tion:

    This function returns a bit position of the least significant
    bit set in the passed ULONGLONG parameter. Passed parameter
    must be non-zero.

--*/
{
    ULONG   bitno;

    for (bitno=0; !(Set & 0xFF); bitno += 8, Set >>= 8) ;
    return FindFirstSetRight[Set & 0xFF] + bitno;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\pat.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pat.c

Abstract:

    WinDbg Extension Api

Author:

    Shivnandan Kaushik Aug 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#pragma hdrstop

//
// PAT MSR architecture definitions
//

//
// PAT model specific register
//

#define PAT_MSR       0x277

//
// PAT memory attributes
//

#define PAT_TYPE_STRONG_UC  0       // corresponds to PPro PCD=1,PWT=1
#define PAT_TYPE_USWC       1
#define PAT_TYPE_WT         4
#define PAT_TYPE_WP         5
#define PAT_TYPE_WB         6
#define PAT_TYPE_WEAK_UC    7       // corresponds to PPro PCD=1,PWT=0
#define PAT_TYPE_MAX        8       

#include "pshpack1.h"

typedef union _PAT {
    struct {
        UCHAR Pat[8];
    } hw;
    ULONGLONG   QuadPart;
} PAT, *PPAT;

#include "poppack.h"

//
// ----------------------------------------------------------------
//

DECLARE_API( pat )

/*++

Routine Description:

    Dumps processors pat

Arguments:

    args - none

Return Value:

    None

--*/
{
    static PUCHAR Type[] = {
    //  0         1           2            3            4       
    "STRONG_UC","USWC     ","????     ","????     ","WT       ",
    //  5         6           7
    "WP       ","WB       ","WEAK_UC  "};
    PAT     Attributes;
    ULONG   i;
    PUCHAR  p;
    ULONG   fb;
    ULONG   Index;

    //
    // Quick sanity check
    //
    
    // X86_ONLY_API
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!pat is X86 only API.\n");
        return E_INVALIDARG;
    }

    i = (ULONG) GetExpression(args);

    if (i != 1) {
        i = (ULONG) GetExpression("KeFeatureBits");
        if (!i) {
            dprintf ("KeFeatureBits not found\n");
            return E_INVALIDARG;
        }

        fb = 0;
        ReadMemory(i, &fb, sizeof(i), &i);
        if (fb == -1  ||  !(fb & KF_PAT_X86)) {
            dprintf ("PAT feature not present\n");
            return E_INVALIDARG;
        }
    }

    //
    // Dump PAT
    //

    ReadMsr(PAT_MSR, &Attributes.QuadPart);

    dprintf("PAT_Index PCD PWT     Memory Type\n");
    for (Index = 0; Index < 8; Index++) {
        p = "????";
        if (Attributes.hw.Pat[Index] < PAT_TYPE_MAX) {
            p = Type[Attributes.hw.Pat[Index]];
        }
        dprintf("%d         %d   %d       %s\n",(Index/4)%2,
            (Index/2)%2,Index%2,p);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\openhci.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Openhci.c

Abstract:

    WinDbg Extension Api

Author:

    Kenneth D. Ray (kenray) June 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

#define PRINT_FLAGS(value, flag) \
    if ((value) & (flag)) { \
        dprintf (#flag " "); \
    }

#define PRINT_VALUE(value)       \
        case (value):           \
            dprintf(#value);    \
            break;

#define InitTypeReadCheck(Addr, Type)                \
    if (GetShortField(Addr, "openhci!" #Type, 1)) {  \
        dprintf("Cannot read %s at %p\n", Addr);     \
        return;                                      \
    }


VOID
DevExtOpenHCI(
    ULONG64 MemLocPtr
    )
{
    ULONG64         MemLoc = MemLocPtr;
    ULONG           result;
    ULONG           i;
    ULONG64         TrueDeviceExtension;
    ULONG           HcFlags, Sz;
    ULONG64         EDList;

    dprintf ("Dump OpenHCI Extension: %p\n", MemLoc);

    if (!ReadPointer (MemLoc, &TrueDeviceExtension)) {
        dprintf ("Could not read Usbd Extension\n");
        return;
    }

    if (0 != TrueDeviceExtension) {
        MemLoc = TrueDeviceExtension;
    }

    InitTypeReadCheck(MemLoc, HCD_DEVICE_DATA);
    
//    dprintf ("DebugLevel (& %x = %x) DeviceNameHandle %x \n",
//             MemLoc + FIELD_OFFSET (HCD_DEVICE_DATA, DebugLevel),
    dprintf ("DebugLevel (%x) DeviceNameHandle %x \n",
             (ULONG) ReadField(DebugLevel),
             (ULONG) ReadField(DeviceNameHandle));

    dprintf ("\n");
    dprintf ("HcFlags %x:  ", HcFlags = (ULONG) ReadField(HcFlags));
    PRINT_FLAGS (HcFlags, HC_FLAG_REMOTE_WAKEUP_CONNECTED);
    PRINT_FLAGS (HcFlags, HC_FLAG_LEGACY_BIOS_DETECTED);
    PRINT_FLAGS (HcFlags, HC_FLAG_SLOW_BULK_ENABLE);
    PRINT_FLAGS (HcFlags, HC_FLAG_SHUTDOWN);
    PRINT_FLAGS (HcFlags, HC_FLAG_MAP_SX_TO_D3);
    PRINT_FLAGS (HcFlags, HC_FLAG_IDLE);
    PRINT_FLAGS (HcFlags, HC_FLAG_DISABLE_IDLE_CHECK);
    PRINT_FLAGS (HcFlags, HC_FLAG_DEVICE_STARTED);
    PRINT_FLAGS (HcFlags, HC_FLAG_LOST_POWER);
    PRINT_FLAGS (HcFlags, HC_FLAG_DISABLE_IDLE_MODE);
    PRINT_FLAGS (HcFlags, HC_FLAG_USE_HYDRA_HACK);
    PRINT_FLAGS (HcFlags, HC_FLAG_LIST_FIX_ENABLE);
    PRINT_FLAGS (HcFlags, HC_FLAG_HUNG_CHECK_ENABLE);
    dprintf ("\n");

    dprintf ("Adapter   %8x MapRegisters %8x Interrupt %x\n"
             "HC        %8x HCCA         %8x HcDma %x\n"
             "Free Desc %8x PageList (& %x)\n",
             (ULONG) ReadField(AdapterObject),
             (ULONG) ReadField(NumberOfMapRegisters),
             (ULONG) ReadField(InterruptObject),
             (ULONG) ReadField(HC),
             (ULONG) ReadField(HCCA),
             (ULONG) ReadField(HcDma),
             (ULONG) ReadField(FreeDescriptorList),
             (ULONG) ReadField(PageList));

    dprintf ("\n");
/*    
    dprintf ("StalledEDReclamation & %x = (%x %x) \n",
             "RunningEDReclamation & %x = (%x %x) \n",
             "PausedEDRestart      & %x = (%x %x) \n",
             "ActiveEndpointList   & %x = (%x %x) \n",
             MemLoc + FIELD_OFFSET (HCD_DEVICE_DATA, StalledEDReclamation),
             (ULONG) ReadField(StalledEDReclamation.Flink),
             (ULONG) ReadField(StalledEDReclamation.Blink),
             MemLoc + FIELD_OFFSET (HCD_DEVICE_DATA, RunningEDReclamation),
             (ULONG) ReadField(RunningEDReclamation.Flink),
             (ULONG) ReadField(RunningEDReclamation.Blink),
             MemLoc + FIELD_OFFSET (HCD_DEVICE_DATA, PausedEDRestart),
             (ULONG) ReadField(PausedEDRestart.Flink),
             (ULONG) ReadField(PausedEDRestart.Blink),
             MemLoc + FIELD_OFFSET (HCD_DEVICE_DATA, ActiveEndpointList),
             (ULONG) ReadField(ActiveEndpointList.Flink),
             (ULONG) ReadField(ActiveEndpointList.Blink));*/
    dprintf ("StalledEDReclamation = (%p %p) \n",
             "RunningEDReclamation = (%p %p) \n",
             "PausedEDRestart      = (%p %p) \n",
             "ActiveEndpointList   = (%p %p) \n",
             ReadField(StalledEDReclamation.Flink),
             ReadField(StalledEDReclamation.Blink),
             ReadField(RunningEDReclamation.Flink),
             ReadField(RunningEDReclamation.Blink),
             ReadField(PausedEDRestart.Flink),
             ReadField(PausedEDRestart.Blink),
             ReadField(ActiveEndpointList.Flink),
             ReadField(ActiveEndpointList.Blink));

    dprintf ("EDList ");
    Sz = GetTypeSize("HCD_ED_LIST");
    EDList = ReadField(EDList[0]);
    for (i = 0; i < NO_ED_LISTS; i++) {
        ULONG64 tmp;

        ReadPointer(EDList + i*Sz, &tmp);
        dprintf ("%p ", tmp);
        if ((i & 3) == 3) {
            dprintf ("\n       ");
        }
    }
    dprintf ("\n");

    dprintf ("CurrentHCControl %x, ListEnablesAtNextSOF %x\n\n"
             "OrigInt %8x FrameHigh    %8x AvailBW      %8x MaxBW %8x\n",
             (ULONG) ReadField(CurrentHcControl),
             (ULONG) ReadField(ListEnablesAtNextSOF),
             (ULONG) ReadField(OriginalInterval),
             (ULONG) ReadField(FrameHighPart),
             (ULONG) ReadField(AvailableBandwidth),
             (ULONG) ReadField(MaxBandwidthInUse));

    dprintf ("\n");
    dprintf ("LostDoneHeadCount %d ResurrectHCCount %d\n"
             "FrozenHcDoneHead %8x LastHccaDoneHead %8x\n"
             "Last Idle Time  %8x IdleTime      %8x \n"
             "InterruptShare %x\n",
             (ULONG) ReadField(LostDoneHeadCount),
             (ULONG) ReadField(ResurrectHCCount),
             (ULONG) ReadField(FrozenHcDoneHead),
             (ULONG) ReadField(LastHccaDoneHead),
             (ULONG) ReadField(LastIdleTime),
             (ULONG) ReadField(IdleTime),
             (ULONG) ReadField(InterruptShare));

    dprintf ("\n");
    dprintf ("RHCtrl             %8x RHInt          %8x RHAddr   %8x \n"
             "RHPortsSusp        %8x RHPortsEnabled %8x\n"
             "CurrentPowerState  %8x RHConfig       %8x\n"
             "NumPorts           %8x ZLEndpointAddr %8x\n",
             (ULONG) ReadField(RootHubControl),
             (ULONG) ReadField(RootHubInterrupt),
             (ULONG) ReadField(RootHubAddress),
             (ULONG) ReadField(PortsSuspendedAtSuspend),
             (ULONG) ReadField(PortsEnabledAtSuspend),
             (ULONG) ReadField(CurrentDevicePowerState),
             (ULONG) ReadField(RootHubConfig),
             (ULONG) ReadField(NumberOfPorts),
             (ULONG) ReadField(ZeroLoadEndpoint_AddrHolder));

    dprintf ("VendorID %x DeviceID %x RevID %x\n",
             (ULONG) ReadField(VendorID),
             (ULONG) ReadField(DeviceID),
             (ULONG) ReadField(RevisionID));

    dprintf ("\n");
}

VOID
OhciHcdTd (
    ULONG64 MemLoc
    )
{
    InitTypeReadCheck(MemLoc, HCD_TRANSFER_DESCRIPTOR);

    dprintf ("OhciHcdTD %p: %x %x %x %x\n"
             "Packet & %x PhysAddr %x\n",
             MemLoc,
             (ULONG) ReadField(HcTD.Control),
             (ULONG) ReadField(HcTD.CBP),
             (ULONG) ReadField(HcTD.NextTD),
             (ULONG) ReadField(HcTD.BE),
             (ULONG) ReadField(HcTD.Packet),
             (ULONG) ReadField(PhysicalAddress));

//    dprintf ("ReqList & %x = (%x, %x)\n",
//             MemLoc + FIELD_OFFSET (HCD_TRANSFER_DESCRIPTOR, RequestList),
    dprintf ("ReqList = (%p, %p)\n",
             ReadField(RequestList.Flink),
             ReadField(RequestList.Blink));
    dprintf ("Next HcdTd     %x UsbdReq   %x Endpoint %x TransferCount %x\n"
             "BaseIsocOffset %x Cancelled %x Flags    %x",
             (ULONG) ReadField(NextHcdTD),
             (ULONG) ReadField(UsbdRequest),
             (ULONG) ReadField(Endpoint),
             (ULONG) ReadField(TransferCount),
             (ULONG) ReadField(BaseIsocURBOffset),
             (ULONG) ReadField(Canceled),
             (ULONG) ReadField(Flags));
}


VOID
OhciHcdEd (
    ULONG64 MemLoc
    )
{
    InitTypeReadCheck(MemLoc, HCD_ENDPOINT_DESCRIPTOR);

    dprintf ("OhciHcED %p: %x %x %x %x\n"
             "PhysicalAddress %x Link = (%x %x)\n",
             MemLoc,
             (ULONG) ReadField(HcED.Control),
             (ULONG) ReadField(HcED.TailP),
             (ULONG) ReadField(HcED.HeadP),
             (ULONG) ReadField(HcED.NextED),
             (ULONG) ReadField(PhysicalAddress),
//             MemLoc + FIELD_OFFSET (HCD_ENDPOINT_DESCRIPTOR, Link),
             (ULONG) ReadField(Link.Flink),
             (ULONG) ReadField(Link.Blink));

    dprintf ("Endpoint %x RecFram %x ListIndex %x Paused %x Flags %x\n",
             (ULONG) ReadField(Endpoint),
             (ULONG) ReadField(ReclamationFrame),
             (ULONG) ReadField(ListIndex),
             (ULONG) ReadField(PauseFlag),
             (ULONG) ReadField(Flags));

//    dprintf ("PausedLink & %x = (%x %x)\n",
//             MemLoc + FIELD_OFFSET (HCD_ENDPOINT_DESCRIPTOR, PausedLink),
    dprintf ("PausedLink = (%p %p)\n",
             ReadField(PausedLink.Flink),
             ReadField(PausedLink.Blink));
}

VOID
OhciEndpoint (
    ULONG64 MemLoc
    )
{
    InitTypeReadCheck(MemLoc, HCD_ENDPOINT);

    dprintf ("Endpoint %p\n", MemLoc);

    dprintf ("Sig %x HcdED %x Head %x Tail %x EpFlags %x Rate %x\n",
             (ULONG) ReadField(Sig),
             (ULONG) ReadField(HcdED),
             (ULONG) ReadField(HcdHeadP),
             (ULONG) ReadField(HcdTailP),
             (ULONG) ReadField(EpFlags),
             (ULONG) ReadField(Rate));

    dprintf ("RequestQueue = (%p %p)\n"
             "EndpointListEntry = (%p %p)\n",
//             MemLoc + FIELD_OFFSET (HCD_ENDPOINT, RequestQueue),
             ReadField(RequestQueue.Flink),
             ReadField(RequestQueue.Blink),
//             MemLoc + FIELD_OFFSET (HCD_ENDPOINT, EndpointListEntry),
             ReadField(EndpointListEntry.Flink),
             ReadField(EndpointListEntry.Blink));

    dprintf ("EndStatus %x  MaxReq %x   Type %x  ListInd %x  BW %x\n"
             "DeviceData %x DescResv %x Close %x BootedBW %x NextIsoFree %x\n"
             "MaxTrans %x   TrueTail %x AbortIrp %x\n",
             (ULONG) ReadField(EndpointStatus),
             (ULONG) ReadField(MaxRequest),
             (ULONG) ReadField(Type),
             (ULONG) ReadField(ListIndex),
             (ULONG) ReadField(Bandwidth),
             (ULONG) ReadField(DeviceData),
             (ULONG) ReadField(DescriptorsReserved),
             (ULONG) ReadField(Closing),
             (ULONG) ReadField(BootedForBandwidth),
             (ULONG) ReadField(NextIsoFreeFrame),
             (ULONG) ReadField(MaxTransfer),
             (ULONG) ReadField(TrueTail),
             (ULONG) ReadField(AbortIrp));
}

VOID
OhciHCRegisters(
    ULONG64   MemLoc
)
{
    ULONG                   HcInterruptStatus, HcInterruptEnable,HcInterruptDisable, HcRhStatus;
    ULONG                   i, NumberDownstreamPorts, Stat[20];

    InitTypeReadCheck(MemLoc, HC_OPERATIONAL_REGISTER);

    dprintf("\n");
    dprintf("Revision %x\n", (ULONG) ReadField(HcRevision.Rev));

    dprintf("Control: CBSR %2x: ",
            (ULONG) ReadField(HcControl.ControlBulkServiceRatio));

    switch ((ULONG) ReadField(HcControl.ControlBulkServiceRatio))
    {
        PRINT_VALUE(HcCtrl_CBSR_1_to_1);
        PRINT_VALUE(HcCtrl_CBSR_2_to_1);
        PRINT_VALUE(HcCtrl_CBSR_3_to_1);
        PRINT_VALUE(HcCtrl_CBSR_4_to_1);
    }

    dprintf("\n");
    dprintf("         PLE:  %1x IE:  %1x CLE: %1x BLE: %1x\n"
            "         HCFS %2x: ",
            (ULONG) ReadField(HcControl.PeriodicListEnable),
            (ULONG) ReadField(HcControl.IsochronousEnable),
            (ULONG) ReadField(HcControl.ControlListEnable),
            (ULONG) ReadField(HcControl.BulkListEnable),
            (ULONG) ReadField(HcControl.HostControllerFunctionalState));

    switch((ULONG) ReadField(HcControl.HostControllerFunctionalState))
    {
        PRINT_VALUE(HcHCFS_USBReset);
        PRINT_VALUE(HcHCFS_USBResume);
        PRINT_VALUE(HcHCFS_USBOperational);
        PRINT_VALUE(HcHCFS_USBSuspend);
    }

    dprintf("\n");
    dprintf("         IR:  %1x RWC: %1x RWE: %1x\n",
            (ULONG) ReadField(HcControl.InterruptRouting),
            (ULONG) ReadField(HcControl.RemoteWakeupConnected),
            (ULONG) ReadField(HcControl.RemoteWakeupEnable));

    dprintf("\n");
    dprintf("Command Status: HCR: %x CLF: %x BLF: %x OCR: %x SOC: %2x\n",
            (ULONG) ReadField(HcCommandStatus.HostControllerReset),
            (ULONG) ReadField(HcCommandStatus.ControlListFilled),
            (ULONG) ReadField(HcCommandStatus.BulkListFilled),
            (ULONG) ReadField(HcCommandStatus.OwnershipChangeRequest),
            (ULONG) ReadField(HcCommandStatus.SchedulingOverrunCount));

    dprintf("\n");
    dprintf("Interrupt Status  %08x: ",
            HcInterruptStatus = (ULONG) ReadField(HcInterruptStatus));

    PRINT_FLAGS(HcInterruptStatus, HcInt_SchedulingOverrun);
    PRINT_FLAGS(HcInterruptStatus, HcInt_WritebackDoneHead);
    PRINT_FLAGS(HcInterruptStatus, HcInt_StartOfFrame);
    PRINT_FLAGS(HcInterruptStatus, HcInt_ResumeDetected);
    PRINT_FLAGS(HcInterruptStatus, HcInt_UnrecoverableError);
    PRINT_FLAGS(HcInterruptStatus, HcInt_FrameNumberOverflow);
    PRINT_FLAGS(HcInterruptStatus, HcInt_RootHubStatusChange);
    PRINT_FLAGS(HcInterruptStatus, HcInt_OwnershipChange);
    PRINT_FLAGS(HcInterruptStatus, HcInt_MasterInterruptEnable);

    dprintf("\n");
    dprintf("Interrupt Enable  %08x: ",
            HcInterruptEnable = (ULONG) ReadField(HcInterruptEnable));

    PRINT_FLAGS(HcInterruptEnable, HcInt_SchedulingOverrun);
    PRINT_FLAGS(HcInterruptEnable, HcInt_WritebackDoneHead);
    PRINT_FLAGS(HcInterruptEnable, HcInt_StartOfFrame);
    PRINT_FLAGS(HcInterruptEnable, HcInt_ResumeDetected);
    PRINT_FLAGS(HcInterruptEnable, HcInt_UnrecoverableError);
    PRINT_FLAGS(HcInterruptEnable, HcInt_FrameNumberOverflow);
    PRINT_FLAGS(HcInterruptEnable, HcInt_RootHubStatusChange);
    PRINT_FLAGS(HcInterruptEnable, HcInt_OwnershipChange);
    PRINT_FLAGS(HcInterruptEnable, HcInt_MasterInterruptEnable);

    dprintf("\n");
    dprintf("Interrupt Disable %08x: ",
            HcInterruptDisable = (ULONG) ReadField(HcInterruptDisable));

    PRINT_FLAGS(HcInterruptDisable, HcInt_SchedulingOverrun);
    PRINT_FLAGS(HcInterruptDisable, HcInt_WritebackDoneHead);
    PRINT_FLAGS(HcInterruptDisable, HcInt_StartOfFrame);
    PRINT_FLAGS(HcInterruptDisable, HcInt_ResumeDetected);
    PRINT_FLAGS(HcInterruptDisable, HcInt_UnrecoverableError);
    PRINT_FLAGS(HcInterruptDisable, HcInt_FrameNumberOverflow);
    PRINT_FLAGS(HcInterruptDisable, HcInt_RootHubStatusChange);
    PRINT_FLAGS(HcInterruptDisable, HcInt_OwnershipChange);
    PRINT_FLAGS(HcInterruptDisable, HcInt_MasterInterruptEnable);

    dprintf("\n");
    dprintf("HCCA:          %08x   PeriodCurrentED:  %08x\n"
            "ControlHeadED: %08x   ControlCurrentED: %08x\n"
            "BulkHeadED:    %08x   BulkCurrentED:    %08x\n"
            "HcDoneHead:    %08x\n",
            (ULONG) ReadField(HcHCCA),
            (ULONG) ReadField(HcPeriodCurrentED),
            (ULONG) ReadField(HcControlHeadED),
            (ULONG) ReadField(HcControlCurrentED),
            (ULONG) ReadField(HcBulkHeadED),
            (ULONG) ReadField(HcBulkCurrentED),
            (ULONG) ReadField(HcDoneHead));

    dprintf("\n");
    dprintf("Frame Interval:  FI: %8x  FSLDP: %8x  FIT: %x\n"
            "Frame Remaining: FR: %8x  FRT:   %8x\n",
            (ULONG) ReadField(HcFmInterval.FrameInterval),
            (ULONG) ReadField(HcFmInterval.FSLargestDataPacket),
            (ULONG) ReadField(HcFmInterval.FrameIntervalToggle),
            (ULONG) ReadField(HcFmRemaining.FrameRemaining),
            (ULONG) ReadField(HcFmRemaining.FrameRemainingToggle));

    dprintf("\n");
    dprintf("HcFmNumber: %x  HcPeriodicStart: %x  HcLSThreshold: %x\n",
            (ULONG) ReadField(HcFmNumber),
            (ULONG) ReadField(HcPeriodicStart),
            (ULONG) ReadField(HcLSThreshold));

    dprintf("\n");
    dprintf("RH Desc A: NDS: %d  PSM: %x  NPS: %x  OCPM: %x  NOP: %x  POTPGT: %d\n",
            (ULONG) ReadField(HcRhDescriptorA.NumberDownstreamPorts),
            (ULONG) ReadField(HcRhDescriptorA.PowerSwitchingMode),
            (ULONG) ReadField(HcRhDescriptorA.NoPowerSwitching),
            (ULONG) ReadField(HcRhDescriptorA.OverCurrentProtectionMode),
            (ULONG) ReadField(HcRhDescriptorA.NoOverCurrentProtection),
            (ULONG) ReadField(HcRhDescriptorA.PowerOnToPowerGoodTime));

    dprintf("RH Desc B: DeviceRemovableMask: %x   PortPowerControlMask: %x\n",
            (ULONG) ReadField(HcRhDescriptorB.DeviceRemovableMask),
            (ULONG) ReadField(HcRhDescriptorB.PortPowerControlMask));

    dprintf("RH Status (%08x): ", HcRhStatus = (ULONG) ReadField(HcRhStatus));
    PRINT_FLAGS(HcRhStatus, HcRhS_LocalPowerStatus);
    PRINT_FLAGS(HcRhStatus, HcRhS_OverCurrentIndicator);
    PRINT_FLAGS(HcRhStatus, HcRhS_DeviceRemoteWakeupEnable);
    PRINT_FLAGS(HcRhStatus, HcRhS_LocalPowerStatusChange);
    PRINT_FLAGS(HcRhStatus, HcRhS_OverCurrentIndicatorChange);

    dprintf("\n");
    dprintf("RH PortStatus: \n");
    NumberDownstreamPorts = (ULONG) ReadField(HcRhDescriptorA.NumberDownstreamPorts);
    GetFieldValue(MemLoc, "openhci!HC_OPERATIONAL_REGISTER", "HcRhPortStatus", Stat);
    
    for (i = 0; i < NumberDownstreamPorts; i++)
    {
        dprintf("Port %2d  (%08x): ", i, Stat[i]);

        PRINT_FLAGS(Stat[i], HcRhPS_CurrentConnectStatus);
        PRINT_FLAGS(Stat[i], HcRhPS_PortEnableStatus);
        PRINT_FLAGS(Stat[i], HcRhPS_PortSuspendStatus);
        PRINT_FLAGS(Stat[i], HcRhPS_PortOverCurrentIndicator);
        PRINT_FLAGS(Stat[i], HcRhPS_PortResetStatus);
        PRINT_FLAGS(Stat[i], HcRhPS_PortPowerStatus);
        PRINT_FLAGS(Stat[i], HcRhPS_LowSpeedDeviceAttached);
        PRINT_FLAGS(Stat[i], HcRhPS_ConnectStatusChange);
        PRINT_FLAGS(Stat[i], HcRhPS_PortEnableStatusChange);
        PRINT_FLAGS(Stat[i], HcRhPS_PortSuspendStatusChange);
        PRINT_FLAGS(Stat[i], HcRhPS_OverCurrentIndicatorChange);
        PRINT_FLAGS(Stat[i], HcRhPS_PortResetStatusChange);

        dprintf("\n");
    }

    return;
}

VOID
OhciHCCA(
    ULONG64   MemLoc
)
{
    ULONG       Table[32];
    ULONG       i;

    InitTypeReadCheck(MemLoc, "HCCA_BLOCK");

    dprintf("\n");

    GetFieldValue(MemLoc, "openhci!HCCA_BLOCK", "HccaInterruptTable", Table);
    for (i = 0; i < 32; i += 2)
    {
        dprintf("HccaInterruptTable[%2d]: %x, HccaInterruptTable[%2d]: %x\n",
                i,
                Table[i],
                i+1,
                Table[i+1]);
    }

    dprintf("HccaFrameNumber: %08x   HccaDoneHead: %08x\n",
            ReadField(HccaFrameNumber),
            ReadField(HccaDoneHead));

    return;
}

VOID
OhciHcEd(
    ULONG64   MemLoc
)
{
    ULONG                   Direction;

    InitTypeReadCheck(MemLoc, HC_ENDPOINT_DESCRIPTOR);

    dprintf("\n");
    dprintf("Endpoint Control:  FA: %3d  EPNum: %3d  Dir: %2x: ",
            (ULONG) ReadField(FunctionAddress),
            (ULONG) ReadField(EndpointNumber),
            Direction = (ULONG) ReadField(Direction));

    switch(Direction)
    {
        PRINT_VALUE(HcEDDirection_Defer);
        PRINT_VALUE(HcEDDirection_In);
        PRINT_VALUE(HcEDDirection_Out);

        default:
            dprintf("Unknown HcED direction");
    }
    dprintf("\n");

    dprintf("                   LS: %3x  sKip:  %3x  Iso: %2x\n"
            "                  MPS: 0x%x\n",
            (ULONG) ReadField(LowSpeed),
            (ULONG) ReadField(sKip),
            (ULONG) ReadField(Isochronous),
            (ULONG) ReadField(MaxPacket));

    dprintf("\n");
    dprintf("TailP: %08x     HeadP: %08x      NextED: %08x\n",
            (ULONG) ReadField(TailP),
            (ULONG) ReadField(HeadP),
            (ULONG) ReadField(NextED));

    return;
}

VOID
OhciHcTd(
    ULONG64   MemLoc
)
{
    ULONG                   Packet[16];
    ULONG                   i;

    InitTypeReadCheck(MemLoc, HC_TRANSFER_DESCRIPTOR);

    dprintf("\n");

    if ((ULONG) ReadField(IsochFlag))
    {
        dprintf("Iso TD: StartFrame: %x     FrameCount: %d\n",
                (ULONG) ReadField(StartingFrame),
                (ULONG) ReadField(FrameCount));

    }
    else
    {
        dprintf("Non-Iso TD: ShortXferOk: %x\n"
                "            Dir:         %2x: ",
                (ULONG) ReadField(ShortXferOk),
                (ULONG) ReadField(Direction));

        switch((ULONG) ReadField(Direction))
        {
            PRINT_VALUE(HcTDDirection_Setup);
            PRINT_VALUE(HcTDDirection_In);
            PRINT_VALUE(HcTDDirection_Out);

            default:
                dprintf("Unknown HcTD direction");
        }
        dprintf("\n");

        dprintf("            IntDelay     %x: ",
                (ULONG) ReadField(IntDelay));

        switch ((ULONG) ReadField(IntDelay))
        {
            PRINT_VALUE(HcTDIntDelay_0ms);
            PRINT_VALUE(HcTDIntDelay_1ms);
            PRINT_VALUE(HcTDIntDelay_2ms);
            PRINT_VALUE(HcTDIntDelay_3ms);
            PRINT_VALUE(HcTDIntDelay_4ms);
            PRINT_VALUE(HcTDIntDelay_5ms);
            PRINT_VALUE(HcTDIntDelay_6ms);
            PRINT_VALUE(HcTDIntDelay_NoInterrupt);
        }
        dprintf("\n");


        dprintf("            Toggle:      %x",
                (ULONG) ReadField(Toggle));

        switch ((ULONG) ReadField(Toggle))
        {
            PRINT_VALUE(HcTDToggle_FromEd);
            PRINT_VALUE(HcTDToggle_Data0);
            PRINT_VALUE(HcTDToggle_Data1);

            default:
                dprintf("Unknown HcTD value");
        }
        dprintf("\n");

        dprintf("            ErrorCount:  %d",
                (ULONG) ReadField(ErrorCount));

        dprintf("            ConditionCode: %x",
                (ULONG) ReadField(ConditionCode));

        switch ((ULONG) ReadField(ConditionCode))
        {
            PRINT_VALUE(HcCC_NoError);
            PRINT_VALUE(HcCC_CRC);
            PRINT_VALUE(HcCC_BitStuffing);
            PRINT_VALUE(HcCC_DataToggleMismatch);
            PRINT_VALUE(HcCC_Stall);
            PRINT_VALUE(HcCC_DeviceNotResponding);
            PRINT_VALUE(HcCC_PIDCheckFailure);
            PRINT_VALUE(HcCC_UnexpectedPID);
            PRINT_VALUE(HcCC_DataOverrun);
            PRINT_VALUE(HcCC_DataUnderrun);
            PRINT_VALUE(HcCC_BufferOverrun);
            PRINT_VALUE(HcCC_BufferUnderrun);
            PRINT_VALUE(HcCC_NotAccessed);

            default:
                dprintf("Unknown HcCC value");
        }
        dprintf("\n");
    }

    dprintf("CBP: %8x  NextTD: %8x  BE: %8x\n",
            (ULONG) ReadField(CBP),
            (ULONG) ReadField(NextTD),
            (ULONG) ReadField(BE));

    GetFieldValue(MemLoc, "openhci!HC_TRANSFER_DESCRIPTOR", "Packet", Packet);
    for (i = 0; i < 8; i += 2)
    {
        dprintf("PSW %d: %4x    PSW %d: %4x\n",
                i,
                Packet[i],
                i+1,
                Packet[i+1]);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\pic.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pic.c

Abstract:

    WinDbg Extension Api

Author:

    Santosh Jodh (santoshj) 29-June-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define PIC_MASTER_PORT0    0x20
#define PIC_MASTER_PORT1    0x21

#define PIC_SLAVE_PORT0     0xA0
#define PIC_SLAVE_PORT1     0xA1

#define ELCR_PORT0          0x4D0
#define ELCR_PORT1          0x4D1


VOID
ShowMask (
    ULONG  Mask
    )
{
    ULONG interrupt;
    
    for (   interrupt = 0;
            interrupt <= 0x0F;
            interrupt++)
    {
        if (Mask & (1 << interrupt))        
            dprintf("  Y");                    
        else
            dprintf("  .");
    }
    
    dprintf("\n");
}

BOOLEAN
GetPICStatus (
    UCHAR   Type,
    PULONG  Status
    )
{
    ULONG   size;
    ULONG   data;
    ULONG   mask;
    
    //
    // Send OCW3 to master.
    //
    
    size = 1;
    WriteIoSpace64(PIC_MASTER_PORT0, Type, &size);

    //
    // Read master's status.
    //
    
    data = 0;
    size = 1;
    ReadIoSpace64(PIC_MASTER_PORT0, &data, &size);
    if (size == 1)
    {
        //
        // Send OCW3 to slave.
        //
        
        mask = data;
        size = 1;
        WriteIoSpace64(PIC_SLAVE_PORT0, Type, &size);

        //
        // Get the slave's status.
        //
        
        data = 0;
        size = 1;
        ReadIoSpace64(PIC_SLAVE_PORT0, &data, &size);
        if (size == 1)
        {
            mask |= (data << 8);
            *Status = mask;

            return (TRUE);
        }
    }

    *Status = 0;
    
    return (FALSE);
}

BOOLEAN
GetELCRStatus(
    OUT PULONG Status
    )
{

    ULONG   data = 0;
    ULONG   size = 1;
    ULONG   mask = 0;

    *Status = 0;
     
    ReadIoSpace64(ELCR_PORT0, &data, &size);

    if (size == 1) {

        mask = data;

        ReadIoSpace64(ELCR_PORT1, &data, &size);

        if (size == 1) {

            mask |= (data << 8);
            *Status = mask;

            return TRUE;
        }

    }

    return FALSE;

}


DECLARE_API(pic)

/*++

Routine Description:

    Dumps PIC information.

Input Parameters:

    args - Supplies the options.

Return Value:

    None

--*/

{
    ULONG   data;
    ULONG   size;
    ULONG   mask;
    ULONG64 addr;
    UCHAR   halName[32];
    BOOL    dumpElcr=FALSE;


    // X86_ONLY_API
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!pic is for X86 targets only.\n");
        return E_INVALIDARG;
    }

    if (strcmp(args, "-e")==0) {

        //
        //  Here we trust that the user knows this machine architecture
        //  such that the ELCR exists at these ports.
        //
        dumpElcr = TRUE;

    }else{

        //
        //  Now lets see what HAL we are running. Currently
        //  we can only dump the ELCR mask safely on ACPI (non-apic) machines
        //  as ACPI has defined static ports for this. 
        //
        addr = GetExpression("hal!HalName");
    
        if (addr == 0) {
            dprintf("Unable to use HAL symbols (hal!HalName), please verify symbols.\n");
            return E_INVALIDARG;
        }
    
        if (!xReadMemory(addr, &halName, sizeof(halName))) {
            dprintf("Failed to read HalName from host memory, quitting.\n");
            return E_INVALIDARG;
        }
        
        halName[sizeof(halName)-1] = '\0';
    
        if (strcmp(halName, "ACPI Compatible Eisa/Isa HAL")==0) {
            
            dumpElcr = TRUE;
        }

    }

    //
    // Display the title.
    //
    dprintf("----- IRQ Number ----- 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n");

    //
    // Dump the Interrupt Service Register information.
    //
    dprintf("Physically in service:");
    
    if (GetPICStatus(0x0B, &mask))
    {
        ShowMask(mask);
    }
    else
    {
        dprintf("Error reading PIC!\n");
    }

    //
    // Dump the Interrupt Mask Register information.
    //
    dprintf("Physically masked:    ");

    data = 0;
    size = 1;
    ReadIoSpace64(PIC_MASTER_PORT1, &data, &size);
    if (size == 1)
    {
        mask = data;
        data = 0;
        size = 1;
        ReadIoSpace64(PIC_SLAVE_PORT1, &data, &size);
        if (size == 1)
        {
            mask |= (data << 8);
            ShowMask(mask);    
        }
        else
        {
            dprintf("Error reading PIC!\n");    
        }
    }
    else
    {
        dprintf("Error reading PIC!\n");    
    }

    
    //
    // Dump the Interrupt Request Register information.
    //
    dprintf("Physically requested: ");

    if (GetPICStatus(0x0A, &mask))
    {
        ShowMask(mask);
    }
    else
    {
        dprintf("Error reading PIC!\n");
    }

    
    if (dumpElcr) {
    
        //
        // Dump the Edge/Level Control Register information.
        //
        dprintf("Level Triggered:      ");
        
        if (GetELCRStatus(&mask)) {
    
            ShowMask(mask);
    
        }else{
    
            dprintf("Error reading ELCR!\n");
    
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\object.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    object.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:
 
    Kshitiz K. Sharma (kksharma)
    
    Using debugger type info.

    Daniel Mihai (DMihai)

    Add !htrace - for dumping handle tracing information.
--*/


#include "precomp.h"
#pragma hdrstop

typedef struct _SEGMENT_OBJECT {
    PVOID BaseAddress;
    ULONG TotalNumberOfPtes;
    LARGE_INTEGER SizeOfSegment;
    ULONG NonExtendedPtes;
    ULONG ImageCommitment;
    PVOID ControlArea;
} SEGMENT_OBJECT, *PSEGMENT_OBJECT;

typedef struct _SECTION_OBJECT {
    PVOID StartingVa;
    PVOID EndingVa;
    PVOID Parent;
    PVOID LeftChild;
    PVOID RightChild;
    PSEGMENT_OBJECT Segment;
} SECTION_OBJECT;


typedef ULONG64 (*ENUM_LIST_ROUTINE)(
                                     IN ULONG64 ListEntry,
                                     IN PVOID   Parameter
                                     );


static ULONG64           ObpTypeObjectType      = 0;
static ULONG64           ObpRootDirectoryObject = 0;
static WCHAR             ObjectNameBuffer[ MAX_PATH ];

//
// Object Type Structure
//

typedef struct _OBJECT_TYPE_READ {
    LIST_ENTRY64 TypeList;
    UNICODE_STRING64 Name; 
    ULONG64 DefaultObject;
    ULONG Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG Key;
} OBJECT_TYPE_READ, *POBJECT_TYPE_READ;

BOOLEAN
DumpObjectsForType(
                  IN ULONG64          pObjectHeader,
                  IN PVOID            Parameter
                  );

ULONG64
WalkRemoteList(
              IN ULONG64           Head,
              IN ENUM_LIST_ROUTINE EnumRoutine,
              IN PVOID             Parameter
              );

ULONG64
CompareObjectTypeName(
                     IN ULONG64      ListEntry,
                     IN PVOID        Parameter
                     );

PWSTR
GetObjectName(
             ULONG64 Object
             );


BOOLEAN
GetObjectTypeName(
                  IN UNICODE_STRING64 ustrTypeName,
                  IN ULONG64 lpType,
                  IN OUT WCHAR * wszTypeName
                 );

ULONG64 HighestUserAddress;


DECLARE_API( obtrace )

/*++

Routine Description:

    Dump the object trace information for an object.

Arguments:

    args - [object (pointer/path)]

Return Value:

    None

--*/
{
    ULONG64 ObpObjectTable,
            ObpStackTable,
            ObpObjectBuckets,
            ObpTraceDepth,
            ObpStacksPerObject,
            ObjectToTrace,
            ObjectHash,
            ObjectHeader,
            ObRefInfoPtr,
            ObRefInfoPtrLoc,
            BaseStackInfoAddr,
            Offset,
            TraceAddr,
            Trace;
    ULONG   ObjectHeaderBodyOffset,
            ObStackInfoTypeSize,
            PVoidTypeSize,
            Lupe,
            TraceNumber,
            NextPos,
            CountRef,
            CountDeref,
            BytesRead;
    USHORT  Sequence,
            Index;
    UCHAR   ImageFileName[16],
            FunctionName[256];

    FIELD_INFO ObRefInfoFields[] = {
        {"ObjectHeader",  NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &ObjectHeader},
        {"NextRef",       NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &ObRefInfoPtr},
        {"ImageFileName", NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &ImageFileName},
        {"StackInfo",     NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS,  0, NULL},
        {"NextPos",       NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &NextPos}
    },         ObStackInfoFields[] = {
        {"Sequence",      NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &Sequence},
        {"Index"   ,      NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &Index}
    };

    SYM_DUMP_PARAM ObRefInfo = {
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_REF_INFO", DBG_DUMP_NO_PRINT,
        0, NULL, NULL, NULL, 2, &ObRefInfoFields[0]
    },             ObStackInfo = {
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_REF_STACK_INFO", DBG_DUMP_NO_PRINT,
        0, NULL, NULL, NULL, 2, &ObStackInfoFields[0]
    };

    ObpObjectTable = GetUlongValue("ObpObjectTable");
    ObpStackTable = GetUlongValue("ObpStackTable");
    ObpObjectBuckets = GetUlongValue("ObpObjectBuckets");
    ObpTraceDepth = GetUlongValue("ObpTraceDepth");
    ObpStacksPerObject = GetUlongValue("ObpStacksPerObject");

    if (GetFieldOffset("nt!_OBJECT_HEADER",
                       "Body",
                       &ObjectHeaderBodyOffset)) {
        return E_INVALIDARG;
    }

    ObStackInfoTypeSize = GetTypeSize("nt!_OBJECT_REF_STACK_INFO");
    PVoidTypeSize = IsPtr64() ? 8 : 4;
    
    if (strlen(args) < 1) {
        return E_INVALIDARG;
    }

    if (args[0] == '\\') {
        ObjectToTrace = FindObjectByName((PUCHAR)args, 0);
    } else {
        ObjectToTrace = GetExpression(args);
    }

    if (ObjectToTrace == 0) {
        dprintf("Object %s not found.\n", args);
        return E_INVALIDARG;
    } 

    // ObjectRefChain <= ObpObjectTable[OBTRACE_HASHOBJECT(ObjectToTrace)]
    ObjectHash = ((ObjectToTrace >> 4) & 0xfffff) % (ObpObjectBuckets ? ObpObjectBuckets : 1);
    ObRefInfoPtrLoc = ObpObjectTable + GetTypeSize("nt!POBJECT_REF_INFO") * ObjectHash;

    for (ObRefInfo.addr = GetPointerFromAddress(ObRefInfoPtrLoc);
         ObRefInfo.addr;
         ObRefInfo.addr = ObRefInfoPtr) {

        if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObRefInfo, ObRefInfo.size)) {
            dprintf("Unable to read ObRefInfo %x\n", ObRefInfo.addr);
            return E_INVALIDARG;
        }

        if (ObjectHeader == ObjectToTrace - ObjectHeaderBodyOffset) {
            break;
        }

        if (CheckControlC()) {
            dprintf("Aborting object lookup\n");
            return S_OK;
        }
    }

    if (! ObRefInfo.addr) {
        dprintf("Unable to find object in table.\n");
        return E_INVALIDARG;
    }

    // We need the rest of the fields now
    ObRefInfo.nFields = sizeof(ObRefInfoFields) / sizeof(ObRefInfoFields[0]);
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObRefInfo, ObRefInfo.size)) {
        return E_INVALIDARG;
    }
    BaseStackInfoAddr = ObRefInfoFields[3].address;

    dprintf("Object: %x\n", ObjectToTrace);
    dprintf(" Image: %s\n", ImageFileName);
    dprintf("Seq.  Stack\n");
    dprintf("----  ----------------------------------------------------------\n");

    CountRef = 0;
    CountDeref = 0;

    for (Lupe = 0;
         Lupe < NextPos;
         Lupe++) {

        if (CheckControlC()) {
            return S_OK;
        }

        ObStackInfo.addr = BaseStackInfoAddr + Lupe * ObStackInfoTypeSize;
        if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObStackInfo, ObStackInfo.size)) {
            dprintf("Unable to read ObStackInfo %x\n", ObStackInfo.addr);
            return E_INVALIDARG;
        }

        if (Index & 0x8000) {
            CountRef++;
        } else {
            CountDeref++;
        }

        for (TraceNumber = 0;
             TraceNumber < ObpTraceDepth;
             TraceNumber++) {
            TraceAddr = ObpStackTable
                + (PVoidTypeSize
                   * (ObpTraceDepth * (Index & 0x7fff)
                      + TraceNumber));
            Trace = GetPointerFromAddress(TraceAddr);
            if (Trace) {
                GetSymbol(Trace, FunctionName, &Offset);
                if (TraceNumber == 0) {
                    dprintf("%04x %c",
                            Sequence,
                            Index & 0x8000 ? '+' : ' ');
                } else {
                    dprintf("      "); /* six spaces */
                }
                dprintf("%s+%x\n", FunctionName, Offset);
            }

            if (CheckControlC()) {
                return S_OK;
            }
        }
        dprintf("\n");
    }

    dprintf("----  ----------------------------------------------------------\n");
    dprintf("References: %d, Dereferences %d", CountRef, CountDeref);
    if(CountDeref + CountRef == ObpStacksPerObject) {
        dprintf("  (maximum stacks reached)");
    }
    dprintf("\n");

    return S_OK;
}



DECLARE_API( object )

/*++

Routine Description:

    Dump an object manager object.

Arguments:

    args - [TypeName]

Return Value:

    None

--*/
{
    ULONG64   ObjectToDump;
    char      NameBuffer[ MAX_PATH ];
    ULONG     NumberOfObjects;

    HighestUserAddress = GetNtDebuggerDataValue(MmHighestUserAddress);
    if (!FetchObjectManagerVariables(FALSE)) {
        return E_INVALIDARG;
    }

    ObjectToDump    = EXPRLastDump;
    NameBuffer[ 0 ] = '\0';

    //
    // If the argument looks like a path, try to chase it.
    //

    if (args[0] == '\\') {

        ULONG64 object;

        object = FindObjectByName((PUCHAR) args, 0);

        if (object != 0) {
            DumpObject("", object, 0xffffffff);
        } else {
            dprintf("Object %s not found\n", args);
        }
        return E_INVALIDARG;
    }

    //
    // If the argument is -r or -R, reload the cached symbol information
    //

    if (!strcmp(args, "-r")) {
        FetchObjectManagerVariables(TRUE);
        return E_INVALIDARG;
    }

    if (GetExpressionEx(args,&ObjectToDump, &args)) {
        if (!args || !*args) {
            DumpObject("", ObjectToDump, 0xFFFFFFFF);
            return E_INVALIDARG;
        }
        while (args && (*args == ' ')) { 
            ++args;
        }
    }
    strcpy(NameBuffer, args);

    if (ObjectToDump == 0 && strlen( NameBuffer ) > 0) {
        NumberOfObjects = 0;
        if (WalkObjectsByType( NameBuffer, DumpObjectsForType, &NumberOfObjects )) {
            dprintf( "Total of %u objects of type '%s'\n", NumberOfObjects, NameBuffer );
        }

        return E_INVALIDARG;
    }

    dprintf( "*** invalid syntax.\n" );
    return S_OK;
}



DECLARE_API( obja )

/*++

Routine Description:

    Dump an object's attributes

Arguments:

    args -

Return Value:

    None

--*/
{
    UNICODE_STRING UnicodeString;
    DWORD64 dwAddrObja;
//    OBJECT_ATTRIBUTES Obja;
    DWORD dwAddrString;
    CHAR Symbol[256];
    LPSTR StringData;
    ULONG64 Displacement;
    ULONG64 ObjectName=0, ObjectNameBuffer=0, RootDirectory=0;
    ULONG   Attributes=0;
    BOOL b;

    HighestUserAddress = GetNtDebuggerDataValue(MmHighestUserAddress);

    //
    // Evaluate the argument string to get the address of
    // the Obja to dump.
    //

    dwAddrObja = GetExpression(args);
    if ( !dwAddrObja ) {
        return E_INVALIDARG;
    }


    //
    // Get the symbolic name of the Obja
    //

    GetSymbol(dwAddrObja,Symbol,&Displacement);

    StringData = NULL;
    
    if (GetFieldValue(dwAddrObja, "nt!_OBJECT_ATTRIBUTES", "ObjectName", ObjectName)) {
        return  E_INVALIDARG;
    }
    
    if ( ObjectName ) {
        if ( GetFieldValue(ObjectName, "nt!_UNICODE_STRING", "Length", UnicodeString.Length) ) {
            return E_INVALIDARG;
        }
        GetFieldValue(ObjectName, "nt!_UNICODE_STRING", "Buffer", ObjectNameBuffer);

        StringData = (LPSTR)LocalAlloc(
                                      LMEM_ZEROINIT,
                                      UnicodeString.Length+sizeof(UNICODE_NULL)
                                      );

        b = ReadMemory(
                      ObjectNameBuffer,
                      StringData,
                      UnicodeString.Length,
                      NULL
                      );
        if ( !b ) {
            LocalFree(StringData);
            return E_INVALIDARG;
        }
        UnicodeString.Buffer = (PWSTR)StringData;
        UnicodeString.MaximumLength = UnicodeString.Length+(USHORT)sizeof(UNICODE_NULL);
    }

    //
    // We got the object name in UnicodeString. StringData is NULL if no name.
    //

    dprintf(
           "Obja %s+%p at %p:\n",
           Symbol,
           Displacement,
           dwAddrObja
           );
    if ( StringData ) {
        GetFieldValue(dwAddrObja, "nt!_OBJECT_ATTRIBUTES", "RootDirectory", RootDirectory);
        dprintf("\t%s is %ws\n",
                RootDirectory ? "Relative Name" : "Full Name",
                UnicodeString.Buffer
               );
        LocalFree(StringData);
    }
    
    GetFieldValue(dwAddrObja, "nt!_OBJECT_ATTRIBUTES", "Attributes", Attributes);
    if ( Attributes ) {
        if ( Attributes & OBJ_INHERIT ) {
            dprintf("\tOBJ_INHERIT\n");
        }
        if ( Attributes & OBJ_PERMANENT ) {
            dprintf("\tOBJ_PERMANENT\n");
        }
        if ( Attributes & OBJ_EXCLUSIVE ) {
            dprintf("\tOBJ_EXCLUSIVE\n");
        }
        if ( Attributes & OBJ_CASE_INSENSITIVE ) {
            dprintf("\tOBJ_CASE_INSENSITIVE\n");
        }
        if ( Attributes & OBJ_OPENIF ) {
            dprintf("\tOBJ_OPENIF\n");
        }
    }
    return S_OK;
}

BOOLEAN
DumpObjectsForType(
                  IN ULONG64          pObjectHeader,
                  IN PVOID            Parameter
                  )
{
    ULONG64 Object;
    ULONG   BodyOffset;
    PULONG NumberOfObjects = (PULONG)Parameter;
    
    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset)) {
        return FALSE;
    }
    *NumberOfObjects += 1;
    Object = pObjectHeader + BodyOffset;
    DumpObject( "", Object, 0xFFFFFFFF );
    return TRUE;
}


BOOLEAN
FetchObjectManagerVariables(
                           BOOLEAN ForceReload
                           )
{
    ULONG        Result;
    ULONG64      Addr;
    static BOOL  HaveObpVariables = FALSE;

    if (HaveObpVariables && !ForceReload) {
        return TRUE;
    }

    Addr = GetNtDebuggerData( ObpTypeObjectType );
    if ( !Addr ||
         !ReadPointer( Addr,
                  &ObpTypeObjectType) ) {
        dprintf("%08p: Unable to get value of ObpTypeObjectType\n", Addr );
        return FALSE;
    }

    Addr = GetNtDebuggerData( ObpRootDirectoryObject );
    if ( !Addr ||
         !ReadPointer( Addr,
                  &ObpRootDirectoryObject) ) {
        dprintf("%08p: Unable to get value of ObpRootDirectoryObject\n",Addr );
        return FALSE;
    }

    HaveObpVariables = TRUE;
    return TRUE;
}

ULONG64
FindObjectType(
              IN PUCHAR TypeName
              )
{
    WCHAR NameBuffer[ 64 ];
    FIELD_INFO offField = {"TypeList", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_TYPE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };

    // Get The offset
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        return 0;
    }




    _snwprintf( NameBuffer,
                sizeof( NameBuffer ) / sizeof( WCHAR ),
                L"%hs",
                TypeName
              );
    return WalkRemoteList( ObpTypeObjectType + offField.address,
                           CompareObjectTypeName,
                           NameBuffer
                         );
}




ULONG64
WalkRemoteList(
              IN ULONG64           Head,
              IN ENUM_LIST_ROUTINE EnumRoutine,
              IN PVOID             Parameter
              )
{
    ULONG        Result;
    ULONG64      Element;
    ULONG64      Flink;
    ULONG64      Next;

    if ( GetFieldValue(Head, "nt!_LIST_ENTRY", "Flink", Next)) {
        dprintf( "%08lx: Unable to read list\n", Head );
        return 0;
    }

    while (Next != Head) {

        Element = (EnumRoutine)( Next, Parameter );
        if (Element != 0) {
            return Element;
        }

        if ( CheckControlC() ) {
            return 0;
        }

        if ( GetFieldValue(Next, "nt!_LIST_ENTRY", "Flink", Flink)) {
            dprintf( "%08lx: Unable to read list\n", Next );
            return 0;
        }
        
        Next = Flink;
    }

    return 0;
}



ULONG64
CompareObjectTypeName(
                     IN ULONG64      ListEntry,
                     IN PVOID        Parameter
                     )
{
    ULONG           Result;
    ULONG64         pObjectTypeObjectHeader;
    WCHAR           NameBuffer[ 64 ];
    UNICODE_STRING64 Name64={0};

    ULONG64                     pCreatorInfo;
    ULONG64                     pNameInfo;
    ULONG BodyOffset, TypeListOffset;

    // Get The offset
    if (GetFieldOffset("nt!_OBJECT_HEADER_CREATOR_INFO", "TypeList", &TypeListOffset)) {
        dprintf("Type nt!_OBJECT_HEADER_CREATOR_INFO, field TypeList not found\n");
        return FALSE;
    }

    pCreatorInfo = ListEntry - TypeListOffset;
    pObjectTypeObjectHeader = (pCreatorInfo + GetTypeSize("nt!_OBJECT_HEADER_CREATOR_INFO"));
    
    KD_OBJECT_HEADER_TO_NAME_INFO( pObjectTypeObjectHeader, &pNameInfo);

    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", Name64.Length);
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", Name64.MaximumLength);
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", Name64.Buffer);

    if (Name64.Length > sizeof( NameBuffer )) {
        Name64.Length = sizeof( NameBuffer ) - sizeof( UNICODE_NULL );
    }

    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset)) {
        dprintf("Type nt!_OBJECT_HEADER, field Body not found\n");
        return FALSE;
    }

    if (!GetObjectTypeName(Name64, (pObjectTypeObjectHeader + BodyOffset) , NameBuffer))
    {
        dprintf( "%08p: Unable to read object type name.\n", pObjectTypeObjectHeader );
        return 0;
    }

    NameBuffer[ Name64.Length / sizeof( WCHAR ) ] = UNICODE_NULL;

    if (!_wcsicmp( NameBuffer, (PWSTR)Parameter )) {
        return (pObjectTypeObjectHeader + BodyOffset);
    }

    return 0;
}

typedef struct _OBJECT_HEADER_READ {
    LONG PointerCount;
    LONG HandleCount;
    ULONG64  SEntry;
    ULONG64  Type;
    UCHAR NameInfoOffset;
    UCHAR HandleInfoOffset;
    UCHAR QuotaInfoOffset;
    UCHAR Flags;
    ULONG64 ObjectCreateInfo;
    ULONG64  SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER_READ, *POBJECT_HEADER_READ;

typedef struct OBJECT_HEADER_NAME_INFO_READ {
    ULONG64          Directory;
    UNICODE_STRING64 Name;
} OBJECT_HEADER_NAME_INFO_READ;

typedef struct _OBJECT_INFO {
    ULONG64        pObjectHeader;
    OBJECT_HEADER_READ  ObjectHeader;
    OBJECT_TYPE_READ    ObjectType;
    OBJECT_HEADER_NAME_INFO_READ NameInfo;
    WCHAR          TypeName[ 32 ];
    WCHAR          ObjectName[ 256 ];
    WCHAR          FileSystemName[ 32 ];
    CHAR           Message[ 256 ];
} OBJECT_INFO, *POBJECT_INFO;


//+---------------------------------------------------------------------------
//
//  Function:   GetObjectTypeName
//
//  Synopsis:   Fill in the ObjectTypeName in the ObjectInfo struct
//
//  Arguments:  [Object]     -- object examined used only in an error message
//              [ObjectInfo] -- struct containing object type info that is
//                              modified to include the object type name
//
//  Returns:    TRUE if successful
//
//  History:    12-05-1997   benl   Created
//
//  Notes:      If the name is paged out we try a direct comparison against
//              known object types, this known list is not comprehensive
//
//----------------------------------------------------------------------------

BOOLEAN
GetObjectTypeName(IN UNICODE_STRING64 ustrTypeName, IN ULONG64 lpType,
                  IN OUT WCHAR * wszTypeName)
{
    DWORD   dwResult;
    BOOLEAN fRet = TRUE;
    ULONG64 dwIoFileObjectType = 0;
    ULONG64 dwCmpKeyObjectType = 0;
    ULONG64 dwMmSectionObjectType = 0;
    ULONG64 dwObpDirectoryObjectType = 0;
    ULONG64 dwObpSymbolicLinkObjectType = 0;


    __try
    {
        if (ReadMemory(  ustrTypeName.Buffer,
                         wszTypeName,
                         ustrTypeName.Length,
                         &dwResult
                       )){
            fRet = TRUE;
            __leave;
        }

        //
        // Unable to directly read object type name so try to load the known
        // types directly and compare addresses
        // This is not comprehensive for all object types, if we don't find
        // a match this way - revert to old behavior and fail with a message
        //


        if (!ReadPointer( GetExpression("NT!IoFileObjectType"),
                      &dwIoFileObjectType)) {
            dprintf("Unable to load NT!IoFileObjectType\n");
        } else if (dwIoFileObjectType == lpType) {
            wcscpy(wszTypeName, L"File");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!CmpKeyObjectType"),
                     &dwCmpKeyObjectType)) {
            dprintf("Unable to load NT!CmpKeyObjectType\n");
        } else if (dwCmpKeyObjectType == lpType) {
            wcscpy(wszTypeName, L"Key");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!MmSectionObjectType"),
                     &dwMmSectionObjectType)) {
            dprintf("Unable to load NT!MmSectionObjectType\n");
        } else if (dwMmSectionObjectType == lpType) {
            wcscpy(wszTypeName, L"Section");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!ObpDirectoryObjectType"),
                     &dwObpDirectoryObjectType)) {
            dprintf("Unable to load NT!ObpDirectoryObjectType\n");
        } else if (dwObpDirectoryObjectType == lpType) {
            wcscpy(wszTypeName, L"Directory");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!ObpSymbolicLinkObjectType"),
                      &dwObpDirectoryObjectType)) {
            dprintf("Unable to load NT!ObpSymbolicLinkObjectType\n");
        } else if (dwObpSymbolicLinkObjectType == lpType) {
            wcscpy(wszTypeName, L"SymbolicLink");
            __leave;
        }

        //
        //Fallthrough if type not found
        //
        wszTypeName[0] = L'\0';
        fRet = FALSE;

    } __finally
    {
    }
    return fRet;
} // GetObjectTypeName


BOOLEAN
GetObjectInfo(
             ULONG64 Object,
             POBJECT_INFO ObjectInfo
             )
{
    ULONG           Result;
    ULONG64         pNameInfo;
    BOOLEAN         PagedOut;
    UNICODE_STRING64  ObjectName;
    PWSTR           FileSystemName;
    SECTION_OBJECT  SectionObject;
    SEGMENT_OBJECT  SegmentObject;
    ULONG           BodyOffset;
#define Hdr         ObjectInfo->ObjectHeader
    FIELD_INFO ObjHdrFields[] = {
        {"PointerCount"     , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.PointerCount},
        {"HandleCount"      , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.HandleCount},
        {"SEntry"           , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.SEntry},
        {"Type"             , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RECUR_ON_THIS, 0, (PVOID) &Hdr.Type},
        {"NameInfoOffset"   , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.NameInfoOffset},
        {"HandleInfoOffset" , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.HandleInfoOffset},
        {"QuotaInfoOffset"  , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.QuotaInfoOffset},
        {"Flags"            , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.Flags},
        {"ObjectCreateInfo" , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.ObjectCreateInfo},
        {"SecurityDescriptor","", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.SecurityDescriptor},
    };                                                                           
#undef Hdr
    SYM_DUMP_PARAM ObjSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_HEADER", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, sizeof (ObjHdrFields) / sizeof (FIELD_INFO), &ObjHdrFields[0]
    };

    PagedOut = FALSE;
    memset( ObjectInfo, 0, sizeof( *ObjectInfo ) );

    GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset);

    ObjectInfo->pObjectHeader = (Object - BodyOffset); // (OBJECT_TO_OBJECT_HEADER( Object );
    ObjSym.addr    = ObjectInfo->pObjectHeader;

    if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObjSym, ObjSym.size)) {
    
        if (Object >= HighestUserAddress && (ULONG)Object < 0xF0000000) {
            PagedOut = TRUE;
            return FALSE;
            // Not using Opt Value
            /*
            sprintf( ObjectInfo->Message, "%08lx: object is paged out.", Object );
            if (!ARGUMENT_PRESENT( OptObjectHeader )) {
                return FALSE;
            }
            ObjectInfo->ObjectHeader.Flags = OptObjectHeader->Flags;
            ObjectInfo->ObjectHeader.HandleCount = OptObjectHeader->HandleCount;
            ObjectInfo->ObjectHeader.NameInfoOffset = OptObjectHeader->NameInfoOffset;
            ObjectInfo->ObjectHeader.ObjectCreateInfo = (ULONG64) OptObjectHeader->ObjectCreateInfo;
            ObjectInfo->ObjectHeader.PointerCount = OptObjectHeader->PointerCount;
            ObjectInfo->ObjectHeader.QuotaInfoOffset = OptObjectHeader->QuotaInfoOffset;
            ObjectInfo->ObjectHeader.SecurityDescriptor = (ULONG64) OptObjectHeader->SecurityDescriptor;
            ObjectInfo->ObjectHeader.SEntry = (ULONG64) OptObjectHeader->SEntry;
            ObjectInfo->ObjectHeader.Type = (ULONG64) OptObjectHeader->Type;*/
        } else {
            sprintf( ObjectInfo->Message, "%p: not a valid object (ObjectHeader invalid)", Object );
            return FALSE;
        }
    }

    if (!ObjectInfo->ObjectHeader.Type) {
        sprintf( ObjectInfo->Message, "%08p: Not a valid object (ObjectType invalid)", Object );
        return FALSE;
    }

    GetFieldValue(ObjectInfo->ObjectHeader.Type, "nt!_OBJECT_TYPE", 
                      "Name.Length", ObjectInfo->ObjectType.Name.Length);
    GetFieldValue(ObjectInfo->ObjectHeader.Type, "nt!_OBJECT_TYPE", 
                      "Name.MaximumLength", ObjectInfo->ObjectType.Name.MaximumLength);
    GetFieldValue(ObjectInfo->ObjectHeader.Type, "nt!_OBJECT_TYPE", 
                      "Name.Buffer", ObjectInfo->ObjectType.Name.Buffer);

    if (ObjectInfo->ObjectType.Name.Length > sizeof( ObjectInfo->TypeName )) {
        ObjectInfo->ObjectType.Name.Length = sizeof( ObjectInfo->TypeName ) - sizeof( UNICODE_NULL );
    }

    if (!GetObjectTypeName(ObjectInfo->ObjectType.Name,
                           ObjectInfo->ObjectHeader.Type, ObjectInfo->TypeName))
    {
        sprintf( ObjectInfo->Message, "%p: Not a valid object "
                                      "(ObjectType.Name at 0x%p invalid)",
                                      Object, ObjectInfo->ObjectType.Name.Buffer);
        return FALSE;
    }

    ObjectInfo->TypeName[ ObjectInfo->ObjectType.Name.Length / sizeof( WCHAR ) ] = UNICODE_NULL;

    if (PagedOut) {
        return TRUE;
    }

    if (!wcscmp( ObjectInfo->TypeName, L"File" )) {
        ULONG64 DeviceObject=0;
        
        if (GetFieldValue(Object, "nt!_FILE_OBJECT", "FileName.Buffer", ObjectName.Buffer)) {
            sprintf( ObjectInfo->Message, "%08p: unable to read _FILE_OBJECT for name\n", Object );
        } else {
        
            GetFieldValue(Object, "nt!_FILE_OBJECT", "DeviceObject", DeviceObject);
            GetFieldValue(Object, "nt!_FILE_OBJECT", "FileName.Length", ObjectName.Length);
            GetFieldValue(Object, "nt!_FILE_OBJECT", "FileName.MaximumLength", ObjectName.MaximumLength);
        
            FileSystemName = GetObjectName( DeviceObject );
            if (FileSystemName != NULL) {
                wcscpy( ObjectInfo->FileSystemName, FileSystemName );
            }
        }
    } else if (!wcscmp( ObjectInfo->TypeName, L"Key" )) {
        ULONG64 pKeyControlBlock=0;
        
        if (GetFieldValue(Object, "nt!_CM_KEY_BODY", "KeyControlBlock", pKeyControlBlock)) {
            sprintf( ObjectInfo->Message, "%08p: unable to read key object for name\n", Object );
        } else if (!pKeyControlBlock) {
            sprintf( ObjectInfo->Message, "%08p: unable to read key control block for name\n", pKeyControlBlock );
        } else {
            ObjectName.Length = GetKcbName( pKeyControlBlock,
                                            ObjectInfo->ObjectName,
                                            sizeof( ObjectInfo->ObjectName));
            return TRUE;
        }
    } else {
        FIELD_INFO NameInfoFields[]= {
            {"Name"             , "", 0, DBG_DUMP_FIELD_RECUR_ON_THIS,   0, NULL},
            {"Name.Len",          "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &ObjectInfo->NameInfo.Name.Length},
            {"Name.Max",          "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &ObjectInfo->NameInfo.Name.MaximumLength},
            {"Name.Buf",          "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &ObjectInfo->NameInfo.Name.Buffer},
            {"Directory",         "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &ObjectInfo->NameInfo.Directory},
        };       
          
        if (ObjectInfo->ObjectHeader.NameInfoOffset) {
            pNameInfo = ObjectInfo->pObjectHeader - ObjectInfo->ObjectHeader.NameInfoOffset;
        } else {
            return TRUE;
         }
        ObjSym.addr = pNameInfo; ObjSym.sName = "nt!_OBJECT_HEADER_NAME_INFO";
         ObjSym.nFields = 5; ObjSym.Fields = &NameInfoFields[0];
        if ( InitTypeRead(pNameInfo, nt!_OBJECT_HEADER_NAME_INFO) ) {              
            dprintf( ObjectInfo->Message, "*** unable to read _OBJECT_HEADER_NAME_INFO at %08p\n", pNameInfo );
            return FALSE;
        }

        ObjectInfo->NameInfo.Name.Length = (USHORT) ReadField(Name.Length);   
        ObjectInfo->NameInfo.Name.MaximumLength = (USHORT) ReadField(Name.MaximumLength);
        ObjectInfo->NameInfo.Name.Buffer = ReadField(Name.Buffer);
        ObjectInfo->NameInfo.Directory = ReadField(Directory);

        ObjectName = ObjectInfo->NameInfo.Name;
    }

    if (ObjectName.Length == 0 && !wcscmp( ObjectInfo->TypeName, L"Section" )) {
        ULONG PtrSize = GetTypeSize("nt!PVOID");
        ULONG64 Segment=0;

        //
        // Get Types of SectionObject etc
        //
        //
        // Assumption ptr to section object is 6th pointer value from Object
        //

        if (!GetFieldValue( Object, "nt!_SECTION_OBJECT", "Segment", Segment)) {
            ULONG64 ControlArea=0;
            if (Segment && !GetFieldValue( Segment, "nt!_SEGMENT_OBJECT", "ControlArea", ControlArea)) {
                ULONG64 FilePointer=0;
                if (ControlArea &&
                    !GetFieldValue( Segment, "nt!_CONTROL_AREA", "FilePointer", FilePointer)) {
                    if (FilePointer) {
                        GetFieldValue(FilePointer, "nt!_FILE_OBJECT", "FileName.Length", ObjectName.Length);
                        GetFieldValue(FilePointer, "nt!_FILE_OBJECT", "FileName.Buffer", ObjectName.Buffer);
                        ObjectName.MaximumLength = ObjectName.Length;
                    } else {
                        sprintf( ObjectInfo->Message, "unable to read file object at %08p for section %08p\n",
                                  FilePointer, Object );
                    }
                } else {
                    sprintf( ObjectInfo->Message, "unable to read segment object at %08lp for section %08p\n",
                           ControlArea, Object );
                }

            } else {
                sprintf( ObjectInfo->Message, "unable to read segment object at %08lp for section %08p\n",
                         Segment, Object );
            }
        } else {
            sprintf( ObjectInfo->Message, "unable to read section object at %08lx\n", Object );
        }
    }

    if (ObjectName.Length >= sizeof( ObjectInfo->ObjectName )) {
        ObjectName.Length = sizeof( ObjectInfo->ObjectName ) - sizeof( UNICODE_NULL );
    }

    if (ObjectName.Length != 0) {
        if (!ReadMemory( ObjectName.Buffer,
                         ObjectInfo->ObjectName,
                         ObjectName.Length,
                         &Result
                       )
           ) {
            wcscpy( ObjectInfo->ObjectName, L"(*** Name not accessable ***)" );
        } else {
            ObjectInfo->ObjectName[ ObjectName.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
        }
    }

    return TRUE;
}


ULONG64
FindObjectByName(
                IN PUCHAR  Path,
                IN ULONG64 RootObject
                )
{
    ULONG Result, i, j;
    ULONG64           pDirectoryObject;
    ULONG64           pDirectoryEntry;
    ULONG64           HashBucketsAddress;
    ULONG             HashBucketSz;
    OBJECT_INFO ObjectInfo;
    BOOLEAN foundMatch = FALSE;
    ULONG             HashOffset;
    PUCHAR nextPath;

    if (RootObject == 0) {

        if (!FetchObjectManagerVariables(FALSE)) {
            return 0;
        }

        RootObject = ObpRootDirectoryObject;
    }

    pDirectoryObject = RootObject;

    //
    // See if we've reached the end of the path, at which point we know
    // that RootObject is the object to be dumped.
    //

    if (*Path == '\0') {
        return RootObject;
    }

    //
    // Scan the path looking for another delimiter or for the end of the
    // string.

    nextPath = Path;

    while ((*nextPath != '\0') &&
           (*nextPath != '\\')) {

        nextPath++;
    }

    //
    // if we found a delimeter remove it from the next path and use it to
    // truncate the current path.
    //

    if (*nextPath == '\\') {
        *nextPath = '\0';
        nextPath++;
    }

    //
    // Make sure there's a path node here.  If not, recursively call ourself
    // with the remainder of the path.
    //

    if (*Path == '\0') {
        return FindObjectByName(nextPath, RootObject);
    }

    //
    // Get the address of hashbuckets array and size of the pointer to scan the array
    //
    
    if (GetFieldOffset("nt!_OBJECT_DIRECTORY", "HashBuckets", &HashOffset)) {
        dprintf("Cannot find _OBJECT_DIRECTORY type.\n");
        return FALSE;
    }
    HashBucketsAddress = pDirectoryObject + HashOffset;
    HashBucketSz = IsPtr64() ? 8 : 4;

// From ob.h
#define NUMBER_HASH_BUCKETS 37

    for (i=0; i<NUMBER_HASH_BUCKETS; i++) {
        ULONG64 HashBucketI = 0;

        ReadPointer(HashBucketsAddress + i*HashBucketSz, &HashBucketI);
        if (HashBucketI != 0) {
            pDirectoryEntry = HashBucketI;
            while (pDirectoryEntry != 0) {
                ULONG64 Object=0, Next=0;

                if (CheckControlC()) {
                    return FALSE;
                }

                if ( GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "Object", Object)) {
                    // dprintf( "Unable to read directory entry at %x\n", pDirectoryEntry );
                    break;
                }

                if (!GetObjectInfo(Object, &ObjectInfo)) {
                    // dprintf( " - %s\n", ObjectInfo.Message );
                } else {
                    foundMatch = TRUE;

                    for (j = 0;
                        (Path[j] != '\0') && (ObjectInfo.ObjectName[j] != L'\0');
                        j++) {

                        if (tolower(Path[j]) !=
                            towlower(ObjectInfo.ObjectName[j])) {
                            foundMatch = FALSE;
                            break;
                        }

                    }

                    if (foundMatch) {

                        if ((Path[j] == '\0') &&
                            (ObjectInfo.ObjectName[j] == L'\0')) {

                            return FindObjectByName(nextPath, Object);
                        }

                    }

                }

                GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "ChainLink", Next);
                pDirectoryEntry = Next;
            }
        }
    }

    return 0;
}

VOID
DumpDirectoryObject(
                   IN char     *Pad,
                   IN ULONG64   Object
                   )
{
    ULONG Result, i;
    ULONG64           pDirectoryObject = Object;
    ULONG64           pDirectoryEntry;
    ULONG64           HashBucketsAddress;
    ULONG             HashBucketSz;
    ULONG             HashOffset;
    OBJECT_INFO ObjectInfo;
    ULONG SymbolicLinkUsageCount=0;

    //
    // Get the address of hashbuckets array and size of the pointer to scan the array
    //
    if (GetFieldOffset("nt!_OBJECT_DIRECTORY", "HashBuckets", &HashOffset)) {
        dprintf("Cannot find _OBJECT_DIRECTORY type.\n");
        return ;
    }
    HashBucketsAddress = pDirectoryObject + HashOffset;
    HashBucketSz = IsPtr64() ? 8 : 4;
    
    GetFieldValue(pDirectoryObject, "nt!_OBJECT_DIRECTORY", "SymbolicLinkUsageCount", SymbolicLinkUsageCount);

    if (SymbolicLinkUsageCount != 0) {
        dprintf( "%s    %u symbolic links snapped through this directory\n",
                 Pad,
                 SymbolicLinkUsageCount
               );
    }
    for (i=0; i<NUMBER_HASH_BUCKETS; i++) {
        ULONG64 HashBucketI = 0;

        ReadPointer(HashBucketsAddress + i*HashBucketSz, &HashBucketI);
        if (HashBucketI != 0) {
            dprintf( "%s    HashBucket[ %02u ]: ",
                     Pad,
                     i
                   );
            pDirectoryEntry = HashBucketI;
            while (pDirectoryEntry != 0) {
                ULONG64 Object=0, Next=0;
                
                if (GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "Object", Object)) {
                    dprintf( "Unable to read directory entry at %p\n", pDirectoryEntry );
                    break;
                }

                if (pDirectoryEntry != HashBucketI) {
                    dprintf( "%s                      ", Pad );
                }
                dprintf( "%p", Object );

                if (!GetObjectInfo( Object, &ObjectInfo)) {
                    dprintf( " - %s\n", ObjectInfo.Message );
                } else {
                    dprintf( " %ws '%ws'\n", ObjectInfo.TypeName, ObjectInfo.ObjectName );
                }

                GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "ChainLink", Next);
                pDirectoryEntry = Next;
            }
        }
    }
}

VOID
DumpSymbolicLinkObject(
                      IN char     *Pad,
                      IN ULONG64   Object,
                      OPTIONAL OUT PCHAR TargetString,
                      IN ULONG     TargetStringSize
                      )
{
    ULONG Result, i;
    ULONG64              pSymbolicLinkObject = Object;
    PWSTR s, FreeBuffer;
    ULONG Length;
    ULONG64 TargetBuffer=0, DosDeviceDriveIndex=0, LinkTargetObject=0;



    if (GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "LinkTarget.Length", Length)) {
        dprintf( "Unable to read symbolic link object at %p\n", Object );
        return;
    }

    GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "LinkTarget.Buffer", TargetBuffer);
    GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "DosDeviceDriveIndex" , DosDeviceDriveIndex);
    GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "LinkTargetObject", LinkTargetObject);

    FreeBuffer = s = HeapAlloc( GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                Length + sizeof( UNICODE_NULL )
                              );
    if (s == NULL ||
        !ReadMemory( TargetBuffer,
                     s,
                     Length,
                     &Result
                   )
       ) {
        s = L"*** target string unavailable ***";
    }
    dprintf( "%s    Target String is '%ws'\n",
             Pad,
             s
           );
    if (TargetString && (TargetStringSize > wcslen(s))) {
        sprintf(TargetString, "%ws", s);
    }

    if (FreeBuffer != NULL) {
        HeapFree( GetProcessHeap(), 0, FreeBuffer );
    }


    if (DosDeviceDriveIndex != 0) {
        dprintf( "%s    Drive Letter Index is %I64u (%c:)\n",
                 Pad,
                 DosDeviceDriveIndex,
                 'A' + DosDeviceDriveIndex - 1
               );
    }
    if (LinkTargetObject != 0) {
        GetFieldValue(pSymbolicLinkObject, "_OBJECT_SYMBOLIC_LINK", "LinkTargetRemaining.Length", Length);

        FreeBuffer = s = HeapAlloc( GetProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    Length + sizeof( UNICODE_NULL )
                                  );
        GetFieldValue(pSymbolicLinkObject, "_OBJECT_SYMBOLIC_LINK", "LinkTargetRemaining.Buffer", TargetBuffer);
        
        if (s == NULL ||
            !ReadMemory( TargetBuffer,
                         s,
                         Length,
                         &Result
                       )
           ) {
            s = L"*** remaining name unavailable ***";
        }
        dprintf( "%s    Snapped to Object %p '%ws'\n",
                 Pad,
                 LinkTargetObject,
                 s
               );

        if (FreeBuffer != NULL) {
            HeapFree( GetProcessHeap(), 0, FreeBuffer );
        }
    }

    return;
}


BOOLEAN
DumpObject(
          IN char     *Pad,
          IN ULONG64  Object,
          IN ULONG    Flags
          )
{
    OBJECT_INFO ObjectInfo;

    if (!GetObjectInfo(Object, &ObjectInfo)) {
        dprintf( "KD: %s\n", ObjectInfo.Message );
        return FALSE;
    }
    dprintf( "Object: %08p  Type: (%08p) %ws\n",
             Object,
             ObjectInfo.ObjectHeader.Type,
             ObjectInfo.TypeName
           );
    dprintf( "    ObjectHeader: %08p\n",
             ObjectInfo.pObjectHeader
           );

    if (!(Flags & 0x1)) {
        return TRUE;
    }

    dprintf( "%s    HandleCount: %u  PointerCount: %u\n",
             Pad,
             ObjectInfo.ObjectHeader.HandleCount,
             ObjectInfo.ObjectHeader.PointerCount
           );

    if (ObjectInfo.ObjectName[ 0 ] != UNICODE_NULL ||
        ObjectInfo.NameInfo.Directory != 0
       ) {
        dprintf( "%s    Directory Object: %08p  Name: %ws",
                 Pad,
                 ObjectInfo.NameInfo.Directory,
                 ObjectInfo.ObjectName
               );
        if (ObjectInfo.FileSystemName[0] != UNICODE_NULL) {
            dprintf( " {%ws}\n", ObjectInfo.FileSystemName );
        } else {
            dprintf( "\n" );
        }
    }

    if ((Flags & 0x8)) {
        if (!wcscmp( ObjectInfo.TypeName, L"Directory" )) {
            DumpDirectoryObject( Pad, Object );
        } else
            if (!wcscmp( ObjectInfo.TypeName, L"SymbolicLink" )) {
            DumpSymbolicLinkObject( Pad, Object, NULL, 0 );
        }
    }

    return TRUE;
}


PWSTR
GetObjectName(
             ULONG64 Object
             )
{
    ULONG            Result;
    ULONG64          pObjectHeader;
    UNICODE_STRING64 ObjectName={0};

    ULONG64          pNameInfo;
    ULONG            NameInfoOffset=0;
    ULONG64          Type=0;
    ULONG            BodyOffset;

    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset)) {
        return NULL;
    }
    
    pObjectHeader = Object - BodyOffset;
    
    if (GetFieldValue(pObjectHeader, "nt!_OBJECT_HEADER", "Type", Type) || 
        GetFieldValue(pObjectHeader, "nt!_OBJECT_HEADER", "NameInfoOffset", NameInfoOffset)) {
        if (Object >= HighestUserAddress && (ULONG)Object < 0xF0000000) {
            swprintf( ObjectNameBuffer, L"(%08p: object is paged out)", Object );
            return ObjectNameBuffer;
        } else {
            swprintf( ObjectNameBuffer, L"(%08p: invalid object header)", Object );
            return ObjectNameBuffer;
        }
    }

    pNameInfo =  NameInfoOffset ? (pObjectHeader - NameInfoOffset) : 0;
    if (pNameInfo == 0) {
        dprintf("NameInfoOffset not found for _OBJECT_HEADER at %p\n", pObjectHeader);
        return NULL;
    }

    if (GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", ObjectName.Length) || 
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", ObjectName.Buffer) || 
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", ObjectName.MaximumLength)) {
        dprintf( "%08p: Unable to read object name info\n", pNameInfo );
        return NULL;
    }

    if (ObjectName.Length == 0 || ObjectName.Buffer == 0) {
        return NULL;
    }

    if (ObjectName.Length >= sizeof(ObjectNameBuffer) / sizeof(WCHAR)) {
        ObjectName.Length = sizeof(ObjectNameBuffer) / sizeof(WCHAR);
    }

    if ( !ReadMemory( ObjectName.Buffer,
                      ObjectNameBuffer,
                      ObjectName.Length,
                      &Result) ) {
        swprintf( ObjectNameBuffer, L"(%08lx: name not accessable)", ObjectName.Buffer );
    } else {
        ObjectNameBuffer[ ObjectName.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
    }

    return ObjectNameBuffer;
}



BOOLEAN
WalkObjectsByType(
                 IN PUCHAR               ObjectTypeName,
                 IN ENUM_TYPE_ROUTINE    EnumRoutine,
                 IN PVOID                Parameter
                 )
{
    ULONG        Result;
    LIST_ENTRY64 ListEntry;
    ULONG64      Head,   Next;
    ULONG64      pObjectHeader;
    ULONG64      pObjectType;
    BOOLEAN      WalkingBackwards;
    ULONG64      pCreatorInfo;
    ULONG        TotalNumberOfObjects=0, TypeListOffset;
    ULONG64      Flink=0, TypeList_Flink=0, TypeList_Blink=0;
    
    if (GetFieldOffset("nt!_OBJECT_TYPE", "TypeList", &TypeListOffset)) {
       return FALSE;
    }

    pObjectType = FindObjectType( ObjectTypeName );
    if (pObjectType == 0) {
        dprintf( "*** unable to find '%s' object type.\n", ObjectTypeName );
        return FALSE;
    }

    if (GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "ListEntry.Flink", Flink)) {
        dprintf( "%08lx: Unable to read object type\n", pObjectType );
        return FALSE;
    }
    GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "TypeList.Blink", TypeList_Blink);
    GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "TypeList.Flink", TypeList_Flink);
    GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "TotalNumberOfObjects", TotalNumberOfObjects);

    dprintf( "Scanning %u objects of type '%s'\n", TotalNumberOfObjects & 0x00FFFFFF, ObjectTypeName );
    Head        = pObjectType + TypeListOffset;
    ListEntry.Flink   = TypeList_Flink;
    ListEntry.Blink   = TypeList_Blink;
    Next        = Flink;
    WalkingBackwards = FALSE;
    if ((TotalNumberOfObjects & 0x00FFFFFF) != 0 && Next == Head) {
        dprintf( "*** objects of the same type are only linked together if the %x flag is set in NtGlobalFlags\n",
                 FLG_MAINTAIN_OBJECT_TYPELIST
               );
        return TRUE;
    }

    while (Next != Head) {
        if ( GetFieldValue(pObjectType, "nt!_LIST_ENTRY", "Blink", ListEntry.Blink) ||
             GetFieldValue(pObjectType, "nt!_LIST_ENTRY", "Flink", ListEntry.Flink)) {
               if (WalkingBackwards) {
                dprintf( "%08p: Unable to read object type list\n", Next );
                return FALSE;
            }

            WalkingBackwards = TRUE ;
            Next = TypeList_Blink;
            dprintf( "%08p: Switch to walking backwards\n", Next );
            continue;
        }

        pCreatorInfo = Next - TypeListOffset; //  CONTAINING_RECORD( Next, OBJECT_HEADER_CREATOR_INFO, TypeList );
        pObjectHeader = pCreatorInfo + GetTypeSize("nt!_OBJECT_HEADER_CREATOR_INFO");
        //
        // Not reading the objectheader as before, just pass the address

        if (!(EnumRoutine)( pObjectHeader, Parameter )) {
            return FALSE;
        }

        if ( CheckControlC() ) {
            return FALSE;
        }

        if (WalkingBackwards) {
            Next = ListEntry.Blink;
        } else {
            Next = ListEntry.Flink;
        }
    }

    return TRUE;
}

BOOLEAN
CaptureObjectName(
                 IN ULONG64          pObjectHeader,
                 IN PWSTR            Buffer,
                 IN ULONG            BufferSize
                 )
{
    ULONG Result;
    PWSTR s1 = L"*** unable to get object name";
    PWSTR s = &Buffer[ BufferSize ];
    ULONG n = BufferSize * sizeof( WCHAR );
    ULONG64                     pNameInfo;
    ULONG64                     pObjectDirectoryHeader = 0;
    ULONG64                     ObjectDirectory;
    UNICODE_STRING64            Name;
    ULONG                       BodyOffset;
    
    Buffer[ 0 ] = UNICODE_NULL;
    KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &pNameInfo );
    if (pNameInfo == 0) {
        return TRUE;
    }

    if ( GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", Name.Buffer)) {
        wcscpy( Buffer, s1 );
        return FALSE;
    }
    GetFieldValue(pNameInfo, "_OBJECT_HEADER_NAME_INFO", "Name.Length", Name.Length);
    GetFieldValue(pNameInfo, "_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", Name.MaximumLength);

    if (Name.Length == 0) {
        return TRUE;
    }
    if (Name.Length > (ULONG64) (s - Buffer)) {
        if (Name.Length > 1024) {
            wsprintfW(Buffer, L"*** Bad object Name length for ObjHdr at %I64lx", pObjectHeader);
            return FALSE;
        }
        Name.Length = (USHORT) (ULONG64) (s - Buffer);
    }
    
    *--s = UNICODE_NULL;
    s = (PWCH)((PCH)s - Name.Length);

    if ( !ReadMemory( Name.Buffer,
                      s,
                      Name.Length,
                      &Result) ) {
        wcscpy( Buffer, s1 );
        return FALSE;
    }

    GetFieldValue(pNameInfo, "_OBJECT_HEADER_NAME_INFO", "Directory", ObjectDirectory);
    while ((ObjectDirectory != ObpRootDirectoryObject) && (ObjectDirectory)) {

        pObjectDirectoryHeader = KD_OBJECT_TO_OBJECT_HEADER(ObjectDirectory);
        
        KD_OBJECT_HEADER_TO_NAME_INFO( pObjectDirectoryHeader, &pNameInfo );

        if ( GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", Name.Buffer)) {
            wcscpy( Buffer, s1 );
            return FALSE;
        }
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", Name.Length);
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", Name.MaximumLength);

        if (Name.Length > (ULONG64) (s - Buffer)) {
            if (Name.Length > 1024) {
                wsprintfW(Buffer, L"*** Bad object Name length for ObjHdr at %I64lx", pObjectDirectoryHeader);
                return FALSE;
            }
            Name.Length = (USHORT) (ULONG64) (s - Buffer);
        }
        *--s = OBJ_NAME_PATH_SEPARATOR;
        s = (PWCH)((PCH)s - Name.Length);
        if ( !ReadMemory( Name.Buffer,
                          s,
                          Name.Length,
                          &Result) ) {
            wcscpy( Buffer, s1 );
            return FALSE;
        }

        ObjectDirectory = 0;
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Directory", ObjectDirectory);

        if ( CheckControlC() ) {
            return FALSE;
        }
    }
    *--s = OBJ_NAME_PATH_SEPARATOR;

    wcscpy( Buffer, s );
    return TRUE;
}

/////////////////////////////////////////////////////////////
static BOOL
ReadStructFieldVerbose( ULONG64 AddrStructBase,
                        PCHAR StructTypeName,
                        PCHAR StructFieldName,
                        PVOID Buffer,
                        ULONG BufferSize )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset
    //

    ErrorCode = GetFieldOffset (StructTypeName,
                                StructFieldName,
                                &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        Success = ReadMemory (AddrStructBase + FieldOffset,
                              Buffer,
                              BufferSize,
                              NULL );

        if (Success != TRUE) {

            dprintf ("ERROR: Cannot read structure field value at 0xp, error %u\n",
                     AddrStructBase + FieldOffset,
                     ErrorCode );
        }
    }
    else {

        dprintf ("ERROR: Cannot get field offset of %s in %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////
static BOOL
ReadPtrStructFieldVerbose( ULONG64 AddrStructBase,
                           PCHAR StructTypeName,
                           PCHAR StructFieldName,
                           PULONG64 Buffer )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset inside the structure 
    //

    ErrorCode = GetFieldOffset (StructTypeName,
                                StructFieldName,
                                &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        ErrorCode = ReadPtr (AddrStructBase + FieldOffset,
                             Buffer );

        if (ErrorCode != S_OK) {

            dprintf ("ERROR: Cannot read structure field value at 0x%p, error %u\n",
                     AddrStructBase + FieldOffset,
                     ErrorCode );
        }
        else {

            Success = TRUE;
        }
    }
    else {

        dprintf ("ERROR: Cannot get field offset of %s in structure %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////
static BOOL
DumpStackTrace (ULONG64 PointerAddress,
                ULONG MaxStackTraceDepth,
                ULONG PointerSize)
{
    ULONG64 CodePointer;
    ULONG64 Displacement;
    ULONG StackTraceDepth;
    ULONG ErrorCode;
    BOOL Continue;
    char Symbol[ 1024 ];

    Continue = TRUE;

    for (StackTraceDepth = 0; StackTraceDepth < MaxStackTraceDepth; StackTraceDepth += 1) {

        if (CheckControlC()) {

            Continue = FALSE;
            goto Done;
        }

        ErrorCode = ReadPtr (PointerAddress,
                             &CodePointer );

        if (ErrorCode != S_OK) {

            dprintf ("ERROR: Cannot read address at 0x%p, error %u\n",
                     PointerAddress,
                     ErrorCode );
        }
        else {

            if( CodePointer == 0 ) {

                //
                // End of stack trace
                //
                
                goto Done;
            }

            GetSymbol (CodePointer,
                       Symbol,
                       &Displacement);

            dprintf ("0x%p: %s+0x%I64X\n",
                     CodePointer,
                     Symbol,
                     Displacement );
        }

        PointerAddress += PointerSize;
    }

Done:

    return Continue;
}

/////////////////////////////////////////////////////////////
static BOOL
DumpHandleTraceEntry (ULONG64 TraceDbEntry,
                      ULONG64 Handle,
                      ULONG64 NullHandleEntry,
                      ULONG StackTraceFieldOffset,
                      ULONG MaxStackTraceDepth,
                      ULONG PointerSize,
                      PULONG EntriesDisplayed)
{
    ULONG64 EntryHandle;
    ULONG Type;
    BOOL Success;
    BOOL Continue;

#ifndef HANDLE_TRACE_DB_OPEN
#define HANDLE_TRACE_DB_OPEN   1
#endif

#ifndef HANDLE_TRACE_DB_CLOSE
#define HANDLE_TRACE_DB_CLOSE  2
#endif

#ifndef HANDLE_TRACE_DB_BADREF
#define HANDLE_TRACE_DB_BADREF 3
#endif

    Continue = TRUE;

    //
    // Read the handle of this entry
    //

    Success = ReadPtrStructFieldVerbose (TraceDbEntry,
                                         "nt!_HANDLE_TRACE_DB_ENTRY",
                                         "Handle",
                                         &EntryHandle );

    if (Success == FALSE) {

        dprintf ("ERROR: Cannot read handle for trace database entry at 0x%p.\n",
                 TraceDbEntry );
        goto Done;
    }

    //
    // Read the operation type
    //

    Success = ReadStructFieldVerbose (TraceDbEntry,
                                      "nt!_HANDLE_TRACE_DB_ENTRY",
                                      "Type",
                                      &Type,
                                      sizeof( Type ) );

    if (Success == FALSE) {

        dprintf ("ERROR: Cannot read operation type for trace database entry at 0x%p.\n",
                 TraceDbEntry );
        goto Done;
    }

    if (EntryHandle == 0 && Type == 0 && TraceDbEntry != NullHandleEntry) {

        //
        // We are done parsing the database.
        //

        Continue = FALSE;

        goto Done;
    }

    //
    // Check if we need to dump this entry.
    //

    if (Handle == 0 || Handle == EntryHandle) {


        *EntriesDisplayed += 1;

        dprintf( "--------------------------------------\n"
                 "Handle 0x%I64X - ",
                 EntryHandle );

        switch( Type ) {

        case HANDLE_TRACE_DB_OPEN:
            dprintf( "OPEN:\n" );
            break;

        case HANDLE_TRACE_DB_CLOSE:
            dprintf( "CLOSE:\n" );
            break;

        case HANDLE_TRACE_DB_BADREF:
            dprintf( "*** BAD REFERENCE ***:\n" );
            break;

        default:

            dprintf( "ERROR: Invalid operation type for database entry at 0x%p\n",
                     TraceDbEntry );

            Continue = FALSE;

            goto Done;
        }

        Continue = DumpStackTrace (TraceDbEntry + StackTraceFieldOffset,
                                   MaxStackTraceDepth,
                                   PointerSize );
    }

Done:

    return Continue;
}

/////////////////////////////////////////////////////////////
static VOID
DumpHandleTraces (ULONG64 Process,
                  ULONG64 Handle)
{
    ULONG64 ObjectTable;
    ULONG64 DebugInfo;
    ULONG64 TraceDbEntry;
    ULONG64 FirstDbEntry;
    ULONG SizeofDbEntry;
    ULONG CurrentStackIndex;
    ULONG SizeofDebugInfo;
    ULONG TraceDbFieldOffset;
    ULONG EntriesInTraceDb;
    ULONG EntriesParsed;
    ULONG StackTraceFieldOffset;
    ULONG MaxStackTraceDepth;
    ULONG PointerTypeSize;
    ULONG ErrorCode;
    ULONG EntriesDisplayed;
    BOOL Success;
    BOOL Continue;

    EntriesParsed = 0;
    EntriesDisplayed = 0;

    //
    // Get the pointer type size 
    //

    PointerTypeSize = GetTypeSize ("nt!PVOID");

    if (PointerTypeSize == 0) {

        dprintf ("ERROR: Cannot get the pointer size.\n");
        goto Done;
    }

    //
    // Read the address of the object table structure
    //

    Success = ReadPtrStructFieldVerbose (Process,
                                         "nt!_EPROCESS",
                                         "ObjectTable",
                                         &ObjectTable);

    if (Success == FALSE) {

        dprintf ("ERROR: Cannot read process object table address.\n");
        goto Done;
    }
    else {

        dprintf ("ObjectTable 0x%p\n\n",
                 ObjectTable );
    }

    //
    // Read the DebugInfo from the handle table structure
    //

    Success = ReadPtrStructFieldVerbose (ObjectTable,
                                         "nt!_HANDLE_TABLE",
                                         "DebugInfo",
                                         &DebugInfo );

    if (Success == FALSE) {

        dprintf( "ERROR: Cannot read object table debug information.\n" );
        goto Done;
    }

    if (DebugInfo == 0) {

        dprintf( "Trace information is not enabled for this process.\n" );
        goto Done;
    }

    //
    // Get the current index in the trace database
    //

    Success = ReadStructFieldVerbose (DebugInfo,
                                      "nt!_HANDLE_TRACE_DEBUG_INFO",
                                      "CurrentStackIndex",
                                      &CurrentStackIndex,
                                      sizeof( CurrentStackIndex ) );

    if (Success == FALSE) {

        dprintf( "ERROR: Cannot read the current index of the trace database.\n" );
        goto Done;
    }

    //
    // Get the size of the HANDLE_TRACE_DB_ENTRY type
    //

    SizeofDbEntry = GetTypeSize ("nt!HANDLE_TRACE_DB_ENTRY");

    if (SizeofDbEntry == 0) {

        dprintf ("Cannot get the size of the trace database entry structure\n");
        goto Done;
    }

    //
    // Get the max number of entries in the StackTrace array inside HANDLE_TRACE_DB_ENTRY
    //

    ErrorCode = GetFieldOffset ("nt!_HANDLE_TRACE_DB_ENTRY",
                                "StackTrace",
                                &StackTraceFieldOffset);

    if (ErrorCode != S_OK) {
        
        dprintf ("Cannot get StackTrace field offset.\n");
        goto Done;
    }

    MaxStackTraceDepth = (SizeofDbEntry - StackTraceFieldOffset) / PointerTypeSize;

    //
    // Get the size of the HANDLE_TRACE_DEBUG_INFO type
    //

    SizeofDebugInfo = GetTypeSize ("nt!HANDLE_TRACE_DEBUG_INFO");

    if (SizeofDebugInfo == 0) {

        dprintf ("ERROR: Cannot get the size of the debug info structure\n");
        goto Done;
    }

    //
    // Get the offset of TraceDb inside the _HANDLE_TRACE_DEBUG_INFO structure
    //

    ErrorCode = GetFieldOffset ("nt!_HANDLE_TRACE_DEBUG_INFO",
                                "TraceDb",
                                &TraceDbFieldOffset);

    if (ErrorCode != S_OK) {
        
        dprintf ("ERROR: Cannot get TraceDb field offset.\n");
        goto Done;
    }

    //
    // Compute the number of entries in the TraceDb array
    //

    EntriesInTraceDb = (SizeofDebugInfo - TraceDbFieldOffset) / SizeofDbEntry;

    if (EntriesInTraceDb == 0) {

        dprintf ("ERROR: zero entries in the trace database.\n");
        goto Done;
    }

    CurrentStackIndex = CurrentStackIndex % EntriesInTraceDb;

    //
    // Compute a pointer to the current stack trace database entry 
    //

    FirstDbEntry = DebugInfo + TraceDbFieldOffset;

    TraceDbEntry = FirstDbEntry + CurrentStackIndex * SizeofDbEntry;

    //
    // Dump all the valid entries in the array
    //

    EntriesDisplayed = 0;

    for (EntriesParsed = 0; EntriesParsed < EntriesInTraceDb; EntriesParsed += 1) {

        if (CheckControlC()) {

            goto Done;
        }

        //
        // The first entry in the array is never used so skip it
        //

        if (EntriesParsed != CurrentStackIndex) {


            Continue = DumpHandleTraceEntry( TraceDbEntry,
                                             Handle,
                                             FirstDbEntry,
                                             StackTraceFieldOffset,
                                             MaxStackTraceDepth,
                                             PointerTypeSize,
                                             &EntriesDisplayed );

            if (Continue == FALSE) {

                //
                // This current entry is free or the user pressed Ctrl-C 
                // so we don't have any entries left to dump.
                //

                EntriesParsed += 1;

                break;
            }

            //
            // Go backward
            //

            TraceDbEntry -= SizeofDbEntry;
        }
        else {

            //
            // We should be at the beginning of the array
            //

            if( TraceDbEntry != FirstDbEntry ) {


                dprintf ("ERROR: 0x%p should be the beginning of the traces array 0x%p\n",
                         TraceDbEntry,
                         FirstDbEntry);
                goto Done;
            }

            //
            // Start over again with the last entry in the array
            //

            TraceDbEntry = DebugInfo + TraceDbFieldOffset + ( EntriesInTraceDb - 1 ) * SizeofDbEntry;
        }
    }

Done:

    dprintf ("\n--------------------------------------\n"
            "Parsed 0x%X stack traces.\n"
            "Dumped 0x%X stack traces.\n",
            EntriesParsed,
            EntriesDisplayed);

    NOTHING;
}

/////////////////////////////////////////////////////////////
DECLARE_API( htrace )

/*++

Routine Description:

    Dump the trace information for a handle

Arguments:

    args - [process] [handle]

Return Value:

    None

--*/
{
    ULONG64 Handle;
    ULONG64 Process;
    ULONG CurrentProcessor;

    //
    // Did the user ask for help?
    //

    if(strcmp( args, "-?" ) == 0 || 
       strcmp( args, "?" ) == 0 || 
       strcmp( args, "-h" ) == 0) {

        dprintf( "\n!htrace [ handle [process] ]    - dump handle tracing information.\n" );
        goto Done;
    }


    Handle = 0;
    Process = 0;

    //
    // Get the current processor number
    //

    if (!GetCurrentProcessor(Client, &CurrentProcessor, NULL)) {
        CurrentProcessor = 0;
    }

    //
    // Did the user specify a process and a handle?
    //

    sscanf  (args, 
             "%I64X %I64X", 
             &Handle,
             &Process );

    if (Process == 0) {

        GetCurrentProcessAddr( CurrentProcessor, 0, &Process );

        if (Process == 0) {

            dprintf ("Cannot get current process address\n"); 
            goto Done;
        }
        else {

            dprintf( "Process 0x%p\n",
                     Process );
        }
    }
    else {

        dprintf ("Process 0x%p\n",
                 Process );
    }

    DumpHandleTraces (Process,
                      Handle);

Done:

    return S_OK;
}


DECLARE_API( driveinfo )
{
    CHAR VolumeName[100];
    CHAR ObjectName[100];
    ULONG i=0;
    ULONG64 Object;
    CHAR targetVolume[100]={0};
    ULONG64 DevObjVPB;
    ULONG64 VpbDevice;
    ULONG64 DriverObject;
    ULONG64 DrvNameAddr;
    OBJECT_INFO ObjectInfo;
    WCHAR FileSystem[100]={0};
    PWSTR FsType;
    ULONG NameLen;
    ULONG result;

    while (*args == ' ') ++args;

    while (*args && *args != ' ') {
        VolumeName[i++] = *args++;
    }
    if (!i) {
        dprintf("Usage :  !drvolume <drive-name>\n");
        return E_INVALIDARG;
    }
    if (VolumeName[i-1] == ':') {
        --i;
    }
    VolumeName[i]=0;


    // Build Object name
    strcpy(ObjectName, "\\global\?\?\\");
    strcat(ObjectName, VolumeName);
    strcat(ObjectName, ":");

    // GetObject info

    Object = FindObjectByName((PUCHAR) ObjectName, 0);

    if (!Object) {
        dprintf("Drive object not found for %s\n", ObjectName);
        return E_FAIL;
    }
    dprintf("Drive %s:, DriveObject %p\n", VolumeName, Object);

    if (!GetObjectInfo(Object, &ObjectInfo)) {
        dprintf( "%s\n", ObjectInfo.Message );
        return E_FAIL;
    }

    if (ObjectInfo.ObjectName[ 0 ] != UNICODE_NULL ||
        ObjectInfo.NameInfo.Directory != 0
        ) {
        dprintf( "    Directory Object: %08p  Name: %ws",
                 ObjectInfo.NameInfo.Directory,
                 ObjectInfo.ObjectName
                 );
        if (ObjectInfo.FileSystemName[0] != UNICODE_NULL) {
            dprintf( " {%ws}\n", ObjectInfo.FileSystemName );
        } else {
            dprintf( "\n" );
        }
    }

    if (!wcscmp( ObjectInfo.TypeName, L"SymbolicLink" )) {
        DumpSymbolicLinkObject( "    ", Object, targetVolume, sizeof(targetVolume) );

    }
    
    // devobj for volume
    Object = FindObjectByName((PUCHAR) targetVolume, 0);

    if (!Object) {
        dprintf("Object not found for %s\n", targetVolume);
        return E_FAIL;
    }

    dprintf("    Volume DevObj: %p\n", Object);

    // Now get the vpb (volume parameter block) for devobj

    if (GetFieldValue(Object, "nt!_DEVICE_OBJECT", "Vpb", DevObjVPB)) {
        dprintf("Cannot get nt!_DEVICE_OBJECT.Vpb @ %p\n", DevObjVPB);
        return E_FAIL;
    }
    
    // Now find device object of VPB
    if (GetFieldValue(DevObjVPB, "nt!_VPB", "DeviceObject", VpbDevice)) {
        dprintf("Cannot get nt!_VPB.DeviceObject @ %p\n", VpbDevice);
        return E_FAIL;
    }
    dprintf("    Vpb: %p  DeviceObject: %p\n", DevObjVPB, VpbDevice);


    // Get fielsystem for VPB Device
    if (GetFieldValue(VpbDevice, "nt!_DEVICE_OBJECT", "DriverObject", DriverObject)) {
        dprintf("Error in getting _DEVICE_OBJECT.DriverObject @ %p\n", VpbDevice);
        return E_FAIL;
    }

    if (GetFieldValue(DriverObject, "nt!_DRIVER_OBJECT", "DriverName.MaximumLength", NameLen)) {
        dprintf("Cannot get driver name for %p\n", DriverObject);
        return E_FAIL;
    }
    GetFieldValue(DriverObject, "nt!_DRIVER_OBJECT", "DriverName.Buffer", DrvNameAddr);
    if (NameLen > sizeof(FileSystem)/sizeof(WCHAR)) {
        NameLen = sizeof(FileSystem)/sizeof(WCHAR)-1;
    }
    if (!ReadMemory( DrvNameAddr,FileSystem,NameLen,&result)) {
        dprintf("Filesystem driver name paged out");
        return E_FAIL;
    }
    
    dprintf("    FileSystem: %ws\n", FileSystem);
    FsType = FileSystem + wcslen(L"\\FileSystem")+1;


    if (!wcscmp(FsType, L"Fastfat")) {
        ULONG NumberOfClusters, NumberOfFreeClusters, LogOfBytesPerSector,
            LogOfBytesPerCluster, FatIndexBitSize;
        ULONG64 ClusterSize;

        // Its a FAT system
        if (GetFieldValue(VpbDevice, 
                          "fastfat!VOLUME_DEVICE_OBJECT", 
                          "Vcb.AllocationSupport.NumberOfClusters", 
                          NumberOfClusters)) {
            dprintf("Cannot get  fastfat!VOLUME_DEVICE_OBJECT.Vcb @ %p\n", VpbDevice);
            return E_FAIL;
        }
        InitTypeRead(VpbDevice, fastfat!VOLUME_DEVICE_OBJECT);
        NumberOfFreeClusters = (ULONG) ReadField(Vcb.AllocationSupport.NumberOfFreeClusters);
        LogOfBytesPerSector = (ULONG) ReadField(Vcb.AllocationSupport.LogOfBytesPerSector);
        LogOfBytesPerCluster = (ULONG) ReadField(Vcb.AllocationSupport.LogOfBytesPerCluster);
        FatIndexBitSize = (ULONG) ReadField(Vcb.AllocationSupport.FatIndexBitSize);

        ClusterSize = 1 << LogOfBytesPerCluster;
        dprintf("    Volume has 0x%lx (free) / 0x%lx (total) clusters of size 0x%I64lx\n",
                NumberOfFreeClusters, NumberOfClusters, ClusterSize);
#define _MB( Bytes ) ((double)(Bytes)/(1 << 20))
        dprintf("    %I64g of %I64g MB free\n",
                _MB(NumberOfFreeClusters*ClusterSize), _MB(NumberOfClusters*ClusterSize));
    } else     if (!wcscmp(FsType, L"Ntfs")) {
        // Ntfs filesystem
        ULONG64 TotalClusters, FreeClusters, BytesPerCluster;
        if (GetFieldValue(VpbDevice, 
                          "ntfs!VOLUME_DEVICE_OBJECT", 
                          "Vcb.TotalClusters", 
                          TotalClusters)) {
            dprintf("Cannot get  ntfs!VOLUME_DEVICE_OBJECT.Vcb @ %p\n", VpbDevice);
            return E_FAIL;
        }
        InitTypeRead(VpbDevice, ntfs!VOLUME_DEVICE_OBJECT);
        FreeClusters = ReadField(Vcb.FreeClusters);
        BytesPerCluster = ReadField(Vcb.BytesPerCluster);
        dprintf("    Volume has 0x%I64lx (free) / 0x%I64lx (total) clusters of size 0x%I64lx\n",
                FreeClusters, TotalClusters, BytesPerCluster);
        dprintf("    %I64g of %I64g MB free\n",
                _MB(FreeClusters*BytesPerCluster), _MB(TotalClusters*BytesPerCluster));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\pci.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pci.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 18-August-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#pragma hdrstop

DECLARE_API(pciir)
{
    ULONG64                 addr;
    ULONG64                 pciIrqRoutingTable;
    ULONG64                 slot;
    ULONG64                 lastSlot;
    ULONG                   slotSz, SizeOfRoutingTable, TableSize;

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("X86 target only API.\n");
        return E_INVALIDARG;
    }

    slotSz = GetTypeSize("hal!_SLOT_INFO");
    SizeOfRoutingTable = GetTypeSize("hal!_PCI_IRQ_ROUTING_TABLE");
    addr = GetExpression("Hal!HalpPciIrqRoutingInfo");
    if (addr == 0)
    {
        dprintf("Error reading Pci Irq Routing Info!\n");
    }
    else
    {
        pciIrqRoutingTable = 0;
        if (ReadPointer(addr, &pciIrqRoutingTable))
        {
            if (pciIrqRoutingTable) 
            {
                //
                // Read and dump the header.
                //

                if (!InitTypeRead(pciIrqRoutingTable, hal!_PCI_IRQ_ROUTING_TABLE))
                {
                    dprintf("Version            = %04x\n", (ULONG) ReadField(Version));
                    dprintf("Size               = %04x\n", TableSize = (ULONG) ReadField(TableSize));
                    dprintf("RouterBus          = %02x\n", (ULONG) ReadField(RouterBus));
                    dprintf("RouterDevFunc      = %02x:%02x\n", (ULONG) ReadField(RouterDevFunc) >> 3, (ULONG) ReadField(RouterDevFunc) & 0x7);
                    dprintf("ExclusiveIRQs      = %04x\n", (ULONG) ReadField(ExclusiveIRQs));
                    dprintf("CompatibleRouterId = %08x\n", (ULONG) ReadField(CompatibleRouter));
                    dprintf("MiniportData       = %08x\n", (ULONG) ReadField(MiniportData));
                    dprintf("CheckSum           = %04x\n", (ULONG) ReadField(Checksum));

                    //
                    // Read and dump the table.
                    //

                    dprintf("----------------------------------------------------------------\n");
                    dprintf("Bus Device  LnkA  Mask  LnkB  Mask  LnkC  Mask  LnkD  Mask  Slot\n");
                    dprintf("----------------------------------------------------------------\n");
                    slot = pciIrqRoutingTable + SizeOfRoutingTable;
                    for (lastSlot = pciIrqRoutingTable + TableSize; slot < lastSlot; slot+=slotSz)
                    {
                        if (!InitTypeRead(slot, hal!_SLOT_INFO))
                        {
                                dprintf("%02x    %02x     %02x   %04x   %02x   %04x   %02x   %04x   %02x   %04x   %02x\n", 
                                        (ULONG) ReadField(BusNumber), 
                                        (ULONG) ReadField(DeviceNumber) >> 3,
                                        (ULONG) ReadField(PinInfo[0].Link), (ULONG) ReadField(PinInfo[0].InterruptMap),
                                        (ULONG) ReadField(PinInfo[1].Link), (ULONG) ReadField(PinInfo[1].InterruptMap),
                                        (ULONG) ReadField(PinInfo[2].Link), (ULONG) ReadField(PinInfo[2].InterruptMap),
                                        (ULONG) ReadField(PinInfo[3].Link), (ULONG) ReadField(PinInfo[3].InterruptMap),
                                        (ULONG) ReadField(SlotNumber));
                        }
                    }
                }
            }
            else
            {
                dprintf("Pci Irq Routing Table not found.\n");
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\pcmcia.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pcmcia.c

Abstract:

    WinDbg Extension Api to dump PCMCIA driver structures.
    This module references some routines & types defined
    in devnode.c

Author:

    Ravisankar Pudipeddi (ravisp) 1-Dec-1997
    Neil Sandlin (neilsa) 1-June-1999

Environment:

    User Mode.

--*/


#include "precomp.h"
#pragma hdrstop

#define FLAG_NAME(flag)           {flag, #flag}

//
// Table of PCMCIA device extension flags
// update them from pcmcia.h
//
FLAG_NAME PcmciaDeviceFlags[] = {
   FLAG_NAME(PCMCIA_DEVICE_STARTED),
   FLAG_NAME(PCMCIA_DEVICE_LOGICALLY_REMOVED),
   FLAG_NAME(PCMCIA_DEVICE_PHYSICALLY_REMOVED),
   FLAG_NAME(PCMCIA_DEVICE_MULTIFUNCTION),
   FLAG_NAME(PCMCIA_DEVICE_WAKE_PENDING),
   FLAG_NAME(PCMCIA_DEVICE_LEGACY_DETECTED),
   FLAG_NAME(PCMCIA_DEVICE_DELETED),
   FLAG_NAME(PCMCIA_DEVICE_CARDBUS),
   FLAG_NAME(PCMCIA_FILTER_ADDED_MEMORY),
   FLAG_NAME(PCMCIA_MEMORY_24BIT),
   FLAG_NAME(PCMCIA_CARDBUS_NOT_SUPPORTED),
   FLAG_NAME(PCMCIA_USE_POLLED_CSC),
   FLAG_NAME(PCMCIA_ATTRIBUTE_MEMORY_MAPPED),
   FLAG_NAME(PCMCIA_SOCKET_REGISTER_BASE_MAPPED),
   FLAG_NAME(PCMCIA_INTMODE_COMPAQ),
   FLAG_NAME(PCMCIA_POWER_WORKER_POWERUP),
   FLAG_NAME(PCMCIA_SOCKET_POWER_REQUESTED),
   FLAG_NAME(PCMCIA_CONFIG_STATUS_DEFERRED),
   FLAG_NAME(PCMCIA_POWER_STATUS_DEFERRED),
   FLAG_NAME(PCMCIA_INT_ROUTE_INTERFACE),
   {0,0}
};

//
// Table of PCMCIA socket structure flags
// update them from pcmcia.h
//
FLAG_NAME PcmciaSocketFlags[] = {
   FLAG_NAME(SOCKET_CARD_IN_SOCKET),
   FLAG_NAME(SOCKET_CARD_INITIALIZED),
   FLAG_NAME(SOCKET_CARD_POWERED_UP),
   FLAG_NAME(SOCKET_CARD_CONFIGURED),
   FLAG_NAME(SOCKET_CARD_MULTIFUNCTION),
   FLAG_NAME(SOCKET_CARD_CARDBUS),
   FLAG_NAME(SOCKET_CARD_MEMORY),
   FLAG_NAME(SOCKET_CHANGE_INTERRUPT),
   FLAG_NAME(SOCKET_CUSTOM_INTERFACE),
   FLAG_NAME(SOCKET_INSERTED_SOUND_PENDING),
   FLAG_NAME(SOCKET_REMOVED_SOUND_PENDING),
   FLAG_NAME(SOCKET_SUPPORT_MESSAGE_SENT),
   FLAG_NAME(SOCKET_MEMORY_WINDOW_ENABLED),
   FLAG_NAME(SOCKET_CARD_STATUS_CHANGE),
   FLAG_NAME(SOCKET_POWER_STATUS_DEFERRED),
   {0,0}
};

ENUM_NAME PcmciaControllerTypeEnum[] = {
   ENUM_NAME(PcmciaIntelCompatible),
   ENUM_NAME(PcmciaCardBusCompatible),
   ENUM_NAME(PcmciaElcController),
   ENUM_NAME(PcmciaDatabook),
   ENUM_NAME(PcmciaPciPcmciaBridge),
   ENUM_NAME(PcmciaCirrusLogic),
   ENUM_NAME(PcmciaTI),
   ENUM_NAME(PcmciaTopic),
   ENUM_NAME(PcmciaRicoh),
   ENUM_NAME(PcmciaDatabookCB),
   ENUM_NAME(PcmciaOpti),
   ENUM_NAME(PcmciaTrid),
   ENUM_NAME(PcmciaO2Micro),
   ENUM_NAME(PcmciaNEC),
   ENUM_NAME(PcmciaNEC_98),
   ENUM_NAME(PcmciaInvalidControllerType),
   {0,0}
};


ENUM_NAME PcmciaSocketPowerWorkerStates[] = {
   ENUM_NAME(SPW_Stopped),
   ENUM_NAME(SPW_Exit),
   ENUM_NAME(SPW_RequestPower),
   ENUM_NAME(SPW_ReleasePower),
   ENUM_NAME(SPW_SetPowerOn),
   ENUM_NAME(SPW_SetPowerOff),
   ENUM_NAME(SPW_ParentPowerUp),
   ENUM_NAME(SPW_ParentPowerUpComplete),
   {0,0}
};

ENUM_NAME PcmciaPdoPowerWorkerStates[] = {
   ENUM_NAME(PPW_Stopped),
   ENUM_NAME(PPW_Exit),
   ENUM_NAME(PPW_InitialState),
   ENUM_NAME(PPW_PowerUp),
   ENUM_NAME(PPW_PowerUpComplete),
   ENUM_NAME(PPW_PowerDown),
   ENUM_NAME(PPW_PowerDownComplete),
   ENUM_NAME(PPW_SendIrpDown),
   ENUM_NAME(PPW_16BitConfigure),
   ENUM_NAME(PPW_Deconfigure),
   ENUM_NAME(PPW_VerifyCard),
   ENUM_NAME(PPW_CardBusRefresh),
   ENUM_NAME(PPW_CardBusDelay),
   {0,0}
};

PUCHAR DeviceTypeTable[] = {
    "Multifunction",
    "Memory card",
    "Serial",
    "Parallel",
    "ATA",
    "Video",
    "Network controller",
    "AIMS",
    "Scsi controller",
    "Modem"
};


VOID
DumpEnum(
        ULONG       EnumVal,
        PENUM_NAME EnumTable
        )
/*++

Routine Description:

    Prints the supplied enum value in a readable string format
    by looking it up in the supplied enum table

Arguments:

    EnumVal   -  Enum to be printed
    EnumTable -  Table in which the enum is looked up to find
                 the string to be printed

Return Value:

None

--*/
{
   ULONG i;

   for (i=0; EnumTable[i].Name != NULL; i++) {
      if (EnumTable[i].EnumVal == EnumVal) {
         break;
      }
   }
   if (EnumTable[i].Name != NULL) {
      dprintf("%s", EnumTable[i].Name);
   } else {
      dprintf("Unknown ");
   }
   return;
}

ULONG64
SocFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!SOCKET", Field, Temp);
    return Temp;
}


VOID
DumpSocket(ULONG64 Socket, ULONG Depth)
/*++

Routine Description

   Dumps the socket structure

Arguments

   Socket - Pointer to the socket structure
   Depth  - Indentation at which to print

Return Value

   None
--*/
{
    ULONG64 tmp;

    dprintf("\n");
    xdprintf(Depth,""); dprintf("NextSocket  0x%p\n", SocFld(Socket, "NextSocket"));
    xdprintf(Depth,""); dprintf("SocketFnPtr 0x%p\n", SocFld(Socket, "SocketFnPtr"));
    xdprintf(Depth,""); dprintf("Fdo devext  0x%p\n", SocFld(Socket, "DeviceExtension"));
    xdprintf(Depth,""); dprintf("PdoList     0x%p\n", SocFld(Socket, "PdoList"));
    DumpFlags(Depth, "Socket Flags", (ULONG) SocFld(Socket, "Flags"), PcmciaSocketFlags);

    xdprintf(Depth,"Revision 0x%x\n", (ULONG) SocFld(Socket, "Revision"));
    xdprintf(Depth,"SocketNumber 0x%x\n", (ULONG) SocFld(Socket, "SocketNumber"));
    xdprintf(Depth,"NumberOfFunctions %d\n", (ULONG) SocFld(Socket, "NumberOfFunctions"));
    xdprintf(Depth,"AddressPort 0x%x\n", (ULONG) SocFld(Socket, "AddressPort"));
    xdprintf(Depth,"RegisterOffset 0x%x\n", (ULONG) SocFld(Socket, "RegisterOffset"));
    xdprintf(Depth,"CBReg Base 0x%I64x size 0x%x\n",
             SocFld(Socket, "CardBusSocketRegisterBase"),
             SocFld(Socket, "CardBusSocketRegisterSize"));
    xdprintf(Depth,"CisCache 0x%x\n", (ULONG) SocFld(Socket, "CisCache"));

    if (tmp = SocFld(Socket, "PciDeviceRelations")) {
        xdprintf(Depth,"PciDeviceRelations 0x%p\n", tmp);
    }

    xdprintf(Depth,"PowerRequests     %d\n", (ULONG) SocFld(Socket, "PowerRequests"));
    xdprintf(Depth,"PowerWorker State: ");
    DumpEnum((ULONG) SocFld(Socket, "WorkerState"), PcmciaSocketPowerWorkerStates);
    dprintf("\n");
    if (SocFld(Socket, "WorkerState") != SPW_Stopped) {
        xdprintf(Depth,"  Worker Phase %d\n", (ULONG) SocFld(Socket, "WorkerPhase"));
        xdprintf(Depth,"  PowerData 0x%x\n", (ULONG) SocFld(Socket, "PowerData"));
        xdprintf(Depth,""); dprintf("  PowerCompletionRoutine 0x%p\n", SocFld(Socket, "PowerCompletionRoutine"));
        xdprintf(Depth,""); dprintf("  PowerCompletionContext 0x%p\n", SocFld(Socket, "PowerCompletionContext"));
        xdprintf(Depth,"  CallerStatus 0x%x\n", (ULONG) SocFld(Socket, "CallerStatus"));
        xdprintf(Depth,"  DeferredStatus 0x%x\n", (ULONG) SocFld(Socket, "DeferredStatus"));
        xdprintf(Depth,"  DeferredPowerRequests 0x%x\n", (ULONG) SocFld(Socket, "DeferredPowerRequests"));
    }
    dprintf("\n");
    return;
}


VOID
DumpDevicePowerState(IN DEVICE_POWER_STATE PowerState)
/*++

Routine Description

   Converts the supplied enum device power state to a
   string & dumps it.

Arguments

   PowerState  - Device power state

Return Value

    None
--*/
{

   dprintf("  DevicePowerState: ");
   switch (PowerState) {
   case PowerDeviceUnspecified: {
         dprintf("PowerDeviceUnspecfied\n");
         break;
      }
   case PowerDeviceD0: {
         dprintf("PowerDeviceD0\n");
         break;
      }
   case PowerDeviceD1: {
         dprintf("PowerDeviceD1\n");
         break;
      }
   case PowerDeviceD2: {
         dprintf("PowerDeviceD2\n");
         break;
      }
   case PowerDeviceD3: {
         dprintf("PowerDeviceD3\n");
         break;
      }
   default:
         dprintf("???\n");
   }
}


VOID
DumpSystemPowerState(IN SYSTEM_POWER_STATE PowerState)
/*++

Routine Description

   Converts the supplied enum system power state to a
   string & dumps it.

Arguments

   PowerState     - System power state

Return Value

   None
--*/
{
   dprintf("  SystemPowerState: ");
   switch (PowerState) {
   case PowerSystemUnspecified: {
         dprintf("PowerSystemUnspecfied\n");
         break;
      }
   case PowerSystemWorking:{
         dprintf("PowerSystemWorking\n");
         break;
      }
   case PowerSystemSleeping1: {
         dprintf("PowerSystemSleeping1\n");
         break;
      }
   case PowerSystemSleeping2: {
         dprintf("PowerSystemSleeping2\n");
         break;
      }
   case PowerSystemSleeping3: {
         dprintf("PowerSystemSleeping3\n");
         break;
      }
   case PowerSystemHibernate: {
         dprintf("PowerSystemHibernate\n");
         break;
      }
   case PowerSystemShutdown: {
         dprintf("PowerSystemShutdown\n");
         break;
      }
   default:
         dprintf("???\n");
   }
}



ULONG64
ConfigFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!SOCKET_CONFIGURATION", Field, Temp);
    return Temp;
}

VOID
DumpSocketConfiguration(ULONG64 Config, ULONG Depth)
/*++

Routine Description

   Dumps the current configuration of the socket

Arguments

   Config      - Pointer to the current configuration for the socket
   Depth       - Indentation at which to print

Return Value

   None

--*/
{

    ULONG i;
    ULONG NumberOfIoPortRanges, NumberOfMemoryRanges;
    CHAR  Buffer[40], Buffer2[40], Buffer3[40];

    xdprintf(Depth, "Irq      0x%x\n", (ULONG) ConfigFld(Config, "Irq"));
    xdprintf(Depth, "ReadyIrq 0x%x\n", (ULONG) ConfigFld(Config, "ReadyIrq"));
    if ((NumberOfIoPortRanges = (ULONG) ConfigFld(Config, "NumberOfIoPortRanges")) > 0) {
        xdprintf(Depth,
                 "%x I/O range(s) configured, %s: ",
                 NumberOfIoPortRanges,
                 (ConfigFld(Config, "Io16BitAccess") ? "16-bit access" : "8-bit access"));

        for (i = 0; i < NumberOfIoPortRanges; i++) {
            if (CheckControlC()) {
                break;
            }
            sprintf(Buffer, "IoPortBase[%d]", i);
            sprintf(Buffer2, "IoPortLength[%d]", i);
            xdprintf(Depth+1, "Base 0x%x, length 0x%x\n",
                     (ULONG) ConfigFld(Config, Buffer), (ULONG) ConfigFld(Config, Buffer2) +1);
        }
    }
    if ((NumberOfMemoryRanges = (ULONG) ConfigFld(Config, "NumberOfMemoryRanges")) > 0) {
        xdprintf(Depth, "%x memory range(s) configured", NumberOfMemoryRanges);
        if (ConfigFld(Config, "Mem16BitAccess")) {
            dprintf(", 16-bit access");
        } else {
            dprintf(", 8-bit access");
        }
        dprintf(":\n");

        for (i = 0; i < NumberOfMemoryRanges; i++) {
            if (CheckControlC()) {
                break;
            }
            sprintf(Buffer, "MemoryHostBase[%d]", i);
            sprintf(Buffer2, "MemoryCardBase[%d]", i);
            sprintf(Buffer3, "MemoryLength[%d]", i);
            xdprintf(Depth+1,"Host base 0x%x, card base 0x%x, length 0x%x\n",
                     (ULONG) ConfigFld(Config, Buffer), (ULONG) ConfigFld(Config, Buffer2),
                     (ULONG) ConfigFld(Config, Buffer3));
        }
    }
}


VOID
DumpIrqMask(ULONG IrqMask)
/*++

Routine Description

   Dumps IRQ values as specified by the supplied mask.

Arguments

   IrqMask - Values correspoinging to bits set to 1 in this mask are dumped:
             the value of a bit is 0-based, counted from LSB to MSB
Return Value

   None

--*/
{
   ULONG temp, index, count;

   temp =  1;
   index = 0;
   count = 0;

   while (temp) {
      if (temp & IrqMask) {
         if (count > 0) {
            //
            // Print trailing comma
            //
            dprintf(",");
         }
         dprintf("%x", index);
         count++;
      }
      temp <<= 1; index++;
   }
   dprintf("\n");

}


ULONG64
EntryFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!CONFIG_ENTRY", Field, Temp);
    return Temp;
}

VOID
DumpConfigEntry(ULONG64 Config, ULONG Depth)
/*++

Routine Description

   Dumps a single "config entry", i.e. the encapsulation of a
   CISTPL_CONFIG_ENTRY tuple on a pc-card

Arguments

   Config      - Pointer to the config entry
   Depth       - Indentation at which to print

Return Value

   None

--*/
{
    ULONG i;
    ULONG NumberOfIoPortRanges, NumberOfMemoryRanges, IrqMask;
    CHAR  buffer[40], buffer2[40], buffer3[40];

    if (EntryFld(Config, "Flags") & PCMCIA_INVALID_CONFIGURATION) {
        xdprintf(Depth, "**This is an invalid configuration**\n");
    }

    xdprintf(Depth, "Index: 0x%x\n", (ULONG) EntryFld(Config, "IndexForThisConfiguration"));

    if ((NumberOfIoPortRanges = (ULONG) EntryFld(Config, "NumberOfIoPortRanges")) > 0) {

        for (i = 0; i < NumberOfIoPortRanges; i++) {
            ULONG IoPortBase;

            if (CheckControlC()) {
                break;
            }
            sprintf(buffer,"IoPortBase[%d]",i);
            sprintf(buffer2,"IoPortLength[%d]",i);
            sprintf(buffer3,"IoPortAlignment[%d]",i);

            if ((IoPortBase = (ULONG) EntryFld(Config, buffer)) == 0) {
                xdprintf(Depth,"I/O Any range of ");
            } else {
                xdprintf(Depth,"I/O Base 0x%x, ", IoPortBase);
            }

            dprintf("length 0x%x, alignment 0x%x, ",
                    (ULONG) EntryFld(Config, buffer2)+1,
                    (ULONG) EntryFld(Config, buffer3));

            if (EntryFld(Config, "Io16BitAccess") && EntryFld(Config, "Io8BitAccess")) {
                dprintf("16/8-bit access");
            } else  if (EntryFld(Config, "Io16BitAccess")) {
                dprintf("16-bit access");
            } else if (EntryFld(Config, "Io8BitAccess")) {
                dprintf("8-bit access");
            }

            dprintf("\n");
        }
    }
    if ((NumberOfMemoryRanges = (ULONG) EntryFld(Config, "NumberOfMemoryRanges")) > 0) {

        for (i = 0; i < NumberOfMemoryRanges; i++) {
            if (CheckControlC()) {
                break;
            }
            sprintf(buffer,"MemoryHostBase[%d]",i);
            sprintf(buffer2,"MemoryCardBase[%d]",i);
            sprintf(buffer3,"MemoryLength[%d]",i);
            xdprintf(Depth,"MEM Host base 0x%x, card base 0x%x, len 0x%x\n",
                     (ULONG) EntryFld(Config, buffer),
                     (ULONG) EntryFld(Config, buffer2),
                     (ULONG) EntryFld(Config, buffer3));
        }
    }

    if ((IrqMask = (ULONG)  EntryFld(Config, "IrqMask")) != 0) {
        xdprintf(Depth,"IRQ - one of: ", IrqMask);
        DumpIrqMask(IrqMask);
   }
   //
   // Have to dump level/share disposition information some time..
   //
}


VOID
DumpPcCardType(UCHAR Type,
               ULONG Depth)
/*++

Routine Description

    Prints the device type of  the pc-card

Arguments

    Type    - Device type value
    Depth   - Indentation

Return value

    None

--*/
{
    PUCHAR s;

    xdprintf(Depth,"Device type: ");

    //
    // Type should be <= number of DeviceTypeTable  entries - 1
    //
    if ((ULONG) Type >= sizeof(DeviceTypeTable)) {
        dprintf("Unknown\n");
    } else {
        dprintf("%s\n", DeviceTypeTable[(ULONG) Type]);
    }
}


VOID
DumpConfigEntryChain(ULONG64 ConfigEntryChain,
                     ULONG   Depth)
/*++
Routine Description

    Dumps the chain of config entries

Arguments

    ConfigEntryChain -  pointer to head of config entry  list
    Depth            -  indentation
--*/
{
   ULONG64 ce;

   ce = ConfigEntryChain;
   while (ce != 0) {
      if (CheckControlC()) {
         break;
      }
      xdprintf(Depth, ""); dprintf("ConfigEntry: 0x%p\n", ce);
      if (!GetFieldValue(ce, "pcmcia!CONFIG_ENTRY", "NextEntry", ConfigEntryChain)) {
         DumpConfigEntry(ce, Depth+1);
         ce = ConfigEntryChain;
      } else {
         ce = 0;
      }
   }
}


ULONG64
SocDataFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!SOCKET_DATA", Field, Temp);
    return Temp;
}


VOID
DumpSocketData(ULONG64 SocketData, ULONG Depth)
/*++

Routine Description

   Dumps the socket data structure hanging off the device extension
   for a pc-card pdo, which describes in entirety the pc-card, it's
   resource/power requirements etc.

Arguments

   SocketData     - Pointer to the socket data structure
   Depth          - Indentation at which to print

Return Value

   None

--*/
{
    ULONG d;
    CHAR Mfg[80]={0}, Ident[80]={0};
    ULONG64 DefaultConfiguration;

    xdprintf(Depth, "");
    dprintf("NextSocketData 0x%p PrevSocketData 0x%p\n",
             SocDataFld(SocketData, "Next"), SocDataFld(SocketData, "Prev"));
    xdprintf(Depth, ""); dprintf("PdoExtension   0x%p\n", SocDataFld(SocketData, "PdoExtension"));
    GetFieldValue(SocketData, "pcmcia!SOCKET_DATA", "Mfg", Mfg);
    GetFieldValue(SocketData, "pcmcia!SOCKET_DATA", "Ident", Ident);
    xdprintf(Depth, "Manufacturer: %s Identifier: %s\n", Mfg, Ident);

    DumpPcCardType((UCHAR) SocDataFld(SocketData, "DeviceType"), Depth);

    xdprintf(Depth,"CisCrc: 0x%X  LastEntryInCardConfig: 0x%x\n",
             (ULONG) SocDataFld(SocketData, "CisCrc"), (ULONG) SocDataFld(SocketData, "LastEntryInCardConfig"));
    xdprintf(Depth, "Manufacturer Code: 0x%x Info: 0x%x\n",
             (ULONG) SocDataFld(SocketData, "ManufacturerCode"),
             (ULONG) SocDataFld(SocketData, "ManufacturerInfo"));
    xdprintf(Depth, "Config Register Base: 0x%I64x\n", SocDataFld(SocketData, "ConfigRegisterBase"));
    //
    // Dump all the config entries hanging off this socket's pc-card
    //
    DumpConfigEntryChain(SocDataFld(SocketData, "ConfigEntryChain"), Depth);

    xdprintf(Depth, ""); dprintf("Default Configuration: 0x%p\n",
             (DefaultConfiguration = SocDataFld(SocketData, "DefaultConfiguration")));
    if (DefaultConfiguration != 0) {
        DumpConfigEntry(DefaultConfiguration, Depth+1);
    }

    xdprintf(Depth,"Vcc: 0x%x Vpp1: 0x%x Vpp2 0x%x\n",
             (ULONG) SocDataFld(SocketData, "Vcc"),
             (ULONG) SocDataFld(SocketData, "Vpp1"),
             (ULONG) SocDataFld(SocketData, "Vpp2"));
    xdprintf(Depth,"Audio: 0x%x RegistersPresentMask 0x%x\n",
             (ULONG) SocDataFld(SocketData, "Audio"),
             (ULONG) SocDataFld(SocketData, "RegistersPresentMask"));
    xdprintf(Depth, "ConfigIndex used for current card configuration: 0x%x\n",
             (ULONG) SocDataFld(SocketData, "ConfigIndexUsed"));
    xdprintf(Depth, "Function number (in a multifunc. card): 0x%x\n",
             (ULONG) SocDataFld(SocketData, "Function"));
    xdprintf(Depth, "Instance number: 0x%x\n", (ULONG) SocDataFld(SocketData, "Instance"));
    xdprintf(Depth, "Mf ResourceMap: irq index %x.%x, i/o index %x.%x, mem index %x.%x\n",
                   (ULONG) SocDataFld(SocketData, "MfIrqResourceMapIndex"),
                   (ULONG) SocDataFld(SocketData, "MfNeedsIrq"),
                   (ULONG) SocDataFld(SocketData, "MfIoPortResourceMapIndex"),
                   (ULONG) SocDataFld(SocketData, "MfIoPortCount"),
                   (ULONG) SocDataFld(SocketData, "MfMemoryResourceMapIndex"),
                   (ULONG) SocDataFld(SocketData, "MfMemoryCount"));
}


ULONG64
PDOxFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!PDO_EXTENSION", Field, Temp);
    return Temp;
}

ULONG64
FDOxFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!FDO_EXTENSION", Field, Temp);
    return Temp;
}


VOID
DevExtPcmcia(
    ULONG64 Extension
    )

/*++

Routine Description:

    Dump a PCMCIA Device extension.

Arguments:

    Extension   Address of the extension to be dumped.

Return Value:

    None.

--*/
{
   ULONG64  DeviceObject=0;
   ULONG64  socketDataPtr;
   ULONG    Flags, depth;

   if (!ReadPointer(Extension, &DeviceObject)) {
      dprintf(
             "Failed to read PCMCIA extension at %08p, giving up.\n",
             Extension
             );
      return;
   }

   if (GetFieldValue(DeviceObject, "nt!_DEVICE_OBJECT", "Flags", Flags)) {
      return;
   }

   if (Flags & DO_BUS_ENUMERATED_DEVICE) {
      //
      // This is the extension for a PC-Card PDO
      //
      ULONG64       socketPtr, Capabilities;
      ULONG64       DeviceId;
      UCHAR         deviceId[PCMCIA_MAXIMUM_DEVICE_ID_LENGTH];

      if (GetFieldValue(Extension, "pcmcia!PDO_EXTENSION", "DeviceId", DeviceId)) {
         return;
      }

      dprintf("PDO Extension, Device Object 0x%p\n",PDOxFld(Extension, "DeviceObject"));

      DumpFlags(0, "  Device Flags", (ULONG) PDOxFld(Extension, "Flags"), PcmciaDeviceFlags);

      dprintf("  NextPdo 0x%p LowerDevice 0x%p PciPdo 0x%p\n",
              PDOxFld(Extension, "NextPdoInFdoChain"),
              PDOxFld(Extension, "LowerDevice"),
              PDOxFld(Extension, "PciPdo"));

      dprintf("  DeviceId 0x%p: ", DeviceId);
      if (DeviceId != 0) {
          ULONG status;

          ReadMemory(DeviceId, deviceId, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH, &status);
          dprintf("%s", deviceId);
      }
      dprintf("\n");

      dprintf("  Socket: 0x%x\n", PDOxFld(Extension, "Socket"));

      socketDataPtr = PDOxFld(Extension, "SocketData");
      while (socketDataPtr != 0) {
          //
          // Dump socket data structure
          //
          dprintf("  SocketData 0x%x\n", socketDataPtr);
          DumpSocketData(socketDataPtr, 2);

          socketDataPtr = SocDataFld(socketDataPtr, "Next");
      }

      DumpDevicePowerState((ULONG) PDOxFld(Extension, "DevicePowerState"));
      DumpSystemPowerState((ULONG) PDOxFld(Extension, "SystemPowerState"));
      dprintf("  WaitWakeIrp 0x%p\n", PDOxFld(Extension, "WaitWakeIrp"));
      dprintf("  PendingPowerIrp 0x%p\n", PDOxFld(Extension, "PendingPowerIrp"));
      dprintf("  DeviceCapabilities (at 0x%p): \n", (Capabilities = PDOxFld(Extension, "Capabilities")));
      if (Capabilities != 0) {
          DumpDeviceCapabilities(Capabilities);
      }

      dprintf("  ConfigurationPhase: %d\n", (ULONG) PDOxFld(Extension, "ConfigurationPhase"));

      dprintf("  PowerWorker State: ");
      DumpEnum((ULONG) PDOxFld(Extension, "PowerWorkerState"), PcmciaPdoPowerWorkerStates);
      dprintf("\n");
      if ((ULONG) PDOxFld(Extension, "PowerWorkerState") != PPW_Stopped) {
         dprintf("    Worker Phase %d\n", (ULONG) PDOxFld(Extension, "PowerWorkerPhase"));
         dprintf("    Worker Sequence 0x%x\n", (ULONG) PDOxFld(Extension, "PowerWorkerSequence"));
      }



   } else {
      //
      // This is the extension for the pcmcia controller FDO
      //
      ULONG64       addr, PdoList, NextFdo, Capabilities;
      ULONG         depth;
      ULONG         model, revision;
      ULONG         ControllerType, off;


      if (GetFieldValue(Extension, "pcmcia!FDO_EXTENSION", "PdoList", PdoList)) {
         return;
      }
      dprintf("FDO Extension, Device Object 0x%p\n", FDOxFld(Extension, "DeviceObject"));
      dprintf("  DriverObject 0x%p, RegistryPath 0x%p\n",
              FDOxFld(Extension, "DriverObject"), FDOxFld(Extension, "RegistryPath"));

      DumpFlags(0, "  Device Flags", (ULONG) FDOxFld(Extension, "Flags"), PcmciaDeviceFlags);

      dprintf("  ControllerType (%x): ", (ControllerType = (ULONG) FDOxFld(Extension, "ControllerType")));
      DumpEnum(PcmciaClassFromControllerType(ControllerType), PcmciaControllerTypeEnum);
      if (model = PcmciaModelFromControllerType(ControllerType)) {
         dprintf("%d", model);
      }
      if (revision = PcmciaRevisionFromControllerType(ControllerType)) {
         dprintf(", rev(%d)", revision);
      }
      dprintf("\n");

      dprintf("  Child PdoList head 0x%p ", PdoList);

      GetFieldOffset("nt!_DEVICE_OBJECT","DeviceExtension", &off);
      if ((PdoList != 0) &&
          ReadPointer( PdoList + off ,
                      &addr)) {
         dprintf("device extension 0x%p\n", addr);
      } else {
         dprintf("\n");
      }

      dprintf("  LivePdoCount       0x%x\n", (ULONG)  FDOxFld(Extension, "LivePdoCount"));
      dprintf("  NextFdo            0x%p ",  (NextFdo = FDOxFld(Extension, "NextFdo")));
      if ((NextFdo != 0) &&
          ReadPointer(NextFdo + off,
                      &addr)) {
         dprintf("device extension 0x%p\n", addr);
      } else {
         dprintf("\n");
      }
      dprintf("  Pdo (for this fdo) 0x%p\n", FDOxFld(Extension, "Pdo"));
      dprintf("  LowerDevice        0x%p\n", FDOxFld(Extension, "LowerDevice"));
      dprintf("  SocketList         0x%p\n", FDOxFld(Extension, "SocketList"));

      dprintf("  IRQ mask 0x%x allows IRQs: ", (ULONG) FDOxFld(Extension, "AllocatedIrqMask"));
      DumpIrqMask((ULONG) FDOxFld(Extension, "AllocatedIrqMask"));
      dprintf("  Memory window physical address 0x%p\n", FDOxFld(Extension, "PhysicalBase"));
      dprintf("  Memory window virtual  address 0x%p\n", FDOxFld(Extension, "AttributeMemoryBase"));
      dprintf("  Memory window size  0x%x\n", (ULONG) FDOxFld(Extension, "AttributeMemorySize"));
      dprintf("  DeviceDispatchIndex %x\n", (ULONG) FDOxFld(Extension, "DeviceDispatchIndex"));
      dprintf("  PCCard Ready Delay Iterations 0x%x (%d)\n",
              (ULONG) FDOxFld(Extension, "ReadyDelayIter"), (ULONG) FDOxFld(Extension, "ReadyDelayIter"));
      dprintf("  PCCard Ready Stall in usecs   0x%x (%d)\n",
              (ULONG) FDOxFld(Extension, "ReadyStall"), (ULONG) FDOxFld(Extension, "ReadyStall"));

      dprintf("  Number of sockets powered up        %d\n",
              (ULONG) FDOxFld(Extension, "NumberOfSocketsPoweredUp"));
      DumpDevicePowerState((ULONG) FDOxFld(Extension, "DevicePowerState"));
      DumpSystemPowerState((ULONG) FDOxFld(Extension, "SystemPowerState"));

      //
      // Pending wait wake irp
      //
      dprintf("  WaitWakeIrp: %p\n", FDOxFld(Extension, "WaitWakeIrp"));

      //
      // Dump saved register context
      //
      dprintf("  PCI     Context range, buffer: %p(%d), %p\n",
              FDOxFld(Extension, "PciContext.Range"), (ULONG) FDOxFld(Extension, "PciContext.RangeCount"),
              FDOxFld(Extension, "PciContextBuffer"));
      dprintf("  Cardbus Context range: %p(%d)\n",
              FDOxFld(Extension, "CardbusContext.Range"), (ULONG) FDOxFld(Extension, "CardbusContext.RangeCount"));
      dprintf("  Exca    Context range: %p(%d)\n",
              FDOxFld(Extension, "ExcaContext.Range"), (ULONG) FDOxFld(Extension, "ExcaContext.RangeCount"));

      //
      // Dump capabilities
      //
      dprintf("  DeviceCapabilities (at 0x%p): \n", (Capabilities = FDOxFld(Extension, "Capabilities")));
      if (Capabilities != 0) {
          DumpDeviceCapabilities(Capabilities);
      }
   }
}

DECLARE_API( socket )

/*++

Routine Description:

    Dump a socket

Arguments:

    args - the location of the socket to dump

Return Value:

    None

--*/
{
    ULONG64 socketAddr=0;
    ULONG   depth, status;

    socketAddr = GetExpression(args);

    if (ReadMemory(socketAddr, &depth, sizeof(depth), &status)) {
        dprintf("Socket at %p:\n", socketAddr);
        DumpSocket(socketAddr, 0);
    } else {
        dprintf("Could not read socket at %p\n", socketAddr);
    }
    return S_OK;
}

VOID
DumpFlagsBrief(ULONG Flags)
{
    if (Flags & PCMCIA_DEVICE_STARTED) {
        dprintf(" ST");
    } else {
        dprintf(" NS");
    }

    if (Flags & PCMCIA_DEVICE_LOGICALLY_REMOVED) {
        dprintf(" RM");
    }
    if (Flags & PCMCIA_DEVICE_PHYSICALLY_REMOVED) {
        dprintf(" EJ");
    }
    if (Flags & PCMCIA_DEVICE_DELETED) {
        dprintf(" DL");
    }
    if (Flags & PCMCIA_DEVICE_MULTIFUNCTION) {
        dprintf(" MF");
    }
    if (Flags & PCMCIA_DEVICE_WAKE_PENDING) {
        dprintf(" WP");
    }
    if (Flags & PCMCIA_DEVICE_LEGACY_DETECTED) {
        dprintf(" LD");
    }
    if (Flags & PCMCIA_DEVICE_CARDBUS) {
        dprintf(" CB");
    }
}


DECLARE_API( pcmcia )

/*++

Routine Description:

    Dumps overview of pcmcia driver state

Arguments:

    args - the location of the socket to dump

Return Value:

    None

--*/
{
   ULONG64 addr;
   ULONG64 fdoDevObj, pdoDevObj, pSocket;
   ULONG64 Extension;
   ULONG Count = 0, off;
   UCHAR deviceId[PCMCIA_MAXIMUM_DEVICE_ID_LENGTH];

   if (args[0] != '\0') {
      dprintf("!pcmcia - dumps general pcmcia driver state\n\n");
      dprintf("flag descriptions:\n");
      dprintf(" ST - Started\n");
      dprintf(" NS - Not Started\n");
      dprintf(" RM - Logically Removed\n");
      dprintf(" EJ - Physically Ejected\n");
      dprintf(" DL - Deleted\n");
      dprintf(" MF - MultiFunction\n");
      dprintf(" WP - Wake Pending\n");
      dprintf(" LD - Legacy Detected\n");
      dprintf(" CB - CardBus\n");
   }


   addr = GetExpression( "pcmcia!fdolist" );

   if (addr == 0) {
      dprintf("Error retrieving address of pcmcia!fdolist\n");
      return E_INVALIDARG;
   }

   if (!ReadPointer(addr, &fdoDevObj)) {
      dprintf("Failed to read fdolist at %08p, giving up.\n", addr);
      return E_INVALIDARG;
   }

   GetFieldOffset("nt!_DEVICE_OBJECT", "DeviceExtension", &off);

   while(fdoDevObj) {
       ULONG64 NextFdo;
       ULONG64 CbReg;

       if (CheckControlC()) {
           break;
       }

       if (!ReadPointer(fdoDevObj+off,&Extension)) {
           dprintf("Failed to read fdo extension address at %08p, giving up.\n", fdoDevObj+off);
           return E_INVALIDARG;
       }

       if (GetFieldValue(Extension, "pcmcia!FDO_EXTENSION", "NextFdo", NextFdo)) {
           dprintf("GetFieldValue failed for fdo extension at %08p, giving up.\n", Extension);
           return E_INVALIDARG;
       }

       dprintf("\nFDO %.8p ext %.8p\n", fdoDevObj, Extension);

       if (GetFieldValue(Extension, "pcmcia!FDO_EXTENSION", "CardBusSocketRegisterBase", CbReg)) {
           dprintf("GetFieldValue failed for fdo extension at %08p, giving up.\n", Extension);
           return E_INVALIDARG;
       }

       if (CbReg) {
          dprintf("    CbReg %.8p\n\n", CbReg);
       } else {
          dprintf("\n");
       }

       //
       // Print list of PDOs enumerated by this FDO
       //

      pdoDevObj = FDOxFld(Extension, "PdoList");
      pSocket = FDOxFld(Extension, "SocketList");
      if (!pdoDevObj) {
          xdprintf(2, "*no PDO's enumerated*\n");
      } else {
         xdprintf(2, "pdolist:");
      }
      while(pdoDevObj) {
         if (CheckControlC()) {
            break;
         }
         if (!ReadPointer(pdoDevObj+off,&Extension)) {
            return E_INVALIDARG;
         }
         dprintf("  %.8p", pdoDevObj);
         pdoDevObj = PDOxFld(Extension, "NextPdoInFdoChain");
      }
      dprintf("\n");

      //
      // Print list of sockets
      //

      if (!pSocket) {
         xdprintf(2, "*no sockets!*\n");
      }
      while(pSocket) {
          ULONG64 NextSocket;
          ULONG SocketNumber;
          if (CheckControlC()) {
              break;
          }

          if (GetFieldValue(pSocket, "pcmcia!SOCKET", "NextSocket", NextSocket)) {
              return E_INVALIDARG;
          }

          dprintf("  Socket %.8p\n", pSocket);
          dprintf("   base %.8p", SocFld(pSocket, "AddressPort"));
          if (SocketNumber = (ULONG) SocFld(pSocket, "SocketNumber")) {
              dprintf(".%d", SocketNumber);
          }
          dprintf("\n");

         //
         // Dump pdo's in socket list
         //
         pdoDevObj = SocFld(pSocket, "PdoList");
         if (!pdoDevObj) {
            xdprintf(3, "*empty*\n");
         }
         while(pdoDevObj) {
             ULONG64 DeviceId;
             ULONG status;

             if (CheckControlC()) {
                 break;
             }
             if (!ReadPointer(pdoDevObj + off,&Extension)) {
                 return E_INVALIDARG;
             }
             if (GetFieldValue(Extension, "pcmcia!PDO_EXTENSION", "DeviceId", DeviceId)) {
                 return E_INVALIDARG;
             }

             dprintf("   PDO %.8p ext %.8p", pdoDevObj, Extension);
             DumpFlagsBrief((ULONG) PDOxFld(Extension, "Flags"));
             dprintf("\n");

            if (DeviceId != 0) {
               ReadMemory(DeviceId, deviceId, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH, &status);
               dprintf("    %s\n", deviceId);
            }
            pdoDevObj = PDOxFld(Extension, "NextPdoInSocket");
         }

         pSocket = NextSocket;
      }

      fdoDevObj = NextFdo;
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\physical.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


/*++

Routine Description:

    Reverse sign extension of the value returned by GetExpression()
    based on the assumption that no physical address may be bigger 
    than 0xfffffff00000000.

Arguments:

    Val - points to the value to reverse sign extension

Return Value:

    None.

--*/

void
ReverseSignExtension(ULONG64* Val)
{
    if ((*Val & 0xffffffff00000000) == 0xffffffff00000000) 
    {
        *Val &= 0x00000000ffffffff;
    }
}


DECLARE_API( chklowmem )

/*++

Routine Description:

    Calls an Mm function that checks if the physical pages
    below 4Gb have a required fill pattern for PAE systems
    booted with /LOWMEM switch.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (Client);

    dprintf ("Checking the low 4GB of RAM for required fill pattern. \n");
    dprintf ("Please wait (verification takes approx. 20s) ...\n");

    Ioctl (IG_LOWMEM_CHECK, NULL, 0);

    dprintf ("Lowmem check done.\n");
    return S_OK;
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////// !search
/////////////////////////////////////////////////////////////////////

//
//  Kernel variable modification functions.
//
            
ULONG 
READ_ULONG (
    ULONG64 Address
    );

VOID
WRITE_ULONG (
    ULONG64 Address,
    ULONG Value
    );

ULONG64
READ_PVOID (
    ULONG64 Address
    );


ULONG
READ_PHYSICAL_ULONG (
    ULONG64 Address
    );

ULONG64
READ_PHYSICAL_ULONG64 (
    ULONG64 Address
    );


ULONG64
SearchGetSystemMemoryDescriptor (
    );

ULONG64
SearchConvertPageFrameToVa (
    ULONG64 PageFrameIndex,
    PULONG Flags,
    PULONG64 PteAddress
    );

#define SEARCH_VA_PROTOTYPE_ADDRESS     0x0001
#define SEARCH_VA_NORMAL_ADDRESS        0x0002
#define SEARCH_VA_LARGE_PAGE_ADDRESS    0x0004
#define SEARCH_VA_UNKNOWN_TYPE_ADDRESS  0x0008

//
// PAE independent functions from p_i386\pte.c
//

ULONG64
DbgGetPdeAddress(
    IN ULONG64 VirtualAddress
    );

ULONG64
DbgGetPteAddress(
    IN ULONG64 VirtualAddress
    );

#define BANG_SEARCH_HELP \
"\n\
!search ADDRESS [DELTA [START_PFN END_PFN]]                     \n\
                                                                \n\
Search the physical pages in range [START_PFN..END_PFN]         \n\
for ULONG_PTRs with values in range ADDRESS+/-DELTA or values   \n\
that differ in only one bit position from ADDRESS.              \n\
                                                                \n\
The default value for DELTA is 0. For START/END_PFN the default \n\
values are lowest physical page and highest physical page.      \n\
                                                                \n\
Examples:                                                       \n\
                                                                \n\
!search AABBCCDD 0A                                             \n\
                                                                \n\
    Search all physical memory for values in range AABBCCD3 -   \n\
    AABBCCE8 or with only one bit different than AABBCCDD.      \n\
                                                                \n\
!search AABBCCDD 0A 13F 240                                     \n\
                                                                \n\
    Search page frames in range 13F - 240 for values in range   \n\
    AABBCCD3 - AABBCCE8 or with only one bit different          \n\
    than AABBCCDD.                                              \n\
                                                                \n\
By default only the first hit in the page is detected. If all   \n\
hits within the page are needed the START_PFN and END_PFN       \n\
must have the same value.                                       \n\
                                                                \n\
Note that a search through the entire physical memory will find \n\
hits in the search engine structures. By doing a search with a  \n\
completely different value it can be deduced what hits can be   \n\
ignored.                                                      \n\n"

        
//
// Comment this to get verbose output.
//
// #define _INTERNAL_DEBUG_
//


DECLARE_API( search )

/*++

Routine Description:

    This routine triggers a search within a given physical
    memory range for a pointer. The hits are defined by
    an interval (below and above the pointer value) and also
    by a Hamming distance equal to one (only one bit different).

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    const ULONG SEARCH_SYMBOL_CHECK = 0xABCDDCBA;

    ULONG64 ParamAddress;
    ULONG64 ParamDelta;
    ULONG64 ParamStart;
    ULONG64 ParamEnd;

    ULONG64 KdpSearchPageHits;
    ULONG64 KdpSearchPageHitOffsets;
    ULONG64 KdpSearchPageHitIndex;

    ULONG64 KdpSearchCheckPoint;
    ULONG64 KdpSearchInProgress;

    ULONG64 KdpSearchStartPageFrame;
    ULONG64 KdpSearchEndPageFrame;

    ULONG64 KdpSearchAddressRangeStart;
    ULONG64 KdpSearchAddressRangeEnd;

    ULONG64 MmLowestPhysicalPage;
    ULONG64 MmHighestPhysicalPage;

    ULONG64 PageFrame;
    ULONG64 StartPage;
    ULONG64 EndPage;
    ULONG64 RunStartPage;
    ULONG64 RunEndPage;
    ULONG RunIndex;

    BOOLEAN RequestForInterrupt;
    BOOLEAN RequestAllOffsets;
    ULONG Hits;
    ULONG Index;
    ULONG64 PfnHit;
    ULONG64 VaHit;
    ULONG VaFlags;
    ULONG PfnOffset;
    ULONG64 AddressStart;
    ULONG64 AddressEnd;
    ULONG DefaultRange;
    ULONG64 MemoryDescriptor;
    ULONG64 PageCount, BasePage, NumberOfPages;
    ULONG   NumberOfRuns;

    ULONG   SizeOfPfnNumber = 0;
    ULONG64 PteAddress;
    BOOLEAN On64Bits;

    UNREFERENCED_PARAMETER (Client);

    switch (TargetMachine) {
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
            On64Bits = TRUE;
            break;
        default:
            On64Bits = FALSE;
            break;
    }

    SizeOfPfnNumber = GetTypeSize("nt!PFN_NUMBER");

    if (SizeOfPfnNumber == 0) {
        dprintf ("Search: cannot get size of PFN_NUMBER \n");
        return E_INVALIDARG;
    }

    RequestForInterrupt = FALSE;
    RequestAllOffsets = FALSE;
    DefaultRange = 128;

    ParamAddress = 0;
    ParamDelta = 0;
    ParamStart = 0;
    ParamEnd = 0;
    
    //
    // Help requested ?
    //

    if (strstr (args, "?") != 0) {

        dprintf (BANG_SEARCH_HELP);
        return S_OK;
        
    }
    
    //
    // Get command line arguments.
    //

    {
        PCHAR Current = (PCHAR)args;
        CHAR Buffer [64];
        ULONG Index;
        ULONG BufferIndex;

        //
        // Get the 4 numeric arguments.
        //

        for (Index = 0; Index < 4; Index++) {

            //
            // Get rid of any leading spaces.
            //

            while (*Current == ' ' || *Current == '\t') {
                Current++;
            }
            
            if (*Current == 0) {

                if (Index == 0) {
                    
                    dprintf (BANG_SEARCH_HELP);
                    return E_INVALIDARG;
                }
                else {

                    break;
                }
            }

            //
            // Get the digits from the Index-th parameter.
            //

            Buffer [0] = '0';
            Buffer [1] = 'x';
            BufferIndex = 2;

            while ((*Current >= '0' && *Current <= '9')
                   || (*Current >= 'a' && *Current <= 'f')
                   || (*Current >= 'A' && *Current <= 'F')) {
                
                Buffer[BufferIndex] = *Current;
                Buffer[BufferIndex + 1] = 0;

                Current += 1;
                BufferIndex += 1;
            }

            switch (Index) {
                
                case 0: ParamAddress = GetExpression(Buffer); break;
                case 1: ParamDelta = GetExpression(Buffer); break;
                case 2: ParamStart = GetExpression(Buffer); break;
                case 3: ParamEnd = GetExpression(Buffer); break; 

                default: 
                        dprintf (BANG_SEARCH_HELP);
                        return E_INVALIDARG;
            }
        }
    }

    //
    // Verify that we have the right symbols.
    //

    KdpSearchCheckPoint = GetExpression ("nt!KdpSearchCheckPoint");

    if (KdpSearchCheckPoint == 0 
        || READ_ULONG (KdpSearchCheckPoint) != SEARCH_SYMBOL_CHECK) {

        dprintf ("Search error: Incorrect symbols for kernel\n");
        return E_INVALIDARG;
    }

    //
    // Get all symbol values so that we can manipulate only addresses
    // from now on.
    //

    KdpSearchPageHits =  GetExpression ("nt!KdpSearchPageHits");
    KdpSearchPageHitOffsets =  GetExpression ("nt!KdpSearchPageHitOffsets");
    KdpSearchPageHitIndex =  GetExpression ("nt!KdpSearchPageHitIndex");
    KdpSearchInProgress =  GetExpression ("nt!KdpSearchInProgress");
    KdpSearchStartPageFrame =  GetExpression ("nt!KdpSearchStartPageFrame");
    KdpSearchEndPageFrame =  GetExpression ("nt!KdpSearchEndPageFrame");
    KdpSearchAddressRangeStart =  GetExpression ("nt!KdpSearchAddressRangeStart");
    KdpSearchAddressRangeEnd =  GetExpression ("nt!KdpSearchAddressRangeEnd");
    
    //
    // Perform some sanity checks on the values.
    //

    if (READ_ULONG (KdpSearchInProgress) != 0) {
        dprintf ("Search error: Inconsistent value for nt!KdpSearchInProgress \n");
        return E_INVALIDARG;
    }

    //
    // Reset the search engine
    //

    WRITE_ULONG (KdpSearchPageHitIndex, 0);
    WRITE_ULONG (KdpSearchInProgress, 1);

    //
    // Read physical memory limits.
    //

    MmLowestPhysicalPage =  GetExpression ("nt!MmLowestPhysicalPage");
    MmHighestPhysicalPage =  GetExpression ("nt!MmHighestPhysicalPage");

#ifdef _INTERNAL_DEBUG_

    dprintf ("Low: %I64X, High: %I64X \n", 
             READ_PVOID (MmLowestPhysicalPage),
             READ_PVOID (MmHighestPhysicalPage));


#endif // #ifdef _INTERNAL_DEBUG_

    //
    // Figure out proper search parameters.
    //

    if (ParamStart == 0) {
        StartPage = READ_PVOID (MmLowestPhysicalPage);
        ParamStart = StartPage;
    }
    else {
        StartPage = ParamStart;
    }

    if (ParamEnd == 0) {
        EndPage = READ_PVOID (MmHighestPhysicalPage);
        ParamEnd = EndPage;
    }
    else {
        EndPage = ParamEnd;
    }

    //
    // Set range of addresses that we want to be searched.
    //

    AddressStart = ParamAddress - ParamDelta;
    AddressEnd = ParamAddress + ParamDelta;

    WritePointer (KdpSearchAddressRangeStart, AddressStart);
    WritePointer (KdpSearchAddressRangeEnd, AddressEnd);

    if (SizeOfPfnNumber == 8) {
        
        dprintf ("Searching PFNs in range %016I64X - %016I64X for [%016I64X - %016I64X]\n\n", 
                 StartPage, EndPage, AddressStart, AddressEnd);
        dprintf ("%-16s %-8s %-16s %-16s %-16s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - ");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    else {

        dprintf ("Searching PFNs in range %08I64X - %08I64X for [%08I64X - %08I64X]\n\n", 
                 StartPage, EndPage, AddressStart, AddressEnd);
        dprintf ("%-8s %-8s %-8s %-8s %-8s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    
    //
    // Get system memory description to figure out what ranges
    // should we skip. This is important for sparse PFN database
    // and for pages managed by drivers.
    //

    MemoryDescriptor = SearchGetSystemMemoryDescriptor ();

    if (MemoryDescriptor == 0) {
        dprintf ("Search error: cannot allocate system memory descriptor \n");
        return E_INVALIDARG;
    }

    //
    // Search all physical memory in the specified range.
    //

    WRITE_ULONG (KdpSearchPageHitIndex, 0);

    if (StartPage == EndPage) {

        EndPage += 1;
        RequestAllOffsets = TRUE;
    }

    //
    // Find out what pages are physically available create
    // page search ranges based on that.
    //
    // SilviuC: I should use ReadField to read all these structures
    // so that I do not have to take into account padding myself.
    //

    NumberOfRuns = READ_ULONG (MemoryDescriptor);
    NumberOfPages = READ_PVOID (MemoryDescriptor + SizeOfPfnNumber);

#ifdef _INTERNAL_DEBUG_

    dprintf ("Runs: %x, Pages: %I64X \n", NumberOfRuns, NumberOfPages);

    for (RunIndex = 0; RunIndex < NumberOfRuns; RunIndex += 1) {

        ULONG64 RunAddress;

        RunAddress = MemoryDescriptor + 2 * SizeOfPfnNumber
            + RunIndex * GetTypeSize("nt!_PHYSICAL_MEMORY_RUN");

        BasePage = READ_PVOID (RunAddress);
        PageCount = READ_PVOID (RunAddress + SizeOfPfnNumber);

        dprintf ("Run[%d]: Base: %I64X, Count: %I64X \n",
            RunIndex, BasePage, PageCount);
    }
#endif // #if _INTERNAL_DEBUG_

#ifdef _INTERNAL_DEBUG_
    dprintf ("StartPage: %I64X, EndPage: %I64X \n", StartPage, EndPage);
#endif // #ifdef _INTERNAL_DEBUG_

    for (PageFrame = StartPage; PageFrame < EndPage; PageFrame += DefaultRange) {

        for (RunIndex = 0; RunIndex < NumberOfRuns; RunIndex += 1) {
            
            //
            // BaseAddress and PageCount for current memory run.
            //

            ULONG64 RunAddress;

#ifdef _INTERNAL_DEBUG_
            // dprintf ("Finding a good range ... \n");
#endif // #ifdef _INTERNAL_DEBUG_

            RunAddress = MemoryDescriptor + 2 * SizeOfPfnNumber
                + RunIndex * GetTypeSize("nt!_PHYSICAL_MEMORY_RUN");

            BasePage = READ_PVOID (RunAddress);
            PageCount = READ_PVOID (RunAddress + SizeOfPfnNumber);

            //
            // Figure out real start and end page.
            //

            RunStartPage = PageFrame;
            RunEndPage = PageFrame + DefaultRange;

            if (RunEndPage < BasePage) {
                continue;
            }
            
            if (RunStartPage >= BasePage + PageCount) {
                continue;
            }
            
            if (RunStartPage < BasePage) {
                RunStartPage = BasePage;
            }

            if (RunEndPage > BasePage + PageCount) {
                RunEndPage = BasePage + PageCount;
            }

            WritePointer (KdpSearchStartPageFrame, RunStartPage);

            if (RequestAllOffsets) {

                //
                // If the search is in only one page then we
                // will try to get all offsets with a hit.
                //

                WritePointer (KdpSearchEndPageFrame, RunStartPage);
            }
            else {

                WritePointer (KdpSearchEndPageFrame, RunEndPage);
            }

#ifdef _INTERNAL_DEBUG_
            dprintf ("Start: %I64X, End: %I64X \n", 
                     READ_PVOID(KdpSearchStartPageFrame),
                     READ_PVOID(KdpSearchEndPageFrame));
#endif // #if _INTERNAL_DEBUG_

            //
            // Reset search index
            //

            WRITE_ULONG (KdpSearchPageHitIndex, 0);

            //
            // Invalidate kd cache
            //

            WRITE_ULONG (KdpSearchPageHits, 0);
            WRITE_ULONG (KdpSearchPageHitOffsets, 0);

            //
            // This is the trigger for memory search. We piggy back on the same
            // code as for !chklowmem and the logic in kernel detects what 
            // we really want to do.
            //

            Ioctl (IG_LOWMEM_CHECK, NULL, 0);

            //
            // Display results
            //

            Hits = READ_ULONG (KdpSearchPageHitIndex);

            for (Index = 0; Index < Hits; Index++) {

                PCHAR VaString = "";

                VaFlags = 0;

                PfnHit = READ_PVOID (KdpSearchPageHits + Index * SizeOfPfnNumber);
                PfnOffset = READ_ULONG (KdpSearchPageHitOffsets + Index * sizeof (ULONG));
                VaHit = SearchConvertPageFrameToVa (PfnHit, &VaFlags, &PteAddress);

                // dprintf ("Hits: %u, Index: %u, Va: %I64X \n", Hits, Index, VaHit);

                PfnOffset &= (ULONG)0xFFFF;

#if DBG
                if ((VaFlags & SEARCH_VA_NORMAL_ADDRESS)) {
                    VaString = ""; // "normal";
                }
                else if ((VaFlags & SEARCH_VA_LARGE_PAGE_ADDRESS)) {
                    VaString = "large page";
                }
                else if ((VaFlags & SEARCH_VA_PROTOTYPE_ADDRESS)) {
                    VaString = "prototype";
                }
                else if ((VaFlags & SEARCH_VA_UNKNOWN_TYPE_ADDRESS)) {
                    VaString = "unknown";
                }
#endif // #if DBG

                if (SizeOfPfnNumber == 8) {
                    
                    dprintf ("%016I64X %08X %016I64X %016I64X %016I64X %s\n", 
                             PfnHit,
                             PfnOffset, 
                             READ_PHYSICAL_ULONG64 (PfnHit * PageSize + PfnOffset),
                             (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                             PteAddress,
                             VaString);
                }
                else {

                    VaHit &= (ULONG64)0xFFFFFFFF;
                    PteAddress &= (ULONG64)0xFFFFFFFF;
                    
                    dprintf ("%08I64X %08X %08X %08I64X %08I64X %s\n", 
                             PfnHit,
                             PfnOffset, 
                             READ_PHYSICAL_ULONG (PfnHit * PageSize + PfnOffset),
                             (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                             PteAddress,
                             VaString);
                }
            }

            //
            // check for ctrl-c
            //

            if (CheckControlC()) {

                dprintf ("Search interrupted. \n");
                RequestForInterrupt = TRUE;
                break;
            }
        }

        if (RequestForInterrupt) {
            break;
        }
    }
    
    //
    // Reset the search engine state
    //

    WRITE_ULONG (KdpSearchInProgress, 0);
    
    if (RequestForInterrupt) {
        
        return E_INVALIDARG;
    }
    else {

        dprintf ("Search done.\n");
    }
    return S_OK;
}

ULONG64
SearchGetSystemMemoryDescriptor (
    )
/*++

Routine Description:


Arguments:

    None.
    
Return Value:

    A malloc'd PHYSICAL_MEMORY_DESCRIPTOR structure.
    Caller is responsible of freeing.

Environment:

    Call triggered only from !search Kd extension.

--*/

{
    ULONG64 MemoryDescriptorAddress;
    ULONG NumberOfRuns;

    MemoryDescriptorAddress = READ_PVOID (GetExpression ("nt!MmPhysicalMemoryBlock"));
    NumberOfRuns = READ_ULONG (MemoryDescriptorAddress);

    if (NumberOfRuns == 0) {
        return 0;
    }

    return MemoryDescriptorAddress;
}


//
// SilviuC: this is copied from \ntos\mm headers.
// We only need it to figure out if a PFN has
// prototype ptes.
//

typedef struct _MMPFNENTRY {
    ULONG Modified : 1;
    ULONG ReadInProgress : 1;
    ULONG WriteInProgress : 1;
    ULONG PrototypePte: 1;
    ULONG PageColor : 3;
    ULONG ParityError : 1;
    ULONG PageLocation : 3;
    ULONG InPageError : 1;
    ULONG VerifierAllocation : 1;
    ULONG RemovalRequested : 1;
#if PFN_CONSISTENCY
    ULONG PageTablePage : 1;
    ULONG Reserved : 1;
#else
    ULONG Reserved : 2;
#endif
    ULONG DontUse : 16; //overlays USHORT for reference count field.
} MMPFNENTRY;


ULONG64 
SearchConvertPageFrameToVa (
    ULONG64 PageFrameIndex,
    PULONG  Flags,
    PULONG64 PteAddress
    )
/*++

Routine Description:

    This routine returnes the virtual address corresponding to a 
    PFN index if the reverse mapping is easy to figure out. For all
    other cases (e.g. prototype PTE) the result is null.

Arguments:

    PageFrameIndex - PFN index to convert.

Return Value:

    The corresponding virtual address or null in case the PFN index
    cannot be easily converted to a virtual address.

Environment:

    Call triggered only from Kd extension.

--*/

{
    ULONG64 Va;
    ULONG64 PfnAddress;
    ULONG BytesRead;
    MMPFNENTRY u3_e1;

    //
    // Get address of PFN structure
    //

    PfnAddress = READ_PVOID (GetExpression("nt!MmPfnDatabase"))
        + PageFrameIndex * GetTypeSize("nt!_MMPFN");

    BytesRead = 0;
    *Flags = 0;
    
    InitTypeRead(PfnAddress, nt!_MMPFN);

    //
    // (SilviuC): should check if MI_IS_PFN_DELETED(Pfn) is on.
    //
    
    //
    // Try to figure out Va if possible.
    //

    *PteAddress = ((ULONG64)ReadField (PteAddress));
    GetFieldValue(PfnAddress, "nt!_MMPFN", "u3.e1", u3_e1);
    
    if (u3_e1.PrototypePte) {

        *Flags |= SEARCH_VA_PROTOTYPE_ADDRESS;
        return 0;
    }

    Va = DbgGetVirtualAddressMappedByPte (*PteAddress);

    *Flags |= SEARCH_VA_NORMAL_ADDRESS;
    return Va;        
}

//
// Read/write functions
//

ULONG 
READ_ULONG (
    ULONG64 Address
    )
{
    ULONG Value = 0;
    ULONG BytesRead;

    if (! ReadMemory (Address, &Value, sizeof Value, &BytesRead)) {
        dprintf ("Search: READ_ULONG error \n");
    }

    return Value;
}

VOID
WRITE_ULONG (
    ULONG64 Address,
    ULONG Value
    )
{
    ULONG BytesWritten; 

    if (! WriteMemory (Address, &Value, sizeof Value, &BytesWritten)) {
        dprintf ("Search: WRITE_ULONG error \n");
    }
}
            
ULONG64
READ_PVOID (
    ULONG64 Address
    )
{
    ULONG64 Value64 = 0;

    if (!ReadPointer(Address, &Value64)) {
        dprintf ("Search: READ_PVOID error \n");
    }
    return Value64;
}

ULONG
READ_PHYSICAL_ULONG (
    ULONG64 Address
    )
{
    ULONG Value = 0;
    ULONG Bytes = 0;

    ReadPhysical (Address, &Value, sizeof Value, &Bytes);

    if (Bytes != sizeof Value) {
        dprintf ("Search: READ_PHYSICAL_ULONG error \n");
    }

    return Value;
}


ULONG64
READ_PHYSICAL_ULONG64 (
    ULONG64 Address
    )
{
    ULONG64 Value = 0;
    ULONG Bytes = 0;

    ReadPhysical (Address, &Value, sizeof Value, &Bytes);

    if (Bytes != sizeof Value) {
        dprintf ("Search: READ_PHYSICAL_ULONG64 error \n");
    }

    return Value;
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////// !searchpte
/////////////////////////////////////////////////////////////////////

DECLARE_API( searchpte )
{
    const ULONG SEARCH_SYMBOL_CHECK = 0xABCDDCBA;
    
    ULONG64 ParamAddress;
    ULONG64 ParamDelta;
    ULONG64 ParamStart;
    ULONG64 ParamEnd;

    ULONG64 KdpSearchPageHits;
    ULONG64 KdpSearchPageHitOffsets;
    ULONG64 KdpSearchPageHitIndex;
    ULONG64 KdpSearchInProgress;
    ULONG64 KdpSearchStartPageFrame;
    ULONG64 KdpSearchEndPageFrame;

    ULONG64 KdpSearchAddressRangeStart;
    ULONG64 KdpSearchAddressRangeEnd;
    ULONG64 KdpSearchPfnValueAddress;
    ULONG64 KdpSearchCheckPoint;

    ULONG64 MmLowestPhysicalPage;
    ULONG64 MmHighestPhysicalPage;

    ULONG64 PageFrame;
    ULONG64 StartPage;
    ULONG64 EndPage;
    ULONG64 RunStartPage;
    ULONG64 RunEndPage;
    ULONG RunIndex;

    BOOLEAN RequestForInterrupt = FALSE;
    ULONG Hits;
    ULONG LastHits;
    ULONG Index;
    ULONG64 PfnHit;
    ULONG64 VaHit;
    ULONG VaFlags;
    ULONG PfnOffset;
    ULONG PfnValue;
    ULONG64 AddressStart;
    ULONG64 AddressEnd;
    ULONG DefaultRange = 128;
    ULONG64 MemoryDescriptor;
    ULONG64 PageCount, BasePage, NumberOfPages;
    ULONG   NumberOfRuns;

    ULONG   SizeOfPfnNumber = 0;
    ULONG64 PteAddress;
    BOOLEAN On64Bits;

    ULONG64 PfnSearchValue;
    ULONG NumberOfHits = 0;

    PULONG64 PfnHitsBuffer = NULL;
    ULONG PfnHitsBufferIndex = 0;
    ULONG PfnHitsBufferSize = 1024;
    ULONG PfnIndex;
    HRESULT Result;

    switch (TargetMachine) {
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
            On64Bits = TRUE;
            break;
        default:
            On64Bits = FALSE;
            break;
    }

    SizeOfPfnNumber = GetTypeSize("nt!PFN_NUMBER");

    if (SizeOfPfnNumber == 0) {
        dprintf ("Search: cannot get size of PFN_NUMBER \n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    ParamAddress = 0;
    
    //
    // Help requested ?
    //

    if (strstr (args, "?") != 0) {

        dprintf ("!searchpte FRAME(in hex)                                        \n");
        dprintf ("                                                                \n");
        return S_OK;
    }
    
    //
    // Get command line arguments.
    //

    sscanf (args, "%I64X", &ParamAddress);

    //
    // Verify that we have the right symbols.
    //

    KdpSearchCheckPoint = GetExpression ("nt!KdpSearchCheckPoint");

    if (KdpSearchCheckPoint == 0 
        || READ_ULONG (KdpSearchCheckPoint) != SEARCH_SYMBOL_CHECK) {

        dprintf ("Search error: Incorrect symbols for kernel\n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    //
    // Get all symbol values so that we can manipulate only addresses
    // from now on.
    //

    KdpSearchPageHits =  GetExpression ("nt!KdpSearchPageHits");
    KdpSearchPageHitOffsets =  GetExpression ("nt!KdpSearchPageHitOffsets");
    KdpSearchPageHitIndex =  GetExpression ("nt!KdpSearchPageHitIndex");
    KdpSearchInProgress =  GetExpression ("nt!KdpSearchInProgress");
    KdpSearchStartPageFrame =  GetExpression ("nt!KdpSearchStartPageFrame");
    KdpSearchEndPageFrame =  GetExpression ("nt!KdpSearchEndPageFrame");
    KdpSearchAddressRangeStart =  GetExpression ("nt!KdpSearchAddressRangeStart");
    KdpSearchAddressRangeEnd =  GetExpression ("nt!KdpSearchAddressRangeEnd");
    KdpSearchPfnValueAddress =  GetExpression ("nt!KdpSearchPfnValue");
    
    //
    // Perform some sanity checks on the values.
    //

    if (READ_ULONG (KdpSearchInProgress) != 0) {
        dprintf ("Search error: Inconsistent value for nt!KdpSearchInProgress \n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    //
    // Reset the search engine
    //

    WRITE_ULONG (KdpSearchPageHitIndex, 0);
    WRITE_ULONG (KdpSearchInProgress, 1);

    PfnSearchValue = ParamAddress;
    
    {
        ULONG BytesWritten = 0;

        WriteMemory (KdpSearchPfnValueAddress,
                     &PfnSearchValue,
                     SizeOfPfnNumber,
                     &BytesWritten);

        if (BytesWritten != SizeOfPfnNumber) {
            dprintf ("Search error: failed to write nt!KdpSearchPfnValue \n");
            Result = E_INVALIDARG;
            goto Exit;
        }
    }

    dprintf ("Searching for PTEs containing PFN value %I64X ...\n", PfnSearchValue);

    //
    // Read physical memory limits.
    //

    MmLowestPhysicalPage =  GetExpression ("nt!MmLowestPhysicalPage");
    MmHighestPhysicalPage =  GetExpression ("nt!MmHighestPhysicalPage");

    //
    // Figure out proper search parameters.
    //

    StartPage = READ_PVOID (MmLowestPhysicalPage);
    ParamStart = StartPage;
    
    EndPage = READ_PVOID (MmHighestPhysicalPage);
    ParamEnd = EndPage;

    //
    // Set the range of addresses that we want searched.
    //

    AddressStart = PfnSearchValue;
    AddressEnd = PfnSearchValue;

    WritePointer (KdpSearchAddressRangeStart, PfnSearchValue);
    WritePointer (KdpSearchAddressRangeEnd, PfnSearchValue);

    if (SizeOfPfnNumber == 8) {

        dprintf ("Searching PFNs in range %016I64X - %016I64X \n\n", 
                 StartPage, EndPage);
        dprintf ("%-16s %-8s %-16s %-16s %-16s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - ");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    else {

        dprintf ("Searching PFNs in range %08I64X - %08I64X \n\n", 
                 StartPage, EndPage);
        dprintf ("%-8s %-8s %-8s %-8s %-8s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    
    //
    // Get system memory description to figure out what ranges
    // should we skip. This is important for sparse PFN database
    // and for pages managed by drivers.
    //

    MemoryDescriptor = SearchGetSystemMemoryDescriptor ();

    if (MemoryDescriptor == 0) {
        dprintf ("Search error: cannot allocate system memory descriptor \n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    //
    // Search all physical memory in the specified range.
    //

    WRITE_ULONG (KdpSearchPageHitIndex, 0);

    //
    // Allocate hits buffer.
    //

    PfnHitsBuffer = (PULONG64) malloc (PfnHitsBufferSize * sizeof(ULONG64));

    if (PfnHitsBuffer == NULL) {
        dprintf ("Search error: cannot allocate hits buffer. \n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    //
    // Find out what pages are physically available create
    // page search ranges based on that.
    //
    // SilviuC: I should use ReadField to read all these structures
    // so that I do not have to take into account padding myself.
    //

    NumberOfRuns = READ_ULONG (MemoryDescriptor);
    NumberOfPages = READ_PVOID (MemoryDescriptor + SizeOfPfnNumber);

    for (PageFrame = StartPage; PageFrame < EndPage; PageFrame += DefaultRange) {

        for (RunIndex = 0; RunIndex < NumberOfRuns; RunIndex += 1) {
            
            //
            // BaseAddress and PageCount for current memory run.
            //

            ULONG64 RunAddress;

            RunAddress = MemoryDescriptor + 2 * SizeOfPfnNumber
                + RunIndex * GetTypeSize("nt!_PHYSICAL_MEMORY_RUN");

            BasePage = READ_PVOID (RunAddress);
            PageCount = READ_PVOID (RunAddress + SizeOfPfnNumber);

            //
            // Figure out real start and end page.
            //

            RunStartPage = PageFrame;
            RunEndPage = PageFrame + DefaultRange;

            if (RunEndPage < BasePage) {
                continue;
            }
            
            if (RunStartPage >= BasePage + PageCount) {
                continue;
            }
            
            if (RunStartPage < BasePage) {
                RunStartPage = BasePage;
            }

            if (RunEndPage > BasePage + PageCount) {
                RunEndPage = BasePage + PageCount;
            }

            WritePointer (KdpSearchStartPageFrame, RunStartPage);
            WritePointer (KdpSearchEndPageFrame, RunEndPage);

            //
            // Reset search index
            //

            WRITE_ULONG (KdpSearchPageHitIndex, 0);

            //
            // Invalidate kd cache
            //

            WRITE_ULONG (KdpSearchPageHits, 0);
            WRITE_ULONG (KdpSearchPageHitOffsets, 0);

            //
            // This is the trigger for memory search. We piggy back on the same
            // code as for !chklowmem and the logic in kernel detects what 
            // we really want to do.
            //

            Ioctl (IG_LOWMEM_CHECK, NULL, 0);

            //
            // Display results
            //

            Hits = READ_ULONG (KdpSearchPageHitIndex);

            for (Index = 0; Index < Hits; Index++) {

                NumberOfHits += 1;

                dprintf (".");

                //
                // Add to hits buffer
                //

                PfnHit = READ_PVOID (KdpSearchPageHits + Index * SizeOfPfnNumber);
                PfnHitsBuffer [PfnHitsBufferIndex] = PfnHit;
                PfnHitsBufferIndex += 1;

                if (PfnHitsBufferIndex >= PfnHitsBufferSize) {
                    PVOID NewBuffer;
                    
                    PfnHitsBufferSize *= 2;

                    NewBuffer = realloc (PfnHitsBuffer,
                                         PfnHitsBufferSize * sizeof(ULONG64));

                    if (NewBuffer == NULL) {
                        dprintf ("Search error: cannot reallocate hits buffer with size %u. \n",
                                 PfnHitsBufferSize);
                        Result = E_INVALIDARG;
                        goto Exit;
                    }

                    PfnHitsBuffer = NewBuffer;
                }
            }

            //
            // check for ctrl-c
            //

            if (CheckControlC()) {

                RequestForInterrupt = TRUE;
                break;
            }
        }

        if (RequestForInterrupt) {
            break;
        }
    }
    
    //
    // Now find all hits in all pages.
    //

    dprintf ("\n");
    dprintf ("Found %u pages with hits. \n", PfnHitsBufferIndex);
    dprintf ("Searching now for all hits in relevant pages ... \n");

    NumberOfHits = 0;

    for (PfnIndex = 0; 
         !RequestForInterrupt && PfnIndex < PfnHitsBufferIndex; 
         PfnIndex += 1) {

        WRITE_ULONG (KdpSearchPageHitIndex, 0);
        WRITE_ULONG (KdpSearchInProgress, 1);

        WritePointer (KdpSearchAddressRangeStart, PfnSearchValue);
        WritePointer (KdpSearchAddressRangeEnd, PfnSearchValue);

        WritePointer (KdpSearchStartPageFrame, PfnHitsBuffer[PfnIndex]);
        WritePointer (KdpSearchEndPageFrame, PfnHitsBuffer[PfnIndex]);

        WRITE_ULONG (KdpSearchPageHits, 0);
        WRITE_ULONG (KdpSearchPageHitOffsets, 0);

        Ioctl (IG_LOWMEM_CHECK, NULL, 0);

        Hits = READ_ULONG (KdpSearchPageHitIndex);

        for (Index = 0; Index < Hits; Index++) {

            NumberOfHits += 1;

            PfnHit = READ_PVOID (KdpSearchPageHits + Index * SizeOfPfnNumber);
            PfnOffset = READ_ULONG (KdpSearchPageHitOffsets + Index * sizeof (ULONG));
            VaHit = SearchConvertPageFrameToVa (PfnHit, &VaFlags, &PteAddress);

            PfnOffset &= (ULONG)0xFFFF;

            if (SizeOfPfnNumber == 8) {

                dprintf ("%016I64X %08X %016I64X %016I64X %016I64X \n", 
                         PfnHit,
                         PfnOffset, 
                         READ_PHYSICAL_ULONG64 (PfnHit * PageSize + PfnOffset),
                         (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                         PteAddress);
            }
            else {

                VaHit &= (ULONG64)0xFFFFFFFF;
                PteAddress &= (ULONG64)0xFFFFFFFF;

                dprintf ("%08I64X %08X %08X %08I64X %08I64X \n", 
                         PfnHit,
                         PfnOffset, 
                         READ_PHYSICAL_ULONG (PfnHit * PageSize + PfnOffset),
                         (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                         PteAddress);
            }

            if (CheckControlC()) {
                RequestForInterrupt = TRUE;
                break;
            }
        }
    }

    dprintf ("\n");

    Result = S_OK;

    //
    // Exit point
    //

    Exit:

    WRITE_ULONG (KdpSearchInProgress, 0);
    PfnSearchValue = 0;

    {
        ULONG BytesWritten = 0;

        WriteMemory (KdpSearchPfnValueAddress,
                     &PfnSearchValue,
                     SizeOfPfnNumber,
                     &BytesWritten);

        if (BytesWritten != SizeOfPfnNumber) {
            dprintf ("Search error: failed to reset nt!KdpSearchPfnValue \n");
        }
    }
    
    if (PfnHitsBuffer) {
        free (PfnHitsBuffer);
    }

    if (! RequestForInterrupt) {
        
        dprintf ("Search done (%u hits in %u pages).\n", 
                 NumberOfHits,
                 PfnHitsBufferIndex);
    }
    else {
        
        dprintf ("Search interrupted. \n");
    }
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\pmc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ia64 pmc

Abstract:

    KD Extension Api

Author:

    Thierry Fevrier (v-thief)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ia64.h"

// 
// EmPmcFields: EM register fields for the Performance Monitor Counter register.
//

EM_REG_FIELD EmGenPmcFields[] = {
        { "plm", "Privilege Level Mask"   , 0x4, 0 },   // 0-3
        { "ev",  "External Visibility"  , 0x1, 4 },   // 4
        { "oi",  "Overflow Interrupt", 0x1, 5 }, // 5
        { "pm",  "Privileged Monitor", 0x1, 6 }, // 6
        { "ig",  "ignored1", 0x1, 7 }, // 7
        { "es",  "Event Selection", 0x7, 8 }, // 8-14
        { "ig",  "ignored2", 0x1, 15 }, // 15
        { "umk", "Unit Mask",    0x4, 16 }, // 16-19
        { "thr", "Event Threshold", 0x3, 20 }, // 20-[21-22]
        { "ig",  "ignored3", 0x1, 23 }, // 23
        { "ism", "Instruction Set Mask", 0x2, 24 }, // 24-25
        { "ig",  "ignored4", 0x26, 26 } // 26-63
};

EM_REG_FIELD EmBtbPmcFields[] = {
        { "plm", "Privilege Level Mask", 0x4, 0 }, // 0-3
        { "ign", "ignored1", 0x2, 4 }, // 4-5
        { "pm" , "Privileged Monitor", 0x1, 6}, // 6
        { "tar", "Target Address Register", 0x1, 7 }, // 7
        { "tm" , "Taken Mask", 0x2, 8 }, // 8-9
        { "ptm", "Predicted Target Address Mask", 0x2, 10 }, // 10-11
        { "ppm", "Predicted Predicate Mask", 0x2, 12 }, // 12-13
        { "bpt", "Branch Prediction Table", 0x1, 14 }, // 14
        { "bac", "Branch Address Calculator", 0x1, 15 }, // 15
        { "ign", "ignored2", 0x30, 16 } // 16-63
};

EM_REG_FIELD EmBtbPmdFields[] = {
        { "b",   "Branch Bit", 0x1, 0 }, // 0
        { "mp",  "Mispredit Bit", 0x1, 1 }, // 1
        { "slt", "Instruction Slot", 0x2, 2}, // 2-3
        { "add", "Address", 0x3c, 4 } // 4-63
};

EM_REG_FIELD EmBtbIndexPmdFields[] = {
        { "bbi", "Branch Buffer Index", 0x3, 0 }, // 0-2
        { "ful", "Full Bit", 0x1, 3 }, // 3
        { "ign", "ignored", 0x3c, 4 } // 4-63
};

typedef
VOID
(*PDISPLAY_PMC)(
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    ); 

VOID
DisplayPmcIA64( 
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{

    dprintf("%s0x%I64x\n", ( Header ? Header : " pmc: " ), PmcValue );
    return;

} // DisplayPmcIA64()

VOID
DisplayGenPmcIA64( 
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmcValue, EmGenPmcFields, DisplayMode );
    }
    else   {
        EM_PMC emPmc;

        emPmc = ULong64ToEM_PMC( PmcValue );
        dprintf(
            "plm ev oi pm es umk thr ism\n       "
            "%1I64x   %1I64x  %1I64x  %1I64x %2I64x  %1I64x   %1I64x   %1I64x\n",
            emPmc.plm,
            emPmc.ev,
            emPmc.oi,
            emPmc.pm,
            emPmc.es,
            emPmc.umask,
            emPmc.threshold,
            emPmc.ism
            );
    }
    return;
} // DisplayGenPmcIA64()

VOID
DisplayBtbPmcIA64( 
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmcValue, EmBtbPmcFields, DisplayMode );
    }
    else   {
        EM_BTB_PMC emPmc;

        emPmc = ULong64ToEM_BTB_PMC( PmcValue );
        dprintf(
            "plm pm tar tm ptm ppm bpt bac\n       "
            "%1I64x   %1I64x  %1I64x   %1I64x  %1I64x   %1I64x   %1I64x   %1I64x\n",
            emPmc.plm,
            emPmc.pm,
            emPmc.tar,
            emPmc.tm,
            emPmc.ptm,
            emPmc.ppm,
            emPmc.bpt,
            emPmc.bac
            );
    }
    return;
} // DisplayBtbPmcIA64()

VOID
DisplayBtbPmdIA64(
    IN const  PCHAR         Header,      // Header string displayed before pmc.
    IN        ULONG64       PmdValue,    // PMD value.
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    )
{
    

    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmdValue, EmBtbPmdFields, DisplayMode );
    }
    else    {
        EM_BTB_PMD btbPmd;
        ULONG64    brAddress;
    
        btbPmd    = ULong64ToEM_BTB_PMD( PmdValue );
#define ITANIUM_PA_ADDRESSING_MASK     0x80000FFFFFFFFFFFUI64 
#define ITANIUM_VA_ADDRESSING_MASK     0xE007FFFFFFFFFFFFUI64
#define ITANIUM_BTB_PMD_ADDRESS_MASK( _pmdValue) \
                    ( ((_pmdValue) & 0xfffffffffffffff0UI64) & ITANIUM_VA_ADDRESSING_MASK )

        brAddress = ITANIUM_BTB_PMD_ADDRESS_MASK( PmdValue );
        dprintf(
            "%1I64x  %1I64x    %1I64x 0x%016I64x ",
            btbPmd.b,
            btbPmd.mp,
            btbPmd.slot,
            brAddress
            );

#if 0
// Thierry 03/19/2001 - BUGBUG
// Itanium Processor Programmer's guide does not present the 
// PMD[8-15] branch/interrupt mode 2 formats.
// I am disabling this check until I can implement it correctly with a context
// that can distinguish between mode 1 and mode 2 at the time this history was created.
        if ( (btbPmd.b == 0) && (btbPmd.mp == 0)) {
            dprintf("<invalid entry>");
        }
        else 
#endif 
        {
            CCHAR    symbol[256];
            PCHAR    s;
            ULONG64  displacement;

            symbol[0] = '!';
            GetSymbol( brAddress, symbol, &displacement);
            s = (PCHAR)symbol + strlen( (PCHAR)symbol );
            if (s == (PCHAR)symbol ) {
                sprintf( s, (IsPtr64() ? "0x%016I64x" : "0x%08x"), brAddress );
            }
            else {
                if ( displacement ) {
                    sprintf( s, (IsPtr64() ? "+0x%I64x" : "+0x%x"), displacement );
                }
            }
            dprintf( "%s", symbol );
        }
        dprintf("\n");
    }

    return;

} // DisplayBtbPmdIA64()

VOID
DisplayBtbIndexPmdIA64(
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmcValue, EmBtbIndexPmdFields, DisplayMode );
    }
    else   {
        EM_BTB_INDEX_PMD emPmd;

        emPmd = ULong64ToEM_BTB_INDEX_PMD( PmcValue );
        dprintf(
            "bbi full\n             "
            "%1I64x    %1I64x\n",
            emPmd.bbi,
            emPmd.full
            );
    }
    return;
} // DisplayBtbIndexPmdIA64()

PDISPLAY_PMC
GetPmcDisplayFunction(
    char *Str
    )
{
    LONG pmc;
    char *c;

    c = Str;
    while( isalnum( (int)(*c) ) )   {
        c++;
    }
    *c = '\0';
    
    pmc = atol( Str );
    switch( pmc )   {
        case 4:
        case 5:
        case 6:
        case 7:
            return( (PDISPLAY_PMC)DisplayGenPmcIA64 );

        case 12:
            return( (PDISPLAY_PMC)DisplayBtbPmcIA64 );

        default:
            if ( !strcmp( Str, "gen" ) ) {
                return( (PDISPLAY_PMC)DisplayGenPmcIA64 ); 
            }
            if ( !strcmp( Str, "btb" ) ) {
                return( (PDISPLAY_PMC)DisplayBtbPmcIA64 );
            }
            return ( (PDISPLAY_PMC)DisplayPmcIA64 );
    }
    
} // IsPmcSupported()

DECLARE_API( pmc )

/*++

Routine Description:

    Dumps a IA-64 Processor PMC Register.
    // Thierry 11/2000: The following scheme could also be used for PMD registers.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64       pmcValue   = 0;
    ULONG         result;
    ULONG         flags      = 0;
    char         *option     = NULL;
    PDISPLAY_PMC  displayPmc = DisplayGenPmcIA64;  // Default display function.
    char         *header;

    if ( TargetMachine != IMAGE_FILE_MACHINE_IA64 )
    {
        dprintf("!pmc not implemented for this architecture.\n");
        return S_OK;
    }

    option = strchr( args, '-' );
    if ( option ) {
        displayPmc = GetPmcDisplayFunction( ++option );
        args += (strlen(option) + 2);
    }
        
    result = sscanf(args,"%I64lx %lx", &pmcValue, &flags);
	if ((result != 1) && (result != 2)) {
        //
        // If user specified "@kpfc*"...
        //

        char kpfcStr[16];
        BOOLEAN valid = FALSE;

        result = sscanf(args,"%s %lx", kpfcStr, &flags);
        if ( (result == 1) || (result == 2) )  {
            if ( option == NULL )   { // If we did not force the display format.
                char *str;

                str = strstr( kpfcStr, "@kpfc" );
                if ( str )      {
                    str += strlen("@kpfc");
                    displayPmc = GetPmcDisplayFunction( str );
                }
            }
        }
        else  {
            dprintf( "USAGE: !pmc [-opt] 0xValue [display_mode:0,1,2]\n"
                     "USAGE: !pmc @kpfc*         [display_mode:0,1,2]\n"
                     "where currently supported option:\n"
                     "\tgen [or 4,5,6,7] - generic PMC registers\n"
                     "\tbtb [or 12]      - branch trace buffer PMC register\n"
                     "\tEx: !pmc -btb @r2 2\n"
                   );
            return E_INVALIDARG;
        }      
        pmcValue = GetExpression(kpfcStr);
    }
    
    header = (flags > DISPLAY_MIN) ? NULL : " pmc: ";
    (*displayPmc)( header, pmcValue, flags );

    return S_OK;

} // !pmc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\power.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    power.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/

// podev - dump power relevent data (and other data) about a device object
// polist [arg] - if no arg, dump data about powerirpseriallist
//                  if arg, show entries in serialist that refer to that device object
// podevnode - dump inverted tree and inclusion %
// podevnode <any> - dump normal pnp tree, used only for testing with inverted tree
// postate - dump state statistics

#include "precomp.h"
#pragma hdrstop

VOID
popDumpDeviceName(
    ULONG64  DeviceAddress
    );

__inline
ULONG64
GetAddress(
    IN ULONG64 Base,
    IN PCHAR Type,
    IN PCHAR Field)
{
    ULONG Offset;

    GetFieldOffset(Type, Field, &Offset);
    return(Base + Offset);
}


typedef struct {
    ULONG   Flags;
    PUCHAR  String;
} DEFBITS, *PDEFBITS;


DEFBITS ActFlags[] = {
        POWER_ACTION_QUERY_ALLOWED,     "QueryApps",
        POWER_ACTION_UI_ALLOWED,        "UIAllowed",
        POWER_ACTION_OVERRIDE_APPS,     "OverrideApps",
        POWER_ACTION_DISABLE_WAKES,     "DisableWakes",
        POWER_ACTION_CRITICAL,          "Critical",
        0, NULL
        };

PUCHAR rgPowerNotifyOrder[PO_ORDER_MAXIMUM+1] = {
    "Non-Paged, PnP, Video",
    "Non-Paged, PnP",
    "Non-Paged, Root-Enum, Video",
    "Non-Paged, Root-Enum",
    "Paged, PnP, Video",
    "Paged, PnP",
    "Paged, Root-Enum, Video",
    "Paged, Root-Enum"
    };


static UCHAR Buffer[50];



VOID
poDumpDevice(
    ULONG64 DeviceAddress
    );


DECLARE_API( podev )
/*++

Routine Description:

    Dump the power relevent fields of a device object.

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64 deviceToDump;

    deviceToDump = GetExpression(args);
    dprintf("Device object is for:\n");
    poDumpDevice(deviceToDump);
    return S_OK;
}


VOID
poDumpDevice(
    ULONG64 DeviceAddress
    )

/*++

Routine Description:

    Displays the driver name for the device object if possible, and
    then displays power relevent fields.

Arguments:

    DeviceAddress - address of device object to dump.

Return Value:

    None

--*/

{
    ULONG                      result;
    ULONG                      i;
    PUCHAR                     buffer;
    UNICODE_STRING             unicodeString;
    ULONG64                    nextEntry;
    ULONG64                    queueAddress;
    ULONG64                    irp;
    ULONG64                    pObjectHeader;
    ULONG64                    pNameInfo;
    ULONG                      rmr;
    ULONG                      Type;
    ULONG                      Flags;
    ULONG64                    Temp, DeviceObjectExtension, Dope;
    USHORT                     Length;


    if (GetFieldValue(DeviceAddress,
                     "nt!_DEVICE_OBJECT",
                      "Type",
                      Type)) {
        dprintf("%08p: Could not read device object\n", DeviceAddress);
        return;
    }

    if (Type != IO_TYPE_DEVICE) {
        dprintf("%08p: is not a device object\n", DeviceAddress);
        return;
    }

    //
    // Dump the device name if present.
    //

    pObjectHeader = KD_OBJECT_TO_OBJECT_HEADER(DeviceAddress);
    if (GetFieldValue(pObjectHeader,
                      "nt!_OBJECT_HEADER",
                      "Type",
                      Temp)) {
        USHORT  Length;
        ULONG64 pName;

        KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &pNameInfo );
        if (GetFieldValue(pNameInfo,
                          "nt!_OBJECT_HEADER_NAME_INFO",
                          "Name.Length",
                          Length)) {
            buffer = LocalAlloc(LPTR, Length);
            if (buffer != NULL) {
                unicodeString.MaximumLength = Length;
                unicodeString.Length = Length;
                unicodeString.Buffer = (PWSTR)buffer;
                GetFieldValue(pNameInfo,
                              "nt!_OBJECT_HEADER_NAME_INFO",
                              "Name.Buffer",
                              pName);
                if (ReadMemory(pName,
                               buffer,
                               unicodeString.Length,
                               &result) && (result == unicodeString.Length)) {
                    dprintf(" %wZ", &unicodeString);
                }
                LocalFree(buffer);
            }
        }
    }

    //
    // Dump Irps related to driver.
    //

    InitTypeRead(DeviceAddress, nt!_DEVICE_OBJECT);
    dprintf("  DriverObject %08lx\n", ReadField(DriverObject));
    dprintf("Current Irp %08lx RefCount %d Type %08lx ",
            ReadField(CurrentIrp),
            ReadField(ReferenceCount),
            ReadField(DeviceType));
    if (ReadField(AttachedDevice)) {
        dprintf("AttachedDev %08p ", ReadField(AttachedDevice));
    }
    if (ReadField(Vpb)) {
        dprintf("Vpb %08p ", ReadField(Vpb));
    }

    dprintf("DevFlags %08lx", (Flags = (ULONG) ReadField(Flags)));
    if (Flags & DO_POWER_PAGABLE) dprintf("  DO_POWER_PAGABLE");
    if (Flags & DO_POWER_INRUSH) dprintf(" DO_POWER_INRUSH");
    if (Flags & DO_POWER_NOOP) dprintf(" DO_POWER_NOOP");
    dprintf("\n");
    DeviceObjectExtension = ReadField(DeviceObjectExtension);

    if (ReadField(DeviceQueue.Busy)) {
        ULONG Off;

        GetFieldOffset("nt!_DEVICE_OBJECT", "DeviceQueue.DeviceListHead", &Off);
        nextEntry = ReadField(DeviceQueue.DeviceListHead.Flink);

        if (nextEntry == DeviceAddress + Off) {
            dprintf("Device queue is busy -- Queue empty\n");
        } else {
            ULONG Qoffset, IrpOffset;

            dprintf("DeviceQueue: ");
            i = 0;

            GetFieldOffset("nt!_DEVICE_OBJECT", "DeviceListEntry", &Qoffset);
            GetFieldOffset("nt!_IRP", "Tail.Overlay.DeviceQueueEntry", &IrpOffset);
            while ( nextEntry != ( DeviceAddress + Off )) {
                queueAddress = (nextEntry - Qoffset);
                if (GetFieldValue(queueAddress,
                                 "nt!_KDEVICE_QUEUE_ENTRY",
                                 "DeviceListEntry.Flink",
                                  nextEntry)) {
                    dprintf("%08p: Could not read queue entry\n", DeviceAddress);
                    return;
                }

//                nextEntry = queueEntry.DeviceListEntry.Flink;

                irp = (queueAddress - IrpOffset);

                dprintf("%08p%s",
                        irp,
                        (i & 0x03) == 0x03 ? "\n\t     " : " ");
                if (CheckControlC()) {
                    break;
                }
            }
            dprintf("\n");
        }
    } else {
        dprintf("Device queue is not busy.\n");
    }

    dprintf("Device Object Extension: %08p:\n", DeviceObjectExtension);
    if (GetFieldValue(DeviceObjectExtension,
                      "nt!_DEVOBJ_EXTENSION",
                      "PowerFlags",
                      Flags)) {
        dprintf("Could not read Device Object Extension %p\n", DeviceObjectExtension);
        return;
    }
    dprintf("PowerFlags: %08lx =>", Flags);

#define PopGetDoSystemPowerState(Flags) \
    (Flags & POPF_SYSTEM_STATE)

#define PopGetDoDevicePowerState(Flags) \
    ((Flags & POPF_DEVICE_STATE) >> 4)


    dprintf("SystemState=%1x", PopGetDoSystemPowerState(Flags) );
    dprintf(" DeviceState=%lx", PopGetDoDevicePowerState(Flags) );
    if (Flags & POPF_SYSTEM_ACTIVE) dprintf(" syact");
    if (Flags & POPF_SYSTEM_PENDING) dprintf(" sypnd");
    if (Flags & POPF_DEVICE_ACTIVE) dprintf(" dvact");
    if (Flags & POPF_DEVICE_PENDING) dprintf(" dvpnd");

    GetFieldValue(DeviceObjectExtension,"nt!_DEVOBJ_EXTENSION","Dope",Dope);
    dprintf("\nDope: %08lx:\n", Dope);
    if (Dope != 0) {
        rmr = GetFieldValue(Dope, "nt!_DEVICE_OBJECT_POWER_EXTENSION",
                            "DeviceType", Type);
        if (!rmr) {
            InitTypeRead(Dope, nt!_DEVICE_OBJECT_POWER_EXTENSION);

            dprintf("IdleCount: %08p  ConIdlTime: %08p  PerfIdlTime: %08p\n",
                ReadField(IdleCount), ReadField(ConservationIdleTime), ReadField(PerformanceIdleTime));
            dprintf("NotifySourceList fl:%08p bl:%08p\n",
                ReadField(NotifySourceList.Flink), ReadField(NotifySourceList.Blink));
            dprintf("NotifyTargetList fl:%08p bl:%08p\n",
                ReadField(NotifyTargetList.Flink), ReadField(NotifyTargetList.Blink));
            dprintf("PowerChannelSummary TotalCount: %08p  D0Count: %08p\n",
                ReadField(PowerChannelSummary.TotalCount), ReadField(PowerChannelSummary.D0Count));

            dprintf("PowerChannelSummary NotifyList fl:%08p bl:%08p\n",
                ReadField(PowerChannelSummary.NotifyList.Flink),
                ReadField(PowerChannelSummary.NotifyList.Blink)
                );
        }
    }
    return;
}


VOID
poDumpList(
    ULONG64 DeviceAddress
    );


DECLARE_API( polist )
/*++

Routine Description:

    Dump the irp serial list, unless a devobj address is given,
    in which case dump the irps in the serial list that point to
    that device object

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64 deviceToDump;

    deviceToDump = 0;
    deviceToDump = GetExpression(args);
    if (deviceToDump == 0) {
        dprintf("All entries in Power Irp Serial List\n");
    } else {
        dprintf("Entries in Power Irp Serial List for: %08p:\n", deviceToDump);
    }
    if (!IsPtr64()) {
        deviceToDump = (ULONG64) (LONG64) (LONG) deviceToDump;
    }
    poDumpList(deviceToDump);
    return S_OK;
}


VOID
poDumpList(
    ULONG64 DeviceAddress
    )

/*++

Routine Description:

Arguments:

    DeviceAddress - address of device object to dump.

Return Value:

    None

--*/

{
    ULONG64 listhead, irpa, iosla, p;
    ULONG   isll, result;
    ULONG   IrpOffset;

    isll = GetUlongValue("nt!PopIrpSerialListLength");
    dprintf("PopIrpSerialListLength = %d\n", isll);

    listhead = GetExpression("nt!PopIrpSerialList");
    GetFieldOffset("nt!_IRP", "Tail.Overlay.DeviceQueueEntry", &IrpOffset);

    for (p = GetPointerFromAddress( listhead );
         p != listhead;
         p = GetPointerFromAddress( p))
    {
        ULONG64 DeviceObject, CurrentStackLocation;
        irpa =  p - IrpOffset;

        if (GetFieldValue(irpa, "nt!_IRP", "Tail.Overlay.CurrentStackLocation", CurrentStackLocation))
        {
            dprintf("Cannot read Irp: %08p\n", irpa);
            return;
        }

        iosla = CurrentStackLocation + DBG_PTR_SIZE;

        if (GetFieldValue(iosla, "nt!_IO_STACK_LOCATION", "DeviceObject", DeviceObject) )
        {
            dprintf("Cannot read Io Stk Loc: %08p\n", iosla);
            return;
        }

        InitTypeRead(iosla, nt!_IO_STACK_LOCATION);
        if ((DeviceAddress == 0) || (DeviceAddress == DeviceObject)) {
            dprintf("Irp:%08p DevObj:%08p ", irpa, DeviceObject);
            dprintf("Ctx:%08p ", ReadField(Parameters.Power.SystemContext));
            if (ReadField(Parameters.Power.SystemContext) & POP_INRUSH_CONTEXT) {
                dprintf("inrush ");
            } else {
                dprintf("       ");
            }

            if (ReadField(Parameters.Power.Type) == SystemPowerState) {
                dprintf("sysirp ");
                dprintf("S%d\n", (LONG)(ReadField(Parameters.Power.State.SystemState)) - (LONG)PowerSystemWorking);
            } else {
                dprintf("devirp ");
                dprintf("D%d\n", (LONG)(ReadField(Parameters.Power.State.DeviceState)) - (LONG)PowerDeviceD0);
            }
        }
    }
    return;
}


VOID
poDumpRequestedList(
    ULONG64 DeviceAddress
    );


DECLARE_API( poreqlist )
/*++

Routine Description:

    Dump the irp serial list, unless a devobj address is given,
    in which case dump the irps in the serial list that point to
    that device object

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64 deviceToDump;

    deviceToDump = GetExpression(args);
    if (deviceToDump == 0) {
        dprintf("All active Power Irps from PoRequestPowerIrp\n");
    } else {
        dprintf("Active Power Irps from PoRequestPowerIrp for: %08p:\n",
                deviceToDump);
    }
    poDumpRequestedList(deviceToDump);

    return S_OK;
}

VOID
poDumpRequestedList (
    ULONG64 DeviceAddress
    )
/*++

Routine Description:

    Dump PopRequestedIrps List, "A list of all the power irps created from
    PoReqestPowerIrp.

Arguments:

    DeviceAddress - optional address to which requested power IRPs were sent

--*/
{
    BOOL    blocked = FALSE;
    ULONG64 listhead;
    ULONG64 p, spAddr, irpAddr;
    ULONG   result;
    ULONG   Off;

    dprintf("PopReqestedPowerIrpList\n");

    listhead = GetExpression("nt!PopRequestedIrps");

    GetFieldOffset("nt!_IO_STACK_LOCATION", "Parameters.Others.Argument1", &Off);
    dprintf("FieldOffset = %p\n",Off);
    for (p = GetPointerFromAddress( listhead );
         p != listhead;
         p = GetPointerFromAddress( p ))
    {
        ULONG64 CurrentStackLocation;
        ULONG MajorFunction;

        //
        // Reguested list is a double list of stack locations
        //
        spAddr = p - Off;
        if (GetFieldValue(spAddr, "nt!_IO_STACK_LOCATION",
                          "Parameters.Others.Argument3", irpAddr)) {

            dprintf("Cannot read 1st stack Location: %08p\n", spAddr);
            return;
        }

        //
        // The 3rd argument of which has the pointer to the irp itself
        //
        if (GetFieldValue(irpAddr, "nt!_IRP", "Tail.Overlay.CurrentStackLocation", CurrentStackLocation))
        {
            dprintf("Cannot read Irp: %08p\n", irpAddr);
            return;
        }
        dprintf ("Irp %08p ", irpAddr);

        //
        // Assume the if the IRP is in this list that it has a valid
        // current stack location
        //
        spAddr = CurrentStackLocation;

        if (GetFieldValue(spAddr, "nt!_IO_STACK_LOCATION", "MajorFunction", MajorFunction) )
        {
            dprintf("Cannot read current stack location: %08p\n", spAddr);
            return;
        }

        //
        // Check to see if the irp is blocked
        //
        blocked = FALSE;
        if (MajorFunction != IRP_MJ_POWER) {

            //
            // Irp is blocked. The next stack location is the real one
            //
            blocked = TRUE;
            spAddr = CurrentStackLocation + DBG_PTR_SIZE;
            if (GetFieldValue(spAddr, "nt!_IO_STACK_LOCATION", "MajorFunction", MajorFunction) )
            {
                dprintf("Cannot read current stack location: %08p\n", spAddr);
                return;
            }

        }

        if ((DeviceAddress == 0) || (DeviceAddress == ReadField(DeviceObject))) {

            ULONG   MinorFunction = 0;
            ULONG64 DeviceObject = 0;
            ULONG64 SystemContext = 0;
            ULONG64 Temp = 0;
            UCHAR   IOStack[] = "nt!_IO_STACK_LOCATION";

            GetFieldValue(spAddr,IOStack, "DeviceObject", DeviceObject);
            GetFieldValue(spAddr,IOStack, "Parameters.Power.SystemContext", SystemContext);
            GetFieldValue(spAddr,IOStack, "MinorFunction", MinorFunction);

            dprintf("DevObj %08p", DeviceObject);
            DumpDevice(DeviceObject,0, FALSE);
            dprintf(" Ctx %08p ", SystemContext);
            if ((SystemContext & POP_INRUSH_CONTEXT) == POP_INRUSH_CONTEXT) {

                dprintf("* ");
            } else {
                dprintf("  ");
            }

            switch (MinorFunction) {
            case IRP_MN_QUERY_POWER:
                dprintf ("Query Power ");
                goto PoDumpRequestedListPowerPrint;
            case IRP_MN_SET_POWER:
                dprintf ("Set Power ");
PoDumpRequestedListPowerPrint:
                GetFieldValue(spAddr, IOStack, "Parameters.Power.Type",Temp);
                if ((ULONG) Temp == SystemPowerState) {
                    GetFieldValue(spAddr, IOStack, "Parameters.Power.State.SystemState", Temp);
                    dprintf("S%d ", (LONG)Temp - (LONG)PowerSystemWorking);
                } else {
                    GetFieldValue(spAddr, IOStack, "Parameters.Power.State.DeviceState", Temp);
                    dprintf("D%d ", (LONG)Temp - (LONG)PowerDeviceD0);
                }
                GetFieldValue(spAddr,IOStack,"Parameters.Power.ShutdownType", Temp);
                dprintf ("ShutdownType %x", (LONG) Temp);
                break;

            case IRP_MN_WAIT_WAKE:
                GetFieldValue(spAddr, IOStack, "Parameters.WaitWake.PowerState", Temp);
                dprintf ("Wait Wake S%d", (LONG)Temp - (LONG)PowerSystemWorking);
                break;

            case IRP_MN_POWER_SEQUENCE:
                dprintf ("Power Sequence Irp");
                break;
            }
            if (blocked) {

                dprintf(" [blocked]");

            }
            dprintf("\n");
        }
    }
    return;
}

VOID poDumpNodePower();

DECLARE_API( ponode )
/*++

Routine Description:

    If an argument is present, dump the devnode list in pnp order.
    (used only for testing)

    Otherwise dump the devnode inverted stack.
    (po enumeration order)

Arguments:

    args - flag

Return Value:

    None

--*/

{
    ULONG flag;

    dprintf("Dump Inverted DevNode Tree (power order)\n");
    poDumpNodePower();
    return S_OK;
}

VOID
poDumpNodePower(
    )
/*++

Routine Description:

    Dump the devnode tree in power order.

Arguments:

Return Value:

    None

--*/
{
#if 0
    LONG    level, SizeOfLE, LevelOff, pdo_off;
    ULONG64 parray, listhead, effaddr, pdo, devNodeAddr, limit;

    level = GetUlongValue("nt!IopMaxDeviceNodeLevel");
    parray = GetExpression("nt!IopDeviceNodeStack");

    dprintf("Max level = %5d\n", level);
    dprintf("IopDeviceNodeStack %08p\n", parray);
    parray = GetPointerFromAddress(parray);
    dprintf("*IopDeviceNodeStack %08p\n", parray);

    dprintf("Level  ListHead  DevNode   PDO\n");
    dprintf("-----  --------  --------  --------\n");

    SizeOfLE = GetTypeSize("nt!_LIST_ENTRY");
    GetFieldOffset("nt!_DEVICE_NODE", "LevelList", &LevelOff);
    GetFieldOffset("nt!_DEVICE_NODE", "PhysicalDeviceObject", &pdo_off);
    for ( ; level >= 0; level--) {

        effaddr = (level * SizeOfLE) + parray;
        listhead = GetPointerFromAddress( effaddr);

        dprintf("%5d  %08lx\n", level, listhead);

        if (listhead) {

            limit = 0;
            for (effaddr = GetPointerFromAddress(listhead);
                 effaddr != listhead;
                 effaddr = GetPointerFromAddress(effaddr))
            {
                devNodeAddr = (effaddr - LevelOff);

                pdo = GetPointerFromAddress((devNodeAddr+pdo_off));

                dprintf("                 %08p  %08p  ", devNodeAddr, pdo);
                popDumpDeviceName(pdo);
                dprintf("\n");
            }
        }
    }
#endif
}


VOID
popDumpDeviceName(
    ULONG64  DeviceAddress
    )
{
    ULONG                      result;


    PUCHAR                     buffer;
    UNICODE_STRING             unicodeString;
    ULONG64                    pObjectHeader;
    ULONG64                    pNameInfo;
    ULONG                      Type;
    ULONG                      Flags;
    ULONG64                    Temp;
    USHORT                     Length;


    if (GetFieldValue(DeviceAddress, "nt!_DEVICE_OBJECT", "Type", Type)) {
        dprintf("%08p: Could not read device object\n", DeviceAddress);
        return;
    }

    if (Type != IO_TYPE_DEVICE) {
        dprintf("%08p: is not a device object\n", DeviceAddress);
        return;
    }

    //
    // Dump the device name if present.
    //

    pObjectHeader = KD_OBJECT_TO_OBJECT_HEADER(DeviceAddress);
    if (GetFieldValue(pObjectHeader, "nt!_OBJECT_HEADER", "Type", Temp)) {
        ULONG64 pName;

        KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &pNameInfo );
        if (GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO",
                          "Name.Length",
                          Length)) {
            buffer = LocalAlloc(LPTR, Length);
            if (buffer != NULL) {
                unicodeString.MaximumLength = Length;
                unicodeString.Length = Length;
                unicodeString.Buffer = (PWSTR)buffer;
                GetFieldValue(pNameInfo,
                              "nt!_OBJECT_HEADER_NAME_INFO",
                              "Name.Buffer",
                              pName);
                if (ReadMemory(pName,
                               buffer,
                               unicodeString.Length,
                               &result) && (result == unicodeString.Length)) {
                    dprintf(" %wZ", &unicodeString);
                }
                LocalFree(buffer);
            }
        }
    }
    return;
}

PUCHAR
PowerAction(
    IN POWER_ACTION     Action
    )
{
    switch (Action) {
        case PowerActionNone:           return "None";
        case PowerActionReserved:       return "Reserved";
        case PowerActionSleep:          return "Sleep";
        case PowerActionHibernate:      return "Hibernate";
        case PowerActionShutdown:       return "Shutdown";
        case PowerActionShutdownReset:  return "ShutdownReset";
        case PowerActionShutdownOff:    return "ShutdownOff";
        case PowerActionWarmEject:      return "WarmEject";
    }

    return "???";
}

PUCHAR
SystemState(
    SYSTEM_POWER_STATE  State
    )
{
    switch (State) {
        case PowerSystemUnspecified:    return "Unspecified";
        case PowerSystemWorking:        return "Working";
        case PowerSystemSleeping1:      return "Sleeping1";
        case PowerSystemSleeping2:      return "Sleeping2";
        case PowerSystemSleeping3:      return "Sleeping3";
        case PowerSystemHibernate:      return "Hibernate";
        case PowerSystemShutdown:       return "Shutdown";
    }

    sprintf (Buffer, "State=%x", State);
    return Buffer;
}

PUCHAR
PoIrpMinor (
    UCHAR   IrpMinor
    )
{
    switch (IrpMinor) {
        case IRP_MN_QUERY_POWER:    return "QueryPower";
        case IRP_MN_SET_POWER:      return "SetPower";
    }

    return "??";
}



PUCHAR
TF (
    BOOLEAN Flag
    )
{
    switch (Flag) {
        case TRUE:    return "TRUE";
        case FALSE:   return "FALSE";
    }

    sprintf (Buffer, "%x", Flag);
    return Buffer;
}




PWCHAR
DumpDoName (
    IN ULONG64  Str
    )
{
    static  WCHAR   Name[50];

    memset (Name, 0, sizeof(Name));
    ReadMemory (Str, Name, sizeof(Name), NULL);
    Name[sizeof(Name)-1] = 0;
    return Name;
}

PUCHAR
DumpQueueHead (
    IN ULONG64  StrucAddr,
    IN ULONG64  Struc,
    IN ULONG    Offset
    )
{
    ULONG64     Head, Flink, Blink;
    ULONG64     Va;

    Head = Struc + Offset;
    Va   = StrucAddr + Offset;

    GetFieldValue(Head, "nt!_LIST_ENTRY", "Flink", Flink);
    GetFieldValue(Head, "nt!_LIST_ENTRY", "Blink", Blink);
    if (Flink == Va  &&  Blink == Va) {
        sprintf (Buffer, "Head:%08p Empty", Va);
    } else {
        sprintf (Buffer, "Head:%08p F:%08p B:%08p", Va, Flink, Blink);
    }

    return Buffer;
}


VOID
DumpDevicePowerIrp (
    IN PUCHAR  Desc,
    IN ULONG64 StrucAddr,
    IN ULONG64 Head,
    IN ULONG   Offset
    )
{
    ULONG64               Va;
    ULONG64               Link;
    ULONG64               Addr;
    ULONG       Off;

    GetFieldOffset("nt!_POP_DEVICE_SYS_STATE", "Head", &Off);
    Va = (StrucAddr + Off + Offset);
    Link = GetPointerFromAddress(Head + Offset);

    if (Link == Va) {
        return ;
    }

    dprintf ("\n%s:\n", Desc);

    while (Link != Va) {
        ULONG64 Irp, Notify;

        Addr = Link - Offset;
        if (GetFieldValue(Addr, "nt!_POP_DEVICE_POWER_IRP", "Irp", Irp)) {
            dprintf ("Could not power irp\n");
            break;
        }
        GetFieldValue(Addr, "nt!_POP_DEVICE_SYS_STATE", "Notify", Notify);
        dprintf ("  Irp: %08p  Notify %08p\n", Irp, Notify);

        Link = GetPointerFromAddress(Addr + Offset);
    }
}

VOID
poDumpOldNotifyList(
    VOID
    )
{
    BOOLEAN             GdiOff;
    UCHAR               LastOrder;
    ULONG               PartOffset, NoLists, SizeOfLE, Off, HeadOff;
    ULONG64             DevState, Notify;
    LONG                i;
    ULONG64             ListHead;
    ULONG64             Link;

    dprintf("  NoLists........: %p\n",   (NoLists = (ULONG) ReadField(Order.NoLists)));
    SizeOfLE = GetTypeSize("nt!_LIST_ENTRY");
    GdiOff = FALSE;
    LastOrder = 0xff;
    Notify = ReadField(Order.Notify);
    for (i=NoLists-1; i >= 0; i--) {
        ListHead = Notify + i*SizeOfLE;
        if (GetFieldValue(ListHead, "nt!_LIST_ENTRY", "Flink", Link)) {
            dprintf ("Could not read list head\n");
            break;
        }

        while (Link != ListHead) {
            UCHAR OrderLevel;

            if (GetFieldValue(Link, "nt!_PO_DEVICE_NOTIFY", "OrderLevel", OrderLevel)) {
                dprintf ("Could not read link\n");
                break;
            }

            if (LastOrder != OrderLevel) {
                LastOrder = OrderLevel;
                dprintf ("     %x   %s",
                    LastOrder,
                    LastOrder <= PO_ORDER_MAXIMUM ? rgPowerNotifyOrder[LastOrder] : ""
                    );

                if (!GdiOff && OrderLevel <= PO_ORDER_GDI_NOTIFICATION) {
                    GdiOff = TRUE;
                    dprintf (", GdiOff\n");
                } else {
                    dprintf ("\n");
                }
            }

            InitTypeRead(Link, nt!_PO_DEVICE_NOTIFY);
            dprintf ("  %02x %x:%x %08x %c",
                i,
                OrderLevel,
                (ULONG) ReadField(NodeLevel),
                Link,
                ((UCHAR) ReadField(WakeNeeded) ? 'w' : ' ')
                );

            dprintf (" %ws\t", DumpDoName (ReadField(DriverName)));
            dprintf (" %ws\n", DumpDoName (ReadField(DeviceName)));

            Link = ReadField(Link.Flink);

            if (CheckControlC()) {
                return;
            }
        }
    }
}

ULONG
DumpNotifyCallback(
    PFIELD_INFO pAddrInfo,
    PVOID Context
    )
{
    if (CheckControlC()) {return 0;}

    InitTypeRead(pAddrInfo->address, nt!_PO_DEVICE_NOTIFY);
    dprintf("   %c %08p: %08p %ws\t",
            ReadField(WakeNeeded) ? 'w' : ' ',
            pAddrInfo->address,
            ReadField(Node),
            DumpDoName(ReadField(DriverName)));
    dprintf("%ws\n",DumpDoName(ReadField(DeviceName)));
            
    return(0);
}

VOID
poDumpNewNotifyList(
    IN ULONG64 DevState
    )
{
    BOOLEAN             GdiOff;
    UCHAR               LastOrder;
    ULONG               PartOffset, NoLists, SizeOfLE, Off, HeadOff;
    ULONG64             Level, Notify;
    LONG                i,j;
    ULONG64             ListHead;
    ULONG64             Link;
    ULONG               LevelOffset;
    ULONG               SizeOfLevel;
    CHAR                FlinkBuff[32];
    PCHAR               NotifyList[] = {"WaitSleep",
                                        "ReadySleep",
                                        "Pending",  
                                        "Complete", 
                                        "ReadyS0",  
                                        "WaitS0"};

    SizeOfLevel = GetTypeSize("nt!_PO_NOTIFY_ORDER_LEVEL");
    GdiOff = FALSE;
    if (GetFieldOffset("nt!_POP_DEVICE_SYS_STATE",
                       "Order.OrderLevel",
                       &LevelOffset)) {
        dprintf("Couldn't get field offset for Order.OrderLevel.");
        return;
    }
    for (i=PO_ORDER_MAXIMUM;i>=0;i--) {
        if (CheckControlC()) {return;}
        Level = DevState + LevelOffset + i*SizeOfLevel;
        InitTypeRead(Level, nt!_PO_NOTIFY_ORDER_LEVEL);
        if (ReadField(DeviceCount)) {
            dprintf("Level %d (%08p) %d/%d\t%s\n",
                    i,
                    Level,
                    (ULONG)ReadField(ActiveCount),
                    (ULONG)ReadField(DeviceCount),
                    rgPowerNotifyOrder[i]);

            for (j=0;j<sizeof(NotifyList)/sizeof(PCHAR);j++) {
                if (CheckControlC()) {return;}
                sprintf(FlinkBuff, "%s.Flink",NotifyList[j]);
                if (GetFieldValue(Level,
                                  "nt!_PO_NOTIFY_ORDER_LEVEL",
                                  FlinkBuff,
                                  Link)) {
                    dprintf("couldn't get field value for PO_NOTIFY_ORDER_LEVEL.%s\n",FlinkBuff);
                    return;
                }
                if (Link != GetAddress(Level, "nt!_PO_NOTIFY_ORDER_LEVEL", FlinkBuff)) {
                    dprintf("  %s:\n",NotifyList[j]);
                    ListType("_PO_DEVICE_NOTIFY",
                             Link,
                             1,
                             "Link.Flink",
                             NULL,
                             DumpNotifyCallback);
                }
            }
        }
    }
}

VOID
PoDevState (
    VOID
    )
/*++

Routine Description:

    Dumps the current power action structure

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64             addr;
    LONG                i;
    ULONG64             ListHead;
    ULONG64             Link;
    ULONG64             DevState, Notify;
    BOOLEAN             GdiOff;
    UCHAR               IrpMinor;
    ULONG               PartOffset, NoLists, SizeOfLE, Off, HeadOff;

    addr = GetExpression( "nt!PopAction" );
    if (!addr) {
        dprintf("Error retrieving address of PopAction\n");
        return;
    }

    if (GetFieldValue(addr, "nt!POP_POWER_ACTION", "DevState", DevState)) {
        dprintf("Error reading PopAction\n");
        return;
    }

    if (!DevState) {
        dprintf("No Device State allocated on PopAction\n");
        return;
    }

    if (GetFieldValue(DevState, "nt!_POP_DEVICE_SYS_STATE", "IrpMinor", IrpMinor)) {
        dprintf("Error reading device state structure\n");
        return;
    }

    GetFieldOffset("nt!_POP_DEVICE_SYS_STATE","PresentIrpQueue", &Off);
    InitTypeRead(DevState, nt!_POP_DEVICE_SYS_STATE);
    dprintf ("PopAction.DevState %08x\n", DevState);
    dprintf("  Irp minor......: %s\n",   PoIrpMinor (IrpMinor));
    dprintf("  System State...: %s\n",   SystemState((ULONG) ReadField(SystemState)));
    dprintf("  Worker thread..: %08p\n", ReadField(Thread));
    dprintf("  Status.........: %x\n",   (ULONG) ReadField(Status));
    dprintf("  Waking.........: %s\n",   TF (((UCHAR) ReadField(Waking))) );
    dprintf("  Cancelled......: %s\n",   TF (((UCHAR) ReadField(Cancelled))) );
    dprintf("  Ignore errors..: %s\n",   TF (((UCHAR) ReadField(IgnoreErrors))) );
    dprintf("  Ignore not imp.: %s\n",   TF (((UCHAR) ReadField(IgnoreNotImplemented))) );
    dprintf("  Wait any.......: %s\n",   TF (((UCHAR) ReadField(WaitAny))) );
    dprintf("  Wait all.......: %s\n",   TF (((UCHAR) ReadField(WaitAll))) );
    dprintf("  Present Irp Q..: %s\n",
        DumpQueueHead (DevState, DevState, Off)
        );

    dprintf("\n");
    dprintf("Order:\n");
    dprintf("  DevNode Seq....: %x\n",   (ULONG) ReadField(Order.DevNodeSequence));
    if (ReadField(Order.NoLists)) {
        poDumpOldNotifyList();
    } else {
        poDumpNewNotifyList(DevState);
    }

    //
    // Dump device notification list order
    //


    //
    // Dump device power irps
    //


    GetFieldOffset("nt!_POP_DEVICE_SYS_STATE","Head", &HeadOff);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Pending", &Off);
    DumpDevicePowerIrp ("Pending irps",   DevState, DevState+HeadOff, Off);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Complete", &Off);
    DumpDevicePowerIrp ("Completed irps", DevState, DevState+HeadOff, Off);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Abort", &Off);
    DumpDevicePowerIrp ("Abort irps",     DevState, DevState+HeadOff, Off);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Failed", &Off);
    DumpDevicePowerIrp ("Failed irps",    DevState, DevState+HeadOff, Off);
    dprintf("\n");
}


DECLARE_API( poaction )
/*++

Routine Description:

    Dumps the current power action structure

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64                 addr;
    ULONG                   i;
    UCHAR                   c, State, Updates;
    ULONG                   Flags;

    addr = GetExpression( "nt!PopAction" );
    if (!addr) {
        dprintf("Error retrieving address of PopAction\n");
        return E_INVALIDARG;
    }

    if (GetFieldValue(addr, "nt!POP_POWER_ACTION", "State", State)) {
        dprintf("Error reading PopAction\n");
        return E_INVALIDARG;
    }

    InitTypeRead(addr, nt!POP_POWER_ACTION);
    dprintf("PopAction: %08x\n", addr);

    dprintf("  State..........: %x ",  State);
    switch (State) {
        case PO_ACT_IDLE:               dprintf ("- Idle\n");             break;
        case PO_ACT_NEW_REQUEST:        dprintf ("- New request\n");      break;
        case PO_ACT_CALLOUT:            dprintf ("- Winlogon callout\n"); break;
        case PO_ACT_SET_SYSTEM_STATE:   dprintf ("- Set System State\n"); break;
        default:                        dprintf ("\n"); break;
    }

    dprintf("  Updates........: %x ",  (Updates = (UCHAR) ReadField(Updates)));
    if (Updates & PO_PM_USER)        dprintf(" user ");
    if (Updates & PO_PM_REISSUE)     dprintf(" reissue ");
    if (Updates & PO_PM_SETSTATE)    dprintf(" setstate ");
    if (ReadField(Shutdown))                    dprintf(" SHUTDOWN-set ");
    dprintf("\n");

    dprintf("  Action.........: %s\n", PowerAction((ULONG) ReadField(Action)));
    dprintf("  Lightest State.: %s\n", SystemState((ULONG) ReadField(LightestState)));
    dprintf("  Flags..........: %x", (Flags = (ULONG) ReadField(Flags)));

    c = ' ';
    for (i=0; ActFlags[i].Flags; i++) {
        if (Flags & ActFlags[i].Flags) {
            dprintf ("%c%s", c, ActFlags[i].String);
            c = '|';
        }
    }
    dprintf("\n");

    dprintf("  Irp minor......: %s\n", PoIrpMinor ((UCHAR)ReadField(IrpMinor)));
    dprintf("  System State...: %s\n", SystemState((ULONG) ReadField(SystemState)));
    dprintf("  Hiber Context..: %08p\n", ReadField(HiberContext));

    if (ReadField(DevState)) {
        dprintf ("\n");
        PoDevState ();
    }

    dprintf("\n");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT
#include <wdbgexts.h>


#include <dbgeng.h>

#include "extsfns.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#ifndef EXTENSION_API
#define EXTENSION_API( name )  \
HRESULT _EFN_##name
#endif // EXTENSION_API

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL2       g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern ULONG64  STeip;
extern ULONG64  STebp;
extern ULONG64  STesp;
extern ULONG64  EXPRLastDump;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

#ifdef DEFINE_GUID
#undef DEFINE_GUID
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

//
// Flag definitions used by extensions
//
#include "extflags.h"


#define ADDRESS_NOT_VALID 0
#define ADDRESS_VALID 1
#define ADDRESS_TRANSITION 2


//#define POOL_TYPE_AND_QUOTA_MASK (15)



#define MAXULONG64_PTR (~((ULONG64)0))
#define MAXLONG64_PTR  ((LONG64)(MAXULONG64_PTR >> 1))
#define MINLONG64_PTR  (~MAXLONG64_PTR)

#define POOL_BIG_TABLE_ENTRY_FREE   0x1

//
// macros to crack the ControllerId field of the socket info structure
//
#define PcmciaClassFromControllerType(type) (((type) & 0xff))
#define PcmciaModelFromControllerType(type) (((type) >> 8) & 0x3ffff)
#define PcmciaRevisionFromControllerType(type) ((type) >> 26)

#ifdef PAGE_SIZE
#undef PAGE_SIZE
#endif

#define DBG_PTR_SIZE      (IsPtr64() ? 8 : 4)

extern ULONG PageSize;
extern ULONG BuildNo;
extern ULONG PoolBlockShift;
extern BOOL  NewPool;
#define _KB (PageSize/1024)

#define POOL_BLOCK_SHIFT_OLD ((PageSize == 0x4000)  ? 6 : (((PageSize == 0x2000) || ((BuildNo < 2257) && (PageSize == 0x1000))) ? 5 : 4))
#define POOL_BLOCK_SHIFT_LAB1_2402 ((PageSize == 0x4000)  ? 5 : (((PageSize == 0x2000)) ? 4 : 3))

#define POOL_BLOCK_SHIFT   PoolBlockShift

#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) (PageSize - 1))))

#define GetBits(from, pos, num)  ((from >> pos) & (((ULONG64) ~0) >> (sizeof(ULONG64)*8 - num)))


extern ULONG64 PaeEnabled;
extern ULONG TargetMachine;
extern ULONG TargetIsDump;

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;

__inline
ULONG64
KD_OBJECT_TO_OBJECT_HEADER(
    ULONG64  o
    )
{
    static ULONG Off=0, GotOff=0;
    if (!GotOff &&
        !GetFieldOffset("nt!_OBJECT_HEADER", "Body", &Off)) {
        GotOff = TRUE;
    } else if (!GotOff){
        return 0;
    }
    return o - Off;
}

__inline
ULONG64
KD_OBJECT_HEADER_TO_OBJECT(
    ULONG64  o
    )
{
    static ULONG Off=0, GotOff=0;
    if (!GotOff &&
        !GetFieldOffset("nt!_OBJECT_HEADER", "Body", &Off)) {
        GotOff = TRUE;
    } else if (!GotOff){
        return 0;
    }
    return o + Off;
}

__inline
VOID
KD_OBJECT_HEADER_TO_QUOTA_INFO(
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG QuotaInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "QuotaInfoOffset", QuotaInfoOffset);
    *pOutH = (QuotaInfoOffset == 0 ? 0 : ((oh) - QuotaInfoOffset));
}


__inline
VOID
KD_OBJECT_HEADER_TO_HANDLE_INFO (
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG HandleInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "HandleInfoOffset", HandleInfoOffset);
    *pOutH = (HandleInfoOffset == 0 ? 0 : ((oh) - HandleInfoOffset));
}

__inline
VOID
KD_OBJECT_HEADER_TO_NAME_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG NameInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "NameInfoOffset", NameInfoOffset);
    *pOutH = (NameInfoOffset == 0 ? 0 : ((oh) - NameInfoOffset));
}

__inline
VOID
KD_OBJECT_HEADER_TO_CREATOR_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG Flags=0;
    GetFieldValue(oh, "_OBJECT_HEADER", "Flags", Flags);
    *pOutH = ((Flags & OB_FLAG_CREATOR_INFO) == 0 ? 0 : ((oh) - GetTypeSize("_OBJECT_HEADER_CREATOR_INFO")));
}



//-----------------------------------------------------------------------------------------
//
//  prototypes for internal non-exported support functions
//
//-----------------------------------------------------------------------------------------

//
// get data from DebuggerData or GetExpression as appropriate
//

char ___SillyString[];
extern KDDEBUGGER_DATA64 KdDebuggerData;

#define GetNtDebuggerData(NAME)                                      \
     (HaveDebuggerData()? (GetDebuggerData(KDBG_TAG,                 \
                                           &KdDebuggerData,          \
                                           sizeof(KdDebuggerData)),  \
                           KdDebuggerData.NAME):                     \
                         GetExpression( (strcpy(___SillyString, #NAME), ___SillyString) ))

#define GetNtDebuggerDataValue(NAME)                                     \
    (HaveDebuggerData()?                                                 \
        GetUlongFromAddress((GetDebuggerData(KDBG_TAG,                   \
                                             &KdDebuggerData,            \
                                             sizeof(KdDebuggerData)),    \
                             KdDebuggerData.NAME)                        \
                            ):                                           \
        GetUlongValue( (strcpy(___SillyString, #NAME), ___SillyString) ))


//
// This is used to read pointer values from address.
//

#define GetNtDebuggerDataPtrValue(NAME)                                     \
    (HaveDebuggerData()?                                                 \
        GetPointerFromAddress((GetDebuggerData(KDBG_TAG,                   \
                                             &KdDebuggerData,            \
                                             sizeof(KdDebuggerData)),    \
                             KdDebuggerData.NAME)                        \
                            ):                                           \
        GetPointerValue( (strcpy(___SillyString, #NAME), ___SillyString) ))

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;


extern BOOL
HaveDebuggerData(
    VOID
    );

BOOL
ReadPcr(
    USHORT  Processor,
    PVOID   Pcr,
    PULONG  AddressOfPcr,
    HANDLE  hThread
    );

ULONG
GetUlongFromAddress (
    ULONG64 Location
    );

ULONG
GetUlongValue (
    PCHAR String
    );

ULONG64
GetGlobalFromAddress (
    ULONG64 Location,
    ULONG   Size
    );

ULONG64
GetGlobalValue (
    PCHAR  String
    );

HRESULT
GetGlobalEx(
    PCHAR String,
    PVOID OutValue,
    ULONG OutSize
    );

#define GetGlobal( _String, _OutValue ) \
    GetGlobalEx( (_String), &(_OutValue), sizeof(_OutValue) )

BOOLEAN
ReadMemoryUncached (
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesRead
    );

BOOLEAN
WriteMemoryUncached (
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesWritten
    );

/////////////////////////////////////////////
//
//  KdExts.c
//
/////////////////////////////////////////////


BOOL
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    );

HRESULT
ExecuteCommand(
    IN PDEBUG_CLIENT Client,
    IN PSTR Command
    );

HRESULT 
GetExtensionFunction(
    IN PCSTR FunctionName,
    IN FARPROC *Function
    );

/////////////////////////////////////////////
//
//  CritSec.c
//
/////////////////////////////////////////////

PLIST_ENTRY
DumpCritSec(
    HANDLE  hCurrentProcess,
    DWORD   dwAddrCritSec,
    BOOLEAN bDumpIfUnowned
    );



/////////////////////////////////////////////
//
//  Device.c
//
/////////////////////////////////////////////

VOID
DumpDevice(
    ULONG64 DeviceAddress,
    ULONG   FieldWidth,
    BOOLEAN FullDetail
    );

HRESULT
GetDevObjInfo(
    IN ULONG64 DeviceObject,
    OUT PDEBUG_DEVICE_OBJECT_INFO pDevObjInfo
    );

/////////////////////////////////////////////
//
// Devnode.c
//
/////////////////////////////////////////////

typedef struct _FLAG_NAME {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

VOID
DumpDeviceCapabilities(
    ULONG64 caps
    );

VOID
DumpFlags(
         ULONG Depth,
         LPSTR FlagDescription,
         ULONG Flags,
         PFLAG_NAME FlagTable
         );

VOID
xdprintf(
        ULONG Depth,
        PCHAR S,
        ...
        );

BOOLEAN
xReadMemory (
            ULONG64 S,
            PVOID D,
            ULONG Len
            );

/////////////////////////////////////////////
//
//  Driver.c
//
/////////////////////////////////////////////

VOID
DumpDriver(
    ULONG64 DriverAddress,
    ULONG   FieldWidth,
    ULONG   Flags
    );

HRESULT
GetDrvObjInfo(
    IN ULONG64 DriverObject,
    OUT PDEBUG_DRIVER_OBJECT_INFO pDrvObjInfo);

/////////////////////////////////////////////
//
//  irp.c
//
/////////////////////////////////////////////

HRESULT
GetIrpInfo(
    ULONG64 Irp,
    PDEBUG_IRP_INFO pIrp
    );

/////////////////////////////////////////////
//
//  lock.c
//
/////////////////////////////////////////////

VOID
DumpStaticFastMutex (
    IN PCHAR Name
    );


/////////////////////////////////////////////
//
//  memory.c
//
/////////////////////////////////////////////

VOID
MemoryUsage (
    IN ULONG64 PfnStart,
    IN ULONG64 LowPage,
    IN ULONG64 HighPage,
    IN ULONG IgnoreInvalidFrames
    );



/////////////////////////////////////////////
//
//  Object.c
//
/////////////////////////////////////////////
extern ULONG64 EXPRLastDump;

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;

typedef BOOLEAN (*ENUM_TYPE_ROUTINE)(
    IN ULONG64          pObjectHeader,
    IN PVOID            Parameter
    );

//
// Object Table Entry Structure
//
typedef struct _OBJECT_TABLE_ENTRY {
    ULONG       NonPagedObjectHeader;
    ACCESS_MASK GrantedAccess;
} OBJECT_TABLE_ENTRY, *POBJECT_TABLE_ENTRY;
#define LOG_OBJECT_TABLE_ENTRY_SIZE 1

BOOLEAN
FetchObjectManagerVariables(
    BOOLEAN ForceReload
    );

ULONG64
FindObjectByName(
    IN PUCHAR  Path,
    IN ULONG64 RootObject
    );

ULONG64
FindObjectType(
    IN PUCHAR TypeName
    );

BOOLEAN
DumpObject(
    IN char     *Pad,
    IN ULONG64  Object,
//    IN POBJECT_HEADER OptObjectHeader OPTIONAL,
    IN ULONG    Flags
    );

BOOLEAN
WalkObjectsByType(
    IN PUCHAR               ObjectTypeName,
    IN ENUM_TYPE_ROUTINE    EnumRoutine,
    IN PVOID                Parameter
    );

BOOLEAN
CaptureObjectName(
    IN ULONG64          pObjectHeader,
//    IN POBJECT_HEADER   ObjectHeader,
    IN PWSTR            Buffer,
    IN ULONG            BufferSize
    );

VOID
DumpObjectName(
   ULONG64 ObjectAddress
   );


/////////////////////////////////////////////
//
//  pcr.c
//
/////////////////////////////////////////////
BOOL
ReadTargetPcr (
    OUT PULONG64 PPcr,
    IN ULONG     Processor
    );


/////////////////////////////////////////////
//
//  Pool.c
//
/////////////////////////////////////////////


typedef
BOOLEAN
(WINAPI *POOLFILTER) (
    PCHAR   Tag,
    PCHAR   Filter,
    ULONG   Flags,
    ULONG64 PoolHeader,
    ULONG   BlockSize,
    ULONG64 Data,
    PVOID   Context
    );


void SearchPool(
    ULONG   TagName,
    ULONG   Flags,
    ULONG64 RestartAddr,
    POOLFILTER Filter,
    PVOID   Context
    );

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );

LOGICAL
PoolInitializeGlobals(void);

HRESULT
ListPoolPage(
    ULONG64 PoolPageToDump,
    ULONG   Flags,
    PDEBUG_POOL_DATA PoolData
    );

PSTR
GetPoolTagDescription(
    IN ULONG PoolTag
    );

void
PrintPoolRegion(
    ULONG64 Pool
    );


/////////////////////////////////////////////
//
//  Process.c
//
/////////////////////////////////////////////

extern CHAR *WaitReasonList[];

BOOL
DumpProcess(
   IN char * pad,
   IN ULONG64 RealProcessBase,
   IN ULONG Flags,
   IN OPTIONAL PCHAR ImageFileName
   );

BOOL
DumpThread (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG64 Flags
    );

BOOL
DumpThreadEx (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG Flags,
    IN PDEBUG_CLIENT pDbgClient
    );

VOID
dumpSymbolicAddress(
    ULONG64 Address,
    PCHAR   Buffer,
    BOOL    AlwaysShowHex
    );

BOOLEAN
FetchProcessStructureVariables(
    VOID
    );


ULONG
GetAddressState(
    IN ULONG64 VirtualAddress
    );

typedef struct _PROCESS_COMMIT_USAGE {
    UCHAR ImageFileName[ 16 ];
    ULONG64 ClientId;
    ULONG64 ProcessAddress;
    ULONG64 CommitCharge;
    ULONG64 NumberOfPrivatePages;
    ULONG64 NumberOfLockedPages;
} PROCESS_COMMIT_USAGE, *PPROCESS_COMMIT_USAGE;


PPROCESS_COMMIT_USAGE
GetProcessCommit (
    PULONG64 TotalCommitCharge,
    PULONG   NumberOfProcesses
    );

VOID
DumpMmThreads (
    VOID
    );

/////////////////////////////////////////////
//
//  pte.c
//
/////////////////////////////////////////////


ULONG
DbgGetValid(
    ULONG64 Pte
    );

ULONG64
DbgGetPdeAddress(
    IN ULONG64 VirtualAddress
    );

ULONG64
DbgGetPteAddress(
    IN ULONG64 VirtualAddress
    );

ULONG64
DbgGetFrameNumber(
    ULONG64 Pte
    );

ULONG64
DbgGetSubsectionAddress(
    IN ULONG64 Pte
    );

ULONG64
DbgGetVirtualAddressMappedByPte(
    IN ULONG64 Pte
    );


/////////////////////////////////////////////
//
//  Registry.c
//
/////////////////////////////////////////////
USHORT
GetKcbName(
    ULONG64 KcbAddr,
    PWCHAR  NameBuffer,
    ULONG   BufferSize
);


/////////////////////////////////////////////
//
//  sel.c
//
/////////////////////////////////////////////
// X86 only

//
//  LDT descriptor entry
//

typedef struct _LDT_ENTRY_X86 {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY_X86, *PLDT_ENTRY_X86;

typedef struct _DESCRIPTOR_TABLE_ENTRY_X86 {
    ULONG Selector;
    LDT_ENTRY_X86 Descriptor;
} DESCRIPTOR_TABLE_ENTRY_X86, *PDESCRIPTOR_TABLE_ENTRY_X86;

NTSTATUS
LookupSelector(
    IN USHORT Processor,
    IN OUT PDESCRIPTOR_TABLE_ENTRY_X86 pDescriptorTableEntry
    );

/////////////////////////////////////////////
//
//  trap.cpp
//
/////////////////////////////////////////////

// IA64 only

typedef enum _DISPLAY_MODE {
    DISPLAY_MIN     = 0,
    DISPLAY_DEFAULT = DISPLAY_MIN,
    DISPLAY_MED     = 1,
    DISPLAY_MAX     = 2,
    DISPLAY_FULL    = DISPLAY_MAX
} DISPLAY_MODE;

typedef struct _EM_REG_FIELD  {
   const    char   *SubName;
   const    char   *Name;
   unsigned long    Length;
   unsigned long    Shift;
} EM_REG_FIELD, *PEM_REG_FIELD;

VOID
DisplayFullEmRegField(
    ULONG64      EmRegValue,
    EM_REG_FIELD EmRegFields[],
    ULONG        Field
    );

VOID
DisplayFullEmReg(
    IN ULONG64      Val,
    IN EM_REG_FIELD EmRegFields[],
    IN DISPLAY_MODE DisplayMode
    );

/////////////////////////////////////////////
//
//  Util.c
//
/////////////////////////////////////////////

typedef VOID
(*PDUMP_SPLAY_NODE_FN)(
    ULONG64 RemoteAddress,
    ULONG   Level
    );

ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    );

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

ULONG
GetBitFieldOffset (
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG
GetFieldOffsetEx ( // returns Offset and Size...
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    );

VOID
DumpUnicode(
    UNICODE_STRING u
    );

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    );


ULONG64
GetPointerValue (
    PCHAR String
    );

BOOLEAN
IsHexNumber(
   const char *szExpression
   );

BOOLEAN
IsDecNumber(
   const char *szExpression
   );

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );

ULONG64
UtilStringToUlong64 (
    UCHAR *String
    );

#define ENUM_NAME(val)            {val, #val}

typedef struct _ENUM_NAME {
   ULONG        EnumVal;
   const char * Name;
} ENUM_NAME, *PENUM_NAME;

const char *
getEnumName(
        ULONG       EnumVal,
        PENUM_NAME EnumTable
        );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\process.cpp ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    process.c

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:
 
    Kshitiz K. Sharma (kksharma)
    
    Using debugger type info.
--*/

#include "precomp.h"
#pragma hdrstop

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition
    } KTHREAD_STATE;


CHAR *WaitReasonList[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "WrExecutive",
    "WrFreePage",
    "WrPageIn",
    "WrPoolAllocation",
    "WrDelayExecution",
    "WrSuspended",
    "WrUserRequest",
    "WrEventPairHigh",
    "WrEventPairLow",
    "WrLpcReceive",
    "WrLpcReply",
    "WrVirtualMemory",
    "WrPageOut",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7"};


extern ULONG64 STeip, STebp, STesp;
#if 0  //  MAKE IT BUILD
static PHANDLE_TABLE PspCidTable;
static HANDLE_TABLE CapturedPspCidTable;
#endif

ULONG64 ProcessLastDump;
ULONG64 ThreadLastDump;
ULONG   TotalProcessCommit;


CHAR * SecImpLevel[] = {
            "Anonymous",
            "Identification",
            "Impersonation",
            "Delegation" };

#define SecImpLevels(x) (x < sizeof( SecImpLevel ) / sizeof( PSTR ) ? \
                        SecImpLevel[ x ] : "Illegal Value" )

typedef BOOLEAN (WINAPI *PENUM_PROCESS_CALLBACK)(PVOID ProcessAddress, PVOID Process, PVOID ThreadAddress, PVOID Thread);

BOOLEAN
GetTheSystemTime (
    OUT PLARGE_INTEGER Time
    )
{
    BYTE               readTime[20]={0};
    PCHAR              SysTime;
    ULONG              err;

    ZeroMemory( Time, sizeof(*Time) );

    SysTime = "SystemTime";

    if (err = GetFieldValue(MM_SHARED_USER_DATA_VA, "nt!_KUSER_SHARED_DATA", SysTime, readTime)) {
        if (err == MEMORY_READ_ERROR) {
            dprintf( "unable to read memory @ %lx\n",
                     MM_SHARED_USER_DATA_VA);
        } else {
            dprintf("type nt!_KUSER_SHARED_DATA not found.\n");
        }
        return FALSE;
    }

    *Time = *(LARGE_INTEGER UNALIGNED *)&readTime[0];
    
    return TRUE;
}


VOID
dumpSymbolicAddress(
    ULONG64 Address,
    PCHAR   Buffer,
    BOOL    AlwaysShowHex
    )
{
    ULONG64 displacement;
    PCHAR s;

    Buffer[0] = '!';
    GetSymbol((ULONG64)Address, Buffer, &displacement);
    s = (PCHAR) Buffer + strlen( (PCHAR) Buffer );
    if (s == (PCHAR) Buffer) {
        sprintf( s, (IsPtr64() ? "0x%016I64x" : "0x%08x"), Address );
        }
    else {
        if (displacement != 0) {
            sprintf( s, (IsPtr64() ? "+0x%016I64x" : "+0x%08x"), displacement );
            }
        if (AlwaysShowHex) {
            sprintf( s, (IsPtr64() ? " (0x%016I64x)" : " (0x%08x)"), Address );
            }
        }

    return;
}

BOOL
GetProcessHead(PULONG64 Head, PULONG64 First)
{
    ULONG64 List_Flink = 0;
        
    *Head = GetNtDebuggerData( PsActiveProcessHead ); 
    if (!*Head) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(*Head, "nt!_LIST_ENTRY", "Flink", List_Flink)) {
        dprintf("Unable to read _LIST_ENTRY @ %p \n", *Head);
        return FALSE;
    }

    if (List_Flink == 0) {
        dprintf("NULL value in PsActiveProcess List\n");
        return FALSE;
    }
    
    *First = List_Flink;
    return TRUE;
}

ULONG64
LookupProcessByName(PCSTR Name, BOOL Verbose)
{
    ULONG64 ProcessHead, Process;
    ULONG64 ProcessNext;
    ULONG   Off;

    if (!GetProcessHead(&ProcessHead, &ProcessNext)) {
        return 0;
    }

    //
    // Walk through the list and find the process with the desired name.
    //
    
    if (GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &Off)) {
        dprintf("Unable to get EPROCESS.ActiveProcessLinks offset\n");
        return 0;
    }
    
    while (ProcessNext != 0 && ProcessNext != ProcessHead) {
        char ImageFileName[64];
        
        Process = ProcessNext - Off;

        if (GetFieldValue(Process, "nt!_EPROCESS", "ImageFileName",
                          ImageFileName)) {
            dprintf("Cannot read EPROCESS at %p\n", Process);
        } else {
            if (Verbose) {
                dprintf("  Checking process %s\n", ImageFileName);
            }
            
            if (!_strcmpi(Name, ImageFileName)) {
                return Process;
            }
        }

        if (!ReadPointer(ProcessNext, &ProcessNext)) {
            dprintf("Cannot read EPROCESS at %p\n", Process);
            return 0;
        }
        
        if (CheckControlC()) {
            return 0;
        }
    }
    
    return 0;
}

BOOL
WaitForExceptionEvent(ULONG Code, ULONG FirstChance, ULONG64 Process)
{
    HRESULT Status;
        
    Status = g_ExtControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
    if (Status != S_OK) {
        dprintf("Unable to wait, 0x%X\n", Status);
        return Status;
    }

    //
    // Got some kind of event.  Make sure it's the right kind.
    //
    
    ULONG Type, ProcId, ThreadId;
    DEBUG_LAST_EVENT_INFO_EXCEPTION ExInfo;
        
    if ((Status = g_ExtControl->
         GetLastEventInformation(&Type, &ProcId, &ThreadId,
                                 &ExInfo, sizeof(ExInfo), NULL,
                                 NULL, 0, NULL)) != S_OK) {
        dprintf("Unable to get event information\n");
        return Status;
    }

    if (Type != DEBUG_EVENT_EXCEPTION ||
        (ULONG)ExInfo.ExceptionRecord.ExceptionCode != Code ||
        ExInfo.FirstChance != FirstChance) {
        dprintf("Unexpected event occurred\n");
        return E_UNEXPECTED;
    }

    if (Process) {
        ULONG Processor;
        ULONG64 EventProcess;
        
        if (!GetCurrentProcessor(g_ExtClient, &Processor, NULL)) {
            Processor = 0;
        }
        GetCurrentProcessAddr(Processor, 0, &EventProcess);
        if (EventProcess != Process) {
            dprintf("Event occurred in wrong process\n");
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}

BOOL
WaitForSingleStep(ULONG64 Process)
{
    HRESULT Status;
        
    Status = g_ExtControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
    if (Status != S_OK) {
        dprintf("Unable to wait, 0x%X\n", Status);
        return Status;
    }

    //
    // Got some kind of event.  Make sure it's the right kind.
    //
    
    ULONG Type, ProcId, ThreadId;
        
    if ((Status = g_ExtControl->
         GetLastEventInformation(&Type, &ProcId, &ThreadId,
                                 NULL, 0, NULL,
                                 NULL, 0, NULL)) != S_OK) {
        dprintf("Unable to get event information\n");
        return Status;
    }

    if (Type != 0) {
        dprintf("Unexpected event occurred\n");
        return E_UNEXPECTED;
    }

    if (Process) {
        ULONG Processor;
        ULONG64 EventProcess;
        
        if (!GetCurrentProcessor(g_ExtClient, &Processor, NULL)) {
            Processor = 0;
        }
        GetCurrentProcessAddr(Processor, 0, &EventProcess);
        if (EventProcess != Process) {
            dprintf("Event occurred in wrong process\n");
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}

DECLARE_API( bpid )

/*++

Routine Description:

    Uses winlogon to cause a user-mode break in the given process.

Arguments:

    None.

Return Value:

    None.

--*/

{
    INIT_API();

    if (BuildNo < 2195) {
        dprintf("bpid only works on 2195 or above\n");
        goto Exit;
    }
    if (TargetMachine != IMAGE_FILE_MACHINE_I386 &&
        TargetMachine != IMAGE_FILE_MACHINE_IA64) {
        dprintf("bpid is only implemented for x86 and IA64\n");
        goto Exit;
    }

    BOOL StopInWinlogon;
    BOOL Verbose;
    BOOL WritePidToMemory;
    ULONG WhichGlobal;
    PSTR WhichGlobalName;

    StopInWinlogon = FALSE;
    Verbose = FALSE;
    WritePidToMemory = FALSE;
    WhichGlobal = 1;
    WhichGlobalName = "Breakin";
    
    for (;;)
    {
        while (*args == ' ' || *args == '\t')
        {
            args++;
        }

        if (*args == '-' || *args == '/')
        {
            switch(*++args)
            {
            case 'a':
                // Set g_AttachProcessId instead of
                // g_BreakinProcessId.
                WhichGlobal = 2;
                WhichGlobalName = "Attach";
                break;
            case 's':
                StopInWinlogon = TRUE;
                break;
            case 'v':
                Verbose = TRUE;
                break;
            case 'w':
                WritePidToMemory = TRUE;
                break;
            default:
                dprintf("Unknown option '%c'\n", *args);
                goto Exit;
            }

            args++;
        }
        else
        {
            break;
        }
    }
    
    ULONG64 Pid;
    
    if (!GetExpressionEx(args, &Pid, &args)) {
        dprintf("Usage: bpid <pid>\n");
        goto Exit;
    }

    ULONG64 Winlogon;
    ULONG64 WinlToken;
    
    dprintf("Finding winlogon...\n");
    Winlogon = LookupProcessByName("winlogon.exe", Verbose);
    if (Winlogon == 0) {
        dprintf("Unable to find winlogon\n");
        goto Exit;
    }
    if (GetFieldValue(Winlogon, "nt!_EPROCESS", "Token", WinlToken)) {
        dprintf("Unable to read winlogon process token\n");
        goto Exit;
    }
    // Low bits of the token value are flags.  Mask off to get pointer.
    if (IsPtr64()) {
        WinlToken &= ~15;
    } else {
        WinlToken = (ULONG64)(LONG64)(LONG)(WinlToken & ~7);
    }

    ULONG ExpOff;

    //
    // winlogon checks its token expiration time.  If it's
    // zero it breaks in and checks a few things, one of which is whether
    // it should inject a DebugBreak into a process.  First,
    // set the token expiration to zero so that winlogon breaks in.
    //
    
    if (GetFieldOffset("nt!_TOKEN", "ExpirationTime", &ExpOff)) {
        dprintf("Unable to get TOKEN.ExpirationTime offset\n");
        goto Exit;
    }
    
    WinlToken += ExpOff;
    
    ULONG64 Expiration, Zero;
    ULONG Done;

    // Save the expiration time.
    if (!ReadMemory(WinlToken, &Expiration, sizeof(Expiration), &Done) ||
        Done != sizeof(Expiration)) {
        dprintf("Unable to read token expiration\n");
        goto Exit;
    }

    // Zero it.
    Zero = 0;
    if (!WriteMemory(WinlToken, &Zero, sizeof(Zero), &Done) ||
        Done != sizeof(Zero)) {
        dprintf("Unable to write token expiration\n");
        goto Exit;
    }

    HRESULT Hr;

    // Get things running.
    if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_GO) != S_OK) {
        dprintf("Unable to go\n");
        goto RestoreExp;
    }
    
    // Wait for a breakin.
    dprintf("Waiting for winlogon to break.  "
            "This can take a couple of minutes...\n");
    Hr = WaitForExceptionEvent(STATUS_BREAKPOINT, TRUE, Winlogon);
    if (Hr != S_OK) {
        goto RestoreExp;
    }

    //
    // We broke into winlogon.
    // We need to set winlogon!g_[Breakin|Attach]ProcessId to
    // the process we want to break into.  Relying on symbols
    // is pretty fragile as the image header may be paged out
    // or the symbol path may be wrong.  Even if we had good symbols
    // the variable itself may not be paged in at this point.
    // The approach taken here is to single-step out to where
    // the global is checked and insert the value at that
    // point.  winlogon currently checks two globals after the
    // DebugBreak.  g_BreakinProcessId is the first one and
    // g_AttachProcessId is the second.
    //

    ULONG Steps;
    ULONG Globals;
    ULONG64 BpiAddr;
    ULONG64 UserProbeAddress;
    PSTR RegDst;
    
    dprintf("Stepping to g_%sProcessId check...\n", WhichGlobalName);
    Steps = 0;
    Globals = 0;
    UserProbeAddress = GetNtDebuggerDataValue(MmUserProbeAddress); 
    while (Globals < WhichGlobal)
    {
        if (CheckControlC()) {
            goto RestoreExp;
        }
        
        if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_STEP_OVER) != S_OK) {
            dprintf("Unable to start step\n");
            goto RestoreExp;
        }
        
        Hr = WaitForSingleStep(Winlogon);
        if (Hr != S_OK) {
            goto RestoreExp;
        }

        char DisStr[128];
        int DisStrLen;
        ULONG64 Pc;
        
        // Check whether this is a global load.
        if (g_ExtRegisters->GetInstructionOffset(&Pc) != S_OK ||
            g_ExtControl->Disassemble(Pc, 0, DisStr, sizeof(DisStr),
                                      NULL, &Pc) != S_OK) {
            dprintf("Unable to check step\n");
            goto RestoreExp;
        }

        // Remove newline at end.
        DisStrLen = strlen(DisStr);
        if (DisStrLen > 0 && DisStr[DisStrLen - 1] == '\n') {
            DisStr[--DisStrLen] = 0;
        }
        
        if (Verbose) {
            dprintf("  Step to '%s'\n", DisStr);
        }
        
        BpiAddr = 0;
        RegDst = NULL;
        
        PSTR OffStr;
        
        switch(TargetMachine) {
        case IMAGE_FILE_MACHINE_I386:
            if (strstr(DisStr, "mov") != NULL &&
                strstr(DisStr, " eax,[") != NULL &&
                DisStr[DisStrLen - 1] == ']' &&
                (OffStr = strchr(DisStr, '[')) != NULL) {

                RegDst = "eax";
                
                //
                // Found a load.  Parse the offset.
                //

                PSTR SymTailStr = strchr(OffStr + 1, '(');
                
                if (SymTailStr != NULL) {
                    // There's a symbol name in the reference.  We
                    // can't check the actual symbol name as symbols
                    // aren't necessarily correct, so just skip
                    // to the open paren.
                    OffStr = SymTailStr + 1;
                }
                
                for (;;) {
                    OffStr++;
                    if (*OffStr >= '0' && *OffStr <= '9') {
                        BpiAddr = BpiAddr * 16 + (*OffStr - '0');
                    } else if (*OffStr >= 'a' && *OffStr <= 'f') {
                        BpiAddr = BpiAddr * 16 + (*OffStr - 'a');
                    } else {
                        BpiAddr = (ULONG64)(LONG64)(LONG)BpiAddr;
                        break;
                    }
                }
                if (*OffStr != ']' && *OffStr != ')') {
                    BpiAddr = 0;
                }
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:
            if (strstr(DisStr, "ld4") != NULL &&
                (OffStr = strchr(DisStr, '[')) != NULL) {

                // Extract destination register name.
                RegDst = OffStr - 1;
                if (*RegDst != '=') {
                    break;
                }
                *RegDst-- = 0;
                while (RegDst > DisStr && *RegDst != ' ') {
                    RegDst--;
                }
                if (*RegDst != ' ') {
                    break;
                }
                RegDst++;

                // Extract source register name and value.
                PSTR RegSrc = ++OffStr;
                while (*OffStr && *OffStr != ']') {
                    OffStr++;
                }
                if (*OffStr == ']') {
                    *OffStr = 0;

                    DEBUG_VALUE RegVal;
                    ULONG RegIdx;
                    
                    if (g_ExtRegisters->GetIndexByName(RegSrc,
                                                       &RegIdx) == S_OK &&
                        g_ExtRegisters->GetValue(RegIdx, &RegVal) == S_OK &&
                        RegVal.Type == DEBUG_VALUE_INT64) {
                        BpiAddr = RegVal.I64;
                    }
                }
            }
            break;
        }

        if (RegDst != NULL &&
            BpiAddr >= 0x10000 && BpiAddr < UserProbeAddress) {
            // Looks like a reasonable global load.
            Globals++;
        }
        
        if (++Steps > 30) {
            dprintf("Unable to find g_%sProcessId load\n", WhichGlobalName);
            goto RestoreExp;
        }
    }

    //
    // We're at the mov eax,[g_BreakinProcessId] instruction.
    // Execute the instruction to accomplish two things:
    // 1. The page will be made available so we can write
    //    to it if we need to.
    // 2. If we don't want to write the actual memory we
    //    can just set eax to do a one-time break.
    //
    
    if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_STEP_OVER) != S_OK) {
        dprintf("Unable to start step\n");
        goto RestoreExp;
    }
        
    Hr = WaitForSingleStep(Winlogon);
    if (Hr != S_OK) {
        goto RestoreExp;
    }

    char RegCmd[64];

    //
    // Update the register and write memory if necessary.
    //
    
    sprintf(RegCmd, "r %s=0x0`%x", RegDst, (ULONG)Pid);
    if (g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, RegCmd,
                              DEBUG_EXECUTE_NOT_LOGGED |
                              DEBUG_EXECUTE_NO_REPEAT) != S_OK) {
        goto RestoreExp;
    }
    
    if (WritePidToMemory) {
        if (!WriteMemory(BpiAddr, &Pid, sizeof(ULONG), &Done) ||
            Done != sizeof(ULONG)) {
            dprintf("Unable to write pid to g_%sProcessId, continuing\n",
                    WhichGlobalName);
        }
    }

    // Everything is set.  Resume execution and the break should
    // occur.
    dprintf("Break into process %x set.  "
            "The next break should be in the desired process.\n",
            (ULONG)Pid);

    if (!StopInWinlogon) {
        if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_GO) != S_OK) {
            dprintf("Unable to go\n");
        }
    } else {
        dprintf("Stopping in winlogon\n");
    }
    
 RestoreExp:
    if (!WriteMemory(WinlToken, &Expiration, sizeof(Expiration), &Done) ||
        Done != sizeof(Expiration)) {
        dprintf("Unable to restore token expiration\n");
    }
    
 Exit:
    EXIT_API();
    return S_OK;
}

BOOL
GetProcessSessionId(ULONG64 Process, PULONG SessionId)
{
    *SessionId = 0;
    
    if (BuildNo && BuildNo < 2280) {
        GetFieldValue(Process, "nt!_EPROCESS", "SessionId", *SessionId);
    } else {
        ULONG64 SessionPointer;

        GetFieldValue(Process, "nt!_EPROCESS", "Session", SessionPointer);
        if (SessionPointer != 0) {
            if (GetFieldValue(SessionPointer, "nt!_MM_SESSION_SPACE",
                              "SessionId", *SessionId)) {
                dprintf("Could not find _MM_SESSION_SPACE type at %p.\n",
                        SessionPointer);
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL 
DumpProcess(
   IN char * pad,
   IN ULONG64 RealProcessBase,
   IN ULONG Flags,
   IN OPTIONAL PCHAR ImageFileName
   )
{
    LARGE_INTEGER RunTime;
    BOOL LongAddrs = IsPtr64();
    TIME_FIELDS Times;
    ULONG TimeIncrement;
    STRING  string1, string2;
    ULONG64 ThreadListHead_Flink=0, ActiveProcessLinks_Flink=0;
    ULONG64 UniqueProcessId=0, Peb=0, InheritedFromUniqueProcessId=0, NumberOfHandles=0;
    ULONG64 ObjectTable=0, NumberOfPrivatePages=0, ModifiedPageCount=0, NumberOfLockedPages=0;
    ULONG NVads = 0;
    ULONG64 VadRoot=0, CloneRoot=0, DeviceMap=0, Token=0;
    ULONG64 CreateTime_QuadPart=0, Pcb_UserTime=0, Pcb_KernelTime=0;
    ULONG64 Vm_WorkingSetSize=0, Vm_MinimumWorkingSetSize=0, Vm_MaximumWorkingSetSize=0;
    ULONG64 Vm_PeakWorkingSetSize=0, VirtualSize=0, PeakVirtualSize=0, Vm_PageFaultCount=0;
    ULONG64 Vm_MemoryPriority=0, Pcb_BasePriority=0, CommitCharge=0, DebugPort=0, Job=0;
    ULONG  SessionId, Pcb_Header_Type=0;
    CHAR   Pcb_DirectoryTableBase[16]={0}, QuotaPoolUsage[16]={0}, ImageFileName_Read[32] = {0};
    TCHAR procType[] = "_EPROCESS";

    if (GetFieldValue(RealProcessBase, "nt!_EPROCESS", "UniqueProcessId", UniqueProcessId)) {
        dprintf("Could not find _EPROCESS type at %p.\n", RealProcessBase);
        return FALSE;
    }

    if (!GetProcessSessionId(RealProcessBase, &SessionId)) {
        return FALSE;
    }
    
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Peb",                     Peb);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "InheritedFromUniqueProcessId",InheritedFromUniqueProcessId);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.DirectoryTableBase",  Pcb_DirectoryTableBase);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.Header.Type",         Pcb_Header_Type);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ObjectTable",             ObjectTable);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ImageFileName",           ImageFileName_Read);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "NumberOfVads",            NVads);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "VadRoot",                 VadRoot);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "CloneRoot",               CloneRoot);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "NumberOfPrivatePages",    NumberOfPrivatePages);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ModifiedPageCount",       ModifiedPageCount);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "NumberOfLockedPages",     NumberOfLockedPages);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "DeviceMap",               DeviceMap);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Token",                   Token);
    if (IsPtr64()) {
        Token = Token & ~(ULONG64)15;
    } else {
        Token = Token & ~(ULONG64)7;
    }
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "CreateTime.QuadPart",     CreateTime_QuadPart);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.UserTime",            Pcb_UserTime);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.KernelTime",          Pcb_KernelTime);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "QuotaPoolUsage",          QuotaPoolUsage);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.WorkingSetSize",       Vm_WorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.MinimumWorkingSetSize",Vm_MinimumWorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.MaximumWorkingSetSize",Vm_MaximumWorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.PeakWorkingSetSize",   Vm_PeakWorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "VirtualSize",             VirtualSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "PeakVirtualSize",         PeakVirtualSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.PageFaultCount",       Vm_PageFaultCount);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.MemoryPriority",       Vm_MemoryPriority);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.BasePriority",        Pcb_BasePriority);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "CommitCharge",            CommitCharge);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "DebugPort",               DebugPort);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Job",                     Job);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink",ThreadListHead_Flink);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ActiveProcessLinks.Flink",ActiveProcessLinks_Flink);
    GetFieldValue(ObjectTable, "nt!_HANDLE_TABLE", "HandleCount",             NumberOfHandles);
    
    // dprintf( " Proc list Next:%I64x, ProceDump:%I64x, Head:%I64x...\n", Next, ProcessToDump, ProcessHead);

//   dprintf("Proc %I64x, %8p %16.16I64x", ProcessToDump, ProcessToDump, ProcessToDump);


    if (Pcb_Header_Type != ProcessObject) {
        dprintf("TYPE mismatch for process object at %p\n", RealProcessBase);
        return FALSE;
    }

    //
    // Get the image file name
    //
    if (ImageFileName_Read[0] == 0 ) {
        strcpy(ImageFileName_Read,"System Process");
    }

    if (ImageFileName != NULL) {
        RtlInitString(&string1, ImageFileName);
        RtlInitString(&string2, ImageFileName_Read);
        if (RtlCompareString(&string1, &string2, TRUE) != 0) {
            return TRUE;
        }
    }

    dprintf("%sPROCESS %08p", pad, RealProcessBase);

    dprintf("%s%sSessionId: %u  Cid: %04I64x    Peb: %08I64x  ParentCid: %04I64x\n",
            (LongAddrs ? "\n    " : " "),
            (LongAddrs ? pad      : " "),
            SessionId,
            UniqueProcessId,
            Peb,
            InheritedFromUniqueProcessId
            );

    if (LongAddrs) {
        dprintf("%s    DirBase: %08I64lx  ObjectTable: %08p  TableSize: %3u.\n",
                pad,
                *((ULONG64 *) &Pcb_DirectoryTableBase[ 0 ]),
                ObjectTable,
                (ULONG) NumberOfHandles
                );
    } else {
        dprintf("%s    DirBase: %08lx  ObjectTable: %08p  TableSize: %3u.\n",
                pad,
                *((ULONG *) &Pcb_DirectoryTableBase[ 0 ]),
                ObjectTable,
                (ULONG) NumberOfHandles
                );
    }

    dprintf("%s    Image: %s\n",pad,ImageFileName_Read);

    if (!(Flags & 1)) {
        dprintf("\n");
        return TRUE;
    }

    dprintf("%s    VadRoot %p Vads %ld Clone %1p Private %I64d. Modified %I64ld. Locked %I64d.\n",
            pad,
            VadRoot ,
            NVads,
            CloneRoot,
            NumberOfPrivatePages,
            ModifiedPageCount,
            NumberOfLockedPages);

    dprintf("%s    DeviceMap %p\n", pad, DeviceMap );


    //
    // Primary token
    //

    dprintf("%s    Token                             %p\n", pad, Token);

    //
    // Get the time increment value which is used to compute runtime.
    //
    TimeIncrement = GetNtDebuggerDataValue( KeTimeIncrement );

    GetTheSystemTime (&RunTime);
    RunTime.QuadPart -= CreateTime_QuadPart;
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%s    ElapsedTime                      %3ld:%02ld:%02ld.%04ld\n",
            pad,
            Times.Hour,
            Times.Minute,
            Times.Second,
            Times.Milliseconds);

    RunTime.QuadPart = UInt32x32To64(Pcb_UserTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%s    UserTime                        %3ld:%02ld:%02ld.%04ld\n",
            pad,
            Times.Hour,
            Times.Minute,
            Times.Second,
            Times.Milliseconds);

    RunTime.QuadPart = UInt32x32To64(Pcb_KernelTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%s    KernelTime                      %3ld:%02ld:%02ld.%04ld\n",
            pad,
            Times.Hour,
            Times.Minute,
            Times.Second,
            Times.Milliseconds);

    if (!LongAddrs) {
        dprintf("%s    QuotaPoolUsage[PagedPool]         %ld\n", pad,*((ULONG *) &QuotaPoolUsage[PagedPool*4]) );
        dprintf("%s    QuotaPoolUsage[NonPagedPool]      %ld\n", pad,*((ULONG *) &QuotaPoolUsage[NonPagedPool*4])    );
    } else {
        dprintf("%s    QuotaPoolUsage[PagedPool]         %I64ld\n", pad,*((ULONG64 *) &QuotaPoolUsage[PagedPool*8]) );
        dprintf("%s    QuotaPoolUsage[NonPagedPool]      %I64ld\n", pad,*((ULONG64 *) &QuotaPoolUsage[NonPagedPool*8])    );
    }

    dprintf("%s    Working Set Sizes (now,min,max)  (%I64ld, %I64ld, %I64ld) (%I64ldKB, %I64ldKB, %I64ldKB)\n",
            pad,
            Vm_WorkingSetSize,
            Vm_MinimumWorkingSetSize,
            Vm_MaximumWorkingSetSize,
            _KB*Vm_WorkingSetSize,
            _KB*Vm_MinimumWorkingSetSize,
            _KB*Vm_MaximumWorkingSetSize
            );
    dprintf("%s    PeakWorkingSetSize                %I64ld\n", pad, Vm_PeakWorkingSetSize           );
    dprintf("%s    VirtualSize                       %I64ld Mb\n", pad, VirtualSize /(1024*1024)     );
    dprintf("%s    PeakVirtualSize                   %I64ld Mb\n", pad, PeakVirtualSize/(1024*1024)  );
    dprintf("%s    PageFaultCount                    %I64ld\n", pad, Vm_PageFaultCount               );
    dprintf("%s    MemoryPriority                    %s\n", pad, Vm_MemoryPriority ? "FOREGROUND" : "BACKGROUND" );
    dprintf("%s    BasePriority                      %I64ld\n", pad, Pcb_BasePriority);
    dprintf("%s    CommitCharge                      %I64ld\n", pad, CommitCharge                    );
    if ( DebugPort ) {
        dprintf("%s    DebugPort                         %p\n", pad, DebugPort );
    }
    if ( Job ) {
        dprintf("%s    Job                               %p\n", pad, Job );
    }


    dprintf("\n");

    return TRUE;

}


//
// This is to be called from .c file extensions which do not do INIT_API 
// that is they do not set g_ExtControl needed for stacktrace in DumpThread
//
// It will set the globals needed to dump stacktrace and call DumpThread
//
BOOL
DumpThreadEx (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG Flags,
    IN PDEBUG_CLIENT pDbgClient
    )
{
    BOOL retval = FALSE;
    if (pDbgClient &&
        (ExtQuery(pDbgClient) == S_OK)) {
        retval = DumpThread(Processor, Pad, RealThreadBase, Flags);

        ExtRelease();
    }
    return retval;
}

BOOL
DumpThread (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG64 Flags
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG64 Address;
    ULONG WaitOffset;
    ULONG64 Process;
    CHAR Buffer[256];
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG err;
    ULONG64 displacement;
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES];
    BOOL LongAddrs = IsPtr64();
    ULONG Tcb_Alertable = 0, Tcb_Proc;
    ULONG64 ActiveImpersonationInfo=0, Cid_UniqueProcess=0, Cid_UniqueThread=0, ImpersonationInfo=0, 
       ImpersonationInfo_ImpersonationLevel=0, ImpersonationInfo_Token=0, IrpList_Flink=0, 
       IrpList_Blink=0, LpcReceivedMessageId=0, LpcReceivedMsgIdValid=0, LpcReplyMessage=0, LpcReplyMessageId=0, 
       PerformanceCountHigh=0, PerformanceCountLow=0, StartAddress=0, Tcb_ApcState_Process=0, 
       Tcb_BasePriority=0, Tcb_CallbackStack=0, Tcb_ContextSwitches=0, Tcb_DecrementCount=0, Tcb_EnableStackSwap=0, 
       Tcb_FreezeCount=0, Tcb_Header_Type=0, Tcb_InitialStack=0, Tcb_KernelStack=0, Tcb_KernelStackResident=0, 
       Tcb_KernelTime=0, Tcb_LargeStack=0, Tcb_NextProcessor=0, Tcb_Priority=0, Tcb_PriorityDecrement=0, 
       Tcb_StackBase=0, Tcb_StackLimit=0, Tcb_State=0, Tcb_SuspendCount=0, Tcb_Teb=0, Tcb_UserTime=0, 
       Tcb_WaitBlockList=0, Tcb_WaitMode=0, Tcb_WaitReason=0, Tcb_WaitTime=0, 
       Tcb_Win32Thread=0, Win32StartAddress=0, ObpLUIDDeviceMapsEnabled=0;
    TCHAR threadTyp[] = "nt!_ETHREAD";
    FIELD_INFO threadFlds[] = {
       {(PUCHAR) "IrpList",           NULL,       0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL}, 
    };
    SYM_DUMP_PARAM sThread = {
       sizeof (SYM_DUMP_PARAM), (PUCHAR) &threadTyp[0], DBG_DUMP_NO_PRINT, RealThreadBase,
       NULL, NULL, NULL, 1, &threadFlds[0],
    };

    if (Ioctl(IG_DUMP_SYMBOL_INFO, (PBYTE) &sThread, sizeof(SYM_DUMP_PARAM))) {
        // To get address of IrpList
        dprintf("Cannot find _ETHREAD type.\n");
       return FALSE;
    }

    if (CheckControlC()) {
        return FALSE;
    }

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    Tcb_Header_Type = ReadField(Tcb.Header.Type);
    Cid_UniqueProcess = ReadField(Cid.UniqueProcess);
    Cid_UniqueThread = ReadField(Cid.UniqueThread);
    Tcb_Teb = ReadField(Tcb.Teb);
    Tcb_Win32Thread = ReadField(Tcb.Win32Thread);
    Tcb_State = ReadField(Tcb.State);
    Tcb_WaitReason = ReadField(Tcb.WaitReason);
    Tcb_WaitMode = ReadField(Tcb.WaitMode); 
    Tcb_Alertable = (ULONG) ReadField(Tcb.Alertable);
    


    if (Tcb_Header_Type != ThreadObject) {
        dprintf("TYPE mismatch for thread object at %p\n",RealThreadBase);
        return FALSE;
    }

    dprintf("%sTHREAD %p  Cid %1p.%1p  Teb: %p %s%sWin32Thread: %p ", 
            Pad, RealThreadBase, 
            Cid_UniqueProcess, 
            Cid_UniqueThread,
            Tcb_Teb,
            (LongAddrs ? "\n" : ""),
            (LongAddrs ? Pad  : ""), 
            Tcb_Win32Thread);


    switch (Tcb_State) {
        case Initialized:
            dprintf("%s\n","INITIALIZED");break;
        case Ready:
            dprintf("%s\n","READY");break;
        case Running:
            dprintf("%s%s%s on processor %lx\n",
                    (!LongAddrs ? "\n" : ""),
                    (!LongAddrs ? Pad  : ""), 
                    "RUNNING", Tcb_Proc = (ULONG) ReadField(Tcb.NextProcessor));
            break;
        case Standby:
            dprintf("%s\n","STANDBY");break;
        case Terminated:
            dprintf("%s\n","TERMINATED");break;
        case Waiting:
            dprintf("%s","WAIT");break;
        case Transition:
            dprintf("%s","TRANSITION");break;
    }

    if (!(Flags & 2)) {
        dprintf("\n");
        return TRUE;
    }
    
    Tcb_SuspendCount = ReadField(Tcb.SuspendCount);
    Tcb_FreezeCount = ReadField(Tcb.FreezeCount);
    Tcb_WaitBlockList = ReadField(Tcb.WaitBlockList);
    LpcReplyMessageId = ReadField(LpcReplyMessageId);
    LpcReplyMessage = ReadField(LpcReplyMessage);
    IrpList_Flink = ReadField(IrpList.Flink); 
    IrpList_Blink = ReadField(IrpList.Blink); 
    ActiveImpersonationInfo = ReadField(ActiveImpersonationInfo);
    ImpersonationInfo = ReadField(ImpersonationInfo);
    Tcb_ApcState_Process = ReadField(Tcb.ApcState.Process);
    Tcb_WaitTime = ReadField(Tcb.WaitTime);
    Tcb_ContextSwitches = ReadField(Tcb.ContextSwitches);
    Tcb_EnableStackSwap = ReadField(Tcb.EnableStackSwap);
    Tcb_LargeStack = ReadField(Tcb.LargeStack);
    Tcb_UserTime = ReadField(Tcb.UserTime);
    Tcb_KernelTime = ReadField(Tcb.KernelTime);
    PerformanceCountHigh = ReadField(PerformanceCountHigh);
    PerformanceCountLow = ReadField(PerformanceCountLow); 
    StartAddress = ReadField(StartAddress);
    Win32StartAddress = ReadField(Win32StartAddress);
    LpcReceivedMsgIdValid = ReadField(LpcReceivedMsgIdValid);
    LpcReceivedMessageId = ReadField(LpcReceivedMessageId);
    Tcb_InitialStack = ReadField(Tcb.InitialStack);
    Tcb_KernelStack = ReadField(Tcb.KernelStack);
    Tcb_StackBase = ReadField(Tcb.StackBase);
    Tcb_StackLimit = ReadField(Tcb.StackLimit);
    Tcb_CallbackStack = ReadField(Tcb.CallbackStack);
    Tcb_Priority = ReadField(Tcb.Priority);
    Tcb_BasePriority = ReadField(Tcb.BasePriority);
    Tcb_PriorityDecrement = ReadField(Tcb.PriorityDecrement);
    Tcb_DecrementCount = ReadField(Tcb.DecrementCount);
    Tcb_KernelStackResident = ReadField(Tcb.KernelStackResident);
    Tcb_NextProcessor = ReadField(Tcb.NextProcessor);

    if (Tcb_State == Waiting) {
       ULONG64 WaitBlock_Object=0, WaitBlock_NextWaitBlock=0;

       dprintf(": (%s) %s %s\n",
            WaitReasonList[Tcb_WaitReason],
            (Tcb_WaitMode==0) ? "KernelMode" : "UserMode", Tcb_Alertable ? "Alertable" : "Non-Alertable");
        if ( Tcb_SuspendCount ) {
            dprintf("SuspendCount %lx\n",Tcb_SuspendCount);
        }
        if ( Tcb_FreezeCount ) {
            dprintf("FreezeCount %lx\n",Tcb_FreezeCount);
        }

        WaitOffset = (ULONG) (Tcb_WaitBlockList - RealThreadBase);

        if (err = GetFieldValue(Tcb_WaitBlockList, "nt!_KWAIT_BLOCK", "Object", WaitBlock_Object)) {
            dprintf("%sCannot read nt!_KWAIT_BLOCK at %p - error %lx\n", Pad, Tcb_WaitBlockList, err);
            goto BadWaitBlock;
        }

        GetFieldValue(Tcb_WaitBlockList, "nt!_KWAIT_BLOCK", "NextWaitBlock", WaitBlock_NextWaitBlock);

        do {
            TCHAR MutantListEntry[16]={0};
            ULONG64 OwnerThread=0, Header_Type=0;

            dprintf("%s    %p  ",Pad, WaitBlock_Object);

            GetFieldValue(WaitBlock_Object, "nt!_KMUTANT", "Header.Type", Header_Type);
            GetFieldValue(WaitBlock_Object, "nt!_KMUTANT", "MutantListEntry", MutantListEntry);
            GetFieldValue(WaitBlock_Object, "nt!_KMUTANT", "OwnerThread", OwnerThread);
            
            switch (Header_Type) {
                case EventNotificationObject:
                    dprintf("NotificationEvent\n");
                    break;
                case EventSynchronizationObject:
                    dprintf("SynchronizationEvent\n");
                    break;
                case SemaphoreObject:
                    dprintf("Semaphore Limit 0x%lx\n",
                             *((ULONG *) &MutantListEntry[0]));
                    break;
                case ThreadObject:
                    dprintf("Thread\n");
                    break;
                case TimerNotificationObject:
                    dprintf("NotificationTimer\n");
                    break;
                case TimerSynchronizationObject:
                    dprintf("SynchronizationTimer\n");
                    break;
                case EventPairObject:
                    dprintf("EventPair\n");
                    break;
                case ProcessObject:
                    dprintf("ProcessObject\n");
                    break;
                case MutantObject:
                    dprintf("Mutant - owning thread %lp\n",
                            OwnerThread);
                    break;
                default:
                    dprintf("Unknown\n");
                    // goto BadWaitBlock;
                    break;
            }

            if ( WaitBlock_NextWaitBlock == Tcb_WaitBlockList) {
                break;
                goto BadWaitBlock;
            }


            if (err = GetFieldValue(WaitBlock_NextWaitBlock, "nt!_KWAIT_BLOCK", "Object", WaitBlock_Object)) {
                dprintf("%sCannot read nt!_KWAIT_BLOCK at %p - error %lx\n", Pad, WaitBlock_NextWaitBlock, err);
                goto BadWaitBlock;
            }
            GetFieldValue(WaitBlock_NextWaitBlock, "nt!_KWAIT_BLOCK", "NextWaitBlock", WaitBlock_NextWaitBlock);
        
            if (CheckControlC()) {
                return FALSE;
            }
        } while ( TRUE );
    }

BadWaitBlock:
    if (!(Flags & 4)) {
        dprintf("\n");
        return TRUE;
    }


    if (LpcReplyMessageId != 0) {
        dprintf("%sWaiting for reply to LPC MessageId %08p:\n",Pad,LpcReplyMessageId);
    }

    if (LpcReplyMessage) {

        if (LpcReplyMessage & 1) {
            
            dprintf("%sCurrent LPC port %08lp\n",Pad, (LpcReplyMessage & ~((ULONG64)1)));
        
        } else {

            ULONG64 Entry_Flink, Entry_Blink;

            dprintf("%sPending LPC Reply Message:\n",Pad);
            Address = (ULONG64) LpcReplyMessage;

            GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Flink", Entry_Flink);
            GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Blink", Entry_Blink);

            dprintf("%s    %08lp: [%08lp,%08lp]\n",
                    Pad, 
                    Address, 
                    Entry_Blink,
                    Entry_Flink
                    );
        }
    }

    if (IrpList_Flink && (IrpList_Flink != IrpList_Blink ||
                          IrpList_Flink != threadFlds[0].address)
       ) {

        ULONG64 IrpListHead = threadFlds[0].address;
        ULONG64 Next;
        ULONG Counter = 0;
        FIELD_INFO fldAddress = {(PUCHAR) "ThreadListEntry", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
        SYM_DUMP_PARAM IrpSym = {
           sizeof (SYM_DUMP_PARAM), (PUCHAR) "nt!_IRP", DBG_DUMP_NO_PRINT, 0,
           NULL, NULL, NULL, 1, &fldAddress 
        }; // For getting ThreadListEntry Offset in _IRP


        Next = IrpList_Flink;
        
        if (!Ioctl(IG_DUMP_SYMBOL_INFO, (PBYTE) &IrpSym, sizeof (SYM_DUMP_PARAM))) {
           dprintf("%sIRP List:\n",Pad);
           while ((Next != IrpListHead) && (Counter < 17)) {
               ULONG Irp_Type=0, Irp_Size=0, Irp_Flags=0;
               ULONG64 Irp_MdlAddress=0;
               
               Counter += 1;
              
               // subtract threadlistentry offset
               Address = Next - fldAddress.address;
               Next=0;
               
               GetFieldValue(Address, "nt!_IRP", "Type",          Irp_Type);
               GetFieldValue(Address, "nt!_IRP", "Size",          Irp_Size);
               GetFieldValue(Address, "nt!_IRP", "Flags",         Irp_Flags);
               GetFieldValue(Address, "nt!_IRP", "MdlAddress",    Irp_MdlAddress);
               GetFieldValue(Address, "nt!_IRP", "ThreadListEntry.Flink",  Next);

               dprintf("%s    %08p: (%04x,%04x) Flags: %08lx  Mdl: %08lp\n",
                       Pad,Address,Irp_Type,Irp_Size,Irp_Flags,Irp_MdlAddress);

           }
        }
    }

    //
    // Impersonation information
    //

    if (ActiveImpersonationInfo) {
        InitTypeRead(ImpersonationInfo, nt!_PS_IMPERSONATION_INFORMATION);
        ImpersonationInfo_Token = ReadField(Token);
        ImpersonationInfo_ImpersonationLevel = ReadField(ImpersonationLevel);

        if (ImpersonationInfo_Token) {
            dprintf("%sImpersonation token:  %p (Level %s)\n",
                        Pad, ImpersonationInfo_Token,
                        SecImpLevels( ImpersonationInfo_ImpersonationLevel ) );
        }
        else
        {
            dprintf("%sUnable to read Impersonation Information at %x\n",
                        Pad, ImpersonationInfo );
        }
    } else {
        dprintf("%sNot impersonating\n", Pad);
    }

    //
    // DeviceMap information
    //

    // check to see if per-LUID devicemaps are turned on 
    ULONG64 ObpLUIDDeviceMapsEnabledAddress;

    ObpLUIDDeviceMapsEnabledAddress = GetExpression("nt!ObpLUIDDeviceMapsEnabled");
    if (ObpLUIDDeviceMapsEnabledAddress) {
	ObpLUIDDeviceMapsEnabled = GetUlongFromAddress(ObpLUIDDeviceMapsEnabled);
    } else {
	ObpLUIDDeviceMapsEnabled = 0;
    }
    
    if (((ULONG)ObpLUIDDeviceMapsEnabled) != 0) {

        //
        // If we're impersonating, get the DeviceMap information
        // from the token.
        //

        if (ActiveImpersonationInfo) {
            ImpersonationInfo_Token = ReadField(Token);

            // get the LUID from the token
            ULONG64 AuthenticationId = 0;
            GetFieldValue(ImpersonationInfo_Token,
                "nt!_TOKEN",
                "AuthenticationId",
                AuthenticationId);

            // find the devmap directory object
            UCHAR Path[64];
            ULONG64 DeviceMapDirectory = 0;
            sprintf((PCHAR)Path, "\\Sessions\\0\\DosDevices\\%08x-%08x",
                (ULONG)((AuthenticationId >> 32) & 0xffffffff), 
                (ULONG)(AuthenticationId & 0xffffffff)
                );
            DeviceMapDirectory = FindObjectByName(Path, 0);

            if(DeviceMapDirectory != 0) {

                // get the device map itself
                ULONG64 DeviceMap = 0;
                GetFieldValue(DeviceMapDirectory,
                    "nt!_OBJECT_DIRECTORY",
                    "DeviceMap",
                    DeviceMap);

                if(DeviceMap != 0) {
                    dprintf("%sDeviceMap %p\n", Pad, DeviceMap);
                }
            }


        //
        // Else, we're not impersonating, so just return the 
        // DeviceMap from our parent process.
        //

        } else if (Tcb_ApcState_Process != 0) {
            // get the devicemap from the process
            ULONG64 DeviceMap = 0;
            GetFieldValue(Tcb_ApcState_Process, 
                "nt!_EPROCESS", 
                "DeviceMap", 
                DeviceMap);

            if (DeviceMap != 0) {
                dprintf("%sDeviceMap %p\n", Pad, DeviceMap);
            }
        }
    }


    // Process = CONTAINING_RECORD(Tcb_ApcState_Process,EPROCESS,Pcb);
    // Pcb is the 1st element
    Process = Tcb_ApcState_Process;
    dprintf("%sOwning Process %lp\n", Pad, Process);

    GetTheSystemTime (&RunTime);

    dprintf("%sWaitTime (ticks)          %ld\n",
              Pad,
              Tcb_WaitTime);

    dprintf("%sContext Switch Count      %ld",
              Pad,
              Tcb_ContextSwitches);

    if (!Tcb_EnableStackSwap) {
        dprintf("  NoStackSwap");
    } else {
        dprintf("             ");
    }

    if (Tcb_LargeStack) {
        dprintf("    LargeStack");
    }

    dprintf ("\n");

    //
    // Get the time increment value which is used to compute runtime.
    //
    TimeIncrement = GetNtDebuggerDataValue( KeTimeIncrement );

    RunTime.QuadPart = UInt32x32To64(Tcb_UserTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%sUserTime                %3ld:%02ld:%02ld.%04ld\n",
              Pad,
              Times.Hour,
              Times.Minute,
              Times.Second,
              Times.Milliseconds);

    RunTime.QuadPart = UInt32x32To64(Tcb_KernelTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%sKernelTime              %3ld:%02ld:%02ld.%04ld\n",
              Pad,
              Times.Hour,
              Times.Minute,
              Times.Second,
              Times.Milliseconds);

    if (PerformanceCountHigh != 0) {
        dprintf("%sPerfCounterHigh         0x%lx %08lx\n",
                Pad,
                PerformanceCountHigh,
                PerformanceCountHigh);
    } else if (PerformanceCountLow != 0) {
        dprintf("%sPerfCounter             %lu\n",Pad,PerformanceCountLow);
    }

    dumpSymbolicAddress(StartAddress, Buffer, TRUE);
    dprintf("%sStart Address %s\n",
        Pad,
        Buffer
        );

    if (Win32StartAddress)
        if (LpcReceivedMsgIdValid)
            {
            dprintf("%sLPC Server thread working on message Id %x\n",
                Pad,
                LpcReceivedMessageId
                );
            }
        else
            {
            dumpSymbolicAddress(Win32StartAddress, Buffer, TRUE);
            dprintf("%sWin32 Start Address %s\n",
                Pad,
                Buffer
                );
            }
    dprintf("%sStack Init %lp Current %lp%s%sBase %lp Limit %lp Call %lp\n",
        Pad,
        Tcb_InitialStack,
        Tcb_KernelStack,
        (LongAddrs ? "\n" : ""),
        (LongAddrs ? Pad  : " " ),
        Tcb_StackBase,
        Tcb_StackLimit,
        Tcb_CallbackStack
        );

    dprintf("%sPriority %I64ld BasePriority %I64ld PriorityDecrement %I64ld DecrementCount %I64ld\n",
        Pad,
        Tcb_Priority,
        Tcb_BasePriority,
        Tcb_PriorityDecrement,
        Tcb_DecrementCount
        );

    if (!Tcb_KernelStackResident) {
        dprintf("Kernel stack not resident.\n", Pad);
//        dprintf("\n");
//        return TRUE;
        // Try getting the stack even in this case - this might still be paged in
    }

    if (// (Tcb_State == Running && Processor == Tcb_Proc) || // Set thread context for everything
        Ioctl(IG_SET_THREAD, &RealThreadBase, sizeof(ULONG64))) {
        g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &frames );

        if (frames) {
            ULONG OutFlags;

            OutFlags = (DEBUG_STACK_COLUMN_NAMES | DEBUG_STACK_FUNCTION_INFO |
                        DEBUG_STACK_FRAME_ADDRESSES | DEBUG_STACK_SOURCE_LINE);

            if (!(Flags & 0x8))
            {
                OutFlags |= DEBUG_STACK_ARGUMENTS;
            }

    //        if (Flags & 0x10)
    //        {
    //            OutFlags |= DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY;
    //        }

            g_ExtClient->SetOutputLinePrefix(Pad);
            g_ExtControl->OutputStackTrace(0, stk, frames, OutFlags);
            g_ExtClient->SetOutputLinePrefix(NULL);
        }
    }
    
    dprintf("\n");
    return TRUE;
}


/**
   
   Routine to get address of the record containing a field on a debugee machine.
   Returns size of the type on success.
 
ULONG
GetContainingRecord (
   IN OUT PULONG64 pAddr, 
   IN LPSTR        Type,
   IN LPSTR        Field
   )
{ 
   ULONG64 off;
   ULONG sz;

   sz = GetFieldOffset(Type, Field, &off);
   *pAddr -= off;
   return sz;
}
 **/

typedef struct THREAD_LIST_DUMP {
    ULONG dwProcessor;
    LPSTR pad;
    ULONG Flags;
} THREAD_LIST_DUMP;

ULONG
ThreadListCallback (
    PFIELD_INFO   NextThrd,
    PVOID         Context
    ) 
{
    THREAD_LIST_DUMP *Thread = (THREAD_LIST_DUMP *) Context;

    return (!DumpThread(Thread->dwProcessor, Thread->pad, NextThrd->address, Thread->Flags));
}

typedef struct PROCESS_DUMP_CONTEXT {
    ULONG   dwProcessor;
    PCHAR   Pad;
    ULONG   Flag;
    PCHAR   ImageFileName;
    BOOL    DumpCid;
    ULONG64 Cid;
    ULONG   SessionId;
} PROCESS_DUMP_CONTEXT;

ULONG
ProcessListCallback(
    PFIELD_INFO   listElement,
    PVOID         Context
    )
{
    PROCESS_DUMP_CONTEXT *ProcDumpInfo = (PROCESS_DUMP_CONTEXT *) Context;
    // address field contains the address of this process 
    ULONG64    ProcAddress=listElement->address; 

    //
    // Dump the process for which this routine is called
    //     
    if (ProcDumpInfo->DumpCid) {
        ULONG64 UniqId;

        GetFieldValue(ProcAddress, "nt!_EPROCESS", "UniqueProcessId", UniqId);

        if (UniqId != ProcDumpInfo->Cid) {
            return FALSE;
        }
    }

    // Limit dump to a single session if so requested.
    if (ProcDumpInfo->SessionId != -1) {
        ULONG SessionId;
        
        if (!GetProcessSessionId(ProcAddress, &SessionId) ||
            SessionId != ProcDumpInfo->SessionId) {
            return FALSE;
        }
    }
    
    if (DumpProcess(ProcDumpInfo->Pad, listElement->address, ProcDumpInfo->Flag, ProcDumpInfo->ImageFileName)) {
        ULONG64 ProcFlink=0;
        if (ProcDumpInfo->Flag & 6) {
            //
            // Dump the threads
            //
            ULONG64 ThreadListHead_Flink=0;
            THREAD_LIST_DUMP Context = {ProcDumpInfo->dwProcessor, "        ", ProcDumpInfo->Flag};


            GetFieldValue(ProcAddress, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", ThreadListHead_Flink);

            // dprintf("Listing threads, threadlist.flnik %p\n", ThreadListHead_Flink);

            // dprintf("Dumping threads from %I64x to %I64x + %x.\n", Next, RealProcessBase , ThreadListHeadOffset);
            ListType("nt!_ETHREAD", ThreadListHead_Flink, 1, "Tcb.ThreadListEntry.Flink", (PVOID) &Context, &ThreadListCallback);

            if (CheckControlC()) {
                return TRUE;
            }

        }
        if (CheckControlC()) {
            return TRUE;
        }

        GetFieldValue(ProcAddress, "nt!_EPROCESS", "ActiveProcessLinks.Flink", ProcFlink);
        // dprintf("Next proc flink %p, this addr %p\n", ProcFlink, listElement->address);
        return FALSE;
    }
    return TRUE;
}

DECLARE_API( process )

/*++

Routine Description:

    Dumps the active process list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64 ProcessToDump;
    ULONG Flags = -1;
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 UserProbeAddress;
    PCHAR ImageFileName;
    CHAR  Buf[256];
    ULONG64 ActiveProcessLinksOffset=0;
    ULONG64 UniqueProcessId=0;
    PROCESS_DUMP_CONTEXT Proc={0, "", Flags, NULL, 0, 0};
    ULONG   dwProcessor=0;
    HANDLE  hCurrentThread=NULL;
    ULONG64 Expr;

    INIT_API();

    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }

    Proc.dwProcessor = dwProcessor;
    ProcessToDump = (ULONG64) -1;

    Proc.SessionId = -1;
    for (;;) {
        while (*args == ' ' || *args == '\t') {
            args++;
        }
        if (*args == '/') {

            switch(*(++args)) {
            case 's':
                args++;
                if (!GetExpressionEx(args, &Expr, &args)) {
                    dprintf("Invalid argument to /s\n");
                } else {
                    Proc.SessionId = (ULONG)Expr;
                }
                break;
            default:
                dprintf("Unknown option '%c'\n", *args);
                args++;
                break;
            }
            
        } else {
            break;
        }
    }
    
    RtlZeroMemory(Buf, 256);

    if (GetExpressionEx(args,&ProcessToDump, &args)) {
        if (sscanf(args, "%lx %s", &Flags, Buf) != 2) {
            Buf[0] = 0;
        }
    }

    if (Buf[0] != '\0') {
        Proc.ImageFileName = Buf;
        ImageFileName      = Buf;
    } else {
        ImageFileName = NULL;
    }


    if (ProcessToDump == (ULONG64) -1) {
        GetCurrentProcessAddr( dwProcessor, 0, &ProcessToDump );
        if (ProcessToDump == 0) {
            dprintf("Unable to get current process pointer.\n");
            goto processExit;
        }
        if (Flags == -1) {
            Flags = 3;
        }
    }

    if (!IsPtr64()) {
        ProcessToDump = (ULONG64) (LONG64) (LONG) ProcessToDump;
    }
    
    if ((ProcessToDump == 0) &&  (ImageFileName == NULL)) {
        dprintf("**** NT ACTIVE PROCESS DUMP ****\n");
        if (Flags == -1) {
            Flags = 3;
        }
    }

    UserProbeAddress = GetNtDebuggerDataValue(MmUserProbeAddress); 
    
    if (!GetExpression("NT!PsActiveProcessHead")) {
        dprintf("NT symbols are incorrect, please fix symbols\n");
        goto processExit;
    }

    if (ProcessToDump < UserProbeAddress) {
        if (!GetProcessHead(&ProcessHead, &Next)) {
            goto processExit;
        }
        
        if (ProcessToDump != 0) {
            dprintf("Searching for Process with Cid == %I64lx\n", ProcessToDump);
            Proc.Cid = ProcessToDump; Proc.DumpCid = TRUE;
        }
    }
    else {
        Next = 0;
        ProcessHead = 1;
    }
    
    Proc.Flag = Flags;

    if (Next != 0) {
        //
        // Dump the process List
        //

        ListType("nt!_EPROCESS", Next, 1, "ActiveProcessLinks.Flink", &Proc, &ProcessListCallback);
        goto processExit;
    }
    else {
        Process = ProcessToDump;
    }

        //dprintf("Next: %I64x, \tProcess: %I64x, \nActLnkOff: %I64x, \tProcHead: %I64x\n",
        //        Next, Process, procLink[0].address, ProcessHead);

    if (GetFieldValue(Process, "nt!_EPROCESS", "UniqueProcessId", UniqueProcessId)) {
        dprintf("Error in reading nt!_EPROCESS at %p\n", Process);
        goto processExit;
    }

    if (//ProcessToDump == 0 ||
        ProcessToDump < UserProbeAddress && ProcessToDump == UniqueProcessId ||
        ProcessToDump >= UserProbeAddress && ProcessToDump == Process
        ) {
        FIELD_INFO dummyForCallback = {(PUCHAR) "", NULL, 0, 0, Process, NULL};
        
        ProcessListCallback(&dummyForCallback, &Proc);

        goto processExit;
    }
processExit:

    EXIT_API();
    return S_OK;
}

typedef struct THREAD_FIND {
    ULONG64  StackPointer;
    ULONG64  Thread;
} THREAD_FIND;

ULONG
FindThreadCallback(
    PFIELD_INFO  pAddrInfo,
    PVOID        Context
    )
{
    ULONG64 stackBaseValue=0, stackLimitValue=0;
    ULONG64 thread = pAddrInfo->address;
    THREAD_FIND *pThreadInfo = (THREAD_FIND *) Context;

    //
    // We need two values from the thread structure: the kernel thread
    // base and the kernel thread limit.
    //

    if (GetFieldValue(thread, "nt!_ETHREAD", "Tcb.StackBase",  stackBaseValue)) {
        dprintf("Unable to get value of stack base of thread(0x%08p)\n",
                 thread);
        return TRUE;
    }

    if (pThreadInfo->StackPointer <= stackBaseValue) {

        if (GetFieldValue(thread, "nt!_ETHREAD", "Tcb.StackLimit", stackLimitValue)) {
            dprintf("Unable to get value of stack limit\n");
            return TRUE;
        }
        if (pThreadInfo->StackPointer >  stackLimitValue) {

            //
            // We have found our thread.
            //

            pThreadInfo->Thread = thread;
            return TRUE;
        }
    }

    //
    // Look at the next thread
    //

    return FALSE;  // Continue list
}

ULONG64
FindThreadFromStackPointerThisProcess(
    ULONG64 StackPointer,
    ULONG64 Process
    )
{
    LIST_ENTRY64 listValue={0};
    THREAD_FIND ThreadFindContext;

    ThreadFindContext.StackPointer = StackPointer;
    ThreadFindContext.Thread = 0;
    
    //
    //  Read the ThreadListHead within Process structure 
    //

    GetFieldValue(Process, "nt!_EPROCESS", "ThreadListHead.Flink", listValue.Flink);
    GetFieldValue(Process, "nt!_EPROCESS", "ThreadListHead.Blink", listValue.Blink);

    //
    // Go through thread list, and try to find thread 
    //
    ListType("nt!_ETHREAD", listValue.Flink, 1, "ThreadListEntry.Flink", (PVOID) &ThreadFindContext, &FindThreadCallback);
    
    return ThreadFindContext.Thread;
}



ULONG64
FindThreadFromStackPointer(
    ULONG64 StackPointer
    )
{
    ULONG64 processHead;
    ULONG64   list;
    LIST_ENTRY64 listValue={0};
    ULONG64    next;
    ULONG64   process=0;
    ULONG64   thread;
    ULONG   ActiveProcessLinksOffset=0;

    //
    // First check the idle process, which is not included in the PS
    // process list.
    //


    process = GetExpression( "NT!KeIdleProcess" );
    if (process != 0) {

        if (ReadPointer( process,
                     &process)) {

            thread = FindThreadFromStackPointerThisProcess( StackPointer,
                                                            process ); 

            if (thread != 0) {
                return thread;
            }
        }
    }

    //
    // Now check the PS process list.
    //

    list = GetNtDebuggerData( PsActiveProcessHead );
    if (list == 0) {
        dprintf("Unable to get address of PsActiveProcessHead\n");
        return 0;
    }

    if (!ReadPointer( list,
                 &listValue.Flink)) {
        dprintf("Unable to read @ %p\n", list);
        return 0;
    }

    next = listValue.Flink;
    processHead = list;

    //
    // Get Offset of ProcessLinks
    //
    GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActiveProcessLinksOffset);

    while (next != processHead) {

        if (CheckControlC()) {
            return 0;
        }
        
        //
        // Derive a pointer to the process structure
        //

        process = next - ActiveProcessLinksOffset;

        thread = FindThreadFromStackPointerThisProcess( StackPointer,
                                                        process );
        if (thread != 0) {

            //
            // We have found the thread who's stack range includes
            // StackPointer.
            //

            return thread;
        }

        //
        // Get a pointer to the next process
        //

        if (!ReadPointer( next,
                     &listValue.Flink) ) {
            dprintf("Unable to read value of ActiveProcessLinks\n");
            return 0;
        }
        next = listValue.Flink;
    }

    return 0;
}

DECLARE_API( thread )

/*++

Routine Description:

    Dumps the specified thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64     Address, Tcb_Header_Type=0;
    ULONG64       Flags;
    ULONG64     Thread;
    ULONG64     UserProbeAddress;
    ULONG       dwProcessor;
    HANDLE      hCurrentThread;
    CHAR        Token[100];
    
    INIT_API();

    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }

    if (!GetExpressionEx(args, &Address, &args))
    {
        Address = (ULONG64)-1;
    }

    if (!GetExpressionEx(args, &Flags, &args))
    {
        Flags = 6;
    }

    if (Address == (ULONG64)-1) {
        GetCurrentThreadAddr( dwProcessor, &Address );
    }

    UserProbeAddress = GetNtDebuggerDataValue(MmUserProbeAddress);

    Thread = Address;

    if (GetFieldValue(Address, "nt!_ETHREAD", "Tcb.Header.Type", Tcb_Header_Type)) {
        dprintf("%08lp: Unable to get thread contents\n", Thread );
        goto threadExit;
    }

    if (Tcb_Header_Type != ThreadObject &&
        Address > UserProbeAddress) {

        ULONG64 stackThread;

        //
        // What was passed in was not a thread.  Maybe it was a kernel stack
        // pointer.  Search the thread stack ranges to find out.
        //

        dprintf("%p is not a thread object, interpreting as stack value...\n",Address);
        stackThread = FindThreadFromStackPointer( Address );
        if (stackThread != 0) {
            Thread = stackThread;
        }
    }

    DumpThread (dwProcessor,"", Thread, Flags);
    EXPRLastDump = Thread;
    ThreadLastDump = Thread;

threadExit:

    EXIT_API();
    return S_OK;

}

DECLARE_API( processfields )

/*++

Routine Description:

    Displays the field offsets for EPROCESS type.

Arguments:

    None.

Return Value:

    None.

--*/

{

    dprintf(" EPROCESS structure offsets: (use 'dt nt!_EPROCESS')\n\n");
    return S_OK;
}


DECLARE_API( threadfields )

/*++

Routine Description:

    Displays the field offsets for ETHREAD type.

Arguments:

    None.

Return Value:

    None.

--*/

{

    dprintf(" ETHREAD structure offsets: (use 'dt ETHREAD')\n\n");
    return S_OK;

}


//+---------------------------------------------------------------------------
//
//  Function:   GetHandleTableAddress
//
//  Synopsis:   Return the address of the handle table given a thread handle
//
//  Arguments:  [Processor]      -- processor number
//              [hCurrentThread] -- thread handle
//
//  Returns:    address of handle table or null
//
//  History:    9-23-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG64 GetHandleTableAddress(
    USHORT Processor,
    HANDLE hCurrentThread
    )
{
    ULONG64   pThread;
    ULONG64   pProcess = 0, pObjTable;

    GetCurrentThreadAddr( Processor, &pThread );
    if (pThread) {
        GetCurrentProcessAddr( Processor, pThread, &pProcess );
    }

    if (pProcess) {
        if (GetFieldValue(pProcess, "nt!_EPROCESS", "ObjectTable", pObjTable) ) {
            dprintf("%08p: Unable to read _EPROCESS\n", pProcess );
            return 0;
        }

        return  pObjTable;
    } else
    {
        return 0;
    }
} // GetHandleTableAddress


#if 0

BOOLEAN
FetchProcessStructureVariables(
    VOID
    )
{
    ULONG Result;
    ULONG64 t;

    static BOOLEAN HavePspVariables = FALSE;

    if (HavePspVariables) {
        return TRUE;
    }

    t=GetNtDebuggerData( PspCidTable );
    PspCidTable = (PHANDLE_TABLE) t;
    if ( !PspCidTable ||
         !ReadMemory((DWORD)PspCidTable,
                     &PspCidTable,
                     sizeof(PspCidTable),
                     &Result) ) {
        dprintf("%08lx: Unable to get value of PspCidTable\n",PspCidTable);
        return FALSE;
    }

    HavePspVariables = TRUE;
    return TRUE;
}


PVOID
LookupUniqueId(
    HANDLE UniqueId
    )
{
    return NULL;
}

#endif

int
__cdecl
CmpFunc(
    const void *pszElem1,
    const void *pszElem2
    )
{
    PPROCESS_COMMIT_USAGE p1, p2;

    p1 = (PPROCESS_COMMIT_USAGE)pszElem1;
    p2 = (PPROCESS_COMMIT_USAGE)pszElem2;
    if (p2->CommitCharge == p1->CommitCharge) {
        ((char*)p2->ClientId - (char*)p1->ClientId);
    }
    return  (ULONG) (p2->CommitCharge - p1->CommitCharge);
}

PPROCESS_COMMIT_USAGE
GetProcessCommit (
    PULONG64 TotalCommitCharge,
    PULONG   NumberOfProcesses
    )
{
    PPROCESS_COMMIT_USAGE p;
    ULONG n;
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 Total;
    ULONG   Result;
    ULONG   ActiveProcessLinksOffset;

    *TotalCommitCharge = 0;
    *NumberOfProcesses = 0;

    // Get the offset of ActiveProcessLinks in _EPROCESS
    if (GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActiveProcessLinksOffset)) {
       return 0;
    }
    
    Total = 0;

    n = 0;
    p = (PPROCESS_COMMIT_USAGE) HeapAlloc( GetProcessHeap(), 0, 1 );

    ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return 0;
    }

    if (GetFieldValue( ProcessHead, "nt!_LIST_ENTRY", "Flink", Next )) {
        dprintf("Unable to read _LIST_ENTRY @ %p\n", ProcessHead);
        return 0;
    }

    while(Next != ProcessHead) {
        ULONG64 CommitCharge=0, NumberOfPrivatePages=0, NumberOfLockedPages=0;
        Process = Next - ActiveProcessLinksOffset;

        if (GetFieldValue( Process, "nt!_EPROCESS", "CommitCharge", CommitCharge )) {
            dprintf("Unable to read _EPROCESS at %p\n",Process);
            return 0;
        }

        Total += CommitCharge;

        n += 1;
        p = (PPROCESS_COMMIT_USAGE) HeapReAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, p, n * sizeof( *p ) );
        if (p != NULL) {
            p[n-1].ProcessAddress = Process;
            GetFieldValue( Process, "nt!_EPROCESS", "ImageFileName",
                           p[ n-1 ].ImageFileName );
            GetFieldValue( Process, "nt!_EPROCESS", "NumberOfPrivatePages",
                           p[ n-1 ].NumberOfPrivatePages );
            GetFieldValue( Process, "nt!_EPROCESS", "NumberOfLockedPages",
                           p[ n-1 ].NumberOfLockedPages );
            GetFieldValue( Process, "nt!_EPROCESS", "UniqueProcessId",
                           p[ n-1 ].ClientId );
            p[ n-1 ].CommitCharge = CommitCharge;
        }

        GetFieldValue(Process, "nt!_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (CheckControlC()) {
            return 0;
        }
    }

    qsort( p, n, sizeof( *p ), CmpFunc );

    *TotalCommitCharge = Total;
    *NumberOfProcesses = n;
    return p;
}

BOOL
DumpJob(
    ULONG64 RealJobBase,
    ULONG   Flags
    )
{
    ULONG64 ProcessListHead_Flink=0, TotalPageFaultCount=0, TotalProcesses=0, ActiveProcesses=0, 
       TotalTerminatedProcesses=0, LimitFlags=0, MinimumWorkingSetSize=0, 
       MaximumWorkingSetSize=0, ActiveProcessLimit=0, PriorityClass=0, 
       UIRestrictionsClass=0, SecurityLimitFlags=0, Token=0, Filter=0;
    ULONG64 Filter_SidCount=0, Filter_Sids=0, Filter_SidsLength=0, Filter_GroupCount=0, 
       Filter_Groups=0, Filter_GroupsLength=0, Filter_PrivilegeCount=0, Filter_Privileges=0,
       Filter_PrivilegesLength=0;
    ULONG ProcessListHeadOffset;

    GetFieldValue(RealJobBase, "nt!_EJOB", "ActiveProcesses",          ActiveProcesses);
    GetFieldValue(RealJobBase, "nt!_EJOB", "ActiveProcessLimit",       ActiveProcessLimit);
    GetFieldValue(RealJobBase, "nt!_EJOB", "Filter",                   Filter);
    GetFieldValue(RealJobBase, "nt!_EJOB", "LimitFlags",               LimitFlags);
    GetFieldValue(RealJobBase, "nt!_EJOB", "MinimumWorkingSetSize",    MinimumWorkingSetSize);
    GetFieldValue(RealJobBase, "nt!_EJOB", "MaximumWorkingSetSize",    MaximumWorkingSetSize);
    GetFieldValue(RealJobBase, "nt!_EJOB", "PriorityClass",            PriorityClass);
    GetFieldValue(RealJobBase, "nt!_EJOB", "ProcessListHead.Flink",    ProcessListHead_Flink);
    GetFieldValue(RealJobBase, "nt!_EJOB", "SecurityLimitFlags",       SecurityLimitFlags);
    GetFieldValue(RealJobBase, "nt!_EJOB", "Token",                    Token);
    GetFieldValue(RealJobBase, "nt!_EJOB", "TotalPageFaultCount",      TotalPageFaultCount);
    GetFieldValue(RealJobBase, "nt!_EJOB", "TotalProcesses",           TotalProcesses);
    GetFieldValue(RealJobBase, "nt!_EJOB", "TotalTerminatedProcesses", TotalTerminatedProcesses);
    GetFieldValue(RealJobBase, "nt!_EJOB", "UIRestrictionsClass",      UIRestrictionsClass);
    
    if (GetFieldOffset("_EJOB", "ProcessListHead", &ProcessListHeadOffset)) {
       dprintf("Can't read job at %p\n", RealJobBase);
    }
    if ( Flags & 1 )
    {
        dprintf("Job at %I64x\n", RealJobBase );
        dprintf("  TotalPageFaultCount      %x\n", TotalPageFaultCount );
        dprintf("  TotalProcesses           %x\n", TotalProcesses );
        dprintf("  ActiveProcesses          %x\n", ActiveProcesses );
        dprintf("  TotalTerminatedProcesses %x\n", TotalTerminatedProcesses );

        dprintf("  LimitFlags               %x\n", LimitFlags );
        dprintf("  MinimumWorkingSetSize    %I64x\n", MinimumWorkingSetSize );
        dprintf("  MaximumWorkingSetSize    %I64x\n", MaximumWorkingSetSize );
        dprintf("  ActiveProcessLimit       %x\n", ActiveProcessLimit );
        dprintf("  PriorityClass            %x\n", PriorityClass );

        dprintf("  UIRestrictionsClass      %x\n", UIRestrictionsClass );

        dprintf("  SecurityLimitFlags       %x\n", SecurityLimitFlags );
        dprintf("  Token                    %p\n", Token );
        if ( Filter )
        {
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedSidCount",        Filter_SidCount );
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedSids",            Filter_Sids );
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedSidsLength",      Filter_SidsLength);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedGroupCount",      Filter_GroupCount);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedGroups",          Filter_Groups);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedGroupsLength",    Filter_GroupsLength);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedPrivilegeCount",  Filter_PrivilegeCount);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedPrivileges",      Filter_Privileges);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedPrivilegesLength",Filter_PrivilegesLength);

            dprintf("  Filter\n");
            dprintf("    CapturedSidCount       %I64x\n", Filter_SidCount );
            dprintf("    CapturedSids           %p\n", Filter_Sids );
            dprintf("    CapturedSidsLength     %I64x\n", Filter_SidsLength );
            dprintf("    CapturedGroupCount     %I64x\n", Filter_GroupCount );
            dprintf("    CapturedGroups         %p\n", Filter_Groups );
            dprintf("    CapturedGroupsLength   %I64x\n", Filter_GroupsLength );
            dprintf("    CapturedPrivCount      %I64x\n", Filter_PrivilegeCount );
            dprintf("    CapturedPrivs          %p\n", Filter_Privileges );
            dprintf("    CapturedPrivLength     %I64x\n", Filter_PrivilegesLength );
        }

    }

    if ( Flags & 2 )
    {
        //
        // Walk the process list for all the processes in the job
        //

        ULONG64 Scan, End;
        ULONG   offset ;
        ULONG64 ProcessBase, NextPrc=0 ;

        dprintf("  Processes assigned to this job:\n" );

        Scan = ProcessListHead_Flink ;
        End = ProcessListHeadOffset + RealJobBase;
        
        if (GetFieldOffset("nt!_EPROCESS", "JobLinks", &offset)) {
            while ( Scan != End )
                {
                ProcessBase = Scan - offset;

                DumpProcess( "    ", ProcessBase, 0, NULL);

                if (!GetFieldValue(ProcessBase, "nt!_EPROCESS", "JobLinks.Flink", NextPrc)) {
                    Scan = NextPrc;
                } else {
                    Scan = End;
                }
            }
        }
    }
    return TRUE ;
}

DECLARE_API( job )

/*++

Routine Description:

    Dumps the specified thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64     Address, JobAddress=0;
    ULONG       Flags;
    ULONG       dwProcessor;
    HANDLE      hCurrentThread;
    
    INIT_API();

    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }

    Address = 0;
    Flags = 1;
    if (GetExpressionEx(args,&Address,&args)) {
        Flags = (ULONG) GetExpression(args);
        if (!Flags) {
            Flags = 1;
        }
    }

    if (Address == 0) {

        GetCurrentProcessAddr( dwProcessor, 0, &Address );
        if (Address == 0) {
            dprintf("Unable to get current process pointer.\n");
            goto jobExit;
        }

        if (GetFieldValue(Address, "nt!_EPROCESS", "Job", JobAddress)) {
           dprintf("%08p: Unable to get process contents\n", Address );
           goto jobExit;
        }
        Address = JobAddress;
        if ( Address == 0 )
        {
            dprintf("Process not part of a job.\n" );
            goto jobExit;
        }
    }


    DumpJob( Address, Flags );

jobExit:

    EXIT_API();
    return S_OK;

}


ULONG64 ZombieCount;
ULONG64 ZombiePool;
ULONG64 ZombieCommit;
ULONG64 ZombieResidentAvailable;

#define BLOB_LONGS 32

BOOLEAN WINAPI
CheckForZombieProcess(
    IN PCHAR Tag,
    IN PCHAR Filter,
    IN ULONG Flags,
    IN ULONG64 PoolHeader,
    IN ULONG BlockSize,
    IN ULONG64 Data,
    IN PVOID Context
    )
{
    ULONG           result;
  //  EPROCESS        ProcessContents;
    ULONG64         Process;
    ULONG64         KProcess;
    //OBJECT_HEADER   ObjectHeaderContents;
    ULONG64         ObjectHeader;
    ULONG64         Blob[BLOB_LONGS];
    ULONG           i;
    ULONG           PoolIndex, PoolBlockSize, SizeOfKprocess;
    ULONG           HandleCount, PointerCount;
    ULONG64         UniqueProcessId;

    UNREFERENCED_PARAMETER (Flags);
    UNREFERENCED_PARAMETER (BlockSize);
    UNREFERENCED_PARAMETER (Context);

    if (PoolHeader == 0) {
        return FALSE;
    }

    if (GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex) ||
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockSize)) {
        dprintf("Cannot read nt!_POOL_HEADER at %p.\n", PoolHeader);
        return FALSE;
    }
    
    if ((PoolIndex & 0x80) == 0) {
        return FALSE;
    }

    if (!CheckSingleFilter (Tag, Filter)) {
        return FALSE;
    }

    if ((PoolBlockSize << POOL_BLOCK_SHIFT) < sizeof(Blob)) {
        return FALSE;
    }

    //
    // There must be a better way to find the object header given the start
    // of a pool block ?
    //

    if (!ReadMemory (Data,
                     &Blob[0],
                     sizeof(Blob),
                     &result)) {
        dprintf ("Could not read process blob at %p\n", Data);
        return FALSE;
    }
    SizeOfKprocess = GetTypeSize("nt!_KPROCESS");
    for (i = 0; i < BLOB_LONGS; i += 1) {
        ULONG Type, Size;

        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KPROCESS",  "Header.Type", Type);
        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KPROCESS",  "Header.Size", Size);
        if ((Type == ProcessObject) &&
            (Size == SizeOfKprocess / sizeof(LONG))) {

            break;
        }
    }

    if (i == BLOB_LONGS) {
        return FALSE;
    }

    ObjectHeader = KD_OBJECT_TO_OBJECT_HEADER (Data + i*sizeof(LONG));
    Process = Data + i*sizeof(LONG);

    if (GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "HandleCount",HandleCount) ||
        GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "PointerCount",PointerCount) ) {
        dprintf ("Could not read process object header at %p\n", ObjectHeader);
        return FALSE;
    }


    if (GetFieldValue( Process,
                      "nt!_EPROCESS",
                       "UniqueProcessId",
                       UniqueProcessId)) {

        dprintf ("Could not read process data at %p\n", Process);
        return FALSE;
    }

    //
    // Skip the system process and the idle process.
    //

    if ((UniqueProcessId == 0) ||
        (UniqueProcessId == 8)) {
        return FALSE;
    }

    //
    // Display any terminated process regardless of object pointer/handle
    // counts.  This is so leaked process handles don't result in processes
    // not getting displayed when they should.
    //
    // A nulled object table with a non-zero create time indicates a process
    // that has finished creation.
    //

    InitTypeRead(Process, nt!_EPROCESS);
    if ((ReadField(ObjectTable) == 0) &&
        (ReadField(CreateTime.QuadPart) != 0)) {

        dprintf ("HandleCount: %u  PointerCount: %u\n",
                HandleCount, PointerCount);
        DumpProcess ("", Process, 0, NULL);

        ZombieCount += 1;
        ZombiePool += (PoolBlockSize << POOL_BLOCK_SHIFT);
        ZombieCommit += (7 * PageSize);               // MM_PROCESS_COMMIT_CHARGE
        ZombieResidentAvailable += (9 * PageSize);    // MM_PROCESS_CREATE_CHARGE
    }

    return TRUE;
}

BOOLEAN WINAPI
CheckForZombieThread(
    IN PCHAR Tag,
    IN PCHAR Filter,
    IN ULONG Flags,
    IN ULONG64 PoolHeader,
    IN ULONG BlockSize,
    IN ULONG64 Data,
    IN PVOID Context
    )
{
    ULONG           result;
    ULONG64         Thread;
    ULONG64         KThread;
    ULONG64         ObjectHeader;
    ULONG           Blob[BLOB_LONGS];
    ULONG           i;
    ULONG64         StackBase;
    ULONG64         StackLimit;
    ULONG           PoolIndex, PoolBlockSize, SizeOfKthread;
    ULONG           HandleCount, PointerCount;

    UNREFERENCED_PARAMETER (Flags);
    UNREFERENCED_PARAMETER (BlockSize);
    UNREFERENCED_PARAMETER (Context);

    if (PoolHeader == 0) {
        return FALSE;
    }

    if (GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex) ||
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockSize)) {
        dprintf("Cannot read POOL_HEADER at %p.\n", PoolHeader);
        return FALSE;
    }
    
    if ((PoolIndex & 0x80) == 0) {
        return FALSE;
    }

    if (!CheckSingleFilter (Tag, Filter)) {
        return FALSE;
    }

    if ((PoolBlockSize << POOL_BLOCK_SHIFT) < sizeof(Blob)) {
        return FALSE;
    }

    //
    // There must be a better way to find the object header given the start
    // of a pool block ?
    //

    if (!ReadMemory ((ULONG) Data,
                    &Blob[0],
                    sizeof(Blob),
                    &result)) {
        dprintf ("Could not read process blob at %p\n", Data);
        return FALSE;
    }
    SizeOfKthread = GetTypeSize("nt!_KTHREAD");
    for (i = 0; i < BLOB_LONGS; i += 1) {
        ULONG Type, Size;

        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KTHREAD",  "Header.Type", Type);
        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KTHREAD",  "Header.Size", Size);
        if ((Type == ThreadObject) &&
            (Size == SizeOfKthread / sizeof(LONG))) {

            break;
        }
    }

    if (i == BLOB_LONGS) {
        return FALSE;
    }

    ObjectHeader = KD_OBJECT_TO_OBJECT_HEADER (Data + i*sizeof(LONG));
    Thread = Data + i*sizeof(LONG);

    if (GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "HandleCount",HandleCount) ||
        GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "PointerCount",PointerCount) ) {
        dprintf ("Could not read process object header at %p\n", ObjectHeader);
        return FALSE;
    }

    if (GetFieldValue( Thread,
                       "nt!_ETHREAD",
                       "Tcb.StackLimit",
                       StackLimit)) {

        dprintf ("Could not read thread data at %p\n", Thread);
        return FALSE;
    }

    InitTypeRead(Thread, KTHREAD);

    if ((ULONG) ReadField(State) != Terminated) {
        return FALSE;
    }
    
    ZombieCount += 1;

    ZombiePool += (PoolBlockSize << POOL_BLOCK_SHIFT);
    ZombieCommit += (ReadField(StackBase) - StackLimit);

    StackBase = (ReadField(StackBase) - 1);

    dprintf ("HandleCount: %u  PointerCount: %u\n",
            HandleCount, PointerCount);
    DumpThread (0, "", Thread, 7);


    while (StackBase >= StackLimit) {
        if (GetAddressState(StackBase) == ADDRESS_VALID) {
            ZombieResidentAvailable += PageSize;
        }
        StackBase = (StackBase - PageSize);
    }

    return TRUE;
}

DECLARE_API( zombies )

/*++

Routine Description:

    Finds zombie processes and threads in non-paged pool.

Arguments:

    None.

Return Value:

    None.

--*/


{
    ULONG       Flags;
    ULONG64     RestartAddress;
    ULONG       TagName;
    ULONG64     ZombieProcessCount;
    ULONG64     ZombieProcessPool;
    ULONG64     ZombieProcessCommit;
    ULONG64     ZombieProcessResidentAvailable;
    ULONG64     tmp;
    
    Flags = 1;
    RestartAddress = 0;

    if (GetExpressionEx(args,&tmp, &args)) {
        RestartAddress = GetExpression(args);
        Flags = (ULONG) tmp;
    }

    if ((Flags & 0x3) == 0) {
        dprintf("Invalid parameter for !zombies\n");
        return E_INVALIDARG;
    }

    if (Flags & 0x1) {

        dprintf("Looking for zombie processes...");

        TagName = '?orP';

        ZombieCount = 0;
        ZombiePool = 0;
        ZombieCommit = 0;
        ZombieResidentAvailable = 0;

        SearchPool (TagName, 0, RestartAddress, &CheckForZombieProcess, NULL);
        SearchPool (TagName, 2, RestartAddress, &CheckForZombieProcess, NULL);

        ZombieProcessCount = ZombieCount;
        ZombieProcessPool = ZombiePool;
        ZombieProcessCommit = ZombieCommit;
        ZombieProcessResidentAvailable = ZombieResidentAvailable;
    }

    if (Flags & 0x2) {

        dprintf("Looking for zombie threads...");

        TagName = '?rhT';
    
        ZombieCount = 0;
        ZombiePool = 0;
        ZombieCommit = 0;
        ZombieResidentAvailable = 0;

        SearchPool (TagName, 0, RestartAddress, &CheckForZombieThread, NULL);
        SearchPool (TagName, 2, RestartAddress, &CheckForZombieThread, NULL);

    }

    //
    // Print summary statistics last so they don't get lost on screen scroll.
    //

    if (Flags & 0x1) {
        if (ZombieProcessCount == 0) {
            dprintf ("\n\n************ NO zombie processes found ***********\n");
        }
        else {
            dprintf ("\n\n************ %d zombie processes found ***********\n", ZombieProcessCount);
            dprintf ("       Resident page cost : %8ld Kb\n",
                ZombieProcessResidentAvailable / 1024);
            dprintf ("       Commit cost :        %8ld Kb\n",
                ZombieProcessCommit / 1024);
            dprintf ("       Pool cost :          %8ld bytes\n",
                ZombieProcessPool);
        }
        dprintf ("\n");
    }

    if (Flags & 0x2) {
        if (ZombieCount == 0) {
            dprintf ("\n\n************ NO zombie threads found ***********\n");
        }
        else {
            dprintf ("\n\n************ %d zombie threads found ***********\n", ZombieCount);
            dprintf ("       Resident page cost : %8ld Kb\n",
                ZombieResidentAvailable / 1024);
            dprintf ("       Commit cost :        %8ld Kb\n",
                ZombieCommit / 1024);
            dprintf ("       Pool cost :          %8ld bytes\n",
                ZombiePool);
        }
    }

    return S_OK;
}

VOID
DumpMmThreads (
    VOID
    )

/*++

Routine Description:

    Finds and dumps the interesting memory management threads.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG   i;
    ULONG64 ProcessToDump;
    ULONG   Flags;
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 Thread;
    CHAR    Buf[256];
    STRING  string1, string2;
    ULONG64 InterestingThreads[4];
    ULONG   ActvOffset, PcbThListOffset, TcbThListOffset;

    ProcessToDump = (ULONG64) -1;
    Flags = 0xFFFFFFFF;

    ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return;
    }

    if (GetFieldValue( ProcessHead, "nt!_LIST_ENTRY", "Flink", Next )) {
        dprintf("Unable to read nt!_LIST_ENTRY @ %p\n", ProcessHead);
        return;
    }

    if (Next == 0) {
        dprintf("PsActiveProcessHead is NULL!\n");
        return;
    }
    InterestingThreads[0] = GetExpression ("nt!MiModifiedPageWriter");
    InterestingThreads[1] = GetExpression ("nt!MiMappedPageWriter");
    InterestingThreads[2] = GetExpression ("nt!MiDereferenceSegmentThread");
    InterestingThreads[3] = GetExpression ("nt!KeBalanceSetManager");

    RtlInitString(&string1, "System");
    GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActvOffset);
    GetFieldOffset("nt!_EPROCESS", "Pcb.ThreadListHead", &PcbThListOffset);
    GetFieldOffset("nt!_KTHREAD",  "ThreadListEntry",    &TcbThListOffset);

    while(Next != ProcessHead) {

        Process = Next - ActvOffset;

        if (GetFieldValue( Process, "nt!_EPROCESS", "ImageFileName", Buf )) {
            dprintf("Unable to read _EPROCESS at %p\n",Process);
            return;
        }

        // strcpy((PCHAR)Buf,(PCHAR)ProcessContents.ImageFileName);
        RtlInitString(&string2, (PCSZ) Buf);

        if (RtlCompareString(&string1, &string2, TRUE) == 0) {

            //
            // Find the threads.
            //

            GetFieldValue( Process, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", Next);

            while ( Next != Process + PcbThListOffset) {
                ULONG64 StartAddress;

                Thread = Next - TcbThListOffset;
                if (GetFieldValue(Thread,
                                  "nt!_ETHREAD",
                                  "StartAddress",
                                  StartAddress)) {
                    dprintf("Unable to read _ETHREAD at %p\n",Thread);
                    break;
                }

                for (i = 0; i < 4; i += 1) {
                    if (StartAddress == InterestingThreads[i]) {
                        DumpThread (0,"        ", Thread, 7);
                        break;
                    }
                }


                GetFieldValue(Thread, "nt!_KTHREAD","ThreadListEntry.Flink", Next);

                if (CheckControlC()) {
                    return;
                }
            }
            dprintf("\n");
            break;
        }


        GetFieldValue( Process, "nt!_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (CheckControlC()) {
            return;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\portclsd.cpp ===
/*****************************************************************************
 * portclsd.cpp - Portcls WinDbg/KD Debugger Extensions
 *****************************************************************************
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"

#define PC_KDEXT

typedef enum _PCKD_PORTTYPE
{
    Topology = 0,
    WaveCyclic,
    WavePci,
    Midi,
    UnknownPort
} PCKD_PORTTYPE;

#define MAPPED_QUEUE  0
#define LOCKED_QUEUE  1
#define PRELOCK_QUEUE 2
#define MAX_QUEUES    3

typedef union _PORTCLS_FLAGS
{
    struct
    {
        ULONG   PortDump        : 1;
        ULONG   FilterDump      : 1;
        ULONG   PinDump         : 1;
        ULONG   DeviceContext   : 1;
        ULONG   PowerInfo       : 1;
        ULONG   Reserved1       : 3;
        ULONG   Verbose         : 1;
        ULONG   ReallyVerbose   : 1;
        ULONG   Reserved        : 22;
    };
    ULONG       Flags;
} PORTCLS_FLAGS;

typedef struct _PCKD_IRPSTREAM_ENTRY
{
    LIST_ENTRY      ListEntry;
    PVOID           Irp;
    ULONG           QueueType;
} PCKD_IRP_ENTRY;

typedef struct _PCKD_PIN_ENTRY
{
    LIST_ENTRY  ListEntry;
    LIST_ENTRY  IrpList;
    PVOID       PinData;
    PVOID       IrpStreamData;
    ULONG       PinInstanceId;
} PCKD_PIN_ENTRY;

typedef struct _PCKD_FILTER_ENTRY
{
    LIST_ENTRY  ListEntry;
    LIST_ENTRY  PinList;
    PVOID       FilterData;
    ULONG       FilterInstanceId;
} PCKD_FILTER_ENTRY;

typedef struct _PCKD_PORT
{
    LIST_ENTRY      FilterList;
    PCKD_PORTTYPE   PortType;
    PVOID           PortData;
} PCKD_PORT;

typedef struct {
    ULONG64                 Create;
    ULONG64                 Context;
    UNICODE_STRING          ObjectClass;
    ULONG64                 ObjectClassBuffer;
    ULONG64                 SecurityDescriptor;
    ULONG                   Flags;
} KSOBJECT_CREATE_ITEM_READ, *PKSOBJECT_CREATE_ITEM_READ;


typedef struct _PCKD_SUBDEVICE_ENTRY
{
    LIST_ENTRY              ListEntry;
    PCKD_PORT               Port;
    ULONG64                 CreateItemAddr;
    KSOBJECT_CREATE_ITEM_READ CreateItem;
} PCKD_SUBDEVICE_ENTRY;



#define TranslateDevicePower( x ) \
    ( x == PowerDeviceD0 ? "PowerDeviceD0" :    \
      x == PowerDeviceD1 ? "PowerDeviceD1" :    \
      x == PowerDeviceD2 ? "PowerDeviceD2" :    \
      x == PowerDeviceD3 ? "PowerDeviceD3" : "Unknown" )
      
#define TranslateSystemPower( x ) \
    ( x == PowerSystemWorking ? "PowerSystemWorking" :  \
      x == PowerSystemSleeping1 ? "PowerSystemSleeping1" :  \
      x == PowerSystemSleeping2 ? "PowerSystemSleeping2" :  \
      x == PowerSystemSleeping3 ? "PowerSystemSleeping3" :  \
      x == PowerSystemHibernate ? "PowerSystemHibernate" :  \
      x == PowerSystemShutdown ? "PowerSystemShutdown" : "Unknown" )
      
#define TranslateKsState( x ) \
    ( x == KSSTATE_STOP ? "KSSTATE_STOP" :          \
      x == KSSTATE_ACQUIRE ? "KSSTATE_ACQUIRE" :    \
      x == KSSTATE_PAUSE ? "KSSTATE_PAUSE" :        \
      x == KSSTATE_RUN ? "KSSTATE_RUN" : "Unknown" )
      
#define TranslateKsDataFlow( x ) \
    ( x == KSPIN_DATAFLOW_IN ? "KSPIN_DATAFLOW_IN" :    \
      x == KSPIN_DATAFLOW_OUT ? "KSPIN_DATAFLOW_OUT" : "Unknown" )      
      
#define TranslateQueueType( x ) \
    ( x == PRELOCK_QUEUE ? "P" :    \
      x == LOCKED_QUEUE ? "L" :     \
      x == MAPPED_QUEUE ? "M" : "U" )

/**********************************************************************
 * Forward References
 **********************************************************************
 */
BOOL
PCKD_ValidateDevObj
(
    PDEVICE_CONTEXT DeviceContext
);

VOID
PCKD_AcquireDeviceData
(
    PDEVICE_CONTEXT DeviceContext,
    PLIST_ENTRY     SubdeviceList,
    ULONG           Flags
);

VOID
PCKD_DisplayDeviceData
(
    PDEVICE_CONTEXT DeviceContext,
    PLIST_ENTRY     SubdeviceList,
    ULONG           Flags
);

VOID
PCKD_FreeDeviceData
(
    PLIST_ENTRY     SubdeviceList
);

VOID
PCKD_AcquireIrpStreamData
(
    PVOID           PinEntry,
    CIrpStream     *RemoteIrpStream,
    CIrpStream     *LocalIrpStream

);

/**********************************************************************
 * DECLARE_API( portcls )
 **********************************************************************
 * Description:
 *      Dumps PortCls data given the device object (FDO) of a PortCls
 *      bound DevObj.
 *
 * Arguments:
 *      args - address flags
 *
 * Return Value:
 *      None
 */
extern "C"
DECLARE_API( portcls )
{
    ULONG64         memLoc;
    ULONG           result;
    CHAR            buffer[256];
    PORTCLS_FLAGS   flags;
    LIST_ENTRY      SubdeviceList;
    ULONG64         DeviceExtension;

    buffer[0] = '\0';
    flags.Flags = 0;

    //
    // get the arguments
    //
    if( !*args )
    {
        memLoc = EXPRLastDump;
    } else
    {
        if (GetExpressionEx(args, &memLoc, &args)) {
            strcpy(buffer, args);
        }
    }

    flags.Flags = 0;
    if ('\0' != buffer[0]) {
        flags.Flags = GetExpression(buffer);
    }

    //
    // print out info
    //
    dprintf("Dump Portcls DevObj Info %p %x \n", memLoc, flags.Flags );

    //
    // get the DevObj data
    //
    if( memLoc )
    {
        if( GetFieldValue( memLoc, "DEVICE_OBJECT", "DeviceExtension", DeviceExtension ) )
        {
            dprintf("Could not read DevObj data\n");
            return E_INVALIDARG;
        }
    } else
    {
        dprintf("\nSYNTAX:  !portcls <devobj> [flags]\n");
    }

    //
    // check for device extension
    //
    if( !DeviceExtension )
    {
        dprintf("DevObj has no device extension\n");
        return E_INVALIDARG;
    }

    //
    // get the device context
    //
    if( InitTypeRead( DeviceExtension, "DEVICE_CONTEXT" ) )
    {
        dprintf("Could not read DevObj device extension\n");
        return E_INVALIDARG;
    }

    //
    // validate the DevObj
    //
    if( !PCKD_ValidateDevObj( DeviceExtension ) )
    {
        dprintf("DevObj not valid or not bound to PortCls\n");
        return E_INVALIDARG;
    }

    //
    // initialize the subdevice list
    //
    InitializeListHead( &SubdeviceList );

    //
    // acquire the device data
    //
    PCKD_AcquireDeviceData( DeviceExtension, &SubdeviceList, flags.Flags );

    //
    // display the requested info
    //
    PCKD_DisplayDeviceData( DeviceExtension, &SubdeviceList, flags.Flags );

    //
    // release the device data
    //
    PCKD_FreeDeviceData( &SubdeviceList );
    return S_OK;
}

/**********************************************************************
 * PCKD_ValidateDevObj
 **********************************************************************
 * Description:
 *      This routine attempts to validate whether or not a given device
 *      extension is from a PortCls bound DevObj.
 *
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      BOOL                TRUE = Valid, FALSE = Invalid
 */
BOOL
PCKD_ValidateDevObj
(
    ULONG64     DeviceContext
)
{
    UNREFERENCED_PARAMETER( DeviceContext );

    // TODO - Validate device extension
    return TRUE;
}

/**********************************************************************
 * PCKD_AcquireDeviceData
 **********************************************************************
 * Description:
 *      This routine acquires device data given a validated device
 *      context and builds a subdevice list contain all of the data.
 *
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PLIST_ENTRY         SubdeviceList
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      None
 */
VOID
PCKD_AcquireDeviceData
(
    ULONG64             DeviceContext,
    PLIST_ENTRY         SubdeviceList,
    ULONG               flags
)
{
    ULONG                   SubdeviceIndex;
    PCKD_SUBDEVICE_ENTRY   *SubdeviceEntry;
    ULONG64                 CreateItems;
    ULONG64                 CurrentCreateItemAddr;
    PKSOBJECT_CREATE_ITEM_READ   ReadCreateItems;
    PKSOBJECT_CREATE_ITEM_READ   CurrentCreateItem;
    PWSTR                   Buffer;
    ULONG                   Size;
    ULONG                   Result;
    ANSI_STRING             AnsiString;
    PLIST_ENTRY             ListEntry;
    PORTCLS_FLAGS           Flags;
    ULONG                   ItemSz, MaxObjects;
    ULONG                   i;
    Flags.Flags = flags;


    ItemSz = GetTypeSize("KSOBJECT_CREATE_ITEM");

    InitTypeRead(DeviceContext, DEVICE_CONTEXT);

    // allocate local memory for the create items table
    Size =  (MaxObjects = (ULONG) ReadField(MaxObjects)) * sizeof(KSOBJECT_CREATE_ITEM_READ);
    
    ReadCreateItems = (PKSOBJECT_CREATE_ITEM_READ)LocalAlloc( LPTR, Size );
    if( !ReadCreateItems )
    {
        dprintf("** Unable to allocate create item table memory\n");
        return;
    }

    CreateItems = ReadField(CreateItems);

    // copy the create items table to local memory
    for (i=0, CurrentCreateItemAddr=CreateItems; 
         i<MaxObjects, CurrentCreateItemAddr+=IteSz; 
         i++) { 
        InitTypeRead(CurrentCreateItemAddr, KSOBJECT_CREATE_ITEM);
        ReadCreateItems[i].Context = ReadField(Context);
        ReadCreateItems[i].Create  = ReadField(Create);
        ReadCreateItems[i].Flags   = ReadField(Flags);
        ReadCreateItems[i].ObjectClassBuffer   = ReadField(ObjectClass.Buffer);
        ReadCreateItems[i].ObjectClass.MaximumLength = ReadField(ObjectClass.MaximumLength);
        ReadCreateItems[i].ObjectClass.Length = ReadField(ObjectClass.Length);
        ReadCreateItems[i].SecurityDescriptor   = ReadField(SecurityDescriptor);
    }
    
    // check out each potential subdevice
    for( SubdeviceIndex = 0, CurrentCreateItem = ReadCreateItems;
         SubdeviceIndex < MaxObjects;
         SubdeviceIndex++, CurrentCreateItem++ )
    {

        if( CurrentCreateItem->Create) )
        {
            // allocate a subdevice list entry
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_SUBDEVICE_ENTRY) );
            if( SubdeviceEntry )
            {
                // initialize the port filter list
                InitializeListHead( &(SubdeviceEntry->Port.FilterList) );

                // copy the create item data
                memcpy( &(SubdeviceEntry->CreateItem), CurrentCreateItem, sizeof(KSOBJECT_CREATE_ITEM_READ) );

                // allocate memory for the unicode string buffer
                Buffer = (PWSTR)LocalAlloc( LPTR, CurrentCreateItem->ObjectClass.MaximumLength );
                if( !Buffer )
                {
                    dprintf("** Unable to allocate unicode string buffer\n");
                    LocalFree( SubdeviceEntry );
                    break;
                }

                // read unicode string data
                if( !ReadMemory( CurrentCreateItem->ObjectClassBuffer,
                                 Buffer,
                                 CurrentCreateItem->ObjectClass.MaximumLength,
                                 &Result ) )
                {
                    dprintf("** Unable to read unicode string buffer (0x%p)\n",CurrentCreateItem->ObjectClassBuffer);
                    LocalFree( Buffer );
                    LocalFree( SubdeviceEntry );
                    break;
                }

                // point the create item string to the local buffer
                // ?????
                SubdeviceEntry->CreateItem.ObjectClass.Buffer = Buffer;

                // determine port type by checking string
                // TODO: this should be done by the GUID
                //
                
                // convert to ansi
                RtlUnicodeStringToAnsiString( &AnsiString,
                                              &(SubdeviceEntry->CreateItem.ObjectClass),
                                              TRUE );

                if( 0 == _stricmp( AnsiString.Buffer, "topology" ) )
                {
                    SubdeviceEntry->Port.PortType = Topology;
                    SubdeviceEntry->Port.PortData = NULL;

                } else if( 0 == _stricmp( AnsiString.Buffer, "wave" ) )
                {
                    SubdeviceEntry->Port.PortType = WaveCyclic;
                    SubdeviceEntry->Port.PortData = NULL;

                } else if( (0 == _stricmp( AnsiString.Buffer, "uart") ) ||
                           (0 == _stricmp( AnsiString.Buffer, "fmsynth") ) )
                {
                    SubdeviceEntry->Port.PortType = Midi;
                    SubdeviceEntry->Port.PortData = NULL;
                } else
                {
                    SubdeviceEntry->Port.PortType = UnknownPort;
                    SubdeviceEntry->Port.PortData = NULL;
                }

                // free the ansi string
                RtlFreeAnsiString( &AnsiString );

                // add the subdevice entry to the subdevice list
                InsertTailList( SubdeviceList, &(SubdeviceEntry->ListEntry) );               

            } else
            {
                dprintf("** Unable to allocate subdevice memory\n");
            }
        }
    }

    // free the create item table local storage
    LocalFree( ReadCreateItems );

    // acquire the port, filter, and pin data
    if( (!IsListEmpty(SubdeviceList)) && (Flags.PortDump || Flags.FilterDump || Flags.PinDump) )
    {
        for( ListEntry = SubdeviceList->Flink; ListEntry != SubdeviceList; ListEntry = ListEntry->Flink )
        {
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *) ListEntry;

            // read basic port data
            PVOID Port;
            ULONG PortSize;

            switch( SubdeviceEntry->Port.PortType)
            {
                case Topology:
                    Port = LocalAlloc( LPTR, sizeof(CPortTopology) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortTopology *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortTopology),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case WaveCyclic:
                    Port = LocalAlloc( LPTR, sizeof(CPortWaveCyclic) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortWaveCyclic *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortWaveCyclic),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case WavePci:
                    Port = LocalAlloc( LPTR, sizeof(CPortWavePci) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortWavePci *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortWavePci),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case Midi:
                    Port = LocalAlloc( LPTR, sizeof(CPortMidi) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortMidi *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortMidi),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                default:
                    break;
            }

            // attach the port data to the subdevice entry
            SubdeviceEntry->Port.PortData = Port;

            switch( SubdeviceEntry->Port.PortType )
            {
                case Topology:
                    break;

                case WaveCyclic:
                    {
                        CPortWaveCyclic *PortWaveCyclic = (CPortWaveCyclic *)Port;


                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               Offset;
                            ULONG               PortBase;
                            PLIST_ENTRY         Flink;
                            PLIST_ENTRY         TempListEntry;
                            ULONG               PinNumber = 0;
                            CPortPinWaveCyclic *PortPinWaveCyclic;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            // get the offsets needed to walk the list
                            Offset = FIELD_OFFSET(CPortWaveCyclic,m_PinList);
                            PortBase = (ULONG)((CPortWaveCyclic *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context)));

                            // get the first pin pointer
                            Flink = PortWaveCyclic->m_PinList.Flink;

                            while (Flink != PLIST_ENTRY(PortBase + Offset))
                            {
                                // allocate a pin list entry
                                CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                if( !CurrentPinEntry )
                                {
                                    dprintf("** Unable to allocate pin list entry\n");
                                    break;
                                }
                                
                                // initialize the pin entry
                                InitializeListHead( &(CurrentPinEntry->IrpList) );
                                CurrentPinEntry->PinData = NULL;
                                CurrentPinEntry->IrpStreamData = NULL;
                                CurrentPinEntry->PinInstanceId = PinNumber++;

                                // allocate local storage for the pin data
                                PortPinWaveCyclic = (CPortPinWaveCyclic *)LocalAlloc( LPTR, sizeof(CPortPinWaveCyclic) );
                                if( !PortPinWaveCyclic )
                                {
                                    dprintf("** Unable to allocate pin data storage\n");
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // read the pin data
                                if( !ReadMemory( (ULONG)CONTAINING_RECORD(Flink,
                                                                          CPortPinWaveCyclic,
                                                                          m_PinListEntry),
                                                 PortPinWaveCyclic,
                                                 sizeof(CPortPinWaveCyclic),
                                                 &Result ) )
                                {
                                    dprintf("** Unable to read pin data\n");
                                    LocalFree( PortPinWaveCyclic );
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // is there an irp stream
                                if( PortPinWaveCyclic->m_IrpStream )
                                {
                                    // allocate local storage for the irp stream data
                                    IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                    if( IrpStream )
                                    {
                                        // read the irp stream data
                                        if( !ReadMemory( (ULONG)((CIrpStream *)(PortPinWaveCyclic->m_IrpStream)),
                                                         IrpStream,
                                                         sizeof(CIrpStream),
                                                         &Result ) )
                                        {
                                            dprintf("** Unable to read irp stream data\n");
                                            LocalFree( IrpStream );
                                        } else
                                        {
                                            PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                       (CIrpStream *)(PortPinWaveCyclic->m_IrpStream),
                                                                       IrpStream );
                                        }
                                    } else
                                    {
                                        dprintf("** Unable to allocate irp stream storage\n");
                                    }
                                }

                                // we need a new filter unless we find it in the filter list
                                NeedNewFilter = TRUE;

                                // is the filter list empty?
                                if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                {
                                    PLIST_ENTRY     FilterListEntry;

                                    for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                         FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                         FilterListEntry = FilterListEntry->Flink )
                                    {
                                        PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                        if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinWaveCyclic->m_Filter) )
                                        {
                                            // found our filter
                                            NeedNewFilter = FALSE;

                                            // add the pin data to the pin entry
                                            CurrentPinEntry->PinData = (PVOID)PortPinWaveCyclic;

                                            // add the pin entry to the filter's pin list
                                            InsertTailList( &(CurrentFilterEntry->PinList),
                                                            &(CurrentPinEntry->ListEntry) );
                                        }
                                    }
                                }

                                // do we need a new filter entry?
                                if( NeedNewFilter )
                                {
                                    PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                    // allocate a new filter entry
                                    CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                    if(!CurrentFilterEntry)
                                    {
                                        dprintf("** Unable to allocate filter entry\n");
                                        LocalFree( PortPinWaveCyclic );
                                        if( CurrentPinEntry->IrpStreamData )
                                        {
                                            LocalFree( CurrentPinEntry->IrpStreamData );
                                        }
                                        // free up any irps in the irp list
                                        while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                        {
                                            PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                            LocalFree( IrpEntry );                                                
                                        }
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    //initialize the new filter entry
                                    InitializeListHead( &(CurrentFilterEntry->PinList) );
                                    CurrentFilterEntry->FilterData = NULL;
                                    CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinWaveCyclic->m_Filter);

                                    // add the pin data to the pin entry
                                    CurrentPinEntry->PinData = (PVOID)PortPinWaveCyclic;

                                    // add the pin entry to the filter's pin list
                                    InsertTailList( &(CurrentFilterEntry->PinList),
                                                    &(CurrentPinEntry->ListEntry) );

                                    /// add the filter entry to the port's filter list
                                    InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                    &(CurrentFilterEntry->ListEntry) );
                                }
                                
                                // allocate list entry storage
                                TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
                                if( TempListEntry )
                                {
                                    // read in the next list entry
                                    if( !ReadMemory( (ULONG)Flink,
                                                     TempListEntry,
                                                     sizeof(LIST_ENTRY),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read temp list entry\n");
                                        LocalFree(TempListEntry);
                                        break;
                                    }

                                    // update FLINK
                                    Flink = TempListEntry->Flink;

                                    // free the temp list entry
                                    LocalFree( TempListEntry );
                                } else
                                {
                                    dprintf("** Unable to allocate temp list entry\n");
                                    break;
                                }                                                
                            }
                        }
                    }
                    break;

                case WavePci:
                    {
                        CPortWavePci *PortWavePci = (CPortWavePci *)Port;


                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               Offset;
                            ULONG               PortBase;
                            PLIST_ENTRY         Flink;
                            PLIST_ENTRY         TempListEntry;
                            ULONG               PinNumber = 0;
                            CPortPinWavePci *PortPinWavePci;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            // get the offsets needed to walk the list
                            Offset = FIELD_OFFSET(CPortWavePci,m_PinList);
                            PortBase = (ULONG)((CPortWavePci *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context)));

                            // get the first pin pointer
                            Flink = PortWavePci->m_PinList.Flink;

                            while (Flink != PLIST_ENTRY(PortBase + Offset))
                            {
                                // allocate a pin list entry
                                CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                if( !CurrentPinEntry )
                                {
                                    dprintf("** Unable to allocate pin list entry\n");
                                    break;
                                }
                                
                                // initialize the pin entry
                                InitializeListHead( &(CurrentPinEntry->IrpList) );
                                CurrentPinEntry->PinData = NULL;
                                CurrentPinEntry->IrpStreamData = NULL;
                                CurrentPinEntry->PinInstanceId = PinNumber++;

                                // allocate local storage for the pin data
                                PortPinWavePci = (CPortPinWavePci *)LocalAlloc( LPTR, sizeof(CPortPinWavePci) );
                                if( !PortPinWavePci )
                                {
                                    dprintf("** Unable to allocate pin data storage\n");
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // read the pin data
                                if( !ReadMemory( (ULONG)CONTAINING_RECORD(Flink,
                                                                          CPortPinWavePci,
                                                                          m_PinListEntry),
                                                 PortPinWavePci,
                                                 sizeof(CPortPinWavePci),
                                                 &Result ) )
                                {
                                    dprintf("** Unable to read pin data\n");
                                    LocalFree( PortPinWavePci );
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // is there an irp stream
                                if( PortPinWavePci->m_IrpStream )
                                {
                                    // allocate local storage for the irp stream data
                                    IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                    if( IrpStream )
                                    {
                                        // read the irp stream data
                                        if( !ReadMemory( (ULONG)((CIrpStream *)(PortPinWavePci->m_IrpStream)),
                                                         IrpStream,
                                                         sizeof(CIrpStream),
                                                         &Result ) )
                                        {
                                            dprintf("** Unable to read irp stream data\n");
                                            LocalFree( IrpStream );
                                        } else
                                        {
                                            PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                       (CIrpStream *)(PortPinWavePci->m_IrpStream),
                                                                       IrpStream );
                                        }
                                    } else
                                    {
                                        dprintf("** Unable to allocate irp stream storage\n");
                                    }
                                }

                                // we need a new filter unless we find it in the filter list
                                NeedNewFilter = TRUE;

                                // is the filter list empty?
                                if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                {
                                    PLIST_ENTRY     FilterListEntry;

                                    for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                         FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                         FilterListEntry = FilterListEntry->Flink )
                                    {
                                        PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                        if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinWavePci->Filter) )
                                        {
                                            // found our filter
                                            NeedNewFilter = FALSE;

                                            // add the pin data to the pin entry
                                            CurrentPinEntry->PinData = (PVOID)PortPinWavePci;

                                            // add the pin entry to the filter's pin list
                                            InsertTailList( &(CurrentFilterEntry->PinList),
                                                            &(CurrentPinEntry->ListEntry) );
                                        }
                                    }
                                }

                                // do we need a new filter entry?
                                if( NeedNewFilter )
                                {
                                    PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                    // allocate a new filter entry
                                    CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                    if(!CurrentFilterEntry)
                                    {
                                        dprintf("** Unable to allocate filter entry\n");
                                        LocalFree( PortPinWavePci );
                                        if( CurrentPinEntry->IrpStreamData )
                                        {
                                            LocalFree( CurrentPinEntry->IrpStreamData );
                                        }
                                        // free up any irps in the irp list
                                        while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                        {
                                            PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                            LocalFree( IrpEntry );                                                
                                        }
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    //initialize the new filter entry
                                    InitializeListHead( &(CurrentFilterEntry->PinList) );
                                    CurrentFilterEntry->FilterData = NULL;
                                    CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinWavePci->Filter);

                                    // add the pin data to the pin entry
                                    CurrentPinEntry->PinData = (PVOID)PortPinWavePci;

                                    // add the pin entry to the filter's pin list
                                    InsertTailList( &(CurrentFilterEntry->PinList),
                                                    &(CurrentPinEntry->ListEntry) );

                                    /// add the filter entry to the port's filter list
                                    InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                    &(CurrentFilterEntry->ListEntry) );
                                }
                                
                                // allocate list entry storage
                                TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
                                if( TempListEntry )
                                {
                                    // read in the next list entry
                                    if( !ReadMemory( (ULONG)Flink,
                                                     TempListEntry,
                                                     sizeof(LIST_ENTRY),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read temp list entry\n");
                                        LocalFree(TempListEntry);
                                        break;
                                    }

                                    // update FLINK
                                    Flink = TempListEntry->Flink;

                                    // free the temp list entry
                                    LocalFree( TempListEntry );
                                } else
                                {
                                    dprintf("** Unable to allocate temp list entry\n");
                                    break;
                                }                                                
                            }
                        }
                    }                    
                    break;

                case Midi:
                    {
                        CPortMidi *PortMidi = (CPortMidi *)Port;

                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               PinIndex;
                            CPortPinMidi       *PortPinMidi;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            for( PinIndex = 0; PinIndex < PortMidi->m_PinEntriesUsed; PinIndex++ )
                            {
                                if( PortMidi->m_Pins[ PinIndex] )
                                {
                                    // allocate a pin list entry
                                    CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                    if( !CurrentPinEntry )
                                    {
                                        dprintf("** Unable to allocate pin list entry\n");
                                        break;
                                    }

                                    // initialize the pin entry
                                    InitializeListHead( &(CurrentPinEntry->IrpList) );
                                    CurrentPinEntry->PinData = NULL;
                                    CurrentPinEntry->PinInstanceId = (ULONG)(PortMidi->m_Pins[ PinIndex ]);

                                    // allocate local storage for the pin data
                                    PortPinMidi = (CPortPinMidi *)LocalAlloc( LPTR, sizeof(CPortPinMidi) );
                                    if( !PortPinMidi )
                                    {
                                        dprintf("** Unable to allocate pin data storage\n");
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // read the pin data
                                    if( !ReadMemory( (ULONG)(PortMidi->m_Pins[ PinIndex ]),
                                                     PortPinMidi,
                                                     sizeof(CPortPinMidi),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read pin data\n");
                                        LocalFree( PortPinMidi );
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // is there an irp stream
                                    if( PortPinMidi->m_IrpStream )
                                    {
                                        // allocate local storage for the irp stream data
                                        IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                        if( IrpStream )
                                        {
                                            // read the irp stream data
                                            if( !ReadMemory( (ULONG)(PortPinMidi->m_IrpStream),
                                                             IrpStream,
                                                             sizeof(CIrpStream),
                                                             &Result ) )
                                            {
                                                dprintf("** Unable to read irp stream data\n");
                                                LocalFree( IrpStream );
                                            } else
                                            {
                                                PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                           (CIrpStream *)(PortPinMidi->m_IrpStream),
                                                                           IrpStream );
                                            }
                                        } else
                                        {
                                            dprintf("** Unable to allocate irp stream storage\n");
                                        }
                                    }

                                    // we need a new filter unless we find it in the filter list
                                    NeedNewFilter = TRUE;

                                    // is the filter list empty?
                                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                    {
                                        PLIST_ENTRY     FilterListEntry;

                                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                             FilterListEntry = FilterListEntry->Flink )
                                        {
                                            PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                            if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinMidi->m_Filter) )
                                            {
                                                // found our filter
                                                NeedNewFilter = FALSE;

                                                // add the pin data to the pin entry
                                                CurrentPinEntry->PinData = (PVOID)PortPinMidi;

                                                // add the pin entry to the filter's pin list
                                                InsertTailList( &(CurrentFilterEntry->PinList),
                                                                &(CurrentPinEntry->ListEntry) );
                                            }
                                        }
                                    }

                                    // do we need a new filter entry?
                                    if( NeedNewFilter )
                                    {
                                        PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                        // allocate a new filter entry
                                        CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                        if(!CurrentFilterEntry)
                                        {
                                            dprintf("** Unable to allocate filter entry\n");
                                            LocalFree( PortPinMidi );
                                            if( CurrentPinEntry->IrpStreamData )
                                            {
                                                LocalFree( CurrentPinEntry->IrpStreamData );
                                            }
                                            // free up any irps in the irp list
                                            while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                            {
                                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                                LocalFree( IrpEntry );
                                            }
                                            LocalFree( CurrentPinEntry );
                                            break;
                                        }

                                        //initialize the new filter entry
                                        InitializeListHead( &(CurrentFilterEntry->PinList) );
                                        CurrentFilterEntry->FilterData = NULL;
                                        CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinMidi->m_Filter);

                                        // add the pin data to the pin entry
                                        CurrentPinEntry->PinData = (PVOID)PortPinMidi;

                                        // add the pin entry to the filter's pin list
                                        InsertTailList( &(CurrentFilterEntry->PinList),
                                                        &(CurrentPinEntry->ListEntry) );

                                        /// add the filter entry to the port's filter list
                                        InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                        &(CurrentFilterEntry->ListEntry) );
                                    }
                                }
                            }
                        }
                    }                    
                    break;

                default:
                    break;
            }
        }
    }
}

/**********************************************************************
 * PCKD_DisplayDeviceData
 **********************************************************************
 * Description:
 *      This routine displays the requested device data on the debugger
 *      given a valid device context and a subdevice list built with
 *      PCKD_AcquireDeviceData.
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PLIST_ENTRY         SubdeviceList
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      None
 */
VOID
PCKD_DisplayDeviceData
(
    PDEVICE_CONTEXT     DeviceContext,
    PLIST_ENTRY         SubdeviceList,
    ULONG               flags
)
{
    PLIST_ENTRY             SubdeviceListEntry;
    PCKD_SUBDEVICE_ENTRY    *SubdeviceEntry;
    ANSI_STRING             AnsiNameString;
    PORTCLS_FLAGS           Flags;

    Flags.Flags = flags;

    dprintf("\n");

    // dump misc device context information
    if( Flags.DeviceContext )
    {
        dprintf("\n  DEVICE INFO:\n");
    
        dprintf("    PDO:                   0x%x\n",DeviceContext->PhysicalDeviceObject);
        if( Flags.Verbose )
        {
            if( Flags.ReallyVerbose )
            {
                dprintf("    Max Objects:           0x%x\n",DeviceContext->MaxObjects);
            }
            dprintf("    Existing Objects:      0x%x\n",DeviceContext->ExistingObjectCount);
            dprintf("    Active Pin Count:      0x%x\n",DeviceContext->ActivePinCount);
            dprintf("    Pending IRP Count:     0x%x\n",DeviceContext->PendingIrpCount);
        }
    }

    // dump power management information
    if( Flags.PowerInfo )
    {
        dprintf("\n  POWER INFO:\n");

        dprintf("    DeviceState:           %s\n", TranslateDevicePower( DeviceContext->CurrentDeviceState ) );
        dprintf("    SystemState:           %s\n", TranslateSystemPower( DeviceContext->CurrentSystemState ) );
        dprintf("    AdapterPower:          0x%x\n", DeviceContext->pAdapterPower );
        if( Flags.Verbose && Flags.ReallyVerbose )
        {
            ULONG index;
            
            dprintf("    Idle Timer:            0x%x\n", DeviceContext->IdleTimer );
            dprintf("    Cons Idle Time:        0x%x\n", DeviceContext->ConservationIdleTime );
            dprintf("    Perf Idle Time:        0x%x\n", DeviceContext->PerformanceIdleTime );
            dprintf("    Idle Device State:     %s\n", TranslateDevicePower( DeviceContext->IdleDeviceState ) );

            dprintf("    State Mappings:\n");    
            for( index = 0; index < (ULONG)PowerSystemMaximum; index++ )
            {
                dprintf("      %20s ==> %14s\n", TranslateSystemPower( index ),
                                                 TranslateDevicePower( DeviceContext->DeviceStateMap[ index ] ) );
            }
        }
    }

    // dump port/filter/pin information
    if( Flags.PortDump || Flags.FilterDump || Flags.PinDump )
    {
        if( !IsListEmpty( SubdeviceList ) )
        {
            // go through the subdevice list
            for( SubdeviceListEntry = SubdeviceList->Flink;
                 SubdeviceListEntry != SubdeviceList;
                 SubdeviceListEntry = SubdeviceListEntry->Flink )
            {
                SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *)SubdeviceListEntry;

                switch( SubdeviceEntry->Port.PortType )
                {
                    case Topology:
                        // dump port name
                        dprintf("\n  TOPOLOGY PORT:\n");
                        break;

                    case WaveCyclic:
                        // dump port name
                        dprintf("\n  WAVECYCLIC PORT:\n");
                        break;

                    case WavePci:
                        // dump port name
                        dprintf("\n  WAVEPCI PORT:\n");
                        break;

                    case Midi:
                        // dump port name
                        dprintf("\n  MIDI PORT:\n");
                        break;

                    default:
                        // dump port name
                        dprintf("\n  UNKNOWN PORT:\n");
                        break;                        
                }

                // print out the real name
                RtlUnicodeStringToAnsiString( &AnsiNameString,
                                              &(SubdeviceEntry->CreateItem.ObjectClass),
                                              TRUE );
                dprintf("    Name:                  %s\n",AnsiNameString.Buffer);
                RtlFreeAnsiString( &AnsiNameString );

                // dump the port instance
                dprintf("    Port Instance:         0x%x\n",SubdeviceEntry->CreateItem.Context);

                if( Flags.Verbose && Flags.ReallyVerbose )
                {
                    // dump generic port data
                    dprintf("    Create:                0x%x\n",SubdeviceEntry->CreateItem.Create);
                    dprintf("    Security:              0x%x\n",SubdeviceEntry->CreateItem.SecurityDescriptor);
                    dprintf("    Flags:                 0x%x\n",SubdeviceEntry->CreateItem.Flags);
                }

                // dump port type specific port data
                switch( SubdeviceEntry->Port.PortType )
                {
                    case Topology:
                        {
                            CPortTopology *port = (CPortTopology *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case WaveCyclic:
                        {
                            CPortWaveCyclic *port = (CPortWaveCyclic *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case WavePci:
                        {
                            CPortWavePci *port = (CPortWavePci *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case Midi:
                        {
                            CPortMidi *port = (CPortMidi *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->m_Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                            dprintf("    Pin Count:             0x%x\n",port->m_PinEntriesUsed);
                        }
                        break;

                    default:
                        break;
                }

                if( Flags.FilterDump || Flags.PinDump )
                {
                    // dump the filters
                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                    {
                        PLIST_ENTRY         FilterListEntry;
                        PCKD_FILTER_ENTRY   *FilterEntry;                        

                        // run through the filter list
                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                             FilterListEntry = FilterListEntry->Flink )
                        {
                            FilterEntry = (PCKD_FILTER_ENTRY *)FilterListEntry;

                            dprintf("      Filter Instance:     0x%x\n",FilterEntry->FilterInstanceId);

                            if( Flags.PinDump )
                            {
                                // dump the pins
                                if( !IsListEmpty( &(FilterEntry->PinList) ) )
                                {
                                    PLIST_ENTRY         PinListEntry;
                                    PCKD_PIN_ENTRY      *PinEntry;

                                    // run through the pin list
                                    for( PinListEntry = FilterEntry->PinList.Flink;
                                         PinListEntry != &(FilterEntry->PinList);
                                         PinListEntry = PinListEntry->Flink )
                                    {
                                        PinEntry = (PCKD_PIN_ENTRY *)PinListEntry;

                                        dprintf("        Pin Instance:      0x%x\n",PinEntry->PinInstanceId);

                                        // dump the pin data
                                        switch( SubdeviceEntry->Port.PortType )
                                        {
                                            case WaveCyclic:
                                                {
                                                    CPortPinWaveCyclic *pin = (CPortPinWaveCyclic *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->m_Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->m_Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->m_CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->m_DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->m_DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->m_Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->m_ServiceGroup);
                                                            dprintf("          Dma Channel:     0x%x\n",pin->m_DmaChannel);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                            if( !IsListEmpty( &(PinEntry->IrpList) ) )
                                                            {
                                                                PLIST_ENTRY     IrpListEntry;
                                                                PCKD_IRP_ENTRY *IrpEntry;

                                                                // run through the irp list
                                                                for( IrpListEntry = PinEntry->IrpList.Flink;
                                                                     IrpListEntry != &(PinEntry->IrpList);
                                                                     IrpListEntry = IrpListEntry->Flink )
                                                                {
                                                                    IrpEntry = (PCKD_IRP_ENTRY *)IrpListEntry;
                                                                    dprintf("            Irp:           0x%x (%s)\n",IrpEntry->Irp,
                                                                                                                     TranslateQueueType(IrpEntry->QueueType));
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;

                                            case WavePci:
                                                {
                                                    CPortPinWavePci *pin = (CPortPinWavePci *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        //dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->ServiceGroup);
                                                            dprintf("          Dma Channel:     0x%x\n",pin->DmaChannel);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                        }
                                                    }
                                                }
                                                break;

                                            case Midi:
                                                {
                                                    CPortPinMidi *pin = (CPortPinMidi *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->m_Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->m_Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->m_CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->m_DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->m_DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->m_Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->m_ServiceGroup);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                        }
                                                    }
                                                }
                                                break;

                                            default:
                                                break;
                                        }

                                    }

                                } else
                                {
                                    dprintf("        No Pin Instances:\n");      
                                }
                            }
                        }   
                    }
                }
            }
        }
    }

    return;
}

/**********************************************************************
 * PCKD_FreeDeviceData
 **********************************************************************
 * Description:
 *      This routine cleans up and frees the subdevice list.
 * Arguments:
 *      PLIST_ENTRY         SubdeviceList
 *
 * Return Value:
 *      None
 */
VOID
PCKD_FreeDeviceData
(
    PLIST_ENTRY         SubdeviceList
)
{
    PLIST_ENTRY             SubdeviceListEntry;
    PLIST_ENTRY             FilterListEntry;
    PLIST_ENTRY             PinListEntry;
    PCKD_SUBDEVICE_ENTRY    *SubdeviceEntry;
    PCKD_FILTER_ENTRY       *FilterEntry;
    PCKD_PIN_ENTRY          *PinEntry;

    if( !IsListEmpty( SubdeviceList ) )
    {
        SubdeviceListEntry = RemoveHeadList( SubdeviceList );

        while( SubdeviceListEntry )
        {
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *) SubdeviceListEntry;

            // see if we have filters in the filter list
            if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
            {
                FilterListEntry = RemoveHeadList( &(SubdeviceEntry->Port.FilterList) );

                while( FilterListEntry )
                {
                    FilterEntry = (PCKD_FILTER_ENTRY *)FilterListEntry;

                    // see if we have pins in the pin list
                    if( !IsListEmpty( &(FilterEntry->PinList) ) )
                    {
                        PinListEntry = RemoveHeadList( &(FilterEntry->PinList) );

                        while( PinListEntry )
                        {
                            PinEntry = (PCKD_PIN_ENTRY *)PinListEntry;

                            // free the pin data
                            if( PinEntry->PinData )
                            {
                                LocalFree( PinEntry->PinData );
                            }

                            // free the irp stream data
                            if( PinEntry->IrpStreamData )
                            {
                                LocalFree( PinEntry->IrpStreamData );
                            }

                            // free up any irps in the irp list
                            while( !IsListEmpty( &(PinEntry->IrpList) ) )
                            {
                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(PinEntry->IrpList));
                                LocalFree( IrpEntry );
                            }

                            // free the pin entry
                            LocalFree( PinEntry );

                            // get the next pin
                            if( !IsListEmpty( &(FilterEntry->PinList) ) )
                            {
                                PinListEntry = RemoveTailList( &(FilterEntry->PinList) );
                            } else
                            {
                                PinListEntry = NULL;
                            }
                        }
                    }

                    // free the filter data
                    if( FilterEntry->FilterData )
                    {
                        LocalFree( FilterEntry->FilterData );
                    }

                    // free the filter entry
                    LocalFree( FilterEntry );

                    // get the next filter
                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                    {
                        FilterListEntry = RemoveTailList( &(SubdeviceEntry->Port.FilterList) );
                    } else
                    {
                        FilterListEntry = NULL;
                    }
                }
            }

            // free the port data
            if( SubdeviceEntry->Port.PortData )
            {
                LocalFree( SubdeviceEntry->Port.PortData );
            }

            // free the unicode string buffer
            LocalFree( SubdeviceEntry->CreateItem.ObjectClass.Buffer );

            // free the subdevice entry
            LocalFree( SubdeviceEntry );

            // on to the next subdevice
            if( !IsListEmpty( SubdeviceList ) )
            {
                SubdeviceListEntry = RemoveTailList( SubdeviceList );
            } else
            {
                SubdeviceListEntry = NULL;
            }
        }
    }

    return;
}

/**********************************************************************
 * PCKD_AcquireIrpStreamData
 **********************************************************************
 * Description:
 *      This routine acquires irp stream irp queue data.
 * Arguments:
 *      PCKD_PIN_ENTRY  *CurrentPinEntry
 *      CIrpStream      *RemoteIrpStream,
 *      CIrpStream      *LocalIrpStream
 *
 * Return Value:
 *      None
 */
VOID
PCKD_AcquireIrpStreamData
(
    PVOID           PinEntry,
    CIrpStream     *RemoteIrpStream,
    CIrpStream     *LocalIrpStream
)
{
    ULONG           QueueType;
    PLIST_ENTRY     Flink;
    PLIST_ENTRY     TempListEntry;
    PIRP            pIrp;
    PCKD_IRP_ENTRY *IrpEntry;
    ULONG           Offset;
    ULONG           Result;
    PCKD_PIN_ENTRY *CurrentPinEntry;

    CurrentPinEntry = (PCKD_PIN_ENTRY *)PinEntry;

    // processs the queues
    for( QueueType = MAPPED_QUEUE; QueueType < MAX_QUEUES; QueueType++ )
    {
        switch( QueueType )
        {
            case PRELOCK_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,PreLockQueue);
                Flink = LocalIrpStream->PreLockQueue.Flink;
                break;
            case LOCKED_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,LockedQueue);
                Flink = LocalIrpStream->LockedQueue.Flink;
                break;
            case MAPPED_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,MappedQueue);
                Flink = LocalIrpStream->MappedQueue.Flink;
                break;
            default:
                Flink = 0;
                break;
        }

        // walk the list (note we can't use IsListEmpty)
        while( (Flink) && (Flink != (PLIST_ENTRY)((PBYTE)RemoteIrpStream + Offset)))
        {
            // get the irp pointer
            pIrp = CONTAINING_RECORD( Flink, IRP, Tail.Overlay.ListEntry );
    
            // allocate an irp entry
            IrpEntry = (PCKD_IRP_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_IRP_ENTRY) );
            if( IrpEntry )
            {
                // initialize the irp entry
                IrpEntry->QueueType = QueueType;
                IrpEntry->Irp = pIrp;
    
                // add the irp entry to the pin entry
                InsertTailList( &(CurrentPinEntry->IrpList),
                                &(IrpEntry->ListEntry) );
    
            } else
            {
                dprintf("** Unable to allocate irp entry\n");
            }
    
            // allocate list entry storage
            TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
            if( TempListEntry )
            {
                // read in the next list entry
                if( !ReadMemory( (ULONG)Flink,
                                 TempListEntry,
                                 sizeof(LIST_ENTRY),
                                 &Result ) )
                {
                    dprintf("** Unable to read temp list entry\n");
                    LocalFree(TempListEntry);
                    break;
                }
    
                // update FLINK
                Flink = TempListEntry->Flink;
    
                // free the temp list entry
                LocalFree( TempListEntry );
            } else
            {
                dprintf("** Unable to allocate temp list entry\n");
                break;
            }                                                
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\pool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pool.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (Loup) 5-Nov-1993

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma)

    Using debugger type info.

--*/

#include "precomp.h"
#pragma hdrstop
typedef struct _POOL_BLOCK_HEAD {
//    POOL_HEADER Header;
    LIST_ENTRY  List;
} POOL_BLOCK_HEAD, *PPOOL_BLOCK_HEADER;

typedef struct _POOL_HACKER {
//    POOL_HEADER Header;
    ULONG Contents[8];
} POOL_HACKER;


#define TAG 0
#define NONPAGED_ALLOC 1
#define NONPAGED_FREE 2
#define PAGED_ALLOC 3
#define PAGED_FREE 4
#define NONPAGED_USED 5
#define PAGED_USED 6

BOOL  NewPool;
ULONG SortBy;

typedef struct _FILTER {
    ULONG Tag;
    BOOLEAN Exclude;
} FILTER, *PFILTER;

#define MAX_FILTER 64
FILTER Filter[MAX_FILTER];

ULONG64 SpecialPoolStart;
ULONG64 SpecialPoolEnd;
ULONG64 PoolBigTableAddress;


#define DecodeLink(Pool)    ( (ULONG64) (Pool & (ULONG64) ~1))

//
// Size of a pool page.
//
// This must be greater than or equal to the page size.
//

#define POOL_PAGE_SIZE  PageSize

//
// The smallest pool block size must be a multiple of the page size.
//
// Define the block size as 32.
//


#define POOL_LIST_HEADS (POOL_PAGE_SIZE / (1 << POOL_BLOCK_SHIFT))



#define SPECIAL_POOL_BLOCK_SIZE(PoolHeader_Ulong1) (PoolHeader_Ulong1 & (MI_SPECIAL_POOL_VERIFIER - 1))

#ifndef  _EXTFNS_H
// GetPoolTagDescription
typedef HRESULT
(WINAPI *PGET_POOL_TAG_DESCRIPTION)(
    ULONG PoolTag,
    PSTR *pDescription
    );
#endif

ULONG64
GetSpecialPoolHeader (
                     IN PVOID     DataPage,
                     IN ULONG64   RealDataPage,
                     OUT PULONG64 ReturnedDataStart
                     );

int __cdecl
ulcomp(const void *e1,const void *e2)
{
    ULONG u1;
    LONG64 diff;
    ULONG64 ValE1, ValE2;

    switch (SortBy) {
    case TAG:

        GetFieldValue(*((PULONG64) e1), "nt!_POOL_TRACKER_TABLE", "Key", ValE1);
        GetFieldValue(*((PULONG64) e2), "nt!_POOL_TRACKER_TABLE", "Key", ValE2);

        u1 = ((PUCHAR)&ValE1)[0] - ((PUCHAR)&ValE2)[0];
        if (u1 != 0) {
            return u1;
        }
        u1 = ((PUCHAR)&ValE1)[1] - ((PUCHAR)&ValE2)[1];
        if (u1 != 0) {
            return u1;
        }
        u1 = ((PUCHAR)&ValE1)[2] - ((PUCHAR)&ValE2)[2];
        if (u1 != 0) {
            return u1;
        }
        u1 = ((PUCHAR)&ValE1)[3] - ((PUCHAR)&ValE2)[3];
        return u1;
        break;

    case NONPAGED_ALLOC:
        GetFieldValue(*((PULONG64) e1), "nt!_POOL_TRACKER_TABLE", "NonPagedAllocs", ValE1);
        GetFieldValue(*((PULONG64) e2), "nt!_POOL_TRACKER_TABLE", "NonPagedAllocs", ValE2);
        diff = ValE2 - ValE1;
        return( diff ? ( diff > 0 ? 1 : -1 ) : 0 );
        break;

    case NONPAGED_FREE:
        GetFieldValue(*((PULONG64) e1), "nt!_POOL_TRACKER_TABLE", "NonPagedFrees", ValE1);
        GetFieldValue(*((PULONG64) e2), "nt!_POOL_TRACKER_TABLE", "NonPagedFrees", ValE2);
        diff = ValE2 - ValE1;
        return( diff ? ( diff > 0 ? 1 : -1 ) : 0 );
        break;

    case NONPAGED_USED:
        GetFieldValue(*((PULONG64) e1), "nt!_POOL_TRACKER_TABLE", "NonPagedBytes", ValE1);
        GetFieldValue(*((PULONG64) e2), "nt!_POOL_TRACKER_TABLE", "NonPagedBytes", ValE2);
        diff = ValE2 - ValE1;
        return( diff ? ( diff > 0 ? 1 : -1 ) : 0 );
        break;

    case PAGED_USED:
        GetFieldValue(*((PULONG64) e1), "nt!_POOL_TRACKER_TABLE", "PagedBytes", ValE1);
        GetFieldValue(*((PULONG64) e2), "nt!_POOL_TRACKER_TABLE", "PagedBytes", ValE2);
        diff = ValE2 - ValE1;
        return( diff ? ( diff > 0 ? 1 : -1 ) : 0 );
        break;

    default:
        return(0);
        break;
    }
}




/*++

Routine Description:

    Sets up generally useful pool globals.

    Must be called in every DECLARE_API interface that uses pool.

Arguments:

    None.

Return Value:

    None

--*/

LOGICAL PoolInitialized = FALSE;

LOGICAL
PoolInitializeGlobals(
                     VOID
                     )
{
    if (PoolInitialized == TRUE) {
        return TRUE;
    }

    SpecialPoolStart = GetPointerValue("nt!MmSpecialPoolStart");
    SpecialPoolEnd = GetPointerValue("nt!MmSpecialPoolEnd");


    if (PageSize < 0x1000 || (PageSize & (ULONG)0xFFF)) {
        dprintf ("unable to get MmPageSize (0x%x) - probably bad symbols\n", PageSize);
        return FALSE;
    }

    PoolInitialized = TRUE;

    return TRUE;
}

DECLARE_API( frag )

/*++

Routine Description:

    Dump pool fragmentation

Arguments:

    args - Flags

Return Value:

    None

--*/

{
    ULONG Flags;
    ULONG result;
    ULONG i;
    ULONG count;
    ULONG64 Pool;
    ULONG64 PoolLoc1;
    ULONG TotalFrag;
    ULONG TotalCount;
    ULONG Frag;
    ULONG64 PoolStart;
    ULONG   PoolOverhead;
    ULONG64 PoolLoc;
    ULONG PoolTag, BlockSize, PreviousSize, PoolIndex;
    ULONG TotalPages, TotalBigPages;
    ULONG64 Flink, Blink;
    PCHAR pc;
    ULONG64 tmp;

#define PoolBlk(F,V) GetFieldValue(Pool, "nt!_POOL_BLOCK_HEAD", #F, V)

    if (PoolInitializeGlobals() == FALSE) {
        return E_INVALIDARG;
    }

    dprintf("\n  NonPaged Pool Fragmentation\n\n");
    Flags = 0;
    PoolStart = 0;

    if (GetExpressionEx(args, &tmp, &args)) {
        Flags = (ULONG) tmp;
        PoolStart = GetExpression (args);
    }

    PoolOverhead  = GetTypeSize("nt!_POOL_HEADER");
    if (PoolStart != 0) {
        PoolStart += PoolOverhead;

        Pool = DecodeLink(PoolStart);
        do {

            Pool = Pool - PoolOverhead;
            if ( PoolBlk(Header.PoolTag, PoolTag) ) {
                dprintf("%08p: Unable to get contents of pool block\n", Pool );
                return E_INVALIDARG;
            }

            PoolBlk(Header.BlockSize,BlockSize);
            PoolBlk(Header.PreviousSize,PreviousSize);
            PoolBlk(List.Flink,Flink);
            PoolBlk(List.Blink,Blink);

            dprintf(" %p size: %4lx previous size: %4lx  %c%c%c%c links: %8p %8p\n",
                    Pool,
                    (ULONG)BlockSize << POOL_BLOCK_SHIFT,
                    (ULONG)PreviousSize << POOL_BLOCK_SHIFT,
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                    PP(PoolTag),
                    PP(PoolTag >> 8),
                    PP(PoolTag >> 16),
                    PP((PoolTag&~PROTECTED_POOL) >> 24),
#undef PP
                    Flink,
                    Blink);

            if (Flags != 3) {
                Pool = Flink;
            } else {
                Pool = Blink;
            }

            Pool = DecodeLink(Pool);

            if (CheckControlC()) {
                return E_INVALIDARG;
            }

        } while ( (Pool & (ULONG64) ~1) != (PoolStart & (ULONG64) ~1) );

        return E_INVALIDARG;
    }

    PoolLoc1 = GetNtDebuggerData( NonPagedPoolDescriptor );

    if (PoolLoc1 == 0) {
        dprintf ("unable to get nonpaged pool head\n");
        return E_INVALIDARG;
    }

    PoolLoc = PoolLoc1;

    TotalFrag   = 0;
    TotalCount  = 0;

    for (i = 0; i < POOL_LIST_HEADS; i += 1) {
        CHAR Buffer[40];
        ULONG ListOffset;

        sprintf(Buffer, "ListHeads[%d].Flink", i);
        Frag  = 0;
        count = 0;

        if (GetFieldValue(PoolLoc, "nt!_POOL_DESCRIPTOR", Buffer, Pool)) {
            dprintf ("%08p: Unable to get pool descriptor\n", PoolLoc1);
            return E_INVALIDARG;
        }
        GetFieldOffset("nt!_POOL_DESCRIPTOR", Buffer, &ListOffset);

//        Pool  = (PUCHAR)PoolDesc.ListHeads[i].Flink;
        Pool = DecodeLink(Pool);

        while (Pool != (ListOffset + PoolLoc)) {

            Pool = Pool - PoolOverhead;
            if ( PoolBlk(Header.PoolTag, PoolTag) ) {
                dprintf("%08p: Unable to get contents of pool block\n", Pool );
                return E_INVALIDARG;
            }

            PoolBlk(Header.BlockSize,BlockSize);
            PoolBlk(Header.PreviousSize,PreviousSize);
            PoolBlk(List.Flink,Flink);

            Frag  += BlockSize << POOL_BLOCK_SHIFT;
            count += 1;

            if (Flags & 2) {
                dprintf(" ListHead[%x]: %p size: %4lx previous size: %4lx  %c%c%c%c\n",
                        i,
                        (ULONG)Pool,
                        (ULONG)BlockSize << POOL_BLOCK_SHIFT,
                        (ULONG)PreviousSize << POOL_BLOCK_SHIFT,
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                        PP(PoolTag),
                        PP(PoolTag >> 8),
                        PP(PoolTag >> 16),
                        PP((PoolTag&~PROTECTED_POOL) >> 24));
#undef PP
            }
            Pool = Flink;
            Pool = DecodeLink(Pool);

            if (CheckControlC()) {
                return E_INVALIDARG;
            }
        }
        if (Flags & 1) {
            dprintf("index: %2ld number of fragments: %5ld  bytes: %6ld\n",
                    i,count,Frag);
        }
        TotalFrag  += Frag;
        TotalCount += count;
    }

    dprintf("\n Number of fragments: %7ld consuming %7ld bytes\n",
            TotalCount,TotalFrag);
    GetFieldValue(PoolLoc, "nt!_POOL_DESCRIPTOR", "TotalPages",TotalPages);
    GetFieldValue(PoolLoc, "nt!_POOL_DESCRIPTOR", "TotalBigPages", TotalBigPages);

    dprintf(  " NonPagedPool Usage:  %7ld bytes\n",(TotalPages + TotalBigPages)*PageSize);
    return S_OK;
#undef PoolBlk
}


PRTL_BITMAP
GetBitmap(
         ULONG64 pBitmap
         )
{
    PRTL_BITMAP p;
    ULONG Size, Result;
    ULONG64 Buffer=0;

    if ( GetFieldValue(pBitmap, "nt!_RTL_BITMAP", "Buffer", Buffer)) {
        dprintf("%08p: Unable to get contents of bitmap\n", pBitmap );
        return 0;
    }
    GetFieldValue(pBitmap, "nt!_RTL_BITMAP", "SizeOfBitMap", Size);

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) + (Size / 8) );
    if (p) {
        p->SizeOfBitMap = Size;
        p->Buffer = (PULONG)(p + 1);
        if ( !ReadMemory( Buffer,
                          p->Buffer,
                          Size / 8,
                          &Result) ) {
            dprintf("%08p: Unable to get contents of bitmap buffer\n", Buffer );
            HeapFree( GetProcessHeap(), 0, p );
            p = NULL;
        }
    }


    return p;
}

VOID
DumpPool(
        VOID
        )
{
    ULONG64 p, pStart;
    ULONG64 Size;
    ULONG BusyFlag;
    ULONG CurrentPage, NumberOfPages;
    PRTL_BITMAP StartMap;
    PRTL_BITMAP EndMap;
    ULONG64 PagedPoolStart;
    ULONG64 PagedPoolEnd;
    ULONG Result;
    UCHAR PgPool[] = "nt!_MM_PAGED_POOL_INFO";
    ULONG64 PagedPoolInfoPointer;
    ULONG64 PagedPoolAllocationMap=0, EndOfPagedPoolBitmap=0;

    if (PoolInitializeGlobals() == FALSE) {
        return;
    }

    PagedPoolInfoPointer = GetNtDebuggerData( MmPagedPoolInformation );

    if ( GetFieldValue( PagedPoolInfoPointer,
                        PgPool,
                        "PagedPoolAllocationMap",
                        PagedPoolAllocationMap)) {
        dprintf("%08p: Unable to get contents of paged pool information\n",
                PagedPoolInfoPointer );
        return;
    }

    GetFieldValue( PagedPoolInfoPointer, PgPool, "EndOfPagedPoolBitmap",  EndOfPagedPoolBitmap);


    StartMap = GetBitmap( PagedPoolAllocationMap );
    EndMap = GetBitmap( EndOfPagedPoolBitmap );

    PagedPoolStart = GetNtDebuggerDataPtrValue( MmPagedPoolStart );
    PagedPoolEnd = GetNtDebuggerDataPtrValue( MmPagedPoolEnd );

    if (StartMap && EndMap) {
        p = PagedPoolStart;
        CurrentPage = 0;
        dprintf( "Paged Pool: %p .. %p\n", PagedPoolStart, PagedPoolEnd );

        while (p < PagedPoolEnd) {
            if ( CheckControlC() ) {
                return;
            }
            pStart = p;
            BusyFlag = RtlCheckBit( StartMap, CurrentPage );
            while ( ~(BusyFlag ^ RtlCheckBit( StartMap, CurrentPage )) ) {
                p += PageSize;
                if (RtlCheckBit( EndMap, CurrentPage )) {
                    CurrentPage++;
                    break;
                }

                CurrentPage++;
                if (p > PagedPoolEnd) {
                    break;
                }
            }

            Size = p - pStart;
            dprintf( "%p: %I64x - %s\n", pStart, Size, BusyFlag ? "busy" : "free" );
        }
    }

    HeapFree( GetProcessHeap(), 0, StartMap );
    HeapFree( GetProcessHeap(), 0, EndMap );
}

void
PrintPoolTagComponent(
    ULONG PoolTag
    )
{
    PGET_POOL_TAG_DESCRIPTION GetPoolTagDescription;
    PSTR TagComponent;
#ifdef  _EXTFNS_H
    DEBUG_POOLTAG_DESCRIPTION Desc = {0};
    Desc.SizeOfStruct = sizeof(DEBUG_POOLTAG_DESCRIPTION);
    GetPoolTagDescription = NULL;
    if ((GetExtensionFunction("GetPoolTagDescription", (FARPROC*) &GetPoolTagDescription) != S_OK) ||
        !GetPoolTagDescription) {
        return;
    }

    (*GetPoolTagDescription)(PoolTag, &Desc);
    
    if (Desc.Description[0]) {
        dprintf("\t\tPooltag %4.4s : %s", &PoolTag, Desc.Description);
        if (Desc.Binary[0]) {
            dprintf(", Binary : %s",Desc.Binary);
        }
        if (Desc.Owner[0]) {
            dprintf(", Owner : %s", Desc.Owner);
        }
        dprintf("\n");
    } else {
        dprintf("\t\tOwning component : Unknown (update pooltag.txt)\n");
    }

#else    
    GetPoolTagDescription = NULL;
    if ((GetExtensionFunction("GetPoolTagDescription", (FARPROC*) &GetPoolTagDescription) != S_OK) ||
        !GetPoolTagDescription) {
        return;
    }

    (*GetPoolTagDescription)(PoolTag, &TagComponent);
    if (TagComponent && (100 < (ULONG64) TagComponent)) {
        dprintf("\t\tOwning component : %s\n", TagComponent);
    } else {
        dprintf("\t\tOwning component : Unknown (update pooltag.txt)\n");
    }

#endif
}

PSTR g_PoolRegion[DbgPoolRegionMax] = {
    "Unknown",                      // DbgPoolRegionUnknown,               
    "Special pool",                 // DbgPoolRegionSpecial,             
    "Paged pool",                   // DbgPoolRegionPaged,               
    "Nonpaged pool",                // DbgPoolRegionNonPaged,            
    "Pool code",                    // DbgPoolRegionCode,                
    "Nonpaged pool expansion",      // DbgPoolRegionNonPagedExpansion,   
};                                  

DEBUG_POOL_REGION
GetPoolRegion(
    ULONG64 Pool
    )
{
    static ULONG64 PoolCodeEnd;
    static ULONG64 SpecialPoolEnd;
    static ULONG64 PagedPoolEnd;       
    static ULONG64 NonPagedPoolEnd;
    static ULONG64 NonPagedPoolStart;
    static ULONG64 SpecialPoolStart;
    static ULONG64 PagedPoolStart;
    static ULONG64 NonPagedPoolExpansionStart;
    static ULONG64 PoolCodeStart;
    static BOOL GotAll = FALSE;

    if (!GotAll) {
        PoolCodeEnd = GetPointerValue("nt!MmPoolCodeEnd");
        SpecialPoolEnd = GetPointerValue("nt!MmSpecialPoolEnd");
        PagedPoolEnd = GetPointerValue("nt!MmPagedPoolEnd");       
        NonPagedPoolEnd = GetPointerValue("nt!MmNonPagedPoolEnd");
        NonPagedPoolStart = GetPointerValue("nt!MmNonPagedPoolStart");
        SpecialPoolStart = GetPointerValue("nt!MmSpecialPoolStart");
        PagedPoolStart = GetPointerValue("nt!MmPagedPoolStart");
        NonPagedPoolExpansionStart = GetPointerValue("nt!MmNonPagedPoolExpansionStart");
        PoolCodeStart = GetPointerValue("nt!MmPoolCodeStart");
        GotAll = TRUE;
    }
    if (!(PoolCodeStart || SpecialPoolStart || SpecialPoolEnd || PoolCodeEnd ||
        NonPagedPoolExpansionStart || NonPagedPoolStart || NonPagedPoolEnd ||
        PagedPoolStart || PagedPoolEnd)) {
        GotAll = FALSE;
        return DbgPoolRegionUnknown;
    }
    if ( Pool >= SpecialPoolStart && Pool < SpecialPoolEnd) {
        return DbgPoolRegionSpecial;
    } else if ( Pool >= PagedPoolStart && Pool < PagedPoolEnd) {
        return DbgPoolRegionPaged;
    } else if ( Pool >= NonPagedPoolStart && Pool < NonPagedPoolEnd) {
        return DbgPoolRegionNonPaged;
    } else if ( Pool >= PoolCodeStart && Pool < PoolCodeEnd) {
        return DbgPoolRegionCode;
    } else if ( Pool >= NonPagedPoolExpansionStart) {
        return DbgPoolRegionNonPagedExpansion;
    } else {
        return DbgPoolRegionUnknown;
    }
    return DbgPoolRegionUnknown;
}

void
PrintPoolRegion(
    ULONG64 Pool
    )
{
    PSTR pszRegion;
    DEBUG_POOL_REGION Region;


    Region = GetPoolRegion(Pool);

    pszRegion = g_PoolRegion[Region];
    if (pszRegion) {
        dprintf(pszRegion);
        dprintf("\n");
    } else {
        dprintf("Region unkown\n", Pool);
    }

}
HRESULT
ListPoolPage(
    ULONG64 PoolPageToDump,
    ULONG   Flags,
    PDEBUG_POOL_DATA PoolData
    )
{
    ULONG64     PoolTableAddress;
    ULONG       result;
    ULONG       PoolTag;
    ULONG       Result;
    ULONG64     StartPage;
    ULONG64     Pool;
    ULONG       PoolBlockSize;
    ULONG       PoolHeaderSize;
    ULONG64     PoolHeader;
    ULONG       Previous;
    UCHAR       c;
    PUCHAR      p;
    ULONG64     PoolDataEnd;
    UCHAR       PoolBlockPattern;
    UCHAR       DataPage[0x5000];
    PUCHAR      DataStart;
    ULONG64     RealDataStart;
    LOGICAL     Pagable;
    LOGICAL     FirstBlock;
    ULONG       BlockType;
    ULONG       PoolWhere;
    ULONG       i;
    ULONG       j;
    ULONG       ct;
    ULONG       start;
    ULONG       PoolBigPageTableSize;
    ULONG       SizeOfPoolHdr=GetTypeSize("nt!_POOL_HEADER");

    if (!SpecialPoolStart) {
        SpecialPoolStart = GetPointerValue("nt!MmSpecialPoolStart");
        SpecialPoolEnd = GetPointerValue("nt!MmSpecialPoolEnd");
    }

    Pool        = PAGE_ALIGN64 (PoolPageToDump);
    StartPage   = Pool;
    Previous    = 0;

    if (PoolData) {
        ZeroMemory(PoolData, sizeof(DEBUG_POOL_DATA));
    }
    if (!(Flags & 0x80000000)) {
        dprintf("Pool page %p region is ", PoolPageToDump);
        PrintPoolRegion(PoolPageToDump);
    }


    if ( Pool >= SpecialPoolStart && Pool < SpecialPoolEnd) {
        ULONG Hdr_Ulong=0;

        // LWFIX: this is not ported yet.
        //  dprintf("reading %I64x datapage %x\n", Pool, min(PageSize, sizeof(DataPage)));
        // Pre read the pool
        if ( !ReadMemory( Pool,
                          &DataPage[0],
                          min(PageSize, sizeof(DataPage)),
                          &Result) ) {
            dprintf("%08p: Unable to get contents of special pool block\n", Pool );
            return  E_INVALIDARG;
        }

        if ( GetFieldValue( Pool, "nt!_POOL_HEADER", "Ulong1", Hdr_Ulong)) {
            dprintf("%08p: Unable to get nt!_POOL_HEADER\n", Pool );
            return E_INVALIDARG;
        }

        //
        // Determine whether the data is at the start or end of the page.
        // Start off by assuming the data is at the end, in this case the
        // header will be at the start.
        //

        PoolHeader = GetSpecialPoolHeader((PVOID) &DataPage[0], Pool, &RealDataStart);

        if (PoolHeader == 0) {
            dprintf("Block %p is a corrupted special pool allocation\n",
                    PoolPageToDump);
            return  E_INVALIDARG;
        }
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", Hdr_Ulong);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTag", PoolTag);
        PoolBlockSize = SPECIAL_POOL_BLOCK_SIZE(Hdr_Ulong);

        if (Hdr_Ulong & MI_SPECIAL_POOL_PAGABLE) {
            Pagable = TRUE;
        } else {
            Pagable = FALSE;
        }

        if (PoolData) {
            PoolData->Pool = RealDataStart;
            PoolData->PoolBlock = PoolPageToDump;
            PoolData->SpecialPool = 1;
            PoolData->Pageable = Hdr_Ulong & 0x8000 ? 1 : 0;
            PoolData->Size = PoolBlockSize;
            if (Flags & 0x80000000) {
                // do not print anything
                return S_OK;
            }
        }
        dprintf("*%p size: %4lx %s special pool, Tag is %c%c%c%c\n",
                RealDataStart,
                PoolBlockSize,
                Hdr_Ulong & 0x8000 ? "pagable" : "non-paged",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                PP(PoolTag),
                PP(PoolTag >> 8),
                PP(PoolTag >> 16),
                PP(PoolTag >> 24)
               );
#undef PP
        PrintPoolTagComponent(PoolTag);

        //
        // Add code to validate whole block.
        //

        return S_OK;
    }

    FirstBlock = TRUE;

    while (PAGE_ALIGN64(Pool) == StartPage) {
        ULONG BlockSize=0, PreviousSize=0, PoolType=0, AllocatorBackTraceIndex=0;
        ULONG PoolTagHash=0, PoolIndex=0;
        ULONG64 ProcessBilled=0;

        if ( CheckControlC() ) {
            return E_INVALIDARG;
        }

        if ( GetFieldValue( Pool, "nt!_POOL_HEADER", "BlockSize", BlockSize) ) {
            dprintf("%08p: Unable to get contents of pool block\n", Pool );
            return E_INVALIDARG;
        }

        if (PoolPageToDump >= Pool &&
            PoolPageToDump < (Pool + (BlockSize << POOL_BLOCK_SHIFT))
           ) {
            c = '*';
        } else {
            c = ' ';
        }

        GetFieldValue( Pool, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolType", PoolType);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolTag", PoolTag);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolTagHash", PoolTagHash);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolIndex", PoolIndex);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "AllocatorBackTraceIndex", AllocatorBackTraceIndex);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "ProcessBilled", ProcessBilled);

        BlockType = 0;

        if ((BlockSize << POOL_BLOCK_SHIFT) >= POOL_PAGE_SIZE) {
            BlockType = 1;
        } else if (BlockSize == 0) {
            BlockType = 2;
        } else if (PreviousSize != Previous) {
            BlockType = 3;
        }

        if (BlockType != 0) {
            ULONG BigPageSize = GetTypeSize ("nt!_POOL_TRACKER_BIG_PAGES");

            if (!BigPageSize) {
                dprintf("Cannot get _POOL_TRACKER_BIG_PAGES type size\n");
                break;
            }

            //
            // See if this is a big block allocation.  Iff we have not parsed
            // any other small blocks in here already.
            //

            if (FirstBlock == TRUE) {

                if (!PoolBigTableAddress) {
                    PoolBigTableAddress = GetPointerValue ("PoolBigPageTable");
                }

                PoolTableAddress = PoolBigTableAddress;

                if (PoolTableAddress) {

                    dprintf ("%p is not a valid small pool allocation, checking large pool...\n", Pool);

                    PoolBigPageTableSize = GetUlongValue ("PoolBigPageTableSize");
                    //
                    // Scan the table looking for a match.
                    //

                    i = 0;
                    ct = PageSize / BigPageSize;

                    while (i < PoolBigPageTableSize) {
                        ULONG64 Va=0;
                        ULONG Key=0, NumberOfPages=0;

                        if (PoolBigPageTableSize - i < ct) {
                            ct = PoolBigPageTableSize - i;
                        }

                        if ( GetFieldValue( PoolTableAddress,
                                            "nt!_POOL_TRACKER_BIG_PAGES",
                                            "Va",
                                            Va) ) {
                            dprintf("%08p: Unable to get contents of pool block\n", PoolTableAddress );
                            return E_INVALIDARG;
                        }

                        for (j = 0; j < ct; j += 1) {

                            if ( GetFieldValue( PoolTableAddress + BigPageSize*j,
                                                "nt!_POOL_TRACKER_BIG_PAGES",
                                                "Va",
                                                Va) ) {
                                dprintf("%08p: Unable to get contents of pool block\n", PoolTableAddress );
                                return E_INVALIDARG;
                            }

                            if (Va == PAGE_ALIGN64(Pool)) {

                                //
                                // Match !
                                //
                                GetFieldValue( PoolTableAddress + BigPageSize*j,
                                               "nt!_POOL_TRACKER_BIG_PAGES",
                                               "Key",
                                               Key);
                                GetFieldValue( PoolTableAddress + BigPageSize*j,
                                               "nt!_POOL_TRACKER_BIG_PAGES",
                                               "NumberOfPages",
                                               NumberOfPages);
                                PoolTag = Key;

                                if (PoolData) {
                                    PoolData->Pool = PoolPageToDump;
                                    PoolData->Size = NumberOfPages*PageSize;
                                    PoolData->PoolTag = PoolTag;
                                    PoolData->LargePool = 1;
                                    PoolData->Free = (Pool & POOL_BIG_TABLE_ENTRY_FREE) ? 1 : 0; 
                                    if (Flags & 0x80000000) {
                                        // do not print anything
                                        return S_OK;
                                    }
                                }
                                dprintf("*%p :%s large page allocation, Tag is %c%c%c%c, size is 0x%x bytes\n",
                                        (Pool & ~POOL_BIG_TABLE_ENTRY_FREE),
                                        (Pool & POOL_BIG_TABLE_ENTRY_FREE) ? "free " : "",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                                        PP(PoolTag),
                                        PP(PoolTag >> 8),
                                        PP(PoolTag >> 16),
                                        PP(PoolTag >> 24),
                                        NumberOfPages * PageSize
                                       );
#undef PP
                                PrintPoolTagComponent(PoolTag);
                                return S_OK;
                            }
                        }
                        i += ct;
                        PoolTableAddress += (ct * BigPageSize);
                    }

                    //
                    // No match in small or large pool, must be
                    // freed or corrupt pool
                    //

                    dprintf("%p is freed (or corrupt) pool\n", Pool);
                    return E_INVALIDARG;
                }

                dprintf("unable to get pool big page table - either wrong symbols or pool tagging is disabled\n");
            }

            if (BlockType == 1) {
                dprintf("Bad allocation size @%p, too large\n", Pool);
                return E_INVALIDARG;
            } else if (BlockType == 2) {
                dprintf("Bad allocation size @%p, zero is invalid\n", Pool);
                return E_INVALIDARG;
            } else if (BlockType == 3) {
                dprintf("Bad previous allocation size @%p, last size was %lx\n",
                        Pool, Previous);
                return E_INVALIDARG;
            }
        }

        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolTag", PoolTag);


        if (!(Flags & 2) || c == '*') {
            if (PoolData) {
                PoolData->Pool          = Pool;
                PoolData->PoolBlock     = PoolPageToDump;
                PoolData->PoolTag       = PoolTag & ~PROTECTED_POOL;
                PoolData->ProcessBilled = ProcessBilled;
                PoolData->PreviousSize  = PreviousSize << POOL_BLOCK_SHIFT;
                PoolData->Size          = BlockSize << POOL_BLOCK_SHIFT;
                PoolData->Free          = ((PoolType != 0) && (!NewPool ? 
                                                               (PoolIndex & 0x80) : (PoolType & 0x04))) ? 0 : 1;
                PoolData->Protected     = (PoolTag&PROTECTED_POOL) ? 1 : 0;
                if (Flags & 0x80000000) {
                    // do not print anything
                    return S_OK;
                }
            }

            dprintf("%c%p size: %4lx previous size: %4lx ",
                    c,
                    Pool,
                    BlockSize << POOL_BLOCK_SHIFT,
                    PreviousSize << POOL_BLOCK_SHIFT);

            if (PoolType == 0) {

                //
                // "Free " with a space after it before the parentheses means
                // it's been freed to a (pool manager internal) lookaside list.
                // We used to print "Lookaside" but that just confused driver
                // writers because they didn't know if this meant in use or not
                // and many would say "but I don't use lookaside lists - the
                // extension or kernel is broken".
                //
                // "Free" with no space after it before the parentheses means
                // it is not on a pool manager internal lookaside list and is
                // instead on the regular pool manager internal flink/blink
                // chains.
                //
                // Note to anyone using the pool package, these 2 terms are
                // equivalent.  The fine distinction is only for those actually
                // writing pool internal code.
                //

                dprintf(" (Free)");

#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                dprintf("      %c%c%c%c%c\n",
                        c,
                        PP(PoolTag),
                        PP(PoolTag >> 8),
                        PP(PoolTag >> 16),
                        PP((PoolTag&~PROTECTED_POOL) >> 24)
                       );
#undef PP
                if (c=='*') {
                    PrintPoolTagComponent(PoolTag & ~PROTECTED_POOL);
                }
            } else {

                if (!NewPool ? (PoolIndex & 0x80) : (PoolType & 0x04)) {
                    dprintf(" (Allocated)");
                } else {
                    //
                    // "Free " with a space after it before the parentheses means
                    // it's been freed to a (pool manager internal) lookaside list.
                    // We used to print "Lookaside" but that just confused driver
                    // writers because they didn't know if this meant in use or not
                    // and many would say "but I don't use lookaside lists - the
                    // extension or kernel is broken".
                    //
                    // "Free" with no space after it before the parentheses means
                    // it is not on a pool manager internal lookaside list and is
                    // instead on the regular pool manager internal flink/blink
                    // chains.
                    //
                    // Note to anyone using the pool package, these 2 terms are
                    // equivalent.  The fine distinction is only for those actually
                    // writing pool internal code.
                    //
                    dprintf(" (Free )");
                }
                if ((PoolType & POOL_QUOTA_MASK) == 0) {
                    /*
                    ULONG Key=0;
                    if (AllocatorBackTraceIndex != 0 &&
                        AllocatorBackTraceIndex & POOL_BACKTRACEINDEX_PRESENT
                       ) {
                        if ( GetFieldValue( PoolTrackTable + ( PoolTagHash&~(PROTECTED_POOL >> 16) )*GetTypeSize("nt!_POOL_TRACKER_TABLE"),
                                            "nt!_POOL_TRACKER_TABLE",
                                            "Key",
                                            Key) ) {
                            PoolTag = 0;
                        } else {
                            PoolTag = Key;
                        }

                        if (PoolTagHash & (PROTECTED_POOL >> 16)) {
                            PoolTag |= PROTECTED_POOL;
                        }

                    } else {
                        PoolTag = PoolTag;
                    }*/

                    dprintf(" %c%c%c%c%c%s\n",
                            c,
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                            PP(PoolTag),
                            PP(PoolTag >> 8),
                            PP(PoolTag >> 16),
                            PP((PoolTag&~PROTECTED_POOL) >> 24),
                            (PoolTag&PROTECTED_POOL) ? " (Protected)" : ""
#undef PP
                        );

                    if (c=='*') {
                        PrintPoolTagComponent(PoolTag & ~PROTECTED_POOL);
                    }
                } else {
                    if (ProcessBilled != 0) {
                        dprintf(" Process: %0p\n", ProcessBilled );
                    }
                }
            }

        }


        if (Flags & 1) {
            ULONG i, Contents[8];

            // BUG if Contents have different size than 32 bits
            ReadMemory(Pool + SizeOfPoolHdr,
                       &Contents,
                       sizeof(Contents),
                       &i);
            dprintf("    %08lx  %08lx %08lx %08lx %08lx\n",
                    Pool+SizeOfPoolHdr,
                    Contents[0],
                    Contents[1],
                    Contents[2],
                    Contents[3]);

            dprintf("    %08lx  %08lx %08lx %08lx %08lx\n",
                    Pool+SizeOfPoolHdr+16,
                    Contents[4],
                    Contents[5],
                    Contents[6],
                    Contents[7]);
            dprintf("\n");
        }

        Previous = BlockSize;
        Pool += (Previous << POOL_BLOCK_SHIFT);
        FirstBlock = FALSE;
    }
    return S_OK;
}

DECLARE_API( pool )

/*++

Routine Description:

    Dump kernel mode heap

Arguments:

    args - Page Flags

Return Value:

    None

--*/

{
    ULONG64     PoolPageToDump;
    ULONG       Flags;
    HRESULT     Hr;

    INIT_API();
    if (PoolInitializeGlobals() == FALSE) {
        Hr = E_INVALIDARG;
    } else {
        PoolPageToDump = 0;
        Flags = 0;
        if (GetExpressionEx(args, &PoolPageToDump, &args)) {
            Flags = (ULONG) GetExpression (args);
        }

        if (PoolPageToDump == 0) {
            DumpPool();
            Hr = S_OK;;
        } else {
            Hr = ListPoolPage(PoolPageToDump, Flags, NULL);
        }

    }
    EXIT_API();

    return Hr;

}



DECLARE_API( poolused )

/*++

Routine Description:

    Dump usage by pool tag

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG PoolTrackTableSize;
    ULONG PoolTrackTableSizeInBytes;
    PULONG64 p;
    PUCHAR PoolTrackTableData;
    ULONG Flags;
    ULONG i;
    ULONG result;
    ULONG ct;
    ULONG TagName;
    CHAR TagNameX[4] = {'*','*','*','*'};
    ULONG SizeOfPoolTarker;
    ULONG64 PoolTableAddress;
    ULONG64 PoolTrackTable;
    ULONG NonPagedAllocsTotal,NonPagedFreesTotal,PagedAllocsTotal,PagedFreesTotal;
    ULONG64 NonPagedBytesTotal, PagedBytesTotal;

    if (PoolInitializeGlobals() == FALSE) {
        return E_INVALIDARG;
    }

    Flags = 0;
    if (!sscanf(args,"%lx %c%c%c%c", &Flags, &TagNameX[0],
           &TagNameX[1], &TagNameX[2], &TagNameX[3])) {
        Flags = 0;
    }

    TagName = TagNameX[0] | (TagNameX[1] << 8) | (TagNameX[2] << 16) | (TagNameX[3] << 24);

    PoolTrackTableSize = GetUlongValue ("PoolTrackTableSize");

    if (!(SizeOfPoolTarker = GetTypeSize("nt!_POOL_TRACKER_TABLE"))) {
        dprintf("Unable to get _POOL_TRACKER_TABLE : probably wrong symbols.\n");
        return E_INVALIDARG;
    }

    PoolTrackTable = GetNtDebuggerDataPtrValue( PoolTrackTable );

    if (PoolTrackTable == 0) {
        dprintf ("unable to get PoolTrackTable - ");
        if (GetExpression("nt!PoolTrackTable")) {
            dprintf ("pool tagging is disabled, enable it to use this command\n");
            dprintf ("Use gflags.exe and check the box that says \"Enable pool tagging\".\n");
        } else {
            dprintf ("symbols could be worng\n");
        }
        return  E_INVALIDARG;
    }


    PoolTrackTableSizeInBytes = PoolTrackTableSize * SizeOfPoolTarker;

    PoolTrackTableData = malloc (PoolTrackTableSizeInBytes);
    if (PoolTrackTableData == NULL) {
        dprintf("unable to allocate memory for tag table.\n");
        return E_INVALIDARG;
    }

    //
    // KD is going to cache the data
    //
    PoolTableAddress = PoolTrackTable;
    if ( !ReadMemory( PoolTableAddress,
                      &PoolTrackTableData[0],
                      PoolTrackTableSizeInBytes,
                      &result) ) {
        dprintf("%08p: Unable to get contents of pool block\n", PoolTableAddress );
        free (PoolTrackTableData);
        return E_INVALIDARG;
    }

    if (Flags & 2) {
        SortBy = NONPAGED_USED;
        dprintf("   Sorting by NonPaged Pool Consumed\n");
    } else if (Flags & 4) {
        SortBy = PAGED_USED;
        dprintf("   Sorting by Paged Pool Consumed\n");
    } else {
        SortBy = TAG;
        dprintf("   Sorting by Tag\n");
    }

    dprintf("\n  Pool Used:\n");
    if (!(Flags & 1)) {
        dprintf("            NonPaged            Paged\n");
        dprintf(" Tag    Allocs     Used    Allocs     Used\n");

    } else {
        dprintf("            NonPaged                    Paged\n");
        dprintf(" Tag    Allocs    Frees     Diff     Used   Allocs    Frees     Diff     Used\n");
    }

    ct = PageSize / SizeOfPoolTarker;
    i = 0;
    PoolTableAddress = PoolTrackTable;

    free (PoolTrackTableData);
    //
    // Create array of POOL_TRACKER_TABLE addresses and sort the addresses
    //
    PoolTrackTableData = malloc (PoolTrackTableSize * sizeof(ULONG64));
    if (PoolTrackTableData == NULL) {
        dprintf("unable to allocate memory for tag table.\n");
        return E_INVALIDARG;
    }

    while (i < PoolTrackTableSize) {

        if ( CheckControlC() ) {
            free (PoolTrackTableData);
            return E_INVALIDARG;
        }

        ((PULONG64) PoolTrackTableData)[i] = PoolTableAddress + i * SizeOfPoolTarker;
        i++;
    }

    qsort((void *)PoolTrackTableData,
          (size_t)PoolTrackTableSize,
          (size_t)sizeof(ULONG64),
          ulcomp);

    i = 0;
    p = (PULONG64) &PoolTrackTableData[i];

    NonPagedAllocsTotal = 0;
    NonPagedFreesTotal = 0;
    NonPagedBytesTotal = 0;

    PagedAllocsTotal = 0;
    PagedFreesTotal = 0;
    PagedBytesTotal = 0;

    for ( ; i < PoolTrackTableSize; i += 1, p += 1) {
        ULONG Key,NonPagedAllocs,NonPagedFrees,PagedAllocs,PagedFrees;
        ULONG64 NonPagedBytes, PagedBytes;

#define TrackFld(F)        GetFieldValue(*p, "nt!_POOL_TRACKER_TABLE", #F, F)

        TrackFld(Key);        TrackFld(NonPagedAllocs); TrackFld(NonPagedBytes);
        TrackFld(PagedBytes); TrackFld(NonPagedFrees);  TrackFld(PagedAllocs);
        TrackFld(PagedFrees);

#undef TrackFld

        if ((Key != 0) &&
            (CheckSingleFilter ((PCHAR)&Key, (PCHAR)&TagName))) {

            if (!(Flags & 1)) {

                if ((NonPagedBytes != 0) || (PagedBytes != 0)) {

                    NonPagedAllocsTotal += NonPagedAllocs;
                    NonPagedFreesTotal += NonPagedFrees;
                    NonPagedBytesTotal += NonPagedBytes;

                    PagedAllocsTotal += PagedAllocs;
                    PagedFreesTotal += PagedFrees;
                    PagedBytesTotal += PagedBytes;

                    dprintf(" %c%c%c%c %8ld %8I64ld  %8ld %8I64ld\n",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                            PP(Key),
                            PP(Key >> 8),
                            PP(Key >> 16),
                            PP(Key >> 24),
                            NonPagedAllocs - NonPagedFrees,
                            NonPagedBytes,
                            PagedAllocs - PagedFrees,
                            PagedBytes);
                }

            } else {

                NonPagedAllocsTotal += NonPagedAllocs;
                NonPagedFreesTotal += NonPagedFrees;
                NonPagedBytesTotal += NonPagedBytes;

                PagedAllocsTotal += PagedAllocs;
                PagedFreesTotal += PagedFrees;
                PagedBytesTotal += PagedBytes;

                dprintf(" %c%c%c%c %8ld %8ld %8ld %8I64ld %8ld %8ld %8ld %8I64ld\n",
                        PP(Key),
                        PP(Key >> 8),
                        PP(Key >> 16),
                        PP(Key >> 24),
                        NonPagedAllocs,
                        NonPagedFrees,
                        NonPagedAllocs - NonPagedFrees,
                        NonPagedBytes,
                        PagedAllocs,
                        PagedFrees,
                        PagedAllocs - PagedFrees,
                        PagedBytes);
#undef PP
        }
        }

    }
    if (!(Flags & 1)) {
        dprintf(" TOTAL    %8ld %8I64ld  %8ld %8I64ld\n",
                NonPagedAllocsTotal - NonPagedFreesTotal,
                NonPagedBytesTotal,
                PagedAllocsTotal - PagedFreesTotal,
                PagedBytesTotal);
    } else {
        dprintf(" TOTAL    %8ld %8ld %8ld %8I64ld %8ld %8ld %8ld %8I64ld\n",
                NonPagedAllocsTotal,
                NonPagedFreesTotal,
                NonPagedAllocsTotal - NonPagedFreesTotal,
                NonPagedBytesTotal,
                PagedAllocsTotal,
                PagedFreesTotal,
                PagedAllocsTotal - PagedFreesTotal,
                PagedBytesTotal);
    }

    free (PoolTrackTableData);
    return S_OK;
}

#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')

BOOLEAN WINAPI
CheckSingleFilterAndPrint (
                          PCHAR Tag,
                          PCHAR Filter,
                          ULONG Flags,
                          ULONG64 PoolHeader,
                          ULONG BlockSize,
                          ULONG64 Data,
                          PVOID Context
                          )
/*++

Routine Description:

    Callback to check a piece of pool and print out information about it
    if it matches the specified tag.

Arguments:

    Tag - Supplies the tag to search for.

    Filter - Supplies the filter string to match against.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.
            Supplies 2 if a special pool search is desired.
            Supplies 4 if a pool is a large pool

    PoolHeader - Supplies the pool header.

    BlockSize - Supplies the size of the pool block in bytes.

    Data - Supplies the address of the pool block.

    Context - Unused.

Return Value:

    TRUE for a match, FALSE if not.

--*/
{
    ULONG UTag = *((PULONG)Tag);
    ULONG HdrUlong1=0, HdrPoolSize ;

    UNREFERENCED_PARAMETER (Context);

    if (CheckSingleFilter (Tag, Filter) == FALSE) {
        return FALSE;
    }

    HdrPoolSize = GetTypeSize("nt!_POOL_HEADER");
    if ((BlockSize >= (PageSize-2*HdrPoolSize)) || (Flags & 0x4)) {
        dprintf("*%p :%slarge page allocation, Tag %3s %c%c%c%c, size %3s 0x%x bytes\n",
                (Data & ~POOL_BIG_TABLE_ENTRY_FREE),
                (Data & POOL_BIG_TABLE_ENTRY_FREE) ? "free " : "",
                (Data & POOL_BIG_TABLE_ENTRY_FREE) ? "was" : "is",
                PP(UTag),
                PP(UTag >> 8),
                PP(UTag >> 16),
                PP(UTag >> 24),
                (Data & POOL_BIG_TABLE_ENTRY_FREE) ? "was" : "is",
                BlockSize
               );
    } else if (Flags & 0x2) {
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", HdrUlong1);
        dprintf("*%p size: %4lx %s special pool, Tag is %c%c%c%c\n",
                Data,
                BlockSize,
                HdrUlong1 & MI_SPECIAL_POOL_PAGABLE ? "pagable" : "non-paged",
                PP(UTag),
                PP(UTag >> 8),
                PP(UTag >> 16),
                PP(UTag >> 24)
               );
    } else {
        ULONG BlockSize, PreviousSize, PoolType, PoolIndex, AllocatorBackTraceIndex;
        ULONG PoolTagHash, PoolTag;
        ULONG64 ProcessBilled;

        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", BlockSize);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolType", PoolType);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTagHash", PoolTagHash);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTag", PoolTag);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "ProcessBilled", ProcessBilled);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "AllocatorBackTraceIndex", AllocatorBackTraceIndex);

        dprintf("%p size: %4lx previous size: %4lx ",
                Data - HdrPoolSize,
                BlockSize << POOL_BLOCK_SHIFT,
                PreviousSize << POOL_BLOCK_SHIFT);

        if (PoolType == 0) {
            //
            // "Free " with a space after it before the parentheses means
            // it's been freed to a (pool manager internal) lookaside list.
            // We used to print "Lookaside" but that just confused driver
            // writers because they didn't know if this meant in use or not
            // and many would say "but I don't use lookaside lists - the
            // extension or kernel is broken".
            //
            // "Free" with no space after it before the parentheses means
            // it is not on a pool manager internal lookaside list and is
            // instead on the regular pool manager internal flink/blink
            // chains.
            //
            // Note to anyone using the pool package, these 2 terms are
            // equivalent.  The fine distinction is only for those actually
            // writing pool internal code.
            //
            dprintf(" (Free)");
            dprintf("      %c%c%c%c\n",
                    PP(UTag),
                    PP(UTag >> 8),
                    PP(UTag >> 16),
                    PP(UTag >> 24)
                   );
        } else {

            if (!NewPool ? (PoolIndex & 0x80) : (PoolType & 0x04)) {
                dprintf(" (Allocated)");
            } else {
                //
                // "Free " with a space after it before the parentheses means
                // it's been freed to a (pool manager internal) lookaside list.
                // We used to print "Lookaside" but that just confused driver
                // writers because they didn't know if this meant in use or not
                // and many would say "but I don't use lookaside lists - the
                // extension or kernel is broken".
                //
                // "Free" with no space after it before the parentheses means
                // it is not on a pool manager internal lookaside list and is
                // instead on the regular pool manager internal flink/blink
                // chains.
                //
                // Note to anyone using the pool package, these 2 terms are
                // equivalent.  The fine distinction is only for those actually
                // writing pool internal code.
                //
                dprintf(" (Free )");
            }
            if ((PoolType & POOL_QUOTA_MASK) == 0) {

                UTag = PoolTag;

                dprintf(" %c%c%c%c%s\n",
                        PP(UTag),
                        PP(UTag >> 8),
                        PP(UTag >> 16),
                        PP((UTag &~PROTECTED_POOL) >> 24),
                        (UTag & PROTECTED_POOL) ? " (Protected)" : ""
                       );

            } else {
                if (ProcessBilled != 0) {
                    dprintf(" Process: %08p\n", ProcessBilled );
                }
            }
        }
    }


    return TRUE;
} // CheckSingleFilterAndPrint

#undef PP

ULONG64
GetNextResidentAddress (
                       ULONG64 VirtualAddress,
                       ULONG64 MaximumVirtualAddress
                       )
{
    ULONG64 PointerPde;
    ULONG64 PointerPte;
    ULONG SizeOfPte;
    ULONG Valid;

    //
    // Note this code will need to handle one more level of indirection for
    // WIN64.
    //

    if (!(SizeOfPte=GetTypeSize("nt!_MMPTE"))) {
        dprintf("Cannot get MMPTE type.\n");
        return 0;
    }

    top:

    PointerPde = DbgGetPdeAddress (VirtualAddress);

    while (GetFieldValue(PointerPde,
                         "nt!_MMPTE",
                         "u.Hard.Valid",
                         Valid) ||
           (Valid == 0)) {

        //
        // Note that on 32-bit systems, the PDE should always be readable.
        // If the PDE is not valid then increment to the next PDE's VA.
        //

        PointerPde = (PointerPde + SizeOfPte);

        VirtualAddress = DbgGetVirtualAddressMappedByPte (PointerPde);
        VirtualAddress = DbgGetVirtualAddressMappedByPte (VirtualAddress);

        if (VirtualAddress >= MaximumVirtualAddress) {
            return VirtualAddress;
        }

        if (CheckControlC()) {
            return VirtualAddress;
        }
        continue;
    }

    PointerPte = DbgGetPteAddress (VirtualAddress);

    while (GetFieldValue(PointerPde,
                         "nt!_MMPTE",
                         "u.Hard.Valid",
                         Valid) ||
           (Valid == 0)) {

        //
        // If the PTE cannot be read then increment by PAGE_SIZE.
        //

        VirtualAddress = (VirtualAddress + PageSize);

        if (CheckControlC()) {
            return VirtualAddress;
        }

        PointerPte = (PointerPte + SizeOfPte);
        if ((PointerPte & (PageSize - 1)) == 0) {
            goto top;
        }

        if (VirtualAddress >= MaximumVirtualAddress) {
            return VirtualAddress;
        }
    }

    return VirtualAddress;
}


VOID
SearchPool(
          ULONG TagName,
          ULONG Flags,
          ULONG64 RestartAddr,
          POOLFILTER Filter,
          PVOID Context
          )
/*++

Routine Description:

    Engine to search the pool.

Arguments:

    TagName - Supplies the tag to search for.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.
            Supplies 2 if a special pool search is desired.

    RestartAddr - Supplies the address to restart the search from.

    Filter - Supplies the filter routine to use.

    Context - Supplies the user defined context blob.

Return Value:

    None.

--*/
{
    LOGICAL     PhysicallyContiguous;
    ULONG       PoolBlockSize;
    ULONG64     PoolHeader;
    ULONG       PoolTag;
    ULONG       Result;
    ULONG64     PoolPage;
    ULONG64     StartPage;
    ULONG64     Pool;
    ULONG       Previous;
    ULONG64     PoolStart;
    ULONG64     PoolPteAddress;
    ULONG64     PoolEnd;
    ULONG64       ExpandedPoolStart;
    ULONG64     ExpandedPoolEnd;
    ULONG       InitialPoolSize;
    ULONG       SkipSize;
    BOOLEAN     TwoPools;
    UCHAR       DataPage[0x4000]; // MAX pzger size
    ULONG64     DataPageReal;
    ULONG64     DataStartReal;
    LOGICAL     Found;
    ULONG       i;
    ULONG       j;
    ULONG       ct;
    ULONG       PoolBigPageTableSize;
    ULONG64     PoolTableAddress;
    UCHAR       FastTag[4];
    ULONG       TagLength;
    ULONG       SizeOfBigPages;
    ULONG       PoolTypeFlags = Flags & 0x3;
    ULONG       Ulong1;
    ULONG       HdrSize;

    if (PoolInitializeGlobals() == FALSE) {
        return;
    }

    if (PoolTypeFlags == 2) {

        if (RestartAddr && (RestartAddr >= SpecialPoolStart) && (RestartAddr <= SpecialPoolEnd)) {
            Pool = RestartAddr;
        } else {
            Pool = SpecialPoolStart;
        }

        dprintf("\nSearching special pool (%p : %p) for Tag: %c%c%c%c\r\n\n",
                Pool,
                SpecialPoolEnd,
                TagName,
                TagName >> 8,
                TagName >> 16,
                TagName >> 24);

        Found = FALSE;
        SkipSize = PageSize;

        if (SpecialPoolStart && SpecialPoolEnd) {

            //
            // Search special pool for the tag.
            //

            while (Pool < SpecialPoolEnd) {

                if ( CheckControlC() ) {
                    dprintf("\n...terminating - searched pool to %p\n",
                            Pool);
                    return;
                }

                DataStartReal = Pool;
                DataPageReal = Pool;
                if ( !ReadMemory( Pool,
                                  &DataPage[0],
                                  min(PageSize, sizeof(DataPage)),
                                  &Result) ) {
                    ULONG64 PteLong=0, PageFileHigh;

                    if (SkipSize != 2 * PageSize) {

//                        dprintf("SP skip %x", Pool);
                        PoolPteAddress = DbgGetPteAddress (Pool);

                        if (!GetFieldValue(PoolPteAddress,
                                           "nt!_MMPTE",
                                           "u.Soft.PageFileHigh",
                                           PageFileHigh) ) {

                            if ((PageFileHigh == 0) ||
                                (PageFileHigh == MI_SPECIAL_POOL_PTE_PAGABLE) ||
                                (PageFileHigh == MI_SPECIAL_POOL_PTE_NONPAGABLE)) {

                                //
                                // Found a NO ACCESS PTE - skip these from
                                // here on to speed up the search.
                                //

                                // dprintf("SP skip double %p", PoolPteAddress);
                                SkipSize = 2 * PageSize;
                                Pool += PageSize;
                                // dprintf("SP skip final %p", Pool);
                                continue;
                            }
                        }
                    }

                    Pool += SkipSize;
                    continue;
                }

                //
                // Determine whether this is a valid special pool block.
                //

                PoolHeader = GetSpecialPoolHeader (DataPage,
                                                   DataPageReal,
                                                   &DataStartReal);

                if (PoolHeader != 0) {

                    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTag", PoolTag);
                    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", Ulong1);
                    PoolBlockSize = (ULONG) SPECIAL_POOL_BLOCK_SIZE(Ulong1);

                    Found = Filter( (PCHAR)&PoolTag,
                                    (PCHAR)&TagName,
                                    Flags,
                                    PoolHeader,
                                    PoolBlockSize,
                                    DataStartReal,
                                    Context );
                } else {
                    dprintf( "No pool header for page: 0x%p\n", Pool );
                }
                Pool += SkipSize;
            }
        }

        if (Found == FALSE) {
            dprintf("The %c%c%c%c tag could not be found in special pool.\n",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                    PP(TagName),
                    PP(TagName >> 8),
                    PP(TagName >> 16),
                    PP(TagName >> 24)
                   );
#undef PP
        }
        return;
    }

    if (PoolTypeFlags == 0) {
        PhysicallyContiguous = TRUE;
    } else {
        PhysicallyContiguous = FALSE;
    }

    __try {
        TwoPools = FALSE;

        if (!PoolBigTableAddress) {
            PoolBigTableAddress = GetPointerValue ("PoolBigPageTable");
        }

        PoolTableAddress = PoolBigTableAddress;

        if (PoolTableAddress) {

            ULONG VaOffset;
            ULONG NumPagesOffset;
            ULONG PtrSize;
            ULONG KeyOffset;

            PoolBigPageTableSize = GetUlongValue ("PoolBigPageTableSize");

            //
            //  Scan the table looking for a match. We read close to a page at a time
            //  physical page / sizeof ( pool_tracker_big_page ) *  sizeof ( pool_tracker_big_page )
            //  on x86 this works out to ffc
            //

            i = 0;
            SizeOfBigPages =  GetTypeSize ("nt!_POOL_TRACKER_BIG_PAGES");
            if (!SizeOfBigPages) {
                dprintf("Cannot get _POOL_TRACKER_BIG_PAGES type size\n");
                return;
            }
            ct = PageSize / SizeOfBigPages;

            dprintf( "\nScanning large pool allocation table for Tag: %c%c%c%c (%p : %p)\n\n\r",
                     TagName,
                     TagName >> 8,
                     TagName >> 16,
                     TagName >> 24,
                     PoolBigTableAddress,
                     PoolBigTableAddress + PoolBigPageTableSize * SizeOfBigPages );

            GetFieldOffset( "nt!_POOL_TRACKER_BIG_PAGES", "Va", &VaOffset );
            GetFieldOffset( "nt!_POOL_TRACKER_BIG_PAGES", "NumberOfPages", &NumPagesOffset );
            GetFieldOffset( "nt!_POOL_TRACKER_BIG_PAGES", "Key", &KeyOffset );
            PtrSize = IsPtr64() ? 8 : 4;

            while (i < PoolBigPageTableSize) {

                if (PoolBigPageTableSize - i < ct) {
                    ct = PoolBigPageTableSize - i;
                }

                if ( !ReadMemory( PoolTableAddress,
                                  &DataPage[0],
                                  ct * SizeOfBigPages,
                                  &Result) ) {

                    dprintf( "%08lx: Unable to get contents of big pool block\r\n", PoolTableAddress );
                    break;
                }

                for (j = 0; j < ct; j += 1) {
                    ULONG64 Va = 0;

                    memcpy( &Va, (PCHAR)DataPage + (SizeOfBigPages * j) + VaOffset, PtrSize );

                    Filter( ((PCHAR)DataPage + (SizeOfBigPages * j) + KeyOffset),
                            (PCHAR)&TagName,
                            Flags | 0x4, // To assist filter routine to recognize this as large pool
                            PoolTableAddress + SizeOfBigPages * j,
                            (*((PULONG)((PCHAR)DataPage + (SizeOfBigPages * j) + NumPagesOffset))) * PageSize,
                            Va,
                            Context );
                    if ( CheckControlC() ) {
                        dprintf("\n...terminating - searched pool to %p\n",
                                PoolTableAddress + j * SizeOfBigPages);
                        return;
                    }
                }
                i += ct;
                PoolTableAddress += (ct * SizeOfBigPages);
                if ( CheckControlC() ) {
                    dprintf("\n...terminating - searched pool to %p\n",
                            PoolTableAddress);
                    return;
                }

            }
        } else {
            dprintf("unable to get large pool allocation table - either wrong symbols or pool tagging is disabled\n");
        }

        if (PoolTypeFlags == 0) {
            PoolStart = GetNtDebuggerDataPtrValue( MmNonPagedPoolStart );

            if (0 == PoolStart) {
                dprintf( "Unable to get MmNonPagedPoolStart\n" );
            }

            PoolEnd =
            PoolStart + GetNtDebuggerDataValue( MmMaximumNonPagedPoolInBytes );

            ExpandedPoolEnd = GetNtDebuggerDataPtrValue( MmNonPagedPoolEnd );

            if (PoolEnd != ExpandedPoolEnd) {
                InitialPoolSize = (ULONG)GetUlongValue( "MmSizeOfNonPagedPoolInBytes" );
                PoolEnd = PoolStart + InitialPoolSize;

                ExpandedPoolStart = GetPointerValue( "MmNonPagedPoolExpansionStart" );
                TwoPools = TRUE;
            }
            for (TagLength = 0;TagLength < 3; TagLength++) {
                if ((*(((PCHAR)&TagName)+TagLength) == '?') ||
                    (*(((PCHAR)&TagName)+TagLength) == '*')) {
                    break;
                }
                FastTag[TagLength] = *(((PCHAR)&TagName)+TagLength);
            }

        } else {
            PoolStart = GetNtDebuggerDataPtrValue( MmPagedPoolStart );
            PoolEnd =
            PoolStart + GetNtDebuggerDataValue( MmSizeOfPagedPoolInBytes );
        }

        if (RestartAddr) {
            PoolStart = RestartAddr;
            if (TwoPools == TRUE) {
                if (PoolStart > PoolEnd) {
                    TwoPools = FALSE;
                    PoolStart = RestartAddr;
                    PoolEnd = ExpandedPoolEnd;
                }
            }
        }

        dprintf("\nSearching %s pool (%p : %p) for Tag: %c%c%c%c\r\n\n",
                (PoolTypeFlags == 0) ? "NonPaged" : "Paged",
                PoolStart,
                PoolEnd,
                TagName,
                TagName >> 8,
                TagName >> 16,
                TagName >> 24);

        PoolPage = PoolStart;
        HdrSize = GetTypeSize("nt!_POOL_HEADER");
        while (PoolPage < PoolEnd) {

            //
            // Optimize things by ioctl'ing over to the other side to
            // do a fast search and start with that page.
            //
            if ((PoolTypeFlags == 0) &&
                PhysicallyContiguous &&
                (TagLength > 0)) {
                SEARCHMEMORY Search;

                Search.SearchAddress = PoolPage;
                Search.SearchLength  = PoolEnd-PoolPage;
                Search.PatternLength = TagLength;
                Search.Pattern = &FastTag;
                Search.FoundAddress = 0;
                if ((Ioctl(IG_SEARCH_MEMORY, &Search, sizeof(Search))) &&
                    (Search.FoundAddress != 0)) {
                    //
                    // Got a hit, search the whole page
                    //
                    PoolPage = PAGE_ALIGN64(Search.FoundAddress);
                } else {
                    //
                    // The tag was not found at all, so we can just skip
                    // this chunk entirely.
                    //
                    PoolPage = PoolEnd;
                    goto skiprange;
                }
            }

            Pool        = PAGE_ALIGN64 (PoolPage);
            StartPage   = Pool;
            Previous    = 0;

            while (PAGE_ALIGN64(Pool) == StartPage) {

                ULONG HdrPoolTag, BlockSize, PreviousSize, AllocatorBackTraceIndex, PoolTagHash;
                ULONG PoolType;

                if ( GetFieldValue(Pool,
                                   "nt!_POOL_HEADER",
                                   "PoolTag",
                                   HdrPoolTag) ) {

                    PoolPage = GetNextResidentAddress (Pool, PoolEnd);

                    //
                    //  If we're half resident - half non-res then we'll get back
                    //  that are starting address is the next resident page. In that
                    //  case just go on to the next page
                    //

                    if (PoolPage == Pool) {
                        PoolPage = PoolPage + PageSize;
                    }

                    goto nextpage;
                }

                GetFieldValue(Pool,"nt!_POOL_HEADER","PoolTag",HdrPoolTag);
                GetFieldValue(Pool,"nt!_POOL_HEADER","PoolType", PoolType);
                GetFieldValue(Pool,"nt!_POOL_HEADER","BlockSize",BlockSize);
                GetFieldValue(Pool,"nt!_POOL_HEADER","PoolTagHash",PoolTagHash);
                GetFieldValue(Pool,"nt!_POOL_HEADER","PreviousSize",PreviousSize);
                GetFieldValue(Pool,"nt!_POOL_HEADER","AllocatorBackTraceIndex",AllocatorBackTraceIndex);

                if ((BlockSize << POOL_BLOCK_SHIFT) > POOL_PAGE_SIZE) {
                    //dprintf("Bad allocation size @%lx, too large\n", Pool);
                    break;
                }

                if (BlockSize == 0) {
                    //dprintf("Bad allocation size @%lx, zero is invalid\n", Pool);
                    break;
                }

                if (PreviousSize != Previous) {
                    //dprintf("Bad previous allocation size @%lx, last size was %lx\n",Pool, Previous);
                    break;
                }

                PoolTag = HdrPoolTag;

                Filter((PCHAR)&PoolTag,
                       (PCHAR)&TagName,
                       Flags,
                       Pool,
                       BlockSize << POOL_BLOCK_SHIFT,
                       Pool + HdrSize,
                       Context );

                Previous = BlockSize;
                Pool += (Previous << POOL_BLOCK_SHIFT);
                if ( CheckControlC() ) {
                    dprintf("\n...terminating - searched pool to %p\n",
                            PoolPage);
                    return;
                }
            }
            PoolPage = (PoolPage + PageSize);
            nextpage:
            if ( CheckControlC() ) {
                dprintf("\n...terminating - searched pool to %p\n",
                        PoolPage);
                return;
            }
            skiprange:
            if (TwoPools == TRUE) {
                if (PoolPage == PoolEnd) {
                    TwoPools = FALSE;
                    PoolStart = ExpandedPoolStart;
                    PoolEnd = ExpandedPoolEnd;
                    PoolPage = PoolStart;
                    PhysicallyContiguous = FALSE;

                    dprintf("\nSearching %s pool (%p : %p) for Tag: %c%c%c%c\n\n",
                            "NonPaged",
                            PoolStart,
                            PoolEnd,
                            TagName,
                            TagName >> 8,
                            TagName >> 16,
                            TagName >> 24);
                }
            }
        }
    } __finally {
    }

    return;
} // SearchPool



DECLARE_API( poolfind )

/*++

Routine Description:

    flags == 0 means finds a tag in nonpaged pool.
    flags == 1 means finds a tag in paged pool.
    flags == 2 means finds a tag in special pool.

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG       Flags;
    CHAR        TagNameX[4] = {' ',' ',' ',' '};
    ULONG       TagName;
    ULONG64     PoolTrackTable;

    Flags = 0;
    if (!sscanf(args,"%c%c%c%c %lx", &TagNameX[0],
           &TagNameX[1], &TagNameX[2], &TagNameX[3], &Flags)) {
        Flags = 0;
    }

    if (TagNameX[0] == '0' && TagNameX[1] == 'x') {
        if (!sscanf( args, "%lx %lx", &TagName, &Flags )) {
            TagName = 0;
        }
    } else {
        TagName = TagNameX[0] | (TagNameX[1] << 8) | (TagNameX[2] << 16) | (TagNameX[3] << 24);
    }

    PoolTrackTable = GetNtDebuggerDataPtrValue( PoolTrackTable );
    if (PoolTrackTable == 0) {
        dprintf ("unable to get PoolTrackTable - probably pool tagging disabled or wrong symbols\n");
    }


    SearchPool( TagName, Flags, 0, CheckSingleFilterAndPrint, NULL );

    return S_OK;
}


BOOLEAN
CheckSingleFilter (
                  PCHAR Tag,
                  PCHAR Filter
                  )
{
    ULONG i;
    UCHAR tc;
    UCHAR fc;

    for ( i = 0; i < 4; i++ ) {
        tc = (UCHAR) *Tag++;
        fc = (UCHAR) *Filter++;
        if ( fc == '*' ) return TRUE;
        if ( fc == '?' ) continue;
        if (i == 3 && (tc & ~(PROTECTED_POOL >> 24)) == fc) continue;
        if ( tc != fc ) return FALSE;
    }
    return TRUE;
}

ULONG64
GetSpecialPoolHeader (
                     IN PVOID     DataPage,
                     IN ULONG64   RealDataPage,
                     OUT PULONG64 ReturnedDataStart
                     )

/*++

Routine Description:

    Examine a page of data to determine if it is a special pool block.

Arguments:

    DataPage - Supplies a pointer to a page of data to examine.

    ReturnedDataStart - Supplies a pointer to return the start of the data.
                        Only valid if this routine returns non-NULL.

Return Value:

    Returns a pointer to the pool header for this special pool block or
    NULL if the block is not valid special pool.

--*/

{
    ULONG       PoolBlockSize;
    ULONG       PoolHeaderSize;
    ULONG       PoolBlockPattern;
    PUCHAR      p;
    PUCHAR      PoolDataEnd;
    PUCHAR      DataStart;
    ULONG64     PoolHeader;
    ULONG       HdrUlong1;

    PoolHeader = RealDataPage;
    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", HdrUlong1);
    //
    // Determine whether the data is at the start or end of the page.
    // Start off by assuming the data is at the end, in this case the
    // header will be at the start.
    //

    PoolBlockSize = SPECIAL_POOL_BLOCK_SIZE(HdrUlong1);

    if ((PoolBlockSize != 0) && (PoolBlockSize < PageSize - POOL_OVERHEAD)) {

        PoolHeaderSize = POOL_OVERHEAD;
        if (HdrUlong1 & MI_SPECIAL_POOL_VERIFIER) {
            PoolHeaderSize += GetTypeSize ("nt!_MI_VERIFIER_POOL_HEADER");
        }


        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockPattern);

        DataStart = (PUCHAR)DataPage + PageSize - PoolBlockSize;
        p = (PUCHAR)DataPage + PoolHeaderSize;

        for ( ; p < DataStart; p += 1) {
            if (*p != PoolBlockPattern) {
                break;
            }
        }

        if (p == DataStart || p >= (PUCHAR)DataPage + PoolHeaderSize + 0x10) {

            //
            // For this page, the data is at the end of the block.
            // The 0x10 is just to give corrupt blocks some slack.
            // All pool allocations are quadword aligned.
            //

            DataStart = (PUCHAR)DataPage + ((PageSize - PoolBlockSize) & ~(sizeof(QUAD)-1));

            *ReturnedDataStart = RealDataPage + (ULONG64) ((PUCHAR) DataStart - (PUCHAR) DataPage);
            return PoolHeader;
        }

        //
        // The data must be at the front or the block is corrupt.
        //
    }

    //
    // Try for the data at the front.  Checks are necessary as
    // the page could be corrupt on both ends.
    //

    PoolHeader = (RealDataPage + PageSize - POOL_OVERHEAD);
    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", HdrUlong1);
    PoolBlockSize = SPECIAL_POOL_BLOCK_SIZE(HdrUlong1);

    if ((PoolBlockSize != 0) && (PoolBlockSize < PageSize - POOL_OVERHEAD)) {
        PoolDataEnd = (PUCHAR)PoolHeader;

        if (HdrUlong1 & MI_SPECIAL_POOL_VERIFIER) {
            PoolDataEnd -= GetTypeSize ("nt!_MI_VERIFIER_POOL_HEADER");
        }


        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockPattern);
        DataStart = (PUCHAR)DataPage;

        p = DataStart + PoolBlockSize;
        for ( ; p < PoolDataEnd; p += 1) {
            if (*p != PoolBlockPattern) {
                break;
            }
        }
        if (p == (PUCHAR)PoolDataEnd || p > (PUCHAR)DataPage + PoolBlockSize + 0x10) {
            //
            // For this page, the data is at the front of the block.
            // The 0x10 is just to give corrupt blocks some slack.
            // All pool allocations are quadword aligned.
            //

            *ReturnedDataStart = RealDataPage + (ULONG64)( (PUCHAR)DataStart - (PUCHAR) DataPage);
            return PoolHeader;
        }
    }

    //
    // Not valid special pool.
    //

    return 0;
}



#define BYTE(u,n)  ((u & (0xff << 8*n)) >> 8*n)
#define LOCHAR_BYTE(u,n)  (tolower(BYTE(u,n)) & 0xff)
#define REVERSE_ULONGBYTES(u) (LOCHAR_BYTE(u,3) | (LOCHAR_BYTE(u,2) << 8) | (LOCHAR_BYTE(u,1) << 16) | (LOCHAR_BYTE(u,0) << 24))


PSTR
GetNextLine(
    HANDLE hFile
    )
// Returns next line in the file hFile
// Returns NULL if EOF is reached
{
    static CHAR FileLines1[MAX_PATH] = {0}, FileLines2[MAX_PATH] = {0};
    static CHAR FileLine[MAX_PATH];
    PCHAR pEOL;
    ULONG BytesRead;
    PCHAR pEndOfBuff;
    ULONG BuffLen, ReadLen;

    pEOL = NULL;
    if (!(pEOL = strchr(FileLines1, '\n'))) {
        // We have something that was already read but it isn't enough for a whole line
        // We need to read the data

        BuffLen = strlen(FileLines1);
        
        // sanity check
        if (BuffLen >= sizeof(FileLines1)) {
            return NULL;
        }

        pEndOfBuff = &FileLines1[0] + BuffLen;
        ReadLen = sizeof(FileLines1) - BuffLen;
        
        ZeroMemory(pEndOfBuff, ReadLen);
        if (ReadFile(hFile, pEndOfBuff, ReadLen - 1, &BytesRead, NULL)) {
            pEOL = strchr(FileLines1, '\n');
        }
    }

    if (pEOL) {
        FileLine[0] = 0;
        
        strncat(FileLine,FileLines1, (ULONG) (pEOL - &FileLines1[0]));
        strcpy(FileLines2, pEOL+1);
        strcpy(FileLines1, FileLines2);
        return FileLine;
    }

    return NULL;
}

EXTENSION_API ( GetPoolRegion )(
     PDEBUG_CLIENT Client,
     ULONG64 Pool,
     DEBUG_POOL_REGION *PoolData
     )
{
    INIT_API();

    *PoolData = GetPoolRegion(Pool);
    
    EXIT_API();
    return S_OK;
}

EXTENSION_API ( GetPoolData )(
     PDEBUG_CLIENT Client,
     ULONG64 Pool,
     PDEBUG_POOL_DATA PoolData
     )
{
    PCHAR Desc;
    HRESULT Hr;
    PGET_POOL_TAG_DESCRIPTION GetPoolTagDescription;

    INIT_API();

    if (!PoolInitializeGlobals()) {
        EXIT_API();
        return E_INVALIDARG;
    }

    Hr = ListPoolPage(Pool, 0x80000002, PoolData);
    
    if (Hr != S_OK) {
        EXIT_API();
        return Hr;
    }

    GetPoolTagDescription = NULL;
#ifndef  _EXTFNS_H
    if (!GetExtensionFunction("GetPoolTagDescription", (FARPROC*) &GetPoolTagDescription)) {
        EXIT_API();
        return E_INVALIDARG;
    }
    (*GetPoolTagDescription)(PoolData->PoolTag, &Desc);
    if (Desc) {
        ULONG strsize = strlen(Desc);
        if (strsize > sizeof(PoolData->PoolTagDescription)) {
            strsize = sizeof(PoolData->PoolTagDescription);
        }
        strncpy(PoolData->PoolTagDescription, Desc, strsize);
        PoolData->PoolTagDescription[strsize] = 0;
    }
#endif    
    EXIT_API();
    return Hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\ptov.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ptov.c

Abstract:

    Kernel debugger extension for dumping all physical to
    virtual translations for a given process.

Author:

    John Vert (jvert) 25-Jul-1995

Revision History:

--*/
#include "precomp.h"

BOOL
ReadPhysicalPage(
    IN ULONG64 PageNumber,
    OUT PVOID Buffer
    );

DECLARE_API( ptov )

/*++

Routine Description:

    Dumps all physical to virtual translations for a given process

Arguments:

    args - supplies physical address of PDE

Return Value:

    None.

--*/

{
    ULONG64 PdeAddress=0;
    ULONG ActualRead;
    PCHAR PageDirectory;
    PCHAR PageTable;
    ULONG i,j;
    ULONG64 VirtualPage=0;
    ULONG SizeOfHwPte;
    ULONG ValidOff, ValidSize, PfnOff, PfnSz;

    if (!sscanf(args, "%I64lx", &PdeAddress)) {
        dprintf("usage: ptov PFNOfPDE\n");
        return E_INVALIDARG;
    }

    PageDirectory = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageDirectory == NULL) {
        dprintf("Couldn't allocate %d bytes for page directory\n",PageSize);
        return E_INVALIDARG;
    }
    PageTable = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageTable == NULL) {
        dprintf("Couldn't allocate %d bytes for page table\n",PageSize);
        LocalFree(PageDirectory);
    }

    SizeOfHwPte = GetTypeSize("nt!HARDWARE_PTE");
    GetBitFieldOffset("nt!HARDWARE_PTE", "Valid", &ValidOff, &ValidSize);
    GetBitFieldOffset("nt!HARDWARE_PTE", "PageFrameNumber", &PfnOff, &PfnSz);
    __try {
        if (ReadPhysicalPage(PdeAddress,PageDirectory)) {
            for (i=0;i<PageSize/SizeOfHwPte;i++) {
                ULONG64 thisPageDir = *((PULONG64) (PageDirectory + i*SizeOfHwPte));
                
                if (CheckControlC()) {
                    return E_INVALIDARG;
                }
                if ((thisPageDir >> ValidOff) & 1) {
                    ULONG64 PageFrameNumber;

                    PageFrameNumber = GetBits(thisPageDir, PfnOff, PfnSz);

                    if (!ReadPhysicalPage(PageFrameNumber,PageTable)) {
                        break;
                    }
                    for (j=0;j<PageSize/SizeOfHwPte;j++) {
                        ULONG64 thisPageTable = *((PULONG64) (PageTable + j*SizeOfHwPte));
                        
                        if ( CheckControlC() ) {
                            return E_INVALIDARG;
                        }
                        if ((thisPageTable >> ValidOff) & 1) {
                            dprintf("%I64lx %I64lx\n",GetBits(thisPageTable, PfnOff, PfnSz)*PageSize,VirtualPage);
                        }
                        VirtualPage+=PageSize;
                    }
                } else {
                    VirtualPage += PageSize * (PageSize/SizeOfHwPte);
                }
            }
        }
    } __finally {
        LocalFree(PageDirectory);
        LocalFree(PageTable);
    }
    return S_OK;
}

ULONG
DBG_GET_PAGE_SHIFT (
    VOID
    );

BOOL
ReadPhysicalPage(
    IN ULONG64 PageNumber,
    OUT PVOID Buffer
    )
{
    ULONG i;
    ULONG64 Address;

    //
    // do the read 1k at a time to avoid overflowing the packet maximum.
    //
    Address = PageNumber << DBG_GET_PAGE_SHIFT();
    if (!IsPtr64()) {
        Address = (ULONG64) (LONG64) (LONG) Address;
    }
//    dprintf("Pg no %I64lx shft by %d, PhyAddr %I64lx\n", PageNumber, DBG_GET_PAGE_SHIFT(), Address);
    for (i=0; i<PageSize/1024; i++) {
        ULONG ActualRead = 0;
        ReadPhysical(Address, Buffer, 1024, &ActualRead);
        if (ActualRead != 1024) {
            dprintf("physical read at %p failed\n",Address);
            return(FALSE);
        }
        Address += 1024;
        Buffer = (PVOID)((PUCHAR)Buffer + 1024);
    }
    return(TRUE);
}


ULONG64
DBG_GET_MM_SESSION_SPACE_DEFAULT (
    VOID
    );


DECLARE_API( vtop )

/*++

Routine Description:

    Dumps the virtual to physical translation for a page

Arguments:

    args - supplies physical address of PDE

Return Value:

    None.

--*/

{
    ULONG ActualRead;
    ULONG i,j;
    PUCHAR PageDirectory;
    PUCHAR PageTable;
    ULONG64 PdeAddress = 0;
    ULONG64 VirtualPage=DBG_GET_MM_SESSION_SPACE_DEFAULT();
    ULONG PageShift,SizeOfHwPte;
    ULONG ValidOff, ValidSize, PfnOff, PfnSz, TransOff, TransSize;

    if (!sscanf(args,"%I64lx %I64lx", &PdeAddress,&VirtualPage)) {
        // Do not use GetExpression - physical addresses
        //        VirtualPage = GetExpression(args);
        PdeAddress = 0;
    }

    PageShift = DBG_GET_PAGE_SHIFT();
    if (PdeAddress == 0) {
        dprintf("usage: vtop PFNOfPDE VA\n");
        return E_INVALIDARG;
    }

    // Common mistake, typed in full 32 bit address, not pfn
    if( PdeAddress & ~((1 << (32-PageShift)) - 1) ) {
        PdeAddress >>= PageShift;
    }

    PageDirectory = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageDirectory == NULL) {
        dprintf("Couldn't allocate %d bytes for page directory\n",PageSize);
        return E_INVALIDARG;
    }
    PageTable = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageTable == NULL) {
        dprintf("Couldn't allocate %d bytes for page table\n",PageSize);
        LocalFree(PageDirectory);
        return E_INVALIDARG;
    }

    __try {
        if (!(SizeOfHwPte = GetTypeSize("nt!HARDWARE_PTE")) ) {
            dprintf("Cannot find HARDWARE_PTE\n");
            return E_INVALIDARG;
        }
    
        i =(ULONG) ( VirtualPage / (PageSize*(PageSize/ SizeOfHwPte)));
        j = (ULONG) ((VirtualPage % (PageSize*(PageSize/ SizeOfHwPte))) / PageSize);

        dprintf("Pdi %x Pti %x\n",i,j);
        GetBitFieldOffset("nt!_MMPTE", "u.Soft.Transition", &TransOff, &TransSize);
        GetBitFieldOffset("nt!HARDWARE_PTE", "Valid", &ValidOff, &ValidSize);
        GetBitFieldOffset("nt!HARDWARE_PTE", "PageFrameNumber", &PfnOff, &PfnSz);

        if (ReadPhysicalPage(PdeAddress,PageDirectory)) {
            ULONG64 thisPageDir = *((PULONG64) (PageDirectory + i*SizeOfHwPte));

            if (CheckControlC()) {
                return E_INVALIDARG;
            }

            if ((thisPageDir >> ValidOff) & 1) {
                ULONG64 PageFrameNumber;
                ULONG64 thisPageTable;

                PageFrameNumber = GetBits(thisPageDir, PfnOff, PfnSz);
                
                if (!ReadPhysicalPage(PageFrameNumber,PageTable)) {
                    return E_INVALIDARG;
                }

                thisPageTable = *((PULONG64) PageTable + j*SizeOfHwPte);
                if ((thisPageTable >> ValidOff) & 1) {
                    dprintf("%08I64lx %08I64lx pfn(%05I64lx)\n",
                            VirtualPage,
                            GetBits(thisPageTable, PfnOff, PfnSz)*PageSize,
                            GetBits(thisPageTable, PfnOff, PfnSz)
                            );
                }
                else {

                    if ((thisPageTable >> TransOff) & 1) {
                        dprintf("%08I64lx Transition %08I64lx (%05I64lx)\n",
                                VirtualPage,
                                GetBits(thisPageTable, PfnOff, PfnSz)*PageSize,
                                GetBits(thisPageTable, PfnOff, PfnSz)
                                );
                    }
                    else {
                        dprintf("%08I64lx Not present (%p)\n",VirtualPage,thisPageTable);
                    }
                }
            }
            else {
                dprintf("PageDirectory Entry %u not valid, try another process\n",i);
        }
    }
    } __finally {
        LocalFree(PageDirectory);
        LocalFree(PageTable);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\psr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ia64 psr

Abstract:

    KD Extension Api

Author:

    Thierry Fevrier (v-thief)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ia64.h"

//
// EmPsrFields: EM register fields for the Processor Status Register.
//

EM_REG_FIELD EmPsrFields[] = {
        { "rv",  "reserved0"   , 0x1, 0 },   // 0
        { "be",  "Big-Endian"  , 0x1, 1 },   // 1
        { "up",  "User Performance monitor enable", 0x1, 2 }, // 2
        { "ac",  "Alignment Check", 0x1, 3 }, // 3
        { "mfl", "Lower floating-point registers written", 0x1, 4 }, // 4
        { "mfh", "Upper floating-point registers written", 0x1, 5 }, // 5
        { "rv",  "reserved1",    0x7, 6 }, // 6-12
        { "ic",  "Interruption Collection", 0x1, 13 }, // 13
        { "i",   "Interrupt enable", 0x1, 14 }, // 14
        { "pk",  "Protection Key enable", 0x1, 15 }, // 15
        { "rv",  "reserved2", 0x1, 16 }, // 16
        { "dt",  "Data Address Translation enable", 0x1, 17 }, // 17
        { "dfl", "Disabled Floating-point Low  register set", 0x1, 18 }, // 18
        { "dfh", "Disabled Floating-point High register set", 0x1, 19 }, // 19
        { "sp",  "Secure Performance monitors", 0x1, 20 }, // 20
        { "pp",  "Privileged Performance monitor enable", 0x1, 21 }, // 21
        { "di",  "Disable Instruction set transition", 0x1, 22 }, // 22
        { "si",  "Secure Interval timer", 0x1, 23 }, // 23
        { "db",  "Debug Breakpoint fault enable", 0x1, 24 }, // 24
        { "lp",  "Lower Privilege transfer trap enable", 0x1, 25 }, // 25
        { "tb",  "Taken Branch trap enable", 0x1, 26 }, // 26
        { "rt",  "Register stack translation enable", 0x1, 27 }, // 27
        { "rv",  "reserved3", 0x4, 28 }, // 28-31
        { "cpl", "Current Privilege Level", 0x2, 32 }, // 32-33
        { "is",  "Instruction Set", 0x1, 34 }, // 34
        { "mc",  "Machine Abort Mask delivery disable", 0x1, 35 }, // 35
        { "it",  "Instruction address Translation enable", 0x1, 36 }, // 36
        { "id",  "Instruction Debug fault disable", 0x1, 37 }, // 37
        { "da",  "Disable Data Access and Dirty-bit faults", 0x1, 38 }, // 38
        { "dd",  "Data Debug fault disable", 0x1, 39 }, // 39
        { "ss",  "Single Step enable", 0x1, 40 }, // 40
        { "ri",  "Restart Instruction", 0x2, 41 }, // 41-42
        { "ed",  "Exception Deferral", 0x1, 43 }, // 43
        { "bn",  "register Bank", 0x1, 44 }, // 44
        { "ia",  "Disable Instruction Access-bit faults", 0x1, 45 }, // 45
        { "rv",  "reserved4", 0x12, 46 } // 46-63
};

VOID
DisplayPsrIA64( 
    IN const PCHAR         Header,
    IN       EM_PSR        EmPsr,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( EM_PSRToULong64(EmPsr), EmPsrFields, DisplayMode );
    }
    else   {
       dprintf(
            "ia bn ed ri ss dd da id it mc is cpl rt tb lp db\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x   %1I64x  %1I64x  %1I64x  %1I64x\n\t\t"
            "si di pp sp dfh dfl dt pk i ic | mfh mfl ac up be\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x   %1I64x   %1I64x  %1I64x %1I64x  %1I64x |  %1I64x   %1I64x   %1I64x  %1I64x  %1I64x\n",
            EmPsr.ia,
            EmPsr.bn,
            EmPsr.ed,
            EmPsr.ri,
            EmPsr.ss,
            EmPsr.dd,
            EmPsr.da,
            EmPsr.id,
            EmPsr.it,
            EmPsr.mc,
            EmPsr.is,
            EmPsr.cpl,
            EmPsr.rt,
            EmPsr.tb,
            EmPsr.lp,
            EmPsr.db,
            EmPsr.si,
            EmPsr.di,
            EmPsr.pp,
            EmPsr.sp,
            EmPsr.dfh,
            EmPsr.dfl,
            EmPsr.dt,
            EmPsr.pk,
            EmPsr.i,
            EmPsr.ic,
            EmPsr.mfh,
            EmPsr.mfl,
            EmPsr.ac,
            EmPsr.up,
            EmPsr.be
            );
    }
    return;
} // DisplayPsrIA64()

DECLARE_API( psr )

/*++

Routine Description:

    Dumps an IA64 Processor Status Word

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     psrValue;
    ULONG       result;
    ULONG       flags = 0;

    char       *header;

    result = sscanf(args,"%X %lx", &psrValue, &flags);
    psrValue = GetExpression(args);

	if ((result != 1) && (result != 2)) {
        //
        // If user specified "@ipsr"...
        //
        char ipsrStr[16];

        result = sscanf(args, "%s %lx", ipsrStr, &flags);
        if ( ((result != 1) && (result != 2)) || strcmp(ipsrStr,"@ipsr") )   {
            dprintf("USAGE: !psr 0xValue [display_mode:0,1,2]\n");
            dprintf("USAGE: !psr @ipsr   [display_mode:0,1,2]\n");
            return E_INVALIDARG;
        }
        psrValue = GetExpression("@ipsr");
    }
    header = (flags > DISPLAY_MIN) ? NULL : "\tpsr:\t";

    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!psr not implemented for this architecture.\n");
    }
    else
    {
        DisplayPsrIA64( header, ULong64ToEM_PSR(psrValue), flags );
    }

    return S_OK;

} // !psr

//
// EmPspFields: EM register fields for the Processor State Parameter.
//

EM_REG_FIELD EmPspFields[] = {
        { "rv",  "reserved0"   , 0x2, 0 }, 
        { "rz",  "Rendez-vous successful"  , 0x1, 2 },
        { "ra",  "Rendez-vous attempted"  , 0x1, 3 },   
        { "me",  "Distinct Multiple errors"  , 0x1, 4 },   
        { "mn",  "Min-state Save Area registered"  , 0x1, 5 },   
        { "sy",  "Storage integrity synchronized"  , 0x1, 6 },   
        { "co",  "Continuable"  , 0x1, 7 },   
        { "ci",  "Machine Check isolated"  , 0x1, 8 },   
        { "us",  "Uncontained Storage damage"  , 0x1, 9 },   
        { "hd",  "Hardware damage"  , 0x1, 10 },   
        { "tl",  "Trap lost"  , 0x1, 11 },   
        { "mi",  "More Information"  , 0x1, 12 },   
        { "pi",  "Precise Instruction pointer"  , 0x1, 13 },   
        { "pm",  "Precise Min-state Save Area"  , 0x1, 14 },   
        { "dy",  "Processor Dynamic State valid"  , 0x1, 15 },   
        { "in",  "INIT interruption"  , 0x1, 16 },   
        { "rs",  "RSE valid"  , 0x1, 17 },   
        { "cm",  "Machine Check corrected"  , 0x1, 18 },   
        { "ex",  "Machine Check expected"  , 0x1, 19 },   
        { "cr",  "Control Registers valid"  , 0x1, 20 },   
        { "pc",  "Performance Counters valid"  , 0x1, 21 },   
        { "dr",  "Debug Registers valid"  , 0x1, 22 },   
        { "tr",  "Translation Registers valid"  , 0x1, 23 },   
        { "rr",  "Region Registers valid"  , 0x1, 24 },   
        { "ar",  "Application Registers valid"  , 0x1, 25 },   
        { "br",  "Branch Registers valid"  , 0x1, 26 },   
        { "pr",  "Predicate Registers valid"  , 0x1, 27 },   
        { "fp",  "Floating-Point Registers valid"  , 0x1, 28 },   
        { "b1",  "Preserved Bank 1 General Registers valid"  , 0x1, 29 },   
        { "b0",  "Preserved Bank 0 General Registers valid"  , 0x1, 30 },   
        { "gr",  "General Registers valid"  , 0x1, 31 },   
        { "dsize",  "Processor Dynamic State size"  , 0x10, 32 },  
        { "rv",  "reserved1"  , 0xB, 48 },  
        { "cc",  "Cache Check"  , 0x1, 59 },   
        { "tc",  "TLB   Check"  , 0x1, 60 },   
        { "bc",  "Bus   Check"  , 0x1, 61 },   
        { "rc",  "Register File Check"  , 0x1, 62 },  
        { "uc",  "Micro-Architectural Check"  , 0x1, 63 }    
};

VOID
DisplayPspIA64( 
    IN const PCHAR         Header,
    IN       EM_PSP        EmPsp,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( EM_PSPToULong64(EmPsp), EmPspFields, DisplayMode );
    }
    else   {
       dprintf(
            "gr b0 b1 fp pr br ar rr tr dr pc cr ex cm rs in dy pm pi mi tl hd us ci co sy mn me ra rz\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x\n\t\t"
            "uc rc bc tc cc dsize\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x     %I64x\n",
            EmPsp.gr,
            EmPsp.b0,
            EmPsp.b1,
            EmPsp.fp,
            EmPsp.pr,
            EmPsp.br,
            EmPsp.ar,
            EmPsp.rr,
            EmPsp.tr,
            EmPsp.dr,
            EmPsp.pc,
            EmPsp.cr,
            EmPsp.ex,
            EmPsp.cm,
            EmPsp.rs,
            EmPsp.in,
            EmPsp.dy,
            EmPsp.pm,
            EmPsp.pi,
            EmPsp.mi,
            EmPsp.tl,
            EmPsp.hd,
            EmPsp.us,
            EmPsp.ci,
            EmPsp.co,
            EmPsp.sy,
            EmPsp.mn,
            EmPsp.me,
            EmPsp.ra,
            EmPsp.rz,
            EmPsp.uc,
            EmPsp.rc,
            EmPsp.bc,
            EmPsp.tc,
            EmPsp.cc,
            EmPsp.dsize
            );
    }
    return;
} // DisplayPspIA64()

DECLARE_API( psp )

/*++

Routine Description:

    Dumps an IA64 Processor State Parameter

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     pspValue;
    ULONG       result;
    ULONG       flags = 0;

    char       *header;

    INIT_API();

    pspValue = (ULONG64)0;
    flags = 0;
    if ( GetExpressionEx( args, &pspValue, &args ) )    {
        if ( args && *args )    {
            flags = (ULONG) GetExpression( args );
        }
    }

    header = (flags > DISPLAY_MIN) ? NULL : "\tpsp:\t";
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!psp not implemented for this architecture.\n");
    }
    else
    {
        DisplayPspIA64( header, ULong64ToEM_PSP(pspValue), flags );
    }

    EXIT_API();

    return S_OK;

} // !psp

#define PROCESSOR_MINSTATE_SAVE_AREA_FORMAT_IA64 \
             "\tGRNats         : 0x%I64x\n" \
             "\tGR1            : 0x%I64x\n" \
             "\tGR2            : 0x%I64x\n" \
             "\tGR3            : 0x%I64x\n" \
             "\tGR4            : 0x%I64x\n" \
             "\tGR5            : 0x%I64x\n" \
             "\tGR6            : 0x%I64x\n" \
             "\tGR7            : 0x%I64x\n" \
             "\tGR8            : 0x%I64x\n" \
             "\tGR9            : 0x%I64x\n" \
             "\tGR10           : 0x%I64x\n" \
             "\tGR11           : 0x%I64x\n" \
             "\tGR12           : 0x%I64x\n" \
             "\tGR13           : 0x%I64x\n" \
             "\tGR14           : 0x%I64x\n" \
             "\tGR15           : 0x%I64x\n" \
             "\tBank0GR16      : 0x%I64x\n" \
             "\tBank0GR17      : 0x%I64x\n" \
             "\tBank0GR18      : 0x%I64x\n" \
             "\tBank0GR19      : 0x%I64x\n" \
             "\tBank0GR20      : 0x%I64x\n" \
             "\tBank0GR21      : 0x%I64x\n" \
             "\tBank0GR22      : 0x%I64x\n" \
             "\tBank0GR23      : 0x%I64x\n" \
             "\tBank0GR24      : 0x%I64x\n" \
             "\tBank0GR25      : 0x%I64x\n" \
             "\tBank0GR26      : 0x%I64x\n" \
             "\tBank0GR27      : 0x%I64x\n" \
             "\tBank0GR28      : 0x%I64x\n" \
             "\tBank0GR29      : 0x%I64x\n" \
             "\tBank0GR30      : 0x%I64x\n" \
             "\tBank0GR31      : 0x%I64x\n" \
             "\tBank1GR16      : 0x%I64x\n" \
             "\tBank1GR17      : 0x%I64x\n" \
             "\tBank1GR18      : 0x%I64x\n" \
             "\tBank1GR19      : 0x%I64x\n" \
             "\tBank1GR20      : 0x%I64x\n" \
             "\tBank1GR21      : 0x%I64x\n" \
             "\tBank1GR22      : 0x%I64x\n" \
             "\tBank1GR23      : 0x%I64x\n" \
             "\tBank1GR24      : 0x%I64x\n" \
             "\tBank1GR25      : 0x%I64x\n" \
             "\tBank1GR26      : 0x%I64x\n" \
             "\tBank1GR27      : 0x%I64x\n" \
             "\tBank1GR28      : 0x%I64x\n" \
             "\tBank1GR29      : 0x%I64x\n" \
             "\tBank1GR30      : 0x%I64x\n" \
             "\tBank1GR31      : 0x%I64x\n" \
             "\tPreds          : 0x%I64x\n" \
             "\tBR0            : 0x%I64x\n" \
             "\tRSC            : 0x%I64x\n" \
             "\tIIP            : 0x%I64x\n" \
             "\tIPSR           : 0x%I64x\n" \
             "\tIFS            : 0x%I64x\n" \
             "\tXIP            : 0x%I64x\n" \
             "\tXPSR           : 0x%I64x\n" \
             "\tXFS            : 0x%I64x\n\n"

VOID
DisplayProcessorMinStateSaveArea(
    ULONG64 Pmssa 
    )
{
    ULONG pmssaSize;

    pmssaSize = GetTypeSize("hal!_PROCESSOR_MINSTATE_SAVE_AREA");
    dprintf("\tProcessor MinState Save Area @ 0x%I64x\n", Pmssa );
    if ( pmssaSize )    {
        CHAR cmd[MAX_PATH];
        sprintf(cmd, "dt -o -r hal!_PROCESSOR_MINSTATE_SAVE_AREA 0x%I64x", Pmssa);
        ExecCommand(cmd);
    }
    else  {
        PROCESSOR_MINSTATE_SAVE_AREA_IA64 minStateSaveArea;
        ULONG bytesRead = 0;
        pmssaSize = sizeof(minStateSaveArea);
        ReadMemory( Pmssa, &minStateSaveArea, pmssaSize, &bytesRead );
        if ( bytesRead >= pmssaSize  ) {
            dprintf( PROCESSOR_MINSTATE_SAVE_AREA_FORMAT_IA64,
                     minStateSaveArea.GRNats,  
                     minStateSaveArea.GR1,   
                     minStateSaveArea.GR2,   
                     minStateSaveArea.GR3,   
                     minStateSaveArea.GR4,   
                     minStateSaveArea.GR5,   
                     minStateSaveArea.GR6,   
                     minStateSaveArea.GR7,   
                     minStateSaveArea.GR8,   
                     minStateSaveArea.GR9,   
                     minStateSaveArea.GR10,   
                     minStateSaveArea.GR11,   
                     minStateSaveArea.GR12,   
                     minStateSaveArea.GR13,   
                     minStateSaveArea.GR14,   
                     minStateSaveArea.GR15,   
                     minStateSaveArea.Bank0GR16,
                     minStateSaveArea.Bank0GR17,
                     minStateSaveArea.Bank0GR18,
                     minStateSaveArea.Bank0GR19,
                     minStateSaveArea.Bank0GR20,
                     minStateSaveArea.Bank0GR21,
                     minStateSaveArea.Bank0GR22,
                     minStateSaveArea.Bank0GR23,
                     minStateSaveArea.Bank0GR24,
                     minStateSaveArea.Bank0GR25,
                     minStateSaveArea.Bank0GR26,
                     minStateSaveArea.Bank0GR27,
                     minStateSaveArea.Bank0GR28,
                     minStateSaveArea.Bank0GR29,
                     minStateSaveArea.Bank0GR30,
                     minStateSaveArea.Bank0GR31,
                     minStateSaveArea.Bank1GR16,
                     minStateSaveArea.Bank1GR17,
                     minStateSaveArea.Bank1GR18,
                     minStateSaveArea.Bank1GR19,
                     minStateSaveArea.Bank1GR20,
                     minStateSaveArea.Bank1GR21,
                     minStateSaveArea.Bank1GR22,
                     minStateSaveArea.Bank1GR23,
                     minStateSaveArea.Bank1GR24,
                     minStateSaveArea.Bank1GR25,
                     minStateSaveArea.Bank1GR26,
                     minStateSaveArea.Bank1GR27,
                     minStateSaveArea.Bank1GR28,
                     minStateSaveArea.Bank1GR29,
                     minStateSaveArea.Bank1GR30,
                     minStateSaveArea.Bank1GR31,
                     minStateSaveArea.Preds,
                     minStateSaveArea.BR0,
                     minStateSaveArea.RSC,
                     minStateSaveArea.IIP,
                     minStateSaveArea.IPSR,
                     minStateSaveArea.IFS,
                     minStateSaveArea.XIP,
                     minStateSaveArea.XPSR,
                     minStateSaveArea.XFS
                      );
        }
        else {
            dprintf("Reading _PROCESSOR_MINSTATE_SAVE_AREA directly from memory failed @ 0x%I64x.\n", Pmssa );
        }
    }

    return;

} // DisplayProcessorMinStateSaveArea()

DECLARE_API( pmssa )

/*++

Routine Description:

    Dumps memory address as an IA64 Processor Min-State Save Area.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     pmssaValue;
    ULONG       result;

    char       *header;

    pmssaValue = GetExpression(args);
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!pmssa not implemented for this architecture.\n");
    }
    else
    {
        if ( pmssaValue )   {
            DisplayProcessorMinStateSaveArea( pmssaValue );
        }
        else {
            dprintf("usage: pmssa <address>\n");
        }
    }

    return S_OK;

} // !pmssa

#define PROCESSOR_CONTROL_REGISTERS_FORMAT_IA64 \
    "\tDCR    : 0x%I64x\n" \
    "\tITM    : 0x%I64x\n" \
    "\tIVA    : 0x%I64x\n" \
    "\tCR3    : 0x%I64x\n" \
    "\tCR4    : 0x%I64x\n" \
    "\tCR5    : 0x%I64x\n" \
    "\tCR6    : 0x%I64x\n" \
    "\tCR7    : 0x%I64x\n" \
    "\tPTA    : 0x%I64x\n" \
    "\tGPTA   : 0x%I64x\n" \
    "\tCR10   : 0x%I64x\n" \
    "\tCR11   : 0x%I64x\n" \
    "\tCR12   : 0x%I64x\n" \
    "\tCR13   : 0x%I64x\n" \
    "\tCR14   : 0x%I64x\n" \
    "\tCR15   : 0x%I64x\n" \
    "\tIPSR   : 0x%I64x\n" \
    "\tISR    : 0x%I64x\n" \
    "\tCR18   : 0x%I64x\n" \
    "\tIIP    : 0x%I64x\n" \
    "\tIFA    : 0x%I64x\n" \
    "\tITIR   : 0x%I64x\n" \
    "\tIFS    : 0x%I64x\n" \
    "\tIIM    : 0x%I64x\n" \
    "\tIHA    : 0x%I64x\n" \
    "\tCR26   : 0x%I64x\n" \
    "\tCR27   : 0x%I64x\n" \
    "\tCR28   : 0x%I64x\n" \
    "\tCR29   : 0x%I64x\n" \
    "\tCR30   : 0x%I64x\n" \
    "\tCR31   : 0x%I64x\n" \
    "\tCR32   : 0x%I64x\n" \
    "\tCR33   : 0x%I64x\n" \
    "\tCR34   : 0x%I64x\n" \
    "\tCR35   : 0x%I64x\n" \
    "\tCR36   : 0x%I64x\n" \
    "\tCR37   : 0x%I64x\n" \
    "\tCR38   : 0x%I64x\n" \
    "\tCR39   : 0x%I64x\n" \
    "\tCR40   : 0x%I64x\n" \
    "\tCR41   : 0x%I64x\n" \
    "\tCR42   : 0x%I64x\n" \
    "\tCR43   : 0x%I64x\n" \
    "\tCR44   : 0x%I64x\n" \
    "\tCR45   : 0x%I64x\n" \
    "\tCR46   : 0x%I64x\n" \
    "\tCR47   : 0x%I64x\n" \
    "\tCR48   : 0x%I64x\n" \
    "\tCR49   : 0x%I64x\n" \
    "\tCR50   : 0x%I64x\n" \
    "\tCR51   : 0x%I64x\n" \
    "\tCR52   : 0x%I64x\n" \
    "\tCR53   : 0x%I64x\n" \
    "\tCR54   : 0x%I64x\n" \
    "\tCR55   : 0x%I64x\n" \
    "\tCR56   : 0x%I64x\n" \
    "\tCR57   : 0x%I64x\n" \
    "\tCR58   : 0x%I64x\n" \
    "\tCR59   : 0x%I64x\n" \
    "\tCR60   : 0x%I64x\n" \
    "\tCR61   : 0x%I64x\n" \
    "\tCR62   : 0x%I64x\n" \
    "\tCR63   : 0x%I64x\n" \
    "\tLID    : 0x%I64x\n" \
    "\tIVR    : 0x%I64x\n" \
    "\tTPR    : 0x%I64x\n" \
    "\tEOI    : 0x%I64x\n" \
    "\tIRR0   : 0x%I64x\n" \
    "\tIRR1   : 0x%I64x\n" \
    "\tIRR2   : 0x%I64x\n" \
    "\tIRR3   : 0x%I64x\n" \
    "\tITV    : 0x%I64x\n" \
    "\tPMV    : 0x%I64x\n" \
    "\tCMCV   : 0x%I64x\n" \
    "\tCR75   : 0x%I64x\n" \
    "\tCR76   : 0x%I64x\n" \
    "\tCR77   : 0x%I64x\n" \
    "\tCR78   : 0x%I64x\n" \
    "\tCR79   : 0x%I64x\n" \
    "\tLRR0   : 0x%I64x\n" \
    "\tLRR1   : 0x%I64x\n" \
    "\tCR82   : 0x%I64x\n" \
    "\tCR83   : 0x%I64x\n" \
    "\tCR84   : 0x%I64x\n" \
    "\tCR85   : 0x%I64x\n" \
    "\tCR86   : 0x%I64x\n" \
    "\tCR87   : 0x%I64x\n" \
    "\tCR88   : 0x%I64x\n" \
    "\tCR89   : 0x%I64x\n" \
    "\tCR90   : 0x%I64x\n" \
    "\tCR91   : 0x%I64x\n" \
    "\tCR92   : 0x%I64x\n" \
    "\tCR93   : 0x%I64x\n" \
    "\tCR94   : 0x%I64x\n" \
    "\tCR95   : 0x%I64x\n" \
    "\tCR96   : 0x%I64x\n" \
    "\tCR97   : 0x%I64x\n" \
    "\tCR98   : 0x%I64x\n" \
    "\tCR99   : 0x%I64x\n" \
    "\tCR100  : 0x%I64x\n" \
    "\tCR101  : 0x%I64x\n" \
    "\tCR102  : 0x%I64x\n" \
    "\tCR103  : 0x%I64x\n" \
    "\tCR104  : 0x%I64x\n" \
    "\tCR105  : 0x%I64x\n" \
    "\tCR106  : 0x%I64x\n" \
    "\tCR107  : 0x%I64x\n" \
    "\tCR108  : 0x%I64x\n" \
    "\tCR109  : 0x%I64x\n" \
    "\tCR110  : 0x%I64x\n" \
    "\tCR111  : 0x%I64x\n" \
    "\tCR112  : 0x%I64x\n" \
    "\tCR113  : 0x%I64x\n" \
    "\tCR114  : 0x%I64x\n" \
    "\tCR115  : 0x%I64x\n" \
    "\tCR116  : 0x%I64x\n" \
    "\tCR117  : 0x%I64x\n" \
    "\tCR118  : 0x%I64x\n" \
    "\tCR119  : 0x%I64x\n" \
    "\tCR120  : 0x%I64x\n" \
    "\tCR121  : 0x%I64x\n" \
    "\tCR122  : 0x%I64x\n" \
    "\tCR123  : 0x%I64x\n" \
    "\tCR124  : 0x%I64x\n" \
    "\tCR125  : 0x%I64x\n" \
    "\tCR126  : 0x%I64x\n" \
    "\tCR127  : 0x%I64x\n" 

VOID
DisplayProcessorControlRegisters(
    ULONG64 Pcrs 
    )
{
    ULONG pcrsSize;

    pcrsSize = GetTypeSize("hal!_PROCESSOR_CONTROL_REGISTERS");
    dprintf("\tProcessor Control Registers File @ 0x%I64x\n", Pcrs );
    if ( pcrsSize )    {
        CHAR cmd[MAX_PATH];
        sprintf(cmd, "dt -o -r hal!_PROCESSOR_CONTROL_REGISTERS 0x%I64x", Pcrs);
        ExecCommand(cmd);
    }
    else  {
        PROCESSOR_CONTROL_REGISTERS_IA64 controlRegisters;
        ULONG bytesRead = 0;
        pcrsSize = sizeof(controlRegisters);
        ReadMemory( Pcrs, &controlRegisters, pcrsSize, &bytesRead );
        if ( bytesRead >= pcrsSize  ) {
            dprintf( PROCESSOR_CONTROL_REGISTERS_FORMAT_IA64,
                    controlRegisters.DCR,
                    controlRegisters.ITM,
                    controlRegisters.IVA,
                    controlRegisters.CR3,
                    controlRegisters.CR4,
                    controlRegisters.CR5,
                    controlRegisters.CR6,
                    controlRegisters.CR7,
                    controlRegisters.PTA,
                    controlRegisters.GPTA,
                    controlRegisters.CR10,
                    controlRegisters.CR11,
                    controlRegisters.CR12,
                    controlRegisters.CR13,
                    controlRegisters.CR14,
                    controlRegisters.CR15,
                    controlRegisters.IPSR,
                    controlRegisters.ISR,
                    controlRegisters.CR18,
                    controlRegisters.IIP,
                    controlRegisters.IFA,
                    controlRegisters.ITIR,
                    controlRegisters.IFS,
                    controlRegisters.IIM,
                    controlRegisters.IHA,
                    controlRegisters.CR26,
                    controlRegisters.CR27,
                    controlRegisters.CR28,
                    controlRegisters.CR29,
                    controlRegisters.CR30,
                    controlRegisters.CR31,
                    controlRegisters.CR32,
                    controlRegisters.CR33,
                    controlRegisters.CR34,
                    controlRegisters.CR35,
                    controlRegisters.CR36,
                    controlRegisters.CR37,
                    controlRegisters.CR38,
                    controlRegisters.CR39,
                    controlRegisters.CR40,
                    controlRegisters.CR41,
                    controlRegisters.CR42,
                    controlRegisters.CR43,
                    controlRegisters.CR44,
                    controlRegisters.CR45,
                    controlRegisters.CR46,
                    controlRegisters.CR47,
                    controlRegisters.CR48,
                    controlRegisters.CR49,
                    controlRegisters.CR50,
                    controlRegisters.CR51,
                    controlRegisters.CR52,
                    controlRegisters.CR53,
                    controlRegisters.CR54,
                    controlRegisters.CR55,
                    controlRegisters.CR56,
                    controlRegisters.CR57,
                    controlRegisters.CR58,
                    controlRegisters.CR59,
                    controlRegisters.CR60,
                    controlRegisters.CR61,
                    controlRegisters.CR62,
                    controlRegisters.CR63,
                    controlRegisters.LID,
                    controlRegisters.IVR,
                    controlRegisters.TPR,
                    controlRegisters.EOI,
                    controlRegisters.IRR0,
                    controlRegisters.IRR1,
                    controlRegisters.IRR2,
                    controlRegisters.IRR3,
                    controlRegisters.ITV,
                    controlRegisters.PMV,
                    controlRegisters.CMCV,
                    controlRegisters.CR75,
                    controlRegisters.CR76,
                    controlRegisters.CR77,
                    controlRegisters.CR78,
                    controlRegisters.CR79,
                    controlRegisters.LRR0,
                    controlRegisters.LRR1,
                    controlRegisters.CR82,
                    controlRegisters.CR83,
                    controlRegisters.CR84,
                    controlRegisters.CR85,
                    controlRegisters.CR86,
                    controlRegisters.CR87,
                    controlRegisters.CR88,
                    controlRegisters.CR89,
                    controlRegisters.CR90,
                    controlRegisters.CR91,
                    controlRegisters.CR92,
                    controlRegisters.CR93,
                    controlRegisters.CR94,
                    controlRegisters.CR95,
                    controlRegisters.CR96,
                    controlRegisters.CR97,
                    controlRegisters.CR98,
                    controlRegisters.CR99,
                    controlRegisters.CR100,
                    controlRegisters.CR101,
                    controlRegisters.CR102,
                    controlRegisters.CR103,
                    controlRegisters.CR104,
                    controlRegisters.CR105,
                    controlRegisters.CR106,
                    controlRegisters.CR107,
                    controlRegisters.CR108,
                    controlRegisters.CR109,
                    controlRegisters.CR110,
                    controlRegisters.CR111,
                    controlRegisters.CR112,
                    controlRegisters.CR113,
                    controlRegisters.CR114,
                    controlRegisters.CR115,
                    controlRegisters.CR116,
                    controlRegisters.CR117,
                    controlRegisters.CR118,
                    controlRegisters.CR119,
                    controlRegisters.CR120,
                    controlRegisters.CR121,
                    controlRegisters.CR122,
                    controlRegisters.CR123,
                    controlRegisters.CR124,
                    controlRegisters.CR125,
                    controlRegisters.CR126,
                    controlRegisters.CR127
                      );
        }
        else {
            dprintf("Reading _PROCESSOR_CONTROL_REGISTERS directly from memory failed @ 0x%I64x.\n", Pcrs );
        }
    }

    return;

} // DisplayProcessorControlRegisters()

DECLARE_API( pcrs )

/*++

Routine Description:

    Dumps memory address as an IA64 Processor Control Registers file.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     pcrsValue;
    ULONG       result;

    char       *header;

    pcrsValue = GetExpression(args);
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!pcrs not implemented for this architecture.\n");
    }
    else
    {
        if ( pcrsValue )   {
            DisplayProcessorControlRegisters( pcrsValue );
        }
        else {
            dprintf("usage: pcrs <address>\n");
        }
    }

    return S_OK;

} // !pcrs

#define PROCESSOR_APPLICATION_REGISTERS_FORMAT_IA64 \
    "\tKR0       : 0x%I64x\n" \
    "\tKR1       : 0x%I64x\n" \
    "\tKR2       : 0x%I64x\n" \
    "\tKR3       : 0x%I64x\n" \
    "\tKR4       : 0x%I64x\n" \
    "\tKR5       : 0x%I64x\n" \
    "\tKR6       : 0x%I64x\n" \
    "\tKR7       : 0x%I64x\n" \
    "\tAR8       : 0x%I64x\n" \
    "\tAR9       : 0x%I64x\n" \
    "\tAR10      : 0x%I64x\n" \
    "\tAR11      : 0x%I64x\n" \
    "\tAR12      : 0x%I64x\n" \
    "\tAR13      : 0x%I64x\n" \
    "\tAR14      : 0x%I64x\n" \
    "\tAR15      : 0x%I64x\n" \
    "\tRSC       : 0x%I64x\n" \
    "\tBSP       : 0x%I64x\n" \
    "\tBSPSTORE  : 0x%I64x\n" \
    "\tRNAT      : 0x%I64x\n" \
    "\tAR20      : 0x%I64x\n" \
    "\tFCR       : 0x%I64x\n" \
    "\tAR22      : 0x%I64x\n" \
    "\tAR23      : 0x%I64x\n" \
    "\tEFLAG     : 0x%I64x\n" \
    "\tCSD       : 0x%I64x\n" \
    "\tSSD       : 0x%I64x\n" \
    "\tCFLG      : 0x%I64x\n" \
    "\tFSR       : 0x%I64x\n" \
    "\tFIR       : 0x%I64x\n" \
    "\tFDR       : 0x%I64x\n" \
    "\tAR31      : 0x%I64x\n" \
    "\tCCV       : 0x%I64x\n" \
    "\tAR33      : 0x%I64x\n" \
    "\tAR34      : 0x%I64x\n" \
    "\tAR35      : 0x%I64x\n" \
    "\tUNAT      : 0x%I64x\n" \
    "\tAR37      : 0x%I64x\n" \
    "\tAR38      : 0x%I64x\n" \
    "\tAR39      : 0x%I64x\n" \
    "\tFPSR      : 0x%I64x\n" \
    "\tAR41      : 0x%I64x\n" \
    "\tAR42      : 0x%I64x\n" \
    "\tAR43      : 0x%I64x\n" \
    "\tITC       : 0x%I64x\n" \
    "\tAR45      : 0x%I64x\n" \
    "\tAR46      : 0x%I64x\n" \
    "\tAR47      : 0x%I64x\n" \
    "\tAR48      : 0x%I64x\n" \
    "\tAR49      : 0x%I64x\n" \
    "\tAR50      : 0x%I64x\n" \
    "\tAR51      : 0x%I64x\n" \
    "\tAR52      : 0x%I64x\n" \
    "\tAR53      : 0x%I64x\n" \
    "\tAR54      : 0x%I64x\n" \
    "\tAR55      : 0x%I64x\n" \
    "\tAR56      : 0x%I64x\n" \
    "\tAR57      : 0x%I64x\n" \
    "\tAR58      : 0x%I64x\n" \
    "\tAR59      : 0x%I64x\n" \
    "\tAR60      : 0x%I64x\n" \
    "\tAR61      : 0x%I64x\n" \
    "\tAR62      : 0x%I64x\n" \
    "\tAR63      : 0x%I64x\n" \
    "\tPFS       : 0x%I64x\n" \
    "\tLC        : 0x%I64x\n" \
    "\tEC        : 0x%I64x\n" \
    "\tAR67      : 0x%I64x\n" \
    "\tAR68      : 0x%I64x\n" \
    "\tAR69      : 0x%I64x\n" \
    "\tAR70      : 0x%I64x\n" \
    "\tAR71      : 0x%I64x\n" \
    "\tAR72      : 0x%I64x\n" \
    "\tAR73      : 0x%I64x\n" \
    "\tAR74      : 0x%I64x\n" \
    "\tAR75      : 0x%I64x\n" \
    "\tAR76      : 0x%I64x\n" \
    "\tAR77      : 0x%I64x\n" \
    "\tAR78      : 0x%I64x\n" \
    "\tAR79      : 0x%I64x\n" \
    "\tAR80      : 0x%I64x\n" \
    "\tAR81      : 0x%I64x\n" \
    "\tAR82      : 0x%I64x\n" \
    "\tAR83      : 0x%I64x\n" \
    "\tAR84      : 0x%I64x\n" \
    "\tAR85      : 0x%I64x\n" \
    "\tAR86      : 0x%I64x\n" \
    "\tAR87      : 0x%I64x\n" \
    "\tAR88      : 0x%I64x\n" \
    "\tAR89      : 0x%I64x\n" \
    "\tAR90      : 0x%I64x\n" \
    "\tAR91      : 0x%I64x\n" \
    "\tAR92      : 0x%I64x\n" \
    "\tAR93      : 0x%I64x\n" \
    "\tAR94      : 0x%I64x\n" \
    "\tAR95      : 0x%I64x\n" \
    "\tAR96      : 0x%I64x\n" \
    "\tAR97      : 0x%I64x\n" \
    "\tAR98      : 0x%I64x\n" \
    "\tAR99      : 0x%I64x\n" \
    "\tAR100     : 0x%I64x\n" \
    "\tAR101     : 0x%I64x\n" \
    "\tAR102     : 0x%I64x\n" \
    "\tAR103     : 0x%I64x\n" \
    "\tAR104     : 0x%I64x\n" \
    "\tAR105     : 0x%I64x\n" \
    "\tAR106     : 0x%I64x\n" \
    "\tAR107     : 0x%I64x\n" \
    "\tAR108     : 0x%I64x\n" \
    "\tAR109     : 0x%I64x\n" \
    "\tAR110     : 0x%I64x\n" \
    "\tAR111     : 0x%I64x\n" \
    "\tAR112     : 0x%I64x\n" \
    "\tAR113     : 0x%I64x\n" \
    "\tAR114     : 0x%I64x\n" \
    "\tAR115     : 0x%I64x\n" \
    "\tAR116     : 0x%I64x\n" \
    "\tAR117     : 0x%I64x\n" \
    "\tAR118     : 0x%I64x\n" \
    "\tAR119     : 0x%I64x\n" \
    "\tAR120     : 0x%I64x\n" \
    "\tAR121     : 0x%I64x\n" \
    "\tAR122     : 0x%I64x\n" \
    "\tAR123     : 0x%I64x\n" \
    "\tAR124     : 0x%I64x\n" \
    "\tAR125     : 0x%I64x\n" \
    "\tAR126     : 0x%I64x\n" \
    "\tAR127     : 0x%I64x\n" 

VOID
DisplayProcessorApplicationRegisters(
    ULONG64 Pars 
    )
{
    ULONG parsSize;

    parsSize = GetTypeSize("hal!_PROCESSOR_APPLICATION_REGISTERS");
    dprintf("\tProcessor Application Registers File @ 0x%I64x\n", Pars );
    if ( parsSize )    {
        CHAR cmd[MAX_PATH];
        sprintf(cmd, "dt -o -r hal!_PROCESSOR_APPLICATION_REGISTERS 0x%I64x", Pars);
        ExecCommand(cmd);
    }
    else  {
        PROCESSOR_APPLICATION_REGISTERS_IA64 applicationRegisters;
        ULONG bytesRead = 0;
        parsSize = sizeof(applicationRegisters);
        ReadMemory( Pars, &applicationRegisters, parsSize, &bytesRead );
        if ( bytesRead >= parsSize  ) {
            dprintf( PROCESSOR_APPLICATION_REGISTERS_FORMAT_IA64,
                     applicationRegisters.KR0,
                     applicationRegisters.KR1,
                     applicationRegisters.KR2,
                     applicationRegisters.KR3,
                     applicationRegisters.KR4,
                     applicationRegisters.KR5,
                     applicationRegisters.KR6,
                     applicationRegisters.KR7,
                     applicationRegisters.AR8,
                     applicationRegisters.AR9,
                     applicationRegisters.AR10,
                     applicationRegisters.AR11,
                     applicationRegisters.AR12,
                     applicationRegisters.AR13,
                     applicationRegisters.AR14,
                     applicationRegisters.AR15,
                     applicationRegisters.RSC,
                     applicationRegisters.BSP,
                     applicationRegisters.BSPSTORE,
                     applicationRegisters.RNAT,
                     applicationRegisters.AR20,
                     applicationRegisters.FCR,
                     applicationRegisters.AR22,
                     applicationRegisters.AR23,
                     applicationRegisters.EFLAG,
                     applicationRegisters.CSD,
                     applicationRegisters.SSD,
                     applicationRegisters.CFLG,
                     applicationRegisters.FSR,
                     applicationRegisters.FIR,
                     applicationRegisters.FDR,
                     applicationRegisters.AR31,
                     applicationRegisters.CCV,
                     applicationRegisters.AR33,
                     applicationRegisters.AR34,
                     applicationRegisters.AR35,
                     applicationRegisters.UNAT,
                     applicationRegisters.AR37,
                     applicationRegisters.AR38,
                     applicationRegisters.AR39,
                     applicationRegisters.FPSR,
                     applicationRegisters.AR41,
                     applicationRegisters.AR42,
                     applicationRegisters.AR43,
                     applicationRegisters.ITC,
                     applicationRegisters.AR45,
                     applicationRegisters.AR46,
                     applicationRegisters.AR47,
                     applicationRegisters.AR48,
                     applicationRegisters.AR49,
                     applicationRegisters.AR50,
                     applicationRegisters.AR51,
                     applicationRegisters.AR52,
                     applicationRegisters.AR53,
                     applicationRegisters.AR54,
                     applicationRegisters.AR55,
                     applicationRegisters.AR56,
                     applicationRegisters.AR57,
                     applicationRegisters.AR58,
                     applicationRegisters.AR59,
                     applicationRegisters.AR60,
                     applicationRegisters.AR61,
                     applicationRegisters.AR62,
                     applicationRegisters.AR63,
                     applicationRegisters.PFS,
                     applicationRegisters.LC,
                     applicationRegisters.EC,
                     applicationRegisters.AR67,
                     applicationRegisters.AR68,
                     applicationRegisters.AR69,
                     applicationRegisters.AR70,
                     applicationRegisters.AR71,
                     applicationRegisters.AR72,
                     applicationRegisters.AR73,
                     applicationRegisters.AR74,
                     applicationRegisters.AR75,
                     applicationRegisters.AR76,
                     applicationRegisters.AR77,
                     applicationRegisters.AR78,
                     applicationRegisters.AR79,
                     applicationRegisters.AR80,
                     applicationRegisters.AR81,
                     applicationRegisters.AR82,
                     applicationRegisters.AR83,
                     applicationRegisters.AR84,
                     applicationRegisters.AR85,
                     applicationRegisters.AR86,
                     applicationRegisters.AR87,
                     applicationRegisters.AR88,
                     applicationRegisters.AR89,
                     applicationRegisters.AR90,
                     applicationRegisters.AR91,
                     applicationRegisters.AR92,
                     applicationRegisters.AR93,
                     applicationRegisters.AR94,
                     applicationRegisters.AR95,
                     applicationRegisters.AR96,
                     applicationRegisters.AR97,
                     applicationRegisters.AR98,
                     applicationRegisters.AR99,
                     applicationRegisters.AR100,
                     applicationRegisters.AR101,
                     applicationRegisters.AR102,
                     applicationRegisters.AR103,
                     applicationRegisters.AR104,
                     applicationRegisters.AR105,
                     applicationRegisters.AR106,
                     applicationRegisters.AR107,
                     applicationRegisters.AR108,
                     applicationRegisters.AR109,
                     applicationRegisters.AR110,
                     applicationRegisters.AR111,
                     applicationRegisters.AR112,
                     applicationRegisters.AR113,
                     applicationRegisters.AR114,
                     applicationRegisters.AR115,
                     applicationRegisters.AR116,
                     applicationRegisters.AR117,
                     applicationRegisters.AR118,
                     applicationRegisters.AR119,
                     applicationRegisters.AR120,
                     applicationRegisters.AR121,
                     applicationRegisters.AR122,
                     applicationRegisters.AR123,
                     applicationRegisters.AR124,
                     applicationRegisters.AR125,
                     applicationRegisters.AR126,
                     applicationRegisters.AR127
                      );
        }
        else {
            dprintf("Reading _PROCESSOR_APPLICATION_REGISTERS directly from memory failed @ 0x%I64x.\n", Pars );
        }
    }

    return;

} // DisplayProcessorApplicationRegisters()

DECLARE_API( pars )

/*++

Routine Description:

    Dumps memory address as an IA64 Processor Control Registers file.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     parsValue;
    ULONG       result;

    char       *header;

    parsValue = GetExpression(args);
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!pars not implemented for this architecture.\n");
    }
    else
    {
        if ( parsValue )   {
            DisplayProcessorApplicationRegisters( parsValue );
        }
        else {
            dprintf("usage: pars <address>\n");
        }
    }

    return S_OK;

} // !pars
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\pte.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pte.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (LouP) 15-Feb-1992

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#include "ia64.h"
#include "amd64.h"

ULONG64 MmNonPagedPoolEnd=0;
ULONG64 MmSubsectionBase=0;

ULONG64 KiIA64VaSignedFill;
ULONG64 KiIA64PtaBase;
ULONG64 KiIA64PtaSign;

ULONG
DbgGetPageFileHigh(
    ULONG64 Pte
    );

////////////////////////////////////////////////////////////////////////////////
//
// I386
//
////////////////////////////////////////////////////////////////////////////////

#define PaeGetPdeAddressX86(va)   ((ULONG64) (LONG64) (LONG) (PDE_BASE_X86 + ((((ULONG)(va)) >> 21) << 3)))

#define MiGetPdeAddressX86(va)  ((ULONG64) (LONG64) (LONG) (((((ULONG)(va)) >> 22) << 2) + PDE_BASE_X86))

#define PaeGetVirtualAddressMappedByPteX86(PTE) (((ULONG64)(PTE) << 9))

#define PaeGetPteAddressX86(va)   ((ULONG64)(PTE_BASE_X86 + ((((ULONG)(va)) >> 12) << 3)))

#define MiGetPteAddressX86(va)  (((((ULONG) (va)) >> 12) << 2) + PTE_BASE_X86)

#define MiGetPteOffsetX86(va)   ((((ULONG) (va)) >> 12) & 0x3ff)

#define MiGetVirtualAddressMappedByPteX86(PTE) ((ULONG64) (LONG64) (LONG) ((PTE) << 10))


////////////////////////////////////////////////////////////////////////////////
//
// AMD64
//
////////////////////////////////////////////////////////////////////////////////

#define AMD64_VA_MASK     (((ULONG64)1 << AMD64_VA_BITS) - 1)

#define MiGetPteAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PTI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PTE_BASE_AMD64))

#define MiGetPdeAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PDI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PDE_BASE_AMD64))

#define MiGetPpeAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PPI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PPE_BASE_AMD64))

#define MiGetPxeAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PXI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PXE_BASE_AMD64))

#define MiGetPteOffsetAMD64(va)   ((((ULONG_PTR) (va)) >> 12) & 0x3ff)

#define MiGetVirtualAddressMappedByPteAMD64(PTE) \
    ((ULONG64)((LONG64)(((LONG64)(PTE) - PTE_BASE_AMD64) << (PAGE_SHIFT_AMD64 + AMD64_VA_SHIFT - PTE_SHIFT_AMD64)) >> AMD64_VA_SHIFT))





////////////////////////////////////////////////////////////////////////////////
//
// IA64
//
////////////////////////////////////////////////////////////////////////////////
//
// MiGetPdeAddress returns the address of the PTE which maps the
// given virtual address.  Note we must redefine some of the MM
// macros here because they cast values to pointers which does not work
// on systems where pointers are only 32 bits.
//

VOID
DbgGetPteBaseIA64(
    VOID
    )
{
    ULONG64 PtaValue;
    ULONG i;

    if (KiIA64PtaBase != 0) {

        return;

    }

    if (g_ExtData == NULL ||
        g_ExtData->lpVtbl->
        ReadProcessorSystemData(g_ExtData, 0,
                                DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET,
                                &PtaValue, sizeof(PtaValue), NULL) != S_OK) {
        PtaValue = (ULONG64) GetExpression("@pta");
    }

    KiIA64PtaBase = PtaValue & ~0xffffUI64;
    
    KiIA64VaSignedFill = 
        (KiIA64PtaBase << (PAGE_SHIFT_IA64 - PTE_SHIFT_IA64)) & ~VRN_MASK_IA64;

    KiIA64PtaSign = KiIA64PtaBase;

    for (i = 0; i < 64; i += 1) {

        KiIA64PtaSign >>= 1;

        if (KiIA64PtaSign & 1) {
            KiIA64PtaSign = (ULONG64)1 << i;
            break;
        }
    }
}

ULONG64
MiGetPteAddressIA64 (
    IN ULONG64 Va
    )
{

    DbgGetPteBaseIA64();

    if (((((ULONG64)(Va)) & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    return (ULONG64) (((((ULONG64)(Va)) & VRN_MASK_IA64)) |
             ((((((ULONG64)(Va)) >> PTI_SHIFT_IA64) << PTE_SHIFT_IA64) & (~(PTE_BASE_IA64|VRN_MASK_IA64))) + PTE_BASE_IA64));
}

ULONG64
MiGetPdeAddressIA64 (
    IN ULONG64 Va
    )
{
    DbgGetPteBaseIA64();

    if (((((ULONG64)(Va)) & PDE_BASE_IA64) == PDE_BASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_BASE_IA64)) < ((ULONG64)1 << PDI_SHIFT_IA64))) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    if (((((ULONG64)(Va)) & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    return (ULONG64) (((((ULONG64)(Va)) & VRN_MASK_IA64)) |
             ((((((ULONG64)(Va)) >> PDI_SHIFT_IA64) << PTE_SHIFT_IA64) & (~(PDE_BASE_IA64|VRN_MASK_IA64))) + PDE_BASE_IA64));
}

ULONG64
MiGetPpeAddressIA64 (
    IN ULONG64 Va
    )
{
    DbgGetPteBaseIA64();

    if ((((ULONG64)(Va) & PTE_BASE_IA64) == PTE_BASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PTE_BASE_IA64)) < ((ULONG64)1 << PDI1_SHIFT_IA64))) {

        return (ULONG64) (((ULONG64)Va & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    if (((((ULONG64)(Va)) & PDE_BASE_IA64) == PDE_BASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_BASE_IA64)) < ((ULONG64)1 << PDI_SHIFT_IA64))) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    if (((((ULONG64)(Va)) & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    return (ULONG64) (((((ULONG64)(Va)) & VRN_MASK_IA64)) |
              ((((((ULONG64)(Va)) >> PDI1_SHIFT_IA64) << PTE_SHIFT_IA64) &
                (~(PDE_TBASE_IA64|VRN_MASK_IA64))) + PDE_TBASE_IA64));
}

ULONG64
MiGetVirtualAddressMappedByPteIA64(
    IN ULONG64 PTE
    ) 
{
    DbgGetPteBaseIA64();

    return (((ULONG64)(PTE) & PTA_SIGN_IA64) ?
            (ULONG64)(((ULONG64)(PTE) & VRN_MASK_IA64) | VA_FILL_IA64 | 
                      (((ULONG64)(PTE)-PTE_BASE_IA64) << (PAGE_SHIFT_IA64 - PTE_SHIFT_IA64))) : 
            (ULONG64)(((ULONG64)(PTE) & VRN_MASK_IA64) | (((ULONG64)(PTE)-PTE_BASE_IA64) << (PAGE_SHIFT_IA64 - PTE_SHIFT_IA64))));

}

#define MiGetSubsectionAddress(lpte)                              \
    (((lpte)->u.Subsect.WhichPool == 1) ?                              \
     ((ULONG64)((ULONG64)MmSubsectionBase +    \
                    ((ULONG64)(lpte)->u.Subsect.SubsectionAddress))) \
     : \
     ((ULONG64)((ULONG64)MM_NONPAGED_POOL_END -    \
                    ((ULONG64)(lpte)->u.Subsect.SubsectionAddress))))

#define MiPteToProto(lpte) \
            ((ULONG64) ((ULONG64)((lpte)->u.Proto.ProtoAddress) + MmProtopte_Base))


////////////////////////////////////////////////////////////////////////////////
//
// AMD64
//
////////////////////////////////////////////////////////////////////////////////

VOID
DbgPrintProtection (
    ULONG Protection
    )
{
    if (Protection == 0) {
        dprintf("0");
        return;
    }

    dprintf ("%x - ", Protection);

    if (Protection == MM_NOACCESS) {
        dprintf("No Access");
    } else if (Protection == MM_DECOMMIT) {
        dprintf("Decommitted");
    } else {
        switch (Protection & 7) {
        case MM_READONLY: dprintf("Readonly"); break;
        case MM_EXECUTE: dprintf("Execute"); break;
        case MM_EXECUTE_READ: dprintf("ExecuteRead"); break;
        case MM_READWRITE: dprintf("ReadWrite"); break;
        case MM_WRITECOPY: dprintf("ReadWriteCopy"); break;
        case MM_EXECUTE_READWRITE: dprintf("ReadWriteExecute"); break;
        case MM_EXECUTE_WRITECOPY: dprintf("ReadWriteCopyExecute "); break;
        default: ;    
        }
        if (Protection & MM_NOCACHE) {
            dprintf(" UC");
        }
        if (Protection & MM_GUARD_PAGE) {
            dprintf(" G");
        }
    }
}

ULONG64
DbgPteLookupNeeded (
    VOID
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            return MI_PTE_LOOKUP_NEEDED_X86;

        case IMAGE_FILE_MACHINE_AMD64:
            return MI_PTE_LOOKUP_NEEDED_AMD64;
            break;

        case IMAGE_FILE_MACHINE_IA64:
            return MI_PTE_LOOKUP_NEEDED_IA64;

        default:
            break;
    }

    return 0;
}

LOGICAL
DbgPteIsDemandZero (
    ULONG64 CurrentPte
    )
{
    ULONG Protection = 0;
    ULONG64 CurrentPteContents = 0;
    
    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);
    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Soft.Protection", Protection);

    //
    // The caller has already ensured that the valid, prototype & transition
    // bits in the PTE are all zero.
    //

    if (DbgGetPageFileHigh (CurrentPte) != 0) {
        return FALSE;
    }

    if ((Protection != 0) &&
        (Protection != MM_NOACCESS) &&
        (Protection != MM_DECOMMIT)) {

        return TRUE;
    }

    return FALSE;
}

#define PMMPTEx ULONG64

#define PACKET_MAX_SIZE 4000

typedef struct _SYS_PTE_LIST {
    ULONG64 Next;
    ULONG64 Previous;
    ULONG64 Value;
    ULONG Count;
} SYS_PTE_LIST, *PSYS_PTE_LIST;

ULONG MmKseg2Frame;

ULONG
MiGetSysPteListDelimiter (
    VOID
    )

/*++

Routine Description:

    The platform-specific system PTE list delimiter is returned.

Arguments:

    None.

--*/

{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if (PaeEnabled) {
                return 0xFFFFFFFF;
            }
            return 0xFFFFF;

        case IMAGE_FILE_MACHINE_AMD64:
            return 0xFFFFFFFF;

        case IMAGE_FILE_MACHINE_IA64:
            return 0xFFFFFFFF;

        default:
            break;
    }

    return 0;
}


ULONG64
MiGetFreeCountFromPteList (
    IN ULONG64 Pte
    )

/*++

Routine Description:

    The specified PTE points to a free list header in the
    system PTE pool. It returns the number of free entries
    in this block.

Arguments:

    Pte - the PTE to examine.

--*/

{
    ULONG OneEntry;
    ULONG64 NextEntry;


    GetFieldValue(Pte, "MMPTE", "u.List.OneEntry", OneEntry);
    GetFieldValue(Pte + GetTypeSize("nt!_MMPTE"), "MMPTE", "u.List.NextEntry",NextEntry);
    
    return (( OneEntry) ?
                1 :
                NextEntry);
}

DECLARE_API( sysptes )

/*++

Routine Description:

     Dumps system PTEs.

Arguments:

    args - Flags

Return Value:

    None

--*/

{
    ULONG   ExtraPtesUnleashed;
    ULONG   MaxPteRead;
    ULONG   TotalNumberOfSystemPtes;
    ULONG64 NonPagedSystemStart;
    ULONG64 ExtraResourceStart;
    ULONG64 ExtraPteStart;
    ULONG   NumberOfExtraPtes;
    ULONG   PteListDelimiter;
    ULONG   result;
    ULONG64 nextfreepte;
    ULONG   Flags;
    ULONG   LastCount;
    ULONG   ReadCount;
    ULONG64 next;
    ULONG64 Pte;
    ULONG64 IndexBase;
    ULONG64 PteBase;
    ULONG64 PteBase2;
    ULONG64 PteArrayReal;
    ULONG64 PteArray2Real;
    PCHAR   PteArray2;
    ULONG64 PteEnd;
    ULONG64 IndexBias;
    ULONG64 FreeStart;
    ULONG   NumberOfSystemPtes;
    ULONG   NumberOfPtesToCover;
    PCHAR   PteArray;
    HANDLE  PteHandle;
    ULONG64 PageCount;
    ULONG64 free;
    ULONG64 totalFree;
    ULONG64 largeFree;
    ULONG   i;
    ULONG64 Flink;
    ULONG64 PteHeaderAddress;
    ULONG   FreeSysPteListBySize[MM_SYS_PTE_TABLES_MAX];
    ULONG   SysPteIndex [MM_SYS_PTE_TABLES_MAX];
    ULONG   PteSize;
    PVOID   PteData;
    PSYS_PTE_LIST List;
    CHAR Buffer[256];
    ULONG64 displacement;

    INIT_API();

    List = NULL;
    PteData = NULL;
    PteArray = NULL;
    PteHandle = (HANDLE)0;

    Flags = 0;
    sscanf(args,"%lx",&Flags);

    if (Flags & 8) {

        //
        // Dump the nonpaged pool expansion free PTE list only.
        //

        IndexBias    = GetPointerValue ("nt!MmSystemPteBase");
    
        PteSize = GetTypeSize ("nt!_MMPTE");

        i           = 0;
        totalFree   = 0;
        largeFree   = 0;
    
        PteData = LocalAlloc (LMEM_FIXED, PteSize * 2);
        if (!PteData) {
            dprintf("Unable to malloc PTE data\n");
            EXIT_API();
            return E_INVALIDARG;
        }
    
        FreeStart = GetExpression ("nt!MmFirstFreeSystemPte") + PteSize;
    
        if ( !ReadMemory( FreeStart,
                          PteData,
                          PteSize,
                          &result) ) {
            dprintf("%08p: Unable to get MmFirstFreeSystemPte\n",FreeStart);
            LocalFree(PteData);
            EXIT_API();
            return E_INVALIDARG;
        }
    
        GetFieldValue(FreeStart, "nt!_MMPTE", "u.List.NextEntry", FreeStart);
        next        = FreeStart;

        PteListDelimiter = MiGetSysPteListDelimiter ();
    
        while (next != PteListDelimiter) {
    
            if ( CheckControlC() ) {
                goto Bail;
            }

            nextfreepte = IndexBias + next * PteSize;

            if ( !ReadMemory( nextfreepte,
                              PteData,
                              PteSize * 2,
                              &result) ) {
                dprintf("%16I64X: Unable to get nonpaged PTE\n", nextfreepte);
                break;
            }

            free = MiGetFreeCountFromPteList (nextfreepte);
    
            if (Flags & 1) {
                dprintf("      free ptes: %8p   number free: %5I64ld.\n",
                        nextfreepte,
                        free);
            }

            if (free > largeFree) {
                largeFree = free;
            }

            totalFree += free;
            i += 1;
    
            GetFieldValue(nextfreepte, "nt!_MMPTE", "u.List.NextEntry", next);
            // next = MiGetNextFromPteList ((PMMPTE)PteData);
        }
        dprintf("\n  free blocks: %ld   total free: %I64ld    largest free block: %I64ld\n\n",
                i, totalFree, largeFree);
    
        LocalFree(PteData);
        EXIT_API();
        return E_INVALIDARG;
    }

    if (Flags & 4) {

        PteHeaderAddress = GetExpression( "nt!MiPteHeader" );
    
        if ( GetFieldValue( PteHeaderAddress,
                            "nt!_SYSPTES_HEADER",
                            "Count",
                            NumberOfSystemPtes) ) {
                dprintf("%08p: Unable to get System PTE lock consumer information\n",
                    PteHeaderAddress);
        }
        else {
            dprintf("\n0x%I64x System PTEs allocated to mapping locked pages\n\n",
                NumberOfSystemPtes);

            dprintf("VA       MDL     PageCount  Caller/CallersCaller\n");

            //
            // Dump the MDL and PTE addresses and 2 callers.
            //
            GetFieldValue( PteHeaderAddress,"SYSPTES_HEADER","ListHead.Flink", Flink);

            for (PageCount = 0; PageCount < NumberOfSystemPtes; ) {
                ULONG64 Count;

                if (Flink == PteHeaderAddress) {
                    dprintf("early finish (%I64u) during syspte tracker dumping\n",
                        PageCount);
                    break;
                }

                if ( CheckControlC() ) {
                    break;
                }

                if ( GetFieldValue( Flink,
                                    "nt!_PTE_TRACKER",
                                    "Count",
                                    Count) ) {
                        dprintf("%08p: Unable to get System PTE individual lock consumer information\n",
                            Flink);
                        break;
                }

                InitTypeRead(Flink, nt!_PTE_TRACKER);
                dprintf("%8p %8p %8I64lx ",
                    ReadField(SystemVa),
                    ReadField(Mdl),
                    Count);

                Buffer[0] = '!';
                Flink = ReadField(ListEntry.Flink);
                GetSymbol (ReadField(CallingAddress),
                           (PCHAR)Buffer,
                           &displacement);
        
                dprintf("%s", Buffer);
                if (displacement) {
                    dprintf( "+0x%1p", displacement );
                }
                dprintf("/");

                Buffer[0] = '!';
                GetSymbol (ReadField(CallersCaller),
                           (PCHAR)Buffer,
                           &displacement);
        
                dprintf("%s", Buffer);
                if (displacement) {
                    dprintf( "+0x%1p", displacement );
                }
        
                dprintf("\n");

                PageCount += Count;
            }
        }
    
        if ((Flags & ~4) == 0) {

            //
            // no other flags specified, so just return.
            //

            EXIT_API();
            return E_INVALIDARG;
        }
    }

    dprintf("\nSystem PTE Information\n");

    PteBase      = GetPointerValue ("nt!MmSystemPtesStart");
    PteEnd       = GetPointerValue ("nt!MmSystemPtesEnd");
    IndexBias    = GetPointerValue ("nt!MmSystemPteBase");
    NumberOfSystemPtes   = GetUlongValue ("nt!MmNumberOfSystemPtes");
    NonPagedSystemStart = GetPointerValue ("nt!MmNonPagedSystemStart");

    PteSize = GetTypeSize ("nt!_MMPTE");

    NumberOfExtraPtes = 0;
    NumberOfPtesToCover = (ULONG) ((PteEnd - PteBase + 1) / PteSize);

    //
    // The system PTEs may exist in 2 separate virtual address ranges.
    //
    // See if there are extra resources, if so then see if they are being
    // used for system PTEs (as opposed to system cache, etc).
    //

    ExtraPtesUnleashed = 0;
    ExtraPtesUnleashed = GetUlongValue ("MiAddPtesCount");

    if (ExtraPtesUnleashed != 0) {
        ExtraResourceStart = GetExpression ("nt!MiExtraResourceStart"); 

        if (ExtraResourceStart != 0) {

            NumberOfExtraPtes = GetUlongValue ("MiExtraPtes1");

            if (NumberOfExtraPtes != 0) {

                if (!ReadPointer(ExtraResourceStart,&ExtraPteStart)) {
                    dprintf("%016I64X: Unable to read PTE start %p\n",ExtraResourceStart);
                    goto Bail;
                }
            }
        }
    }

    TotalNumberOfSystemPtes = (ULONG) (NumberOfSystemPtes + NumberOfExtraPtes);

    dprintf("  Total System Ptes %ld\n", TotalNumberOfSystemPtes);

    free = GetExpression( "nt!MmSysPteIndex" );

    if ( !ReadMemory( free,
                      &SysPteIndex[0],
                      sizeof(ULONG) * MM_SYS_PTE_TABLES_MAX,
                      &result) ) {
        dprintf("%08p: Unable to get PTE index\n",free);
        goto Bail;
    }

    free = GetExpression( "nt!MmSysPteListBySizeCount" );

    if ( !ReadMemory( free,
                      &FreeSysPteListBySize[0],
                      sizeof (FreeSysPteListBySize),
                      &result) ) {
        dprintf("%08p: Unable to get free PTE index\n",free);
        goto Bail;
    }

    for (i = 0; i < MM_SYS_PTE_TABLES_MAX; i += 1 ) {
        dprintf("     SysPtes list of size %ld has %ld free\n",
            SysPteIndex[i],
            FreeSysPteListBySize[i]);
    }

    dprintf(" \n");

    dprintf("    starting PTE: %016I64X\n", PteBase);
    dprintf("    ending PTE:   %016I64X\n", PteEnd);

    PteHandle = LocalAlloc(LMEM_MOVEABLE, NumberOfPtesToCover * PteSize);

    if (!PteHandle) {
        dprintf("Unable to get allocate memory of %ld bytes\n",
                NumberOfPtesToCover * PteSize);
        goto Bail;
    }

    MaxPteRead = ((PACKET_MAX_SIZE/PteSize)-1);

    PteArray = LocalLock(PteHandle);

    PteArrayReal = PteBase; 

    //
    // If the ranges are discontiguous, zero the piece(s) in the middle.
    //

    if (NumberOfExtraPtes != 0) {
        RtlZeroMemory (PteArray, NumberOfPtesToCover * PteSize);
    }

    for (PageCount = 0; PageCount < NumberOfExtraPtes; PageCount += ReadCount) {

        if ( CheckControlC() ) {
            goto Bail;
        }

        dprintf("loading (%d%% complete)\r", (PageCount * 100)/ TotalNumberOfSystemPtes);

        ReadCount = (ULONG) (NumberOfExtraPtes - PageCount > MaxPteRead ?
                             MaxPteRead :
                               NumberOfExtraPtes - PageCount + 1);

        Pte = (PteBase + PageCount * PteSize);

        if ( !ReadMemory( Pte,
                          (PCHAR)PteArray + PageCount * PteSize,
                          ReadCount * PteSize,
                          &result) ) {
            dprintf("Unable to get system pte block - "
                    "address %p - count %lu - page %lu\n",
                    Pte, ReadCount, PageCount);
            goto Bail;
        }
    }
    LastCount = (ULONG) PageCount;

    if (NumberOfSystemPtes != 0) {

        if (NumberOfExtraPtes != 0) {
            PteBase2 = DbgGetPteAddress (NonPagedSystemStart);
        }
        else {
            PteBase2 = PteBase;
        }

        PteArray2 = (PteArray + (ULONG) (PteBase2 - PteBase));
        PteArray2Real = PteBase2;
        for (PageCount = 0; (PageCount < NumberOfSystemPtes); PageCount += ReadCount) {
    
            if ( CheckControlC() ) {
                goto Bail;
            }
    
            dprintf("loading (%d%% complete)\r", ((LastCount + PageCount) * 100)/ TotalNumberOfSystemPtes);
            ReadCount = (ULONG) (NumberOfSystemPtes - PageCount > MaxPteRead ?
                                 MaxPteRead :
                                  NumberOfSystemPtes - PageCount + 1);
    
            Pte = (PteBase2 + PageCount * PteSize);
    
            if ( !ReadMemory( Pte,
                              PteArray2 + PageCount * PteSize,
                              ReadCount * PteSize,
                              &result) ) {
                dprintf("Unable to get system pte block2 - "
                        "address %p - count %lu - page %lu\n",
                        Pte, ReadCount, PageCount);
                goto Bail;
            }
        }
    }

    dprintf("\n");

    //
    // Now we have a local copy: let's take a look.
    //

    //
    // Walk the free list.
    //

    IndexBase = (PteBase - IndexBias) / PteSize;

    totalFree   = 0;
    i           = 0;
    largeFree   = 0;

    FreeStart = GetExpression ("nt!MmFirstFreeSystemPte");

    if ( GetFieldValue( FreeStart, "nt!_MMPTE", "u.List.NextEntry", next) ) {
        dprintf("%08p: Unable to get MmFirstFreeSystemPte\n",FreeStart);
        goto Bail;
    }

    FreeStart = next;

    PteListDelimiter = MiGetSysPteListDelimiter ();

    while (next != PteListDelimiter) {

        if ( CheckControlC() ) {
            goto Bail;
        }

        free = MiGetFreeCountFromPteList ((PteArrayReal + (next - IndexBase)* PteSize));

        if (Flags & 1) {
            dprintf("      free ptes: %8p   number free: %5I64ld.\n",
                    PteBase + (next - IndexBase) * PteSize,
                    free);
        }
        if (free > largeFree) {
            largeFree = free;
        }
        totalFree += free;
        i += 1;

        GetFieldValue ((PteArrayReal + (next - IndexBase) * PteSize),
                       "nt!_MMPTE", "u.List.NextEntry", next);
    }
    dprintf("\n  free blocks: %ld   total free: %I64ld    largest free block: %I64ld\n\n",
                i, totalFree, largeFree);

#if 0

    //
    // Walk through the array and sum up the usage on a per physical
    // page basis.
    //

    List = VirtualAlloc (NULL,
                         (ULONG) NumberOfPtes * sizeof(SYS_PTE_LIST),
                         MEM_COMMIT | MEM_RESERVE,
                         PAGE_READWRITE);
    if (List == NULL) {
        dprintf("alloc failed %lx\n",GetLastError());
        goto Bail;
    }
    RtlZeroMemory (List, (ULONG) NumberOfPtes * sizeof(SYS_PTE_LIST));
    
    GetBitFieldOffset("nt!_MMPTE", "u.Hard.PageFrameNumber", &PfnOff, &PfnSz);

    free             = 0;
    next             = 0;
    List[0].Value    = (ULONG64) -1;
    List[0].Previous = 0xffffff;
    first            = 0;

    for (i = 0; i < NumberOfPtes ; i += 1) {
        ULONG64 lPte = *((PULONG64) (PteArray + i * PteSize));

        Page =0;
        if ((lPte >> ValidOff) & 1) {
            Page =  GetBits(lPte, PfnOff, PfnSz); // DbgGetFrameNumber (PteArray + i * PteSize);
        }
        if (!(i%100)) dprintf("%c\r",rot[(i/100) % 4]);
        if (Page != 0) {
            // dprintf("Adding PTE @ %p, Pfn %p\n", PteArrayReal + i*PteSize, Page);
            next = first;
            while (Page > List[next].Value) {
                next = List[next].Next;
            }
            if (List[next].Value == Page) {
                List[next].Count += 1;
            } else {
                free += 1;
                List[free].Next = next;
                List[free].Value = Page;
                List[free].Count = 1;
                List[free].Previous = List[next].Previous;
                if (next == first) {
                    first = free;
                } else {
                    List[List[next].Previous].Next = free;
                }
                List[next].Previous = free;
            }
        }

        if ( CheckControlC() ) {
            goto Bail;
        }
    }

    next = first;
    dprintf ("     Page    Count\n");
    while (List[next].Value != (ULONG64) -1) {
        if ((Flags & 2) || (List[next].Count > 1)) {
            dprintf (" %8p    %5ld.\n", List[next].Value, List[next].Count);
        }
        next = List[next].Next;
        if ( CheckControlC() ) {
            goto Bail;
        }    
    }
#endif

Bail:

    if (PteArray) {
        LocalUnlock(PteArray);
        if (PteHandle) {
            LocalFree((void *)PteHandle);
        }
    }
    if (List) {
        VirtualFree (List, 0, MEM_RELEASE);
    }

    EXIT_API();
    return S_OK;
}


ULONG64
DbgGetFrameNumber(
    ULONG64 Pte
    ) 
{
    ULONG   Valid=0;
    ULONG   Prototype=0;
    ULONG   Transition=0;
    ULONG64 PageFrameNumber=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Valid", Valid);
    if (Valid) {
        GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.PageFrameNumber", PageFrameNumber);
    }
    else {
        GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.Prototype", Prototype);
        if (Prototype == 0) {
            GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.Transition", Transition);
            if (Transition == 1) {
                GetFieldValue(Pte, "_MMPTE", "u.Trans.PageFrameNumber", PageFrameNumber);
            }
            else {
                // Must be pagefile or demand zero.
                GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.PageFileHigh", PageFrameNumber);
            }
        }
    }

    return PageFrameNumber;
}


ULONG
DbgGetOwner(
    ULONG64 Pte
    ) 
{
    ULONG Owner=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Owner", Owner);

    return Owner;
}


ULONG
DbgGetValid(
    ULONG64 Pte
    ) 
{
    ULONG Valid=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Valid", Valid);

    return Valid;
}

ULONG
DbgGetDirty(
    ULONG64 Pte
    ) 
{
    ULONG Dirty=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Dirty", Dirty);

    return Dirty;
}


ULONG
DbgGetAccessed(
    ULONG64 Pte
    ) 
{
    ULONG Accessed=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Accessed", Accessed);

    return Accessed;
}


ULONG
DbgGetWrite(
    ULONG64 Pte
    ) 
{
    ULONG Write=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Write", Write);

    return Write;
}


ULONG
DbgGetExecute(
    ULONG64 Pte
    ) 
{
    ULONG Execute=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Execute", Execute);

    return Execute;
}


ULONG
DbgGetCopyOnWrite(
    ULONG64 Pte
    ) 
{
    ULONG CopyOnWrite=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.CopyOnWrite", CopyOnWrite);

    return CopyOnWrite;
}


ULONG
DbgGetPageFileHigh(
    ULONG64 Pte
    )
{
    ULONG64 PageFileHigh=0;
    
    GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.PageFileHigh", PageFileHigh);
    return (ULONG) PageFileHigh;
}

ULONG
DbgGetPageFileLow(
    ULONG64 Pte
    )
{
    ULONG PageFileLow=0;
    
    GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.PageFileLow", PageFileLow);
    return PageFileLow;
}

ULONG64
DbgPteToProto(
    ULONG64 lpte
    )
{
    ULONG64 PteLong=0;
    ULONG64 ProtoAddress=0;
                
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        GetFieldValue(lpte, "nt!_MMPTE", "u.Proto.ProtoAddress",ProtoAddress);
        return ProtoAddress;
    }

    if (PaeEnabled) {
        GetFieldValue(lpte, "nt!_MMPTE", "u.Proto.ProtoAddress",ProtoAddress);
        return ProtoAddress;
    }

    GetFieldValue(lpte, "nt!_MMPTE", "u.Long", PteLong);

    ProtoAddress = (((ULONG)PteLong >> 11) << 9) + (((ULONG)PteLong << 24) >> 23) + 0xE1000000;

    return ProtoAddress;
}

ULONG64
DbgGetSubsectionAddress(
    IN ULONG64 Pte
    )
{
    ULONG64 PteLong=0;
    ULONG64 MmSubsectionBase;
    ULONG64 SubsectionAddress=0;

    if (PaeEnabled && 
        (TargetMachine == IMAGE_FILE_MACHINE_I386)) {
        ULONG64 SubsectionAddress=0;

        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.SubsectionAddress", SubsectionAddress);
        return SubsectionAddress;
    }

    MmSubsectionBase = GetNtDebuggerDataPtrValue(MmSubsectionBase);
    GetFieldValue(Pte, "nt!_MMPTE", "u.Long", PteLong);

    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{

        if (!MmNonPagedPoolEnd) {
            MmNonPagedPoolEnd = GetNtDebuggerDataValue(MmNonPagedPoolEnd);
        }

        SubsectionAddress = 
            ((PteLong & 0x80000000) ? 
             (((ULONG) MmSubsectionBase + (((PteLong & 0x7ffff800) >> 4) |
                                   ((PteLong<<2) & 0x78)))) 
             : 
            (((ULONG) MmNonPagedPoolEnd - ((((PteLong)>>11)<<7) | 
                                   ((PteLong<<2) & 0x78)))));

        SubsectionAddress = (ULONG64) (LONG64) (LONG) SubsectionAddress;
        break;
    }
    case IMAGE_FILE_MACHINE_AMD64: {

        LONG64 SignedSubsectionAddress;

        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.SubsectionAddress", SignedSubsectionAddress);

        SubsectionAddress = (ULONG64) SignedSubsectionAddress;
        break;
                                   }
    case IMAGE_FILE_MACHINE_IA64: {
        ULONG64 WhichPool=0, SubsectionAddress2=0;

        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.SubsectionAddress", SubsectionAddress2);
        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.WhichPool", WhichPool);

        if (!MmNonPagedPoolEnd) {
            MmNonPagedPoolEnd = GetNtDebuggerDataValue(MmNonPagedPoolEnd);
        }

        SubsectionAddress =
            ((WhichPool == 1) ? 
             ((MmSubsectionBase + (SubsectionAddress2))) 
             : 
            ((MmNonPagedPoolEnd -
                    (SubsectionAddress2))));
        
        break;
    }
    default:
        return FALSE;
    } /* switch */
    return SubsectionAddress;
}

ULONG64
DbgGetPdeAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if (PaeEnabled) {
                return PaeGetPdeAddressX86 (VirtualAddress);
            }
            return MiGetPdeAddressX86(VirtualAddress);

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetPdeAddressAMD64(VirtualAddress);

        case IMAGE_FILE_MACHINE_IA64:
            return MiGetPdeAddressIA64(VirtualAddress);

        default:
            break;
    }
    return 0;
}

ULONG64
DbgGetPpeAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetPpeAddressAMD64(VirtualAddress);

        case IMAGE_FILE_MACHINE_IA64:
            return MiGetPpeAddressIA64(VirtualAddress);

        default:
            break;
    }

    return 0;
}

ULONG64
DbgGetPxeAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetPxeAddressAMD64(VirtualAddress);

        default:
            break;
    }

    return 0;
}

ULONG64
DbgGetVirtualAddressMappedByPte(
    IN ULONG64 Pte
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if (PaeEnabled) {
                return PaeGetVirtualAddressMappedByPteX86(Pte);
            }
            return MiGetVirtualAddressMappedByPteX86 (Pte);

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetVirtualAddressMappedByPteAMD64 (Pte);

        case IMAGE_FILE_MACHINE_IA64:
            return MiGetVirtualAddressMappedByPteIA64 (Pte);

        default:
            break;
    }

    return 0;
}


ULONG64
DbgGetPteAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        if (PaeEnabled) {
            return PaeGetPteAddressX86 (VirtualAddress);
        }
        return MiGetPteAddressX86(VirtualAddress);
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return MiGetPteAddressAMD64(VirtualAddress);
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MiGetPteAddressIA64(VirtualAddress);
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

BOOL
Mi_Is_Physical_Address (
    ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_IA64: {
        return MI_IS_PHYSICAL_ADDRESS_IA64(VirtualAddress);
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG
DBG_GET_PAGE_SHIFT (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return PAGE_SHIFT_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return PAGE_SHIFT_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return PAGE_SHIFT_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG64
DBG_GET_MM_SESSION_SPACE_DEFAULT (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_SESSION_SPACE_DEFAULT_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return MM_SESSION_SPACE_DEFAULT_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_SESSION_SPACE_DEFAULT_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG
GET_MM_PTE_VALID_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_VALID_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return MM_PTE_VALID_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_VALID_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_LARGE_PAGE_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_LARGE_PAGE_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_LARGE_PAGE_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_LARGE_PAGE_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_TRANSITION_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_TRANSITION_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_TRANSITION_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_TRANSITION_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_PROTOTYPE_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_PROTOTYPE_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_PROTOTYPE_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_PROTOTYPE_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_PROTECTION_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_PROTECTION_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_PROTECTION_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_PROTECTION_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG
GET_MM_PTE_PAGEFILE_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_PAGEFILE_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_PAGEFILE_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_PAGEFILE_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG64
GET_PTE_TOP (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return PTE_TOP_X86;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return PDE_TOP_IA64;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return PTE_TOP_AMD64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG64
GET_PDE_TOP (
    VOID
    )
{
    return GET_PTE_TOP();
}


ULONG64
GET_PTE_BASE (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return PTE_BASE_X86;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return PTE_BASE_IA64;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return PTE_BASE_AMD64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GetAddressState(
    IN ULONG64 VirtualAddress
    )

{
    ULONG64 Address;
    ULONG   result;
    ULONG64 Pte;
    ULONG64 Pde;
    ULONG   PdeContents;
    ULONG   PteContents;

    if (Mi_Is_Physical_Address (VirtualAddress)) {
        return ADDRESS_VALID;
    }
    Address = VirtualAddress;

    Pde = DbgGetPdeAddress (VirtualAddress);
    Pte = DbgGetPteAddress (VirtualAddress);

    if ( !ReadMemory( Pde,
                      &PdeContents,
                      sizeof(ULONG),
                      &result) ) {
        dprintf("%08p: Unable to get PDE\n",Pde);
        return ADDRESS_NOT_VALID;
    }

    if (PdeContents & GET_MM_PTE_VALID_MASK()) {
        if (PdeContents & GET_MM_PTE_LARGE_PAGE_MASK()) {
            return ADDRESS_VALID;
        }
        if ( !ReadMemory( Pte,
                          &PteContents,
                          sizeof(ULONG),
                          &result) ) {
            dprintf("%08p: Unable to get PTE\n",Pte);
            return ADDRESS_NOT_VALID;
        }
        if (PteContents & GET_MM_PTE_VALID_MASK()) {
            return ADDRESS_VALID;
        }
        if (PteContents & GET_MM_PTE_TRANSITION_MASK()) {
            if (!(PteContents & GET_MM_PTE_PROTOTYPE_MASK())) {
                return ADDRESS_TRANSITION;
            }
        }
    }
    return ADDRESS_NOT_VALID;
}

VOID
DbgDisplayInvalidPte (
    ULONG64 CurrentPte,
    ULONG64 flags,
    PCHAR Indent
    )
{
    ULONG Transition = 0;
    ULONG Protection = 0;
    ULONG PrototypeBit = 0;
    ULONG64  CurrentPteContents;
    ULONG   PteSize;

    PteSize = GetTypeSize ("nt!_MMPTE");

    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);
    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Soft.Prototype", PrototypeBit);

    dprintf("not valid\n", Indent);
    GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Soft.Protection", Protection);
    GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Soft.Transition", Transition);

    if (PrototypeBit) {
        if (DbgGetPageFileHigh (CurrentPte) == DbgPteLookupNeeded ()) {
            dprintf("%s Proto: VAD\n", Indent);
            dprintf("%s Protect: ", Indent);
            DbgPrintProtection (Protection);
        }
        else if (flags) {
            if (PteSize == 4) {
                dprintf("%s Subsection: %08I64X\n",
                    Indent,
                    DbgGetSubsectionAddress (CurrentPte));
            }
            else {
                dprintf("%s Subsection: %016I64X\n",
                    Indent,
                    DbgGetSubsectionAddress (CurrentPte));
            }
            dprintf("%s Protect: ", Indent);
            DbgPrintProtection (Protection);
        }
        else {
            if (PteSize == 4) {
                dprintf("%s Proto: %08I64X\n",
                    Indent,
                    DbgPteToProto (CurrentPte));
            }
            else {
                dprintf("%s Proto: %016I64X\n",
                    Indent,
                    DbgPteToProto (CurrentPte));
            }
        }
    } else if (Transition) {
        dprintf("%s Transition: %x\n",
                    Indent,
                    (ULONG) DbgGetFrameNumber (CurrentPte));
        dprintf("%s Protect: ", Indent);
        DbgPrintProtection (Protection);

    } else if (CurrentPteContents != 0) {

        if (DbgPteIsDemandZero (CurrentPte)) {
            dprintf("%s DemandZero\n", Indent);
        }
        else {
            dprintf("%s PageFile: %2lx\n",
                    Indent,
                    DbgGetPageFileLow (CurrentPte));
            dprintf("%s Offset: %lx\n", Indent, DbgGetPageFileHigh (CurrentPte));
        }
        dprintf("%s Protect: ", Indent);
        DbgPrintProtection (Protection);
    }
    dprintf ("\n");
}

VOID
DbgDisplayValidPte (
    ULONG64 Pte
    )
{
    ULONG64 Pte_Long;

    if (Pte == 0) {
        return;
    }

    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
        case IMAGE_FILE_MACHINE_AMD64:

            GetFieldValue(Pte, "nt!_MMPTE", "u.Long", Pte_Long);
            dprintf("pfn %x %c%c%c%c%c%c%c%c%cV",
                        (ULONG) DbgGetFrameNumber(Pte),
                        DbgGetCopyOnWrite(Pte) ? 'C' : '-',
                        Pte_Long & 0x100 ? 'G' : '-',
                        Pte_Long & 0x80 ? 'L' : '-',
                        DbgGetDirty(Pte) ? 'D' : '-',
                        DbgGetAccessed(Pte) ? 'A' : '-',
                        Pte_Long & 0x10 ? 'N' : '-',
                        Pte_Long & 0x8 ? 'T' : '-',
                        DbgGetOwner(Pte) ? 'U' : 'K',
                        Pte_Long & 0x2 ? 'W' : 'R');
            break;

        case IMAGE_FILE_MACHINE_IA64:

            dprintf("pfn %x %c%c%c%c%c%cV",
                        (ULONG) DbgGetFrameNumber(Pte),
                        DbgGetExecute(Pte) ? 'E' : '-',
                        DbgGetCopyOnWrite(Pte) ? 'C' : '-',
                        DbgGetDirty(Pte) ? 'D' : '-',
                        DbgGetAccessed(Pte) ? 'A' : '-',
                        DbgGetOwner(Pte) ? 'U' : 'K',
                        DbgGetWrite(Pte) ? 'W' : 'R');

            break;

        default:
            break;
    }
}

LOGICAL
DbgAddressSelfMapped (
    ULONG64 Address
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if ((Address >= GET_PTE_BASE()) && (Address < GET_PTE_TOP())) {
                return TRUE;
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:

            if (((Address & PTE_BASE_IA64) == PTE_BASE_IA64) &&
                ((Address & ~(VRN_MASK_IA64|PTE_BASE_IA64)) < ((ULONG64)1 << PDI1_SHIFT_IA64))) {
                return TRUE;
            }
            else if (((Address & PDE_BASE_IA64) == PDE_BASE_IA64) &&
                ((Address & ~(VRN_MASK_IA64|PDE_BASE_IA64)) < ((ULONG64)1 << PDI_SHIFT_IA64))) {
                return TRUE;
            }
            else if (((Address & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
                ((Address & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {
                return TRUE;
            }

            break;

        case IMAGE_FILE_MACHINE_AMD64:
            if ((Address >= PTE_BASE_AMD64) && (Address <= PTE_TOP_AMD64)) {
                return TRUE;
            }
            break;

        default:
            break;
    }

    return FALSE;
}

VOID
DumpPte (
    ULONG64 Address,
    ULONG64 flags
    )
{
    PCHAR Indent;
    ULONG   Levels;
    ULONG64 Pte;
    ULONG64 Pde;
    ULONG64 Ppe;
    ULONG64 Pxe;
    ULONG64 CurrentPte;
    ULONG64 CurrentPteContents;
    ULONG   ValidBit;
    ULONG64 Pde_Long=0;
    ULONG64 Pte_Long=0;
    ULONG64 Ppe_Long=0;
    ULONG64 Pxe_Long=0;
    ULONG   PteSize;

    PteSize = GetTypeSize ("nt!_MMPTE");

    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            Levels = 2;
            break;

        case IMAGE_FILE_MACHINE_IA64:
            Levels = 3;
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            Levels = 4;
            break;

        default:
            dprintf("Not implemented for this platform\n");
            return;
            break;
    }

    if (DbgAddressSelfMapped (Address)) {

        if (!flags) {

            //
            // The address is the address of a PTE, rather than
            // a virtual address.  Don't get the corresponding
            // PTE contents, use this address as the PTE.
            //

            Address = DbgGetVirtualAddressMappedByPte (Address);
        }
    }

    if (!flags) {
        Pxe = DbgGetPxeAddress (Address);
        Ppe = DbgGetPpeAddress (Address);
        Pde = DbgGetPdeAddress (Address);
        Pte = DbgGetPteAddress (Address);
    } else {
        Pxe = Address;
        Ppe = Address;
        Pde = Address;
        Pte = Address;
    }

    if (Levels >= 3) {
        dprintf("                                 VA %016p\n", Address);
    }
    else {
        dprintf("               VA %08p\n", Address);
    }

    if (Levels == 4) {
       dprintf("PXE @ %016P     PPE at %016P    PDE at %016P    PTE at %016P\n",
            Pxe, Ppe, Pde, Pte);
    }
    else if (Levels == 3) {
       dprintf("PPE at %016P    PDE at %016P    PTE at %016P\n",
            Ppe, Pde, Pte);
    }
    else {
       if (PteSize == 4) {
            dprintf("PDE at   %08P        PTE at %08P\n", Pde, Pte);
       }
       else {
            dprintf("PDE at %016P    PTE at %016P\n", Pde, Pte);
       }
    }

    //
    // Decode the PXE.
    //

    if (Levels >= 4) {

        CurrentPte = Pxe;

        if (GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit)) {
            dprintf("Unable to get PXE %I64X\n", CurrentPte);
            return;
        }

        GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);

        Pxe_Long = CurrentPteContents;

        if (ValidBit == 0) {

            dprintf("contains %016I64X        unavailable\n", Pxe_Long);
            Indent = "";

            if (CurrentPteContents != 0) {
                DbgDisplayInvalidPte (CurrentPte, flags, Indent);
            }
            else {
                dprintf ("\n");
            }
            return;
        }
    }


    //
    // Decode the PPE.
    //

    if (Levels >= 3) {

        CurrentPte = Ppe;

        if (GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit)) {
            dprintf("Unable to get PPE %I64X\n", CurrentPte);
            return;
        }

        GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);

        Ppe_Long = CurrentPteContents;

        if (ValidBit == 0) {

            if (Levels >= 4) {
                dprintf("contains %016I64X  contains %016I64X\n",
                            Pxe_Long, Ppe_Long);
                Indent = "                   ";
                DbgDisplayValidPte (Pxe);
            }
            else {
                dprintf("contains %016I64X\n",
                            Ppe_Long);
                Indent = "";
            }
        
            if (CurrentPteContents != 0) {
                DbgDisplayInvalidPte (CurrentPte, flags, Indent);
            }
            else {
                dprintf ("\n");
            }
            return;
        }
    }
    


    //
    // Decode the PDE.
    //


    CurrentPte = Pde;

    if ( GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
        dprintf("Unable to get PDE %I64X\n", CurrentPte);
        return;
    }

    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);

    Pde_Long = CurrentPteContents;

    if (ValidBit == 0) {

        if (Levels >= 4) {
            dprintf("contains %016I64X  contains %016I64X  contains %016I64X\n",
                Pxe_Long, Ppe_Long, Pde_Long);
            DbgDisplayValidPte (Pxe);
            dprintf ("        ");
            DbgDisplayValidPte (Ppe);
            Indent = "                                            ";
        }
        else if (Levels == 3) {
            dprintf("contains %016I64X  contains %016I64X\n",
                Ppe_Long, Pde_Long);
            DbgDisplayValidPte (Ppe);
            Indent = "                   ";
        }
        else {
            if (PteSize == 4) {
                dprintf("contains %08I64X\n", Pde_Long);
            }
            else {
                dprintf("contains %016I64X\n", Pde_Long);
            }

            Indent = "";
        }
        
        if (CurrentPteContents != 0) {
            DbgDisplayInvalidPte (CurrentPte, flags, Indent);
        }
        else {
            dprintf ("\n");
        }
        return;
    }

    //
    // Decode the PTE and print everything out.
    //

    CurrentPte = Pte;

    if ( GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
        dprintf("Unable to get PTE %I64X\n", CurrentPte);
        return;
    }

    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);

    if (Pde_Long & GET_MM_PTE_LARGE_PAGE_MASK()) {
        CurrentPteContents = 0;
    }

    Pte_Long = CurrentPteContents;

    //
    // Print the raw values.
    //

    if (Levels == 4) {
        dprintf("contains %016I64X  contains %016I64X  contains %016I64X  contains %016I64X\n",
            Pxe_Long, Ppe_Long, Pde_Long, Pte_Long);
        Indent = "                                                         ";
        DbgDisplayValidPte (Pxe);
        dprintf ("        ");
        DbgDisplayValidPte (Ppe);
        dprintf ("        ");
        DbgDisplayValidPte (Pde);
        dprintf ("        ");
    }
    else if (Levels == 3) {
        dprintf("contains %016I64X  contains %016I64X  contains %016I64X\n",
            Ppe_Long, Pde_Long, Pte_Long);
        Indent = "                                                        ";
        DbgDisplayValidPte (Ppe);
        dprintf ("            ");
        DbgDisplayValidPte (Pde);
        dprintf ("            ");
    }
    else {
        if (PteSize == 4) {
            dprintf("contains %08I64X      contains %08I64X\n", Pde_Long, Pte_Long);
            Indent = "                      ";
        }
        else {
            dprintf("contains %016I64X  contains %016I64X\n", Pde_Long, Pte_Long);
            Indent = "                      ";
        }
        DbgDisplayValidPte (Pde);
        dprintf ("    ");
    }

    if (Pde_Long & GET_MM_PTE_LARGE_PAGE_MASK()) {
        dprintf ("LARGE PAGE\n");
    }
    else if (ValidBit != 0) {
        DbgDisplayValidPte (Pte);
        dprintf ("\n");
    }
    else {
        if (CurrentPteContents != 0) {
            DbgDisplayInvalidPte (CurrentPte, flags, Indent);
        }
        else {
            dprintf ("\n");
        }
    }

    dprintf ("\n");

    return;
}

DECLARE_API( pte )

/*++

Routine Description:

     Displays the corresponding PDE and PTE.

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64 Address = 0;
    ULONG64 flags = 0;
    ULONG   flags2 = 0;

    INIT_API();

    if (GetExpressionEx(args,&Address, &args)) {
        if (GetExpressionEx(args,&flags, &args)) {
            flags2  = (ULONG) GetExpression(args);
        }
    }

    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:
        Address = (ULONG64) (LONG64) (LONG) Address;
        DumpPte (Address, flags);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        DumpPte (Address, flags);
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        DumpPte (Address, flags);
        break;
    default:
        dprintf("Unknown platform %d\n",TargetMachine);
        break;
    }

    EXIT_API();
    return S_OK;
}


BOOLEAN
GetPhysicalAddress (
    IN ULONG64 Address,
    OUT PULONG64 PhysAddress
    )

/*++

Routine Description:

    Retrieves the physical address corresponding to the supplied virtual
    address.

Arguments:

    Va - Supplies the virtual address for which the PTE address is sought.

    PhysAddress - Supplies a pointer to caller-supplied memory which is to
                  contain the physical address.

Return Value:
    
    TRUE - The supplied Va is valid and it's physical address was placed
           in *PhysAddress.

    FALSE - The supplied Va does not correspond to a valid address.

--*/

{
    ULONG     ValidBit;
    ULONG     LargePageBit;
    ULONG     PageFrameIndex;
    ULONG64   PteAddress, PteContents;

    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
        case IMAGE_FILE_MACHINE_AMD64:
            PteAddress = DbgGetPdeAddress (Address);

            if (GetFieldValue (PteAddress, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
                dprintf("Unable to get PDE %I64X\n", PteAddress);
                return FALSE;
            }

            if (ValidBit == 0) {
                return FALSE;
            }

            if (GetFieldValue (PteAddress, "nt!_MMPTE", "u.Hard.LargePage", LargePageBit) ) {
                dprintf("Unable to get PDE %I64X\n", PteAddress);
                return FALSE;
            }

            if (LargePageBit == 0) {
                break;
            }

            PageFrameIndex = (ULONG) DbgGetFrameNumber(PteAddress);

            switch (TargetMachine) { 

                case IMAGE_FILE_MACHINE_I386:
                    PageFrameIndex += MiGetPteOffsetX86 (Address);
                    break;

                case IMAGE_FILE_MACHINE_AMD64:
                    PageFrameIndex += (ULONG) MiGetPteOffsetAMD64 (Address);
                    break;
            }

            *PhysAddress =
                ((PageFrameIndex << DBG_GET_PAGE_SHIFT ()) | (Address & 0xFFF));

            return TRUE;

        default:
            break;
    }

    PteAddress = DbgGetPteAddress (Address);

    if (GetFieldValue (PteAddress, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
        dprintf("Unable to get PTE %I64X\n", PteAddress);
        return FALSE;
    }

    if (ValidBit == 0) {
        return FALSE;
    }

    GetFieldValue (PteAddress, "nt!_MMPTE", "u.Long", PteContents);

    *PhysAddress =
        ((DbgGetFrameNumber(PteAddress) << DBG_GET_PAGE_SHIFT ()) | (Address & 0xFFF));

    return TRUE;
}


typedef struct _BPENTRY {
    ULONG64 VirtualAddress;
    ULONG64 PhysicalAddress;
    ULONG Flags;
    ULONG Contents;
} BPENTRY, *PBPENTRY;

#define PHYSICAL_BP_TABLE_SIZE 16

#define PBP_BYTE_POSITION       0x03
#define PBP_INUSE               0x04
#define PBP_ENABLED             0x08

BPENTRY PhysicalBreakpointTable[PHYSICAL_BP_TABLE_SIZE];


#define MAX_FORMAT_STRINGS 8
LPSTR
FormatAddr64(
    ULONG64 addr
    )
{
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) {
        next = 0;
    }
    if (addr >> 32) {
        sprintf(string, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    } else {
        sprintf(string, "%08x", (ULONG)addr);
    }
    return string;
}


DECLARE_API( ubl )
{
    int i;

    INIT_API();
    UNREFERENCED_PARAMETER (args);

    for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
        if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
            dprintf("%2d: %c %s (%s) %d %02x",
                    i,
                    (PhysicalBreakpointTable[i].Flags & PBP_ENABLED) ? 'e' : 'd',
                    FormatAddr64(PhysicalBreakpointTable[i].VirtualAddress),
                    FormatAddr64(PhysicalBreakpointTable[i].PhysicalAddress),
                    (PhysicalBreakpointTable[i].Flags & PBP_BYTE_POSITION),
                    PhysicalBreakpointTable[i].Contents
                    );
        }
    }

    EXIT_API();
    return S_OK;
}

void
PbpEnable(
    int n
    )
{
    PBPENTRY Pbp = PhysicalBreakpointTable + n;
    ULONG mask;
    ULONG Data;
    ULONG cb=0;

    mask = 0xff << (8 * (Pbp->Flags & PBP_BYTE_POSITION));
    Data = (Pbp->Contents & ~mask) | (0xcccccccc & mask);

    WritePhysical(Pbp->PhysicalAddress, &Data, 4, &cb);

    if (cb == 4) {
        Pbp->Flags |= PBP_ENABLED;
    }
}

void
PbpDisable(
    int n
    )
{
    PBPENTRY Pbp = PhysicalBreakpointTable + n;
    ULONG cb;

    WritePhysical(Pbp->PhysicalAddress, &Pbp->Contents, 4, &cb);

    if (cb == 4) {
        Pbp->Flags &= ~PBP_ENABLED;
    }
}

void
PbpClear(
    int n
    )
{
    PBPENTRY Pbp = PhysicalBreakpointTable + n;
    ULONG cb;

    WritePhysical(Pbp->PhysicalAddress, &Pbp->Contents, 4, &cb);

    if (cb == 4) {
        Pbp->Flags = 0;
    }
}


DECLARE_API( ubc )
{
    int i;
    int n;

    INIT_API();

    if (*args == '*') {
        //
        // clear them all
        //

        for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
            if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
                PbpClear(i);
            }
        }
        EXIT_API();
        return E_INVALIDARG;
    }

    n = sscanf(args,"%d",&i);

    if (n != 1 || i < 0 || i >= PHYSICAL_BP_TABLE_SIZE) {
        dprintf("!ubc: bad breakpoint number\n");
        EXIT_API();
        return  E_INVALIDARG;
    }

    if ( !(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
        dprintf("!ubc: breakpoint number %d not set\n", i);
        EXIT_API();
        return E_INVALIDARG;
    }

    PbpClear(i);

    EXIT_API();
    return S_OK;
}

DECLARE_API( ube )
{
    int i;
    int n;

    INIT_API();

    if (*args == '*') {
        //
        // enable them all
        //

        for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
            if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
                PbpEnable(i);
            }
        }
        EXIT_API();
        return E_INVALIDARG;
    }

    n = sscanf(args,"%d",&i);

    if (n != 1 || i < 0 || i >= PHYSICAL_BP_TABLE_SIZE) {
        dprintf("!ube: bad breakpoint number\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ( !(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
        dprintf("!ube: breakpoint number %d not set\n", i);
        EXIT_API();
        return E_INVALIDARG;
    }

    PbpEnable(i);

    EXIT_API();
    return S_OK;
}

DECLARE_API( ubd )
{
    int i;
    int n;

    INIT_API();

    if (*args == '*') {
        //
        // disable them all
        //

        for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
            if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
                PbpDisable(i);
            }
        }
        EXIT_API();
        return E_INVALIDARG;
    }

    n = sscanf(args,"%d",&i);

    if (n != 1 || i < 0 || i >= PHYSICAL_BP_TABLE_SIZE) {
        dprintf("!ubd: bad breakpoint number\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ( !(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
        dprintf("!ubd: breakpoint number %d not set\n", i);
        EXIT_API();
        return E_INVALIDARG;
    }

    PbpDisable(i);

    EXIT_API();
    return S_OK;
}

DECLARE_API( ubp )
{
    ULONG64 Address;
    ULONG   result;
    ULONG PageShift;
    PMMPTEx  Pte;
    PMMPTEx  Pde;
    ULONG64 PdeContents;
    ULONG64 PteContents;
    PBPENTRY Pbp = NULL;
    ULONG cb;
    int i;
    ULONG64 PhysicalAddress;

    static BOOL DoWarning = TRUE;

    INIT_API();

    if (DoWarning) {
        DoWarning = FALSE;
        dprintf("This command is VERY DANGEROUS, and may crash your system!\n");
        dprintf("If you don't know what you are doing, enter \"!ubc *\" now!\n\n");
    }

    for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
        if (!(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
            Pbp = PhysicalBreakpointTable + i;
            break;
        }
    }

    if (!Pbp) {
        dprintf("!ubp: breakpoint table is full!\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    Address = GetExpression(args);

    if ((Address >= GET_PTE_BASE()) && (Address < GET_PDE_TOP())) {

        //
        // The address is the address of a PTE, rather than
        // a virtual address.
        //

        dprintf("!ubp: cannot set a breakpoint on a PTE\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    Pde = DbgGetPdeAddress (Address);
    Pte = DbgGetPteAddress (Address);

    if ( !ReadMemory( (DWORD)Pde,
                      &PdeContents,
                      sizeof(ULONG),
                      &result) ) {
        dprintf("!ubp: %08lx: Unable to get PDE\n",Pde);
        EXIT_API();
        return E_INVALIDARG;
    }

    if (!(PdeContents & 0x1)) {
        dprintf("!ubp: no valid PTE\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if (PdeContents & GET_MM_PTE_LARGE_PAGE_MASK()) {
        dprintf("!ubp: not supported for large page\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ( GetFieldValue( Pte, "nt!_MMPTE", "u.Long", PteContents) ) {
        dprintf("!ubp: %08p: Unable to get PTE (PDE = %08p)\n",Pte, Pde);
        EXIT_API();
        return E_INVALIDARG;
    }

    if (!(PteContents & 1)) {
        dprintf("!ubp: no valid PTE\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    PageShift = DBG_GET_PAGE_SHIFT ();
    PhysicalAddress = ((DbgGetFrameNumber (PteContents)) << PageShift);
    PhysicalAddress &= ~((1 << PageShift) - 1);
    PhysicalAddress |= (Address & ~((1 << PageShift) - 1));
    PhysicalAddress &= ~3;

    for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
        if (PhysicalBreakpointTable[i].PhysicalAddress == PhysicalAddress) {
            dprintf("!ubp: cannot set two breakpoints in the same word\n");
            EXIT_API();
            return E_INVALIDARG;
        }
    }

    ReadPhysical(PhysicalAddress, &Pbp->Contents, 4, &cb);

    if (cb != 4) {
        dprintf("!ubp: unable to read physical at 0x%08x\n", PhysicalAddress);
        EXIT_API();
        return E_INVALIDARG;
    }

    Pbp->VirtualAddress = Address;
    Pbp->PhysicalAddress = PhysicalAddress;
    Pbp->Flags = PBP_INUSE | ((ULONG) Address & 3);

    PbpEnable((int)(Pbp - PhysicalBreakpointTable));

    EXIT_API();
    return S_OK;
}

DECLARE_API( halpte )
{

#define HAL_VA_START_X86    0xffffffffffd00000
    
    ULONG64 virtAddr = HAL_VA_START_X86;
    ULONG64 pteAddr;
    ULONG64 pteContents;
    ULONG  count = 0;

    INIT_API();
    UNREFERENCED_PARAMETER (args);

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("X86 only API\n");
        EXIT_API();
        return E_UNEXPECTED;
    }
    dprintf("\n\nDumping HAL PTE ranges\n\n");
    
    while (virtAddr < 0xffffffffffffe000) {

        pteAddr = DbgGetPteAddress(virtAddr);

        if (!InitTypeRead(pteAddr, nt!_MMPTE)) {

            if (pteContents = ReadField(u.Long)) {

                dprintf("[%03x] %p -> %I64x\n", 
                        count++, 
                        virtAddr, 
                        pteContents & (ULONG64) ~0xFFF);
            }
        }

        virtAddr += PageSize;
    }

    EXIT_API();
    return S_OK;
}



#if defined(ALT_4K)

#undef MiGetAltPteAddress

#define MiGetAltPteAddress(VA) \
      ((ULONG64) (ALT4KB_PERMISSION_TABLE_START + \
                     ((((ULONG64) (VA)) >> PAGE_4K_SHIFT) << ALT_PTE_SHIFT)))

#endif // defined(ALT_4K)

//
// Limit the IA32 subsystem to a 2GB virtual address space.
// This means "Large Address Aware" apps are not supported in emulation mode.
//

#define _MAX_WOW64_ADDRESS       (0x00000000080000000UI64)


DECLARE_API( ate )

/*++

Routine Description:

     Displays the correnponding ATE.

Arguments:

     Args - Address Flags

Return Value:

     None

--*/
{
#if defined(ALT_4K)
    ULONG64 Address;
    ULONG flags;
    ULONG Result;
    ULONG64 PointerAte;
    ULONG64 Process;
    ULONG     AltTable[(_MAX_WOW64_ADDRESS >> PTI_SHIFT)/32];
    ULONG64 *Wow64Process; 
    

    if (GetExpressionEx(args,&Address, &args)) {
        flags  = (ULONG) GetExpression(args);
    }

    Address = Address & ~((ULONG64)PageSize - 1);
    
    PointerAte = MiGetAltPteAddress(Address);

    if ( InitTypeRead( PointerAte,
                       nt!_MMPTE) ) {
        dprintf("Unable to get ATE %p\n", PointerAte);
        return E_INVALIDARG;
    }
        
    dprintf("%016I64X: %016I64X  ", PointerAte, ReadField(u.Long));

    dprintf("PTE off: %08I64X  protect: ",
            ReadField(u.Alt.PteOffset));

    DbgPrintProtection((ULONG) ReadField(u.Alt.Protection));

    dprintf("  %c%c%c%c%c%c%c%c%c%c\n",
            ReadField(u.Alt.Commit) ? 'V' : '-',
            ReadField(u.Alt.Accessed) ? '-' : 'G',
            ReadField(u.Alt.Execute) ? 'E' : '-',
            ReadField(u.Alt.Write) ? 'W' : 'R',
            ReadField(u.Alt.Lock) ? 'L' : '-',
            ReadField(u.Alt.FillZero) ? 'Z' : '-',
            ReadField(u.Alt.NoAccess) ? 'N' : '-',
            ReadField(u.Alt.CopyOnWrite) ? 'C' : '-',
            ReadField(u.Alt.PteIndirect) ? 'I' : '-',
            ReadField(u.Alt.Private) ? 'P' : '-');

#else

    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (Client);

#endif // defined(ALT_4K)

    return S_OK;
}
 
DECLARE_API( pte2va )

/*++

Routine Description:

     Displays the correnponding ATE.

Arguments:

     Args - Address Flags

Return Value:

     None

--*/
{
    ULONG64 Address=0;
    ULONG flags=0;
    
    UNREFERENCED_PARAMETER (Client);

    if (GetExpressionEx(args,&Address, &args)) {
        flags  = (ULONG) GetExpression(args);
    }

    Address = DbgGetVirtualAddressMappedByPte(Address);

    dprintf("%p \n", Address);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\queue.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       queue.c
//
//  Contents:   Extension to dump the ExWorkerQueues
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    5-04-1998   benl   Created
//
//----------------------------------------------------------------------------


#include "precomp.h"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:   DumpQueue
//
//  Synopsis: Dumps a KQUEUE from its address
//
//  Arguments:  [iAddress] -- address of queue
//
//  Returns:
//
//  History:    4-29-1998   benl   Created
//
//  Notes: Assumes the items on the queue are of WORK_QUEUE_ITEM form
//         If this ever extended to dump arbitrary queues that assumption
//         will have to be dropped
//
//----------------------------------------------------------------------------

VOID DumpQueue(ULONG64 iAddress, ULONG dwProcessor, ULONG Flags)
{
    DWORD           dwRead;
    UCHAR           szSymbol[0x100];
    ULONG64         dwDisp;
    ULONG64         iNextAddr;
    ULONG64         iThread;
    ULONG64         pThread;
    ULONG           CurrentCount, MaximumCount, Off;
    ULONG           queueOffset;

    if (GetFieldValue(iAddress, "nt!_KQUEUE", "CurrentCount", CurrentCount))
    {
        dprintf("ReadMemory for queue at %p failed\n", iAddress );
        return;
    }
    GetFieldValue(iAddress, "nt!_KQUEUE", "MaximumCount",MaximumCount);
//    dprintf("EntryListHead: 0x%x 0x%x\n", Queue.EntryListHead.Flink,
//            Queue.EntryListHead.Blink);
    dprintf("( current = %u", CurrentCount);
    dprintf(" maximum = %u )\n", MaximumCount);

    if (CurrentCount >= MaximumCount) {
        
        dprintf("WARNING: active threads = maximum active threads in the queue. No new\n"
                "  workitems schedulable in this queue until they finish or block.\n");
    }

    //print threads
    GetFieldValue(iAddress, "nt!_KQUEUE", "ThreadListHead.Flink", iThread);
    GetFieldOffset("nt!_KQUEUE", "ThreadListHead", &Off);
    GetFieldOffset("nt!_KTHREAD", "QueueListEntry", &queueOffset);
    while (iThread != iAddress + Off)
    {
        ULONG64 Flink;

        if (GetFieldValue(iThread, "nt!_LIST_ENTRY", "Flink", Flink))
        {
            dprintf("ReadMemory for threadqueuelist at %p failed\n", iThread);
            return;
        }

        pThread = iThread - queueOffset;

        DumpThread( dwProcessor, "", pThread, Flags);
        
        if (CheckControlC())
        {
            return;
        }
        iThread = (Flink);
    }
    dprintf("\n");

    //print queued items
    GetFieldValue(iAddress, "nt!_KQUEUE", "EntryListHead.Flink", iNextAddr);
    GetFieldOffset("nt!_KQUEUE", "EntryListHead", &Off);
    while (iNextAddr != iAddress + Off)
    {
        ULONG64 WorkerRoutine, Parameter;
        iThread = 0;

        if (GetFieldValue(iNextAddr, "nt!_WORK_QUEUE_ITEM", "WorkerRoutine",WorkerRoutine))
        {
            dprintf("ReadMemory for entry at %p failed\n", iNextAddr);
            return;
        }

        //try to get the function name
        GetSymbol(WorkerRoutine, szSymbol, &dwDisp);
        GetFieldValue(iNextAddr, "nt!_WORK_QUEUE_ITEM", "Parameter",Parameter);
        if (dwDisp) {
            dprintf("PENDING: WorkerRoutine %s+0x%p (%p) Parameter %p\n",
                    szSymbol, WorkerRoutine, dwDisp, Parameter);
        } else {
            dprintf("PENDING: WorkerRoutine %s (%p) Parameter %p\n",
                    szSymbol, WorkerRoutine, Parameter);
        }

        if (CheckControlC())
        {
            return;
        }

        GetFieldValue(iNextAddr, "nt!_WORK_QUEUE_ITEM", "List.Flink", iNextAddr);
    }

    if (!iThread) {
        dprintf("\n");
    }

} // DumpQueue


//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API
//
//  Synopsis:   Dump the ExWorkerQueues
//
//  Arguments:  [dexqueue] --
//
//  Returns:
//
//  History:    4-29-1998   benl   Created
//
//  Notes: Symbols better be correct or this will print garbage
//
//----------------------------------------------------------------------------

DECLARE_API(exqueue)
{
    ULONG64   iExQueue;
    ULONG Flags = 0;
    ULONG n;
    ULONG dwProcessor=0;
    
    INIT_API();
    GetCurrentProcessor(Client, &dwProcessor, NULL);

    //
    //  Flags == 2 apes the default behavior of just printing out thread state.
    //
    
    if (args) {
        Flags = (ULONG)GetExpression(args);
     }

    iExQueue = GetExpression("NT!ExWorkerQueue");
    dprintf("Dumping ExWorkerQueue: %P\n\n", iExQueue);
    if (iExQueue)
    {
        if (!(Flags & 0xf0) || (Flags & 0x10)) {
            dprintf("**** Critical WorkQueue");
            DumpQueue(iExQueue, dwProcessor, Flags & 0xf);
        }
        if (!(Flags & 0xf0) || (Flags & 0x20)) {
            dprintf("**** Delayed WorkQueue");
            DumpQueue(iExQueue + GetTypeSize("nt!_EX_WORK_QUEUE"), dwProcessor, Flags & 0xf);
        }
        if (!(Flags & 0xf0) || (Flags & 0x40)) {
            dprintf("**** HyperCritical WorkQueue");
            DumpQueue(iExQueue + 2 * GetTypeSize("nt!_EX_WORK_QUEUE"), dwProcessor, Flags & 0xf);
        }
    }

    EXIT_API();
    return S_OK;
} // DECLARE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\ready.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ready.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:
    Jamie Hankins (a-jamhan) 20-Oct-1997 Added CheckControlC to loop.

--*/

#include "precomp.h"
#pragma hdrstop


DECLARE_API( ready )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64     KiDispatcherReadyListHead;
    ULONG       ListEntrySize, WaitListOpffset;
    ULONG       result;
    DWORD       Flags = 6;
    LONG        i;
    BOOLEAN     ThreadDumped = FALSE;
    ULONG       dwProcessor=0;

    GetCurrentProcessor(Client, &dwProcessor, NULL);

    Flags = (ULONG)GetExpression(args);

    KiDispatcherReadyListHead = GetExpression( "nt!KiDispatcherReadyListHead" );
    if ( KiDispatcherReadyListHead ) {

        ListEntrySize = GetTypeSize("nt!_LIST_ENTRY");
        if (ListEntrySize == 0) {
            ListEntrySize = DBG_PTR_SIZE * 2;
        }
        GetFieldOffset("nt!_ETHREAD", "Tcb.WaitListEntry", &WaitListOpffset);

        for (i = MAXIMUM_PRIORITY-1; i >= 0 ; i -= 1 ) {
            ULONG64 Flink, Blink;

            if ( GetFieldValue( KiDispatcherReadyListHead + i*ListEntrySize,
                                "nt!_LIST_ENTRY",
                                "Flink",
                                Flink) ) {
                dprintf(
                    "Could not read contents of KiDispatcherReadyListHead at %08p [%ld]\n",
                    (KiDispatcherReadyListHead + i * ListEntrySize), i
                    );
                return E_INVALIDARG;
            }

            if (Flink != KiDispatcherReadyListHead+i*ListEntrySize) {
                ULONG64 ThreadEntry, ThreadFlink;

                dprintf("Ready Threads at priority %ld\n", i);

                for (ThreadEntry = Flink ;
                     ThreadEntry != KiDispatcherReadyListHead+i*ListEntrySize ;
                     ThreadEntry = ThreadFlink ) {
                    ULONG64 ThreadBaseAddress = (ThreadEntry - WaitListOpffset);

                    if ( GetFieldValue( ThreadBaseAddress,
                                        "nt!_ETHREAD",
                                        "Tcb.WaitListEntry.Flink",
                                        ThreadFlink) ) {
                        dprintf("Could not read contents of thread %p\n", ThreadBaseAddress);
                    }

                    if(CheckControlC()) {
                        return E_INVALIDARG;
                    }

                    DumpThreadEx(dwProcessor,"    ", ThreadBaseAddress, Flags, Client);
                    ThreadDumped = TRUE;

                }
            } else {
                GetFieldValue( KiDispatcherReadyListHead + i*ListEntrySize,
                               "nt!_LIST_ENTRY",
                               "Blink",
                               Blink);
                if (Flink != Blink) {
                    dprintf("Ready linked list may to be corrupt...\n");
                }
            }
        }

        if (!ThreadDumped) {
            dprintf("No threads in READY state\n");
        }
    } else {
        dprintf("Could not determine address of KiDispatcherReadyListHead\n");
        return E_INVALIDARG;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\registry.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regext.c

Abstract:

    Kernel debugger extensions useful for the registry

Author:

    John Vert (jvert) 7-Sep-1993

Environment:

    Loaded as a kernel debugger extension

Revision History:

    John Vert (jvert) 7-Sep-1993
        created

    Dragos C. Sambotin (dragoss) 05-May-2000
        updated to support new registry layout
        enhanced with new commands

--*/


#include "precomp.h"
#pragma hdrstop

ULONG TotalPages;
ULONG TotalPresentPages;
PCHAR pc;

BOOLEAN  SavePages;
BOOLEAN  RestorePages;
HANDLE   TempFile;
ULONG64  gHiveListAddr;

static ULONG DirectoryOffset, TableOffset, BlockAddrOffset, PtrSize, ULongSize, HMapSize, GotOnce = FALSE;

void
poolDumpHive(
    IN ULONG64 Hive
    );

VOID
poolDumpMap(
    IN ULONG   Length,
    IN ULONG64 Map
    );


void
dumpHiveFromFile(
    HANDLE hFile
    );

void 
regdumppool(
            LPSTR args
           )
/*++

Routine Description:

    Goes through all the paged pool allocated to registry space and
    determines which pages are present and which are not.

    Called as:

        !regpool [s|r]

        s Save list of registry pages to temporary file
        r Restore list of registry pages from temp. file

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    ULONG64 pCmpHiveListHead;
    ULONG64 pNextHiveList;
    ULONG64 pHiveListEntry;
    ULONG BytesRead;
    ULONG64 CmHive;
    BYTE HiveList[1024];
    CHAR            Dummy1[ 256 ],Dummy2[64];

    if (sscanf(args,"%s %I64lX",Dummy1,Dummy2)) {
        Dummy2[0] = 0;
    }

    if (toupper(Dummy2[0])=='S') {
        SavePages = TRUE;
    } else {
        SavePages = FALSE;
    }
    if (toupper(Dummy2[0])=='R') {
        RestorePages = TRUE;
    } else {
        RestorePages = FALSE;
    }

    //
    // Go get the hivelist.
    //
    // memset(HiveList,0,sizeof(HiveList));
    pHiveListEntry = GetExpression("nt!CmpMachineHiveList");
    gHiveListAddr = pHiveListEntry;
    if (pHiveListEntry != 0) {
        // Kd caches hive list
        ReadMemory(pHiveListEntry,
                   HiveList,
                   8 * GetTypeSize("_HIVE_LIST_ENTRY"),
                   &BytesRead);
    }

    //
    // First go and get the hivelisthead
    //
    pCmpHiveListHead = GetExpression("nt!CmpHiveListHead");
    if (pCmpHiveListHead==0) {
        dprintf("CmpHiveListHead couldn't be read\n");
        return;
    }

    

    if (!ReadPointer(pCmpHiveListHead, &pNextHiveList)) {
        dprintf("Couldn't read first Flink (%p) of CmpHiveList\n",
                pCmpHiveListHead);
        return;
    }

    TotalPages = TotalPresentPages = 0;

    if (SavePages || RestorePages) {
        TempFile = CreateFile( "regext.dat",
                               GENERIC_READ | GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_ALWAYS,
                               0,
                               NULL
                             );
        if (TempFile == INVALID_HANDLE_VALUE) {
            dprintf("Couldn't open regext.dat\n");
            return;
        }
    }

    if (RestorePages) {
        dumpHiveFromFile(TempFile);
    } else {
        ULONG HiveListOffset;
        FIELD_INFO offField = {"HiveList", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
        SYM_DUMP_PARAM TypeSym ={                                                     
            sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
            NULL, NULL, NULL, 1, &offField
        };
        
        // Get The offset
        if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
           return;
        }
        HiveListOffset = (ULONG) offField.address;
        
        
        
        while (pNextHiveList != pCmpHiveListHead) {
            CmHive = pNextHiveList - HiveListOffset;
            
            poolDumpHive(CmHive);

            if (GetFieldValue(pNextHiveList, "_LIST_ENTRY", "Flink", pNextHiveList)) {
                dprintf("Couldn't read Flink (%p) of %p\n",
                          pCmpHiveListHead,pNextHiveList);
                break;
            }

            if (CheckControlC()) {
                return;
            }
        }
    }

    dprintf("Total pages present = %d / %d\n",
            TotalPresentPages,
            TotalPages);

    if (SavePages || RestorePages) {
        CloseHandle( TempFile );
    }
}

BOOLEAN
GetHiveMaps(
    ULONG64 pHive,
    ULONG64 *pStableMap,
    ULONG   *pStableLength,
    ULONG64 *pVolatileMap,
    ULONG   *pVolatileLength
    )
{
    ULONG   BytesRead;
    ULONG Stable_Length=0, Volatile_Length=0;
    ULONG64 Stable_Map=0, Volatile_Map=0;
    ULONG StorageOffset, DUAL_Size;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Hive.Storage in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return FALSE;
    }
    
    StorageOffset = (ULONG) offField.address;

    DUAL_Size = GetTypeSize("_DUAL");
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Length", Stable_Length);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Length", Volatile_Length);
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Map", Stable_Map);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Map", Volatile_Map);

    (*pStableMap) = Stable_Map;
    (*pStableLength) = Stable_Length;
    (*pVolatileMap) = Volatile_Map;
    (*pVolatileLength) = Volatile_Length;
    return TRUE;
}

BOOLEAN 
USE_OLD_CELL(
    ULONG64     pHive
             ) 
{
    ULONG                   Version;
    
    if(!GetFieldValue(pHive, "_CMHIVE", "Hive.Version", Version)) {
        return (Version==1);
    }
    return FALSE;
}

ULONG64
MyHvpGetCellPaged(
    ULONG64     pHive,
    ULONG       Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for hives with full maps.
    It is the normal version of the routine.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    ULONG           Stable_Length=0, Volatile_Length=0;
    ULONG64         Stable_Map=0, Volatile_Map=0;
    ULONG64         MapTable;
    ULONG64         Map;
    ULONG64         MapEntryAddress, BlockAddress=0;
    ULONG64       lRez;
    ULONG64       pcell;

    if(!GetHiveMaps(pHive,&Stable_Map,&Stable_Length,&Volatile_Map,&Volatile_Length) ) {
        return 0;
    }

    
    Type = ((ULONG)((Cell & HCELL_TYPE_MASK) >> HCELL_TYPE_SHIFT));
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    if( Type == 0 ) {
        Map = Stable_Map;
    } else {
        Map = Volatile_Map;
    }

    dprintf("Map = %p Type = %lx Table = %lx Block = %lx Offset = %lx\n",Map,Type,Table,Block,Offset);

    if (!ReadPointer(Map + DirectoryOffset + Table*PtrSize,
                 &MapTable))
        return 0;

    dprintf("MapTable     = %p \n",MapTable);

    MapEntryAddress = MapTable + Block * HMapSize + BlockAddrOffset;
    if (!ReadPointer(MapEntryAddress, &BlockAddress)) {
        dprintf("  can't read HMAP_ENTRY at %p\n",
                  MapEntryAddress);
        return 0;
    }

    dprintf("BlockAddress = %p \n\n",BlockAddress);

    pcell = ((ULONG64)(BlockAddress) + Offset);
    lRez = (ULONG64)pcell; 
    if (USE_OLD_CELL(pHive)) {
        return lRez + ULongSize + ULongSize;
        //return (struct _CELL_DATA *)&(hcell.u.OldCell.u.UserData);
    } else {
        return lRez + ULongSize;
        //return (struct _CELL_DATA *)&(hcell.u.NewCell.u.UserData);
    }
    return 0;
}

ULONG64
MyHvpGetCellFlat(
    ULONG64     pHive,
    ULONG       Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for read only hives with
    single allocation flat images.  Such hives do not have cell
    maps ("page tables"), instead, we compute addresses by
    arithmetic against the base image address.

    Such hives cannot have volatile cells.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG64     BaseBlock;
    ULONG64   lRez;

    if (GetFieldValue(pHive, "_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
        dprintf("\tCan't CMHIVE Read from %p\n",pHive);
        return 0;
    }

    

    //
    // Address is base of Hive image + Cell
    //
    lRez = (ULONG64)BaseBlock + HBLOCK_SIZE + Cell;
    if (USE_OLD_CELL(pHive)) {
        return lRez + ULongSize + ULongSize;
        //return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return lRez + ULongSize;
        //return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
    return 0;
}

void
poolDumpHive(
    IN ULONG64 pHive
    )
{
    ULONG   BytesRead;
    WCHAR   FileName[HBASE_NAME_ALLOC/2 + 1];
    CHAR    buf[512];
    ULONG   cb;
    ULONG Stable_Length=0, Volatile_Length=0;
    ULONG64 Stable_Map=0, Volatile_Map=0;
    ULONG64 BaseBlock;
    ULONG StorageOffset, DUAL_Size;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Hive.Storage in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return ;
    }
    
    StorageOffset = (ULONG) offField.address;

    dprintf("\ndumping hive at %p ",pHive);
    
    if (GetFieldValue(pHive, "_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
        dprintf("\tCan't CMHIVE Read from %p\n",pHive);
        return;
    }

    if (GetFieldValue( BaseBlock, "_HBASE_BLOCK", "FileName", FileName )) {
        wcscpy(FileName, L"UNKNOWN");
    } else {
        if (FileName[0]==L'\0') {
            wcscpy(FileName, L"NONAME");
        } else {
            FileName[HBASE_NAME_ALLOC/2]=L'\0';
        }
    }

    dprintf("(%ws)\n",FileName);

    DUAL_Size = GetTypeSize("_DUAL");
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Length", Stable_Length);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Length", Volatile_Length);
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Map", Stable_Map);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Map", Volatile_Map);
    
    dprintf("  Stable Length = %lx\n",Stable_Length);
    if (SavePages) {
        sprintf(buf,
                "%ws %d %d\n",
                FileName,
                Stable_Length,
                Volatile_Length);
        WriteFile( TempFile, buf, strlen(buf), &cb, NULL );
    }
    poolDumpMap(Stable_Length, Stable_Map);

    dprintf("  Volatile Length = %lx\n",Volatile_Length);
    poolDumpMap(Volatile_Length, Volatile_Map);

}


VOID
poolDumpMap(
    IN ULONG   Length,
    IN ULONG64 Map
    )
{
    ULONG Tables;
    ULONG MapSlots;
    ULONG i;
    ULONG BytesRead;
    ULONG64 MapTable;
    ULONG Garbage;
    ULONG Present=0;
    CHAR    buf[512];
    ULONG   cb;
    
    // Get the offsets
    if (!GotOnce) {
        if (GetFieldOffset("_HMAP_DIRECTORY", "Directory", &DirectoryOffset)){
            return;
        }
        if (GetFieldOffset("_HMAP_ENTRY", "BlockAddress", &BlockAddrOffset)) {
            return;
        }
        if (GetFieldOffset("_HMAP_TABLE", "Table", &TableOffset)) {
            return;
        }
        PtrSize = DBG_PTR_SIZE;
        ULongSize = sizeof(ULONG); // This doesn't change with target GetTypeSize("ULONG");
        HMapSize = GetTypeSize("_HMAP_ENTRY");
        GotOnce = TRUE;
    }

    if (Length==0) {
        return;
    }

    MapSlots = Length / HBLOCK_SIZE;
    Tables = 1+ ((MapSlots-1) / HTABLE_SLOTS);

    //
    // read in map directory
    //
//    ReadMemory((DWORD)Map,
//             &MapDirectory,
//             Tables * sizeof(PHMAP_TABLE),
//             &BytesRead);
/*    if (BytesRead < (Tables * sizeof(PHMAP_TABLE))) {
        dprintf("Only read %lx/%lx bytes from %lx\n",
                  BytesRead,
                  Tables * sizeof(PHMAP_TABLE),
                  Map);
        return;

    }*/

    //
    // check out each map entry
    //
    for (i=0; i<MapSlots; i++) {
        ULONG64 MapEntryAddress, BlockAddress=0;

        if (!ReadPointer(Map + DirectoryOffset + (i/HTABLE_SLOTS)*PtrSize,
                     &MapTable))
            return;

        MapEntryAddress = MapTable + TableOffset + (i%HTABLE_SLOTS) * PtrSize;
        if (!ReadPointer(MapEntryAddress, &BlockAddress)) {
            dprintf("  can't read HMAP_ENTRY at %p\n",
                      MapEntryAddress);
        }

        if (SavePages) {
            sprintf(buf, "%p\n",BlockAddress);
            WriteFile( TempFile, buf, strlen(buf), &cb, NULL );
        }

        //
        // probe the HBLOCK
        //
        ReadMemory( BlockAddress,
                    &Garbage,
                    sizeof(ULONG),
                    &BytesRead);
        if (BytesRead > 0) {
            ++Present;
        }
        if (CheckControlC()) {
            return;
        }
    }
    dprintf("  %d/%d pages present\n",
              Present,
              MapSlots);

    TotalPages += MapSlots;
    TotalPresentPages += Present;

}


void
dumpHiveFromFile(
    HANDLE hFile
    )

/*++

Routine Description:

    Takes a list of the registry hives and pages from a file and
    checks to see how many of the pages are in memory.

    The format of the file is as follows
       hivename stablelength volatilelength
       stable page address
       stable page address
            .
            .
            .
       volatile page address
       volatile page address
            .
            .
            .
       hivename stablelength volatilelength
            .
            .
            .


Arguments:

    File - Supplies a file.

Return Value:

    None.

--*/

{
#if 0
    CHAR Hivename[33];
    ULONG StableLength;
    ULONG VolatileLength;
    ULONG64 Page;
    ULONG NumFields;
    ULONG Garbage;
    ULONG Present;
    ULONG Total;
    ULONG BytesRead;
    BYTE  buf[512];

    while (!feof(File)) {
        NumFields = fscanf(File,"%s %d %d\n",
                            Hivename,
                            &StableLength,
                            &VolatileLength);
        if (NumFields != 3) {
            dprintf("fscanf returned %d\n",NumFields);
            return;
        }

        dprintf("\ndumping hive %s\n",Hivename);
        dprintf("  Stable Length = %lx\n",StableLength);
        Present = 0;
        Total = 0;
        while (StableLength > 0) {
            fscanf(File, "%I64lx\n",&Page);
            ReadMemory((DWORD)Page,
                        &Garbage,
                        sizeof(ULONG),
                        &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            StableLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            dprintf("  %d/%d stable pages present\n",
                      Present,Total);
        }
        TotalPages += Total;
        TotalPresentPages += Present;

        dprintf("  Volatile Length = %lx\n",VolatileLength);
        Present = 0;
        Total = 0;
        while (VolatileLength > 0) {
            fscanf(File, "%lx\n",&Page);
            ReadMemory(Page,
                       &Garbage,
                       sizeof(ULONG),
                       &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            VolatileLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            dprintf("  %d/%d volatile pages present\n",
                      Present,Total);
        }

        TotalPages += Total;
        TotalPresentPages += Present;
    }
#endif //0
}

USHORT
GetKcbName(
    ULONG64 KcbAddr,
    PWCHAR  NameBuffer,
    ULONG   BufferSize
)
/*++

Routine Description:

    Takes a kcb and dump its complete name.

Arguments:

    KcbAddr - Address of key control block.

    NameBuffer - The Name buffer to fill in the name.

    BufferSize - Size of Buffer.
Return Value:

    Size of Name String.

--*/
{
    WCHAR Name[ 256 ];
    ULONG64 TmpKcbAddr;
    ULONG64 NameBlockAddr;
    DWORD   BytesRead;
    ULONG   Length;
    ULONG   TotalLength;
    ULONG   size;
    ULONG   i;
    ULONG   BeginPosition;
    ULONG   NameOffset;
    WCHAR  *w1, *w2;
    WCHAR  *BufferEnd;
    UCHAR  *u2;

    //
    // Calculate the total string length.
    //
    TotalLength = 0;
    TmpKcbAddr = KcbAddr;
    //    dprintf("Kcb %p ", KcbAddr);
    while (TmpKcbAddr) {
        ULONG Compressed=0, NameLength=0;

        if (GetFieldValue(TmpKcbAddr, "CM_KEY_CONTROL_BLOCK", "NameBlock", NameBlockAddr)) {
            dprintf("Cannot find CM_KEY_CONTROL_BLOCK type.\n");
            return 0;
        }

        if (GetFieldValue(NameBlockAddr, "_CM_NAME_CONTROL_BLOCK", "Compressed", Compressed) ||
            GetFieldValue(NameBlockAddr, "_CM_NAME_CONTROL_BLOCK", "NameLength", NameLength)) {
            dprintf("Cannot find type _CM_NAME_CONTROL_BLOCK.\n");
            return 0;
        }

        if (Compressed) {
            Length = NameLength * sizeof(WCHAR);
        } else {
            Length = NameLength;
        }
        TotalLength += Length;

        //
        // Add the sapce for OBJ_NAME_PATH_SEPARATOR;
        //
        TotalLength += sizeof(WCHAR);

        GetFieldValue(TmpKcbAddr, "CM_KEY_CONTROL_BLOCK", "ParentKcb", TmpKcbAddr);

        if (CheckControlC()) {
            return 0;
        }
    }

    BufferEnd = &(NameBuffer[BufferSize/sizeof(WCHAR) - 1]);
    if (TotalLength < BufferSize) {
        NameBuffer[TotalLength/sizeof(WCHAR)] =  UNICODE_NULL;
    } else {
        *BufferEnd = UNICODE_NULL;
    }

    //
    // Now fill the name into the buffer.
    //
    TmpKcbAddr = KcbAddr;
    BeginPosition = TotalLength;
    GetFieldOffset("CM_NAME_CONTROL_BLOCK", "Name", &NameOffset);

    while (TmpKcbAddr) {
        ULONG NameLength=0, Compressed=0;
        //
        // Read the information.
        //
        if (GetFieldValue(TmpKcbAddr, "CM_KEY_CONTROL_BLOCK", "NameBlock", NameBlockAddr)) {
            dprintf("Cannot find CM_KEY_CONTROL_BLOCK type.\n");
            return 0;
        }

        if (GetFieldValue(NameBlockAddr, "_CM_NAME_CONTROL_BLOCK", "Compressed", Compressed) ||
            GetFieldValue(NameBlockAddr, "_CM_NAME_CONTROL_BLOCK", "NameLength", NameLength)) {
            dprintf("Cannot find type _CM_NAME_CONTROL_BLOCK.\n");
            return 0;
        }

        if (NameLength > sizeof(Name)) {
            NameLength = sizeof(Name);
        }

        ReadMemory(NameBlockAddr +  NameOffset,// FIELD_OFFSET(CM_NAME_CONTROL_BLOCK, Name),
                   Name,
                   NameLength,
                   &BytesRead);

        if (BytesRead < NameLength) {
            dprintf("Could not read Name BUFFER: 5\n");
            return (0);
        }
        
        //
        // Calculate the begin position of each subkey. Then fill in the char.
        //
        if (Compressed) {
            BeginPosition -= (NameLength + 1) * sizeof(WCHAR);
            w1 = &(NameBuffer[BeginPosition/sizeof(WCHAR)]);
            if (w1 < BufferEnd) {
               *w1 = OBJ_NAME_PATH_SEPARATOR;
            }
            w1++;
   
            u2 = (UCHAR *) &(Name[0]);
   
            for (i=0; i<NameLength; i++) {
                if (w1 < BufferEnd) {
                    *w1 = (WCHAR)(*u2);
                } else {
                    break;
                }
                w1++;
                u2++;
            }
        } else {
            BeginPosition -= (NameLength + sizeof(WCHAR));
            w1 = &(NameBuffer[BeginPosition/sizeof(WCHAR)]);
            if (w1 < BufferEnd) {
                *w1 = OBJ_NAME_PATH_SEPARATOR;
            }
            w1++;
   
            w2 = Name;
   
            for (i=0; i<NameLength; i=i+sizeof(WCHAR)) {
                if (w1 < BufferEnd) {
                    *w1 = *w2;
                } else {
                    break;
                }
                w1++;
                w2++;
            }
        }
        GetFieldValue(TmpKcbAddr, "CM_KEY_CONTROL_BLOCK", "ParentKcb", TmpKcbAddr);
    }
    //    dprintf("\n%5d, %ws\n", TotalLength, NameBuffer);
    return ((USHORT) TotalLength);

}

#define CMP_CELL_CACHED_MASK  1

#define CMP_IS_CELL_CACHED(Cell) ((ULONG64) (Cell) & CMP_CELL_CACHED_MASK)
#define CMP_GET_CACHED_ADDRESS(Cell) (((ULONG64) (Cell)) & ~CMP_CELL_CACHED_MASK)

void 
regkcb(
                LPSTR args
                  )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !regkcb KCB_Address

Arguments:

    args - Supplies the address of the KCB.

Return Value:

    .

--*/

{
    WCHAR           KeyName[ 256 ];
    ULONG64         KcbAddr, ParentKcbAddr, KeyHiveAddr, IndexHintAddr,RealKcb;
    DWORD           BytesRead;
    ULONG           ExtFlags, Delete, Flags, KeyCell, KcbMaxNameLen, KcbMaxValueNameLen,KcbMaxValueDataLen,SubKeyCount,ValueCount;
    ULONG           ValueCacheOffset,i,CellIndex;
    ULONG64         ValueList,ValueAddr,CellData;
    USHORT          RefCount, TotalLevels;
    SHORT           DelayedCloseIndex;
    LARGE_INTEGER   KcbLastWriteTime;
    CHAR            Dummy[ 256 ];
    ULONG           KeyBodyListHeadOffset;

    if (sscanf(args,"%s %lX",Dummy,&KcbAddr)) {
        KcbAddr = GetExpression(args + strlen(Dummy));
    }

    if (GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "ExtFlags", ExtFlags) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "Flags", Flags) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "Delete", Delete) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "RefCount", RefCount) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "ParentKcb", ParentKcbAddr) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "KeyHive", KeyHiveAddr) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "KeyCell", KeyCell) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "TotalLevels", TotalLevels) ||
        GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "DelayedCloseIndex", DelayedCloseIndex) 
        ) {
        dprintf("Could not read Kcb\n");
        return;
    }
    
    if(GetKcbName(KcbAddr, KeyName, sizeof(KeyName))) {
        dprintf("Key              : %ws\n", KeyName);
    } else {
        dprintf("Could not read key name\n");
        return;
    }

    dprintf("RefCount         : %lx\n", RefCount);
    dprintf("Flags            :");
    if (Delete) {
        dprintf(" Deleted,");
    }
    if (Flags & KEY_COMP_NAME) {
        dprintf(" CompressedName,");
    }
    if (Flags & KEY_PREDEF_HANDLE) {
        dprintf(" PredefinedHandle,");
    }
    if (Flags & KEY_SYM_LINK) {
        dprintf(" SymbolicLink,");
    }
    if (Flags & KEY_NO_DELETE) {
        dprintf(" NoDelete,");
    }
    if (Flags & KEY_HIVE_EXIT) {
        dprintf(" HiveExit,");
    }
    if (Flags & KEY_HIVE_ENTRY) {
        dprintf(" HiveEntry,");
    }
    if (Flags & KEY_VOLATILE) {
        dprintf(" Volatile");
    } else {
        dprintf(" Stable");
    }

    dprintf("\n");

    dprintf("ExtFlags         :");
    if (ExtFlags & CM_KCB_KEY_NON_EXIST) {
        dprintf(" Fake,");
    }
    if (ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        dprintf(" SymbolicLinkFound,");
    }
    if (ExtFlags & CM_KCB_NO_DELAY_CLOSE) {
        dprintf(" NoDelayClose,");
    }
    if (ExtFlags & CM_KCB_INVALID_CACHED_INFO) {
        dprintf(" InvalidCachedInfo,");
    }
    if (ExtFlags & CM_KCB_NO_SUBKEY) {
        dprintf(" NoSubKey,");
    }
    if (ExtFlags & CM_KCB_SUBKEY_ONE) {
        dprintf(" SubKeyOne,");
    }
    if (ExtFlags & CM_KCB_SUBKEY_HINT) {
        dprintf(" SubKeyHint");
    }
    dprintf("\n");

    dprintf("Parent           : 0x%p\n", ParentKcbAddr);
    dprintf("KeyHive          : 0x%p\n", KeyHiveAddr);
    dprintf("KeyCell          : 0x%lx [cell index]\n", KeyCell);
    dprintf("TotalLevels      : %u\n", TotalLevels);
    dprintf("DelayedCloseIndex: %d\n", DelayedCloseIndex);

    if(!GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "KcbMaxNameLen", KcbMaxNameLen)) {
        dprintf("MaxNameLen       : 0x%lx\n", KcbMaxNameLen);
    }
    if(!GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "KcbMaxValueNameLen", KcbMaxValueNameLen)) {
        dprintf("MaxValueNameLen  : 0x%lx\n", KcbMaxValueNameLen);
    }
    if(!GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "KcbMaxValueDataLen", KcbMaxValueDataLen)) {
        dprintf("MaxValueDataLen  : 0x%lx\n", KcbMaxValueDataLen);
    }
    if(!GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "KcbLastWriteTime", KcbLastWriteTime)) {
        dprintf("LastWriteTime    : 0x%8lx:0x%8lx\n", KcbLastWriteTime.HighPart,KcbLastWriteTime.LowPart);
    }

    if( !GetFieldOffset("CM_KEY_CONTROL_BLOCK", "KeyBodyListHead", &KeyBodyListHeadOffset) ) {
        ParentKcbAddr = KcbAddr + KeyBodyListHeadOffset;

        dprintf("KeyBodyListHead  : ");
        if (!GetFieldValue(ParentKcbAddr, "_LIST_ENTRY", "Flink", KeyHiveAddr)) {
            dprintf("0x%p ", KeyHiveAddr);
        }
        if (!GetFieldValue(ParentKcbAddr, "_LIST_ENTRY", "Blink", KeyHiveAddr)) {
            dprintf("0x%p", KeyHiveAddr);
        }
        dprintf("\n");
    }    
    if(!(Flags&KEY_HIVE_ENTRY)) {
        dprintf("SubKeyCount      : ");
        if( !(ExtFlags & CM_KCB_INVALID_CACHED_INFO) ) {
            if (ExtFlags & CM_KCB_NO_SUBKEY ) {
                dprintf("0");
            } else if (ExtFlags & CM_KCB_SUBKEY_ONE ) {
                dprintf("1");
            } else if (ExtFlags & CM_KCB_SUBKEY_HINT ) {
                if( !GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "IndexHint", IndexHintAddr) ) {
                    if( !GetFieldValue(IndexHintAddr, "CM_INDEX_HINT_BLOCK", "Count", SubKeyCount) ) {
                        dprintf("%lu",SubKeyCount);
                    }
                }
            } else {
                if( !GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", "SubKeyCount", SubKeyCount) ) {
                    dprintf("%lu",SubKeyCount);
                }
            }
        } else {
            dprintf("hint not valid");
        }
        dprintf("\n");
    }

    GetFieldOffset("CM_KEY_CONTROL_BLOCK", "ValueCache", &ValueCacheOffset);
    if( ExtFlags & CM_KCB_SYM_LINK_FOUND ) {
        if(!GetFieldValue(KcbAddr + ValueCacheOffset, "_CACHED_CHILD_LIST", "RealKcb", RealKcb)) {
            dprintf("RealKcb          : 0x%p\n", RealKcb);
        }
    } else {
        if(!GetFieldValue(KcbAddr + ValueCacheOffset, "_CACHED_CHILD_LIST", "Count", ValueCount)) {
            dprintf("ValueCache.Count : %lu\n", ValueCount);
            if(!GetFieldValue(KcbAddr + ValueCacheOffset, "_CACHED_CHILD_LIST", "ValueList", ValueList)) {
                if (CMP_IS_CELL_CACHED(ValueList)) {
                    ValueList = CMP_GET_CACHED_ADDRESS(ValueList);
                    if(!GetFieldValue(ValueList, "_CM_CACHED_VALUE_INDEX", "CellIndex", CellIndex) ) {
                        
                        dprintf("ValueList        : 0x%lx\n", CellIndex);

                        GetFieldOffset("_CM_CACHED_VALUE_INDEX", "Data.CellData", &ValueCacheOffset);
                        ValueList += ValueCacheOffset;
                        for (i = 0; i < ValueCount; i++) {
                        
                            dprintf("    ValueList[%2lu] = ",i);

                            ReadMemory(ValueList + i*PtrSize, &ValueAddr, PtrSize, &BytesRead);
                            if (BytesRead < PtrSize) {
                                dprintf("Couldn't read memory\n");
                            } else {
                                dprintf("  0x%p\n",ValueAddr);
                            }
                        
                        }
                    }

                } else {
                    dprintf("ValueCache.List  : 0x%p\n", ValueList);
                }
            }
        }
    }

}

//
// Miscelaneous Hash routines
//
ULONG CmpHashTableSize = 0;
#define RNDM_CONSTANT   314159269    /* default value for "scrambling constant" */
#define RNDM_PRIME     1000000007    /* prime number, also used for scrambling  */

#define HASH_KEY(_convkey_) ((RNDM_CONSTANT * (_convkey_)) % RNDM_PRIME)

#define GET_HASH_INDEX(Key) HASH_KEY(Key) % CmpHashTableSize
#define GET_HASH_ENTRY(Table, Key) Table[GET_HASH_INDEX(Key)]


void 
regopenkeys(
                LPSTR args,
                LPSTR subkey
                  )

/*++

Routine Description:

    Dumps the registry hash table

    Called as:

        !openkeys <HiveAddr|0>

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    DWORD64 TableSizeAddr;
    DWORD64 HashTableAddr;
    ULONG64 HashTable;
    DWORD i;
    ULONG64 KcbAddr;
    WCHAR KeyName[ 256 ];
    ULONG64 HashEntryAddr;
    DWORD BytesRead;
    ULONG KeyHashOffset;
    BOOLEAN First;
    ULONG64 TargetHive = 0;
    CHAR        Dummy[ 256 ];
    ULONG ConvKey = 0;
    ULONG j,Count;
    ULONG SearchedIndex;
    WCHAR FullKeyName[ 512 ];

    TableSizeAddr = GetExpression("nt!CmpHashTableSize");
    if (TableSizeAddr == 0) {
        dprintf("Couldn't find address of CmpHashTableSize\n");
        return;
    }

    HashTableAddr = GetExpression("nt!CmpCacheTable");
    if (HashTableAddr == 0) {
        dprintf("Couldn't find address of CmpCacheTable\n");
        return;
    }
    ReadMemory(TableSizeAddr, &CmpHashTableSize, sizeof(CmpHashTableSize), &BytesRead);
    if (BytesRead < sizeof(CmpHashTableSize)) {
        dprintf("Couldn't get CmpHashTableSize from %08p\n",TableSizeAddr);
        return;
    }
    
    if (!ReadPointer(HashTableAddr, &HashTable)) {
        dprintf("Couldn't get CmpCacheTable from %08p\n",HashTableAddr);
        return;
    }

    if( subkey == NULL ) {

        if (sscanf(args,"%s %lX",Dummy,&TargetHive)) {
            TargetHive = GetExpression(args + strlen(Dummy));
        }

        i=0;
        SearchedIndex = CmpHashTableSize - 1;
    } else {
        for( Count=0;subkey[Count];Count++) {
            FullKeyName[Count] = (WCHAR)subkey[Count];
            if( FullKeyName[Count] != OBJ_NAME_PATH_SEPARATOR ) {
                ConvKey = 37 * ConvKey + (ULONG) RtlUpcaseUnicodeChar(FullKeyName[Count]);
            }
        }
        FullKeyName[Count] = UNICODE_NULL;
        SearchedIndex = GET_HASH_INDEX(ConvKey);
        i=SearchedIndex;
     }

    
    GetFieldOffset("CM_KEY_CONTROL_BLOCK", "KeyHash", &KeyHashOffset);
    
    for (; i<=SearchedIndex; i++) {
        if (CheckControlC()) {
            return;
        }
        
        if (!ReadPointer(HashTable + i*PtrSize,&HashEntryAddr)) {
            dprintf("Couldn't get HashEntryAddr from %08p\n", HashTable + i*PtrSize);
            continue;
        }
        if (HashEntryAddr != 0) {
            First = TRUE;
            while (HashEntryAddr != 0) {
#define KcbFld(F) GetFieldValue(KcbAddr, "CM_KEY_CONTROL_BLOCK", #F, F)
                ULONG64 KeyHive, NextHash;
                ULONG   ConvKey, KeyCell, Flags, ExtFlags;
                
                KcbAddr = HashEntryAddr - KeyHashOffset;
                if (KcbFld(ConvKey)) {
                    dprintf("Couldn't get HashEntry from %08lx\n", HashEntryAddr);
                    break;
                } 
                
                KcbFld(KeyHive); KcbFld(KeyCell);
                KcbFld(Flags);   KcbFld(ExtFlags); KcbFld(NextHash);
        
                if( subkey == NULL ) {
                    if( (TargetHive == 0) || ((ULONG64)TargetHive == (ULONG64)KeyHive) ) {
                        if( !First ) {
                            dprintf("\t");
                        } else {
                            dprintf("Index %x: ",i);
                        }
                        dprintf("\t %08lx kcb=%p cell=%08lx f=%04lx%04lx ",
                                ConvKey,
                                KcbAddr,
                                KeyCell,
                                Flags,
                                ExtFlags);
                        First = FALSE;
                        if (GetKcbName(KcbAddr, KeyName, sizeof(KeyName))) {
                            dprintf("%ws\n", KeyName);
                        }
                    }
                } else {
                    //
                    // findkcb case
                    //
                        if (GetKcbName(KcbAddr, KeyName, sizeof(KeyName))) {
                            for(j=0;KeyName[j] != UNICODE_NULL;j++);
                            if( (j == Count) && (_wcsnicmp(FullKeyName,KeyName,Count) == 0) ) {
                                dprintf("\nFound KCB = %p :: %ws\n\n",KcbAddr,KeyName);
                                return;
                            }
                        }

                }
                HashEntryAddr = NextHash;
                if (CheckControlC()) {
                    return;
                }
#undef KcbFld
            }
        }
    }
    if( subkey != NULL ) {
        dprintf("\nSorry <%ws> is not cached \n\n",FullKeyName);
    }

}

void 
regcellindex(
                LPSTR args
                  )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !cellindex HiveAddr HCELL_INDEX 

Arguments:

    args - Supplies the address of the HCELL_INDEX.

Return Value:

    .

--*/

{
    ULONG64     HiveAddr;
    ULONG       IdxAddr;
    ULONG64   pcell;
    BOOLEAN     Flat;
    CHAR        Dummy[ 256 ];

    if (sscanf(args,"%s %lX %lx",Dummy,&HiveAddr,&IdxAddr)) {
       if (GetExpressionEx(args + strlen(Dummy), &HiveAddr, &args)) {
           IdxAddr = (ULONG) GetExpression(args);
       }
    }

    if(!GetFieldValue(HiveAddr, "HHIVE", "Flat", Flat) ){
        if(Flat) {
            pcell = MyHvpGetCellFlat(HiveAddr,IdxAddr);
        } else {
            pcell = MyHvpGetCellPaged(HiveAddr,IdxAddr);
        }

        dprintf("pcell:  %p\n",pcell);
    } else {
        dprintf("could not read hive\n");
    }
}

void 
reghashindex (
            LPSTR args
           )
/*++

Routine Description:

    display the index for the convkey

    Called as:

        !hashindex conv_key

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG       ConvKey;
    CHAR        Dummy[ 256 ];
    DWORD64     TableSizeAddr;
    DWORD64     HashTableAddr;
    ULONG64     HashTable;
    DWORD       BytesRead;
    ULONG       Index;

    if (!sscanf(args,"%s %lx",Dummy,&ConvKey)) {
        ConvKey = 0;
    }

    TableSizeAddr = GetExpression("nt!CmpHashTableSize");
    if (TableSizeAddr == 0) {
        dprintf("Couldn't find address of CmpHashTableSize\n");
        return;
    }

    ReadMemory(TableSizeAddr, &CmpHashTableSize, sizeof(CmpHashTableSize), &BytesRead);
    if (BytesRead < sizeof(CmpHashTableSize)) {
        dprintf("Couldn't get CmpHashTableSize from %08p\n",TableSizeAddr);
        return;
    }
    
    HashTableAddr = GetExpression("nt!CmpCacheTable");
    if (HashTableAddr == 0) {
        dprintf("Couldn't find address of CmpCacheTable\n");
        return ;
    }
    if (!ReadPointer(HashTableAddr, &HashTable)) {
        dprintf("Couldn't get CmpCacheTable from %08p\n",HashTableAddr);
        return;
    } else {
        dprintf("CmpCacheTable = %p\n\n",HashTable);
    }

    Index = GET_HASH_INDEX(ConvKey);
    HashTable += Index*PtrSize;
    dprintf("Hash Index[%8lx] : %lx\n",ConvKey,Index);
    dprintf("Hash Entry[%8lx] : %p\n",ConvKey,HashTable);
}

void 
regknode(
            LPSTR args
           )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !knode KNode_Address

Arguments:

    args - Supplies the address of the CM_KEY_NODE.

Return Value:

    .

--*/

{
    char            KeyName[ 256 ];
    ULONG64         KnodeAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    USHORT          Signature,Flags,NameLength;
    LARGE_INTEGER   LastWriteTime;
    ULONG           Parent,MaxNameLen,MaxClassLen,MaxValueNameLen,MaxValueDataLen,Security,Class;
    ULONG           KeyNameOffset,Count,ValueList;
    ULONG           SubKeys[4];  

    if (sscanf(args,"%s %lX",Dummy,&KnodeAddr)) {

        KnodeAddr = GetExpression(args + strlen(Dummy));
    }

    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "Signature", Signature) ) {
        if( Signature == CM_KEY_NODE_SIGNATURE) {
            dprintf("Signature: CM_KEY_NODE_SIGNATURE (kn)\n");
        } else if(Signature == CM_LINK_NODE_SIGNATURE) {
            dprintf("Signature: CM_LINK_NODE_SIGNATURE (kl)\n");
        } else {
            dprintf("Invalid Signature %u\n",Signature);
        }
    }

    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "NameLength", NameLength) ) {
        GetFieldOffset("CM_KEY_NODE", "Name", &KeyNameOffset);
        
        if( !ReadMemory(KnodeAddr + KeyNameOffset,
                   KeyName,
                   NameLength,
                   &BytesRead) ) {
            dprintf("Could not read KeyName\n");
        } else {
            KeyName[NameLength] = '\0';
            dprintf("Name                 : %s\n", KeyName);
        }
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "Parent", Parent) ) {
        dprintf("ParentCell           : 0x%lx\n", Parent);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "Security", Security) ) {
        dprintf("Security             : 0x%lx [cell index]\n", Security);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "Class", Class) ) {
        dprintf("Class                : 0x%lx [cell index]\n", Class);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "Flags", Flags) ) {
        dprintf("Flags                : 0x%lx\n", Flags);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "MaxNameLen", MaxNameLen) ) {
        dprintf("MaxNameLen           : 0x%lx\n", MaxNameLen);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "MaxClassLen", MaxClassLen) ) {
        dprintf("MaxClassLen          : 0x%lx\n", MaxClassLen);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "MaxValueNameLen", MaxValueNameLen) ) {
        dprintf("MaxValueNameLen      : 0x%lx\n", MaxValueNameLen);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "MaxValueDataLen", MaxValueDataLen) ) {
        dprintf("MaxValueDataLen      : 0x%lx\n", MaxValueDataLen);
    }
    if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "LastWriteTime", LastWriteTime) ) {
        dprintf("LastWriteTime        : 0x%8lx:0x%8lx\n", LastWriteTime.HighPart,LastWriteTime.LowPart);
    }

    if(!(Flags&KEY_HIVE_ENTRY)) {
        GetFieldOffset("CM_KEY_NODE", "SubKeyCounts", &KeyNameOffset);
        if( !ReadMemory(KnodeAddr + KeyNameOffset,
                   SubKeys,
                   4*ULongSize,
                   &BytesRead) ) {
            dprintf("Could not read SubKey Info\n");
        } else {
            dprintf("SubKeyCount[Stable  ]: 0x%lx\n", SubKeys[0]);
            dprintf("SubKeyLists[Stable  ]: 0x%lx\n", SubKeys[2]);
            dprintf("SubKeyCount[Volatile]: 0x%lx\n", SubKeys[1]);
            dprintf("SubKeyLists[Volatile]: 0x%lx\n", SubKeys[3]);
        }
        if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "ValueList.Count", Count)) {
            dprintf("ValueList.Count      : 0x%lx\n", Count);
            if (!GetFieldValue(KnodeAddr, "CM_KEY_NODE", "ValueList.List", ValueList)) {
                dprintf("ValueList.List       : 0x%lx\n", ValueList);
            }
        }

    }
}

void 
regkbody(
            LPSTR args
           )
/*++

Routine Description:

    displays a CM_KEY_BODY

    Called as:

        !kbody KBody_Address

Arguments:

    args - Supplies the address of the CM_KEY_BODY.
    
Return Value:

    .

--*/

{
    ULONG64         KbodyAddr,KeyControlBlock,NotifyBlock,Process,KeyBodyList,CallerAddress;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           Type,Offset,Callers,i;

    if (sscanf(args,"%s %lX",Dummy,&KbodyAddr)) {

        KbodyAddr = GetExpression(args+ strlen(Dummy));
    }


    if (!GetFieldValue(KbodyAddr, "CM_KEY_BODY", "Type", Type) ) {
        if( Type == KEY_BODY_TYPE) {
            dprintf("Type        : KEY_BODY_TYPE\n");
        } else {
            dprintf("Invalid Type %lx\n",Type);
            return;
        }
    }
    if (!GetFieldValue(KbodyAddr, "CM_KEY_BODY", "KeyControlBlock", KeyControlBlock) ) {
        dprintf("KCB         : %p\n", KeyControlBlock);
    }
    if (!GetFieldValue(KbodyAddr, "CM_KEY_BODY", "NotifyBlock", NotifyBlock) ) {
        dprintf("NotifyBlock : %p\n", NotifyBlock);
    }
    if (!GetFieldValue(KbodyAddr, "CM_KEY_BODY", "Process", Process) ) {
        dprintf("Process     : %p\n", Process);
    }
    if (!GetFieldValue(KbodyAddr, "CM_KEY_BODY", "KeyBodyList", KeyBodyList) ) {
        GetFieldOffset("CM_KEY_BODY", "KeyBodyList", &Offset);

        dprintf("KeyBodyList : ");
        if (!GetFieldValue(KbodyAddr + Offset, "_LIST_ENTRY", "Flink", KeyBodyList)) {
            dprintf("0x%p ", KeyBodyList);
        }
        if (!GetFieldValue(KbodyAddr + Offset, "_LIST_ENTRY", "Blink", KeyBodyList)) {
            dprintf("0x%p", KeyBodyList);
        }
        dprintf("\n");
    }
    if (!GetFieldValue(KbodyAddr, "CM_KEY_BODY", "Callers", Callers) ) {
        GetFieldOffset("CM_KEY_BODY", "CallerAddress", &Offset);
        if( Callers ) {
            dprintf("Callers Stack: ");
        }
        for(i = 0;i< Callers;i++) {
            dprintf("[%lu] ",i);
            if( !ReadMemory(KbodyAddr + Offset + i*PtrSize,
                       &CallerAddress,
                       sizeof(CallerAddress),
                       &BytesRead) ) {
                dprintf("Could not memory\n");
            } else {
                dprintf("  %p\n", CallerAddress);
            }            
        }
    }

}


void 
regkvalue(
            LPSTR args
           )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !kvalue KValue_Address

Arguments:

    args - Supplies the address of the CM_KEY_NODE.

Return Value:

    .

--*/

{
    char            ValName[ 256 ];
    ULONG64         KvalAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           Offset,DataLength,Data,Type;
    USHORT          Signature,Flags,NameLength;

    if (sscanf(args,"%s %lX",Dummy,&KvalAddr)) {

        KvalAddr = GetExpression(args+ strlen(Dummy));
    }

    if (!GetFieldValue(KvalAddr, "CM_KEY_VALUE", "Signature", Signature) ) {
        if( Signature == CM_KEY_VALUE_SIGNATURE) {
            dprintf("Signature: CM_KEY_VALUE_SIGNATURE (kv)\n");
        } else {
            dprintf("Invalid Signature %lx\n",Signature);
        }
    }

    if (!GetFieldValue(KvalAddr, "CM_KEY_VALUE", "Flags", Flags) ) {
        if( (Flags & VALUE_COMP_NAME) &&
            !GetFieldValue(KvalAddr, "CM_KEY_VALUE", "NameLength", NameLength)
            ) {
            GetFieldOffset("CM_KEY_VALUE", "Name", &Offset);
            ReadMemory(KvalAddr + Offset,
                       ValName,
                       NameLength,
                       &BytesRead);
            ValName[NameLength] = '\0';
            dprintf("Name      : %s {compressed}\n", ValName);
        }
    }

    if (!GetFieldValue(KvalAddr, "CM_KEY_VALUE", "DataLength", DataLength) ) {
        dprintf("DataLength: %lx\n", DataLength);
    }
    if (!GetFieldValue(KvalAddr, "CM_KEY_VALUE", "Data", Data) ) {
        dprintf("Data      : %lx  [cell index]\n", Data);
    }
    if (!GetFieldValue(KvalAddr, "CM_KEY_VALUE", "Type", Type) ) {
        dprintf("Type      : %lx\n", Type);
    }

}

void 
regbaseblock(
            LPSTR args
           )
/*++

Routine Description:

    displays the base block structure

    Called as:

        !baseblock HiveAddress

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    WCHAR           FileName[HBASE_NAME_ALLOC/sizeof(WCHAR) + 1];
    ULONG64         BaseBlock,HiveAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           Work;
    LARGE_INTEGER   TimeStamp;

    if (sscanf(args,"%s %lX",Dummy,&HiveAddr)) {

        HiveAddr = GetExpression(args+ strlen(Dummy));
    }

    if (GetFieldValue(HiveAddr, "_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
        dprintf("\tCan't CMHIVE Read from %p\n",HiveAddr);
        return;
    }

    if (GetFieldValue( BaseBlock, "_HBASE_BLOCK", "FileName", FileName )) {
        wcscpy(FileName, L"UNKNOWN");
    } else {
        if (FileName[0]==L'\0') {
            wcscpy(FileName, L"NONAME");
        } else {
            FileName[HBASE_NAME_ALLOC/sizeof(WCHAR)]=L'\0';
        }
    }
    dprintf("FileName :  %ws\n",FileName);

    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Signature", Work )) {
        if( Work == HBASE_BLOCK_SIGNATURE ) {
            dprintf("Signature:  HBASE_BLOCK_SIGNATURE\n");
        } else {
            dprintf("Signature:  %lx\n",Work);
        }
    }

    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Sequence1", Work )) {
        dprintf("Sequence1:  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Sequence2", Work )) {
        dprintf("Sequence2:  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "TimeStamp", TimeStamp )) {
        dprintf("TimeStamp:  %lx %lx\n",TimeStamp.HighPart,TimeStamp.LowPart);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Major", Work )) {
        dprintf("Major    :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Minor", Work )) {
        dprintf("Minor    :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Type", Work )) {
        switch(Work) {
        case HFILE_TYPE_PRIMARY:
            dprintf("Type     :  HFILE_TYPE_PRIMARY\n");
            break;
        case HFILE_TYPE_LOG:
            dprintf("Type     :  HFILE_TYPE_LOG\n");
            break;
        case HFILE_TYPE_EXTERNAL:
            dprintf("Type     :  HFILE_TYPE_EXTERNAL\n");
            break;
        default:
            dprintf("Type     :  %lx\n",Work);
            break;

        }
    }
    
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Format", Work )) {
        if( Work == HBASE_FORMAT_MEMORY ) {
            dprintf("Format   :  HBASE_FORMAT_MEMORY\n");
        } else {
            dprintf("Format   :  %lx\n",Work);
        }
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "RootCell", Work )) {
        dprintf("RootCell :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Length", Work )) {
        dprintf("Length   :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "Cluster", Work )) {
        dprintf("Cluster  :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "_HBASE_BLOCK", "CheckSum", Work )) {
        dprintf("CheckSum :  %lx\n",Work);
    }
}

void 
reghivelist(
           )
/*++

Routine Description:

    dumps all the hives in the system

    Called as:

        !hivelist 

Arguments:

Return Value:

    .

--*/

{
    ULONG64 pCmpHiveListHead;
    ULONG64 pNextHiveList;
    ULONG BytesRead, WorkVar;
    ULONG64 CmHive;
    USHORT  Count;
    ULONG HiveListOffset;
    FIELD_INFO offField = {"HiveList", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    ULONG           Stable_Length=0, Volatile_Length=0;
    ULONG64         Stable_Map=0, Volatile_Map=0;
    WCHAR           FileName[HBASE_NAME_ALLOC/sizeof(WCHAR) + 1];
    ULONG64         BaseBlock;


    //
    // First go and get the hivelisthead
    //
    pCmpHiveListHead = GetExpression("nt!CmpHiveListHead");
    if (pCmpHiveListHead==0) {
        dprintf("CmpHiveListHead couldn't be read\n");
        return;
    }

    

    if (!ReadPointer(pCmpHiveListHead, &pNextHiveList)) {
        dprintf("Couldn't read first Flink (%p) of CmpHiveList\n",
                pCmpHiveListHead);
        return;
    }

    TotalPages = TotalPresentPages = 0;

    // Get The offset
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return;
    }
    HiveListOffset = (ULONG) offField.address;
    
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
    dprintf("| HiveAddr |Stable Length|Stable Map|Volatile Length|Volatile Map|MappedViews|PinnedViews|U(Cnt)| BaseBlock | FileName \n");
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
    while (pNextHiveList != pCmpHiveListHead) {

        if (CheckControlC()) {
            break;
        }

        CmHive = pNextHiveList - HiveListOffset;
        

        if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.Signature", WorkVar)) {
            if( WorkVar != HHIVE_SIGNATURE ) {
                dprintf("Invalid Hive signature:  %lx\n",WorkVar);
                break;
            }
        }
        dprintf("| %p ",CmHive);
        

        if(!GetHiveMaps(CmHive,&Stable_Map,&Stable_Length,&Volatile_Map,&Volatile_Length) ) {
            break;
        }

        dprintf("|   %8lx  ",Stable_Length);
        dprintf("| %p ",Stable_Map);
        dprintf("|   %8lx    ",Volatile_Length);
        dprintf("|  %p  ",Volatile_Map);
        if (!GetFieldValue(CmHive, "CMHIVE", "MappedViews", Count)) {
            dprintf("| %8u  ",Count);
        }
        if (!GetFieldValue(CmHive, "CMHIVE", "PinnedViews", Count)) {
            dprintf("| %8u  ",Count);
        }
        if (!GetFieldValue(CmHive, "CMHIVE", "UseCount", WorkVar)) {
            dprintf("| %5u",WorkVar);
        }
        if (GetFieldValue(CmHive, "_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
            dprintf("\tCan't CMHIVE Read from %p\n",CmHive);
            continue;
        }
        dprintf("| %p  |",BaseBlock);

        if (GetFieldValue( BaseBlock, "_HBASE_BLOCK", "FileName", FileName )) {
            wcscpy(FileName, L"<UNKNOWN>");
        } else {
            if (FileName[0]==L'\0') {
                wcscpy(FileName, L"<NONAME>");
            } else {
                FileName[HBASE_NAME_ALLOC/sizeof(WCHAR)]=L'\0';
            }
        }
        dprintf(" %ws\n",FileName);

        if (GetFieldValue(pNextHiveList, "_LIST_ENTRY", "Flink", pNextHiveList)) {
            dprintf("Couldn't read Flink (%p) of %p\n",
                      pCmpHiveListHead,pNextHiveList);
            break;
        }

    }
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
 
    dprintf("\n");

}

void 
regviewlist(
            LPSTR args
           )
/*++

Routine Description:

    dumps all the views mapped/pinned for the specified hive

    Called as:

        !viewlist <HiveAddr>

Arguments:

    args - hive.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,PinViewListHead,LRUViewListHead,Flink,Blink,ViewAddr,Address;
    ULONG64         List1,List2;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,OffsetPinned,OffsetMapped,OffsetPinnedHead,OffsetMappedHead;
    USHORT          MappedViews,PinnedViews;

    
    if (sscanf(args,"%s %lX",Dummy,&CmHive)) {

        CmHive = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }

    if (GetFieldValue(CmHive, "CMHIVE", "MappedViews", MappedViews) ||
        GetFieldValue(CmHive, "CMHIVE", "PinnedViews", PinnedViews) ||
        GetFieldOffset("_CMHIVE", "PinViewListHead", &OffsetPinnedHead) ||
        GetFieldOffset("_CMHIVE", "LRUViewListHead", &OffsetMappedHead) ||
        GetFieldOffset("_CM_VIEW_OF_FILE", "PinViewList", &OffsetPinned) ||
        GetFieldOffset("_CM_VIEW_OF_FILE", "LRUViewList", &OffsetMapped)
        ) {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }

    PinViewListHead = CmHive + OffsetPinnedHead;
    LRUViewListHead = CmHive + OffsetMappedHead;
    if ( !GetFieldValue(PinViewListHead, "_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(PinViewListHead, "_LIST_ENTRY", "Blink", Blink)
         ) {
        dprintf("%4u  Pinned Views ; PinViewListHead = %p %p\n",PinnedViews,Flink,Blink);
        if( PinnedViews ) {
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
            dprintf("| ViewAddr |FileOffset|   Size   |ViewAddress|   Bcb    |    LRUViewList     |    PinViewList     | UseCount |\n");
            dprintf("--------------------------------------------------------------------------------------------------------------\n");

            
            for(;PinnedViews;PinnedViews--) {
                if (CheckControlC()) {
                    break;
                }

                ViewAddr = Flink;
                ViewAddr -= OffsetPinned;
                
                dprintf("| %p ",ViewAddr);

                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "FileOffset", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "Size", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "ViewAddress", Address) ) {
                    dprintf("| %p  ",Address);
                }
                if( Address == 0 ) {
                    dprintf("could not read memory - paged out\n");
                    break;
                }
                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "Bcb", Address) ) {
                    dprintf("| %p ",Address);
                }


                if( !GetFieldValue(ViewAddr + OffsetMapped, "_LIST_ENTRY", "Flink", List1) ) {
                    dprintf("| %p",List1);
                }
                if( !GetFieldValue(ViewAddr + OffsetMapped, "_LIST_ENTRY", "Blink", List2) ) {
                    dprintf("  %p ",List2);
                }

                if( !GetFieldValue(ViewAddr + OffsetPinned, "_LIST_ENTRY", "Flink", Flink) ) {
                    dprintf("| %p",Flink);
                }
                if( !GetFieldValue(ViewAddr + OffsetPinned, "_LIST_ENTRY", "Blink", Blink) ) {
                    dprintf("  %p |",Blink);
                }

                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "UseCount", WorkVar) ) {
                    dprintf(" %8lx |\n",WorkVar);
                }
                
            }
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
        }
    }

    dprintf("\n");
    if ( !GetFieldValue(LRUViewListHead, "_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(LRUViewListHead, "_LIST_ENTRY", "Blink", Blink)
         ) {
        dprintf("%4u  Mapped Views ; LRUViewListHead = %p %p\n",MappedViews,Flink,Blink);
        if( MappedViews ) {
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
            dprintf("| ViewAddr |FileOffset|   Size   |ViewAddress|   Bcb    |    LRUViewList     |    PinViewList     | UseCount |\n");
            dprintf("--------------------------------------------------------------------------------------------------------------\n");

            
            for(;MappedViews;MappedViews--) {
                if (CheckControlC()) {
                    break;
                }
                ViewAddr = Flink;
                ViewAddr -= OffsetMapped;
                
                dprintf("| %p ",ViewAddr);

                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "FileOffset", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "Size", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "ViewAddress", Address) ) {
                    dprintf("| %p  ",Address);
                }
                if( Address == 0 ) {
                    dprintf("could not read memory - paged out\n");
                    break;
                }
                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "Bcb", Address) ) {
                    dprintf("| %p ",Address);
                }


                if( !GetFieldValue(ViewAddr + OffsetMapped, "_LIST_ENTRY", "Flink", Flink) ) {
                    dprintf("| %p",Flink);
                }
                if( !GetFieldValue(ViewAddr + OffsetMapped, "_LIST_ENTRY", "Blink", Blink) ) {
                    dprintf("  %p ",Blink);
                }

                if( !GetFieldValue(ViewAddr + OffsetPinned, "_LIST_ENTRY", "Flink", List1) ) {
                    dprintf("| %p",List1);
                }
                if( !GetFieldValue(ViewAddr + OffsetPinned, "_LIST_ENTRY", "Blink", List2) ) {
                    dprintf("  %p |",List2);
                }

                if( !GetFieldValue(ViewAddr, "_CM_VIEW_OF_FILE", "UseCount", WorkVar) ) {
                    dprintf(" %8lx |\n",WorkVar);
                }
                
            }
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
        }
    }
    dprintf("\n");

}

void 
regfreebins(
            LPSTR args
           )
/*++

Routine Description:

    dumps all the free bins for the specified hive

    Called as:

        !freebins <HiveAddr>

Arguments:

    args - hive.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,AnchorAddr,BinAddr,Flink,Blink;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,OffsetFreeBins,Offset;
    ULONG           DUAL_Size,StorageOffset;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    USHORT      Nr = 0;

    if (sscanf(args,"%s %lX",Dummy,&CmHive)) {

        CmHive = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }
    
    // Get the offset of Hive.Storage in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return;
    }
    
    StorageOffset = (ULONG) offField.address;
    DUAL_Size = GetTypeSize("_DUAL");

    GetFieldOffset("_FREE_HBIN", "ListEntry", &Offset);
    GetFieldOffset("_DUAL", "FreeBins", &OffsetFreeBins);

    dprintf("Stable Storage ... \n");

    dprintf("-------------------------------------------------------------------\n");
    dprintf("| Address  |FileOffset|   Size   |   Flags  |   Flink  |   Blink  |\n");
    dprintf("-------------------------------------------------------------------\n");
    Nr = 0;

    AnchorAddr = CmHive + StorageOffset + OffsetFreeBins;

    if ( !GetFieldValue(AnchorAddr, "_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(AnchorAddr, "_LIST_ENTRY", "Blink", Blink)
         ) {
        while((ULONG64)Flink != (ULONG64)AnchorAddr ) {
            if (CheckControlC()) {
                break;
            }
            BinAddr = Flink - Offset;
            dprintf("| %p ",BinAddr);

            if(!GetFieldValue(BinAddr, "_FREE_HBIN", "FileOffset", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "_FREE_HBIN", "Size", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "_FREE_HBIN", "Flags", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }

            if( !GetFieldValue(BinAddr + Offset, "_LIST_ENTRY", "Flink", Flink) ) {
                dprintf("| %p ",Flink);
            }
            if( !GetFieldValue(BinAddr + Offset, "_LIST_ENTRY", "Blink", Blink) ) {
                dprintf("| %p |\n",Blink);
            }
            
            Nr++;
        }
        
    }

    dprintf("-------------------------------------------------------------------\n");

    dprintf("%4u  FreeBins\n",Nr);

    dprintf("\n");

    dprintf("Volatile Storage ... \n");

    dprintf("-------------------------------------------------------------------\n");
    dprintf("| Address  |FileOffset|   Size   |   Flags  |   Flink  |   Blink  |\n");
    dprintf("-------------------------------------------------------------------\n");

    AnchorAddr = CmHive + StorageOffset + DUAL_Size + OffsetFreeBins;
    Nr = 0;

    if ( !GetFieldValue(AnchorAddr, "_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(AnchorAddr, "_LIST_ENTRY", "Blink", Blink)
         ) {
        while((ULONG64)Flink != (ULONG64)AnchorAddr ) {
            if (CheckControlC()) {
                break;
            }
            BinAddr = Flink - Offset;
            dprintf("| %p ",BinAddr);

            if(!GetFieldValue(BinAddr, "_FREE_HBIN", "FileOffset", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "_FREE_HBIN", "Size", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "_FREE_HBIN", "Flags", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }

            if( !GetFieldValue(BinAddr + Offset, "_LIST_ENTRY", "Flink", Flink) ) {
                dprintf("| %p ",Flink);
            }
            if( !GetFieldValue(BinAddr + Offset, "_LIST_ENTRY", "Blink", Blink) ) {
                dprintf("| %p |\n",Blink);
            }
            
            Nr++;
        }
        
    }

    dprintf("-------------------------------------------------------------------\n");

    dprintf("%4u  FreeBins\n",Nr);

    dprintf("\n");
}

void 
regdirtyvector(
            LPSTR args
           )
/*++

Routine Description:

    displays the dirty vector of the hive

    Called as:

        !dirtyvector <HiveAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,BufferAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,SizeOfBitMap,i;
    ULONG           BitsPerULONG;
    ULONG           BitsPerBlock;
    ULONG           DirtyBuffer;
    ULONG           Mask;

    if (sscanf(args,"%s %lX",Dummy,&CmHive)) {

        CmHive = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }

    dprintf("HSECTOR_SIZE = %lx\n",HSECTOR_SIZE);
    dprintf("HBLOCK_SIZE  = %lx\n",HBLOCK_SIZE);
    dprintf("PAGE_SIZE    = %lx\n",PageSize);
    dprintf("\n");

    if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.DirtyAlloc", WorkVar)) {
        dprintf("DirtyAlloc      = :  0x%lx\n",WorkVar);
    }
    if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.DirtyCount", WorkVar)) {
        dprintf("DirtyCount      = :  0x%lx\n",WorkVar);
    }
    if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.DirtyVector.Buffer", BufferAddr)) {
        dprintf("Buffer          = :  0x%p\n",BufferAddr);
    }
    dprintf("\n");
    
    if(GetFieldValue(CmHive, "_CMHIVE", "Hive.DirtyVector.SizeOfBitMap", SizeOfBitMap)) {
        return;
    }

    BitsPerULONG = 8*ULongSize;
    BitsPerBlock = HBLOCK_SIZE / HSECTOR_SIZE;

    dprintf("   Address                       32k                                       32k");
    for(i=0;i<SizeOfBitMap;i++) {
        if (CheckControlC()) {
            break;
        }
        if( !(i%(2*BitsPerULONG ) ) ){
            dprintf("\n 0x%8lx  ",i*HSECTOR_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            dprintf(" ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            if( !ReadMemory(BufferAddr,
                        &DirtyBuffer,
                        ULongSize,
                        &BytesRead)) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,BufferAddr);
                return;
            }
            BufferAddr += ULongSize;
            dprintf("\t");
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        dprintf("%s",Mask?"1":"0");
    }
    dprintf("\n\n");
    
}

CCHAR CmKDFindFirstSetLeft[256] = {
        0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

#define CmKDComputeIndex(Index, Size)                                   \
    {                                                                   \
        Index = (Size >> HHIVE_FREE_DISPLAY_SHIFT) - 1;                 \
        if (Index >= HHIVE_LINEAR_INDEX ) {                             \
                                                                        \
            /*                                                          \
            ** Too big for the linear lists, compute the exponential    \
            ** list.                                                    \
            */                                                          \
                                                                        \
            if (Index > 255) {                                          \
                /*                                                      \
                ** Too big for all the lists, use the last index.       \
                */                                                      \
                Index = HHIVE_FREE_DISPLAY_SIZE-1;                      \
            } else {                                                    \
                Index = CmKDFindFirstSetLeft[Index] +                   \
                        HHIVE_FREE_DISPLAY_BIAS;                        \
            }                                                           \
        }                                                               \
    }

void 
regfreecells(
            LPSTR args
           )
/*++

Routine Description:

    displays the free cells map in a bin

    Called as:

        !freecells <BinAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         BinAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,FileOffset,Size,BinHeaderSize;
    ULONG           NrOfCellsPerIndex;
    ULONG           NrOfCellsTotal;
    ULONG           TotalFreeSize;
    ULONG           Index;
    ULONG           CurrIndex,Offset;
    LONG            Current;

    if (sscanf(args,"%s %lX",Dummy,&BinAddr)) {

        BinAddr = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(BinAddr, "_HBIN", "Signature", WorkVar)) {
        if( WorkVar != HBIN_SIGNATURE ) {
            dprintf("\tInvalid Bin signature %lx \n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read bin at %p\n",BinAddr);
        return;
    }

    if(GetFieldValue(BinAddr, "_HBIN", "FileOffset", FileOffset) ||
       GetFieldValue(BinAddr, "_HBIN", "Size", Size)
        ) {
        dprintf("Could not read bin at %p\n",BinAddr);
    }
    
    BinHeaderSize = GetTypeSize("_HBIN");
    dprintf("Bin Offset = 0x%lx  Size = 0x%lx\n",FileOffset,Size);

    NrOfCellsTotal = 0;
    TotalFreeSize = 0;

    for(CurrIndex = 0;CurrIndex<HHIVE_FREE_DISPLAY_SIZE;CurrIndex++) {
        dprintf("\n FreeDisplay[%2lu] :: ",CurrIndex);

        NrOfCellsPerIndex = 0;
        Offset = BinHeaderSize;
        while( Offset < Size ) {
            if (CheckControlC()) {
                break;
            }
            if( !ReadMemory(BinAddr + Offset,
                        &Current,
                        ULongSize,
                        &BytesRead) ) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,BinAddr + Offset);
                return;
            }
        
            if(Current>0) {
                //
                // free cell
                //
                CmKDComputeIndex(Index, Current);
                if( Index == CurrIndex ) {
                    //
                    // dum it here as this is the right index
                    //
                    NrOfCellsTotal++;
                    NrOfCellsPerIndex++;
                    TotalFreeSize += Current;
                    dprintf("    %lx [%lx]",Offset,Current);
                    if( !(NrOfCellsPerIndex % 8) && ((Offset + Current) < Size) ) {
                        dprintf("\n");
                    }
                }
            } else {
                Current *= -1;
            }
            Offset += Current;
        }
    }    

    dprintf("\nTotal: FreeCells = %lu, FreeSpace = 0x%lx BinUsage = %.2f%%\n",NrOfCellsTotal,TotalFreeSize,
                (float)(((float)(Size-BinHeaderSize-TotalFreeSize)/(float)(Size-BinHeaderSize))*100.00)
             );

}

void 
regfreehints(
            LPSTR args
           )
/*++

Routine Description:

    displays the freehints information for the hive

    Called as:

        !freehints <HiveAddr> <StorageCount> <DisplayCount>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,BufferAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar;
    ULONG           Mask;
    ULONG           BitsPerULONG;
    ULONG           BitsPerBlock;
    ULONG           BitsPerLine;
    ULONG           Stable_Length=0, Volatile_Length=0;
    ULONG64         Stable_Map=0, Volatile_Map=0;
    ULONG           DisplayCount;
    ULONG           StorageCount;
    ULONG           SizeOfBitmap;
    ULONG           i;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    ULONG           DUAL_Size,StorageOffset,RTL_BITMAP_Size,OffsetFreeDisplay;
    ULONG64         DirtyBufferAddr;
    ULONG           DirtyBuffer;

    if (sscanf(args,"%s %lX",Dummy,&CmHive)) {
        if  (GetExpressionEx(args+ strlen(Dummy), &CmHive, &args)) {
            if (!sscanf(args,"%lu %lu",&StorageCount,&DisplayCount)) {
                StorageCount = DisplayCount = 0;
            }
        }
    }

    if(!GetFieldValue(CmHive, "_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }
    
    dprintf("HSECTOR_SIZE = %lx\n",HSECTOR_SIZE);
    dprintf("HBLOCK_SIZE  = %lx\n",HBLOCK_SIZE);
    dprintf("PAGE_SIZE    = %lx\n",PageSize);
    dprintf("\n");

    BitsPerULONG = 8*ULongSize;
    BitsPerBlock = 0x10000 / HBLOCK_SIZE; // 64k blocks
    BitsPerLine  = 0x40000 / HBLOCK_SIZE; // 256k lines (vicinity reasons)
    
    if(!GetHiveMaps(CmHive,&Stable_Map,&Stable_Length,&Volatile_Map,&Volatile_Length) ) {
        return;
    }

    if( StorageCount == 0 ) {
        SizeOfBitmap = Stable_Length / HBLOCK_SIZE;
    } else {
        SizeOfBitmap = Volatile_Length / HBLOCK_SIZE;
    }

    // Get the offset of Hive.FreeDisplay in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return;
    }
    
    StorageOffset = (ULONG) offField.address;
    DUAL_Size = GetTypeSize("_DUAL");
    RTL_BITMAP_Size = GetTypeSize("RTL_BITMAP");
    dprintf("bitmap size = %lu\n",RTL_BITMAP_Size);
    GetFieldOffset("_DUAL", "FreeDisplay", &OffsetFreeDisplay);

    BufferAddr = CmHive + StorageOffset + DUAL_Size * StorageCount + OffsetFreeDisplay + DisplayCount * RTL_BITMAP_Size;
    if(GetFieldValue(BufferAddr, "RTL_BITMAP", "Buffer", DirtyBufferAddr) ) {
        dprintf("Cannot read bitmap address\n");
        return;
    }

    dprintf("Storage = %s , FreeDisplay[%lu]: \n",StorageCount?"Volatile":"Stable",DisplayCount);
    
    dprintf("\n%8s    %16s %16s %16s %16s","Address","64K (0x10000)","64K (0x10000)","64K (0x10000)","64K (0x10000)");

    for(i=0;i<SizeOfBitmap;i++) {
        if (CheckControlC()) {
            break;
        }
        if( !(i%BitsPerLine) ){
            dprintf("\n 0x%8lx  ",i*HBLOCK_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            dprintf(" ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            if( !ReadMemory(DirtyBufferAddr,
                        &DirtyBuffer,
                        ULongSize,
                        &BytesRead) ) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,DirtyBufferAddr);
                return;
            }
            DirtyBufferAddr += ULongSize;
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        dprintf("%s",Mask?"1":"0");
    }

    dprintf("\n\n");

}

void 
regseccache(
            LPSTR args
           )
/*++

Routine Description:

    displays the base block structure

    Called as:

        !seccache <HiveAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         HiveAddr,SecCache;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,i,Cell;
    LONG            WorkHint;
    ULONG           CacheEntrySize = GetTypeSize("_CM_KEY_SECURITY_CACHE_ENTRY");
    ULONG64         CachedSec;

    if (sscanf(args,"%s %lX",Dummy,&HiveAddr)) {
        HiveAddr = GetExpression(args + strlen(Dummy));
    }

    if(!GetFieldValue(HiveAddr, "_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    }
    if (!GetFieldValue(HiveAddr, "CMHIVE", "SecurityCacheSize", WorkVar)) {
        dprintf("SecurityCacheSize = :  0x%lx\n",WorkVar);
    }
    if (!GetFieldValue(HiveAddr, "CMHIVE", "SecurityCount", WorkVar)) {
        dprintf("SecurityCount     = :  0x%lx\n",WorkVar);
    }
    if (!GetFieldValue(HiveAddr, "CMHIVE", "SecurityHitHint", WorkHint)) {
        dprintf("SecurityHitHint   = :  0x%lx\n",WorkHint);
    }

    if (!GetFieldValue(HiveAddr, "CMHIVE", "SecurityCache", SecCache)) {
        dprintf("SecurityCache     = :  0x%p\n\n",SecCache);
        dprintf("[Entry No.]  [Security Cell] [Security Cache]\n",WorkHint);

        for( i=0;i<WorkVar;i++) {
            if (CheckControlC()) {
                break;
            }

            if (GetFieldValue(SecCache + i*CacheEntrySize, "_CM_KEY_SECURITY_CACHE_ENTRY", "CachedSecurity", CachedSec)) {
                continue;
            }
            if (GetFieldValue(SecCache + i*CacheEntrySize, "_CM_KEY_SECURITY_CACHE_ENTRY", "Cell", Cell)) {
                continue;
            }
            dprintf("%[%8lu]    0x%8lx       0x%p\n",i,Cell,CachedSec);
        }
    }
}


void ParseArgs(
                LPSTR args,
                LPSTR Dummy
               )
{
    ULONG i =0;    
    while( (args[i]!= 0) && (args[i] != ' ') ) {
        Dummy[i] = args[i];
        i++;
    }
    Dummy[i] = 0;
}

void ParseKcbNameInArg(
                LPSTR args,
                LPSTR KcbName
               )
{
    ULONG i =0;    
    ULONG j =0;
    while( (args[i]!= 0) && (args[i] != ' ') ) {
        i++;
    }
    while( args[i] == ' ' ) {
        i++;
    }
    while( args[i]!= 0 ) {
        KcbName[j] = args[i];
        i++;j++;
    }
    KcbName[j] = 0;
}

DECLARE_API( reg )
/*++

Routine Description:

    Dispatch point for all registry extensions

    Called as:

        !reg <command> <params>

Arguments:

    args - Supplies the address of the HCELL_INDEX.

Return Value:

    .

--*/

{
    CHAR        Dummy[ 512 ];

    ParseArgs((LPSTR)args,(LPSTR)Dummy);

    // Get the offsets
    if (!GotOnce) {
        if (GetFieldOffset("_HMAP_DIRECTORY", "Directory", &DirectoryOffset)){
            return E_INVALIDARG;
        }
        if (GetFieldOffset("_HMAP_ENTRY", "BlockAddress", &BlockAddrOffset)) {
            return E_INVALIDARG;
        }
        if (GetFieldOffset("_HMAP_TABLE", "Table", &TableOffset)) {
            return E_INVALIDARG;
        }
        PtrSize = DBG_PTR_SIZE;
        ULongSize = sizeof(ULONG); // 
        HMapSize = GetTypeSize("_HMAP_ENTRY");

        GotOnce = TRUE;
    }

    dprintf("\n");
    if (!strcmp(Dummy, "kcb")) {
        regkcb((LPSTR)args);
    } else if (!strcmp(Dummy, "cellindex")) {
        regcellindex((LPSTR)args);
    } else if( !strcmp(Dummy, "hashindex")) {
        reghashindex((LPSTR)args);
    } else if( !strcmp(Dummy, "openkeys")) {
        regopenkeys((LPSTR)args,NULL);
    } else if( !strcmp(Dummy, "knode")) {
        regknode((LPSTR)args);
    } else if( !strcmp(Dummy, "kbody")) {
        regkbody((LPSTR)args);
    } else if( !strcmp(Dummy, "kvalue")) {
        regkvalue((LPSTR)args);
    } else if( !strcmp(Dummy, "baseblock")) {
        regbaseblock((LPSTR)args);
    } else if( !strcmp(Dummy, "findkcb")) {
        ParseKcbNameInArg((LPSTR)args,(LPSTR)Dummy);
        regopenkeys((LPSTR)args,(LPSTR)Dummy);
    } else if( !strcmp(Dummy, "hivelist")) {
        reghivelist();
    } else if( !strcmp(Dummy, "seccache")) {
        regseccache((LPSTR)args);
    } else if( !strcmp(Dummy, "viewlist")) {
        regviewlist((LPSTR)args);
    } else if( !strcmp(Dummy, "freebins")) {
        regfreebins((LPSTR)args);
    } else if( !strcmp(Dummy, "dirtyvector")) {
        regdirtyvector((LPSTR)args);
    } else if( !strcmp(Dummy, "freecells")) {
        regfreecells((LPSTR)args);
    } else if( !strcmp(Dummy, "freehints")) {
        regfreehints((LPSTR)args);
    } else if( !strcmp(Dummy, "dumppool")) {
        regdumppool((LPSTR)args);
    } else {
        // dump general usage
        dprintf("reg <command>  <params>       - Registry extensions\n");
        dprintf("    kcb        <Address>      - Dump registry key-control-blocks\n");
        dprintf("    knode      <Address>      - Dump registry key-node struct\n");
        dprintf("    kbody      <Address>      - Dump registry key-body struct\n");
        dprintf("    kvalue     <Address>      - Dump registry key-value struct\n");
        dprintf("    baseblock  <HiveAddr>     - Dump the baseblock for the specified hive\n");
        dprintf("    seccache   <HiveAddr>     - Dump the security cache for the specified hive\n");
        dprintf("    hashindex  <conv_key>     - Find the hash entry given a Kcb ConvKey\n");
        dprintf("    openkeys   <HiveAddr|0>   - Dump the keys opened inside the specified hive\n");
        dprintf("    findkcb    <FullKeyPath>  - Find the kcb for the corresponding path\n");
        dprintf("    hivelist                  - Displays the list of the hives in the system\n");
        dprintf("    viewlist   <HiveAddr>     - Dump the pinned/mapped view list for the specified hive\n");
        dprintf("    freebins   <HiveAddr>     - Dump the free bins for the specified hive\n");
        dprintf("    freeceells <BinAddr>      - Dump the free free cells in the specified bin\n");
        dprintf("    dirtyvector<HiveAddr>     - Dump the dirty vector for the specified hive\n");
        dprintf("    cellindex  <HiveAddr> <cellindex> - Finds the VA for a specified cell index\n");
        dprintf("    freehints  <HiveAddr> <Storage> <Display> - Dumps freehint info\n");
        dprintf("    dumppool   [s|r]          - Dump registry allocated paged pool\n");
        dprintf("       s - Save list of registry pages to temporary file\n");
        dprintf("       r - Restore list of registry pages from temp. file\n");
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\qlocks.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    qlocks.c

Abstract:

    WinDbg Extension Api

Author:

    David N. Cutler (davec) 25-Sep-1999

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define queued lock data.
//

#define NUMBER_PROCESSORS 32
#define NUMBER_PROCESSORS_X86  32
#define NUMBER_PROCESSORS_IA64 64

#if (NUMBER_PROCESSORS_IA64 < MAXIMUM_PROCESSORS)
#error "Update NUMBER_PROCESSORS definition"
#endif

UCHAR Key[NUMBER_PROCESSORS];

#define KEY_CORRUPT         255
#define KEY_OWNER           254
#define KEY_NOTHING         253

typedef struct KSPIN_LOCK_QUEUE_READ {
    ULONG64 Next;
    ULONG64 Lock;
} KSPIN_LOCK_QUEUE_READ;

KSPIN_LOCK_QUEUE_READ LockQueue[NUMBER_PROCESSORS_IA64][LockQueueMaximumLock];

ULONG64 ProcessorBlock[NUMBER_PROCESSORS_IA64];

ULONG64 SpinLock[LockQueueMaximumLock];

typedef struct _LOCK_NAME {
    KSPIN_LOCK_QUEUE_NUMBER Number;
    PCHAR Name;
} LOCK_NAME, *PLOCK_NAME;

LOCK_NAME LockName[] = {
    { LockQueueDispatcherLock,    "KE   - Dispatcher   " },
    { LockQueueContextSwapLock,   "KE   - Context Swap " },
    { LockQueuePfnLock,           "MM   - PFN          " },
    { LockQueueSystemSpaceLock,   "MM   - System Space " },
    { LockQueueVacbLock,          "CC   - Vacb         " },
    { LockQueueMasterLock,        "CC   - Master       " },
    { LockQueueNonPagedPoolLock,  "EX   - NonPagedPool " },
    { LockQueueIoCancelLock,      "IO   - Cancel       " },
    { LockQueueWorkQueueLock,     "EX   - WorkQueue    " },
    { LockQueueIoVpbLock,         "IO   - Vpb          " },
    { LockQueueIoDatabaseLock,    "IO   - Database     " },
    { LockQueueIoCompletionLock,  "IO   - Completion   " },
    { LockQueueNtfsStructLock,    "NTFS - Struct       " },
    { LockQueueAfdWorkQueueLock,  "AFD  - WorkQueue    " },
    { LockQueueBcbLock,           "CC   - Bcb          " },
    { LockQueueMaximumLock,       NULL                   },
};

//
// Define forward referenced prototypes.
//

ULONG
ProcessorIndex (
    ULONG64 LockAddress,
    ULONG   LockIndex
    );

DECLARE_API( qlocks )

/*++

Routine Description:

    Dump kernel mode queued spinlock status.

Arguments:

    None.

Return Value:

    None.

--*/

{

    BOOL Corrupt;
    ULONG HighestProcessor;
    ULONG Index;
    KSPIN_LOCK_QUEUE_READ *LockOwner;
    ULONG Last;
    ULONG Loop;
    ULONG64 MemoryAddress;
    ULONG Number;
    ULONG Result;
    CHAR Sequence;
    ULONG LockQueueOffset;
    ULONG Processor;
    ULONG PtrSize = DBG_PTR_SIZE;
    ULONG SizeOfQ = GetTypeSize("nt!KSPIN_LOCK_QUEUE");
    ULONG MaximumProcessors;


    MaximumProcessors = (UCHAR) GetUlongValue("NT!KeNumberProcessors");
//        IsPtr64() ? NUMBER_PROCESSORS_IA64 : NUMBER_PROCESSORS_X86;

    //
    // Get address of processor block array and read entire array.
    //

    MemoryAddress = GetExpression("nt!KiProcessorBlock");
    if (MemoryAddress == 0) {

        //
        // Either the processor block address is zero or the processor
        // block array could not be read.
        //

        dprintf("Unable to read processor block array\n");
        return E_INVALIDARG;
    }
    HighestProcessor = 0;
    for (Index = 0; Index < MaximumProcessors; Index++) { 
        
        if (!ReadPointer(MemoryAddress + Index*PtrSize, &ProcessorBlock[Index])) {
            dprintf("Unable to read processor block array\n");
            return E_INVALIDARG;
        }

        if (ProcessorBlock[Index] != 0) {
            HighestProcessor = Index;
        }
    } 

    if (GetFieldOffset("nt!KPRCB", "LockQueue", &LockQueueOffset)) {
        dprintf("Unable to read KPRCB.LockQueue offset.\n");
        return E_INVALIDARG;
    }

    //
    // Read the lock queue information for each processor.
    //

    for (Index = 0; Index < MaximumProcessors; Index += 1) {
        RtlZeroMemory(&LockQueue[Index][0],
                      sizeof(KSPIN_LOCK_QUEUE_READ) * LockQueueMaximumLock);

        if (ProcessorBlock[Index] != 0) {
            ULONG j;

            for (j=0; j< LockQueueMaximumLock; j++) { 
                if (GetFieldValue(ProcessorBlock[Index] + LockQueueOffset + j*SizeOfQ,
                                  "nt!KSPIN_LOCK_QUEUE",
                                  "Next",
                                  LockQueue[Index][j].Next)) {

                    //
                    // Lock queue information could not be read for the respective
                    // processor.
                    //

                    dprintf("Unable to read lock queue information for processor %d @ %p\n",
                            Index, ProcessorBlock[Index]);

                    return E_INVALIDARG;
                }
                GetFieldValue(ProcessorBlock[Index] + LockQueueOffset + j*SizeOfQ,
                              "nt!KSPIN_LOCK_QUEUE",
                              "Lock",
                              LockQueue[Index][j].Lock);
            }
        }
    }

    //
    // Read the spin lock information for each queued lock.
    //

    for (Index = 0; Index < LockQueueMaximumLock; Index += 1) {
        SpinLock[Index] = 0;
        if (LockQueue[0][Index].Lock != 0) {
            if (GetFieldValue(LockQueue[0][Index].Lock & ~(LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER),
                              "nt!PVOID", // KSPIN_LOCK == ULONG_PTR, this would sign-extens it
                              NULL,
                              SpinLock[Index])) {

                //
                // Spin lock information could not be read for the respective
                // queued lock.
                //

                dprintf("Unable to read spin lock information for queued lock %d\n",
                        Index);

                return E_INVALIDARG;
            }
        }
    }

    //
    // Verify that the kernel spin lock array is not corrupt. Each entry in
    // this array should either be zero or contain the address of the correct
    // lock queue entry in one of the processor control blocks.
    //

    Corrupt = FALSE;
    for (Index = 0; Index < LockQueueMaximumLock && (LockName[Index].Name != NULL); Index += 1) {
        if (SpinLock[Index] != 0) {
            if (ProcessorIndex(SpinLock[Index], Index) == 0) {
                Corrupt = TRUE;
                dprintf("Kernel spin lock %s is corrupt.\n", LockName[Index].Name);
            }
        }
    }

    //
    // Verify that all lock queue entries are not corrupt. Each lock queue
    // entry should either have a next field of NULL of contain the address
    // of the correct lock queue entry in one of the processor control blocks.
    //

    for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
        for (Index = 0; Index < LockQueueMaximumLock; Index += 1) {
            if (LockQueue[Loop][Index].Next != 0) {
                if (ProcessorIndex(LockQueue[Loop][Index].Next, Index) == 0) {
                    Corrupt = TRUE;
                    dprintf("Lock entry %d for processor %d is corrupt\n",
                            Index,
                            Loop);
                }
            }
        }
    }

    if (Corrupt != FALSE) {
        return E_INVALIDARG;
    }

    //
    // Output key information and headings.
    //

    dprintf("Key: O = Owner, 1-n = Wait order, blank = not owned/waiting, C = Corrupt\n\n");
    dprintf("                       Processor Number\n");
    dprintf("    Lock Name       ");
    for (Index = 0; Index <= HighestProcessor; Index++) {
        dprintf("%3d", Index);
    }
    dprintf("\n\n");

    //
    // Process each queued lock and output owner information.
    //

    for (Index = 0; Index < LockQueueMaximumLock && (LockName[Index].Name != NULL); Index += 1) {

        if (Index != (ULONG) LockName[Index].Number) {
            dprintf("ERROR: extension bug: name array does not match queued lock list!\n");
            break;
        }

        dprintf("%s", LockName[Index].Name);

        //
        // If the lock is owned, then find the owner and any waiters. Output
        // the owner and waiters in order.
        //
        // If the lock is not owned, then check the consistency of lock queue
        // entries. They should all contain next pointer of NULL and both the
        // owner and wait flags should be clear.
        //

        RtlFillMemory(&Key[0], NUMBER_PROCESSORS, KEY_NOTHING);
        if (SpinLock[Index] != 0) {
            LockOwner = NULL;
            for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                if (LockQueue[Loop][Index].Lock & LOCK_QUEUE_OWNER) {
                    LockOwner = &LockQueue[Loop][Index];
                    break;
                }
            }

            //
            // If the lock owner was not found, then assume that the kernel
            // spin lock points to the owner and the owner bit has not been
            // set yet. Otherwise, fill out the owner/wait key array.
            //

            if (LockOwner == NULL) {
                Number = ProcessorIndex(SpinLock[Index], Index);
                Key[Number - 1] = KEY_OWNER;

                //
                // The owner processor has been determined by the kernel
                // spin lock address. Check to determine if any of the
                // lock queue entries are corrupt and fill in the key
                // array accordingly. A corrupt lock queue entry is one
                // that has a non NULL next field or one of the owner or
                // wait flags is set.
                //

                for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                    if ((LockQueue[Loop][Index].Next != 0) ||
                        (LockQueue[Loop][Index].Lock & (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER))) {
                        Key[Loop] = KEY_CORRUPT;
                    }
                }

            } else {

                //
                // The lock owner was found. Attempt to construct the wait
                // chain.
                //

                Key[Loop] = KEY_OWNER;
                Last = Loop;
                Sequence = 0;
                while (LockOwner->Next != 0) {
                    Number = ProcessorIndex(LockOwner->Next, Index);
                    if (Key[Number - 1] == KEY_NOTHING) {
                        Last = Number - 1;
                        Sequence += 1;
                        Key[Last] = Sequence;
                        LockOwner = &LockQueue[Last][Index];

                    } else {

                        //
                        // The wait chain loops back on itself. Mark the
                        // entry as corrupt and scan the other entries to
                        // detemine if they are also corrupt.
                        //

                        Key[Last] = KEY_CORRUPT;
                        for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                            if ((LockQueue[Loop][Index].Next != 0) ||
                                (LockQueue[Loop][Index].Lock & (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER))) {
                                if (Key[Loop] == KEY_NOTHING) {
                                    Key[Loop] = KEY_CORRUPT;
                                }
                            }
                        }

                        break;
                    }
                }

                //
                // If the lock owner next field is NULL, then the wait
                // search ended normally. Check to determine if the kernel
                // spin lock points to the last entry in the queue.
                //

                if (LockOwner->Next == 0) {
                    Number = ProcessorIndex(SpinLock[Index], Index);
                    if (Last != (Number - 1)) {
                        Sequence += 1;
                        Key[Number - 1] = Sequence;
                    }
                }
            }

        } else {

            //
            // The kernel spin lock is not owned. Check to determine if any
            // of the lock queue entries are corrupt and fill in the key
            // array accordingly. A corrupt entry is one that has a non NULL
            // next field or one of the owner or wait flags is set.
            //

            for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                if ((LockQueue[Loop][Index].Next != 0) ||
                    (LockQueue[Loop][Index].Lock & (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER))) {
                    Key[Loop] = KEY_CORRUPT;
                }
            }
        }

        for (Processor = 0; Processor <= HighestProcessor; Processor++) {
            switch (Key[Processor]) {
            case KEY_CORRUPT:
                dprintf("  C");
                break;
            case KEY_OWNER:
                dprintf("  O");
                break;
            case KEY_NOTHING:
                dprintf("   ");
                break;
            default:
                dprintf("%3d", Key[Processor]);
                break;
            }
        }
        dprintf("\n");
    }

    dprintf("\n");
    return S_OK;
}

ULONG
ProcessorIndex (
    ULONG64 LockAddress,
    ULONG   LockIndex
    )

/*++

Routine Description:

    This function computes the processor number of the respective processor
    given a lock queue address and the lock queue index.

Arguments:

    LockQueue - Supplies a lock queue address in target memory.

Return Value:

    Zero is returned if a matching processor is not found. Otherwise, the
    processor number plus one is returned.

--*/

{

    ULONG64 LockBase;
    ULONG Loop;
    ULONG SizeOfKprcb = GetTypeSize("nt!KPRCB");
    ULONG SizeOfQ = GetTypeSize("nt!KSPIN_LOCK_QUEUE");
    ULONG LockQueueOffset;

    if (GetFieldOffset("nt!KPRCB", "LockQueue", &LockQueueOffset)) {
        dprintf("Unable to read KPRCB type.\n");
        return 0;
    }

    //
    // Attempt to find the lock address in one of the processor control
    // blocks.
    //

    for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
        if ((LockAddress >= ProcessorBlock[Loop]) &&
            (LockAddress < ProcessorBlock[Loop] + SizeOfKprcb)) {
            LockBase = ProcessorBlock[Loop] + LockQueueOffset;
            if (LockAddress == (LockBase + SizeOfQ * LockIndex)) {
                return Loop + 1;
            }
        }
    }

    return 0;
}

PUCHAR QueuedLockName[] = {
    "DispatcherLock",
    "ContextSwapLock",
    "PfnLock",
    "SystemSpaceLock",
    "VacbLock",
    "MasterLock",
    "NonPagedPoolLock",
    "IoCancelLock",
    "WorkQueueLock",
    "IoVpbLock",
    "IoDatabaseLock",
    "IoCompletionLock",
    "NtfsStructLock",
    "AfdWorkQueueLock",
    "BcbLock"
};

DECLARE_API( qlockperf )

/*++

Routine Description:

    Displays queued spin lock performance data (if present).

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // The following structure is used to accumulate data about each
    // acquire/release pair for a lock.
    //

    typedef struct {
        union {
            ULONGLONG   Key;
            struct {
                ULONG_PTR Releaser;
                ULONG_PTR Acquirer;
            };
        };
        ULONGLONG   Time;
        ULONGLONG   WaitTime;
        ULONG       Count;
        ULONG       Waiters;
        ULONG       Depth;
        ULONG       IncreasedDepth;
        ULONG       Clean;
    } QLOCKDATA, *PQLOCKDATA;

    //
    // House keeping data for each lock.
    //

    typedef struct {

        //
        // The following fields are used to keep data from acquire
        // to release.
        //

        ULONGLONG   AcquireTime;
        ULONGLONG   WaitToAcquire;
        ULONG_PTR   AcquirePoint;
        BOOLEAN     Clean;

        //
        // Remaining fields accumulate global stats for this lock.
        //

        ULONG       Count;
        ULONG       Pairs;
        ULONG       FailedTry;
        UCHAR       MaxDepth;
        UCHAR       PreviousDepth;
        ULONG       NoWait;
    } QLOCKHOUSE, *PQLOCKHOUSE;


    ULONG64     TargetHouse;
    ULONG64     TargetLog;
    PQLOCKHOUSE LockHome;
    PQLOCKDATA  LockData;
    QLOCKDATA   TempEntry;
    ULONG       LogEntrySize;
    ULONG       LogSize;
    ULONG       HouseEntrySize;
    ULONG       HouseSize;
    ULONG       NumberOfLocks;
    ULONG       LockIndex;
    ULONG       i, j;
    ULONG       MaxEntriesPerLock;
    ULONG       HighIndex;
    ULONGLONG   HighTime;
    ULONGLONG   TotalHoldTime;
    ULONG       PercentageHeld;
    ULONG64 AcquiredAddress;
    ULONG64 ReleasedAddress;
    UCHAR AcquirePoint[80];
    UCHAR ReleasePoint[80];
    ULONG64 AcquireOffset;
    ULONG64 ReleaseOffset;
    BOOLEAN Verbose = FALSE;
    BOOLEAN Columnar = FALSE;
    BOOLEAN Interesting = FALSE;
    ULONG LockLow, LockHigh;

    //
    // First, see if we can do anything useful.
    //
    // For the moment, this is x86 only.
    //

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("Sorry, don't know how to gather queued spinlock performance\n",
                "data on anything but an x86.\n");
        return E_INVALIDARG;
    }

    //
    // Parse arguments.
    //
    
    if (strstr(args, "?")) {

        //
        // Has asked for usage information.   Give them the options
        // and an explanation of the output.
        //

        dprintf("usage: qlockperf [-v] [n]\n"
                "       -v  indicates verbose output (see below).\n"
                "       -c  verbose columnar output.\n"
                "       -ci verbose columnar output, no totals.\n"
                "       n  supplies the lock number (default is all)\n\n"
                "Verbose output includes details of each lock acquire and\n"
                "release pair.   Two lines per pair.\n\n"
                "Line 1: ppp A symbolic_address R symbolic_address\n"
                "        ppp    percentage, this pair for this lock (overall)\n"
                "        A      Acquire point\n"
                "        R      Release point\n\n"
                "Line 2:\n"
                "        HT     Hold Time total (average)\n"
                "               This is the time from acquire to release.\n"
                "        WT     Wait Time total (average)\n"
                "               This is the time waiting to acquire.\n"
                "        C      Count\n"
                "               Number of times this pair occured.\n"
                "        CA     Clean Acquires (percentage)\n"
                "               Number of times acquire did not wait.\n"
                "        WC     Waiter Count\n"
                "               Number of processors waiting for this\n"
                "               lock at release.\n"
                "        avD    Average number of waiters (at release).\n"
                "        ID     Increased Depth\n"
                "               Number of times the queue length increased\n"
                "               while the lock was held in this pair.\n"
                );
        return E_INVALIDARG;
    }

    if (strstr(args, "-c")) {
        Verbose = TRUE;
        Columnar = TRUE;
    }

    if (strstr(args, "-ci")) {
        Interesting = TRUE;
    }

    if (strstr(args, "-v")) {
        Verbose = TRUE;
    }

    LockLow = 0;
    LockHigh = 999;

    for (i = 0; args[i]; i++) {
        if ((args[i] >= '0') && (args[i] <= '9')) {
            LockLow = (ULONG)GetExpression(&args[i]);
            LockHigh = LockLow;
        }
    }
   
    TargetHouse = GetExpression("nt!KiQueuedSpinLockHouse");

    //
    // Checking for control C after the first operation that might
    // cause symbol load in case the user has bad symbols and is
    // trying to get out.
    //

    if (CheckControlC()) {
        return E_ABORT;
    }

    TargetLog      = GetExpression("nt!KiQueuedSpinLockLog");
    LogEntrySize   = GetTypeSize("nt!QLOCKDATA");
    LogSize        = GetTypeSize("nt!KiQueuedSpinLockLog");
    HouseEntrySize = GetTypeSize("nt!QLOCKHOUSE");
    HouseSize      = GetTypeSize("nt!KiQueuedSpinLockHouse");

    if (!(TargetHouse &&
          TargetLog &&
          LogEntrySize &&
          LogSize &&
          HouseEntrySize &&
          HouseSize)) {
        dprintf("Sorry, can't find required system data, perhaps this kernel\n",
                "was not built with QLOCK_STAT_GATHER defined?\n");
        return E_INVALIDARG;
    }

    if ((LogEntrySize != sizeof(QLOCKDATA)) ||
        (HouseEntrySize != sizeof(QLOCKHOUSE))) {
        dprintf("Structure sizes in the kernel and debugger extension don't\n",
                "match.  This extension needs to be rebuild to match the\n",
                "running system.\n");
        return E_INVALIDARG;
    }

    NumberOfLocks = HouseSize / HouseEntrySize;
    MaxEntriesPerLock = LogSize / LogEntrySize / NumberOfLocks;
    dprintf("Kernel build with %d PRCB queued spinlocks\n", NumberOfLocks);
    dprintf("(maximum log entries per lock = %d)\n", MaxEntriesPerLock);

    if (LockHigh >= NumberOfLocks) {
        if (LockLow == LockHigh) {
            dprintf("User requested lock %d, system has only %d locks, quitting.\n",
                    LockLow,
                    NumberOfLocks);
            return E_INVALIDARG;
        }
        LockHigh = NumberOfLocks - 1;
    }

    if (NumberOfLocks > 16) {

        //
        // I don't believe it.
        //

        dprintf("The number of locks doesn't seem reasonable, giving up.\n");
        return E_INVALIDARG;
    }

    if (CheckControlC()) {
        return E_ABORT;
    }

    //
    // Allocate space to process the data for one lock at a time.
    //

    LockHome = LocalAlloc(LPTR, sizeof(*LockHome));
    LockData = LocalAlloc(LPTR, sizeof(*LockData) * MaxEntriesPerLock);

    if (!(LockHome && LockData)) {
        dprintf("Couldn't allocate memory for local copies of kernel data.\n",
                "unable to continue.\n");
        goto outtahere;
    }

    for (LockIndex = LockLow; LockIndex <= LockHigh; LockIndex++) {
        if ((!ReadMemory(TargetHouse + (LockIndex * sizeof(QLOCKHOUSE)),
                         LockHome,
                         sizeof(QLOCKHOUSE),
                         &i)) || (i < sizeof(QLOCKHOUSE))) {
            dprintf("unable to read data for lock %d, quitting\n",
                    LockIndex);
            return E_INVALIDARG;
        }

        if (CheckControlC()) {
            goto outtahere;
        }

        if (LockHome->Pairs == 0) {
            continue;
        }
        dprintf("\nLock %d %s\n", LockIndex, QueuedLockName[LockIndex]);
        dprintf("  Acquires %d (%d pairs)\n", LockHome->Count, LockHome->Pairs);
        dprintf("  Failed Tries %d\n", LockHome->FailedTry);
        dprintf("  Maximum Depth (at release) %d\n", LockHome->MaxDepth);
        dprintf("  No Waiters (at acquire) %d (%d%%)\n",
                LockHome->NoWait,
                LockHome->NoWait * 100 / LockHome->Count);

        //
        // Change the following to a parameter saying we want the
        // details.
        //

        if (Verbose) {
            ULONG Entries = LockHome->Pairs;
            PQLOCKDATA Entry;

            if ((!ReadMemory(TargetLog + (LockIndex * MaxEntriesPerLock * sizeof(QLOCKDATA)),
                             LockData,
                             Entries * sizeof(QLOCKDATA),
                             &i)) || (i < (Entries * sizeof(QLOCKDATA)))) {
                dprintf("unable to read data for lock %d, quitting\n",
                        LockIndex);
                return E_INVALIDARG;
            }

            if (CheckControlC()) {
                goto outtahere;
            }

            //
            // Sort table into longest duration.
            //

            TotalHoldTime = 0;
            for (i = 0; i < (Entries - 1); i++) {
                HighTime = LockData[i].Time;
                HighIndex = i;
                for (j = i + 1; j < Entries; j++) {
                    if (LockData[j].Time > HighTime) {
                        HighIndex = j;
                        HighTime = LockData[j].Time;
                    }
                }
                if (HighIndex != i) {

                    //
                    // Swap entries.
                    //

                    TempEntry = LockData[i];
                    LockData[i] = LockData[HighIndex];
                    LockData[HighIndex] = TempEntry;
                }
                TotalHoldTime += LockData[i].Time;
            }
            TotalHoldTime += LockData[Entries-1].Time;
            dprintf("  Total time held %I64ld\n");

            //
            // Print something!
            //

            if (Interesting) {
                dprintf("\n     Average  Average     Count   %% Av.  %%\n"
                        "  %%     Hold     Wait            0w Dp Con\n");
            } else if (Columnar) {
                dprintf("\n                   Total  Average               Total  Average     Count     Clean   %%   Waiters Av Increased   %%\n"
                        "  %%                 Hold     Hold                Wait     Wait                      0w           Dp           Con\n");
            }
            for (i = 0; i < Entries; i++) {

                if (CheckControlC()) {
                    goto outtahere;
                }

                Entry = &LockData[i];

                //
                // Sign extend if necessary.
                //
            
                if (!IsPtr64()) {
                    AcquiredAddress = (ULONG64)(LONG64)(LONG)Entry->Acquirer;
                    ReleasedAddress = (ULONG64)(LONG64)(LONG)Entry->Releaser;
                }

                //
                // Lookup the symbolic addresses.
                //

                GetSymbol(AcquiredAddress, AcquirePoint, &AcquireOffset);
                GetSymbol(ReleasedAddress, ReleasePoint, &ReleaseOffset);

                PercentageHeld = (ULONG)(Entry->Time * 100 / TotalHoldTime);

                if (Interesting) {
                    dprintf("%3d%9d%9d%10d%4d%3d%4d %s+0x%x  %s+0x%x\n",
                            PercentageHeld,
                            (ULONG)(Entry->Time / Entry->Count),
                            (ULONG)(Entry->WaitTime / Entry->Count),
                            Entry->Count,
                            Entry->Clean * 100 / Entry->Count,
                            Entry->Depth / Entry->Count,
                            Entry->IncreasedDepth * 100 / Entry->Count,
                            AcquirePoint, (ULONG)AcquireOffset,
                            ReleasePoint, (ULONG)ReleaseOffset);

                } else if (Columnar) {
                    dprintf("%3d %20I64ld%9d%20I64ld%9d",
                            PercentageHeld,
                            Entry->Time,
                            (ULONG)(Entry->Time / Entry->Count),
                            Entry->WaitTime,
                            (ULONG)(Entry->WaitTime / Entry->Count));
                    dprintf("%10d%10d%4d%10d%3d%10d%4d %s+0x%x  %s+0x%x\n",
                            Entry->Count,
                            Entry->Clean,
                            Entry->Clean * 100 / Entry->Count,
                            Entry->Waiters,
                            Entry->Depth / Entry->Count,
                            Entry->IncreasedDepth,
                            Entry->IncreasedDepth * 100 / Entry->Count,
                            AcquirePoint, (ULONG)AcquireOffset,
                            ReleasePoint, (ULONG)ReleaseOffset);

                } else {
                    dprintf("%3d A %s+0x%x R %s+0x%x\n", 
                            PercentageHeld,
                            AcquirePoint, (ULONG)AcquireOffset,
                            ReleasePoint, (ULONG)ReleaseOffset);
                    dprintf("   HT %I64ld (av %I64ld), WT %I64ld (av %I64ld), C %d, CA %d (%d%%) WC %d, (avD %d) ID %d (%d%%)\n",
                            Entry->Time,
                            Entry->Time / Entry->Count,
                            Entry->WaitTime,
                            Entry->WaitTime / Entry->Count,
                            Entry->Count,
                            Entry->Clean,
                            Entry->Clean * 100 / Entry->Count,
                            Entry->Waiters,
                            Entry->Depth / Entry->Count,
                            Entry->IncreasedDepth,
                            Entry->IncreasedDepth * 100 / Entry->Count);
                    dprintf("\n");
                }
            }
        }
    }

outtahere:
    if (LockHome) {
        LocalFree(LockHome);
    }
    if (LockData) {
        LocalFree(LockData);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\remlock.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "precomp.h"
//#include <nt.h>
//#include <ntos.h>
//#include <io.h>

//
// From remlock.h
//
#define IO_REMOVE_LOCK_SIG     'COLR'

/*
typedef struct FULL_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
} FULL_REMOVE_LOCK;
*/
typedef union _REMLOCK_FLAGS {

    struct {
        ULONG   Checked: 1;
        ULONG   Filler: 31;
    };

    ULONG Raw;

} REMLOCK_FLAGS;



DECLARE_API ( remlock )

/*++

Routine Description:

   Dump a remove lock structure

--*/
{
    ULONG64 memLoc=0;
    UCHAR   buffer[256];
    ULONG   result;
    ULONG64 blockLoc;
    UCHAR   allocateTag[8];
    REMLOCK_FLAGS flags;
//    FULL_REMOVE_LOCK fullLock;
//    IO_REMOVE_LOCK_DBG_BLOCK dbgLock;
//    IO_REMOVE_LOCK_COMMON_BLOCK commonLock;
//    IO_REMOVE_LOCK_TRACKING_BLOCK  block;
    ULONG64 pDbgLock;
    ULONG64 pCommonLock;
    ULONG64 pBlock;
    ULONG   IoCount, Removed, Signature;
    
    buffer[0] = '\0';

    if (!*args) {
        memLoc = EXPRLastDump;
    } else {
        if (GetExpressionEx(args, &memLoc, &args)) {
            strcpy(buffer, args);
        }
    }

    flags.Raw = 0;
    if ('\0' != buffer[0]) {
        flags.Raw = (ULONG) GetExpression(buffer);
    }

    dprintf ("Dump Remove Lock: %I64x %x ", memLoc, flags.Raw);

    if (flags.Checked) {
        ULONG Sz = GetTypeSize("IO_REMOVE_LOCK_COMMON_BLOCK");

        dprintf ("as Checked\n");

        pCommonLock = memLoc; pDbgLock = memLoc + Sz;

        if (GetFieldValue (pCommonLock, "IO_REMOVE_LOCK_COMMON_BLOCK", 
                           "Removed", Removed) ||
            GetFieldValue (pDbgLock, "IO_REMOVE_LOCK_DBG_BLOCK", 
                           "Signature", Signature)) {
            dprintf ("Could not read memLock extension\n");
            return E_INVALIDARG;
        }

        if (IO_REMOVE_LOCK_SIG != Signature) {
            dprintf ("Signature does not match that of a remove lock\n");
            return E_INVALIDARG;
        }

    } else {
        dprintf ("as Free\n");
        pCommonLock = memLoc;
        if (GetFieldValue (memLoc, "IO_REMOVE_LOCK_COMMON_BLOCK", 
                           "Removed", Removed)) {
            dprintf ("Could not read memLock extension\n");
            return E_INVALIDARG;
        }
    }


    GetFieldValue (pCommonLock, "IO_REMOVE_LOCK_COMMON_BLOCK", "IoCount", IoCount);
    dprintf ("IsRemoved %x, IoCount %x\n", Removed, IoCount);

    if (flags.Checked) { // checked
        SYM_DUMP_PARAM sym = { 0 };

        sym.sName = (PUCHAR) "PCHAR";
        sym.size = sizeof(sym);

        InitTypeRead(pDbgLock, IO_REMOVE_LOCK_DBG_BLOCK);
        allocateTag [4] = '\0';
        * (PULONG) allocateTag = (ULONG) ReadField(AllocateTag);

        dprintf ("HighWatermark %x, MaxLockedTicks %I64x, AllocateTag %s \n",
                 (ULONG) ReadField(HighWatermark),
                 ReadField(MaxLockedTicks),
                 allocateTag);

        blockLoc = ReadField(Blocks);
        while (blockLoc) {
            ULONG offset = 0;

            InitTypeRead(blockLoc, _IO_REMOVE_LOCK_TRACKING_BLOCK);

            dprintf ("Block Tag %p Line %d TimeLock %I64d\n",
                     ReadField(Tag),
                     (ULONG) ReadField(Line),
                     ReadField(TimeLocked));

            //
            // Using ReadField(File) returns the wrong pointer.  I need a pointer
            // to the pointer value, so we must use the field offset
            //
            if (!GetFieldOffset("_IO_REMOVE_LOCK_TRACKING_BLOCK", "File", &offset)) {
                dprintf("   File ");
                sym.addr = blockLoc + offset; 
                Ioctl(IG_DUMP_SYMBOL_INFO, &sym, sym.size);
            }

            blockLoc = ReadField(Link);
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\sel.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sel.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#pragma hdrstop


DECLARE_API( sel )

/*++

Routine Description:

    Dumps a selector (or range of selectors) from the GDT or LDT and displays
    relevant information about that selector.

Arguments:

    arg - Supplies the selector to examine.  If this is NULL, it dumps a
          range of selectors.

Return Value:

    None

--*/

{

    DESCRIPTOR_TABLE_ENTRY_X86  Entry;
    static ULONG            StartSelector=8;
    static ULONG            EndSelector;
    NTSTATUS                Result;
    ULONG                   dwProcessor=0;
    
    if (!GetCurrentProcessor(Client, &dwProcessor, NULL)) {
        dwProcessor = 0;
    }

    if (*args != '\0') {
        Entry.Selector = (ULONG) GetExpression(args);
        StartSelector=EndSelector=Entry.Selector;
    } else {
        EndSelector=StartSelector+0x80;
        Entry.Selector=StartSelector;
    }
    do {
        Result=LookupSelector((USHORT)dwProcessor,&Entry);
        dprintf("%04x  ",(USHORT)Entry.Selector);
        if (Result == STATUS_SUCCESS) {
            dprintf("Bas=%08lx ", (ULONG)Entry.Descriptor.BaseLow +
                        ((ULONG)Entry.Descriptor.HighWord.Bytes.BaseMid << 16) +
                        ((ULONG)Entry.Descriptor.HighWord.Bytes.BaseHi  << 24) );
            dprintf("Lim=%08lx ", (ULONG)Entry.Descriptor.LimitLow +
                        (ULONG)(Entry.Descriptor.HighWord.Bits.LimitHi << 16) );
            dprintf((Entry.Descriptor.HighWord.Bits.Granularity) ? "Pages" : "Bytes");
            dprintf(" DPL=%i ",Entry.Descriptor.HighWord.Bits.Dpl);
            dprintf((Entry.Descriptor.HighWord.Bits.Pres) ? " P " : "NP ");

            if (Entry.Descriptor.HighWord.Bits.Type & 0x10) {
                //
                // Code or Data segment descriptor
                //
                if (Entry.Descriptor.HighWord.Bits.Type & 0x8) {
                    //
                    // Code segment descriptor
                    //
                    dprintf("Code  ");
                    if (Entry.Descriptor.HighWord.Bits.Type & 0x2) {
                        //
                        // Read/Execute
                        //
                        dprintf("RE ");
                    } else {
                        dprintf("EO ");
                    }
                } else {
                    //
                    // Data segment descriptor
                    //
                    dprintf("Data  ");
                    if (Entry.Descriptor.HighWord.Bits.Type & 0x2) {
                        //
                        // Read/Write
                        //
                        dprintf("RW ");
                    } else {
                        dprintf("RO ");
                    }
                }
                if (Entry.Descriptor.HighWord.Bits.Type & 0x1) {
                    //
                    // Accessed
                    //
                    dprintf("A ");
                }
            } else {
                //
                // System Segment or Gate Descriptor
                //
                switch (Entry.Descriptor.HighWord.Bits.Type) {
                    case 2:
                        //
                        // LDT
                        //
                        dprintf("LDT  ");
                        break;
                    case 1:
                    case 3:
                    case 9:
                    case 0xB:
                        //
                        // TSS
                        //
                        if (Entry.Descriptor.HighWord.Bits.Type & 0x8) {
                            dprintf("TSS32    ");
                        } else {
                            dprintf("TSS16    ");
                        }
                        if (Entry.Descriptor.HighWord.Bits.Type & 0x2) {
                            dprintf("B ");
                        } else {
                            dprintf("A ");
                        }
                        break;

                    case 4:
                        dprintf("C-GATE16   ");
                        break;
                    case 5:
                        dprintf("TSK-GATE   ");
                        break;
                    case 6:
                        dprintf("I-GATE16   ");
                        break;
                    case 7:
                        dprintf("TRP-GATE16 ");
                        break;
                    case 0xC:
                        dprintf("C-GATE32   ");
                        break;
                    case 0xF:
                        dprintf("T-GATE32   ");
                        break;

                }

            }

            dprintf("\n");

        } else {
            if (Result == STATUS_UNSUCCESSFUL) {
                dprintf("LDT page is invalid\n");
            } else {
                dprintf("Selector is invalid\n");
            }
        }

        Entry.Selector += 8;
    } while ( Entry.Selector < EndSelector );
    StartSelector = EndSelector;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\selector.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    selector.c

Abstract:

    This module allows the host side of the kernel debugger to look up
    selector values in the GDT and LDT of the target machine.

Author:

    John Vert   (jvert) 10-Jun-1991

Revision History:

    Wesley Witt (wesw)  26-Aug-1993  (ported to WinDbg)

--*/

#include "precomp.h"
#pragma hdrstop
#include "i386.h"

#define  SELECTOR_CACHE_LENGTH          6

typedef struct _sc {
        struct _sc            *nextYoungest;
        struct _sc            *nextOldest;
        USHORT                 processor;
        DESCRIPTOR_TABLE_ENTRY_X86 desc;
} SELCACHEENTRY;

SELCACHEENTRY SelectorCache[SELECTOR_CACHE_LENGTH], *selYoungest, *selOldest;

BOOL fInitialized = FALSE;

void
InitSelCache(void)
{
    int     i;

    for(i=0;i<SELECTOR_CACHE_LENGTH;i++){
        SelectorCache[i].nextYoungest = &SelectorCache[i+1];
        SelectorCache[i].nextOldest   = &SelectorCache[i-1];
        SelectorCache[i].processor    = (USHORT)-1;
        SelectorCache[i].desc.Selector = 0;
    }

    SelectorCache[--i].nextYoungest = NULL;
    SelectorCache[0].nextOldest     = NULL;
    selYoungest = &SelectorCache[i];
    selOldest   = &SelectorCache[0];
}

BOOLEAN
FindSelector(USHORT Processor, PDESCRIPTOR_TABLE_ENTRY_X86 pdesc)
{
    int     i;


    for(i=0;i<SELECTOR_CACHE_LENGTH;i++) {
        if (SelectorCache[i].desc.Selector == pdesc->Selector &&
            SelectorCache[i].processor == Processor) {
                *pdesc = SelectorCache[i].desc;
                return TRUE;
        }
    }

    return FALSE;
}

void
PutSelector(USHORT Processor, PDESCRIPTOR_TABLE_ENTRY_X86 pdesc)
{
    selOldest->desc = *pdesc;
    selOldest->processor = Processor;
    (selOldest->nextYoungest)->nextOldest = NULL;
    selOldest->nextOldest    = selYoungest;
    selYoungest->nextYoungest= selOldest;
    selYoungest = selOldest;
    selOldest   = selOldest->nextYoungest;
}


NTSTATUS
LookupSelector(
    IN USHORT Processor,
    IN OUT PDESCRIPTOR_TABLE_ENTRY_X86 pDescriptorTableEntry
    )

/*++

Routine Description:

    Looks up a selector in the GDT or LDT on the host machine.

Arguments:

    Processor - Supplies the processor whose selector is desired.

    pDescriptorTableEntry->Selector - Supplies value of the selector to
                                      be looked up.

    pDescriptorTableEntry->Descriptor - Returns descriptor

Return Value:

    STATUS_SUCCESS - The selector was found in the GDT or LDT, and the
                     Descriptor field pointed to by pDescriptorTableEntry
                     has been filled in with valid data.

    STATUS_UNSUCCESSFUL - The selector's descriptor could not be read from
                     virtual memory.  (Page is invalid or not present)

    STATUS_INVALID_PARAMETER - The selector was not in the GDT or LDT,
                               and the Descriptor field is invalid.

--*/
{
    ULONG64 Address;
    ULONG TableBase=0;
    USHORT TableLimit=0;
    ULONG Result;
    ULONG Index;
    ULONG Off;
    LDT_ENTRY_X86 Descriptor;

    if (!fInitialized) {
        fInitialized = TRUE;
        InitSelCache();
    }

    if (FindSelector(Processor, pDescriptorTableEntry)) {
        return(STATUS_SUCCESS);
    }

    //
    // Fetch the address and limit of the GDT
    //

    if (GetFieldOffset("KPROCESSOR_STATE", "SpecialRegisters.Gdtr.Base", &Off)) {
        dprintf("Cannot find KPROCESSOR_STATE type\n");
        return(STATUS_INVALID_PARAMETER);
    }
    Address = Off;
    ReadControlSpace64((USHORT)Processor, Address,
                     &TableBase, sizeof(TableBase));
    if (!TableBase) {
        return STATUS_INVALID_PARAMETER;
    }

    GetFieldOffset("KPROCESSOR_STATE", "SpecialRegisters.Gdtr.Limit", &Off);
    Address = Off;
    ReadControlSpace64((USHORT)Processor, Address,
                     &TableLimit, sizeof(TableLimit));

    //
    // Find out whether this is a GDT or LDT selector
    //
    if (pDescriptorTableEntry->Selector & 0x4) {

        //
        // This is an LDT selector, so we reload the TableBase and TableLimit
        // with the LDT's Base & Limit by loading the descriptor for the
        // LDT selector.
        //

        ReadMemory((ULONG64) (LONG64) (LONG) (TableBase)+KGDT_LDT_I386,&Descriptor,
                   sizeof(Descriptor),&Result);

        TableBase = ((ULONG)Descriptor.BaseLow +
                    ((ULONG)Descriptor.HighWord.Bits.BaseMid << 16) +
                    ((ULONG)Descriptor.HighWord.Bytes.BaseHi << 24));

        TableLimit = Descriptor.LimitLow;  // LDT can't be > 64k

        if(Descriptor.HighWord.Bits.Granularity == GRAN_PAGE) {

            //
            //  I suppose it's possible, although strange to have an
            //  LDT with page granularity.
            //
            TableLimit <<= PAGE_SHIFT_X86;
        }
    }

    Index = (USHORT)(pDescriptorTableEntry->Selector) & ~0x7;
                                                    // Irrelevant bits
    //
    // Check to make sure that the selector is within the table bounds
    //
    if (Index >= TableLimit) {

        //
        // Selector is out of table's bounds
        //

        return(STATUS_INVALID_PARAMETER);
    }
    ReadMemory((ULONG64) (LONG64) (LONG) TableBase+Index,
               &(pDescriptorTableEntry->Descriptor),
               sizeof(pDescriptorTableEntry->Descriptor),
               &Result);
    if(Result != sizeof(pDescriptorTableEntry->Descriptor)) {
        return(STATUS_UNSUCCESSFUL);
    }

    PutSelector(Processor, pDescriptorTableEntry);
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\session.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    process.c

Abstract:

    WinDbg Extension Api

Author:

    John Richardson (v-johnjr) 05-Nov-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
DumpSession(
    IN char *  pad,
    IN ULONG64 RealProcessBase,
    IN ULONG   Flags,
    IN PCHAR   ImageFileName
    );


DECLARE_API( session )

/*++

Routine Description:

    Dumps the active sessions list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64 ProcessToDump;
    ULONG   SessionToDump;
    ULONG   Flags;
    ULONG Result;
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 Thread;
    PCHAR ImageFileName;
    STRING  string1, string2;
    CHAR  Buf[256];
    CHAR  Buf2[256];
    ULONG ActiveProcessLinksOffset;

    // Dump all processes
    ProcessToDump = 0;
    SessionToDump = 0xFFFFFFFF;
    Flags = 0xFFFFFFFF;

    RtlZeroMemory(Buf, 256);
    if (!sscanf(args,"%lx %lx %s",&SessionToDump, &Flags, Buf)) {
        Flags = 0xFFFFFFFF;
        SessionToDump = 0xFFFFFFFF;
    }
    
    if (Flags == 0xFFFFFFFF) {
        Flags = 3;
    }

    // We use csrss.exe to represent sessions by default
    if (Buf[0] != '\0') {
        ImageFileName = Buf;
    } else {
        ImageFileName = "csrss.exe";
    }
    dprintf("*** !session obsolete, Use !process");
    if (SessionToDump == -1) {
        dprintf(" 0 0 %s\n", ImageFileName);
    } else {
        dprintf(" /s %lx 0 0 %s\n", SessionToDump, ImageFileName);
    }
    dprintf("**** NT ACTIVE SESSION DUMP ****\n");

    ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return E_INVALIDARG;
    }

    if (GetFieldValue( ProcessHead, "nt!_LIST_ENTRY", "Flink", Next)) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return E_INVALIDARG;
    }

    if (Next == 0) {
        dprintf("PsActiveProcessHead is NULL!\n");
        return E_INVALIDARG;
    }

    if (GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActiveProcessLinksOffset)) {
        dprintf("Cannot find nt!_EPROCESS type.\n");
        return E_INVALIDARG;
    }
    //dprintf("Offset %#x\n", ActiveProcessLinksOffset);
    while(Next != ProcessHead) {
        ULONG SessionId;

        if (Next != 0) {
            Process = (Next - ActiveProcessLinksOffset);
        }
        else {
            Process = ProcessToDump;
        }

        if (GetFieldValue( Process, "nt!_EPROCESS", "ImageFileName", Buf2)) {
            dprintf("Unable to read nt!_EPROCESS at %p\n",Process);
            return E_INVALIDARG;
        }

        if (Buf2[0] == '\0' ) {
            strcpy((PCHAR)Buf2,"System Process");
        }

        RtlInitString(&string1, ImageFileName);
        RtlInitString(&string2, (PCSZ) Buf2);

        GetFieldValue( Process, "nt!_EPROCESS", "SessionId" ,SessionId);

        if ( ((SessionToDump == (ULONG) -1) || (SessionToDump == SessionId))
             &&
             RtlCompareString(&string1, &string2, TRUE) == 0) {

            if (DumpSession ("", Process, Flags, ImageFileName) && (Flags & 6)) {
                EXPRLastDump = Process;
                dprintf("\n");
            }

            if (ProcessToDump != 0) {
                return E_INVALIDARG;
            }
        }

        GetFieldValue( Process, "nt!_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (Next == 0) {
            return E_INVALIDARG;
        }
        
        if (CheckControlC()) {
            return E_INVALIDARG;
        }
    }
    return S_OK;
}

DECLARE_API( dss )

/*++

Routine Description:

    Dumps the session space structure

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Result;
    ULONG64 MmSessionSpace;
    ULONG64 MmSessionSpacePtr = 0;
    ULONG64 Wsle;

    MmSessionSpacePtr = GetExpression(args);

    if( MmSessionSpacePtr == 0 ) {
        MmSessionSpacePtr = GetExpression("nt!MmSessionSpace");
        if( !MmSessionSpacePtr ) {
            dprintf("Unable to get address of MmSessionSpace\n");
            return E_INVALIDARG;
        }

        if (!ReadPointer( MmSessionSpacePtr, &MmSessionSpace)) {
            dprintf("Unable to get value of MmSessionSpace\n");
            return E_INVALIDARG;
        }
    } else {
        MmSessionSpace = MmSessionSpacePtr;
    }

    dprintf("MM_SESSION_SPACE at 0x%p\n",
        MmSessionSpace
    );

    if (GetFieldValue(MmSessionSpace, "MM_SESSION_SPACE", "Wsle", Wsle)) {
        dprintf("Unable to get value of MM_SESSION_SPACE at 0x%p\n",MmSessionSpace);
        return E_INVALIDARG;
    }

    GetFieldOffset("MM_SESSION_SPACE", "PageTables", &Result);
    dprintf("&PageTables %p\n",
            MmSessionSpace + Result
            );

    GetFieldOffset("MM_SESSION_SPACE", "PagedPoolInfo", &Result);
    dprintf("&MM_PAGED_POOL_INFO %x\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "Vm", &Result);
    dprintf("&MMSUPPORT %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "Wsle", &Result);
    dprintf("&PMMWSLE %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "Session", &Result);
    dprintf("&MMSESSION %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "WorkingSetLockOwner", &Result);
    dprintf("&WorkingSetLockOwner %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "PagedPool", &Result);
    dprintf("&POOL_DESCRIPTOR %p\n",
            MmSessionSpace + Result
    );

    return S_OK;
}

BOOL
DumpSession(
    IN char *  pad,
    IN ULONG64 RealProcessBase,
    IN ULONG   Flags,
    IN PCHAR   ImageFileName
    )
{
    ULONG NumberOfHandles;
    ULONG Result;
    LARGE_INTEGER RunTime;
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    STRING  string1, string2;
    ULONG Type, SessionId,StackCount;
    ULONG64 ObjectTable,UniqueProcessId, Peb,DirBase;

#define ProcFld(F, V) GetFieldValue(RealProcessBase, "EPROCESS", #F, V)
#define ProcFld2(F) GetFieldValue(RealProcessBase, "EPROCESS", #F, F)

    if (ProcFld(Pcb.Header.Type, Type)) {
        dprintf("Unable to read EPROCESS at %p\n", RealProcessBase);
        return FALSE;
    }

    if (Type != (ULONG) ProcessObject) {
        dprintf("TYPE mismatch for process object at %p\n",RealProcessBase);
        return FALSE;
    }

    ProcFld2(ObjectTable);  ProcFld2(UniqueProcessId); ProcFld2(Peb);
    ProcFld2(SessionId);    ProcFld(Pcb.StackCount, StackCount);
    ProcFld(Pcb.DirectoryTableBase[0], DirBase);
    
    NumberOfHandles = 0;
    if (ObjectTable) {
        GetFieldValue(ObjectTable,
                      "HANDLE_TABLE",
                      "HandleCount",
                      NumberOfHandles);        
    }

    dprintf("%sPROCESS %08p  Cid: %04I64lx    Peb: %08p  SessionId: %08u\n",
            pad,
            RealProcessBase,
            UniqueProcessId,
            Peb,
            SessionId
           );

    // If Pcb.StackCount is 0, PD is not resident!
    if( StackCount == 0 ) {
        dprintf("%s    DirBase: NotResident  ObjectTable: %08p  TableSize: %3u.\n",
                pad,
                ObjectTable,
                NumberOfHandles
                );
    }
    else {
        dprintf("%s    DirBase: %08p  ObjectTable: %08p  TableSize: %3u.\n",
                pad,
                DirBase,
                ObjectTable,
                NumberOfHandles
                );
    }

    dprintf("%s    Image: %s\n",pad,ImageFileName);

#undef ProcFld
#undef ProcFld2
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\stacks.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    stacks.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition
    } KTHREAD_STATE;

typedef enum {

    NO_STACK_ACTION     = 0,
    SKIP_FRAME,
    SKIP_THREAD

} STACKS_ACTION, *PSTACKS_ACTION;

#define ETHREAD_NOT_READABLE    1
#define THREAD_VALID            2
#define FIRST_THREAD_VALID      3
#define NO_THREADS              4

struct _BLOCKER_TREE ;
typedef struct _BLOCKER_TREE BLOCKER_TREE, *PBLOCKER_TREE ;

BOOL
StacksValidateProcess(
    IN ULONG64 RealProcessBase
    );

BOOL
StacksValidateThread(
    IN ULONG64 RealThreadBase
    );

VOID StacksDumpProcessAndThread(
    IN ULONG64   RealProcessBase,
    IN ULONG     ThreadDesc,
    IN ULONG64   RealThreadBase,
    IN PBLOCKER_TREE BlockerTree,
    IN ULONG     Verbosity,
    IN char *    Filter
    );

VOID StacksGetThreadStateName(
    IN ULONG ThreadState,
    OUT PCHAR Dest
    );

VOID
DumpThreadBlockageInfo (
    IN char   *pad,
    IN ULONG64 RealThreadBase,
    IN ULONG   Verbosity
    );

typedef enum {

    STACK_WALK_DUMP_STARTING = 0,
    STACK_WALK_DUMP_NOT_RESIDENT,
    STACK_WALK_DUMP_ENTRY,
    STACK_WALK_DUMP_FINISHED

} WALK_STAGE;

typedef struct {

    ULONG   Verbosity;
    BOOLEAN FirstEntry;
    char*   ThreadState;
    char*   ThreadBlocker;
    ULONG   ProcessCid;
    ULONG   ThreadCid;
    ULONG64 ThreadBlockerDisplacement;

} STACK_DUMP_CONTEXT, *PSTACK_DUMP_CONTEXT;

typedef BOOLEAN (*PFN_FRAME_WALK_CALLBACK)(
    IN WALK_STAGE   WalkStage,
    IN ULONG64      RealThreadBase,
    IN PVOID        Context,
    IN char *       Buffer,
    IN ULONG64      Offset
    );

VOID
ForEachFrameOnThread(
    IN ULONG64                 RealThreadBase,
    IN PFN_FRAME_WALK_CALLBACK Callback,
    IN PVOID                   Context
    );

BOOLEAN
StacksDumpStackCallback(
    IN WALK_STAGE   WalkStage,
    IN ULONG64      RealThreadBase,
    IN PVOID        Context,
    IN char *       Buffer,
    IN ULONG64      Offset
    );

extern ULONG64 STeip, STebp, STesp;
static ULONG64 PspCidTable;

ULONG64 ProcessLastDump;
ULONG64 ThreadLastDump;

ULONG TotalProcessCommit;

struct _BLOCKER_TREE {
   char const *Symbolic ;
   STACKS_ACTION Action ;
   PBLOCKER_TREE Child ;
   PBLOCKER_TREE Sibling ;
   PBLOCKER_TREE Parent ;
   BOOL Nested ;
} ;

VOID
AnalyzeThread(
    IN  ULONG64         RealThreadBase,
    IN  PBLOCKER_TREE   BlockerTree,
    IN  char *          Filter,
    OUT PCHAR           BlockSymbol,
    OUT ULONG64        *BlockDisplacement,
    OUT BOOLEAN        *SkipThread
    );

BOOL
BlockerTreeWalk(
   IN OUT PBLOCKER_TREE *blockerHead,
   IN char *szSymbolic,
   IN STACKS_ACTION Action
   );

PBLOCKER_TREE
BlockerTreeBuild(
   VOID
   ) ;

VOID
BlockerTreeFree(
   IN PBLOCKER_TREE BlockerTree
   ) ;

DECLARE_API( stacks )

/*++

Routine Description:

    Dumps the active process list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Result;
    ULONG64 Next;
    ULONG64 NextThread;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 Thread;
    ULONG64 UserProbeAddress;
    ULONG Verbosity = 0, ThreadCount = 0;
    ULONG ActProcOffset, ThrdListOffset, ThrdEntryOffset;
    PBLOCKER_TREE blockerTree ;
    char szFilter[256];

    blockerTree = BlockerTreeBuild() ;

    if (sscanf(args, "%x %s", &Verbosity, szFilter) < 2) {

        szFilter[0] = '\0';
    }

    dprintf("Proc.Thread  .Thread  ThreadState  Blocker\n") ;

    UserProbeAddress = GetNtDebuggerDataValue(MmUserProbeAddress);
    ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead!\n");
        goto Exit;
    }

    if (GetFieldValue( ProcessHead, "nt!_LIST_ENTRY", "Flink", Next )) {
        dprintf("Unable to get value of PsActiveProcessHead.Flink\n");
        goto Exit ;
    }

    if (Next == 0) {
        dprintf("PsActiveProcessHead is NULL!\n");
        goto Exit;
    }

    GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActProcOffset);
    GetFieldOffset("nt!_EPROCESS", "Pcb.ThreadListHead", &ThrdListOffset);
    GetFieldOffset("nt!_KTHREAD",  "ThreadListEntry",    &ThrdEntryOffset);

    while(Next != ProcessHead) {
        ULONG64 FirstThread;

        Process = Next - ActProcOffset;

        if (GetFieldValue( Process, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", FirstThread )) {
            dprintf("Unable to read nt!_EPROCESS at %p\n",Process);
            goto Exit;
        }

        NextThread = FirstThread;
        if (!StacksValidateProcess(Process)) {

            dprintf("Process list damaged, or maybe symbols are incorrect?\n%p\n",Process);
            goto Exit;
        }

        if (NextThread == Process + ThrdListOffset) {

            StacksDumpProcessAndThread(Process, NO_THREADS, 0, blockerTree, Verbosity, szFilter) ;

        } else {

            while ( NextThread != Process + ThrdListOffset) {
                ULONG64 ThreadFlink;

                Thread = NextThread - ThrdEntryOffset;
                if (GetFieldValue(Thread,
                                  "nt!_ETHREAD",
                                  "Tcb.ThreadListEntry.Flink",
                                  ThreadFlink)) {

                    StacksDumpProcessAndThread(Process, ETHREAD_NOT_READABLE, 0, blockerTree, Verbosity, szFilter) ;

                    dprintf("Unable to read _ETHREAD at %lx\n",Thread);
                    break;
                }

                if (!StacksValidateThread(Thread)) {

                    StacksDumpProcessAndThread( Process, ETHREAD_NOT_READABLE, 0, blockerTree, Verbosity, szFilter) ;
                } else if (NextThread == FirstThread) {

                    ThreadCount++;
                    StacksDumpProcessAndThread(Process, FIRST_THREAD_VALID, Thread, blockerTree, Verbosity, szFilter) ;
                } else {

                    ThreadCount++;
                    StacksDumpProcessAndThread(Process, THREAD_VALID, Thread, blockerTree, Verbosity, szFilter) ;
                }

                NextThread = ThreadFlink;
                if (CheckControlC()) {
                    goto Exit;
                }
            }
        }

        EXPRLastDump = Process;
        ProcessLastDump = Process;
        dprintf("\n");
        GetFieldValue( Process, "nt!_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (CheckControlC()) {
            goto Exit;
        }
    }
Exit:
   BlockerTreeFree(blockerTree) ;
   dprintf("\nThreads Processed: %d\n", ThreadCount);
   return S_OK;
}

BOOL
StacksValidateProcess(
    IN ULONG64 RealProcessBase
    )
{
    ULONG Type;

    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.Header.Type", Type);
    if (Type != ProcessObject) {
        dprintf("TYPE mismatch for process object at %p\n",RealProcessBase);
        return FALSE;
    }
    return TRUE ;
}

VOID StacksDumpProcessAndThread(
    IN ULONG64       RealProcessBase,
    IN ULONG         ThreadDesc,
    IN ULONG64       RealThreadBase,
    IN PBLOCKER_TREE BlockerTree,
    IN ULONG         Verbosity,
    IN char *        Filter
    )
{
    ULONG NumberOfHandles;
    ULONG Result;
    CHAR  Buf[512];
    CHAR  ThreadState[13] ;
    CHAR  ThreadBlocker[256] ;
    UINT  i ;
    ULONG64 ObjectTable, ThreadBlockerDisplacement;
    CHAR *ThreadStateName ;
    ULONG UniqueProcessCid;
    STACK_DUMP_CONTEXT dumpData;
    BOOLEAN SkipThread;

    NumberOfHandles = 0;
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ImageFileName", Buf);

    InitTypeRead(RealProcessBase, nt!_EPROCESS);

    if (ObjectTable = ReadField(ObjectTable)) {
        GetFieldValue(ObjectTable, "nt!_HANDLE_TABLE", "HandleCount", NumberOfHandles);
    }

    if (Buf[0] == '\0' ) {
        strcpy((char *)Buf,"System Process");
    }

    UniqueProcessCid = (ULONG) ReadField(UniqueProcessId);

    if (!RealThreadBase) {

        switch(ThreadDesc) {

            case NO_THREADS:

                dprintf("                            [%p %s]\n", RealProcessBase, Buf) ;

                if ((Verbosity > 0) && (Filter[0] == '\0')) {
                    dprintf("%4lx.------  NOTHREADS\n",
                        UniqueProcessCid
                        );
                }

                break ;

            case ETHREAD_NOT_READABLE:

                dprintf("%4lx.------  NO ETHREAD DATA\n",
                    UniqueProcessCid
                    );

                break ;
        }

        return;
    }

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    ASSERT(((ULONG) ReadField(Cid.UniqueProcess)) == UniqueProcessCid);

    StacksGetThreadStateName((ULONG) ReadField(Tcb.State), ThreadState) ;
    i=strlen(ThreadState) ;
    while(i<11) ThreadState[i++]=' ' ;
    ThreadState[i]='\0' ;

    AnalyzeThread(
        RealThreadBase,
        BlockerTree,
        Filter,
        ThreadBlocker,
        &ThreadBlockerDisplacement,
        &SkipThread
        );

    if (ThreadDesc == FIRST_THREAD_VALID) {

        dprintf("                            [%p %s]\n", RealProcessBase, Buf) ;
    }

    if (SkipThread && ((Verbosity == 0) || (Filter[0]))) {

        return;
    }

    dumpData.Verbosity = Verbosity;
    dumpData.ThreadState = ThreadState;
    dumpData.ThreadBlocker = ThreadBlocker;
    dumpData.ThreadBlockerDisplacement = ThreadBlockerDisplacement;
    dumpData.ProcessCid = UniqueProcessCid;
    dumpData.ThreadCid = (ULONG) ReadField(Cid.UniqueThread);

    ForEachFrameOnThread(
        RealThreadBase,
        StacksDumpStackCallback,
        (PVOID) &dumpData
        );
}

BOOLEAN
StacksDumpStackCallback(
    IN WALK_STAGE   WalkStage,
    IN ULONG64      RealThreadBase,
    IN PVOID        Context,
    IN char *       Buffer,
    IN ULONG64      Offset
    )
{
    PSTACK_DUMP_CONTEXT dumpData = (PSTACK_DUMP_CONTEXT) Context;

    switch(WalkStage) {

        case STACK_WALK_DUMP_STARTING:

            dprintf("%4lx.%06lx  %08p  %s",
                dumpData->ProcessCid,
                dumpData->ThreadCid,
                RealThreadBase,
                dumpData->ThreadState
                );

            dumpData->FirstEntry = TRUE;
            return TRUE;

        case STACK_WALK_DUMP_FINISHED:

            dumpData->FirstEntry = FALSE;
            dprintf("\n");
            return TRUE;

        case STACK_WALK_DUMP_NOT_RESIDENT:
        case STACK_WALK_DUMP_ENTRY:

            if (dumpData->FirstEntry) {

                dumpData->FirstEntry = FALSE;
            } else {

                dprintf("\n                                  ");
            }
            break;

        default:
            return FALSE;
    }

    if (WalkStage == STACK_WALK_DUMP_NOT_RESIDENT) {

        switch(dumpData->Verbosity) {

            case 0:
            case 1:
            case 2:
                dprintf("Stack paged out");
                break;
        }

        return FALSE;
    }

    switch(dumpData->Verbosity) {

        case 0:
        case 1:
            dprintf("%s", dumpData->ThreadBlocker);
            if (dumpData->ThreadBlockerDisplacement) {
                dprintf( "+0x%1p", dumpData->ThreadBlockerDisplacement );
            }
            dprintf("\n");
            return FALSE;

        case 2:
            dprintf("%s", Buffer);
            if (Offset) {
                dprintf( "+0x%1p", Offset );
            }
            break;
    }

    return TRUE;
}


UCHAR *StacksWaitReasonList[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "WrExecutive",
    "WrFreePage",
    "WrPageIn",
    "WrPoolAllocation",
    "WrDelayExecution",
    "WrSuspended",
    "WrUserRequest",
    "WrEventPairHigh",
    "WrEventPairLow",
    "WrLpcReceive",
    "WrLpcReply",
    "WrVirtualMemory",
    "WrPageOut",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7"};


VOID StacksGetThreadStateName(
    IN ULONG ThreadState,
    OUT PCHAR Dest
    )
{
    switch (ThreadState) {
        case Initialized: strcpy(Dest, "INITIALIZED"); break;
        case Ready:       strcpy(Dest, "READY"); break;
        case Running:     strcpy(Dest, "RUNNING"); break;
        case Standby:     strcpy(Dest, "STANDBY"); break;
        case Terminated:  strcpy(Dest, "TERMINATED"); break;
        case Waiting:     strcpy(Dest, "Blocked"); break;
        case Transition:  strcpy(Dest, "TRANSITION"); break;
        default:          strcpy(Dest, "????") ; break ;
    }
}


BOOL
StacksValidateThread (
    IN ULONG64 RealThreadBase
    )
{
    ULONG Type;

    GetFieldValue(RealThreadBase, "nt!_ETHREAD", "Tcb.Header.Type", Type);
    if (Type != ThreadObject) {
        dprintf("TYPE mismatch for thread object at %p\n",RealThreadBase);
        return FALSE;
    }
    return TRUE ;
}


VOID
DumpThreadBlockageInfo (
    IN char   *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG   Verbosity
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG64 Address;
    ULONG Result;
    ULONG64 WaitBlock;
    ULONG WaitOffset;
    ULONG64 Process;
    CHAR Buffer[80];
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG displacement;
    ULONG64 WaitBlockList;
    ULONG   IrpOffset;

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    if ((ULONG) ReadField(Tcb.State) == Waiting) {
        dprintf("%s (%s) %s %s\n",
            Pad,
            StacksWaitReasonList[(ULONG) ReadField(Tcb.WaitReason)],
            ((ULONG) ReadField(Tcb.WaitMode)==KernelMode) ? "KernelMode" : "UserMode",(ULONG) ReadField(Tcb.Alertable) ? "Alertable" : "Non-Alertable");
        if ( ReadField(Tcb.SuspendCount) ) {
            dprintf("SuspendCount %lx\n",(ULONG) ReadField(Tcb.SuspendCount));
        }
        if ( ReadField(Tcb.FreezeCount) ) {
            dprintf("FreezeCount %lx\n",(ULONG) ReadField(Tcb.FreezeCount));
        }

        WaitBlockList = ReadField(Tcb.WaitBlockList);

        if (InitTypeRead(WaitBlockList,nt!KWAIT_BLOCK)) {
            dprintf("%sunable to get Wait object\n",Pad);
            goto BadWaitBlock;
        }

        do {
            ULONG64 Object, NextWaitBlock, OwnerThread;
            ULONG Limit;

            dprintf("%s    %lx  ",Pad, Object = ReadField(Object));
            NextWaitBlock = ReadField(NextWaitBlock);

            if (InitTypeRead(Object,nt!KMUTANT)) {

                dprintf("%sunable to get Wait object\n",Pad);
                break;
            }

            GetFieldValue(Object, "nt!KSEMAPHORE", "Limit", Limit);
            GetFieldValue(Object, "nt!KSEMAPHORE", "OwnerThread",OwnerThread);
            switch (ReadField(Header.Type)) {
                case EventNotificationObject:
                    dprintf("NotificationEvent\n");
                    break;
                case EventSynchronizationObject:
                    dprintf("SynchronizationEvent\n");
                    break;
                case SemaphoreObject:
                    dprintf("Semaphore Limit 0x%p\n",
                             Limit);
                    break;
                case ThreadObject:
                    dprintf("Thread\n");
                    break;
                case TimerNotificationObject:
                    dprintf("NotificationTimer\n");
                    break;
                case TimerSynchronizationObject:
                    dprintf("SynchronizationTimer\n");
                    break;
                case EventPairObject:
                    dprintf("EventPair\n");
                    break;
                case ProcessObject:
                    dprintf("ProcessObject\n");
                    break;
                case MutantObject:
                    dprintf("Mutant - owning thread %p\n",
                            OwnerThread);
                    break;
                default:
                    dprintf("Unknown\n");
                    break;
            }

            if (NextWaitBlock == WaitBlockList) {
                break;
            }

            if (InitTypeRead(NextWaitBlock,nt!KWAIT_BLOCK)) {
                dprintf("%sunable to get Wait object\n",Pad);
                break;
            }
        } while ( TRUE );
    }

BadWaitBlock:

    //
    // Re-intialize thread read
    //
    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    if ( ReadField(LpcReplyMessageId) != 0) {
        dprintf("%sWaiting for reply to LPC MessageId %08x:\n",Pad, (ULONG) ReadField(LpcReplyMessageId));
    }

    if (Address = ReadField(LpcReplyMessage)) {
        ULONG64 Entry_Flink, Entry_Blink;

        dprintf("%sPending LPC Reply Message:\n",Pad);

        if (GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Blink", Entry_Blink)) {
            dprintf("unable to get LPC msg\n");
        } else {
            GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Flink", Entry_Flink);
            dprintf("%s    %08p: [%08p,%08p]\n",
                    Pad, Address, Entry_Blink, Entry_Flink
                   );
        }
    }

    GetFieldOffset("nt!_ETHREAD", "IrpList", &IrpOffset);

    if (ReadField(IrpList.Flink) != ReadField(IrpList.Blink) ||
        ReadField(IrpList.Flink) != RealThreadBase + IrpOffset
       ) {

        ULONG64 IrpListHead = RealThreadBase + IrpOffset;
        ULONG64 Next;
        ULONG Counter = 0;
        ULONG IrpThrdOff;

        Next = ReadField(IrpList.Flink);

        GetFieldOffset("nt!_IRP", "ThreadListEntry", &IrpThrdOff);

        dprintf("%sIRP List:\n",Pad);
        while ((Next != IrpListHead) && (Counter < 17)) {
            ULONG Irp_Type=0, Irp_Size=0, Irp_Flags=0;
            ULONG64 Irp_MdlAddress=0;

            Counter += 1;

            Address = Next - IrpThrdOff;

            GetFieldValue(Address, "nt!_IRP", "Type",          Irp_Type);
            GetFieldValue(Address, "nt!_IRP", "Size",          Irp_Size);
            GetFieldValue(Address, "nt!_IRP", "Flags",         Irp_Flags);
            GetFieldValue(Address, "nt!_IRP", "MdlAddress",    Irp_MdlAddress);
            GetFieldValue(Address, "nt!_IRP", "ThreadListEntry.Flink",  Next);

            dprintf("%s    %08p: (%04x,%04x) Flags: %08lx  Mdl: %08lp\n",
                    Pad,Address,Irp_Type,Irp_Size,Irp_Flags,Irp_MdlAddress);

        }
    }

}

VOID
ForEachFrameOnThread(
    IN ULONG64                 RealThreadBase,
    IN PFN_FRAME_WALK_CALLBACK Callback,
    IN PVOID                   Context
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    CHAR Buffer[256];
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG64 displacement, tcb_KernelStackResident;
    EXTSTACKTRACE64 stk[MAX_STACK_FRAMES];

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    tcb_KernelStackResident = ReadField(Tcb.KernelStackResident);

    if (!tcb_KernelStackResident) {

        if (Callback(STACK_WALK_DUMP_STARTING, RealThreadBase, Context, NULL, 0)) {

            Callback(STACK_WALK_DUMP_NOT_RESIDENT, RealThreadBase, Context, NULL, 0);
            Callback(STACK_WALK_DUMP_FINISHED, RealThreadBase, Context, NULL, 0);
        }

        return;
    }

    SetThreadForOperation64( &RealThreadBase );
    frames = StackTrace( 0, 0, 0, stk, MAX_STACK_FRAMES );


    if (!Callback(STACK_WALK_DUMP_STARTING, RealThreadBase, Context, NULL, 0)) {

        return;
    }

    for (i=0; i<frames; i++) {

        Buffer[0] = '!';
        GetSymbol(stk[i].ProgramCounter, Buffer, &displacement);

        if (!Callback(
            STACK_WALK_DUMP_ENTRY,
            RealThreadBase,
            Context,
            Buffer,
            displacement)) {

            return;
        }
    }

    Callback(STACK_WALK_DUMP_FINISHED, RealThreadBase, Context, NULL, 0);
}

VOID
AnalyzeThread(
    IN  ULONG64         RealThreadBase,
    IN  PBLOCKER_TREE   BlockerTree,
    IN  char *          Filter,
    OUT PCHAR           BlockBuffer,
    OUT ULONG64        *BlockerDisplacement,
    OUT BOOLEAN        *SkipThread
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    ULONG WaitOffset;
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG64 displacement, tcb_KernelStackResident;
    PBLOCKER_TREE blockerCur ;
    EXTSTACKTRACE64 stk[MAX_STACK_FRAMES];
    BOOLEAN filterMatch, blockerMatch;
    CHAR  tempFrame[256], lcFilter[256], lcFrame[256];

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    tcb_KernelStackResident = ReadField(Tcb.KernelStackResident);

    if (!tcb_KernelStackResident) {

        *SkipThread = TRUE;
        *BlockerDisplacement = 0;
        BlockBuffer[0] = '\0';
        return;
    }

    SetThreadForOperation64( &RealThreadBase );
    frames = StackTrace( 0, 0, 0, stk, MAX_STACK_FRAMES );

    *SkipThread = FALSE;

    BlockBuffer[0] = '!';

    if (Filter[0]) {

        strcpy(lcFilter, Filter);
        _strlwr(lcFilter);
    }

    if (frames == 0) {

         strcpy(BlockBuffer, "?? Kernel stack not resident ??") ;
         *SkipThread = TRUE;
    } else {

        if (ReadField(Tcb.State) == Running) {

            GetSymbol(stk[0].ProgramCounter, BlockBuffer, &displacement);
            *BlockerDisplacement = displacement;

        } else {

            blockerMatch = FALSE;
            filterMatch = FALSE;

            for(i=0; i<frames; i++) {

                GetSymbol(stk[i].ProgramCounter, tempFrame, &displacement);
                if ((!filterMatch) && Filter[0]) {

                    strcpy(lcFrame, tempFrame);
                    _strlwr(lcFrame);
                    if (strstr(lcFrame, lcFilter)) {

                        filterMatch = TRUE;
                    }
                }

                blockerCur = BlockerTree;
                if ((!blockerMatch) &&
                    (!BlockerTreeWalk(&blockerCur, tempFrame, SKIP_FRAME))) {

                    blockerMatch = TRUE;
                    strcpy(BlockBuffer, tempFrame);
                    *BlockerDisplacement = displacement;
                    if (filterMatch || (Filter[0]=='\0')) {
                        break;
                    }
                }
            }

            blockerCur = BlockerTree;
            if (Filter[0]) {

                if (!filterMatch) {

                    *SkipThread = TRUE;
                }

            } else {

                if (BlockerTreeWalk(&blockerCur, BlockBuffer, SKIP_THREAD)) {

                    *SkipThread = TRUE;
                }
            }
        }
    }
}

#define BEGIN_TREE()
#define END_TREE()
#define DECLARE_ENTRY(foo, action) BlockerTreeDeclareEntry(foo, action)
#define BEGIN_LIST() BlockerTreeListBegin()
#define END_LIST() BlockerTreeListEnd()

PBLOCKER_TREE gpCurrentBlocker ;

VOID
BlockerTreeListBegin(
   VOID
   )
{
   //dprintf("Nest for %x\n", gpCurrentBlocker) ;
   ASSERT(!gpCurrentBlocker->Nested) ;
   gpCurrentBlocker->Nested = TRUE ;
}

VOID
BlockerTreeListEnd(
   VOID
   )
{
   //dprintf("Unnest for %x\n", gpCurrentBlocker) ;
   gpCurrentBlocker = gpCurrentBlocker->Parent ;
   ASSERT(gpCurrentBlocker->Nested) ;
   gpCurrentBlocker->Nested = FALSE ;
}

VOID
BlockerTreeDeclareEntry(
   const char      *szSymbolic,
   STACKS_ACTION    StacksAction
   )
{
   PBLOCKER_TREE blockerEntry ;

   blockerEntry = (PBLOCKER_TREE) malloc(sizeof(BLOCKER_TREE)) ;
   if (!blockerEntry) {
      return ;
   }

   memset(blockerEntry, 0, sizeof(BLOCKER_TREE)) ;
   blockerEntry->Symbolic = szSymbolic ;
   blockerEntry->Action = StacksAction;

   if (gpCurrentBlocker->Nested) {
      ASSERT(!gpCurrentBlocker->Child) ;
      //dprintf("Child %x for %x\n", blockerEntry, gpCurrentBlocker) ;
      blockerEntry->Parent = gpCurrentBlocker ;
      gpCurrentBlocker->Child = blockerEntry ;
   } else {
      ASSERT(!gpCurrentBlocker->Sibling) ;
      //dprintf("sibling %x for %x\n", blockerEntry, gpCurrentBlocker) ;
      blockerEntry->Parent = gpCurrentBlocker->Parent ;
      gpCurrentBlocker->Sibling = blockerEntry ;
   }
   gpCurrentBlocker = blockerEntry ;
}

PBLOCKER_TREE
BlockerTreeBuild(
   VOID
   )
{
   BLOCKER_TREE blockerHead ;

   memset(&blockerHead, 0, sizeof(BLOCKER_TREE)) ;

   gpCurrentBlocker = &blockerHead ;

   //
   // Generate the list...
   //
   #include "stacks.h"

   //
   // And return it.
   //
   return blockerHead.Sibling ;
}

VOID BlockerTreeFree(
   PBLOCKER_TREE BlockerHead
   )
{
   PBLOCKER_TREE blockerCur, blockerNext ;

   for(blockerCur = BlockerHead; blockerCur; blockerCur = blockerNext) {
      if (blockerCur->Child) {
         BlockerTreeFree(blockerCur->Child) ;
      }
      blockerNext = blockerCur->Sibling ;
      free(blockerCur) ;
   }
}

BOOL
BlockerTreeWalk(
   IN OUT PBLOCKER_TREE *blockerHead,
   IN char *szSymbolic,
   IN STACKS_ACTION Action
   )
{
   PBLOCKER_TREE blockerCur ;
   const char *blockString, *curString, *strptr;
   char szStringCopy[512];

   for(blockerCur = *blockerHead; blockerCur; blockerCur = blockerCur->Sibling) {

       if (Action != blockerCur->Action) {

           continue;
       }

       blockString = blockerCur->Symbolic;
       curString = szSymbolic;

       strptr = strstr(curString, "!.");
       if (strptr) {

           //
           // This must be an ia64 symbol. Replace the !. with a nice simple !
           //
           strcpy(szStringCopy, curString);
           strcpy(szStringCopy + (strptr - curString) + 1, strptr + 2);
           curString = szStringCopy;
       }

       //
       // Special case "Our Kernel of Many Names"
       //
       if (!_strnicmp(blockString, "nt!", 3)) {

           if ((!_strnicmp(curString, "ntoskrnl!", 9)) ||
               (!_strnicmp(curString, "ntkrnlmp!", 9)) ||
               (!_strnicmp(curString, "ntkrpamp!", 9)) ||
               (!_strnicmp(curString, "ntkrnlpa!", 9))) {

               blockString += 3;
               curString += 9;
           }
       }

       if (!_strcmpi(blockString, curString)) {
           *blockerHead = blockerCur->Child;
           return TRUE;
       }
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\thermal.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    thermal

Abstract:

    WinDbg Extension Api

Author:

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define TZ_LOOP             0x00000001
#define TZ_DUMP_INFO        0x00000002
#define TZ_NO_HEADER        0x80000000

PCHAR    DumpPowerStateMappings[10] = {
    "x", "0", "1", "2", "3", "4", "5", "?", "?", "?"
};

PCHAR    DumpPowerActionMappings[] = {
    "     None",
    " Reserved",
    "    Sleep",
    "Hibernate",
    " Shutdown",
    "    Reset",
    "      Off"
};

PCHAR   DumpDynamicThrottleMapping[] = {
    "    None",
    "Constant",
    " Degrade",
    "Adaptive",
    " Maximum"
};

PCHAR
DumpTimeInStandardForm(
    IN  ULONG64   CurrentTime
    )
/*++

Routine Description:

    Print the Kernel's view of time into something that a user can
    understand

Arguments:

    CurrentTime - Kernel's Idea of time

Return Value:

    None

--*/
{
    static  CHAR    TimeBuffer[256];
    ULONG           TimeIncrement;
    TIME_FIELDS     Times;
    LARGE_INTEGER   RunTime;

    TimeIncrement = GetNtDebuggerDataValue( KeTimeIncrement );
    RunTime.QuadPart = UInt32x32To64(CurrentTime, TimeIncrement);
    RtlTimeToElapsedTimeFields( &RunTime, &Times);
    if (Times.Hour) {
        sprintf(TimeBuffer,"%3ld:%02ld:%02ld.%03lds",
                Times.Hour,
                Times.Minute,
                Times.Second,
                Times.Milliseconds);
    } else if (Times.Minute) {
        sprintf(TimeBuffer,"%02ld:%02ld.%03lds",
                Times.Minute,
                Times.Second,
                Times.Milliseconds);
    } else {
        sprintf(TimeBuffer,"%02ld.%03lds",
                Times.Second,
                Times.Milliseconds);
    }
    return TimeBuffer;
}

PCHAR
DumpMicroSecondsInStandardForm(
    IN  ULONG64 CurrentTime
    )
{
    static CHAR     PerfBuffer[256];
    ULONG64         FreqAddr;
    LARGE_INTEGER   Freq;
    ULONG           Result;
    ULONG64         MicroSeconds;
    ULONG64         MilliSeconds;
    ULONG64         Seconds;
    ULONG64         Minutes;
    ULONG64         Hours;
    ULONG64         Days;

    MicroSeconds = CurrentTime;
    MilliSeconds = MicroSeconds / 1000;
    MicroSeconds = MicroSeconds % 1000;

    Seconds      = MilliSeconds / 1000;
    MilliSeconds = MilliSeconds % 1000;

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    Hours   = Minutes / 60;
    Minutes = Minutes % 60;

    Days  = Hours / 24;
    Hours = Hours % 24;

#if 0
    sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
            (ULONG)Hours,
            (ULONG)Minutes,
            (ULONG)Seconds,
            (ULONG)MilliSeconds,
            (ULONG)MicroSeconds
            );
    return PerfBuffer;
#endif

    if (Hours) {
        sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
                (ULONG)Hours,
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Minutes) {
        sprintf(PerfBuffer,"%02ld:%02ld.%03ld.%03lds",
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Seconds) {
        sprintf(PerfBuffer,"%02ld.%03ld.%03lds",
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else {
        sprintf(PerfBuffer,".%03ld.%03lds",
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    }
    return PerfBuffer;
}


PCHAR
DumpPerformanceCounterInStandardForm(
    IN  ULONG64 CurrentTime
    )
/*++

Routine Description:

    Print a performance counter's view of time into something that a
    user can understand

--*/
{
    static CHAR     PerfBuffer[256];
    ULONG64         FreqAddr;
    LARGE_INTEGER   Freq;
    ULONG           Result;
    ULONG64         MicroSeconds;
    ULONG64         MilliSeconds;
    ULONG64         Seconds;
    ULONG64         Minutes;
    ULONG64         Hours;
    ULONG64         Days;

    FreqAddr = GetExpression( "nt!KdPerformanceCounterRate" );
    if (!FreqAddr || !ReadMemory( FreqAddr, &Freq, sizeof(Freq), &Result) ) {
        sprintf(PerfBuffer,"<unknown rate>");
        return PerfBuffer;
    }


    MicroSeconds = (CurrentTime * 1000000L) / Freq.LowPart;
    MilliSeconds = MicroSeconds / 1000;
    MicroSeconds = MicroSeconds % 1000;

    Seconds      = MilliSeconds / 1000;
    MilliSeconds = MilliSeconds % 1000;

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    Hours   = Minutes / 60;
    Minutes = Minutes % 60;

    Days  = Hours / 24;
    Hours = Hours % 24;

#if 0
    sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
            (ULONG)Hours,
            (ULONG)Minutes,
            (ULONG)Seconds,
            (ULONG)MilliSeconds,
            (ULONG)MicroSeconds
            );
    return PerfBuffer;
#endif

    if (Hours) {
        sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
                (ULONG)Hours,
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Minutes) {
        sprintf(PerfBuffer,"%02ld:%02ld.%03ld.%03lds",
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Seconds) {
        sprintf(PerfBuffer,"%02ld.%03ld.%03lds",
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else {
        sprintf(PerfBuffer,".%03ld.%03lds",
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    }
    return PerfBuffer;
}

VOID
DumpTemperatureInKelvins(
    IN  ULONG                   Temperature
    )
/*++

Routine Description:

    Dumps the temperatures in Kelvins

Arguments:

    Temperature - What to dump in Kelvins

Return Value:

    None

--*/
{
    dprintf(" (%d.%dK)", (Temperature / 10), (Temperature % 10) );
}

VOID
DumpPowerActionPolicyBrief(
    IN  ULONG    Action,
    IN  ULONG    Flags,
    IN  ULONG    EventCode
    )
{
    dprintf("%s  Flags: %08lx   Event: %08lx  ",
            DumpPowerActionMappings[Action],
            Flags,
            EventCode
            );
    if (Flags & POWER_ACTION_QUERY_ALLOWED) {

        dprintf(" Query");

    }
    if (Flags & POWER_ACTION_UI_ALLOWED) {

        dprintf(" UI");

    }
    if (Flags & POWER_ACTION_OVERRIDE_APPS) {

        dprintf(" Override");

    }
    if (Flags & POWER_ACTION_LOCK_CONSOLE) {

        dprintf(" Lock");

    }
    if (Flags & POWER_ACTION_DISABLE_WAKES) {

        dprintf(" NoWakes");

    }
    if (Flags & POWER_ACTION_CRITICAL) {

        dprintf(" Critical");

    }

    if (EventCode & POWER_LEVEL_USER_NOTIFY_TEXT) {

        dprintf(" NotifyText");

    }
    if (EventCode & POWER_LEVEL_USER_NOTIFY_SOUND) {

        dprintf(" NotifySound");

    }
    if (EventCode & POWER_LEVEL_USER_NOTIFY_EXEC) {

        dprintf(" NotifyExec");

    }
    dprintf("\n");
}

VOID
DumpSystemPowerPolicy(
    IN  PCHAR                  Pad,
    IN  ULONG64                Address,
    IN  ULONG                  Flags
    )
/*++

Routine Description:

    System Power Policy change

Arguments:

Return Value:

--*/
{
    UCHAR   temp;

    InitTypeRead(Address, nt!_SYSTEM_POWER_POLICY);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sSYSTEM_POWER_POLICY (R.%d) @ 0x%08p\n",
                Pad, (ULONG) ReadField(Revision), Address);

    }

    temp = (UCHAR) ReadField(DynamicThrottle);
    if (temp > PO_THROTTLE_MAXIMUM) {
        temp = PO_THROTTLE_MAXIMUM;
    }

    dprintf("%s  PowerButton:     ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(PowerButton.Action),
                                (ULONG) ReadField(PowerButton.Flags),
                                (ULONG) ReadField(PowerButton.EventCode));
    dprintf("%s  SleepButton:     ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(SleepButton.Action),
                                (ULONG) ReadField(SleepButton.Flags),
                                (ULONG) ReadField(SleepButton.EventCode));
    dprintf("%s  LidClose:        ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(LidClose.Action),
                                (ULONG) ReadField(LidClose.Flags),
                                (ULONG) ReadField(LidClose.EventCode));
    dprintf("%s  Idle:            ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(Idle.Action),
                                (ULONG) ReadField(Idle.Flags),
                                (ULONG) ReadField(Idle.EventCode));
    dprintf("%s  OverThrottled:   ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(OverThrottled.Action),
                                (ULONG) ReadField(OverThrottled.Flags),
                                (ULONG) ReadField(OverThrottled.EventCode));
    dprintf("%s  IdleTimeout:      %8lx  IdleSensitivity:        %d%%\n",
            Pad,
            (ULONG) ReadField(IdleTimeout),
            (ULONG) ReadField(IdleSensitivity));
    dprintf("%s  MinSleep:               S%s  MaxSleep:               S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(MinSleep)],
            DumpPowerStateMappings[(ULONG) ReadField(MaxSleep)]);
    dprintf("%s  LidOpenWake:            S%s  FastSleep:              S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(LidOpenWake)],
            DumpPowerStateMappings[(ULONG) ReadField(ReducedLatencySleep)]);
    dprintf("%s  WinLogonFlags:    %8lx  S4Timeout:        %8lx\n",
            Pad,
            (ULONG) ReadField(WinLogonFlags),
            (ULONG) ReadField(DozeS4Timeout));
    dprintf("%s  VideoTimeout:     %8d  VideoDim:               %2d\n",
            Pad,
            (ULONG) ReadField(VideoTimeout),
            (ULONG) ReadField(VideoDimDisplay));
    dprintf("%s  SpinTimeout:      %8lx  OptForPower:            %2d\n",
            Pad,
            (ULONG) ReadField(SpindownTimeout),
            (ULONG) ReadField(OptimizeForPower)
            );
    dprintf("%s  FanTolerance:         %4d%% ForcedThrottle:       %4d%%\n",
            Pad,
            (ULONG) ReadField(FanThrottleTolerance),
            (ULONG) ReadField(ForcedThrottle));
    dprintf("%s  MinThrottle:          %4d%% DyanmicThrottle:  %8s (%d)\n",
            Pad, (ULONG) ReadField(MinThrottle),
            DumpDynamicThrottleMapping[temp],
            temp
            );
}

DECLARE_API( popolicy )
/*++

Routine Description:

    Dumps the power policy

Arguments:

Return Value:

--*/
{
    ULONG64                     Address = 0;
    ULONG64                     PolicyAddress;
    ULONG                       Flags = 0;
    ULONG                       Result;

    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (!Address) {

        Address = GetExpression("nt!PopPolicy");
        if (!Address) {

            dprintf("Could not read PopPolicy\n");
            return E_INVALIDARG;

        }
        if (!ReadPointer(Address,
                    &PolicyAddress) ) {

            dprintf("Could not read PopPolicy at %p\n", Address );
            return E_INVALIDARG;

        }
        Address = PolicyAddress;

    }
    if (!Address) {

        dprintf("!popolicy [addr [flags]]\n");
        return E_INVALIDARG;

    }

    if (GetFieldValue( Address,
                       "nt!_SYSTEM_POWER_POLICY",
                       "Revision",
                       Result) ) {

        dprintf("Could not read PopPolicy at %p\n", Address );
        return E_INVALIDARG;

    }

    DumpSystemPowerPolicy( "", Address, Flags );
    return S_OK;
}

VOID
DumpProcessorPowerPolicy(
    IN  PCHAR                  Pad,
    IN  ULONG64                Address,
    IN  ULONG                  Flags
    )
/*++

Routine Description:

    Processor Power Policy change

Arguments:

Return Value:

--*/
{
    ULONG   i;
    ULONG   count;
    ULONG   offset;
    ULONG64 size;

    InitTypeRead(Address, nt!_PROCESSOR_POWER_POLICY);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPROCESSOR_POWER_POLICY %p (Rev .%d)\n",
                Pad,
                Address,
                (ULONG) ReadField(Revision)
                );

    }

    dprintf(
        "%s  DynamicThrottle:                %4d   PolicyCount:                 %8d\n",
        Pad,
        (ULONG) ReadField(DynamicThrottle),
        (ULONG) ReadField(PolicyCount)
        );

    GetFieldOffset("nt!_PROCESSOR_POWER_POLICY", "Policy", &offset);
    Address += offset;
    size = GetTypeSize("nt!_PROCESSOR_POWER_POLICY_INFO");
    count = (ULONG) ReadField(PolicyCount);
    if (count > 3) {

        count = 3;

    }

    //
    // Walk the PROCESSOR_POWER_POLICY_INFO structures
    //
    for (i = 0; i < count; i++) {

        InitTypeRead(Address, nt!_PROCESSOR_POWER_POLICY_INFO);
        dprintf(
            "\n%s  PROCESSOR_POWER_POLICY_INFO %p\n",
            Pad,
            Address
            );
        dprintf(
            "%s  PromotePercent:                 %4d%%  DemotePercent:             %4d%%\n",
            Pad,
            (ULONG) ReadField( PromotePercent ),
            (ULONG) ReadField( DemotePercent )
            );
        dprintf(
            "%s  AllowPromotion:                %5s   AllowDemotion:            %5s\n",
            Pad,
            ( (ULONG) ReadField( AllowPromotion ) ? " TRUE" : "FALSE"),
            ( (ULONG) ReadField( AllowDemotion) ? " TRUE" : "FALSE")
            );
        dprintf(
            "%s  TimeCheck:                %21s (%8p)\n",
            Pad,
            DumpMicroSecondsInStandardForm( ReadField( TimeCheck ) ),
            (ULONG) ReadField( TimeCheck )
            );
        dprintf(
            "%s  PromoteLimit:             %21s (%8p)\n",
            Pad,
            DumpMicroSecondsInStandardForm( ReadField( PromoteLimit ) ),
            (ULONG) ReadField( PromoteLimit )
            );
        dprintf(
            "%s  DemoteLimit:              %21s (%8p)\n",
            Pad,
            DumpMicroSecondsInStandardForm( ReadField( DemoteLimit ) ),
            (ULONG) ReadField( DemoteLimit )
            );
        Address += size;

    }

}

DECLARE_API( poprocpolicy )
/*++

Routine Description:

    Dumps the power policy

Arguments:

Return Value:

--*/
{
    ULONG64                     Address = 0;
    ULONG64                     PolicyAddress;
    ULONG                       Flags = 0;
    ULONG                       Result;

    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (!Address) {

        Address = GetExpression("nt!PopProcessorPolicy");
        if (!Address) {

            dprintf("Could not read PopProcessorPolicy\n");
            return E_INVALIDARG;

        }
        if (!ReadPointer(Address,&PolicyAddress) ) {

            dprintf("Could not read PopProcessorPolicy at %p\n", Address );
            return E_INVALIDARG;

        }
        Address = PolicyAddress;

    }
    if (!Address) {

        dprintf("!poprocpolicy [addr [flags]]\n");
        return E_INVALIDARG;

    }

    if (GetFieldValue( Address,"PROCESSOR_POWER_POLICY", "Revision", Result) ) {

        dprintf("Could not read PopProcessorPolicy at %p\n", Address );
        return E_INVALIDARG;

    }

    DumpProcessorPowerPolicy( "", Address, Flags );
    return S_OK;
}

VOID
DumpProcessorPowerState(
    IN  PCHAR                 Pad,
    IN  ULONG64               Address,
    IN  ULONG                 Flags
    )
/*++

Routine Description:

    Processor Power State dump

Arguments:

Return Value:

--*/
{
    ULONG   time;
    ULONG   temp;
    CHAR    FunctionName[256];
    ULONG64 Offset;

    InitTypeRead(Address, nt!_PROCESSOR_POWER_STATE);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPROCESSOR_POWER_STATE %p\n", Pad, Address );

    }

    dprintf(
        "%s  IdleState:          %16p   IdleHandlers:       %16p\n",
        Pad,
        ReadField(IdleState),
        ReadField(IdleHandlers)
        );
    dprintf(
        "%s  C1 Idle Transitions:        %8lx   C1 Idle Time:       %17s\n",
        Pad,
        (ULONG) ReadField( TotalIdleTransitions[0] ),
        DumpPerformanceCounterInStandardForm( ReadField( TotalIdleStateTime[0] ) )
        );
    dprintf(
        "%s  C2 Idle Transitions:        %8lx   C2 Idle Time:       %17s\n",
        Pad,
        (ULONG) ReadField( TotalIdleTransitions[1] ),
        DumpPerformanceCounterInStandardForm( ReadField( TotalIdleStateTime[1] ) )
        );
    dprintf(
        "%s  C3 Idle Transitions:        %8lx   C3 Idle Time:       %17s\n\n",
        Pad,
        (ULONG) ReadField( TotalIdleTransitions[2] ),
        DumpPerformanceCounterInStandardForm( ReadField( TotalIdleStateTime[2] ) )
        );
    dprintf(
        "%s  DebugDelta:         %16I64x   LastCheck:          %17s\n",
        Pad,
        ReadField(DebugDelta),
        DumpPerformanceCounterInStandardForm( ReadField( LastCheck ) )
        );
    dprintf(
        "%s  DebugCount:                 %8lx   IdleTime.Start:     %17s\n",
        Pad,
        (ULONG) ReadField(DebugCount),
        DumpPerformanceCounterInStandardForm( ReadField( IdleTimes.StartTime ) )
        );
    dprintf(
        "%s  PromotionCheck:             %8lx   IdleTime.End:       %17s\n",
        Pad,
        (ULONG) ReadField(PromotionCheck ),
        DumpPerformanceCounterInStandardForm( ReadField( IdleTimes.EndTime ) )
        );
    dprintf(
        "%s  IdleTime1:                  %8lx   Idle0LastTime:      %17s\n",
        Pad,
        (ULONG) ReadField(IdleTime1),
        DumpTimeInStandardForm( ReadField( Idle0LastTime ) )
        );
    dprintf(
        "%s  IdleTime2:                  %8lx   LastSystTime:       %17s\n",
        Pad,
        (ULONG) ReadField(IdleTime2),
        DumpTimeInStandardForm( ReadField( LastSysTime ) )
        );
    dprintf(
        "%s  CurrentThrottle:                %4d%%  Idle0KernelTimeLimit: %15s\n",
        Pad,
        (ULONG) ReadField(CurrentThrottle),
        DumpTimeInStandardForm( ReadField( Idle0KernelTimeLimit ) )
        );
    dprintf(
        "%s  CurrentThrottleIndex:           %4d   ThermalThrottleLimit:           %4d%%\n",
        Pad,
        (ULONG) ReadField(CurrentThrottleIndex),
        (ULONG) ReadField(ThermalThrottleLimit)
        );
    dprintf(
        "%s  KneeThrottleIndex:              %4d   ThermalThrottleIndex:           %4d\n",
        Pad,
        (ULONG) ReadField(KneeThrottleIndex),
        (ULONG) ReadField(ThermalThrottleIndex)
        );
    dprintf(
        "%s  ThrottleLimitIndex:             %4d   Flags:                      %8x\n",
        Pad,
        (ULONG) ReadField(ThrottleLimitIndex),
        (ULONG) ReadField(Flags)
        );
    dprintf(
        "%s  PerfStates:                 %8p   PerfStatesCount:                %4d\n",
        Pad,
        ReadField(PerfStates),
        (ULONG) ReadField(PerfStatesCount)
        );
    dprintf(
        "%s  ProcessorMinThrottle:           %4d%%  ProcessorMaxThrottle:           %4d%%\n",
        Pad,
        (ULONG) ReadField(ProcessorMinThrottle),
        (ULONG) ReadField(ProcessorMaxThrottle)
        );
    dprintf(
        "%s  PromotionCount:             %8d   DemotionCount:              %8d\n",
        Pad,
        (ULONG) ReadField( PromotionCount ),
        (ULONG) ReadField( DemotionCount )
        );
    dprintf(
        "%s  ErrorCount:                 %8d   RetryCount:                 %8d\n",
        Pad,
        (ULONG) ReadField(ErrorCount),
        (ULONG) ReadField(RetryCount)
        );
    dprintf(
        "%s  LastBusyPercentage:             %4d%%  LastC3Percentage:               %4d%%\n",
        Pad,
        (ULONG) ReadField( LastBusyPercentage ),
        (ULONG) ReadField( LastC3Percentage )
        );
    dprintf(
        "%s  LastAdjustedBusyPercent:        %4d%%\n",
        Pad,
        (ULONG) ReadField(LastAdjustedBusyPercentage)
        );
    dprintf("\n");
    GetSymbol(ReadField(IdleFunction), FunctionName, &Offset);
    dprintf(
        "%s  IdleFunction:            %50s\n",
        Pad,
        FunctionName
        );
    GetSymbol(ReadField(PerfSetThrottle), FunctionName, &Offset);
    dprintf(
        "%s  PerfSetThrottle:         %50s\n",
        Pad,
        FunctionName
        );
    dprintf(
        "%s  PreviousC3StateTime:      %21s (%16p)\n",
        Pad,
        DumpPerformanceCounterInStandardForm( ReadField( PreviousC3StateTime ) ),
        ReadField( PreviousC3StateTime )
        );
    dprintf(
        "%s  PerfSystemTime:           %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( ReadField(PerfSystemTime) ),
        ReadField( PerfSystemTime )
        );
    dprintf(
        "%s  PerfIdleTime:             %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( ReadField(PerfIdleTime) ),
        ReadField( PerfIdleTime )
        );
    dprintf(
        "%s  PerfTickCount:            %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( ReadField(PerfTickCount) ),
        ReadField( PerfTickCount )
        );

    //
    // At this point, go look at the corresponding PRCB to see what the
    // kernel and user times are
    //
    GetFieldOffset("nt!_KPRCB", "PowerState", &temp);
    Address -= temp;
    InitTypeRead( Address, _KPRCB );
    time = (ULONG) ReadField(UserTime) + (ULONG) ReadField(KernelTime);
    dprintf(
        "%s  CurrentSystemTime:        %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( time ),
        time
        );

    //
    // Read the Idle Thread to see what the current idle thread time is
    //
    Address = ReadField( IdleThread );
    InitTypeRead( Address, _KTHREAD );
    time = (ULONG) ReadField(KernelTime);
    dprintf(
        "%s  CurrentIdleTime:          %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( time ),
        time
        );

}

DECLARE_API( poproc )
/*++

Routine Description:

    Dumps the Processor Power State

Arguments:

Return Value:

--*/
{
    ULONG64  Address = 0;
    ULONG64  Pkprcb;
    ULONG    Flags = 0;
    ULONG    processor;
    ULONG64  Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (Address == 0) {

        HRESULT Hr;

        INIT_API();

        GetCurrentProcessor(Client, &processor, NULL);

        Hr = g_ExtData->ReadProcessorSystemData(processor,
                                                DEBUG_DATA_KPRCB_OFFSET,
                                                &Pkprcb,
                                                sizeof(Pkprcb),
                                                NULL);


        if (Hr != S_OK)
        {
            dprintf("Cannot get PRCB address\n");
        }
        else
        {
            InitTypeRead(Pkprcb,nt!_KPRCB);
            Address = ReadField(PowerState);
            if (!Address)
            {
                dprintf("Unable to get PowerState from the PRCB at %p",Pkprcb);
                dprintf("poproc <address>\n");
                Hr = E_INVALIDARG;

            }
        }

        if (Hr != S_OK)
        {
            return Hr;
        }
    }

    if (GetFieldValue( Address,
                       "PROCESSOR_POWER_STATE",
                       "IdleTime1",
                       Result) ) {

        dprintf("Could not read PROCESSOR_POWER_STATE at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Dump the Trigger Information
    //
    DumpProcessorPowerState("", Address, Flags );

    return S_OK;
}

VOID
DumpPowerCapabilities(
    IN  PCHAR                      Pad,
    IN  ULONG64                    Address,
    IN  ULONG                      Flags
    )
/*++

Routine Description:

    Dumps the power capabilities

Arguments:

Return Value:

--*/
{
    InitTypeRead(Address, nt!SYSTEM_POWER_CAPABILITIES);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPopCapabilities @ 0x%08p\n", Pad, Address );

    }

    dprintf("%s  Misc Supported Features: ", Pad);
    if ((ULONG) ReadField(PowerButtonPresent)) {

        dprintf(" PwrButton");
    }
    if ((ULONG) ReadField(SleepButtonPresent)) {

        dprintf(" SlpButton");
    }
    if ((ULONG) ReadField(LidPresent)) {

        dprintf(" Lid");
    }
    if ((ULONG) ReadField(SystemS1)) {

        dprintf(" S1");
    }
    if ((ULONG) ReadField(SystemS2)) {

        dprintf(" S2");
    }
    if ((ULONG) ReadField(SystemS3)) {

        dprintf(" S3");
    }
    if ((ULONG) ReadField(SystemS4)) {

        dprintf(" S4");
    }
    if ((ULONG) ReadField(SystemS5)) {

        dprintf(" S5");
    }
    if ((ULONG) ReadField(HiberFilePresent)) {

        dprintf(" HiberFile");
    }
    if ((ULONG) ReadField(FullWake)) {

        dprintf(" FullWake");
    }
    if ((ULONG) ReadField(VideoDimPresent)) {

        dprintf(" VideoDim");
    }
    dprintf("\n");

    dprintf("%s  Processor Features:      ", Pad);
    if ((ULONG) ReadField(ThermalControl)) {

        dprintf(" Thermal");
    }
    if ((ULONG) ReadField(ProcessorThrottle)) {

        dprintf(" Throttle (MinThrottle = %d%%, Scale = %d%%)",
                (ULONG) ReadField(ProcessorMinThrottle),
                (ULONG) ReadField(ProcessorThrottleScale));

    }
    dprintf("\n");

    dprintf("%s  Disk Features:           ", Pad );
    if ((ULONG) ReadField(DiskSpinDown)) {

        dprintf(" SpinDown");
    }
    dprintf("\n");

    dprintf("%s  Battery Features:        ", Pad);
    if ((ULONG) ReadField(SystemBatteriesPresent)) {

        dprintf(" BatteriesPresent");

    }
    if ((ULONG) ReadField(BatteriesAreShortTerm)) {

        dprintf(" ShortTerm");
    }
    dprintf("\n");
    if ((ULONG) ReadField(SystemBatteriesPresent)) {

        dprintf("%s    Battery 0 - Capacity: %8lx  Granularity: %8lx\n",
                Pad,
                (ULONG) ReadField(BatteryScale[0].Capacity),
                (ULONG) ReadField(BatteryScale[0].Granularity)
                );
        dprintf("%s    Battery 1 - Capacity: %8lx  Granularity: %8lx\n",
                Pad,
                (ULONG) ReadField(BatteryScale[1].Capacity),
                (ULONG) ReadField(BatteryScale[1].Granularity)
                );
        dprintf("%s    Battery 2 - Capacity: %8lx  Granularity: %8lx\n",
                Pad,
                (ULONG) ReadField(BatteryScale[2].Capacity),
                (ULONG) ReadField(BatteryScale[2].Granularity)
                );

    }
    dprintf("%s  Wake Caps\n", Pad);
    dprintf("%s    Ac OnLine Wake:         S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(AcOnLineWake)]);
    dprintf("%s    Soft Lid Wake:          S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(SoftLidWake)]);
    dprintf("%s    RTC Wake:               S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(RtcWake)]);
    dprintf("%s    Min Device Wake:        S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(MinDeviceWakeState)]);
    dprintf("%s    Default Wake:           S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(DefaultLowLatencyWake)]);

}

DECLARE_API( pocaps )
/*++

Routine Description:

    Dumps the power capabilities

Arguments:

Return Value:

--*/
{
    ULONG64                     Address = 0;
    ULONG                       Flags = 0;
    ULONG                       Result;

    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (!Address) {

        Address = GetExpression("nt!PopCapabilities");
        if (!Address) {

            dprintf("Could not read PopCapabilities\n");
            return E_INVALIDARG;

        }

    }
    if (!Address) {

        dprintf("!pocaps [addr [flags]]\n");
        return E_INVALIDARG;

    }
    if (GetFieldValue(Address,
                      "nt!SYSTEM_POWER_CAPABILITIES",
                      "PowerButtonPresent",
                      Result) ) {

        dprintf("Could not read PopCapabilities at %08p\n", Address );
        return E_INVALIDARG;

    }
    DumpPowerCapabilities( "", Address, Flags );
    return S_OK;
}

VOID
DumpPopActionTrigger(
    IN  PCHAR              Pad,
    IN  ULONG64            Address,
    IN  ULONG              Flags
    )
/*++

--*/
{
    ULONG Type, PopFlags;

    InitTypeRead(Address, nt!_POP_ACTION_TRIGGER);

    //
    // Header line
    //
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPOP_ACTION_TRIGGER @ 0x%08p\n", Pad, Address );

    }

    dprintf("%s  Type:  ", Pad);
    switch(Type = (ULONG) ReadField(Type)) {
    case PolicyDeviceSystemButton:
        dprintf("    SystemButton"); break;
    case PolicyDeviceThermalZone:
        dprintf("     ThermalZone"); break;
    case PolicyDeviceBattery:
        dprintf("         Battery"); break;
    case PolicyInitiatePowerActionAPI:
        dprintf("   InitActionAPI"); break;
    case PolicySetPowerStateAPI:
        dprintf("     SetStateAPI"); break;
    case PolicyImmediateDozeS4:
        dprintf("          DozeS4"); break;
    case PolicySystemIdle:
        dprintf("      SystemIdle"); break;
    default:
        dprintf("         Unknown"); break;
    }

    dprintf("  Flags:   %02x%02x%02x%02x",
            (ULONG) ReadField(Spare[2]),
            (ULONG) ReadField(Spare[1]),
            (ULONG) ReadField(Spare[0]),
            (PopFlags = (ULONG) ReadField(Flags)));
    if (PopFlags & PO_TRG_USER) {

        dprintf(" UserAction");

    }
    if (PopFlags & PO_TRG_SYSTEM) {

        dprintf(" SystemAction");

    }
    if (PopFlags & PO_TRG_SYNC) {

        dprintf(" Sync");

    }
    if (PopFlags & PO_TRG_SET) {

        dprintf(" Set");

    }
    dprintf("\n");

    if (Type != PolicyDeviceBattery) {

        dprintf("%s  Wait Trigger:  %08p\n", Pad, ReadField(Wait ));

    } else {

        dprintf("%s  BatteryLevel:  %08lx\n", Pad, (ULONG) ReadField(Battery.Level ));

    }

}

DECLARE_API( potrigger )
/*++

Routine Description:

    Dumps a Pop Action Trigger

Arguments:

Return Value:

--*/
{
    ULONG64             Address = 0;
    ULONG               Flags = 0;
    ULONG               Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        dprintf("potrigger <address>\n");
        return E_INVALIDARG;

    }
    if (GetFieldValue(Address,
                      "nt!_POP_ACTION_TRIGGER",
                      "Type",
                      Result) ) {

        dprintf("Could not read POP_ACTION_TRIGGER at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Dump the Trigger Information
    //
    DumpPopActionTrigger("", Address, Flags );

    return S_OK;
}

VOID
DumpThermalZoneInformation(
    IN  PCHAR                  Pad,
    IN  ULONG64                Address,
    IN  ULONG                  Flags
    )
/*++

Routine Description:

    Displays the thermal zone information structure

Arguments:

Return Value:

--*/
{
    ULONG   i, Count;

    InitTypeRead(Address, nt!_THERMAL_INFORMATION);
    //
    // Header line
    //
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sThermalInfo @ 0x%08p\n", Pad, Address );

    }

    //
    // First line
    //
    dprintf("%s  Stamp:         %08lx  Constant1:  %08lx  Constant2:  %08lx\n",
            Pad,
            (ULONG) ReadField(ThermalStamp),
            (ULONG) ReadField(ThermalConstant1),
            (ULONG) ReadField(ThermalConstant2));

    //
    // Second Line
    //
    dprintf("%s  Affinity:      %08lx  Period:     %08lx  ActiveCnt:  %08lx\n",
            Pad,
            (ULONG) ReadField(Processors),
            (ULONG) ReadField(SamplingPeriod),
            (ULONG) ReadField(ActiveTripPointCount ));

    //
    // Temperatures
    //
    dprintf("%s  Current Temperature:                 %08lx",
            Pad,
            (ULONG) ReadField(CurrentTemperature ));
    DumpTemperatureInKelvins((ULONG) ReadField(CurrentTemperature));
    dprintf("\n");
    dprintf("%s  Passive TripPoint Temperature:       %08lx",
            Pad,
            (ULONG) ReadField(PassiveTripPoint ));
    DumpTemperatureInKelvins((ULONG) ReadField(PassiveTripPoint));
    dprintf("\n");

    //
    // Active trip points
    //
    Count = (ULONG) ReadField(ActiveTripPointCount);
    for (i = 0; i < Count; i++) {
        CHAR Buff[40];
        ULONG Act;

        sprintf(Buff, "ActiveTripPoint[%d]", i);
        dprintf("%s  Active TripPoint Temperature %d:      %08lx",
                Pad,
                i,
                (Act = (ULONG) GetShortField(0, Buff, 0)));
        DumpTemperatureInKelvins(Act);
        dprintf("\n");

    }

    //
    // Dump critical temperatures
    //
    dprintf("%s  Critical TripPoint Temperature:      %08lx",
            Pad,
            (ULONG) ReadField(CriticalTripPoint ));
    DumpTemperatureInKelvins((ULONG) ReadField(CriticalTripPoint));
    dprintf("\n");

}

DECLARE_API( tzinfo )
/*++

Routine Description:

    Dumps the thermal zone information structure

Arguments:

Return Value:

--*/
{
//    THERMAL_INFORMATION ThermalInfo;
    ULONG64             Address = 0;
    ULONG               Flags = 0;
    ULONG               Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        dprintf("tzinfo <address>\n");
        return E_INVALIDARG;

    }
    if (GetFieldValue(Address,
                      "nt!_THERMAL_INFORMATION",
                      "ThermalStamp",
                      Result) ) {

        dprintf("Could not read THERMAL_INFO at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Dump the thermal zone information
    //
    DumpThermalZoneInformation("", Address, Flags );

    return S_OK;
}

VOID
DumpThermalZone(
    IN  ULONG              Count,
    IN  PCHAR              Pad,
    IN  ULONG64            Address,
    IN  ULONG              Flags
    )
/*++

Routine Description:

    Dumps a thermal zone

--*/
{
    ULONG ThFlags, Off1, Off2, LastTemp;

    InitTypeRead(Address, NT!_POP_THERMAL_ZONE);
    //
    // Header line
    //
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%s%d - ThermalZone @ 0x%08p\n", Pad, Count, Address );

    }

    //
    // First line
    //
    dprintf("%s  State:         ",Pad);
    switch ((ULONG) ReadField(State)) {
    case 1: dprintf("    Read"); break;
    case 2: dprintf("Set Mode"); break;
    case 3: dprintf("  Active"); break;
    default:dprintf("No State"); break;
    }
    dprintf("  Flags:               %08lx", (ThFlags = (ULONG) ReadField(Flags)));
    if (ThFlags & PO_TZ_THROTTLING) {
        dprintf(" Throttling");
    }
    if (ThFlags & PO_TZ_CLEANUP) {
        dprintf(" CleanUp");
    }
    dprintf("\n");

    //
    // Second Line
    //
    dprintf("%s  Mode:          ", Pad );
    switch((ULONG) ReadField(Mode)) {
    case 0: dprintf("  Active"); break;
    case 1: dprintf(" Passive"); break;
    default: dprintf(" Invalid"); break;
    }
    dprintf("  PendingMode:         ");
    switch((ULONG) ReadField(PendingMode)) {
    case 0: dprintf("  Active"); break;
    case 1: dprintf(" Passive"); break;
    default: dprintf(" Invalid"); break;
    }
    dprintf("\n");


    dprintf("%s  ActivePoint:   %08lx  PendingTrp:          %08lx\n",
            Pad, (ULONG) ReadField(ActivePoint), (ULONG) ReadField(PendingActivePoint ));
    dprintf("%s  SampleRate:    %08lx  LastTime:    %016I64x\n",
            Pad, (ULONG) ReadField(SampleRate), ReadField(LastTime ));
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "PassiveTimer", &Off1);
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "PassiveDpc", &Off2);
    dprintf("%s  Timer:         %08lx  Dpc:                 %08lx\n",
            Pad,
            Address + Off1,
            Address + Off2);
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "OverThrottled", &Off1);
    dprintf("%s  OverThrottled: %08lx  Irp:                 %08p\n",
            Pad,
            Address + Off1,
            ReadField(Irp ));
    dprintf("%s  Throttle:      %08lx  LastTemp:            %08lx",
            Pad,
            (ULONG) ReadField(Throttle),
            (LastTemp = (ULONG) ReadField(LastTemp )));
    DumpTemperatureInKelvins( LastTemp );
    dprintf("\n");
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "Info", &Off1);
    dprintf("%s  Thermal Info:  %08lx\n",
            Pad,
            Address + Off1);
    if (Flags & TZ_DUMP_INFO) {

        CHAR   buffer[80];

        //
        // Increase the buffer
        //
        sprintf(buffer,"  %s", Pad );

        //
        // Dump the thermal zone
        //
        DumpThermalZoneInformation(
            buffer,
            (Address + Off1),
            (Flags | TZ_NO_HEADER)
            );

    }
}


DECLARE_API( tz )
/*++

Routine Description:


Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64             Address = 0;
    ULONG               Count = 0;
    ULONG64             EndAddress = 0, Flink;
    ULONG               Flags = 0;
    ULONG               Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        Address = GetExpression("nt!PopThermal");
        if (!Address) {

            dprintf("Could not read PopThermal\n");
            return E_INVALIDARG;

        }
        if (GetFieldValue(Address,
                          "nt!_LIST_ENTRY",
                          "Flink",
                          Flink) ) {

            dprintf("Could not read PopThermal at %08p\n", Address );
            return E_INVALIDARG;

        }
        if (Flink == Address) {

            dprintf("No Thermal Zones\n");
            return E_INVALIDARG;

        }

        Flags |= TZ_LOOP;
        EndAddress = Address;
        Address = Flink;

    } else {

        EndAddress = Address;

    }

    //
    // Now read the proper thermal zone
    //
    if (GetFieldValue(Address,
                      "nt!_LIST_ENTRY",
                      "Flink",
                      Flink) ) {

        dprintf("Could not read LIST_ENTRY at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Do we stop looping?
    //
    if (!Flags & TZ_LOOP) {

        EndAddress = Flink;

    }

    do {

        //
        // Read the thermal zone
        // Try both names for backward compatibility
        //
        if (GetFieldValue(Address, "NT!_POP_THERMAL_ZONE", "Link.Flink", Flink) &&
            GetFieldValue(Address, "NT!POP_THERMAL_ZONE", "Link.Flink", Flink)) {
            dprintf("Could not read THERMAL_ZONE at %08p\n", Address );
            return E_INVALIDARG;
        }

        //
        // Dump the zone
        //
        DumpThermalZone( Count, "", Address, Flags );

        //
        // Check for Control C
        //
        if (CheckControlC()) {
            return E_INVALIDARG;
        }

        //
        // Next
        //
        Address = Flink;
        Count++;

    } while (Address != EndAddress  );
    return S_OK;
}

VOID
DumpPopIdleHandler(
    IN  ULONG64                     Address,
    IN  ULONG                       Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    CHAR    FunctionName[256];
    ULONG64 Offset;

    if (InitTypeRead(Address,nt!_POP_IDLE_HANDLER)) {
        // If the new type name fails, use the old one
        InitTypeRead(Address,nt!POP_IDLE_HANDLER);
    }

    dprintf("PopIdleHandle[%d] - POP_IDLE_HANDLER %p\n",(ULONG)ReadField(State),Address);
    dprintf("  State:                      %8d   PromoteCount:               %8d\n",
            (ULONG)ReadField(State),
            (ULONG)ReadField(PromoteCount)
            );
    dprintf("  DemotePercent:              %8d%%  PromotePercent:            %8d%%\n",
            (ULONG)ReadField(DemotePercent),
            (ULONG)ReadField(PromotePercent)
            );
    dprintf("  Demote:                     %8d   Promote:                    %8d\n",
            (ULONG)ReadField(Demote),
            (ULONG)ReadField(Promote)
            );
    dprintf("\n");
    GetSymbol(ReadField(IdleFunction), FunctionName, &Offset);
    dprintf("  Function:           %27s  (%p)\n",
            FunctionName,
            ReadField(IdleFunction)
            );
    dprintf("  Latency:            %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(Latency) ),
            (ULONG)ReadField(Latency)
            );
    dprintf("  TimeCheck:          %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(TimeCheck) ),
            (ULONG)ReadField(TimeCheck)
            );
    dprintf("  PromoteLimit:       %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(PromoteLimit) ),
            (ULONG)ReadField(PromoteLimit)
            );
    dprintf("  DemoteLimit:        %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(DemoteLimit) ),
            (ULONG) ReadField(DemoteLimit)
            );
    dprintf("\n");

}

DECLARE_API( poidle )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG64             Address = 0;
    ULONG64             Pkprcb;
    ULONG64             PowerState;
    ULONG64             Size;
    ULONG               Loop = 3;
    ULONG               Flags = 0;
    ULONG               processor = 0;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (Address == 0) {

        HRESULT Hr;

        INIT_API();

        GetCurrentProcessor(Client, &processor, NULL);

        Hr = g_ExtData->ReadProcessorSystemData(processor,
                                                DEBUG_DATA_KPRCB_OFFSET,
                                                &Pkprcb,
                                                sizeof(Pkprcb),
                                                NULL);


        if (Hr != S_OK) {

            dprintf("Cannot get PRCB address\n");

        } else {

            InitTypeRead(Pkprcb,nt!_KPRCB);
            PowerState = ReadField(PowerState);
            if (!PowerState) {

                dprintf("Unable to get PowerState from the PRCB at %p",Pkprcb);
                dprintf("poproc <address>\n");
                Hr = E_INVALIDARG;

            }

        }
        if (Hr != S_OK){

            return Hr;

        }

        if (GetFieldValue( PowerState,
                           "PROCESSOR_POWER_STATE",
                           "IdleHandlers",
                           Address) ) {

            dprintf("Could not read PROCESSOR_POWER_STATE at %p\n", PowerState );
            return E_INVALIDARG;

        }

        Loop = 3;

    }

    //
    // We will need to know how large the structure is..
    //
    Size = GetTypeSize("nt!_POP_IDLE_HANDLER");
    if (!Size) {
        Size = GetTypeSize("nt!POP_IDLE_HANDLER");
    }

    do {

        DumpPopIdleHandler( Address, Flags );
        Address += Size;
        if (CheckControlC() || !Loop) {
            break;
        }
        Loop--;

    } while ( Loop );

    return S_OK;
}

VOID
DumpProcessorPerfState(
    IN  ULONG64                     Address,
    IN  ULONG                       Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG64 Value = 0;

    InitTypeRead(Address,nt!PROCESSOR_PERF_STATE);
    dprintf(
        "  Power:  %4dmW",
        (ULONG)ReadField(Power)
        );
    Value = ReadField(Flags);
    if (Value) {
        dprintf("  NonLinear\n");
    } else {
        dprintf("  Linear\n");
    }
    dprintf(
        "    Frequency:     %8d%% MinCapacity:   %8d%%\n",
        (ULONG)ReadField(PercentFrequency),
        (ULONG)ReadField(MinCapacity)
        );
    dprintf(
        "    IncreaseLevel: %8d%% DecreaseLevel: %8d%%\n",
        (ULONG)ReadField(IncreaseLevel),
        (ULONG)ReadField(DecreaseLevel)
        );
    dprintf(
        "    IncreaseCount: %8x  DecreaseCount: %8x\n",
        (ULONG)ReadField(IncreaseCount),
        (ULONG)ReadField(DecreaseCount)
        );
    dprintf(
        "    PerformanceTime: %21s (%8x)\n",
        DumpPerformanceCounterInStandardForm( ReadField(PerformanceTime) ),
        ReadField(PerformanceTime)
        );
    dprintf(
        "    IncreaseTime:    %21s (%8x)\n",
        DumpTimeInStandardForm( (ULONG) ReadField(IncreaseTime) ),
        ReadField(IncreaseTime)
        );
    dprintf(
        "    DecreaseTime:    %21s (%8x)\n",
        DumpTimeInStandardForm( (ULONG) ReadField(DecreaseTime) ),
        ReadField(DecreaseTime)
        );

}

DECLARE_API( poperf )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG64             Address = 0;
    ULONG64             Count = 1;
    ULONG64             Index;
    ULONG64             PolicyAddress;
    ULONG64             Size = 0;
    ULONG               Flags = 0;
    ULONG               Processor;
    ULONG               Prcb;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        HRESULT Hr;

        INIT_API();

        //
        // Fetch them from the current processor's prcb
        //
        GetCurrentProcessor(Client, &Processor, NULL);

        Hr = g_ExtData->ReadProcessorSystemData(
            Processor,
            DEBUG_DATA_KPRCB_OFFSET,
            &Address,
            sizeof(Address),
            NULL
            );
        if (Hr != S_OK) {

            dprintf("Unable to get PRCB address\n");
            return Hr;

        }

        InitTypeRead(Address,nt!_KPRCB);
        PolicyAddress = ReadField(PowerState.PerfStates);
        Count         = ReadField(PowerState.PerfStatesCount);

        //
        // Remember what's the address we will use
        //
        Address = PolicyAddress;
        dprintf("Prcb.PowerState.PerfStates - %p (%d Levels)\n", Address, (ULONG) Count );

    } else {

        dprintf("PROCESSOR_PERF_STATE - %p\n",Address);

    }

    //
    // We will need to know how large the structure is..
    //
    Size = GetTypeSize("nt!PROCESSOR_PERF_STATE");

    //
    // Dump all the states
    //
    for (Index = 0; Index < Count; Index++, Address += Size) {

        DumpProcessorPerfState( Address, Flags );
        if (CheckControlC()) {
            break;
        }

    }

    //
    // Done
    //
    return S_OK;
}

DECLARE_API( whattime )
{
    ULONG64 Address = 0;

    //
    // Get address and flags
    //
    GetExpressionEx(args, &Address, &args);

    dprintf(
        "%d Ticks in Standard Time: %s\n",
        (ULONG) Address,
        DumpTimeInStandardForm( (ULONG) Address )
        );
    return S_OK;
}

DECLARE_API( whatperftime )
{
    ULONG64 Address = 0;

    //
    // Get address and flags
    //
    GetExpressionEx(args, &Address, &args);

    dprintf(
        "%ld Performance Counter in Standard Time: %s\n",
        (ULONG) Address,
        DumpPerformanceCounterInStandardForm( Address )
        );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\srb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    srb.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


PCHAR SrbFunctionTable[] =
{
 "SRB_FUNCTION_EXECUTE_SCSI",       // 0x00
 "SRB_FUNCTION_CLAIM_DEVICE",       // 0x01
 "SRB_FUNCTION_IO_CONTROL",         // 0x02
 "SRB_FUNCTION_RECEIVE_EVENT",      // 0x03
 "SRB_FUNCTION_RELEASE_QUEUE",      // 0x04
 "SRB_FUNCTION_ATTACH_DEVICE",      // 0x05
 "SRB_FUNCTION_RELEASE_DEVICE",     // 0x06
 "SRB_FUNCTION_SHUTDOWN",           // 0x07
 "SRB_FUNCTION_FLUSH",              // 0x08
 "??9",                             // 0x09
 "??a",                             // 0x0a
 "??b",                             // 0x0b
 "??c",                             // 0x0c
 "??d",                             // 0x0d
 "??e",                             // 0x0e
 "??f",                             // 0x0f
 "SRB_FUNCTION_ABORT_COMMAND",      // 0x10
 "SRB_FUNCTION_RELEASE_RECOVERY",   // 0x11
 "SRB_FUNCTION_RESET_BUS",          // 0x12
 "SRB_FUNCTION_RESET_DEVICE",       // 0x13
 "SRB_FUNCTION_TERMINATE_IO",       // 0x14
 "SRB_FUNCTION_FLUSH_QUEUE",        // 0x15
 "SRB_FUNCTION_REMOVE_DEVICE",      // 0x16
 "SRB_FUNCTION_WMI",                // 0x17
 "SRB_FUNCTION_LOCK_QUEUE",         // 0x18
 "SRB_FUNCTION_UNLOCK_QUEUE"        // 0x19
};

#define SRB_COMMAND_MAX 0x19


DECLARE_API( srb )

/*++

Routine Description:

    Dumps the specified SCSI request block.

Arguments:

    Ascii bits for address.

Return Value:

    None.

--*/

{
    PUCHAR              buffer;
    PCHAR               functionName;
    UCHAR               i;
    ULONG64             srbToDump=0;
    ULONG               SrbFlags, Function, SrbStatus, CdbLength;

    srbToDump = GetExpression(args);
    if (GetFieldValue( srbToDump, 
                       "SCSI_REQUEST_BLOCK",
                       "SrbFlags",
                       SrbFlags)) {
        dprintf("%08p: Could not read Srb\n", srbToDump);
        return E_INVALIDARG;
    }

    if (SrbFlags & SRB_FLAGS_ALLOCATED_FROM_ZONE) {
        dprintf("Srb %08p is from zone\n", srbToDump);
    }
    else {
        dprintf("Srb %08p is from pool\n", srbToDump);
    }

    InitTypeRead(srbToDump, nt!_SCSI_REQUEST_BLOCK);
    if ((Function = (ULONG) ReadField(Function)) > SRB_COMMAND_MAX) {
        functionName = "Unknown function";
    }
    else {
        functionName = SrbFunctionTable[Function];
    }

    dprintf("%s: Path %x, Tgt %x, Lun %x, Tag %x, SrbStat %x, ScsiStat %x\n",
            functionName,
            (ULONG) ReadField(PathId),
            (ULONG) ReadField(TargetId),
            (ULONG) ReadField(Lun),
            (ULONG) ReadField(QueueTag),
            (SrbStatus = (ULONG) ReadField(SrbStatus)),
            (ULONG) ReadField(ScsiStatus));

    dprintf("OrgRequest %08p SrbExtension %08p TimeOut %08lx SrbFlags %08lx\n",
            ReadField(OriginalRequest),
            ReadField(SrbExtension),
            (ULONG) ReadField(TimeOutValue),
            (ULONG) ReadField(SrbFlags));

    if (SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) {
        dprintf("Queue Enable, ");
    }
    if (SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {
        dprintf("No Disconnect, ");
    }
    if (SrbFlags & SRB_FLAGS_DISABLE_SYNCH_TRANSFER) {
        dprintf("No Sync, ");
    }
    if (SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {
        dprintf("Bypass Queue, ");
    }
    if (SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) {
        dprintf("Disable Sense, ");
    }
    if (SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) {
        dprintf("No freeze, ");
    }
    if (SrbFlags & SRB_FLAGS_ADAPTER_CACHE_ENABLE) {
        dprintf("Cache Enable, ");
    }
    if (SrbFlags & SRB_FLAGS_IS_ACTIVE) {
        dprintf("Is active, ");
    }

    if (Function == SRB_FUNCTION_EXECUTE_SCSI) {
        dprintf("\n%2d byte command with %s: ",
                (CdbLength=(ULONG) ReadField(CdbLength)),
                (SrbFlags & SRB_FLAGS_DATA_IN)  ? "data transfer in" :
                (SrbFlags & SRB_FLAGS_DATA_OUT) ? "data transfer out" :
                                                      "no data transfer");
        for (i = 0; i < CdbLength; i++) {
            CHAR Buff[20];
            sprintf(Buff, "Cdb[%d]", i);
            dprintf("%2x ", (ULONG) GetShortField(0, Buff, 0));
        }
    }
    dprintf("\n");

    if (SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        ULONG length = (ULONG) ReadField(SenseInfoBufferLength);
        ULONG64 SenseInfoBuffer;

        dprintf(" Autosense valid: ");

        if (length == 0) {
            dprintf("Sense info length is zero\n");
        } else if (length > 64) {
            dprintf("Length is too big 0x%x ", length);
            length = 64;
        }

        buffer = (PUCHAR)LocalAlloc(LPTR, length);
        if (buffer == NULL) {
            dprintf("Cannot alloc memory\n");
            return E_INVALIDARG;
        }

        if (!ReadMemory((SenseInfoBuffer = ReadField(SenseInfoBuffer)), 
                        buffer,
                        length, NULL )) {
            dprintf("%08p: Could not read sense info\n", SenseInfoBuffer);
            LocalFree(buffer);
            return  E_INVALIDARG;
        }

        for (i = 0; i < length; i++) {
            if(CheckControlC()) {
                dprintf("^C");
                break;
            }

            dprintf("%2x ", buffer[i]);
        }
        dprintf("\n");

        LocalFree(buffer);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\time.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    time.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

VOID
FileTimeToString(
    IN LARGE_INTEGER Time,
    IN BOOLEAN TimeZone,
    OUT PCHAR Buffer
    );

ULONG64
DumpKTimer(
    IN ULONG64 pTimer,
    IN ULONGLONG InterruptTimeOffset,
    IN OPTIONAL ULONG64 Blink
    )
{
    ULONG64         Displacement;
    CHAR            Buff[256];
    ULONG           Result;
    ULONG64         NextThread;
    LARGE_INTEGER   SystemTime;
    ULONG           Period, Off;
    LARGE_INTEGER   Due;
    ULONG64         Dpc, DeferredRoutine, WaitList_Flink, Timer_Flink, Timer_Blink;

    if ( GetFieldValue(pTimer, "nt!_KTIMER", "DueTime.QuadPart", Due.QuadPart) ) {
        dprintf("Unable to get contents of Timer @ %p\n", pTimer );
        return(0);
    }

    SystemTime.QuadPart = Due.QuadPart + InterruptTimeOffset;
    if (SystemTime.QuadPart < 0) {
        strcpy(Buff, "         NEVER         ");
    } else {
        FileTimeToString(SystemTime, FALSE, Buff);
    }

    GetFieldValue(pTimer, "nt!_KTIMER", "Period", Period);
    GetFieldValue(pTimer, "nt!_KTIMER", "Dpc", Dpc);
    GetFieldValue(pTimer, "nt!_KTIMER", "Header.WaitListHead.Flink", WaitList_Flink);
    GetFieldValue(pTimer, "nt!_KTIMER", "TimerListEntry.Flink", Timer_Flink);
    GetFieldValue(pTimer, "nt!_KTIMER", "TimerListEntry.Blink", Timer_Blink);

    dprintf("%c %08lx %08lx [%s]  ",
            (Period != 0) ? 'P' : ' ',
            Due.LowPart,
            Due.HighPart,
            Buff);

    if (Dpc != 0) {
        if (GetFieldValue(Dpc, "nt!_KDPC", "DeferredRoutine", DeferredRoutine)) {
            dprintf("Unable to get contents of DPC @ %p\n", Dpc);
            return(0);
        }
        // dprintf("p(%p)", DeferredRoutine);
        GetSymbol(DeferredRoutine,
                  Buff,
                  &Displacement);
        dprintf("%s",Buff);
        if (Displacement != 0) {
            dprintf("+%1p ", Displacement);
        } else {
            dprintf(" ");
        }
    }

    //
    // List all the threads
    //
    NextThread = WaitList_Flink;
    GetFieldOffset("nt!_KTIMER", "Header.WaitListHead", &Off);
    while (WaitList_Flink && (NextThread != pTimer+Off)) {
        ULONG64 Flink;
        ULONG64 Thread=0;

        if (GetFieldValue(NextThread, "nt!_KWAIT_BLOCK", "Thread", Thread)) {
            dprintf("Unable to get contents of waitblock @ %p\n", NextThread);
        } else {
            dprintf("thread %p ",Thread);
        }

        if (GetFieldValue(NextThread,
                          "nt!_LIST_ENTRY",
                          "Flink",
                          Flink)) {
            dprintf("Unable to read next WaitListEntry @ %p\n",NextThread);
            break;
        }
        NextThread = Flink;
    }

    dprintf("\n");

    if (Blink &&
        (Timer_Blink != Blink)) {
        dprintf("   Timer at %p has wrong Blink! (Blink %08p, should be %08p)\n",
                pTimer,
                Timer_Blink,
                Blink);
    }

    if (Timer_Flink == 0) {
        dprintf("   Timer at %p has been zeroed! (Flink %08p, Blink %08p)\n",
                pTimer,
                Timer_Flink,
                Timer_Blink);
    }

    return(Timer_Flink);

}



DECLARE_API( timer )

/*++

Routine Description:

    Dumps all timers in the system.

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG           CurrentList;
    ULONG           Index;
    LARGE_INTEGER   InterruptTime;
    LARGE_INTEGER   SystemTime;
    ULONG           MaximumList;
    ULONG           MaximumSearchCount=0;
    ULONG           MaximumTimerCount;
    ULONG64         NextEntry;
    ULONG64         LastEntry;
    ULONG64         p;
    ULONG64         NextTimer;
    ULONG64         KeTickCount;
    ULONG64         KiMaximumSearchCount;
    ULONG           Result;
    ULONG64         TickCount=0;
    ULONG64         TimerTable;
    ULONG           TotalTimers;
    ULONG           KtimerOffset;
    ULONG           TimerListOffset;
    ULONG           WakeTimerListOffset;
    ULONG64         WakeTimerList;
    ULONG64         pETimer, Temp;
    ULONG64         SharedUserData;
    CHAR            Buffer[256];
    ULONGLONG       InterruptTimeOffset;
    UCHAR           TypName[]="_KUSER_SHARED_DATA";
    CHAR            SystemTime1[12]={0}, InterruptTime1[12]={0};
    FIELD_INFO offField = {"TimerListEntry", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={
        sizeof (SYM_DUMP_PARAM), "nt!_KTIMER", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };


    SharedUserData = MM_SHARED_USER_DATA_VA;
    //
    // Get the system time and print the header banner.
    //
    if (!GetFieldValue(SharedUserData, TypName, "SystemTime", SystemTime1) )
    {
        // For x86
        GetFieldValue(SharedUserData, TypName, "InterruptTime.High1Time", InterruptTime.HighPart);
        GetFieldValue(SharedUserData, TypName, "InterruptTime.LowPart", InterruptTime.LowPart);

        GetFieldValue(SharedUserData, TypName, "SystemTime.High1Time", SystemTime.HighPart);
        GetFieldValue(SharedUserData, TypName, "SystemTime.LowPart", SystemTime.LowPart);
    }
    else if (!GetFieldValue(SharedUserData, TypName, "InterruptTime", InterruptTime1) ) {
        // For Alphas
        InterruptTime.QuadPart = *((PULONG64) &InterruptTime1[0]);
        SystemTime.QuadPart = *((PULONG64) &SystemTime1[0]);

    }
    else
    {
        dprintf("%08p: Unable to get shared data\n",SharedUserData);
        return E_INVALIDARG;
    }

    /*
#ifdef TARGET_ALPHA
    InterruptTime.QuadPart = SharedData.InterruptTime;
    SystemTime.QuadPart = SharedData.SystemTime;
#else
    InterruptTime.HighPart = SharedData.InterruptTime.High1Time;
    InterruptTime.LowPart = SharedData.InterruptTime.LowPart;
    SystemTime.HighPart = SharedData.SystemTime.High1Time;
    SystemTime.LowPart = SharedData.SystemTime.LowPart;
#endif
*/

    InterruptTimeOffset = SystemTime.QuadPart - InterruptTime.QuadPart;
    FileTimeToString(SystemTime, TRUE, Buffer);

    dprintf("Dump system timers\n\n");
    dprintf("Interrupt time: %08lx %08lx [%s]\n\n",
            InterruptTime.LowPart,
            InterruptTime.HighPart,
            Buffer);

    //
    // Get the address of the timer table list head array and scan each
    // list for timers.
    //

    dprintf("List Timer    Interrupt Low/High     Fire Time              DPC/thread\n");
    MaximumList = 0;

    TimerTable = GetExpression( "nt!KiTimerTableListHead" );
    if ( !TimerTable ) {
        dprintf("Unable to get value of KiTimerTableListHead\n");
        return E_INVALIDARG;
    }

    TotalTimers = 0;
    // Get The TimerListOffset in KTIMER offset
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        return E_INVALIDARG ;
    }
    TimerListOffset = (ULONG) offField.address;

    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {

        //
        // Read the forward link in the next timer table list head.
        //

        if ( GetFieldValue(TimerTable, "nt!_LIST_ENTRY", "Flink", NextEntry)) {
            dprintf("Unable to get contents of next entry @ %p\n", TimerTable );
            continue;
        }

        //
        // Scan the current timer list and display the timer values.
        //

        LastEntry = TimerTable;
        CurrentList = 0;
        while (NextEntry != TimerTable) {
            CurrentList += 1;
            NextTimer = NextEntry - TimerListOffset; // CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            TotalTimers += 1;

            if (CurrentList == 1) {
                dprintf("%3ld %08p ", Index, NextTimer);
            } else {
                dprintf("    %08p ", NextTimer);
            }

            p = LastEntry;
            LastEntry = NextEntry;
            NextEntry = DumpKTimer(NextTimer, InterruptTimeOffset, p);
            if (NextEntry==0) {
                break;
            }

            if (CheckControlC()) {
                return E_INVALIDARG;
            }
        }

        TimerTable += GetTypeSize("nt!_LIST_ENTRY");
        if (CurrentList > MaximumList) {
            MaximumList = CurrentList;
        }
        if (CheckControlC()) {
            return E_INVALIDARG;
        }
    }

    dprintf("\n\nTotal Timers: %d, Maximum List: %d\n",
            TotalTimers,
            MaximumList);

    //
    // Get the current tick count and convert to the hand value.
    //

    KeTickCount =  GetExpression( "nt!KeTickCount" );
    if ( KeTickCount && !GetFieldValue(KeTickCount, "ULONG", NULL, TickCount)) {
        dprintf("Current Hand: %d", (ULONG) TickCount & (TIMER_TABLE_SIZE - 1));
    }

    //
    // Get the maximum search count if the target system is a checked
    // build and display the count.
    //

    KiMaximumSearchCount = GetExpression( "nt!KiMaximumSearchCount" );
    if ( KiMaximumSearchCount &&
         !GetFieldValue(KiMaximumSearchCount, "ULONG", NULL, Temp)) {
        MaximumSearchCount = (ULONG) Temp;
        dprintf(", Maximum Search: %d", MaximumSearchCount);
    }

    dprintf("\n\n");

    //
    // Dump the list of wakeable timers
    //
    dprintf("Wakeable timers:\n");
    WakeTimerList =  GetExpression("nt!ExpWakeTimerList");
    if (!WakeTimerList) {
        dprintf("Unable to get value of ExpWakeTimerList\n");
        return E_INVALIDARG;
    }

    // Get The WakeTimerLis tOffset in ETIMER
    TypeSym.sName = "_ETIMER";
    offField.fName = "WakeTimerListEntry";
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        return  E_INVALIDARG;
    }
    TimerListOffset = (ULONG) offField.address;

    offField.fName = "KeTimer";
    Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size);
    KtimerOffset = (ULONG) offField.address;

    //
    // Read the forward link in the wake timer list
    //
    if (!ReadPointer(WakeTimerList,
                &NextEntry)) {
        dprintf("Unable to get contents of next entry @ %p\n",WakeTimerList);
        return E_INVALIDARG;
    }

    //
    // Scan the timer list and display the timer values.
    //
    while (NextEntry != WakeTimerList) {
        pETimer = NextEntry - TimerListOffset;

        dprintf("%08lx\t", pETimer + KtimerOffset);
        DumpKTimer(pETimer + KtimerOffset, InterruptTimeOffset, 0);


        GetFieldValue(pETimer, "_ETIMER", "WakeTimerListEntry.Flink", NextEntry);
//        NextEntry = ETimer.WakeTimerListEntry.Flink;

        if (CheckControlC()) {
            return E_INVALIDARG;
        }
    }
    dprintf("\n");

    return S_OK;
}

VOID
FileTimeToString(
    IN LARGE_INTEGER Time,
    IN BOOLEAN TimeZone,
    OUT PCHAR Buffer
    )
{
    TIME_FIELDS TimeFields;
    TIME_ZONE_INFORMATION TimeZoneInfo;
    PWCHAR pszTz;
    ULONGLONG TzBias;
    DWORD Result;

    //
    // Get the local (to the debugger) timezone bias
    //
    Result = GetTimeZoneInformation(&TimeZoneInfo);
    if (Result == 0xffffffff) {
        pszTz = L"UTC";
    } else {
        //
        // Bias is in minutes, convert to 100ns units
        //
        TzBias = (ULONGLONG)TimeZoneInfo.Bias * 60 * 10000000;
        switch (Result) {
            case TIME_ZONE_ID_UNKNOWN:
                pszTz = L"unknown";
                break;
            case TIME_ZONE_ID_STANDARD:
                pszTz = TimeZoneInfo.StandardName;
                break;
            case TIME_ZONE_ID_DAYLIGHT:
                pszTz = TimeZoneInfo.DaylightName;
                break;
        }

        Time.QuadPart -= TzBias;
    }

    RtlTimeToTimeFields(&Time, &TimeFields);
    if (TimeZone) {
        sprintf(Buffer, "%2d/%2d/%d %02d:%02d:%02d.%03d (%ws)",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds,
                pszTz);
    } else {
        sprintf(Buffer, "%2d/%2d/%d %02d:%02d:%02d.%03d",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds);
    }

}


DECLARE_API( filetime )

/*++

Routine Description:

    Reformats a 64-bit NT time (FILETIME) as something a human
    being can understand

Arguments:

    args - 64-bit filetime to reformat

Return Value:

    None

--*/

{
    LARGE_INTEGER Time;
    CHAR Buffer[256];

    Time.QuadPart = GetExpression(args);

    if (Time.QuadPart == 0) {
        dprintf("!filetime <64-bit FILETIME>\n");
    } else {
        FileTimeToString(Time,TRUE, Buffer);
        dprintf("%s\n",Buffer);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\token.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    token.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


BOOL
DumpToken (
    IN char     *Pad,
    IN ULONG64  RealTokenBase,
    IN ULONG    Flags
    );



DECLARE_API( token )

/*++

Routine Description:

    Dump token at specified address

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    ULONG64 Address;
    ULONG   Flags;
    ULONG   result;

    Address = 0;
    Flags = 6;
    
    if (GetExpressionEx(args,&Address,&args)) {
        if (args && *args) {
            Flags = (ULONG) GetExpression(args);
        }
    }

    if (Address == 0) {
        dprintf("usage: !token <token-address>\n");
        return E_INVALIDARG;
    }

    //
    // Dump token with no pad
    //

    DumpToken ("", Address, Flags);
    EXPRLastDump = Address;
    return S_OK;
}



DECLARE_API( tokenfields )

/*++

Routine Description:

    Displays the field offsets for TOKEN type.

Arguments:

    args -

Return Value:

    None

--*/

{
    dprintf("Use : dt TOKEN\n");

    return S_OK;
    /*
    dprintf(" TOKEN structure offsets:\n");
    dprintf("    TokenSource:           0x%lx\n", FIELD_OFFSET(TOKEN, TokenSource) );
    dprintf("    AuthenticationId:      0x%lx\n", FIELD_OFFSET(TOKEN, AuthenticationId) );
    dprintf("    ExpirationTime:        0x%lx\n", FIELD_OFFSET(TOKEN, ExpirationTime) );
    dprintf("    ModifiedId:            0x%lx\n", FIELD_OFFSET(TOKEN, ModifiedId) );
    dprintf("    UserAndGroupCount:     0x%lx\n", FIELD_OFFSET(TOKEN, UserAndGroupCount) );
    dprintf("    PrivilegeCount:        0x%lx\n", FIELD_OFFSET(TOKEN, PrivilegeCount) );
    dprintf("    VariableLength:        0x%lx\n", FIELD_OFFSET(TOKEN, VariableLength) );
    dprintf("    DynamicCharged:        0x%lx\n", FIELD_OFFSET(TOKEN, DynamicCharged) );
    dprintf("    DynamicAvailable:      0x%lx\n", FIELD_OFFSET(TOKEN, DynamicAvailable) );
    dprintf("    DefaultOwnerIndex:     0x%lx\n", FIELD_OFFSET(TOKEN, DefaultOwnerIndex) );
    dprintf("    DefaultDacl:           0x%lx\n", FIELD_OFFSET(TOKEN, DefaultDacl) );
    dprintf("    TokenType:             0x%lx\n", FIELD_OFFSET(TOKEN, TokenType) );
    dprintf("    ImpersonationLevel:    0x%lx\n", FIELD_OFFSET(TOKEN, ImpersonationLevel) );
    dprintf("    TokenFlags:            0x%lx\n", FIELD_OFFSET(TOKEN, TokenFlags) );
    dprintf("    TokenInUse:            0x%lx\n", FIELD_OFFSET(TOKEN, TokenInUse) );
    dprintf("    ProxyData:             0x%lx\n", FIELD_OFFSET(TOKEN, ProxyData) );
    dprintf("    AuditData:             0x%lx\n", FIELD_OFFSET(TOKEN, AuditData) );
    dprintf("    VariablePart:          0x%lx\n", FIELD_OFFSET(TOKEN, VariablePart) );

    return;
    */
}





BOOL
DumpToken (
    IN char     *Pad,
    IN ULONG64  RealTokenBase,
    IN ULONG    Flags
    )
{
    ULONG TokenType, TokenFlags, TokenInUse, UserAndGroupCount;
    ULONG RestrictedSidCount, PrivilegeCount;
    ULONG64 AuthenticationId, TokenId, ParentTokenId, ModifiedId, UserAndGroups;
    ULONG64 RestrictedSids, Privileges, ImpersonationLevel;
    CHAR  SourceName[16];

#define TokFld(F) GetFieldValue(RealTokenBase, "TOKEN", #F, F)
#define TokSubFld(F,N) GetFieldValue(RealTokenBase, "TOKEN", #F, N)

    if (TokFld(TokenType)) {
        dprintf("%sUnable to read TOKEN at %p.\n", Pad, RealTokenBase);
        return FALSE;
    }

    //
    // It would be worth sticking a check in here to see if we
    // are really being asked to dump a token, but I don't have
    // time just now.
    //

    if (TokenType != TokenPrimary  &&
        TokenType != TokenImpersonation) {
        dprintf("%sUNKNOWN token type - probably is not a token\n", Pad);
        return FALSE;
    }

    TokSubFld(TokenSource.SourceName, SourceName);
    TokFld(TokenFlags); TokFld(AuthenticationId); TokFld(TokenInUse);
    TokFld(ImpersonationLevel); TokFld(TokenId), TokFld(ParentTokenId);
    TokFld(ModifiedId); TokFld(RestrictedSids); TokFld(RestrictedSidCount);
    TokFld(PrivilegeCount); TokFld(Privileges); TokFld(UserAndGroupCount);
    TokFld(UserAndGroups);

    dprintf("%sTOKEN %p  Flags: %x  Source %8s  AuthentId (%lx, %lx)\n",
        Pad,
        RealTokenBase,
        TokenFlags,
        &(SourceName[0]),
        (ULONG) ((AuthenticationId >> 32) & 0xffffffff),
        (ULONG) AuthenticationId & 0xffffffff
        );

    //
    // Token type
    //
    if (TokenType == TokenPrimary) {
        dprintf("%s    Type:                    Primary", Pad);

        if (TokenInUse) {
            dprintf(" (IN USE)\n");
        } else {
            dprintf(" (NOT in use)\n");
        }

    } else {
        dprintf("%s    Type:                    Impersonation (level: ", Pad);
        switch (ImpersonationLevel) {
            case SecurityAnonymous:
                dprintf(" Anonymous)\n");
                break;

            case SecurityIdentification:
                dprintf(" Identification)\n");
                break;

            case SecurityImpersonation:
                dprintf(" Impersonation)\n");
                break;

            case SecurityDelegation:
                dprintf(" Delegation)\n");
                break;

            default:
                dprintf(" UNKNOWN)\n");
                break;
        }
    }

    //
    // Token ID and modified ID
    //
    dprintf("%s    Token ID:                %I64lx\n",
        Pad, TokenId );

    dprintf("%s    ParentToken ID:          %I64lx\n",
        Pad, ParentTokenId );

    dprintf("%s    Modified ID:             (%lx, %lx)\n",
        Pad, (ULONG) (ModifiedId >> 32) & 0xffffffff,  (ULONG) (ModifiedId & 0xffffffff));

    dprintf("%s    TokenFlags:              0x%x\n",
        Pad, TokenFlags );

    dprintf("%s    SidCount:                %d\n",
        Pad, UserAndGroupCount );

    dprintf("%s    Sids:                    %p\n",
        Pad, UserAndGroups );

    dprintf("%s    RestrictedSidCount:      %d\n",
        Pad, RestrictedSidCount );

    dprintf("%s    RestrictedSids:          %p\n",
        Pad, RestrictedSids );

    dprintf("%s    PrivilegeCount:          %d\n",
        Pad, PrivilegeCount );

    dprintf("%s    Privileges:              %p\n",
        Pad, Privileges );

    dprintf("\n");
#undef TokFld
#undef TokSubFld
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\trap.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    trap.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#include "ia64.h"
#pragma hdrstop

extern ULONG64 STeip, STebp, STesp;
extern ULONG64 ThreadLastDump;



DECLARE_API( callback )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64         Address;
    ULONG           Flags;
    ULONG           result;
    ULONG64         Thread;
    ULONG64         prevCallout ;
    INT             calloutNum ;
    INT             whichCallout ;
    ULONG64         InitialStack;
    ULONG64         TrFr;
    ULONG           dwProcessor=0;
    
    GetCurrentProcessor(Client, &dwProcessor, NULL);

    Address = 0;
    whichCallout = 0 ;
    if (GetExpressionEx(args, &Address, &args)) {
        if (!sscanf(args, "%ld", &whichCallout)) {
            whichCallout = 0;
        }
    }

    if (Address == 0) {
        GetCurrentThreadAddr((USHORT)dwProcessor, &Address);
    }

    if (!DumpThreadEx(dwProcessor, "", Address, 0, Client))
        return E_INVALIDARG;

    GetFieldValue(Address, "ETHREAD", "Tcb.InitialStack", InitialStack);
    
    /*
     * now try and grab the contents of the stack
     */
    if (GetFieldValue(InitialStack, "KCALLOUT_FRAME", "TrFr", TrFr)) {
        dprintf("%08p: Unable to get callout frame\n", InitialStack);
        return E_INVALIDARG;
    }

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
        /*
         * Save eip, esp, ebp for quick backtrace from this callback in case
         * they gave us a bogus callout frame.
         */
        GetFieldValue(InitialStack, "KCALLOUT_FRAME", "Ret", STeip);
        STesp = (ULONG) InitialStack ;
        GetFieldValue(InitialStack, "KCALLOUT_FRAME", "Ebp", STebp);
    }

    /*
     * Print the callout chain
     */
    calloutNum = 0 ;
    prevCallout = InitialStack ;
    
    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
        dprintf("Callout#    ebp        esp        eip        trapframe\n") ;
    } else {
        dprintf("Callout#        esp        trapframe\n") ;
    }

    while (prevCallout) {

        if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
            ULONG Ret, Ebp;

            GetFieldValue(prevCallout, "KCALLOUT_FRAME", "Ebp", Ebp);
            GetFieldValue(prevCallout, "KCALLOUT_FRAME", "Ret", Ret);

            dprintf("  %3d       %08lx   %08p   %08lx   %08lx",
                    calloutNum, Ebp, prevCallout,
                    Ret, TrFr) ;
            if (calloutNum == whichCallout) {
                STeip = Ret ;
                STesp = (ULONG) prevCallout ;
                STebp = Ebp ;
                dprintf("   <-- !kb\n") ;
            }
            else
                dprintf("\n") ;
        } else {
            dprintf("  %3d       %08p   %08lx",
                    calloutNum, prevCallout, TrFr) ;
        }


        /*
         * advance to the next callout and try to read it
         */
        calloutNum++ ;

        GetFieldValue(prevCallout, "KCALLOUT_FRAME", "CbStk", prevCallout);
        
        if (GetFieldValue(prevCallout, "KCALLOUT_FRAME", "TrFr", TrFr)) {
            dprintf("%08p: Unable to get callout frame\n", prevCallout);
            return E_INVALIDARG;
        }
        
    }
    dprintf("\n") ;

    if (calloutNum <= whichCallout) {
        dprintf("#(%ld) is out of range.  Frame #0 selected.\n", calloutNum) ;
    }

    return S_OK;
}

DECLARE_API( kb )

/*++

--*/

{
    dprintf("\n");
    dprintf("    \"!kb\" is no longer necessary as using \"kb\" after a \".cxr\" or \".trap\"\n");
    dprintf("  command will give you the stack for the faulting thread.\n");
    dprintf("\n");
    dprintf("    Type \"!cxr\" or \"!trap\" for more help on this.\n");
    dprintf("\n");

    return S_OK;
}


DECLARE_API( kv )

/*++

--*/

{
    dprintf("\n");
    dprintf("    \"!kv\" is no longer necessary as using \"kv\" after a \".cxr\" or \".trap\"\n");
    dprintf("  command will give you the stack for the faulting thread.\n");
    dprintf("\n");
    dprintf("    Type \"!cxr\" or \"!trap\" for more help on this.\n");
    dprintf("\n");

    return S_OK;
}


#define HIGH(x) ((ULONG) ((x>>32) & 0xFFFFFFFF))
#define LOW(x) ((ULONG) (x & 0xFFFFFFFF))



VOID
DisplayFullEmRegField(
    ULONG64      EmRegValue,
    EM_REG_FIELD EmRegFields[],
    ULONG        Field
    )
{
   dprintf( "\n %3.3s : %I64x : %-s",  
            EmRegFields[Field].SubName,
            (EmRegValue >> EmRegFields[Field].Shift) & ((1 << EmRegFields[Field].Length) - 1),
            EmRegFields[Field].Name
          );
   return;
} // DisplayFullEmRegField()

VOID
DisplayFullEmReg(
    IN ULONG64      Val,
    IN EM_REG_FIELD EmRegFields[],
    IN DISPLAY_MODE DisplayMode
    )
{
    ULONG i, j;

    i = j = 0;
    if ( DisplayMode >= DISPLAY_MAX )   {
       while( j < EM_REG_BITS )   {
          DisplayFullEmRegField( Val, EmRegFields, i );
          j += EmRegFields[i].Length;
          i++;
       }
    }
    else  {
       while( j < EM_REG_BITS )   {
          if ( !strstr(EmRegFields[i].Name, "reserved" ) &&
               !strstr(EmRegFields[i].Name, "ignored"  ) ) {
             DisplayFullEmRegField( Val, EmRegFields, i );
          }
          j += EmRegFields[i].Length;
          i++;
       }
    }
    dprintf("\n");

    return;

} // DisplayFullEmReg()


#if 0

//
// ISR codes for General Exceptions: ISR{7:4}
//

#define ISR_ILLEGAL_OP     0        // Illegal operation fault
#define ISR_PRIV_OP        1        // Privileged operation fault
#define ISR_PRIV_REG       2        // Privileged register fault
#define ISR_RESVD_REG      3        // Reserved register/field fault
#define ISR_ILLEGAL_ISA    4        // Disabled instruction set transition fault
#define ISR_ILLEGAL_HAZARD 8        // Illegal hazard fault

//
// ISR codes for Nat Consumption Faults: ISR{7:4}
//

#define ISR_NAT_REG     1           // Nat Register Consumption fault
#define ISR_NAT_PAGE    2           // Nat Page Consumption fault

//
// For Traps ISR{4:0}
//

// FP trap
#define ISR_FP_TRAP    0
// Lower privilege transfer trap
#define ISR_LP_TRAP    1
// Taken branch trap
#define ISR_TB_TRAP    2
// Single step trap
#define ISR_SS_TRAP    3
// Unimplemented instruction address trap
#define ISR_UI_TRAP    4

ISR Settings for Non-Access Instructions
Instruction ISR fields
                     code{3:0} na r w
tpa                  0 1 0 0
fc                   1 1 1 0
probe                2 1 0 or 1 a 0 or 1 a
tak                  3 1 0 0
lfetch, lfetch.fault 4 1 1 0
probe.fault          5 1 0 or 1 a 0 or 1 a
a. Sets r or w or both to 1 depending on the probe form.

#endif // 0

EM_REG_FIELD EmIsrFields[] = {
        { "code",   "interruption Code"   , 0x10, 0 },   // 0-15
        { "vector", "IA32 exception vector number"  , 0x8, 16 },   // 16-23
        { "rv",     "reserved0", 0x8, 24  }, // 24-31
        { "x",      "eXecute exception", 0x1, 32 }, // 32
        { "w",      "Write exception", 0x1, 33 }, // 33
        { "r",      "Read exception", 0x1, 34 }, // 34
        { "na",     "Non-Access exception", 0x1, 35 }, // 35
        { "sp",     "Speculative load exception", 0x1, 36 }, // 36
        { "rs",     "Register Stack", 0x1, 37 }, // 37
        { "ir",     "Invalid Register frame", 0x1, 38 }, // 38
        { "ni",     "Nested Interruption", 0x1, 39 }, // 39
        { "so",     "IA32 Supervisor Override", 0x1, 40 }, // 40
        { "ei",     "Exception IA64 Instruction", 0x2, 41 }, // 41-42
        { "ed",     "Exception Deferral", 0x1, 43 }, // 43
        { "rv",     "reserved1", 0x14, 44 } // 44-63
};

VOID
DisplayIsrIA64( 
    IN const PCHAR         Header,
    IN       EM_ISR        EmIsr,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
        DisplayFullEmReg( EM_ISRToULong64(EmIsr), EmIsrFields, DisplayMode );
    }
    else   {
       dprintf(
            "ed ei so ni ir rs sp na r w x vector code\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x %1I64x %1I64x %1I64x      %I64x   %I64x\n",
            EmIsr.ed,
            EmIsr.ei,
            EmIsr.so,
            EmIsr.ni,
            EmIsr.ir,
            EmIsr.rs,
            EmIsr.sp,
            EmIsr.na,
            EmIsr.r,
            EmIsr.w,
            EmIsr.x,
            EmIsr.vector,
            EmIsr.code
            );
    }

    return;

} // DisplayIsrIA64()


DECLARE_API( isr )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64     isrValue;
    ULONG       result;
    ULONG       flags = 0;
    char       *header;

    if (!GetExpressionEx(args,&isrValue, &args)) {
        dprintf("USAGE: !isr 0xValue [display_mode:0,1,2]\n");
        dprintf("USAGE: !isr @isr    [display_mode:0,1,2]\n");
        return E_INVALIDARG;
    } else {
        flags = (ULONG) GetExpression(args);
    }
    
    header = (flags > DISPLAY_MIN) ? NULL : "\tisr:\t";

    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!isr not implemented for this architecture.\n");
    }
    else
    {
        DisplayIsrIA64( header, ULong64ToEM_ISR(isrValue), (DISPLAY_MODE) flags );
    }

    return S_OK;
    
} // !isr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\stacks.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    stacks.h

Abstract:

    This file contains the stack walking scripts for !stacks

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

//
// This tree describes a tree of functions that will be "drilled" through when
// !stacks is used to give a summary of what each thread is currently doing...
//
// SKIP_FRAME - The entry should be skipped if a thread is being examined to
//              determine what "really" is going on.
//
// SKIP_THREAD - The thread should be skipped if the symbol is found on the
//               stack immediately after SKIP_FRAME processing.
//
BEGIN_TREE();
  DECLARE_ENTRY("nt!KiSwapContext", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiSwapThread", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiSwapThreadExit", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiSystemService", SKIP_FRAME);
  DECLARE_ENTRY("nt!_KiSystemService", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeRemoveQueue", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExpWaitForResource", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExAcquireResourceSharedLite", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExAcquireResourceExclusiveLite", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExpAcquireResourceExclusiveLite", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeWaitForSingleObject", SKIP_FRAME);
  DECLARE_ENTRY("nt!VerifierKeWaitForSingleObject", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtWaitForSingleObject", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeWaitForMultipleObjects", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtWaitForMultipleObjects", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtRemoveIoCompletion", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtReplyWaitReceivePort", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtReplyWaitReceivePortEx", SKIP_FRAME);
  DECLARE_ENTRY("nt!ZwReplyWaitReceivePort", SKIP_FRAME);
  DECLARE_ENTRY("nt!IopSynchronousServiceTail", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtRequestWaitReplyPort", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeDelayExecutionThread", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtDelayExecution", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiUnlockDispatcherDatabase", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeSetEvent", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeInsertQueue", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExQueueWorkItem", SKIP_FRAME);

  DECLARE_ENTRY("nt!MmZeroPageThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!PspSystemThreadStartup", SKIP_THREAD);
  DECLARE_ENTRY("nt!ExpWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!ExpWorkerThreadBalanceManager", SKIP_THREAD);
  DECLARE_ENTRY("nt!MiDereferenceSegmentThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!MiModifiedPageWriterWorker", SKIP_THREAD);
  DECLARE_ENTRY("nt!KeBalanceSetManager", SKIP_THREAD);
  DECLARE_ENTRY("nt!KeSwapProcessOrStack", SKIP_THREAD);
  DECLARE_ENTRY("nt!FsRtlWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!SepRmCommandServerThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!MiMappedPageWriter", SKIP_THREAD);
  DECLARE_ENTRY("nt!NtGetPlugPlayEvent", SKIP_THREAD);
  DECLARE_ENTRY("nt!PspReaper", SKIP_THREAD);
  DECLARE_ENTRY("nt!WmipLogger", SKIP_THREAD);
  DECLARE_ENTRY("srv!WorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("NDIS!ndisWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("dmio!voliod_loop", SKIP_THREAD);
  DECLARE_ENTRY("raspptp!PacketWorkingThread", SKIP_THREAD);
  DECLARE_ENTRY("raspptp!MainPassiveLevelThread", SKIP_THREAD);
  DECLARE_ENTRY("rdpdr!RxpWorkerThreadDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("rdpdr!RxSpinUpRequestsDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("mrxdav!RxpWorkerThreadDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("mrxdav!RxSpinUpRequestsDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("mrxdav!RxWorkItemDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("rdbss!RxpWorkerThreadDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("rdbss!RxSpinUpRequestsDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("rasacd!AcdNotificationRequestThread", SKIP_THREAD);
  DECLARE_ENTRY("win32k!RawInputThread", SKIP_THREAD);
  DECLARE_ENTRY("win32k!xxxSleepThread", SKIP_THREAD);
  DECLARE_ENTRY("redbook!RedBookSystemThread", SKIP_THREAD);
  DECLARE_ENTRY("USBPORT!USBPORT_WorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("ACPI!ACPIWorker", SKIP_THREAD);
  DECLARE_ENTRY("kmixer!MxPrivateWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("irda!RxThread", SKIP_THREAD);
  DECLARE_ENTRY("irenum!WorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("ltmdmntt!WriteRegistryThread", SKIP_THREAD);
  DECLARE_ENTRY("ltmdmntt!WakeupTimerThread", SKIP_THREAD);
  DECLARE_ENTRY("TDI!CTEpEventHandler", SKIP_THREAD);
  DECLARE_ENTRY("parport!P5FdoThread", SKIP_THREAD);
  DECLARE_ENTRY("*SharedIntelSystemCall", SKIP_THREAD);
  DECLARE_ENTRY("*SharedUserSystemCall", SKIP_THREAD);

END_TREE();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\tunnel.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Tunnel.c

Abstract:

    WinDbg Extension Api

Author:

    Dan Lovinger            2-Apr-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  printf is really expensive to iteratively call to do the indenting,
//  so we just build up some avaliable spaces to mangle as required
//

#define MIN(a,b) ((a) > (b) ? (b) : (a))

#define MAXINDENT  128
#define INDENTSTEP 2
#define MakeSpace(I)       Space[MIN((I)*INDENTSTEP, MAXINDENT)] = '\0'
#define RestoreSpace(I)    Space[MIN((I)*INDENTSTEP, MAXINDENT)] = ' '

CHAR    Space[MAXINDENT*INDENTSTEP + 1];

//#define SplitLI(LI) (LI).HighPart, (LI).LowPart
#define SplitLL(LL) (ULONG)((LL) >> 32), (ULONG)((LL) & 0xffffffff)

VOID
DumpTunnelNode (
    ULONG64 Node,
    ULONG Indent
    )
{
    WCHAR ShortNameStr[8+1+3];
    WCHAR LongNameStr[64];
    ULONG Flags;
    UNICODE_STRING ShortName, LongName;

    if (GetFieldValue(Node, "TUNNEL_NODE", "Flags", Flags)) {
        return;
    }

    InitTypeRead(Node, TUNNEL_NODE);

    //
    //  Grab the strings from the debugee
    //

    if (!ReadMemory(ReadField(ShortName.Buffer),
                    &ShortNameStr,
                    (ShortName.Length = (USHORT) ReadField(ShortName.Length)),
                    NULL)) {

        return;
    }

    if (!ReadMemory(ReadField(LongName.Buffer),
                    &LongNameStr,
                    LongName.Length = MIN((USHORT) ReadField(LongName.Length), sizeof(LongNameStr)),
                    NULL)) {

        return;
    }

    //
    //  Modify the node in-place so we can use normal printing
    //

    LongName.Buffer = LongNameStr;
    ShortName.Buffer = ShortNameStr;

    MakeSpace(Indent);

    dprintf("%sNode @ %08 Cr %08x%08x DK %08x%08x [",
             Space,
             Node,
             SplitLL(ReadField(CreateTime)),
             SplitLL(ReadField(DirKey)));

    //
    //  Must be kept in sync with flag usage in fsrtl\tunnel.c
    //

    if (Flags & 0x1)
        dprintf("NLA");
    else
        dprintf("LA");

    if (Flags & 0x2)
        dprintf(" KYS");
    else
        dprintf(" KYL");

    dprintf("]\n");

    dprintf("%sP %08p R %08p L %08p Sfn/Lfn \"%wZ\"/\"%wZ\"\n",
            Space,
            ReadField(CacheLinks.Parent),
            ReadField(CacheLinks.RightChild),
            ReadField(CacheLinks.LeftChild),
            &ShortName,
            &LongName );

    dprintf("%sF %08p B %08p\n",
            Space,
            ReadField(ListLinks.Flink),
            ReadField(ListLinks.Blink));

    RestoreSpace(Indent);
}

VOID DumpTunnelNodeWrapper (
    ULONG64 pCacheLinks,
    ULONG Indent
    )
{
//    TUNNEL_NODE Node, *pNode;
    static ULONG Off=0;

    if (!Off) {
        GetFieldOffset("TUNNEL_NODE", "CacheLinks", &Off);
    }

    DumpTunnelNode(pCacheLinks - Off, Indent);
}

VOID
DumpTunnel (
    ULONG64 pTunnel
    )
{
    ULONG64 pLink, pHead, NodeFlink=0, TimerQueueFlink, pNode;
    ULONG   Indent = 0, EntryCount = 0, NumEntries, Offset, ListOffset;
    ULONG64 Cache; 

    if (GetFieldValue(pTunnel, "TUNNEL", "NumEntries", NumEntries)) {
        dprintf("Can't read TUNNEL at %p\n", pTunnel);
        return;
    }
    GetFieldValue(pTunnel, "TUNNEL", "Cache", Cache);
    GetFieldValue(pTunnel, "TUNNEL", "TimerQueue.Flink", TimerQueueFlink);
    pLink = TimerQueueFlink;
    GetFieldOffset("TUNNEL", "TimerQueue", &Offset);

    dprintf("Tunnel @ %08x\n"
            "NumEntries = %ld\n\n"
            "Splay Tree @ %08x\n",
            pTunnel,
            NumEntries,
            Cache);

    EntryCount = DumpSplayTree(Cache, DumpTunnelNodeWrapper);

    if (EntryCount != NumEntries) {

        dprintf("Tree count mismatch (%d not expected %d)\n", EntryCount, NumEntries);
    }

    GetFieldOffset("TUNNEL_NODE", "ListLinks", &ListOffset);

    for (EntryCount = 0,
         pHead = pTunnel + Offset,
         pLink = TimerQueueFlink;

         pLink != pHead;

         pLink = NodeFlink,
         EntryCount++) {


        pNode = pLink - ListOffset;
        if (pLink == TimerQueueFlink) {

            dprintf("\nTimer Queue @ %08x\n", pHead);
        }

        if (GetFieldValue(pNode, "TUNNEL_NODE",
                          "ListLinks.Flink", NodeFlink)) {
            dprintf("Can't read TUNNEL_NODE at %p\n", pNode);
            return;
        }

        DumpTunnelNode(pNode, 0);
    
        if ( CheckControlC() ) {

            return;
        }
    }

    if (EntryCount != NumEntries) {

        dprintf("Timer count mismatch (%d not expected %d)\n", EntryCount, NumEntries);
    }
}


DECLARE_API( tunnel )
/*++

Routine Description:

    Dump tunnel caches

Arguments:

    arg - <Address>

Return Value:

    None

--*/
{
    ULONG64 Tunnel = 0;

    RtlFillMemory(Space, sizeof(Space), ' ');

    Tunnel = GetExpression(args);

    if (Tunnel == 0) {

        //
        //  No args
        //

        return E_INVALIDARG;
    }

    DumpTunnel(Tunnel);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\uhcd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    UHCD.c

Abstract:

    WinDbg Extension Api

Author:

    Kenneth D. Ray (kenray) June 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

typedef union _USB_FLAGS {
    struct {
        ULONG   FullListing         : 1;
        ULONG   Reserved            : 31;
    };
    ULONG Flags;
} USB_FLAGS;

#define PRINT_FLAGS(value, flag) \
    if ((value) & (flag)) { \
        dprintf (#flag " "); \
    }

#define MAX_INTERVAL                32

//
// MACROS for USB controller registers
//

#define COMMAND_REG(DeviceRegisters)                    \
    (DeviceRegisters)
#define STATUS_REG(DeviceRegisters)                     \
    ((DeviceRegisters + 0x02))
#define INTERRUPT_MASK_REG(DeviceRegisters)             \
    (DeviceRegisters + 0x04)
#define FRAME_LIST_CURRENT_INDEX_REG(DeviceRegisters)   \
    (DeviceRegisters + 0x06)
#define FRAME_LIST_BASE_REG(DeviceRegisters)            \
    (DeviceRegisters + 0x08)
#define SOF_MODIFY_REG(DeviceRegisters)   \
    (DeviceRegisters + 0x0C)
#define PORT1_REG(DeviceRegisters)                      \
    (DeviceRegisters + 0x10)
#define PORT2_REG(DeviceRegisters)                      \
    (DeviceRegisters + 0x12)

VOID
UhciPortRegister(
    ULONG   PortNumber,
    ULONG   Value
);

VOID
DevExtUHCD(
    ULONG64 MemLocPtr
    )
{
    ULONG64           MemLoc = MemLocPtr;
    ULONG             HcFlags;
    ULONG             i;

    dprintf ("Dump UHCD Extension: %p\n", MemLoc);
    

    if (InitTypeRead (MemLoc, uhcd!_USBD_EXTENSION)) {
        dprintf ("Could not read Usbd Extension\n");
        return;
    }
    
    if (0 != ReadField( TrueDeviceExtension)) {
        MemLoc = ReadField(TrueDeviceExtension);
    }


    if (InitTypeRead (MemLoc, uhcd!_DEVICE_EXTENSION)) {
        dprintf ("Could not read UHCD Extension\n");
        return;
    }

    dprintf("\n");
    dprintf("PhysicalDO:   %8p  TopOfStackDO: %8p  InterruptObject: %8p\n"
            "FrameListVA:  %8p  FrameListLA:  %8p  ",
            ReadField(PhysicalDeviceObject),
            ReadField(TopOfStackDeviceObject),
            ReadField(InterruptObject),
            ReadField(FrameListVirtualAddress),
            ReadField(FrameListLogicalAddress));

    dprintf("FrameListCopyVA: %08p\n",
             ReadField(FrameListCopyVirtualAddress));

    dprintf("\n");
    /*
    dprintf("PersistantQH: %8x  PQH_DescriptorList: %8x\n"
            "EndpointList          & %x = (%x %x) \n"
            "EndpointLookAsideList & %x = (%x %x) \n"
            "ClosedEndpointList    & %x = (%x %x) \n",
            (ULONG) ReadField(PersistantQueueHead),
            (ULONG) ReadField(PQH_DescriptorList),
            &((ULONG) ReadField(EndpointList)),
            (ULONG) ReadField(EndpointList.Flink),
            (ULONG) ReadField(EndpointList.Blink),
            &((ULONG) ReadField(EndpointLookAsideList)),
            (ULONG) ReadField(EndpointLookAsideList.Flink),
            (ULONG) ReadField(EndpointLookAsideList.Blink),
            &((ULONG) ReadField(ClosedEndpointList)),
            (ULONG) ReadField(ClosedEndpointList.Flink),
            (ULONG) ReadField(ClosedEndpointList.Blink));*/
    dprintf("PersistantQH: %8p  PQH_DescriptorList: %8p\n"
            "EndpointList          = (%p %p) \n"
            "EndpointLookAsideList = (%p %p) \n"
            "ClosedEndpointList    = (%p %p) \n",
            ReadField(PersistantQueueHead),
            ReadField(PQH_DescriptorList),
            ReadField(EndpointList.Flink),
            ReadField(EndpointList.Blink),
            ReadField(EndpointLookAsideList.Flink),
            ReadField(EndpointLookAsideList.Blink),
            ReadField(ClosedEndpointList.Flink),
            ReadField(ClosedEndpointList.Blink));

    dprintf("\n");
    dprintf("InterruptSchedule: ");

    for (i = 0; i < MAX_INTERVAL; i++) 
    {
        UCHAR Sch[40];

        sprintf(Sch, "InterruptSchedule[%d]", i);
        dprintf("%8x  ", (ULONG) GetShortField(0, Sch, 0));

        if (3 == i % 4) 
        {
            dprintf("\n");
            dprintf("                   ");
        }
    }

    dprintf("\n");
//    dprintf("PageList & %x = (%x %x) \n",
//            &( (ULONG) ReadField(PageList)),
    dprintf("PageList = (%x %x) \n",
            ReadField(PageList.Flink),
            ReadField(PageList.Blink));

    dprintf("\n");
    dprintf("BwTable: ");

    for (i = 0; i < MAX_INTERVAL; i++) 
    {
        UCHAR Table[40];

        sprintf(Table, "BwTable[%d]", i);
   
        dprintf("%5d   ", GetShortField(0, Table, 0));

        if (7 == i % 8) 
        {
            dprintf("\n");
            dprintf("         ");
        }
    }

    dprintf("\n");
    dprintf("LastFrame:             %8x  FrameHighPart:       %8x\n"
            "LastIdleTime.High:     %8x  LastIdleTime.Low     %8x\n",
            "LastXferIdleTime.High: %8x  LastXferIdleTime.Low %8x\n",
            "IdleTime:              %8x  XferIdleTime         %8x\n",
            (ULONG) ReadField(LastFrame),
            (ULONG) ReadField(FrameHighPart),
            (ULONG) ReadField(LastIdleTime.HighPart),
            (ULONG) ReadField(LastIdleTime.LowPart),
            (ULONG) ReadField(LastXferIdleTime.HighPart),
            (ULONG) ReadField(LastXferIdleTime.LowPart),
            (ULONG) ReadField(IdleTime),
            (ULONG) ReadField(XferIdleTime));

    dprintf("\n");
    dprintf("TriggerList:      %08p\n"
            "LargeBufferPool:  %08p\n"
            "MediumBufferPool: %08p\n"
            "SmallBufferPool:  %08p\n",
            ReadField(TriggerTDList),
            ReadField(LargeBufferPool), 
            ReadField(MediumBufferPool), 
            ReadField(SmallBufferPool));

    dprintf("\nRootHub Variables\n");
    dprintf("DeviceAddress: %3d  RootHub:           %8x\n"  
            "TimersActive:  %3d  InterruptEndpoint: %8x\n",
            (ULONG) ReadField(RootHubDeviceAddress),
            (ULONG) ReadField(RootHub),
            (ULONG) ReadField(RootHubTimersActive),
            (ULONG) ReadField(RootHubInterruptEndpoint));

    dprintf("\n");
    dprintf("LastFrameProcessed:   %x\n"
            "AdapterObject:        %8x\n"
            "MapRegisters:         %d\n"
            "DeviceNameHandle:     %x\n"
            "FrameBabbleRecoverTD: %8x\n",
            (ULONG) ReadField(LastFrameProcessed),
            (ULONG) ReadField(AdapterObject),
            (ULONG) ReadField(NumberOfMapRegisters),
            (ULONG) ReadField(DeviceNameHandle),
            (ULONG) ReadField(FrameBabbleRecoverTD));

    dprintf("\nSaved Bios Info\n");
    dprintf("Cmd:             %x  IntMask:              %x\n"
            "FrameListBase:   %x  LegacySuppReg:        %x\n"
            "DeviceRegisters: %x  SavedInterruptEnable: %x\n"
            "SavedCommandReg: %x\n",
            (ULONG) ReadField(BiosCmd),
            (ULONG) ReadField(BiosIntMask),
            (ULONG) ReadField(BiosFrameListBase),
            (ULONG) ReadField(LegacySupportRegister),
            (ULONG) ReadField(DeviceRegisters[0]),
            (ULONG) ReadField(SavedInterruptEnable),
            (ULONG) ReadField(SavedCommandReg));

    dprintf("\n");
    dprintf("PowerState: %x\n"
            "HcFlags %x: ",
            (ULONG) ReadField(CurrentDevicePowerState),
            HcFlags = (ULONG) ReadField(HcFlags));
            PRINT_FLAGS(HcFlags, HCFLAG_GOT_IO);
            PRINT_FLAGS(HcFlags, HCFLAG_UNMAP_REGISTERS);
            PRINT_FLAGS(HcFlags, HCFLAG_USBBIOS);
            PRINT_FLAGS(HcFlags, HCFLAG_BWRECLIMATION_ENABLED);
            PRINT_FLAGS(HcFlags, HCFLAG_NEED_CLEANUP);
            PRINT_FLAGS(HcFlags, HCFLAG_IDLE);
            PRINT_FLAGS(HcFlags, HCFLAG_ROLLOVER_IDLE);
            PRINT_FLAGS(HcFlags, HCFLAG_HCD_STOPPED);
            PRINT_FLAGS(HcFlags, HCFLAG_DISABLE_IDLE);
            PRINT_FLAGS(HcFlags, HCFLAG_WORK_ITEM_QUEUED);
            PRINT_FLAGS(HcFlags, HCFLAG_HCD_SHUTDOWN);
            PRINT_FLAGS(HcFlags, HCFLAG_LOST_POWER);
            PRINT_FLAGS(HcFlags, HCFLAG_RH_OFF);
            PRINT_FLAGS(HcFlags, HCFLAG_MAP_SX_TO_D3);
    dprintf("\n");

    dprintf("\n");
    dprintf("SavedFrameNumber:     %8x  SavedFRBaseAdd: %8x\n"
            "Port:                 %8x  HcDma:          %8x\n"
            "RegRecClocksPerFrame: %8x  Piix4EP         %8x\n"
            "EndpointListBusy:     %8d  SteppingVer:    %8x\n"
            "SavedSOFModify:       %8x  ControllerType: %8x\n",
            (ULONG) ReadField(SavedFRNUM),
            (ULONG) ReadField(SavedFRBASEADD),
            (ULONG) ReadField(Port),
            (ULONG) ReadField(HcDma),
            (ULONG) ReadField(RegRecClocksPerFrame),
            (ULONG) ReadField(Piix4EP),
            (ULONG) ReadField(EndpointListBusy),
            (ULONG) ReadField(SteppingVersion),
            (ULONG) ReadField(SavedSofModify),
            (ULONG) ReadField(ControllerType));

    return;
}

VOID
UHCD_HCRegisters(
    ULONG64 MemLoc
)
{
    ULONG64             hcObject;
    ULONG64             devExtAddr;

    ULONG               result;
    ULONG64             DeviceRegisters;
    ULONG               regValue;
    ULONG               size;
    ULONG64             TrueDeviceExtension;

    //
    // In this case, MemLoc points the the device object for the given
    //   host controller.
    //

    hcObject = MemLoc;

    //
    // Get the address of the device extension
    //

    GetFieldValue(MemLoc, "uhcd!_DEVICE_OBJECT", "DeviceExtension", devExtAddr);

    //
    // Read the USBD extension
    //

    if (GetFieldValue(devExtAddr, "uhcd!_USBD_EXTENSION", "TrueDeviceExtension", TrueDeviceExtension)) {
        dprintf ("Could not read Usbd Extension\n");
        return;
    }

    if (0 != TrueDeviceExtension) {
        devExtAddr = TrueDeviceExtension;
    }

    if (GetFieldValue(devExtAddr, "uhcd!_DEVICE_EXTENSION", "DeviceRegisters[0]", DeviceRegisters)) {
        dprintf ("Could not read UHCD Extension\n");
        return;
    }

    //
    // Get and display the command register (USBCMD)
    //

    size = 2;
//    ReadIoSpace((ULONG) COMMAND_REG((&uhcd)), &regValue, &size);
    ReadIoSpace64(COMMAND_REG(DeviceRegisters), &regValue, &size);

    dprintf("\n");
    dprintf("Command Register: Run/Stop:       %x  HC reset:      %x  Global reset: %x\n"
            "                  Global Suspend: %x  Global Resume: %x  SW Debug:     %x\n"
            "                  Configure Flag: %x  Max Packet:    %x\n",
                               regValue & UHCD_CMD_RUN,
                               regValue & UHCD_CMD_RESET,
                               regValue & UHCD_CMD_GLOBAL_RESET,
                               regValue & UHCD_CMD_SUSPEND,
                               regValue & UHCD_CMD_FORCE_RESUME,
                               regValue & UHCD_CMD_SW_DEBUG,
                               regValue & UHCD_CMD_SW_CONFIGURED,
                               regValue & UHCD_CMD_MAXPKT_64);

    //
    // Get and display the status register (USBSTS)
    //

    ReadIoSpace64(STATUS_REG(DeviceRegisters), &regValue, &size);

    dprintf("\n");
    dprintf("Status Register:  Transfer Int: %x  Error Int: %x  Resume Detect: %x\n",
            "                  Host Error:   %x  HC Error:  %x  HC Halted: %x\n",
            regValue & UHCD_STATUS_USBINT,
            regValue & UHCD_STATUS_USBERR,
            regValue & UHCD_STATUS_RESUME,
            regValue & UHCD_STATUS_PCIERR,
            regValue & UHCD_STATUS_HCERR,
            regValue & UHCD_STATUS_HCHALT);

    //
    // Get and display the interrupt enable register (USBINTR)
    //

    ReadIoSpace64(INTERRUPT_MASK_REG(DeviceRegisters), &regValue, &size);

    dprintf("\n");
    dprintf("Interrupt Register: ");
    PRINT_FLAGS(regValue, UHCD_INT_MASK_TIMEOUT);
    PRINT_FLAGS(regValue, UHCD_INT_MASK_RESUME);
    PRINT_FLAGS(regValue, UHCD_INT_MASK_IOC);
    PRINT_FLAGS(regValue, UHCD_INT_MASK_SHORT);
    dprintf("\n");

    //
    // Get and display the frame number (FRNUM)
    //

    ReadIoSpace64(FRAME_LIST_CURRENT_INDEX_REG(DeviceRegisters), &regValue, &size);

    dprintf("\n");
    dprintf("Frame Number: %4x  ", regValue);

    //
    // Get and display the frame list base address (FRBASEADD)
    //

    size = 4;
    ReadIoSpace64(FRAME_LIST_BASE_REG(DeviceRegisters), &regValue, &size);

    dprintf("Frame List Base Address: %8x\n", regValue);
    
    //
    // Get and display the SOF Modify register (SOFMOD)
    //

    size = 2;
    ReadIoSpace64(SOF_MODIFY_REG(DeviceRegisters), &regValue, &size);

    dprintf("\n");
    dprintf("SOF Modify (%2x) --> Frame Length = %d\n",
            regValue,
            regValue + UHCD_12MHZ_SOF);

    //
    // Get and display the port status register for port 1
    //

    ReadIoSpace64(PORT1_REG(DeviceRegisters), &regValue, &size);

    UhciPortRegister(1, regValue);

    //
    // Get and display the port status register for port 2
    //

    ReadIoSpace64( PORT2_REG(DeviceRegisters), &regValue, &size);

    UhciPortRegister(2, regValue);

    return;
}

VOID
UhciPortRegister(
    ULONG   PortNumber,
    ULONG   Value
)
{
    dprintf("\n");
    dprintf("Port %2d: Device Connected: %1x  Connect Status Change: %1x\n"
            "          Port Enabled:     %1x  Port Enabled Changed:  %1x\n"
            "          Line Status D+:   %1x  Line Status D-         %1x\n"
            "          Resume Detect:    %1x  LS Device Attached:    %1x\n"
            "          Suspended (%1x):  ",
            PortNumber,
            Value & 0x01,
            Value & 0x02,
            Value & 0x04,
            Value & 0x08,
            Value & 0x10,
            Value & 0x20,
            Value & 0x40,
            Value & 0x100,
            Value & 0x400,
            Value & 0x1800);

    switch (Value & 0x1800)
    {
        case (0x00008000):
            dprintf("Enabled");
            break;

        case (0x00018000):
            dprintf("Suspend");
            break;

        default:
            dprintf("Disabled");
            break;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\usbd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    USBD.c

Abstract:

    WinDbg Extension Api

Author:

    Chris Robinson (crobins) Feburary 1999

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

//#include "usbd.h"

typedef union _URB_FLAGS {
    struct {
        ULONG   FullListing         : 1;
        ULONG   Reserved            : 31;
    };
    ULONG Flags;
} URB_FLAGS;

#define PRINT_FLAGS(value, flag) \
    if ((value) & (flag)) { \
        dprintf (#flag " "); \
    }

extern VOID 
DumpDeviceCapabilities(
    ULONG64 caps
    );

VOID USBD_DumpURB (ULONG64 UrbLoc, URB_FLAGS);
VOID USBD_DeviceDescriptor (PCHAR Comment, ULONG64 Desc);
VOID USBD_InterfaceDescriptor (PCHAR Comment, ULONG64 Desc);
VOID USBD_EndpointDescriptor (PCHAR Comment, ULONG64 Desc);
VOID USBD_PowerDescriptor (PCHAR Comment, ULONG64 Desc);

#define InitTypeReadCheck(Addr, Type)                \
    if (InitTypeRead(Addr, Type)) {                  \
        dprintf("Cannot read %s at %p\n", Addr);     \
        return;                                      \
    }

//
// USBD function definitions
//

DECLARE_API( urb )

/*++

Routine Description:

   Dumps a URB block

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG64         memLoc=0;
    UCHAR           buffer[256];
    URB_FLAGS       flags;

    buffer[0] = '\0';
    flags.Flags = 0;

    if (!*args)
    {
        memLoc = EXPRLastDump;
    }
    else
    {
        if (GetExpressionEx(args, &memLoc, &args)) {
            strcpy(buffer, args);
        }
    }

    if ('\0' != buffer[0])
    {
        flags.Flags = (ULONG) GetExpression(buffer);
    }

    dprintf ("Dump URB %p %x \n", memLoc, flags.Flags);

    USBD_DumpURB (memLoc, flags);
    return S_OK;
}

VOID
USBD_DeviceDescriptor (
    PCHAR   Comment,
    ULONG64 Desc
    )
{
    InitTypeReadCheck(Desc, usbd!USB_DEVICE_DESCRIPTOR);

    dprintf ("%s \n", Comment);
    dprintf ("bLength         %x \t bDescriptor Type %x \t bcdUSB %x\n"
             "bDeviceClass    %x \t bDeviceSubClass  %x \t bDeviceProtocol %x\n"
             "bMaxPacketSize0 %x \t (Vid / Pid / rev)  (%x / %x / %x)\n"
             "Manu %x Prod %x Serial %x #Configs %x\n",
             (ULONG) ReadField(bLength),
             (ULONG) ReadField(bDescriptorType),
             (ULONG) ReadField(bcdUSB),
             (ULONG) ReadField(bDeviceClass),
             (ULONG) ReadField(bDeviceSubClass),
             (ULONG) ReadField(bDeviceProtocol),
             (ULONG) ReadField(bMaxPacketSize0),
             (ULONG) ReadField(idVendor),
             (ULONG) ReadField(idProduct),
             (ULONG) ReadField(bcdDevice),
             (ULONG) ReadField(iManufacturer),
             (ULONG) ReadField(iProduct),
             (ULONG) ReadField(iSerialNumber),
             (ULONG) ReadField(bNumConfigurations));
}

VOID
USBD_ConfigurationDescriptor (
    PCHAR   Comment,
    ULONG64 Config
    )
{
    InitTypeReadCheck(Config, usbd!USB_CONFIGURATION_DESCRIPTOR);

    dprintf ("%s \n", Comment);
    dprintf ("Length      %x \t Desc Type  %x \t TotalLength %d \n"
             "Num Ints    %x \t Config Val %x \t \n"
             "Config Desc %x \t Attrib     %x \t MaxPower %x\n",
             (ULONG) ReadField(bLength),
             (ULONG) ReadField(bDescriptorType),
             (ULONG) ReadField(wTotalLength),
             (ULONG) ReadField(bNumInterfaces),
             (ULONG) ReadField(bConfigurationValue),
             (ULONG) ReadField(iConfiguration),
             (ULONG) ReadField(bmAttributes),
             (ULONG) ReadField(MaxPower));

    return;
}

VOID
USBD_InterfaceDescriptor (
    PCHAR   Comment,
    ULONG64 Interface
    )
{
    InitTypeReadCheck(Interface, usbd!USB_INTERFACE_DESCRIPTOR);

    dprintf ("%s \n", Comment);
    dprintf ("Length      %x \t Desc Type %x \t Interface Number %x\n"
             "Alt Setting %x \t Num Ends  %x \t \n"
             "Class       %x \t SubClass  %x \t Protocol %x \n"
             "Interface   %x\n",
             (ULONG) ReadField(bLength),
             (ULONG) ReadField(bDescriptorType),
             (ULONG) ReadField(bInterfaceNumber),
             (ULONG) ReadField(bAlternateSetting),
             (ULONG) ReadField(bNumEndpoints),
             (ULONG) ReadField(bInterfaceClass),
             (ULONG) ReadField(bInterfaceSubClass),
             (ULONG) ReadField(bInterfaceProtocol),
             (ULONG) ReadField(iInterface));
}

VOID
USBD_EndpointDescriptor (
    PCHAR   Comment,
    ULONG64 Endpoint
    )
{
    InitTypeReadCheck(Endpoint, usbd!USB_ENDPOINT_DESCRIPTOR);

    dprintf ("%s \n", Comment);
    dprintf ("Length %x  \t Desc Type %x     \t EndAddress %x\n"
             "Attribs %x \t MaxPacketSize %x \t Interval %x\n",
             (ULONG) ReadField(bLength),
             (ULONG) ReadField(bDescriptorType),
             (ULONG) ReadField(bEndpointAddress),
             (ULONG) ReadField(bmAttributes),
             (ULONG) ReadField(wMaxPacketSize),
             (ULONG) ReadField(bInterval));
}

VOID
USBD_PowerDescriptor (
    PCHAR   Comment,
    ULONG64 Power
    )
{
    dprintf ("%s - not implemented\n", Comment);
}

VOID
USBD_Pipe(
    PCHAR           Comment,
    ULONG64         PipeHandle
)
{
    ULONG   numEndpoints, Sig, Off;

    dprintf ("%s \n", Comment);

    if (0 == PipeHandle) 
    {
        dprintf("Pipe Handle is NULL\n");
        return;
    }
    InitTypeReadCheck(PipeHandle, usbd!USBD_PIPE);

    Sig = (ULONG) ReadField(Sig);

    dprintf("Signature: %c%c%c%c\n"
            "HcdEndpoint: %08x \t MPS  %x \t Sched Offset %x\n",
            ((PUCHAR) &Sig)[0],
            ((PUCHAR) &Sig)[1],
            ((PUCHAR) &Sig)[2],
            ((PUCHAR) &Sig)[3],
            (ULONG) ReadField(HcdEndpoint),
            (ULONG) ReadField(MaxTransferSize),
            (ULONG) ReadField(ScheduleOffset));

    dprintf("\n");
    dprintf("Endpoint Descriptor\n"
            "-------------------");

    GetFieldOffset("usbd!USBD_PIPE", "EndpointDescriptor", &Off);
    USBD_EndpointDescriptor("", (PipeHandle + Off)); 

    return;
}

VOID
USBD_Interface(
    ULONG64 MemLoc
)
{
    ULONG                       i;
    ULONG                       numEndpoints;
    ULONG                       Off;
    ULONG                       Sig;
    ULONG                       PipeSize;

    InitTypeReadCheck(MemLoc, usbd!_USBD_INTERFACE);

    numEndpoints  = (ULONG) ReadField(InterfaceDescriptor.bNumEndpoints);
    Sig           = (ULONG) ReadField(Sig);

    dprintf("Signature: %c%c%c%c\n",
            ((PUCHAR) &Sig)[0],
            ((PUCHAR) &Sig)[1],
            ((PUCHAR) &Sig)[2],
            ((PUCHAR) &Sig)[3]);
    
    dprintf("Has Alt Settings: %x\n",
            (ULONG) ReadField(HasAlternateSettings));

    dprintf("Interface Info: %x\n",
            (ULONG) ReadField(InterfaceInformation));

    dprintf("\n");
    dprintf("Interface Descriptor\n"
            "--------------------");

    GetFieldOffset("usbd!_USBD_INTERFACE", "InterfaceDescriptor", &Off);
    USBD_InterfaceDescriptor("", MemLoc + Off);

    GetFieldOffset("usbd!_USBD_INTERFACE", "PipeHandle", &Off);
    PipeSize = GetTypeSize("usbd!USBD_PIPE");

    for (i = 0; i < numEndpoints; i++) 
    {
        dprintf("\n");
        dprintf("Pipe Handle\n"
                "-----------");

        USBD_Pipe("", MemLoc + i*PipeSize);
    }
    return;
}

VOID
USBD_ConfigHandle(
    ULONG64   MemLoc
)
{
    ULONG                           configDataSize;
    ULONG                           i;
    ULONG                           numInterfaces;
    ULONG                           Sz, Sig;
    ULONG64                         ConfigurationDescriptor, InterfaceHandle;

    if (GetFieldValue(MemLoc, "usbd!_USBD_CONFIG",
                      "ConfigurationDescriptor", ConfigurationDescriptor))
    {
        dprintf("Could not read configuration handle\n");
        return;
    }

    InitTypeReadCheck(ConfigurationDescriptor, usbd!USB_CONFIGURATION_DESCRIPTOR);

    numInterfaces  = (ULONG) ReadField(bNumInterfaces);
    
    InitTypeRead(MemLoc, usbd!_USBD_CONFIG);
    Sig            = (ULONG) ReadField(Sig);


    dprintf("Signature: %c%c%c%c\n",
            ((PUCHAR) &Sig)[0],
            ((PUCHAR) &Sig)[1],
            ((PUCHAR) &Sig)[2],
            ((PUCHAR) &Sig)[3]);

    dprintf("Config Descriptor: %08p\n", ConfigurationDescriptor);

    InterfaceHandle = ReadField(InterfaceHandle[0]);
    Sz= GetTypeSize("usbd!USBD_INTERFACE");
    
    USBD_ConfigurationDescriptor("", ConfigurationDescriptor);

    for (i = 0; 0 != InterfaceHandle && i < numInterfaces; i++) 
    {
        InitTypeReadCheck(InterfaceHandle, usbd!_USBD_INTERFACE);

        dprintf("\n");
        dprintf("Interface Handle: %08x\n"
                "-----------------\n",
                InterfaceHandle);

        USBD_Interface(InterfaceHandle);
        InterfaceHandle += Sz;
    }

    return;
}
 
VOID
URB_HCD_AREA(ULONG64 Hcd) 
{
    InitTypeRead(Hcd, usbd!_URB_HCD_AREA);
    dprintf ("HCD_Area: HcdEndpoint %x HcdIrp %x \n" 
             "          HcdList (%x, %x) HcdList2 (%x, %x) \n" 
             "          CurrentIoFlush %x HcdExt %x \n", 
             (ULONG) ReadField(HcdEndpoint), 
             (ULONG) ReadField(HcdIrp), 
             (ULONG) ReadField(HcdListEntry.Flink), 
             (ULONG) ReadField(HcdListEntry.Blink), 
             (ULONG) ReadField(HcdListEntry2.Flink),
             (ULONG) ReadField(HcdListEntry2.Blink),
             (ULONG) ReadField(HcdCurrentIoFlushPointer),
             (ULONG) ReadField(HcdExtension));
}


VOID
USBD_DumpURB (
    ULONG64     MemLoc,
    URB_FLAGS   Flags
    )
{
    ULONG64         urbLoc;
    ULONG           result;
    ULONG           i;
//    PURB            urb;
//    PHCD_URB        hcd;
//    URB             urbBuffer;
    ULONG64         packetLoc;
//    PUSBD_ISO_PACKET_DESCRIPTOR  packet;
//    USBD_ISO_PACKET_DESCRIPTOR   packetBuffer;
    BOOLEAN         again;

    UNREFERENCED_PARAMETER (Flags);

    urbLoc = MemLoc;
    
    InitTypeReadCheck(urbLoc, usbd!_URB_HEADER);

#define URB_HEADER() \
    dprintf ("URB : Fn %x len %x stat %x DevH %x Flgs %x\n", \
              (ULONG) ReadField(UrbHeader.Function), \
              (ULONG) ReadField(UrbHeader.Length), \
              (ULONG) ReadField(UrbHeader.Status), \
              (ULONG) ReadField(UrbHeader.UsbdDeviceHandle), \
              (ULONG) ReadField(UrbHeader.UsbdFlags))

    again = TRUE;
    while (again && urbLoc) {

        dprintf (" ---- URB: %x ---- \n", urbLoc);
        again = FALSE;

        InitTypeReadCheck (urbLoc, usbd!_URB_HEADER);

        switch (ReadField(Function)) {
        case URB_FUNCTION_SELECT_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_SELECT_INTERFACE);
            dprintf ("Select Interface: ConfigHandle %x Interface %x\n",
                     (ULONG) ReadField(UrbSelectInterface.ConfigurationHandle),
                     (ULONG) ReadField(UrbSelectInterface.Interface));
            URB_HEADER();

            break;

        case URB_FUNCTION_SELECT_CONFIGURATION:
            InitTypeReadCheck (urbLoc, usbd!_URB_SELECT_CONFIGURATION);
            dprintf ("Select Config: Config Desc %x Hand %x Int %x\n",
                     (ULONG) ReadField(UrbSelectConfiguration.ConfigurationDescriptor),
                     (ULONG) ReadField(UrbSelectConfiguration.ConfigurationHandle),
                     (ULONG) ReadField(UrbSelectConfiguration.Interface));
            URB_HEADER();
            break;

        case URB_FUNCTION_ABORT_PIPE:
            InitTypeReadCheck (urbLoc, usbd!_URB_PIPE_REQUEST);
            dprintf ("Abort Pipe: %x\n", (ULONG) ReadField(UrbPipeRequest.PipeHandle));
            URB_HEADER();
            break;

        case URB_FUNCTION_RESET_PIPE:
            InitTypeReadCheck (urbLoc, usbd!_URB_PIPE_REQUEST);
            dprintf ("Reset Pipe: %x\n",  (ULONG) ReadField(UrbPipeRequest.PipeHandle));
            URB_HEADER();
            break;

        case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
            InitTypeReadCheck (urbLoc, usbd!_URB_FRAME_LENGTH_CONTROL);
            dprintf ("Get Frame Length Control \n");
            URB_HEADER();
            break;

        case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
            InitTypeReadCheck (urbLoc, usbd!_URB_FRAME_LENGTH_CONTROL);
            dprintf ("Release Frame Length Control \n");
            URB_HEADER();
            break;

        case URB_FUNCTION_GET_FRAME_LENGTH:
            InitTypeReadCheck (urbLoc, usbd!_URB_GET_FRAME_LENGTH);
            dprintf ("Get Frame Length %x Num %x \n",
                     (ULONG) ReadField(UrbGetFrameLength.FrameLength),
                     (ULONG) ReadField(UrbGetFrameLength.FrameNumber));
            URB_HEADER();
            break;

        case URB_FUNCTION_SET_FRAME_LENGTH:
            InitTypeReadCheck (urbLoc, usbd!_URB_SET_FRAME_LENGTH);
            dprintf ("Set Frame Length Delta %x \n",
                      (ULONG) ReadField(UrbSetFrameLength.FrameLengthDelta));
            URB_HEADER();
            break;

        case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
            InitTypeReadCheck (urbLoc, usbd!_URB_GET_CURRENT_FRAME_NUMBER);
            dprintf ("Current Frame Number %x \n",
                      (ULONG) ReadField(UrbGetCurrentFrameNumber.FrameNumber));
            URB_HEADER();
            break;

        case URB_FUNCTION_CONTROL_TRANSFER:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_TRANSFER);
            dprintf ("Control Xfer: Pipe %x Flags %x "
                     "Len %x Buffer %x MDL %x HCA %x "
                     "SetupPacket: %02.02x %02.02x %02.02x %02.02x "
                     "%02.02x %02.02x %02.02x %02.02x\n",
                     (ULONG) ReadField(UrbControlTransfer.PipeHandle),
                     (ULONG) ReadField(UrbControlTransfer.TransferFlags),
                     (ULONG) ReadField(UrbControlTransfer.TransferBufferLength),
                     (ULONG) ReadField(UrbControlTransfer.TransferBuffer),
                     (ULONG) ReadField(UrbControlTransfer.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlTransfer.hca),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[0]),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[1]),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[2]),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[3]),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[4]),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[5]),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[6]),
                     (ULONG) ReadField(UrbControlTransfer.SetupPacket[7]));
            URB_HCD_AREA ( ReadField(UrbControlTransfer.hca));
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_TRANSFER);
            URB_HEADER();
            urbLoc = ReadField(UrbControlTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
            InitTypeReadCheck (urbLoc, usbd!_URB_BULK_OR_INTERRUPT_TRANSFER);
            dprintf ("Bulk | Interrupt Xfer: Pipe %x Flags %x "
                     "Len %x Buffer %x MDL %x HCA %x\n",
                     (ULONG) ReadField(UrbBulkOrInterruptTransfer.PipeHandle),
                     (ULONG) ReadField(UrbBulkOrInterruptTransfer.TransferFlags),
                     (ULONG) ReadField(UrbBulkOrInterruptTransfer.TransferBufferLength),
                     (ULONG) ReadField(UrbBulkOrInterruptTransfer.TransferBuffer),
                     (ULONG) ReadField(UrbBulkOrInterruptTransfer.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlTransfer.hca));
            URB_HCD_AREA (ReadField(UrbBulkOrInterruptTransfer.hca));
            InitTypeReadCheck (urbLoc, usbd!_URB_BULK_OR_INTERRUPT_TRANSFER);
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_ISOCH_TRANSFER: {
            ULONG Off, Sz, NumberOfPackets;

            InitTypeReadCheck (urbLoc, usbd!_URB_ISOCH_TRANSFER);
            dprintf ("Isoch Xfer: Pipe %x Flags %x "
                     "Len %x Buffer %x MDL %x HCA %p "
                     "StartFrame %x NumPkts %x ErrorCount %x\n",
                     (ULONG) ReadField(UrbIsochronousTransfer.PipeHandle),
                     (ULONG) ReadField(UrbIsochronousTransfer.TransferFlags),
                     (ULONG) ReadField(UrbIsochronousTransfer.TransferBufferLength),
                     (ULONG) ReadField(UrbIsochronousTransfer.TransferBuffer),
                     (ULONG) ReadField(UrbIsochronousTransfer.TransferBufferMDL),
                     ReadField(UrbIsochronousTransfer.hca),
                     (ULONG) ReadField(UrbIsochronousTransfer.StartFrame),
                     (ULONG) ReadField(UrbIsochronousTransfer.NumberOfPackets),
                     (ULONG) ReadField(UrbIsochronousTransfer.ErrorCount));
            URB_HCD_AREA (ReadField(UrbIsochronousTransfer.hca));
            InitTypeReadCheck (urbLoc, usbd!_URB_ISOCH_TRANSFER);
            URB_HEADER();
            
            NumberOfPackets = (ULONG) ReadField(UrbIsochronousTransfer.NumberOfPackets);

            GetFieldOffset("usbd!_URB_ISOCH_TRANSFER", "IsoPacket", &Off);
            Sz = GetTypeSize("usbd!USBD_ISO_PACKET_DESCRIPTOR");
            packetLoc = urbLoc + Off;

            for (i = 0; i < NumberOfPackets; i++) {

                InitTypeReadCheck (packetLoc, usbd!USBD_ISO_PACKET_DESCRIPTOR);

                dprintf ("[%2x]: Offset %6x, Length %4x, Status %8x\n",
                         i,
                         (ULONG) ReadField(Offset),
                         (ULONG) ReadField(Length),
                         (ULONG) ReadField(Status));

                packetLoc += Sz;
            }
            break;
        }

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_DESCRIPTOR_REQUEST);
            dprintf ("Device Desc: Length %x Buffer %x MDL %x "
                     "Index %x Type %x Lang %x HCA %x\n",
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlDescriptorRequest.Index),
                     (ULONG) ReadField(UrbControlDescriptorRequest.DescriptorType),
                     (ULONG) ReadField(UrbControlDescriptorRequest.LanguageId),
                     (ULONG) ReadField(UrbControlDescriptorRequest.hca));
            URB_HEADER();
            urbLoc = ReadField(UrbControlDescriptorRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_DESCRIPTOR_REQUEST);
            dprintf ("Endpoint Desc: Length %x Buffer %x MDL %x "
                     "Index %x Type %x Lang %x HCA %p\n",
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlDescriptorRequest.Index),
                     (ULONG) ReadField(UrbControlDescriptorRequest.DescriptorType),
                     (ULONG) ReadField(UrbControlDescriptorRequest.LanguageId),
                     (ULONG) ReadField(UrbControlDescriptorRequest.hca));
            URB_HEADER();
            urbLoc = ReadField(UrbControlDescriptorRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_DESCRIPTOR_REQUEST);
            dprintf ("Interface Desc: Length %x Buffer %x MDL %x "
                     "Index %x Type %x Lang %x HCA %p\n",
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlDescriptorRequest.Index),
                     (ULONG) ReadField(UrbControlDescriptorRequest.DescriptorType),
                     (ULONG) ReadField(UrbControlDescriptorRequest.LanguageId),
                     (ULONG) ReadField(UrbControlDescriptorRequest.hca));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_DESCRIPTOR_REQUEST);
            dprintf ("SET Device Desc: Length %x Buffer %x MDL %x "
                     "Index %x Type %x Lang %x HCA %p\n",
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlDescriptorRequest.Index),
                     (ULONG) ReadField(UrbControlDescriptorRequest.DescriptorType),
                     (ULONG) ReadField(UrbControlDescriptorRequest.LanguageId),
                     ReadField(UrbControlDescriptorRequest.hca));
            URB_HEADER();
            urbLoc = (ULONG) (ULONG) ReadField(UrbControlDescriptorRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_DESCRIPTOR_REQUEST);
            dprintf ("SET End Desc: Length %x Buffer %x MDL %x "
                     "Index %x Type %x Lang %x HCA %p\n",
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlDescriptorRequest.Index),
                     (ULONG) ReadField(UrbControlDescriptorRequest.DescriptorType),
                     (ULONG) ReadField(UrbControlDescriptorRequest.LanguageId),
                     ReadField(UrbControlDescriptorRequest.hca));
            URB_HEADER();
            urbLoc = ReadField(UrbControlDescriptorRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_DESCRIPTOR_REQUEST);
            dprintf ("SET Intrfc Desc: Len %x Buffer %x MDL %x "
                     "Index %x Type %x Lang %x HCA %p\n",
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlDescriptorRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlDescriptorRequest.Index),
                     (ULONG) ReadField(UrbControlDescriptorRequest.DescriptorType),
                     (ULONG) ReadField(UrbControlDescriptorRequest.LanguageId),
                     ReadField(UrbControlDescriptorRequest.hca));
            URB_HEADER();
            urbLoc = ReadField(UrbControlDescriptorRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Set Dev Feature: Selector %x Index %x\n",
                     (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                     (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Set Interface Feature: Selector %x Index %x\n",
                     (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                     (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Set Endpoint Feature: Selector %x Index %x\n",
                     (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                     (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_OTHER:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Set Other Feature: Selector %x Index %x\n",
                     (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                     (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Clear Device Feature: Selector %x Index %x\n",
                     (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                     (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Clear Interface Feature: Selector %x Index %x\n",
                    (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                    (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Clear Endpoint Feature: Selector %x Index %x\n",
                     (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                     (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_FEATURE_REQUEST);
            dprintf ("Clear Other Feature: Selector %x Index %x\n",
                     (ULONG) ReadField(UrbControlFeatureRequest.FeatureSelector),
                     (ULONG) ReadField(UrbControlFeatureRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlFeatureRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_GET_STATUS_REQUEST);
            dprintf ("Get Device Status: len %x Buffer %x MDL %x "
                     "Index %x\n",
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlGetStatusRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlGetStatusRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_GET_STATUS_REQUEST);
            dprintf ("Get Interface Status: len %x Buffer %x MDL %x "
                     "Index %x\n",
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlGetStatusRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlGetStatusRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_GET_STATUS_REQUEST);
            dprintf ("Get Endpoint Status: len %x Buffer %x MDL %x "
                     "Index %x\n",
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlGetStatusRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlGetStatusRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_OTHER:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_GET_STATUS_REQUEST);
            dprintf ("Get Other Status: len %x Buffer %x MDL %x "
                     "Index %x\n",
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlGetStatusRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlGetStatusRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbControlGetStatusRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_DEVICE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Vendor Device Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Vendor Intfc Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Vendor Endpt Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_OTHER:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Vendor Other Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_DEVICE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Class Device Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Class Intface Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Class Endpnt Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_OTHER:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
            dprintf ("Class Other Req: len %x Buffer %x MDL %x "
                     "Flags %x RequestTypeBits %x "
                     "Request %x Value %x Index %x\n",
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferBufferMDL),
                     (ULONG) ReadField(UrbControlVendorClassRequest.TransferFlags),
                     (ULONG) ReadField(UrbControlVendorClassRequest.RequestTypeReservedBits),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Request),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Value),
                     (ULONG) ReadField(UrbControlVendorClassRequest.Index));
            URB_HEADER();
            urbLoc = ReadField(UrbBulkOrInterruptTransfer.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_CONFIGURATION:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_GET_CONFIGURATION_REQUEST);
            dprintf ("Get Configuration: len %x Buffer %x MDL %x "
                     "\n",
                     (ULONG) ReadField(UrbControlGetConfigurationRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlGetConfigurationRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlGetConfigurationRequest.TransferBufferMDL));
            URB_HEADER();
            urbLoc = ReadField(UrbControlGetConfigurationRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_GET_INTERFACE:
            InitTypeReadCheck (urbLoc, usbd!_URB_CONTROL_GET_INTERFACE_REQUEST);
            dprintf ("Get Interface: len %x Buffer %x MDL %x "
                     "\n",
                     (ULONG) ReadField(UrbControlGetInterfaceRequest.TransferBufferLength),
                     (ULONG) ReadField(UrbControlGetInterfaceRequest.TransferBuffer),
                     (ULONG) ReadField(UrbControlGetInterfaceRequest.TransferBufferMDL));
            URB_HEADER();
            urbLoc = ReadField(UrbControlGetConfigurationRequest.UrbLink);
            again = TRUE;
            break;

        case URB_FUNCTION_HCD_OPEN_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_HCD_URB);
            dprintf ("HCD: Open: DevAddr %x EndDesc %x "
                     "Xfer %x HcdEndpoint %x ",
                     (ULONG) ReadField(HcdUrbOpenEndpoint.DeviceAddress),
                     (ULONG) ReadField(HcdUrbOpenEndpoint.EndpointDescriptor),
                     (ULONG) ReadField(HcdUrbOpenEndpoint.MaxTransferSize),
                     (ULONG) ReadField(HcdUrbOpenEndpoint.HcdEndpoint));

//
// JD is currently in the process of changing this interface...It has 
//  already been changed for Win98 OSR but changes to hcdi.h have not
//  yet been checked in for Win2k.  But we'll anticipate those changes and 
//  make a conditional define here.
//

// #ifdef USBD_EP_FLAG_LOWSPEED
//            if ((ULONG) ReadField(HcdUrbOpenEndpoint.HcdEndpointFlags) & USBD_EP_FLAG_LOWSPEED) {
// #else            
            if (ReadField(HcdUrbOpenEndpoint.LowSpeed)) {
// #endif

                dprintf ("LowSpeed ");
            }

// #ifdef USBD_EP_FLAG_NEVERHALT
//            if ((ULONG) ReadField(HcdUrbOpenEndpoint.HcdEndpointFlags) & USBD_EP_FLAG_NEVERHALT) {
// #else            
            if (ReadField(HcdUrbOpenEndpoint.NeverHalt)) {
// #endif
                dprintf ("NeverHalt");
            }
            dprintf ("\n");
            InitTypeReadCheck (urbLoc, uabd!_URB_HCD_OPEN_ENDPOINT);
            URB_HEADER();
            break;

        case URB_FUNCTION_HCD_CLOSE_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_HCD_URB);
            dprintf ("HCD: Close Endpoint: HcdEndpoint %x \n",
                     (ULONG) ReadField(HcdUrbCloseEndpoint.HcdEndpoint));
            InitTypeReadCheck (urbLoc, _URB_HCD_CLOSE_ENDPOINT);
            URB_HEADER();
            break;

        case URB_FUNCTION_HCD_GET_ENDPOINT_STATE:
            InitTypeReadCheck (urbLoc, usbd!_HCD_URB);
            dprintf ("HCD: Get Endpoint State: HcdEndpoint %x state %x \n",
                     (ULONG) ReadField(HcdUrbEndpointState.HcdEndpoint),
                     (ULONG) ReadField(HcdUrbEndpointState.HcdEndpointState));
            InitTypeReadCheck (urbLoc, usbd!_URB_HCD_ENDPOINT_STATE);
            URB_HEADER();
            break;

        case URB_FUNCTION_HCD_SET_ENDPOINT_STATE:
            InitTypeReadCheck (urbLoc, usbd!_HCD_URB);
            dprintf ("HCD: Set Endpoint State: HcdEndpoint %x state %x \n",
                     (ULONG) ReadField(HcdUrbEndpointState.HcdEndpoint),
                     (ULONG) ReadField(HcdUrbEndpointState.HcdEndpointState));
            URB_HEADER();
            break;

        case URB_FUNCTION_HCD_ABORT_ENDPOINT:
            InitTypeReadCheck (urbLoc, usbd!_HCD_URB);
            dprintf ("HCD: Abort Endpoint: HcdEndpoint %x \n",
                     (ULONG) ReadField(HcdUrbAbortEndpoint.HcdEndpoint));
            InitTypeReadCheck (urbLoc, usbd!_URB_HCD_ABORT_ENDPOINT);
            URB_HEADER();
            break;

        default:
            dprintf ("WARNING Unkown urb type %x\n", (ULONG) ReadField(Function));
        }
    }
}

VOID
DevExtUsbd(
    ULONG64 MemLocPtr
    )
/*++

Routine Description:

    Dump a USBD Device extension.

Arguments:

    Extension   Address of the extension to be dumped.

Return Value:

    None.

--*/
{
    ULONG           result, Flags, HcWakeFlags, DeviceHackFlags;
    ULONG64         MemLoc = MemLocPtr, TrueDeviceExtension;
//    USBD_EXTENSION  usbd;

    dprintf ("Dump USBD Extension: %p\n", MemLoc);

    if (!ReadPointer(MemLoc, &TrueDeviceExtension)) {
        dprintf ("Could not read Usbd Extension\n");
        return;
    }

    if (TrueDeviceExtension) {
        MemLoc = TrueDeviceExtension;
    }


    InitTypeReadCheck(MemLoc, usbd!_USBD_EXTENSION);
    
    dprintf ("True DevExt: %p, Flags %x ",
             ReadField(TrueDeviceExtension),
             (Flags = (ULONG) ReadField(Flags)));
    PRINT_FLAGS (Flags, USBDFLAG_PDO_REMOVED);
    PRINT_FLAGS (Flags, USBDFLAG_HCD_SHUTDOWN);
    dprintf ("\n");

    dprintf ("Hcd Calls: RhPo %x DefStart %x SetPo %x GetFrame %x\n",
             (ULONG) ReadField(RootHubPower),
             (ULONG) ReadField(HcdDeferredStartDevice),
             (ULONG) ReadField(HcdSetDevicePowerState),
             (ULONG) ReadField(HcdGetCurrentFrame));

    dprintf ("\n");
    dprintf ("HcCurrentPowerState %x, PendingWake %x, HcWake %x\n",
             (ULONG) ReadField(HcCurrentDevicePowerState),
             (ULONG) ReadField(PendingWakeIrp),
             (ULONG) ReadField(HcWakeIrp));

    DumpDeviceCapabilities ( ReadField(HcDeviceCapabilities));
    DumpDeviceCapabilities ( ReadField(RootHubDeviceCapabilities));

    dprintf ("Power Irp %p", ReadField(PowerIrp));

    dprintf ("Address List: %x %x %x %x\n",
             (ULONG) ReadField(AddressList[0]),
             (ULONG) ReadField(AddressList[1]),
             (ULONG) ReadField(AddressList[2]),
             (ULONG) ReadField(AddressList[3]));

    dprintf ("DeviceLinkUnicode String (%x %x) %p\n",
             (ULONG) ReadField(DeviceLinkUnicodeString.Length),
             (ULONG) ReadField(DeviceLinkUnicodeString.MaximumLength),
             ReadField(DeviceLinkUnicodeString.Buffer));

//    dprintf ("Diag Mode (& %x == %x) Flags (& %x == %x)\n",
    dprintf ("Diag Mode (%x) Flags (%x)\n",
//             MemLoc + FIELD_OFFSET (USBD_EXTENSION, DiagnosticMode),
             (ULONG) ReadField(DiagnosticMode),
//             MemLoc + FIELD_OFFSET (USBD_EXTENSION, DiagIgnoreHubs),
             (ULONG) ReadField(DiagIgnoreHubs));

    dprintf ("\n");
    dprintf ("HcWakeFlags %x ", HcWakeFlags = (ULONG) ReadField(HcWakeFlags));
    PRINT_FLAGS (HcWakeFlags, HC_ENABLED_FOR_WAKEUP);
    PRINT_FLAGS (HcWakeFlags, HC_WAKE_PENDING);
    dprintf ("\n");

    dprintf ("DeviceHackFlags %x ", DeviceHackFlags = (ULONG) ReadField(DeviceHackFlags));
    PRINT_FLAGS (DeviceHackFlags, USBD_DEVHACK_SLOW_ENUMERATION);
    PRINT_FLAGS (DeviceHackFlags, USBD_DEVHACK_DISABLE_SN);
    dprintf ("\n");

    dprintf ("RootHubDeviceData %x\n", (ULONG) ReadField(RootHubDeviceData));

    dprintf ("RootHubPowerState %x SuspendPowerState %x \n",
             (ULONG) ReadField(RootHubDeviceState),
             (ULONG) ReadField(SuspendPowerState));

    dprintf ("RootHubSymLink (%x %x) %p\n",
             (ULONG) ReadField(RootHubSymbolicLinkName.Length),
             (ULONG) ReadField(RootHubSymbolicLinkName.MaximumLength),
             ReadField(RootHubSymbolicLinkName.Buffer));
}

VOID
USBD_DeviceHandle(
    ULONG64   MemLoc
)
{
    ULONG               Sig;

    InitTypeReadCheck(MemLoc, usbd!_USBD_DEVICE_DATA);

    Sig = (ULONG) ReadField(Sig);

    dprintf("Signature:          %c%c%c%c\n"
            "DeviceAddress:      %d\n"
            "Config Handle:      %08x\n"
            "LowSpeed:           %d\n"
            "AcceptingRequests:  %d\n",
            ((PUCHAR) &Sig)[0],
            ((PUCHAR) &Sig)[1],
            ((PUCHAR) &Sig)[2],
            ((PUCHAR) &Sig)[3],
            (ULONG) ReadField(DeviceAddress),
            (ULONG) ReadField(ConfigurationHandle),
            (ULONG) ReadField(LowSpeed),
            (ULONG) ReadField(AcceptingRequests));

    dprintf("\n");
    dprintf("Default Pipe\n"
            "------------");

    USBD_Pipe("", ReadField(DefaultPipe));

    dprintf("\n");
    dprintf("Device Descriptor\n"
            "-----------------");

    USBD_DeviceDescriptor("",  ReadField(DeviceDescriptor));
            
    dprintf("\n");
    dprintf("Configuration Handle\n" 
            "--------------------\n");

    USBD_ConfigHandle( ReadField(ConfigurationHandle));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\usb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    USB.c

Abstract:

    WinDbg Extension Api

Author:

    Kenneth D. Ray (kenray) June 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

typedef union _USB_FLAGS {
    struct {
        ULONG   FullListing         : 1;
        ULONG   Reserved            : 31;
    };
    ULONG Flags;
} USB_FLAGS;

#define PRINT_FLAGS(value, flag) \
    if ((value) & (flag)) { \
        dprintf (#flag " "); \
    }

#define DESC_MAXTOKENS 3
#define DESC_MAXBUFFER 80
#define DESC_USAGE() { UsbStrucUsage(); return E_INVALIDARG; }

extern
ULONG
TokenizeString(
              PUCHAR Input,
              PUCHAR *Output,
              ULONG  Max
              );
   
extern
VOID
OhciHcdTd (
    ULONG64 MemLoc
    );

extern
VOID 
OhciHcdEd (
    ULONG64 MemLoc
    );

extern
VOID
OhciEndpoint (
    ULONG64 MemLoc
    );

extern
VOID
OhciHCRegisters(
    ULONG64   MemLoc
    );

extern
VOID
OhciHCCA(
    ULONG64   MemLoc
);

extern
VOID
OhciHcEd(
    ULONG64   MemLoc
);

extern
VOID
OhciHcTd(
    ULONG64 MemLoc
);

VOID
UHCD_HCRegisters(
    ULONG64   MemLoc
);

extern
VOID
USBD_DeviceHandle(
    ULONG64   MemLoc
);


VOID
UsbStrucUsage ()
{
    dprintf("!UsbStruc <address> <type>\n");
    dprintf("  <address> - address of a structure to be dumped\n");
    dprintf("  <type>    - {OHCIReg | HCCA | OHCIHcdED | OHCIHcdTD |\n"
            "               OHCIEndpoint | DevData | UHCDReg  }\n");
    dprintf("\n");
}

DECLARE_API ( usbstruc )
{
    ULONG64  Desc = 0;
    PUCHAR Tokens[DESC_MAXTOKENS];
    UCHAR  Buffer[DESC_MAXBUFFER];
    PUCHAR s;
    UCHAR  c;
    ULONG  count;
 
    //
    // Validate parameters.   Tokenize the incoming string, the first
    // argument should be a (kernel mode) address, the second a string.
    //
 
    //
    // args is const, we need to modify the buffer, copy it.
    //
 
    for (count = 0; count < DESC_MAXBUFFER; count++) {
       if ((Buffer[count] = args[count]) == '\0') {
          break;
       }
    }
    if (count == DESC_MAXBUFFER) {
        dprintf("Buffer to small to contain input arguments\n");
        DESC_USAGE();
    }
 
    if (TokenizeString(Buffer, Tokens, DESC_MAXTOKENS) !=
        (DESC_MAXTOKENS - 1)) {
        DESC_USAGE();
    }
 
    if ((Desc = GetExpression(Tokens[0])) == 0) {
        DESC_USAGE();
    }

    //
    // The second argument should be a string telling us what kind of
    // device extension to dump.  Convert it to upper case to make life
    // easier.
    //
 
    s = Tokens[1];
    while ((c = *s) != '\0') {
       *s++ = (UCHAR)toupper(c);
    }
 
    s = Tokens[1];
    if (!strcmp(s, "OHCIHCDED")) {
 
        //
        // It's an OpenHCI Hcd Endpoint Descriptor
        //
        OhciHcdEd (Desc);
 
    } else if (!strcmp(s, "OHCIHCDTD")) {
 
        //
        // It's an OpenHCI Hcd Transfer Descriptor
        //
        OhciHcdTd (Desc);
 
    } else if (!strcmp(s, "OHCIENDPOINT")) {
 
        //
        // It's an OpenHCI Hcd Endpoint Descriptor
        //
        OhciEndpoint(Desc);
 
    } else if (!strcmp(s, "OHCIREG")) {
 
        //
        // It's the OpenHCI Registers
        //
        OhciHCRegisters(Desc);
 
    } else if (!strcmp(s, "HCCA")) {
 
        //
        // It's the OpenHCI HCCA
        //
        OhciHCCA(Desc);

    } else if (!strcmp(s, "OHCIHCED")) {
 
        //
        // It's the OpenHCI HcED
        //
        OhciHcEd(Desc);

    } else if (!strcmp(s, "OHCIHCTD")) {
 
        //
        // It's the OpenHCI HcTD
        //
        OhciHcTd(Desc);

    } else if (!strcmp(s, "DEVDATA")) {
 
        //
        // It's the USBD_DEVICE_DATA
        //

        USBD_DeviceHandle(Desc);

    } else if (!strcmp(s, "UHCDREG")) {
 
        //
        // It's the UHCD_Registers
        //

//        UHCD_HCRegisters(Desc);
    

 
#if 0

   } else if (!strcmp(s, "SOME_OTHER_DESCRIPTOR_TYPE")) {

       //
       // It's some other extension type.
       //

       UsbStruc (Extension);

#endif
   } else {
      dprintf("Structure type '%s' is not handled by !usbStruc.\n", s);
   }
   return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\usblog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    USBLOG.c

Abstract:

    WinDbg Extension Api

Author:

    Chris Robinson (crobins) February 1999

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

#ifndef MAKE_SYMBOL
    #define MAKE_SYMBOL(m, s)   #m "!" #s
#endif
                                
#define DUMP_STRING(s)          dprintf((s))
#define DUMP_DWORD(d)           dprintf("0x%08x", (d))
#define DUMP_ADDRESS(a)         dprintf("0x%08p", (a))
#define END_LINE()              dprintf("\n")

#define TRACE_SPEW              

#define DECLARE_LOG(logname, name, start, end, ptr, lines, desc) \
        static struct _USB_LOG logname = {  name, start, end, ptr, \
                                            0, 0, 0, 0,            \
                                            0, 0, lines, desc };

#define DEFAULT_LINES_TO_DUMP   16

#define TAG_CHAR_LENGTH     4
#define TAG_STRING_LENGTH   TAG_CHAR_LENGTH+1

#define LOG_SEARCH_DELIMS   ","

#define LogHasRolledOver(log)       (IsValidEntry((log) -> LogStart) && ((log) -> LogStart != (log) -> LogPtr))
#define CalcNumberLines(pe1, pe2)   (((pe2) - (pe1)) + 1)

#define TAG(str)    dprintf("%-6s", str)
#define PARAM(str)  dprintf("%-12s", str)
#define DESC(str)   dprintf("%-12s", str)

#define USBHUB_LOG_NAME USBHUBLog
#define USBD_LOG_NAME   USBDLog
#define OHCI_LOG_NAME   OHCILog
#define UHCD_LOG_NAME   UHCDLog

#define USBHUB_LNAME    "USBHUB"
#define USBHUB_START    MAKE_SYMBOL(usbhub, hublstart)
#define USBHUB_END      MAKE_SYMBOL(usbhub, hublend)
#define USBHUB_PTR      MAKE_SYMBOL(usbhub, hublptr)

#define USBD_LNAME    "USBD"
#define USBD_START    MAKE_SYMBOL(usbd, lstart)
#define USBD_END      MAKE_SYMBOL(usbd, lend)
#define USBD_PTR      MAKE_SYMBOL(usbd, lptr)

#define OHCI_LNAME    "OpenHCI"
#define OHCI_START    MAKE_SYMBOL(openhci, ohcilstart)
#define OHCI_END      MAKE_SYMBOL(openhci, ohcilend)
#define OHCI_PTR      MAKE_SYMBOL(openhci, ohcilptr)

#define UHCD_LNAME    "UHCD"
#define UHCD_START    MAKE_SYMBOL(uhcd, HCDLStart)
#define UHCD_END      MAKE_SYMBOL(uhcd, HCDLEnd)
#define UHCD_PTR      MAKE_SYMBOL(uhcd, HCDLPtr)

//
// USBLOG typedefs
// 

typedef union {
    ULONG   TagValue;
    CHAR    TagChars[TAG_CHAR_LENGTH];
} USBLOG_TAG_READ, *PUSBLOG_TAG_READ;


typedef struct _usb_log_entry {
    USBLOG_TAG_READ      Tag;
    DWORD           Param1;
    DWORD           Param2;
    DWORD           Param3;
} USB_LOG_ENTRY, *PUSB_LOG_ENTRY;

typedef PCHAR (DESC_ROUTINE) (
    ULONG64  Entry
);
typedef DESC_ROUTINE    *PDESC_ROUTINE;

typedef struct _USB_LOG {
    PCHAR   LogName;
    PCHAR   LogStartName;
    PCHAR   LogEndName;
    PCHAR   LogPtrName;

    ULONG64 LogStart;
    ULONG64 LogEnd;
    ULONG64 LogPtr;

    ULONG64 LastSearchResult;

    ULONG64 LogCurrViewTop;
    ULONG64 LogCurrViewBottom;

    LONG    LinesToDump;
    
    PDESC_ROUTINE   DescRoutine;
} USB_LOG, *PUSB_LOG;

typedef struct _USBLOG_ARGS {
    ULONG64 Address;
    LONG    NumberLines;
    PCHAR   SearchString;
    BOOLEAN ResetLog;
    BOOLEAN SearchLog;
} USBLOG_ARGS, *PUSBLOG_ARGS;

//
// Add logging function declarations
//

VOID USBLOG_DoLog(PUSB_LOG LogToDump, PCSTR Args);
VOID USBLOG_Usage(void);
VOID USBLOG_GetParams(PCSTR Args, PUSBLOG_ARGS ParsedArgs);
ULONG64 USBLOG_SearchLog(PUSB_LOG Log, ULONG64 SearchBegin, PCHAR SearchString);

VOID DumpDefaultLogHeader(VOID);
BOOLEAN DumpLog(PUSB_LOG, BOOLEAN, BOOLEAN);
BOOLEAN ResetLog(PUSB_LOG);

#define GetMostRecentEntry(l)       ((l) -> LogPtr)

ULONG64 GetEntryBefore(PUSB_LOG, ULONG64);
ULONG64 GetEntryAfter(PUSB_LOG, ULONG64);

#define IsMostRecentEntry(l, e)     ((e) == (l) -> LogPtr)
#define IsLeastRecentEntry(l, e)    (((LogHasRolledOver((l)))               \
                                            ? ( (e) == ((l) -> LogPtr - 1)) \
                                            : ( (e) == ((l) -> LogEnd))) )

VOID GetLogEntryTag(ULONG64, PUSBLOG_TAG_READ);
VOID GetLogEntryParams(ULONG64, ULONG64 *, ULONG64 *, ULONG64 *);

ULONG64 SearchLogForTag(PUSB_LOG, ULONG64, ULONG, USBLOG_TAG_READ[]);

#define GetLastSearchResult(l)      ((l) -> LastSearchResult)
#define SetLastSearchResult(l, a)   ((l) -> LastSearchResult = (a))

#define SetLinesToDump(l, n)        ((l) -> LinesToDump = (n))
#define GetLinesToDump(l)           ((l) -> LinesToDump)

VOID ConvertStringToTag(PCHAR, PUSBLOG_TAG_READ);
VOID ConvertTagToString(PUSBLOG_TAG_READ, PCHAR, ULONG);
BOOLEAN IsValidEntry(ULONG64);

VOID GetCurrentView(PUSB_LOG, ULONG64 *, ULONG64 *);
VOID SetCurrentView(PUSB_LOG, ULONG64, ULONG64);

VOID LogViewScrollUp(PUSB_LOG);
VOID LogViewScrollDown(PUSB_LOG);
VOID DisplayCurrentView(PUSB_LOG);

VOID DisplayHeader();

//
// Global log structure declarations
//

DECLARE_LOG(USBHUB_LOG_NAME, USBHUB_LNAME, USBHUB_START, USBHUB_END, USBHUB_PTR,
            DEFAULT_LINES_TO_DUMP, NULL);

DECLARE_LOG(USBD_LOG_NAME, USBD_LNAME, USBD_START, USBD_END, USBD_PTR,
            DEFAULT_LINES_TO_DUMP, NULL);

DECLARE_LOG(OHCI_LOG_NAME, OHCI_LNAME, OHCI_START, OHCI_END, OHCI_PTR,
            DEFAULT_LINES_TO_DUMP, NULL);

DECLARE_LOG(UHCD_LOG_NAME, UHCD_LNAME, UHCD_START, UHCD_END, UHCD_PTR,
            DEFAULT_LINES_TO_DUMP, NULL);

//
// Define each of these, which is relatively simple
//

DECLARE_API( usblog )
/*++

Routine Description:

   Dumps a HID Preparsed Data blob

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG                   index;
    UCHAR                   logName[32];
    UCHAR                   buffer[256];

    logName[0] = '\0';
    memset(buffer, '\0', sizeof(buffer));

    if (!*args)
    {
        USBLOG_Usage();
    }
    else
    {
        if (!sscanf(args, "%s %256c", logName, buffer)) {
            USBLOG_Usage();
        }
    }


    index = 0;
    while ('\0' != logName[index]) 
    {
        logName[index] = (UCHAR) toupper(logName[index]);
        index++;
    }

    if (!strcmp(logName, "USBHUB")) 
    {
        USBLOG_DoLog(&(USBHUB_LOG_NAME), buffer);
    }
    else if (!strcmp(logName, "USBD")) 
    {
        USBLOG_DoLog(&(USBD_LOG_NAME), buffer);
    }
    else if (!strcmp(logName, "OPENHCI")) 
    {
        USBLOG_DoLog(&(OHCI_LOG_NAME), buffer);
    }
    else if (!strcmp(logName, "UHCD")) 
    {
        USBLOG_DoLog(&(UHCD_LOG_NAME), buffer);
    }
    else
    {
        dprintf("Unknown USB log type!\n");
        USBLOG_Usage();
    }
    return S_OK;
}

VOID
USBLOG_DoLog(
    PUSB_LOG    LogToDump,
    PCSTR       Args
)
{
    BOOLEAN         atEnd;
    BOOLEAN         dumpSuccess;
    USBLOG_ARGS     logArgs;
    BOOLEAN         doDump;
    BOOLEAN         doScroll;
    ULONG64         searchAddress;

    TRACE_SPEW("Entering USBLOG_DoLog with args %s\n", Args);

    doDump = TRUE;
    doScroll = TRUE;

    //
    // Parse the arguments to the logging function
    //

    USBLOG_GetParams(Args, &logArgs);

    //
    // Analyze the params and modify the log structure if need be
    //

    if (0 != logArgs.NumberLines)
    {
        SetLinesToDump(LogToDump, logArgs.NumberLines);
    }

    if (0 != logArgs.Address)
    {
        if (!logArgs.SearchLog) 
        {
            if (GetLinesToDump(LogToDump) > 0) 
            {
                SetCurrentView(LogToDump, logArgs.Address, 0);
            }
            else 
            {
                SetCurrentView(LogToDump, 0, logArgs.Address);
            }
            doScroll = FALSE;
        }
    }

    if (logArgs.ResetLog)
    {
        ResetLog(LogToDump);
        doScroll = FALSE;
    }

    if (logArgs.SearchLog)
    {
        if (0 == logArgs.Address) 
        {
            searchAddress = GetLastSearchResult(LogToDump);

            if (0 == searchAddress) 
            {
                searchAddress = GetMostRecentEntry(LogToDump);
            }
        }
        else 
        {
            searchAddress = logArgs.Address;
        }
        
        searchAddress = USBLOG_SearchLog(LogToDump, 
                                         searchAddress, 
                                         logArgs.SearchString);

        if (0 != searchAddress)
        {
            SetLastSearchResult(LogToDump, searchAddress);
    
            SetCurrentView(LogToDump, searchAddress, 0);
    
            doScroll = FALSE;
        }
        else 
        {
            dprintf("Couldn't find any such tag(s)\n");
            doDump = FALSE;
        }
    }

    if (doDump)
    {
        dumpSuccess = DumpLog(LogToDump, FALSE, doScroll);

        if (!dumpSuccess)
        {
            dprintf("Error dumping log\n");
        }
    }
    return;
}

VOID 
USBLOG_GetParams(
    IN  PCSTR           Args, 
    OUT PUSBLOG_ARGS    ParsedArgs
)
{
    PCHAR   arg;
    PCHAR   args;
    CHAR    argDelims[] = " \t\n";

    //
    // Initialize the arguments structure first
    //

    memset(ParsedArgs, 0x00, sizeof(USBLOG_ARGS));

    //
    // Setup the argument string so that it's not a const anymore which
    //  eliminates compiler errors.
    //

    args = (PCHAR) Args;

    //
    // The command line for !log is the following:
    //  !log [address] [-r] [-s searchstring] [-l n] 
    //
    // The argument parsing will assume these can be entered in any order,
    //   so we'll simply examine each argument until there are no more
    //   arguments.  The main loop will look for either an address or an 
    //   option.  If it finds either, it processes as necessary.  Otherwise,
    //   the argument is simply ignored.
    //

    arg = strtok(args, argDelims);

    while (NULL != arg) {

        TRACE_SPEW("Analyzing usblog arg: %s\n", arg);

        // 
        // Check to see if this is an option or not
        //

        if ('-' != *arg) 
        {
            //
            // No, then it must be an address, call GetExpression
            //

            ParsedArgs -> Address =  GetExpression(arg);

            // 
            // Assume user competence and store the result...
            //  Add the value to the the ParsedArgs structure.
            //  Note that if > 1 address is given, this function 
            //  simply uses the last one specified
            //

        }
        else 
        {
            //
            // OK, it's an option...Process appropriately
            //

            switch (*(arg+1))
            {
                //
                // Reset Log
                //

                case 'r':
                    ParsedArgs -> ResetLog = TRUE;
                    break;

                //
                // Set lines to display
                //

                case 'l':
                    arg = strtok(NULL, argDelims);

                    if (NULL != arg)
                    {
                        //
                        // Assume user competence and get the decimal string
                        //

                        if (!sscanf(arg, "%d", &(ParsedArgs -> NumberLines))) {
                            ParsedArgs -> NumberLines = 0;
                        }

                        TRACE_SPEW("Parsed -l command with %d lines\n", 
                                    ParsedArgs -> NumberLines);
                    }
                    break;

                //
                // Search the log
                //

                case 's':
                    ParsedArgs -> SearchLog = TRUE;
                    ParsedArgs -> SearchString = strtok(NULL, argDelims);
                    break;

                default:
                    dprintf("Unknown option %c\n", *(arg+1));
                    break;
            }
        }
        arg = strtok(NULL, argDelims);
    }
    return;
}

ULONG64
USBLOG_SearchLog(
    PUSB_LOG        Log,
    ULONG64         SearchBegin,
    PCHAR           SearchString
)
{
    ULONG64         firstFoundEntry;
    USBLOG_TAG_READ      tagArray[32];
    ULONG           index;
    PCHAR           searchToken;

    TRACE_SPEW("Entering USBLOG_SearchLog looking for %s\n", SearchString);

    index = 0;
    firstFoundEntry = 0;

    searchToken = strtok(SearchString, LOG_SEARCH_DELIMS);

    while (index < 32 && NULL != searchToken) 
    {
        TRACE_SPEW("Adding %s to tag array\n", searchToken);

        ConvertStringToTag(searchToken, &(tagArray[index++]));
        searchToken = strtok(NULL, LOG_SEARCH_DELIMS);
    }

    if (index > 0)
    {
        firstFoundEntry = SearchLogForTag(Log, SearchBegin, index, tagArray);
    }

    return (firstFoundEntry);
}

//
// Local logging function definitions.
//

BOOLEAN
DumpLog(
    IN  PUSB_LOG    Log,
    IN  BOOLEAN     StartFromTop,
    IN  BOOLEAN     Scroll
)
{
    ULONG           lineCount;
    BOOLEAN         resetStatus;
    ULONG64         currViewTop;
    ULONG64         currViewBottom;

    //
    // Check if the log has been opened/reset yet
    //
    
    GetCurrentView(Log, &currViewTop, &currViewBottom);

    if (0 == currViewTop || StartFromTop) 
    {
        //
        // Reset the log and return FALSE if the reset failed
        //
        
        resetStatus = ResetLog(Log);
        if (!resetStatus)
        {
            return (FALSE);
        }

        Scroll = FALSE;
    }
    
    //
    // Call the log's dump routine based on the direction
    //

    if (Scroll) 
    {
        TRACE_SPEW("Checking lines to dump: %d\n", Log -> LinesToDump);

        if (Log -> LinesToDump < 0) 
        {
            LogViewScrollUp(Log);
        }
        else
        {
            LogViewScrollDown(Log);
        }
    }

    DisplayCurrentView(Log);

    return (TRUE);
}

BOOLEAN
ResetLog(
    IN  PUSB_LOG    Log
)
{
    ULONG           bytesRead;
    ULONG64         symbolAddress;
    ULONG           readStatus;

    //
    // Get the address of the start symbol, the end symbol, and the 
    //   current pointer symbol
    //

    symbolAddress = GetExpression(Log -> LogStartName);

    if (0 != symbolAddress) 
    {
        if (!ReadPointer(symbolAddress, &(Log -> LogStart)))
        {
            dprintf("Unable to read %p\n", symbolAddress);
            Log -> LogStart = 0;
        }
    }

    symbolAddress = GetExpression(Log -> LogEndName);

    if (0 != symbolAddress) 
    {
        if (!ReadPointer(symbolAddress, &(Log -> LogEnd)))
        {
            dprintf("Unable to read %p\n", symbolAddress);
            Log -> LogEnd = 0;
        }
    }

    symbolAddress = GetExpression(Log -> LogPtrName);

    if (0 != symbolAddress) 
    {
        if (!ReadPointer(symbolAddress, &(Log -> LogPtr)))
        {
            dprintf("Unable to read %p\n", symbolAddress);
            Log -> LogPtr= 0;
        }
    }

    if ( (0 == Log -> LogStart) || 
         (0 == Log -> LogEnd) ||
         (0 == Log -> LogPtr) ) 
    {
        dprintf("Unable to reset log\n");
        return (FALSE);
    }

    SetCurrentView(Log, Log -> LogPtr, 0);

    return (TRUE);
}

VOID
GetCurrentView(
    IN  PUSB_LOG Log,
    OUT ULONG64  *CurrTop,
    OUT ULONG64  *CurrBottom
)
{
    *CurrTop    = Log -> LogCurrViewTop;
    *CurrBottom = Log -> LogCurrViewBottom;

    return;
}

VOID
SetCurrentView(
    IN PUSB_LOG  Log,
    IN ULONG64   NewTop,
    IN ULONG64   NewBottom
)
{
    LONG    lineCount;

    if (0 == NewTop && 0 == NewBottom)
    {
        return;
    }

    lineCount = abs(Log -> LinesToDump);

    if (0 == NewBottom)
    {
        //
        // Calculate the new bottom based on NewTop and the number of lines to
        // be displayed in the log. 
        //

        NewBottom = NewTop + lineCount;

        if (NewTop >= Log -> LogPtr) 
        {
            lineCount -= (ULONG) CalcNumberLines(NewTop, Log -> LogEnd);

            if (lineCount > 0)
            {
                if (LogHasRolledOver(Log)) 
                {
                    NewBottom = Log -> LogStart + lineCount - 1;

                    if (NewBottom >= Log -> LogPtr) 
                    {
                        NewBottom = Log -> LogPtr - 1;
                    }
                }
                else 
                {
                    NewBottom = Log -> LogEnd;
                }
            }
        }
        else 
        {
            if (lineCount > CalcNumberLines(NewTop, Log -> LogPtr - 1))
            {
                NewBottom = Log -> LogPtr - 1;
            }
        }
    }
    else if (0 == NewTop) 
    {
        //
        // NULL == NewTop -- Need to calculate the NewTop of the view
        //

        NewTop = NewBottom - lineCount;

        if (NewBottom <= Log -> LogPtr - 1) 
        {
            lineCount -= (ULONG) CalcNumberLines(Log -> LogStart, NewBottom);
        
            if (lineCount > 0) 
            {
                NewTop = Log -> LogEnd - lineCount + 1;
                
                if (NewTop < Log -> LogPtr)
                {
                    NewTop = Log -> LogPtr;
                }
            }
        }
        else 
        {
            if (NewTop < Log -> LogPtr) 
            {
                NewTop = Log -> LogPtr;
            }
        }
    }

    TRACE_SPEW("Set CurrentView  NewTop (0x%08x)  NewBottom(0x%08x)\n",
               NewTop, NewBottom);

    Log -> LogCurrViewTop = NewTop;
    Log -> LogCurrViewBottom = NewBottom;

    return;
}

ULONG64
GetEntryBefore(
    IN PUSB_LOG         Log,
    IN ULONG64          Entry
)
{
    if (Entry == Log -> LogEnd) 
    {
        if (LogHasRolledOver(Log)) 
        {
            return (Log -> LogStart);
        }
        
        return (0);
    }

    //
    // Check to see if we hit the most recent entry in the log.  If so we've
    //  hit the end of the log and will loop again.  return NULL.
    //

    return ( ((Entry + 1) == Log -> LogPtr) ? 0 : Entry+1);
}
            
ULONG64
GetEntryAfter(
    IN PUSB_LOG         Log,
    IN ULONG64          Entry
)
{
    if (Entry == Log -> LogPtr)
    {
        return (0);
    }

    if (Entry == Log -> LogStart)
    {
        return (Log -> LogEnd);
    }

    return (Entry-1);
}

VOID
GetLogEntryTag(
    IN  ULONG64           Entry,
    OUT PUSBLOG_TAG_READ  Tag
)
{
    ULONG   bytesRead;
    
    InitTypeRead(Entry, uhcd!USB_LOG_ENTRY);
//    ReadMemory( Entry + (ULONG64) &(((PUSB_LOG_ENTRY) 0) -> Tag), Tag, sizeof(*Tag), &bytesRead);

    Tag->TagValue = (ULONG) ReadField(Tag.TagValue);
    return;
}


VOID
GetLogEntryParams(
    IN  ULONG64         Entry,
    OUT ULONG64         *Param1,
    OUT ULONG64         *Param2,
    OUT ULONG64         *Param3
)
{
    ULONG   bytesRead;
    InitTypeRead(Entry, uhcd!USB_LOG_ENTRY);

    *Param1 = ReadField(Param1);
    *Param2 = ReadField(Param2);
    *Param3 = ReadField(Param3);

//    ReadMemory(Entry + (ULONG64) &(((PUSB_LOG_ENTRY) 0)-> Param1), Param1, sizeof(*Param1), &bytesRead);
//    ReadMemory(Entry + (ULONG64) &(((PUSB_LOG_ENTRY) 0)-> Param3), Param2, sizeof(*Param2), &bytesRead);
//    ReadMemory(Entry + (ULONG64) &(((PUSB_LOG_ENTRY) 0)-> Param2), Param3, sizeof(*Param3), &bytesRead);    
    return;
}

ULONG64
SearchLogForTag(
    IN  PUSB_LOG        Log,
    IN  ULONG64         SearchBegin,
    IN  ULONG           TagCount,
    IN  USBLOG_TAG_READ TagArray[]
)
{
    ULONG           tagIndex;
    ULONG64         currEntry;
    USBLOG_TAG_READ currTag;

    //
    // Start the search at the most recent log entry
    //
    
    currEntry = SearchBegin;
    
    while (currEntry != 0) {
        GetLogEntryTag(currEntry, &currTag);
        
        for (tagIndex = 0; tagIndex < TagCount; tagIndex++) {
           if (TagArray[tagIndex].TagValue == currTag.TagValue) {
               return (currEntry);
           }
        }

        currEntry = GetEntryBefore(Log, currEntry);
    }

    return (0);
}    

VOID
ConvertStringToTag(
    IN  PCHAR       TagString,
    OUT PUSBLOG_TAG_READ Tag
)
{
    USBLOG_TAG_READ  tag;
    ULONG       shiftAmount;
    
    //
    // Since a Tag is four characters long, this routine will convert only
    //  the first four characters even though the string might be longer
    //

    tag.TagValue = 0;
    shiftAmount = 0;

    while (tag.TagValue < 0x01000000 && *TagString) {
        tag.TagValue += (*TagString) << shiftAmount;
        TagString++;
        shiftAmount += 8;
    }

    *Tag = tag;
    
    return;
}

VOID
ConvertTagToString(
    IN  PUSBLOG_TAG_READ Tag,
    IN  PCHAR            String,
    IN  ULONG            StringLength
)
{
    ULONG   tagIndex;

    for (tagIndex = 0; tagIndex < 4 && tagIndex < StringLength-1; tagIndex++) {
        *String = Tag -> TagChars[tagIndex];
        *String++;
    }

    *String = '\0';

    return;
}

BOOLEAN 
IsValidEntry(
    ULONG64 Entry
)
{
    USBLOG_TAG_READ  tag;

    GetLogEntryTag(Entry, &tag);

    return (0 != tag.TagValue);
}

VOID
LogViewScrollUp(
    IN  PUSB_LOG  Log
)
{
    ULONG64 newBottom;

    TRACE_SPEW("In ScrollUp routine\n");

    newBottom =  GetEntryAfter(Log, Log -> LogCurrViewTop);

    if (newBottom) 
    {
        SetCurrentView(Log, 0, newBottom);
    }

    return;
}

VOID
LogViewScrollDown(
    IN  PUSB_LOG  Log
)
{
    ULONG64 newTop;

    TRACE_SPEW("In ScrollDown routine\n");

    newTop =  GetEntryBefore(Log, Log -> LogCurrViewBottom);

    if (newTop) 
    {
        SetCurrentView(Log, newTop, 0);
    }

    return;
}

VOID
DisplayCurrentView(
    IN PUSB_LOG Log
)
{
    ULONG64 viewTop;
    ULONG64 viewBottom;
    ULONG64 currEntry;
    USBLOG_TAG_READ      currTag;
    CHAR    TagString[TAG_STRING_LENGTH];
    ULONG   lineCount;
    ULONG64  param1;
    ULONG64  param2;
    ULONG64  param3;
    PCHAR    desc;

    //
    // Display the header
    //

    DisplayHeader();

    //
    // Determine which line of the log to begin displaying
    //

    GetCurrentView(Log, &viewTop, &viewBottom);

    //
    // Start displaying lines and stop when we hit the end of the log
    //  or we have displayed the requested number of lines
    //

    //
    // Check first to see if the top of the view is the most recent entry
    //

    if (IsMostRecentEntry(Log, viewTop)) 
    {
        dprintf("Top of log...\n");
    }

    currEntry = viewTop;

    while (1)
    {
        //
        // Display a line of the log
        //

        GetLogEntryTag(currEntry, &currTag);
        
        ConvertTagToString(&currTag,
                           TagString, 
                           TAG_STRING_LENGTH);

        GetLogEntryParams(currEntry, &param1, &param2, &param3);
                           
        DUMP_ADDRESS(currEntry);
        DUMP_STRING("  ");

        DUMP_STRING(TagString);
        DUMP_STRING("  ");

        DUMP_DWORD(param1);
        DUMP_STRING("  ");
        
        DUMP_DWORD(param2);
        DUMP_STRING("  ");

        DUMP_DWORD(param3);
        DUMP_STRING("  ");

        if (0 != Log -> DescRoutine) 
        {
            desc = Log -> DescRoutine(currEntry);

            if (0 != desc)
            {
                DUMP_STRING(desc);
            }
        }

        END_LINE();

        if (currEntry == viewBottom) 
        {
            break;
        }

        currEntry = GetEntryBefore(Log, currEntry);
    }

    if (IsLeastRecentEntry(Log, currEntry)) 
    {
        dprintf("Bottom of log...\n");
    }

    return;
}

//
// Local Function Definitions
//

VOID
DisplayHeader(
    VOID
)
{
    TRACE_SPEW("Entering dump default log header\n");

    END_LINE();

    PARAM("Entry");
    TAG("Tag");
    PARAM("Param1");
    PARAM("Param2");
    PARAM("Param3");
    DESC("Description");
    END_LINE();

    DUMP_STRING("------------------------------------------------------------------");
    END_LINE();
    
    return;
}

VOID
USBLOG_Usage(
    VOID
)
{
    dprintf("!usblog <log> [addr] [-r] [-s str] [-l n]\n"
            "  <log>    - {USBHUB | USBD | UHCD | OpenHCI}\n"
            "  [addr]   - address to begin dumping from in <log>\n"
            "  [-r]     - reset the log to dump from most recent entry\n"
            "  [-s str] - search for first instance of a particular tag\n"
            "                from the current position; str should be a list\n"
            "                of tags delimited by comma's with no whitespace\n"
            "  [-l n]   - set the number of lines to display at a time to n\n");
    dprintf("\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\usbhub.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    USBHUB.c

Abstract:

    WinDbg Extension Api

Author:

    Kenneth D. Ray (kenray) June 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"

typedef union _USBHUB_FLAGS {
    struct {
        ULONG   FullListing         : 1;
        ULONG   Reserved            : 31;
    };
    ULONG Flags;
} USBHUB_FLAGS;

#define PRINT_FLAGS(value, flag) \
    if ((value) & (flag)) { \
        dprintf (#flag " "); \
    }

#define ENTRY(x) { x, #x }


extern VOID USBD_DeviceDescriptor (PCHAR Comment, ULONG64 Desc);
extern VOID USBD_InterfaceDescriptor (PCHAR Comment, ULONG64 Desc);

void USBHUB_DumpHub (ULONG64, USBHUB_FLAGS);
void USBHUB_DumpHubHub (ULONG64, USBHUB_FLAGS);
void USBHUB_DumpHubPort (ULONG64, USBHUB_FLAGS);
void USBHUB_DumpHubParent (ULONG64, USBHUB_FLAGS);
void USBHUB_DumpHubFunction (ULONG64, USBHUB_FLAGS);


VOID
DevExtUsbhub(
    ULONG64  MemLocPtr
    )

/*++
Routine Description:

   Dumps a hub device extension

Arguments:

    args - Address flags

Return Value:

    None

--*/
{
    ULONG                   result;
    USBHUB_FLAGS            flags;

    flags.Flags = 1;

    dprintf ("Dump Hub Device Extension: %p %x \n", MemLocPtr, flags.Flags);

    //
    // Get the extension
    //

    if (InitTypeRead (MemLocPtr, usbhub!_DEVICE_EXTENSION_HEADER)) {
        dprintf ("Could not read Hub Extension\n");
        return;
    }

    USBHUB_DumpHub (MemLocPtr, flags);

    return;
}

void
USBHUB_DumpHub (
    ULONG64                  MemLoc,
    USBHUB_FLAGS             Flags
    )
{
    ULONG                       ExtensionType;

    if (GetFieldValue(MemLoc, "usbhub!_DEVICE_EXTENSION_HEADER", "ExtensionType", ExtensionType)) {
        return;
    }
    switch (ExtensionType) {
    case EXTENSION_TYPE_HUB:
        if (InitTypeRead (MemLoc, usbhub!_DEVICE_EXTENSION_HUB)) {
            dprintf ("Could not read _DEVICE_EXTENSION_HUB at %p\n", MemLoc);
            return;
        }
        USBHUB_DumpHubHub (MemLoc, Flags);
        break;

    case EXTENSION_TYPE_PORT:
        if (InitTypeRead(MemLoc, usbhub!_DEVICE_EXTENSION_PORT)) {
            dprintf ("Could not read _DEVICE_EXTENSION_PORT\n");
            return;
        }
        USBHUB_DumpHubPort (MemLoc, Flags);
        break;

    case EXTENSION_TYPE_PARENT:
        if (InitTypeRead (MemLoc, usbhub!_DEVICE_EXTENSION_PARENT)) {
            dprintf ("Could not read PDEVICE_EXTENSION_PARENT\n");
            return;
        }
        USBHUB_DumpHubParent (MemLoc, Flags);
        break;

    case EXTENSION_TYPE_FUNCTION:
        if (InitTypeRead(MemLoc, usbhub!_DEVICE_EXTENSION_FUNCTION)) {
            dprintf ("Could not read PDEVICE_EXTENSION_FUNCTION\n");
            return;
        }
        USBHUB_DumpHubFunction (MemLoc, Flags);
        break;
    }


    return ;
}

void
USBHUB_DumpHubHub (
    ULONG64                 MemLoc,
    USBHUB_FLAGS            Flags
    )
{
    ULONG   i;
//    PDEVICE_EXTENSION_HUB   Hub,
//    USB_HUB_DESCRIPTOR  hubDesc;
//    PORT_DATA           portData [32];
    ULONG   HubFlags, bNumberOfPorts, SizeOfPortData;
    ULONG64 PortData;
    ULONG64 HubDescriptor;

    if (InitTypeRead (MemLoc, usbhub!_DEVICE_EXTENSION_HUB)) {
        dprintf ("Could not read DEVICE_EXTENSION_HUB at %p\n", MemLoc);
        return;
    }

    dprintf ("\nHUB HUB\n");
    dprintf ("FDO %x PDO %x TOS %x RootHub %x HcdTos %x\n",
             (ULONG) ReadField(FunctionalDeviceObject),
             (ULONG) ReadField(PhysicalDeviceObject),
             (ULONG) ReadField(TopOfStackDeviceObject),
             (ULONG) ReadField(RootHubPdo),
             (ULONG) ReadField(TopOfHcdStackDeviceObject));

    dprintf ("FLG: ");
    HubFlags = (ULONG) ReadField(HubFlags);
    PRINT_FLAGS (HubFlags, HUBFLAG_NEED_CLEANUP);
    PRINT_FLAGS (HubFlags, HUBFLAG_ENABLED_FOR_WAKEUP);
    PRINT_FLAGS (HubFlags, HUBFLAG_DEVICE_STOPPING);
    PRINT_FLAGS (HubFlags, HUBFLAG_HUB_FAILURE);
    PRINT_FLAGS (HubFlags, HUBFLAG_SUPPORT_WAKEUP);

    dprintf ("\nStatus: ");
    PRINT_FLAGS ((ULONG) ReadField(HubState.HubStatus), HUB_STATUS_LOCAL_POWER);
    PRINT_FLAGS ((ULONG) ReadField(HubState.HubStatus), HUB_STATUS_OVER_CURRENT);
    dprintf ("\n");

    dprintf ("HubChange %x\n", (ULONG) ReadField(HubState.HubChange));

    dprintf ("IRP %p      Buffer %p      len %x       Desc %p \n"
             "PowerIrp %p PendingWake %p #PortWake %x \n",
             ReadField(Irp),
             ReadField(TransferBuffer),
             (ULONG) ReadField(TransferBufferLength),
             HubDescriptor = ReadField(HubDescriptor),
             ReadField(PowerIrp),
             ReadField(PendingWakeIrp),
             (ULONG) ReadField(NumberPortWakeIrps));

    PortData = ReadField(PortData);
    if (GetFieldValue(HubDescriptor,
                      "usbhub!_USB_HUB_DESCRIPTOR",
                      "bNumberOfPorts",
                      bNumberOfPorts)) {
        dprintf ("Could not read Hub Descriptor\n");
        goto NO_HUB_DESC;
    }

    dprintf ("PortData %p size %x \n", PortData, bNumberOfPorts);

    SizeOfPortData = GetTypeSize("usbhub!_PORT_DATA");
    for (i = 0; i < bNumberOfPorts; i++) {
        ULONG PortStatus;

        if (InitTypeRead(PortData + SizeOfPortData*i,usbhub!_PORT_DATA)) {
            dprintf ("was not able to obtain the port list\n");
            break;
        }
        
        dprintf ("Port %x change %x Status %x",
                 (ULONG) ReadField(DeviceObject),
                 (ULONG) ReadField(PortState.PortChange),
                 PortStatus = (ULONG) ReadField(PortState.PortStatus));
        dprintf ("\n     ");
        PRINT_FLAGS (PortStatus, PORT_STATUS_CONNECT);
        PRINT_FLAGS (PortStatus, PORT_STATUS_ENABLE);
        PRINT_FLAGS (PortStatus, PORT_STATUS_SUSPEND);
        PRINT_FLAGS (PortStatus, PORT_STATUS_OVER_CURRENT);
        PRINT_FLAGS (PortStatus, PORT_STATUS_RESET);
        PRINT_FLAGS (PortStatus, PORT_STATUS_POWER);
        PRINT_FLAGS (PortStatus, PORT_STATUS_LOW_SPEED);
        dprintf ("\n");
    }
    InitTypeRead (MemLoc, usbhub!_DEVICE_EXTENSION_HUB);

NO_HUB_DESC:

    dprintf ("Config Handle %x ConfigDesc %x\n",
             (ULONG) ReadField(Configuration),
             (ULONG) ReadField(ConfigurationDescriptor));

    dprintf ("PowerTable ");
    for (i = 0; i < PowerSystemMaximum; i++) {
        UCHAR Dev[40];
        sprintf(Dev,"DeviceState[%d]",i);
        dprintf ("%x ", (ULONG) GetShortField(0, Dev,0));
    }
    dprintf ("Current %x\n", (ULONG) ReadField(CurrentPowerState));

    dprintf ("Pending Req %x ErrorCount %x \n",
             (ULONG) ReadField(PendingRequestCount),
             (ULONG) ReadField(ErrorCount));
    dprintf ("DeviceDesc %p PipInfo %p Urb %p\n",
             ReadField(DeviceDescriptor),
             ReadField(PipeInformation),
             ReadField(Urb));

    dprintf ("\n");
}

void
USBHUB_DumpHubPort (
    ULONG64                 MemLoc,
    USBHUB_FLAGS            Flags
    )
{
    struct { ULONG Value; PCHAR Name; } PdoFlags[] = {
        ENTRY (PORTPDO_DEVICE_IS_HUB),
        ENTRY (PORTPDO_DEVICE_IS_PARENT),
        ENTRY (PORTPDO_DEVICE_ENUM_ERROR),
        // ENTRY (PORTPDO_SUPPORT_NON_COMP
        ENTRY (PORTPDO_REMOTE_WAKEUP_SUPPORTED),
        ENTRY (PORTPDO_REMOTE_WAKEUP_ENABLED),
        ENTRY (PORTPDO_DELETED_PDO),
        ENTRY (PORTPDO_DELETE_PENDING),
        ENTRY (PORTPDO_NEED_RESET),
        ENTRY (PORTPDO_STARTED),
        ENTRY (PORTPDO_WANT_POWER_FEATURE),
        ENTRY (PORTPDO_SYM_LINK),
        ENTRY (PORTPDO_DEVICE_FAILED),
        ENTRY (PORTPDO_USB_SUSPEND)
        // ENTRY (PORTPDO_OVERCURRENT
    };
    ULONG i, j;
    ULONG PortPdoFlags;
    WCHAR UniqueIdString[8]={0};

    if (InitTypeRead(MemLoc, usbhub!_DEVICE_EXTENSION_PORT)) {
        return;
    }

    dprintf ("\nHUB PORT\n");
    dprintf ("Port PDO: %p \n", ReadField(PortPhysicalDeviceObject));
    dprintf ("Hub DeviceExtension: %p \n", ReadField(DeviceExtensionHub));
    dprintf ("PortNum %x, SerialNumberBuffer %x Length %x\n",
             (ULONG) ReadField(PortNumber),
             (ULONG) ReadField(SerialNumberBuffer),
             (ULONG) ReadField(SerialNumberBufferLength));
    dprintf ("DeviceData %x, DevicePowerState %x\n",
             (ULONG) ReadField(DeviceData),
             (ULONG) ReadField(DeviceState));
    dprintf ("WaitWaitIrp %x HackFlags %x\n",
             (ULONG) ReadField(WaitWakeIrp),
             (ULONG) ReadField(DeviceHackFlags));
    GetFieldValue(MemLoc, "usbhub!_DEVICE_EXTENSION_PORT", "UniqueIdString", UniqueIdString);
    dprintf ("UId String %ws SymLinkName Len %x MaxLen %x Buffer %p\n",
             UniqueIdString,
             (ULONG) ReadField(SymbolicLinkName.Length),
             (ULONG) ReadField(SymbolicLinkName.MaximumLength),
             (ULONG) ReadField(SymbolicLinkName.Buffer));

    if (Flags.FullListing) {
        USBD_DeviceDescriptor ("Device Descriptor", ReadField(DeviceDescriptor));
        USBD_DeviceDescriptor ("Old Dev Descriptor", ReadField(OldDeviceDescriptor));
        USBD_InterfaceDescriptor ("Interface Descriptor", ReadField(InterfaceDescriptor));
    } else {
        dprintf ("DevDesc %p Old DevD %p IntefaceD %p\n",
                 ReadField(DeviceDescriptor),
                 ReadField(OldDeviceDescriptor),
                 ReadField(InterfaceDescriptor));
    }

    dprintf (" Port PDO Flags: %x ", PortPdoFlags = (ULONG) ReadField(PortPdoFlags));
    for (j = 0, i = 0; i < (sizeof PdoFlags / sizeof PdoFlags[1]); i++) {
        if (PdoFlags[i].Value & PortPdoFlags) {
            if (0 == j) {
                dprintf ("\n                 ");
            }
            j ^= 1;

            dprintf ("%s  ", PdoFlags[i].Name);
        }
    }
    dprintf ("\n\n");

}

void
USBHUB_DumpHubParent (
    ULONG64                     MemLoc,
    USBHUB_FLAGS                Flags
    )
{
    UNREFERENCED_PARAMETER (MemLoc);
    UNREFERENCED_PARAMETER (Flags);

    dprintf ("Hub parent\n");
}

void
USBHUB_DumpHubFunction (
    ULONG64                     MemLoc,
    USBHUB_FLAGS                Flags
    )
{
    UNREFERENCED_PARAMETER (MemLoc);
    UNREFERENCED_PARAMETER (Flags);

    dprintf ("Hub parent\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\vpb.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       vpb.c
//
//  Contents:   windbg extension to dump a Vpb
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    2-17-1998   benl   Created
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(vpb)
//
//  Synopsis:   just print out the fields in the vpb (Volume Parameter Block)
//
//  Arguments:  address of vpb
//
//  Returns:
//
//  History:    2-17-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( vpb )
{
    ULONG64 dwAddress;
    DWORD   dwRead, Flags;
    UCHAR   VolumeLabel[80]={0};

    //read in the vpb
    dwAddress = GetExpression(args);
    if (GetFieldValue(dwAddress, "VPB", "Flags", Flags))
    {
        dprintf("ReadMemory at 0x%p failed\n", dwAddress);
        return  E_INVALIDARG;
    }

    //now print some stuff
    dprintf("Vpb at 0x%p\n", dwAddress);
    dprintf("Flags: 0x%x ", Flags);
    if (Flags & VPB_MOUNTED) {
        dprintf("mounted ");
    }
    if (Flags & VPB_LOCKED) {
        dprintf("locked ");
    }

    if (Flags & VPB_PERSISTENT) {
        dprintf("persistent");
    }
    dprintf("\n");
    GetFieldValue(dwAddress, "VPB", "VolumeLabel", VolumeLabel);
    InitTypeRead(dwAddress, VPB);
    dprintf("DeviceObject: 0x%p\n", ReadField(DeviceObject));
    dprintf("RealDevice:   0x%p\n", ReadField(RealDevice));
    dprintf("RefCount: %d\n", (ULONG) ReadField(ReferenceCount));
    dprintf("Volume Label: %*S\n", (ULONG) ReadField(VolumeLabelLength), VolumeLabel);

    return S_OK;
} // DECLARE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\vad.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vad.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (loup) 12-Jun-1992

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

CHAR *ProtectString[] = {
                   "NO_ACCESS",
                   "READONLY",
                   "EXECUTE",
                   "EXECUTE_READ",
                   "READWRITE",
                   "WRITECOPY",
                   "EXECUTE_READWRITE",
                   "EXECUTE_WRITECOPY"
                   };


DECLARE_API( vad )

/*++

Routine Description:

    Dumps all vads for process.

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    ULONG64 Next;
    ULONG64 VadToDump;
    ULONG64 ParentStored;
    ULONG64 First;
    ULONG64 Left;
    ULONG64 Prev;
    ULONG   Flags;
    ULONG   Done;
    ULONG   Level = 0;
    ULONG   Count = 0;
    ULONG   AverageLevel = 0;
    ULONG   MaxLevel = 0;
    ULONG   VadFlagsPrivateMemory=0, VadFlagsNoChange=0;
    ULONG   PhysicalMapping=0,ImageMap=0,NoChange=0,LargePages=0,MemCommit=0,PrivateMemory=0,Protection=0;
    ULONG64 StartingVpn=0, EndingVpn=0, Parent=0, LeftChild=0, RightChild=0;
    ULONG64 ControlArea=0, FirstPrototypePte=0, LastContiguousPte=0, CommitCharge=0;

    VadToDump = 0;
    Flags     = 0;

    if (GetExpressionEx(args, &VadToDump, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (VadToDump == 0) {
        dprintf("Specify the address of a VAD within the VAD tree\n");
        return E_INVALIDARG;
    }

    First = VadToDump;
    if (First == 0) {
        return E_INVALIDARG;
    }

#define ReadFirstVad(fld, var) GetFieldValue(First, (PUCHAR) "MMVAD", #fld, var)
#define ReadFirstVadShort(fld, var) GetFieldValue(First, (PUCHAR) "MMVAD_SHORT", #fld, var)

    if ( ReadFirstVadShort(u.VadFlags.PrivateMemory, VadFlagsPrivateMemory) ) {
        dprintf("%08p: Unable to get contents of VAD1\n",First );
        return E_INVALIDARG;
    }

    ReadFirstVadShort(u.VadFlags.NoChange, VadFlagsNoChange);
    ReadFirstVadShort(StartingVpn, StartingVpn);
    ReadFirstVadShort(EndingVpn, EndingVpn);
    ReadFirstVadShort(Parent, Parent);
    ReadFirstVadShort(LeftChild, LeftChild);
    ReadFirstVadShort(RightChild, RightChild);
    ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);

    if (Flags == 1) {
        ULONG FileOffset=0;
        ULONG64 ListFlink=0, ListBlink=0, Banked=0;
        ULONG CopyOnWrite=0,Inherit=0,ExtendableFile=0,SecNoChange=0;
        ULONG OneSecured=0,MultipleSecured=0,ReadOnly=0,StoredInVad=0;

        //
        // Dump only this vad.
        //

        if ((VadFlagsPrivateMemory == 0) ||
            (VadFlagsNoChange == 1))  {
            if ( ReadFirstVad(ControlArea, ControlArea) ) {
                dprintf("%08p: Unable to get contents of VAD2\n",First );
                return E_INVALIDARG;
            }
            ReadFirstVad(FirstPrototypePte, FirstPrototypePte);
            ReadFirstVad(LastContiguousPte, LastContiguousPte);     
            ReadFirstVad(u2.VadFlags2.CopyOnWrite, CopyOnWrite);
            ReadFirstVad(u2.VadFlags2.Inherit, Inherit);
            ReadFirstVad(u2.VadFlags2.ExtendableFile, ExtendableFile);
            ReadFirstVad(u2.VadFlags2.SecNoChange, SecNoChange);
            ReadFirstVad(u2.VadFlags2.OneSecured, OneSecured);
            ReadFirstVad(u2.VadFlags2.MultipleSecured, MultipleSecured);
            ReadFirstVad(u2.VadFlags2.ReadOnly, ReadOnly);
            ReadFirstVad(u2.VadFlags2.StoredInVad, StoredInVad);
            ReadFirstVad(u2.VadFlags2.FileOffset, FileOffset);
            ReadFirstVad(u3.List.Flink, ListFlink);
            ReadFirstVad(u3.List.Blink, ListBlink);
            ReadFirstVad(u4.Banked, Banked);
        }
        
        ReadFirstVad(u.VadFlags.CommitCharge, CommitCharge);
        ReadFirstVad(u.VadFlags.PhysicalMapping, PhysicalMapping);
        ReadFirstVad(u.VadFlags.ImageMap, ImageMap);
        ReadFirstVad(u.VadFlags.Protection, Protection);
        ReadFirstVad(u.VadFlags.NoChange, NoChange);
        ReadFirstVad(u.VadFlags.LargePages, LargePages);
        ReadFirstVad(u.VadFlags.MemCommit, MemCommit);
        ReadFirstVad(u.VadFlags.PrivateMemory, PrivateMemory);

        dprintf("\nVAD @ %8p\n",VadToDump);
        dprintf("  Start VPN:      %8p  End VPN: %8p  Control Area:  %8p\n",
            StartingVpn,
            EndingVpn,
            ControlArea);
        dprintf("  First ProtoPte: %8p  Last PTE %8p  Commit Charge  %8lx (%ld.)\n",
            FirstPrototypePte,
            LastContiguousPte,
            (ULONG)CommitCharge,
            (ULONG)CommitCharge
            );
        dprintf("  Secured.Flink   %8p  Blink    %8p  Banked/Extend: %8p Offset %lx\n",
            ListFlink,
            ListBlink,
            Banked,
            FileOffset);

        dprintf("   ");

        if (PhysicalMapping) { dprintf("PhysicalMapping "); }
        if (ImageMap) { dprintf("ImageMap "); }
        Inherit ? dprintf("ViewShare ") : dprintf("ViewUnmap ");
        if (NoChange) { dprintf("NoChange "); }
        if (CopyOnWrite) { dprintf("CopyOnWrite "); }
        if (LargePages) { dprintf("LargePages "); }
        if (MemCommit) { dprintf("MemCommit "); }
        if (PrivateMemory) { dprintf("PrivateMemory "); }
        dprintf ("%s\n\n",ProtectString[Protection & 7]);

        if (ExtendableFile) { dprintf("ExtendableFile "); }
        if (SecNoChange) { dprintf("SecNoChange "); }
        if (OneSecured) { dprintf("OneSecured "); }
        if (MultipleSecured) { dprintf("MultipleSecured "); }
        if (ReadOnly) { dprintf("ReadOnly "); }
        if (StoredInVad) { dprintf("StoredInVad "); }
        dprintf ("\n\n");

        return E_INVALIDARG;
    }

    Prev = First;

    while (LeftChild != 0) {
        if ( CheckControlC() ) {
            return E_INVALIDARG;
        }
        Prev = First;
        First = LeftChild;
        Level += 1;
        if (Level > MaxLevel) {
            MaxLevel = Level;
        }

        if (Flags & 2) {
            dprintf("Reading LeftChild VAD %08p\n",First );
        }

        if ( ReadFirstVadShort(LeftChild, LeftChild) ) {
            dprintf("%08p %08p: Unable to get contents of VAD3\n", First, Prev);
            return E_INVALIDARG;
        }
    }

    ReadFirstVadShort(StartingVpn, StartingVpn);
    ReadFirstVadShort(EndingVpn, EndingVpn);
    ReadFirstVadShort(Parent, Parent);
    ReadFirstVadShort(RightChild, RightChild);
    ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);
    ReadFirstVadShort(u.VadFlags.PrivateMemory, PrivateMemory);
    ReadFirstVadShort(u.VadFlags.PhysicalMapping, PhysicalMapping);
    ReadFirstVadShort(u.VadFlags.ImageMap, ImageMap);
    ReadFirstVadShort(u.VadFlags.Protection, Protection);


    dprintf("VAD     level      start      end    commit\n");
    dprintf("%p (%2ld)   %8p %8p      %4ld %s %s %s\n",
            First,
            Level,
            StartingVpn,
            EndingVpn,
            (ULONG)CommitCharge,
            PrivateMemory ? "Private" : "Mapped ",
            ImageMap ? "Exe " :
                PhysicalMapping ? "Phys" : "    ",
            ProtectString[Protection & 7]
            );
    Count += 1;
    AverageLevel += Level;

    Next = First;
    while (Next != 0) {

        if ( CheckControlC() ) {
            return E_INVALIDARG;
        }

        if (RightChild == 0) {

            Done = TRUE;
            while ((ParentStored = Parent) != 0) {
                if ( CheckControlC() ) {
                    return E_INVALIDARG;
                }

                Level -= 1;

                //
                // Locate the first ancestor of this node of which this
                // node is the left child of and return that node as the
                // next element.
                //

                First = ParentStored;
                if ( ReadFirstVadShort( LeftChild, LeftChild) ||
                     ReadFirstVadShort(Parent, Parent) ) {
                    dprintf("%08p %08p: Unable to get contents of VAD4\n",Parent, Prev);
                    return E_INVALIDARG;
                }
                Prev = First;
                
                ReadFirstVadShort(StartingVpn, StartingVpn);
                ReadFirstVadShort(EndingVpn, EndingVpn);
                ReadFirstVadShort(RightChild, RightChild);
                ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);
                ReadFirstVadShort(u.VadFlags.PrivateMemory, PrivateMemory);
                ReadFirstVadShort(u.VadFlags.PhysicalMapping, PhysicalMapping);
                ReadFirstVadShort(u.VadFlags.ImageMap, ImageMap);
                ReadFirstVadShort(u.VadFlags.Protection, Protection);

                if (LeftChild == Next) {
                    Next = ParentStored;
                    
                    dprintf("%p (%2ld)   %8p %8p      %4ld %s %s %s\n",
                            Next,
                            Level,
                            StartingVpn,
                            EndingVpn,
                            (ULONG)CommitCharge,
                            PrivateMemory ? "Private" : "Mapped ",
                            ImageMap ? "Exe " :
                                PhysicalMapping ? "Phys" : "    ",
                            ProtectString[Protection & 7]
                           );
                    Done = FALSE;
                    Count += 1;
                    AverageLevel += Level;
                    break;
                }
                Next = ParentStored;
            }
            if (Done) {
                Next = 0;
                break;
            }
        } else {

            //
            // A right child exists, locate the left most child of that right child.
            //

            Next = RightChild;
            Level += 1;
            if (Level > MaxLevel) {
                MaxLevel = Level;
            }

            First = Next;

            if ( ReadFirstVadShort(LeftChild, LeftChild) ) {
                dprintf("%08p %08p: Unable to get contents of VAD5\n",Next, Prev);
                return E_INVALIDARG;
            }

            while ((Left = LeftChild) != 0) {
                if ( CheckControlC() ) {
                    return E_INVALIDARG;
                }
                Level += 1;
                if (Level > MaxLevel) {
                    MaxLevel = Level;
                }
                Next = Left;
                First = Next;
                if ( ReadFirstVadShort(LeftChild, LeftChild) ) {
                    dprintf("%08p %08p: Unable to get contents of VAD6\n",Next, Prev);
                    return E_INVALIDARG;
                }
                Prev = First;
            }

            ReadFirstVadShort(StartingVpn, StartingVpn);
            ReadFirstVadShort(EndingVpn, EndingVpn);
            ReadFirstVadShort(Parent, Parent);
            ReadFirstVadShort(RightChild, RightChild);
            ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);
            ReadFirstVadShort(u.VadFlags.PrivateMemory, PrivateMemory);
            ReadFirstVadShort(u.VadFlags.PhysicalMapping, PhysicalMapping);
            ReadFirstVadShort(u.VadFlags.ImageMap, ImageMap);
            ReadFirstVadShort(u.VadFlags.Protection, Protection);

            dprintf("%p (%2ld)   %8p %8p      %4ld %s %s %s\n",
                      Next,
                      Level,
                      StartingVpn,
                      EndingVpn,
                      (ULONG)CommitCharge,
                      PrivateMemory ? "Private" : "Mapped ",
                      ImageMap ? "Exe " :
                          PhysicalMapping ? "Phys" : "    ",
                      ProtectString[Protection & 7]
                   );
                    Count += 1;
                    AverageLevel += Level;
        }
    }
    dprintf("\nTotal VADs: %5ld  average level: %4ld  maximum depth: %ld\n",
            Count, 1+(AverageLevel/Count),MaxLevel);

#undef ReadFirstVad
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\util.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

ULONG
GetBitFieldOffset (
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   )
{
   FIELD_INFO flds = {
       Field, "", 0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_SIZE_IN_BITS,
       0, NULL};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG Err, i=0;
   LPSTR dot, last=Field;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   *pSize   = flds.size;
   return Err;
}

ULONG
GetFieldOffsetEx (
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   )
{
   FIELD_INFO flds = {
       Field, "", 0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0, NULL};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG Err, i=0;
   LPSTR dot, last=Field;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   *pSize   = flds.size;
   return Err;
} // GetFieldOffsetEx()

ULONG
GetUlongFromAddress (
    ULONG64 Location
    )
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("GetUlongFromAddress: unable to read from %p\n", Location);
        return 0;
    }

    return Value;
}

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    )
{
    ULONG64 Value;
    ULONG result;

    if (!ReadPointer( Location, &Value )) {
        dprintf( "GetPointerFromAddress: unable to read from %p\n", Location );
        return 0;
    }
    return Value;
}

ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG64 Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetUlongFromAddress( Location );
}


ULONG64
GetPointerValue (
    PCHAR String
    )
{
    ULONG64 Location, Val=0;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    ReadPointer(Location, &Val);

    return Val;
}

ULONG64
GetGlobalFromAddress (
    ULONG64 Location,
    ULONG   Size
    )
{
    ULONG64 value;
    ULONG   result;

    value = 0;
    if ((!ReadMemory(Location,&value,Size,&result)) || (result < Size)) {
        dprintf("GetGlobalFromAddress: unable to read from %p\n", Location);
        return 0;
    }
    return value;
} // GetGlobalFromAddress()

ULONG64
GetGlobalValue (
    PCHAR  String
    )
{
    ULONG64 location;
    ULONG   size;

    location = GetExpression( String );
    if (!location) {
        dprintf("GetGlobalValue: unable to get %s\n",String);
        return 0;
    }
    size = GetTypeSize( String );
    if (!size)  {
        dprintf("GetGlobalValue: unable to get %s type size\n",String);
        return 0;
    }
    return GetGlobalFromAddress( location, size );
} // GetGlobalValue()

HRESULT
GetGlobalEx(
    PCHAR String,
    PVOID OutValue, 
    ULONG OutSize
    )
{
    ULONG64 location;
    ULONG   size;
    ULONG   result;

    ZeroMemory( OutValue, OutSize );
    location = GetExpression( String );
    if (!location) {
        return E_INVALIDARG;
    }
    size = GetTypeSize( String );
    if (!size)  {
        return E_INVALIDARG;
    }
    if ( size > OutSize )   {
        return E_OUTOFMEMORY;
    }
    if ((!ReadMemory(location,OutValue,size,&result)) || (result < size)) {
        return E_FAIL;
    }
    return S_OK;
} // GetGlobalEx()

#if 0
VOID
DumpImageName(
    IN ULONG64 Process
    )
{
    ULONG64 ImageFileName;
    STRING String;
    ULONG Result;
    IN WCHAR Buf[512];


    if ( !GetFieldValue(Process, "EPROCESS", "ImageFileName.Buffer", ImageFileName ) ){

        wcscpy(Buf,L"*** image name unavailable ***");
        if ( ReadMemory( ImageFileName,
                         &String,
                         sizeof(STRING),
                         &Result) ) {
            if ( ReadMemory( (DWORD)String.Buffer,
                             &Buf[0],
                             String.Length,
                             &Result) ) {
                Buf[String.Length/sizeof(WCHAR)] = UNICODE_NULL;
            }
        }
    } else {
        wcscpy(Buf,L"System Process");
    }
    dprintf("%ws",Buf);
}
#endif

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 RightChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "RightChild", RightChild)) {

        return FALSE;
    }

    if (RightChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 LeftChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "LeftChild", LeftChild)) {

        return FALSE;
    }

    if (LeftChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}


ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    )
/*++
    Purpose:

        Perform an in-order iteration across a splay tree, calling a
        user supplied function with a pointer to each RTL_SPLAY_LINKS
        structure encountered in the tree, and the level in the tree
        at which it was encountered (zero based).

    Arguments:

        pSplayLinks     - pointer to root of a splay tree

        DumpNodeFn      - user supplied dumping function

   Returns:

        Count of nodes encountered in the tree.

   Notes:

        Errors reading memory do not terminate the iteration if more
        work is possible.

        Consumes the Control-C flag to terminate possible loops in
        corrupt structures.

--*/
{
    ULONG Level = 0;
    ULONG NodeCount = 0;

    if (pSplayLinks) {
        ULONG64 LeftChild, RightChild, Parent, Current;

        //
        //  Retrieve the root links, find the leftmost node in the tree
        //

        if (GetFieldValue(Current = pSplayLinks,
                          "RTL_SPLAY_LINKS",
                          "LeftChild",
                          LeftChild)) {

            return NodeCount;
        }

        while (LeftChild != 0) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            if (GetFieldValue(Current = LeftChild,
                              "RTL_SPLAY_LINKS",
                              "LeftChild",
                              LeftChild)) {

                //
                //  We can try to continue from this
                //

                break;
            }

            Level++;
        }

        while (TRUE) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            NodeCount++;
            pSplayLinks = Current;
            (*DumpNodeFn)(pSplayLinks, Level);

            /*
                first check to see if there is a right subtree to the input link
                if there is then the real successor is the left most node in
                the right subtree.  That is find and return P in the following diagram

                      Links
                         \
                          .
                         .
                        .
                       /
                      P
                       \
            */

            GetFieldValue(Current, "RTL_SPLAY_LINKS", "RightChild", RightChild);
            if (RightChild != 0) {

                if (GetFieldValue(Current = RightChild,
                                  "RTL_SPLAY_LINKS",
                                  "RightChild",
                                  RightChild)) {

                    //
                    //  We've failed to step through to a successor, so
                    //  there is no more to do
                    //

                    return NodeCount;
                }

                Level++;

                GetFieldValue(Current,"RTL_SPLAY_LINKS","LeftChild",LeftChild);
                while (LeftChild != 0) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    if (GetFieldValue(Current = LeftChild,
                                     "RTL_SPLAY_LINKS",
                                     "LeftChild",
                                     LeftChild)) {

                        //
                        //  We can continue from this
                        //

                        break;
                    }

                    Level++;
                }

            } else {

                /*
                    we do not have a right child so check to see if have a parent and if
                    so find the first ancestor that we are a left decendent of. That
                    is find and return P in the following diagram

                               P
                              /
                             .
                              .
                               .
                              Links
                */

                //
                //  If the IsLeft or IsRight functions fail to read through a parent
                //  pointer, then we will quickly exit through the break below
                //

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                while (DbgRtlIsRightChild(Current, Parent)) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    Level--;
                    pSplayLinks = (Current = Parent);
                }

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                if (!DbgRtlIsLeftChild(Current, Parent)) {

                    //
                    //  we do not have a real successor so we break out
                    //

                    break;

                } else {

                    Level--;
                    pSplayLinks = (Current = Parent);
                }
            }
        }
    }

    return NodeCount;
}

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    )
{
    UNICODE_STRING v;
    DWORD BytesRead;

//    dprintf("L %x, M %x, B %p ", u.Length, u.MaximumLength, u.Buffer);
    if ((u.Length <= u.MaximumLength) &&
        (u.Buffer) &&
        (u.Length > 0)) {

        v.Buffer = LocalAlloc(LPTR, u.MaximumLength);
        if (v.Buffer != NULL) {
            v.MaximumLength = u.MaximumLength;
            v.Length = u.Length;
            if (ReadMemory(u.Buffer,
                           v.Buffer,
                           u.Length,
                           (PULONG) &u.Buffer)) {
                dprintf("%wZ", &v);
            } else {
                dprintf("<???>");
            }
            LocalFree(v.Buffer);

            return;
        }
    }
}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {

      if      ((*szExpression)< '0') { return FALSE ; }
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}


BOOLEAN
IsDecNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   while(*szExpression) {

      if      ((*szExpression)<'0') { return FALSE ; }
      else if ((*szExpression)>'9') { return FALSE ; }
      szExpression ++ ;
   }
   return TRUE ;
}

ULONG64
UtilStringToUlong64 (
    UCHAR *String
    )
{
    UCHAR LowDword[9], HighDword[9];

    ZeroMemory (&HighDword, sizeof (HighDword));
    ZeroMemory (&LowDword, sizeof (LowDword));

    if (strlen (String) > 8) {

        memcpy (&LowDword, (void *) &String[strlen (String) - 8], 8);
        memcpy (&HighDword, (void *) &String[0], strlen (String) - 8);

    } else {

        return strtoul (String, 0, 16);
    }

    return ((ULONG64) strtoul (HighDword, 0, 16) << 32) + strtoul (LowDword, 0, 16);
}

const char *
getEnumName(
        ULONG       EnumVal,
        PENUM_NAME EnumTable
        )
/*++

Routine Description:

    Gets the supplied enum value's name in string format

Arguments:

    EnumVal   -  Enum to be retrieved
    EnumTable -  Table in which the enum is looked up to find
                 the string to be retrieved (since we can't rely on the debugger)

Return Value:

None

--*/
{
   ULONG i;

   for (i=0; EnumTable[i].Name != NULL; i++) {
      if (EnumTable[i].EnumVal == EnumVal) {
         break;
      }
   }
   if (EnumTable[i].Name != NULL) {
      return EnumTable[i].Name;
   } else {
      return "Unknown ";
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\wdmaud.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wdmaud.c

Abstract:

    WinDbg Extension Api

Author:

    Noel Cross (NoelC) 18-Sept-1998

Environment:

    Kernel Mode.

Revision History:

--*/


#include "precomp.h"
#define UNDER_NT
#define WDMA_KD
// #include "..\..\ntos\dd\wdm\audio\legacy\wdmaud.sys\wdmsys.h"

typedef union _WDMAUD_FLAGS {
    struct {
        ULONG   Ioctls              : 1;
        ULONG   PendingIrps         : 1;
        ULONG   AllocatedMdls       : 1;
        ULONG   pContextList        : 1;
        ULONG   Reserved1           : 4;
        ULONG   Verbose             : 1;
        ULONG   Reserved            : 23;
    };
    ULONG Flags;
} WDMAUD_FLAGS;

/**********************************************************************
 * Forward References
 **********************************************************************
 */
VOID
PrintCommand (
    ULONG           IoCode
    );

VOID
DumpIoctlLog (
    ULONG64         memLoc,
    ULONG           flags
    );

VOID
DumpPendingIrps (
    ULONG64         memLoc,
    ULONG           flags
    );

VOID
DumpAllocatedMdls (
    ULONG64         memLoc,
    ULONG           flags
    );

VOID
DumpContextList (
    ULONG64         memLoc,
    ULONG           flags
    );


DECLARE_API( wdmaud )
/*++

Routine Description:

    Entry point for the kernel debugger extensions for wdmaud

Arguments:

    flags - 1 - Ioctl History Dump
            2 - Pending Irps
            4 - Allocated Mdls
            8 - pContext Dump
            100 - Verbose

Return Value:

    None.

--*/
{
    ULONG64         memLoc=0;
    CHAR            buffer[256];
    WDMAUD_FLAGS    flags;

    buffer[0] = '\0';
    flags.Flags = 0;

    //
    // get the arguments
    //
    if (!*args)
    {
        memLoc = EXPRLastDump;
    }
    else
    {
        if (GetExpressionEx( args, &memLoc, &args)) {
            strcpy(buffer, args );
        }
    }

    if( '\0' != buffer[0] )
    {
        flags.Flags = (ULONG) GetExpression( buffer );
    }

    if (memLoc)
    {
        if (flags.Ioctls)
        {
            //
            //  dump wdmaud's history of ioctls
            //
            DumpIoctlLog ( memLoc, flags.Flags );
        }
        else if (flags.PendingIrps)
        {
            //
            //  dump any pending irps that wdmaud hasn't completed yet
            //
            DumpPendingIrps ( memLoc, flags.Flags );
        }
        else if (flags.AllocatedMdls)
        {
            //
            //  dump all Mdls which have been allocated by wdmaud
            //
            DumpAllocatedMdls ( memLoc, flags.Flags );
        }
        else if (flags.pContextList)
        {
            //
            //  dump the list of all registered pContexts
            //
            DumpContextList ( memLoc, flags.Flags );
        }
        else
        {
            dprintf("\nNo valid flags\n");
            dprintf("SYNTAX:  !wdmaud <address> <flags>\n");
        }
    }
    else
    {
        dprintf("\nInvalid memory location\n");
        dprintf("SYNTAX:  !wdmaud <address> <flags>\n");
    }

    return S_OK;
}

VOID
PrintCommand(
    ULONG   IoCode
    )
/*++

Routine Description:

    Prints out individual ioctls

Arguments:

    pCommand - Ioctl to log

Return Value:

    None.

--*/
{
    switch( IoCode )
    {
        case IRP_MJ_CREATE:
            dprintf("IRP_MJ_CREATE");
            break;
        case IRP_MJ_CLOSE:
            dprintf("IRP_MJ_CLOSE");
            break;
        case IOCTL_WDMAUD_INIT:
            dprintf("IOCTL_WDMAUD_INIT");
            break;
        case IOCTL_WDMAUD_EXIT:
            dprintf("IOCTL_WDMAUD_EXIT");
            break;
        case IOCTL_WDMAUD_ADD_DEVNODE:
            dprintf("IOCTL_WDMAUD_ADD_DEVNODE");
            break;
        case IOCTL_WDMAUD_REMOVE_DEVNODE:
            dprintf("IOCTL_WDMAUD_REMOVE_DEVNODE");
            break;
        case IOCTL_WDMAUD_GET_CAPABILITIES:
            dprintf("IOCTL_WDMAUD_GET_CAPABILITIES");
            break;
        case IOCTL_WDMAUD_GET_NUM_DEVS:
            dprintf("IOCTL_WDMAUD_GET_NUM_DEVS");
            break;
        case IOCTL_WDMAUD_OPEN_PIN:
            dprintf("IOCTL_WDMAUD_OPEN_PIN");
            break;
        case IOCTL_WDMAUD_CLOSE_PIN:
            dprintf("IOCTL_WDMAUD_CLOSE_PIN");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_PAUSE:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_PAUSE");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_PLAY:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_PLAY");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_RESET:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_RESET");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_GET_POS:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_GET_POS");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN");
            break;
        case IOCTL_WDMAUD_WAVE_IN_STOP:
            dprintf("IOCTL_WDMAUD_WAVE_IN_STOP");
            break;
        case IOCTL_WDMAUD_WAVE_IN_RECORD:
            dprintf("IOCTL_WDMAUD_WAVE_IN_RECORD");
            break;
        case IOCTL_WDMAUD_WAVE_IN_RESET:
            dprintf("IOCTL_WDMAUD_WAVE_IN_RESET");
            break;
        case IOCTL_WDMAUD_WAVE_IN_GET_POS:
            dprintf("IOCTL_WDMAUD_WAVE_IN_GET_POS");
            break;
        case IOCTL_WDMAUD_WAVE_IN_READ_PIN:
            dprintf("IOCTL_WDMAUD_WAVE_IN_READ_PIN");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_RESET:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_RESET");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA");
            break;
        case IOCTL_WDMAUD_MIDI_IN_STOP:
            dprintf("IOCTL_WDMAUD_MIDI_IN_STOP");
            break;
        case IOCTL_WDMAUD_MIDI_IN_RECORD:
            dprintf("IOCTL_WDMAUD_MIDI_IN_RECORD");
            break;
        case IOCTL_WDMAUD_MIDI_IN_RESET:
            dprintf("IOCTL_WDMAUD_MIDI_IN_RESET");
            break;
        case IOCTL_WDMAUD_MIDI_IN_READ_PIN:
            dprintf("IOCTL_WDMAUD_MIDI_IN_READ_PIN");
            break;
        case IOCTL_WDMAUD_MIXER_OPEN:
            dprintf("IOCTL_WDMAUD_MIXER_OPEN");
            break;
        case IOCTL_WDMAUD_MIXER_CLOSE:
            dprintf("IOCTL_WDMAUD_MIXER_CLOSE");
            break;
        case IOCTL_WDMAUD_MIXER_GETLINEINFO:
            dprintf("IOCTL_WDMAUD_MIXER_GETLINEINFO");
            break;
        case IOCTL_WDMAUD_MIXER_GETLINECONTROLS:
            dprintf("IOCTL_WDMAUD_MIXER_GETLINECONTROLS");
            break;
        case IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS:
            dprintf("IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS");
            break;
        case IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS:
            dprintf("IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS");
            break;
        default:
            dprintf("UNKNOWN command %X", IoCode );
            break;
    }
}

VOID
DumpIoctlLog (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of Ioctls that have been sent down
    to wdmaud.sys.  In debugging it is useful to see the context and
    request being made to wdmaud.sys to track down coding errors.

Arguments:

    Flags - Verbose turns prints the pContext that the Ioctl was sent
            down with.

Return Value:

    None

--*/
{
    LIST_ENTRY                  List;
    ULONG64                     ple;
    ULONG64                     pIoctlHistoryListItem;
  //  IOCTL_HISTORY_LIST_ITEM     IoctlHistoryBuffer;
    ULONG                       Result;
    WDMAUD_FLAGS                Flags;
    ULONG                       IoCode, IoStatus;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "tag_IOCTL_HISTORY_LIST_ITEM", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in tag_IOCTL_HISTORY_LIST_ITEM
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaIoctlHistoryListHead\n");
        return;
    }

    dprintf("Command history, newest first:\n");

//  ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaIoctlHistoryListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pContext, pIrp;

        if (CheckControlC())
        {
            return;
        }

        pIoctlHistoryListItem = ple - NextOffset;
        if (GetFieldValue(pIoctlHistoryListItem,
                           "tag_IOCTL_HISTORY_LIST_ITEM",
                           "IoCode",
                           IoCode))
        {
            dprintf("Unable to read IOCTL_HISTORY_LIST_ITEM at %08p",pIoctlHistoryListItem);
            return;
        }

        PrintCommand ( IoCode );
        GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM","IoStatus",IoStatus);

        dprintf(" Status=%08X, ", IoStatus );

        if ( Flags.Verbose )
        {
            GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM","pContext",pContext);
            GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM","pIrp",pIrp);
            
            dprintf(" pContext=%08X, Irp=%08X\n", pContext, pIrp );
        }
        else
        {
            dprintf("\n");
        }

        GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM", "Next.Flink", ple);
    }
}

VOID
DumpPendingIrps (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of Irps that WDMAUD has marked
    pending.  WDMAUD needs to make sure that all Irps have completed
    for a context before allowing the context to be closed.

Arguments:

    Flags - Verbose mode will print out the context on which this
            Irp was allocated.

Return Value:

    None

--*/
{
    LIST_ENTRY              List;
    ULONG64                 ple;
    ULONG64                 pPendingIrpListItem;
//    PENDING_IRP_LIST_ITEM   PendingIrpBuffer;
    ULONG                   Result;
    WDMAUD_FLAGS            Flags;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "tag_PENDING_IRP_LIST_ITEM", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in tag_IOCTL_HISTORY_LIST_ITEM
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaPendingIrpListHead\n");
        return;
    }


    dprintf("Dumping pending irps:\n");

//    ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaPendingIrpListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pIrp, pContext;
        ULONG IrpDeviceType;

        if (CheckControlC())
        {
            return;
        }

        pPendingIrpListItem = ple - NextOffset;

        if (GetFieldValue(pPendingIrpListItem,
                          "tag_PENDING_IRP_LIST_ITEM",
                           "IrpDeviceType",
                           IrpDeviceType))
        {
            dprintf("Unable to read PENDING_IRP_LIST_ITEM at %08p",pPendingIrpListItem);
            return;
        }

        GetFieldValue(pPendingIrpListItem,"tag_PENDING_IRP_LIST_ITEM","pIrp",pIrp);
        if ( Flags.Verbose )
        {
            GetFieldValue(pPendingIrpListItem,
                          "tag_PENDING_IRP_LIST_ITEM",
                          "pContext",
                          pContext);
            
            dprintf("Irp: %p, ", pIrp);
            switch (IrpDeviceType)
            {
                case WaveOutDevice:
                    dprintf("IrpType: WaveOut, ");
                    break;

                case WaveInDevice:
                    dprintf("IrpType: WaveIn, ");
                    break;

                case MidiOutDevice:
                    dprintf("IrpType: MidiOut, ");
                    break;

                case MidiInDevice:
                    dprintf("IrpType: MidiIn, ");
                    break;

                case MixerDevice:
                    dprintf("IrpType: Mixer, ");
                    break;

                case AuxDevice:
                    dprintf("IrpType: Aux, ");
                    break;

                default:
                    dprintf("IrpType: Unknown, ");
                    break;
            }
            dprintf("pContext: %p\n", pContext);
        }
        else
        {
            dprintf("Irp: %p\n", pIrp);
        }

        GetFieldValue(pPendingIrpListItem,"tag_PENDING_IRP_LIST_ITEM","Next.Flink", ple);
    }

}

VOID
DumpAllocatedMdls (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of MDLs that WDMAUD has allocated.
    WDMAUD needs to make sure that all MDLs have freed for a context
    before allowing the context to be closed.

Arguments:

    Flags - Verbose mode will print out the context on which this
            Mdl was allocated.

Return Value:

    None

--*/
{
    LIST_ENTRY                  List;
    ULONG64                     ple;
    ULONG64                     pAllocatedMdlListItem;
//    ALLOCATED_MDL_LIST_ITEM     AllocatedMdlBuffer;
    ULONG                       Result;
    WDMAUD_FLAGS                Flags;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "ALLOCATED_MDL_LIST_ITEM", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in tag_IOCTL_HISTORY_LIST_ITEM
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaPendingIrpListHead\n");
        return;
    }


    dprintf("Dumping allocated Mdls:\n");

//    ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaPendingIrpListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pMdl, pContext;
        ULONG IrpDeviceType;

        if (CheckControlC())
        {
            return;
        }

        pAllocatedMdlListItem = ple - NextOffset;

        if (GetFieldValue(pAllocatedMdlListItem,
                          "ALLOCATED_MDL_LIST_ITEM",
                           "pMdl",
                           pMdl))
        {
            dprintf("Unable to read ALLOCATED_MDL_LIST_ITEM at %08p",pAllocatedMdlListItem);
            return;
        }

        if ( Flags.Verbose )
        {
            GetFieldValue(pAllocatedMdlListItem,"ALLOCATED_MDL_LIST_ITEM","pContext",pContext);
            dprintf("Mdl: %p, pContext: %p\n", pMdl,
                                               pContext);
        }
        else
        {
            dprintf("Mdl: %p\n", pMdl);
        }

        GetFieldValue(pAllocatedMdlListItem,"ALLOCATED_MDL_LIST_ITEM","Next.Flink", ple);
    }

}

VOID
DumpContextList (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of active contexts attached to wdmaud.sys.
    The contexts contain most of the state data for each device.  Whenever
    wdmaud.drv is loaded into a new process, wdmaud.sys will be notified
    of its arrival.  When wdmaud.drv is unload, wdmaud.sys cleans up any
    allocation made in that context.

Arguments:

    Flags - Verbose mode will print out the data members of each
            context structure.

Return Value:

    None

--*/
{
    LIST_ENTRY      List;
    ULONG64         ple;
    ULONG64         pWdmaContextListItem;
  //  WDMACONTEXT     WdmaContextBuffer;
    ULONG           Result;
    WDMAUD_FLAGS    Flags;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "WDMACONTEXT", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in WDMACONTEXT
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaContextListHead\n");
        return;
    }


    dprintf("Dumping list of active WDMAUD contexts:\n");

//    ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaAllocatedMdlListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pContext;

        if (CheckControlC())
        {
            return;
        }

        pWdmaContextListItem = ple - NextOffset;
        if (GetFieldValue(pWdmaContextListItem,
                           "WDMACONTEXT",
                           "Next.Flink",
                           ple))
        {
            dprintf("Unable to read WDMACONTEXT at %08lx",pWdmaContextListItem);
            return;
        }

        if ( Flags.Verbose )
        {
            dprintf("Use dt WDMACONTEXT <addr>\n");
/*            dprintf("pContext: %X\n", pWdmaContextListItem);
            dprintf("   fInList:                    %X\n", WdmaContextBuffer.fInList);
            dprintf("   fInitializeSysaudio:        %X\n", WdmaContextBuffer.fInitializeSysaudio);
            dprintf("   InitializedSysaudioEvent:   %X\n", &WdmaContextBuffer.InitializedSysaudioEvent);
            dprintf("   pFileObjectSysaudio:        %X\n", WdmaContextBuffer.pFileObjectSysaudio);
            dprintf("   EventData:                  %X\n", &WdmaContextBuffer.EventData);
            dprintf("   VirtualWavePinId:           %X\n", WdmaContextBuffer.VirtualWavePinId);
            dprintf("   VirtualMidiPinId:           %X\n", WdmaContextBuffer.VirtualMidiPinId);
            dprintf("   PreferredSysaudioWaveDevice:%X\n", WdmaContextBuffer.PreferredSysaudioWaveDevice);
            dprintf("   DevNodeListHead:            %X\n", WdmaContextBuffer.DevNodeListHead);
            dprintf("   NotificationEntry:          %X\n", WdmaContextBuffer.NotificationEntry);
            dprintf("   WorkListWorkItem:           %X\n", WdmaContextBuffer.WorkListWorkItem);
            dprintf("   WorkListHead:               %X\n", WdmaContextBuffer.WorkListHead);
            dprintf("   WorkListSpinLock:           %X\n", WdmaContextBuffer.WorkListSpinLock);
            dprintf("   cPendingWorkList:           %X\n", WdmaContextBuffer.cPendingWorkList);
            dprintf("   SysaudioWorkItem:           %X\n", WdmaContextBuffer.SysaudioWorkItem);
            dprintf("   WorkListWorkerObject:       %X\n", WdmaContextBuffer.WorkListWorkerObject);
            dprintf("   SysaudioWorkerObject:       %X\n", WdmaContextBuffer.SysaudioWorkerObject);

            dprintf("   WaveOutDevs:                %X\n", &WdmaContextBuffer.WaveOutDevs);
            dprintf("   WaveInDevs:                 %X\n", &WdmaContextBuffer.WaveInDevs);
            dprintf("   MidiOutDevs:                %X\n", &WdmaContextBuffer.MidiOutDevs);
            dprintf("   MidiInDevs:                 %X\n", &WdmaContextBuffer.MidiInDevs);
            dprintf("   MixerDevs:                  %X\n", &WdmaContextBuffer.MixerDevs);
            dprintf("   AuxDevs:                    %X\n", &WdmaContextBuffer.AuxDevs);

            dprintf("   apCommonDevice:             %X\n", &WdmaContextBuffer.apCommonDevice);*/
        }
        else
        {
            dprintf("pContext: %p\n", pWdmaContextListItem);
        }

//        ple = WdmaContextBuffer.Next.Flink;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdlog\kdlogctl.h ===
//
// 
//

#define KDLOG_QUERY_LOG_CONTEXT     CTL_CODE (FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define KDLOG_GET_LOG_DATA          CTL_CODE (FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdlog\app\kdlog.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   kdlog.c

Abstract:

    This app dumps out the KD debugger log, which is produced
    by the KD hw ext (e.g. KD1394.DLL, KDCOM.DLL).

Author:

    Neil Sandlin (neilsa) 31-Oct-2000

Envirnoment:



Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <kdlog.h>
#include <kdlogctl.h>

VOID
DumpLogData(
    PKD_DBG_LOG_CONTEXT LogContext,
    PUCHAR pData
    );


__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    HANDLE                      DriverHandle;
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    KD_DBG_LOG_CONTEXT          LogContext;
    PUCHAR                      pData;
    ULONG                       DataLength;

    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\KDLog");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        printf("Error: KDLOG.SYS not running\n");
        return ;
    }

    //
    // Get the log context
    //
    
    status = NtDeviceIoControlFile(
                DriverHandle,
                (HANDLE) NULL,
                (PIO_APC_ROUTINE) NULL,
                (PVOID) NULL,
                &IOSB,
                KDLOG_QUERY_LOG_CONTEXT,
                &LogContext,
                sizeof (LogContext),
                NULL,       
                0
                );

    if (!NT_SUCCESS(status)) {
        printf("Error %08x retrieving Log Context\n", status);
        NtClose (DriverHandle);
        return ;
    }
    
    printf("EntryLength %08x, LastIndex %08x\n", LogContext.EntryLength, LogContext.LastIndex);
    printf("Count %08x, Index %08x\n\n", LogContext.Count, LogContext.Index);

    DataLength = LogContext.EntryLength * (LogContext.LastIndex + 1);
    pData = malloc(DataLength);


    if (pData == NULL) {
        printf("Unable to allocate %08x bytes for data\n", DataLength);
    } else {
        
        //
        // Get the log data
        //
        
        status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    KDLOG_GET_LOG_DATA,
                    pData,
                    DataLength,
                    NULL,       
                    0
                    );
      
        if (!NT_SUCCESS(status)) {
            printf("Error %08x retrieving Log Context\n", status);
        } else {
        
            DumpLogData(&LogContext, pData);
        }      
        free(pData);    
    }        
        
        
    NtClose (DriverHandle);

    return;
}



VOID
DumpLogData(
    PKD_DBG_LOG_CONTEXT LogContext,
    PUCHAR pData
    )
{
    ULONG Count = LogContext->Count;
    ULONG Index = LogContext->Index;
    
    while(Count--) {

        if (Index == 0) {
            Index = LogContext->LastIndex+1;
        }
        Index--;

        printf("%s", &pData[Index*LogContext->EntryLength]);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kernrate\makefile.inc ===
HALIA64_PATH=$(PROJECT_ROOT)\hals\halia64\ia64

$(O)\kernrate.res: kernrate.rc

merced.c: $(HALIA64_PATH)\merced.c profevts.pl makefile.inc
    @perl profevts.pl $(HALIA64_PATH)\merced.c > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdexts2\wsle.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    wsle.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (LouP) 14-Mar-1994

Environment:

    User Mode.

--*/


#include "precomp.h"
#pragma hdrstop

#define PACKET_MAX_SIZE 4000
#define NUMBER_OF_WSLE_TO_READ  1000 // ((PACKET_MAX_SIZE/sizeof(MMWSLE))-1)

USHORT
GetPfnRefCount(
    IN ULONG64 PageFrameNumber
    );

DECLARE_API( wsle )

/*++

Routine Description:

    Dumps all wsles for process.

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    ULONG Result;
    ULONG Flags;
    ULONG index;
    ULONG64 WorkingSet;
    ULONG64 WsleBase;
    ULONG64 Va;
    ULONG64 Wsle;
    ULONG next;
    ULONG j;
    ULONG k;
    PCHAR WsleArray;
    ULONG64 WsleStart;
    ULONG ReadCount;
    ULONG result;
    ULONG found;
    ULONG64 PteAddress;
    ULONG SizeofWsle;
    ULONG64 Quota, HashTable; 
    ULONG FirstFree, FirstDynamic, LastEntry, NextSlot, LastInitializedWsle;
    ULONG NonDirectCount, HashTableSize;
    PCHAR pc;

    Flags = 0;
    WorkingSet = 0;
    Flags = (ULONG) GetExpression(args);
    pc = strchr(args, ' ');
    WorkingSet = pc ? GetExpression(pc) : 0;

    if (WorkingSet == 0) {
        if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
            WorkingSet = GetPointerValue("nt!MmWorkingSetList");
        }
        else if (TargetMachine == IMAGE_FILE_MACHINE_IA64) {
            WorkingSet = (ULONG64)0x6FC00a02000;
        }
        else if (TargetMachine == IMAGE_FILE_MACHINE_AMD64) {
            WorkingSet = (ULONG64)0xFFFFF70000082000;
        }
        else {
            dprintf ("No default WSL for target machine %x\n", TargetMachine);
            return E_INVALIDARG;
        }
    }

    if (GetFieldValue(WorkingSet, "nt!_MMWSL", "Quota", Quota)) {
        dprintf("%08p: Unable to get contents of WSL\n",WorkingSet );
        return E_INVALIDARG;
    }

    if (GetTypeSize("nt!_MMWSL") == 0) {
        dprintf("Type MMWSL not found.\n");
        return E_INVALIDARG;
    }

    GetFieldValue(WorkingSet,"nt!_MMWSL","FirstDynamic", FirstDynamic);
    GetFieldValue(WorkingSet,"nt!_MMWSL","FirstFree", FirstFree);
    GetFieldValue(WorkingSet,"nt!_MMWSL","Wsle", Wsle);
    GetFieldValue(WorkingSet,"nt!_MMWSL","LastEntry", LastEntry);
    GetFieldValue(WorkingSet,"nt!_MMWSL","NextSlot", NextSlot);
    GetFieldValue(WorkingSet,"nt!_MMWSL","LastInitializedWsle", LastInitializedWsle);
    GetFieldValue(WorkingSet,"nt!_MMWSL","NonDirectCount", NonDirectCount);
    GetFieldValue(WorkingSet,"nt!_MMWSL","HashTableSize", HashTableSize);
    GetFieldValue(WorkingSet,"nt!_MMWSL","HashTable", HashTable);

    dprintf ("\nWorking Set @ %8p\n", WorkingSet);

    dprintf ("    Quota:    %8I64lx  FirstFree: %8lx  FirstDynamic:   %8lx\n",
        Quota,
        FirstFree,
        FirstDynamic);

    dprintf ("    LastEntry %8lx  NextSlot:  %8lx  LastInitialized %8lx\n",
        LastEntry,
        NextSlot,
        LastInitializedWsle);

    dprintf ("    NonDirect %8lx  HashTable: %8p  HashTableSize:  %8lx\n",
        NonDirectCount,
        HashTable,
        HashTableSize);

    if (Flags == 0) {
        return E_INVALIDARG;
    }
    
    SizeofWsle = GetTypeSize("nt!_MMWSLE");
    if (SizeofWsle == 0) {
        dprintf("Type _MMWSLE not found.\n");
        return E_INVALIDARG;
    }

    if (Flags == 7) {
        BOOL FirstTime = TRUE;

        //
        // Check free entries in the working set list.
        //

        WsleArray = VirtualAlloc (NULL,
                                  (LastInitializedWsle + 1) * SizeofWsle,
                                  MEM_RESERVE | MEM_COMMIT,
                                  PAGE_READWRITE);

        //
        // Copy the working set list over to the debugger.
        //

        if (WsleArray == NULL) {
            dprintf("Unable to get allocate memory of %ld bytes\n",
                       (LastInitializedWsle + 1) * SizeofWsle);
            return E_INVALIDARG;
        }

        dprintf("\nVirtual Address           Age  Locked  ReferenceCount\n");
        WsleStart = Wsle;

        for (j = 0;
             j <= LastInitializedWsle;
             j += NUMBER_OF_WSLE_TO_READ) {

            if ( CheckControlC() ) {
                VirtualFree (WsleArray,0,MEM_RELEASE);
                return E_INVALIDARG;
            }

            ReadCount = (LastInitializedWsle + 1 - j ) > NUMBER_OF_WSLE_TO_READ ?
                            NUMBER_OF_WSLE_TO_READ :
                            LastInitializedWsle + 1 - j;

            ReadCount *= SizeofWsle;

            //
            // Enough to read and forget - KD will cache the data
            //
            if ( !ReadMemory( WsleStart + j*SizeofWsle,
                              WsleArray + j*SizeofWsle,
                              ReadCount,
                              &result) ) {
                dprintf("Unable to get Wsle table block - "
                        "address %lx - count %lu - page %lu\n",
                        WsleStart + j*SizeofWsle, ReadCount, j);
                VirtualFree (WsleArray,0,MEM_RELEASE);
                return E_INVALIDARG;
            }

            for (k=0; k<ReadCount/SizeofWsle; k++) { 
                GetFieldValue(WsleStart + (j+k)*SizeofWsle, "nt!_MMWSLE", "u1.e1.Valid", WsleArray[j+k]);
            } 

            dprintf(".");
        }
        dprintf("\r");

        //
        // Walk the array looking for bad free entries.
        //

        for (j = 0;
             j <= LastInitializedWsle;
             j += 1) {
            ULONG Valid, Age, LockedInWs, LockedInMemory;
            ULONG64 WsleToread = WsleStart + j*SizeofWsle, Long;

            if ( CheckControlC() ) {
                dprintf("j= %x\n",j);
                VirtualFree (WsleArray,0,MEM_RELEASE);
                return E_INVALIDARG;
            }


            GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.e1.Valid", Valid);

            if (Valid == 0) {

                //
                // Locate j in the array.
                //

                found = FALSE;
                for (k = 0;
                     k <= LastInitializedWsle;
                     k += 1) {
                    ULONG k_Valid;
                    ULONG64 k_Long;
                    
                    k_Valid = WsleArray[k];
                    
                    if (k_Valid == 0) {
                        GetFieldValue(WsleStart + k*SizeofWsle, "nt!_MMWSLE", "u1.Long", k_Long);
                        if ((ULONG) (k_Long >> MM_FREE_WSLE_SHIFT) == j) {
                            found = TRUE;
#if 0
                            dprintf(" free entry located @ index %ld. %lx %ld. %lx\n",
                                j, WsleArray[j].u1.Long,k,WsleArray[k]);
#endif
                            break;
                        }
                    }
                 }
                 if (!found) {
                     
                     if (FirstFree == j) {
                         //        dprintf("first index found\n");
                     } else {
                         
                         GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.VirtualAddress", Long);
                         dprintf(" free entry not located @ index %ld. %p\n",
                                 j, Long);
                     }
                 }
            }
            else {
                ULONG PteValid;

                GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.VirtualAddress", Long);
                Va = Long;
                PteAddress = DbgGetPteAddress (Va);

                if (!GetFieldValue(PteAddress,
                                   "nt!_MMPTE",
                                   "u.Hard.Valid",
                                   PteValid) ) {

                    if (PteValid == 0) {
                        dprintf(" cannot find valid PTE for WS index %d, VA %p\n",
                            j, Long);
                    }
                    else {
                        ULONG64 PageFrameNumber;
                        USHORT ReferenceCount;

                        GetFieldValue( PteAddress,
                                       "nt!_MMPTE",
                                       "u.Hard.PageFrameNumber",
                                       PageFrameNumber);
                        ReferenceCount = GetPfnRefCount (PageFrameNumber);
                        GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.e1.Age", Age);
                        GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.e1.LockedInWs", LockedInWs);
                        GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.LockedInMemory", LockedInMemory);


                        dprintf("%16p         %2u %8ld %8ld\n",
                                Long, Age,
                            (LockedInWs |
                            LockedInMemory) ? 1 : 0,
                            ReferenceCount);
                    }
                }
                else {
                    dprintf(" cannot find valid PDE for WS index %d, VA %p\n",
                        j, Long);
                }
            }
        }

        VirtualFree (WsleArray,0,MEM_RELEASE);

    } else {
        ULONG64 nextLong;

        next = FirstFree;
        WsleBase = Wsle;

        while (next != (ULONG) WSLE_NULL_INDEX) {
            if (CheckControlC()) {
                return E_INVALIDARG;
            }

            if ( GetFieldValue( WsleBase + SizeofWsle*next,
                                 "nt!_MMWSLE",
                                 "u1.VirtualAddress",
                                 nextLong) ) {
                dprintf("%08p: Unable to get contents of wsle\n",
                        WsleBase+SizeofWsle*next );
                return E_INVALIDARG;
            }
            dprintf("index %8lx  value %8p\n", next, nextLong);
            next = (ULONG) (nextLong >> MM_FREE_WSLE_SHIFT);
        }
    }
    return S_OK;
}

typedef struct _MMSECTION_FLAGS {
    unsigned BeingDeleted : 1;
    unsigned BeingCreated : 1;
    unsigned BeingPurged : 1;
    unsigned NoModifiedWriting : 1;

    unsigned FailAllIo : 1;
    unsigned Image : 1;
    unsigned Based : 1;
    unsigned File : 1;

    unsigned Networked : 1;
    unsigned NoCache : 1;
    unsigned PhysicalMemory : 1;
    unsigned CopyOnWrite : 1;

    unsigned Reserve : 1;  // not a spare bit!
    unsigned Commit : 1;
    unsigned FloppyMedia : 1;
    unsigned WasPurged : 1;

    unsigned UserReference : 1;
    unsigned GlobalMemory : 1;
    unsigned DeleteOnClose : 1;
    unsigned FilePointerNull : 1;

    unsigned DebugSymbolsLoaded : 1;
    unsigned SetMappedFileIoComplete : 1;
    unsigned CollidedFlush : 1;
    unsigned NoChange : 1;

    unsigned HadUserReference : 1;
    unsigned ImageMappedInSystemSpace : 1;
    unsigned UserWritable : 1;
    unsigned Accessed : 1;

    unsigned GlobalOnlyPerSession : 1;
    unsigned Rom : 1;
    unsigned filler : 2;
} MMSECTION_FLAGS;

typedef struct _MMSUBSECTION_FLAGS {
    unsigned ReadOnly : 1;
    unsigned ReadWrite : 1;
    unsigned CopyOnWrite : 1;
    unsigned GlobalMemory: 1;
    unsigned Protection : 5;
    unsigned LargePages : 1;
    unsigned StartingSector4132 : 10;   // 2 ** (42+12) == 4MB*4GB == 16K TB
    unsigned SectorEndOffset : 12;
} MMSUBSECTION_FLAGS;

DECLARE_API( ca )

/*++

Routine Description:

    Dumps a control area.

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    LARGE_INTEGER StartingSector;
    ULONG64 ControlAreaVa;
    ULONG64 SubsectionVa;
    ULONG ControlAreaSize;
    ULONG LargeControlAreaSize;
    ULONG SubsectionSize;
    ULONG SubsectionCount;
    ULONG64 Segment;
    ULONG64 FileObject;
    ULONG NumberOfSubsections;
    MMSECTION_FLAGS ControlAreaFlags;
    MMSUBSECTION_FLAGS SubsectionFlags;
    LOGICAL MappedDataFile;
    LOGICAL PrintedSomething;

    ControlAreaVa = GetExpression(args);

    dprintf("\n");
    dprintf("ControlArea @%08p\n", ControlAreaVa);

    ControlAreaSize = GetTypeSize("nt!_CONTROL_AREA");
    if (ControlAreaSize == 0) {
        dprintf("Type CONTROL_AREA not found.\n");
        return E_INVALIDARG;
    }

    InitTypeRead(ControlAreaVa, nt!_CONTROL_AREA);

    Segment = ReadField(Segment);
    NumberOfSubsections = (ULONG)ReadField(NumberOfSubsections);
    FileObject = ReadField(FilePointer);

    dprintf ("  Segment:    %08p    Flink       %8p   Blink          %8p\n",
        Segment,
        ReadField(DereferenceList.Flink),
        ReadField(DereferenceList.Blink));

    dprintf ("  Section Ref %8lx    Pfn Ref     %8lx   Mapped Views   %8lx\n",
        (ULONG) ReadField(NumberOfSectionReferences),
        (ULONG) ReadField(NumberOfPfnReferences),
        (ULONG) ReadField(NumberOfMappedViews));

    dprintf ("  User Ref    %8lx    Subsections %8lx   Flush Count    %8lx\n",
        (ULONG) ReadField(NumberOfUserReferences),
        NumberOfSubsections,
        (USHORT) ReadField(FlushInProgressCount));

    dprintf ("  File Object %08p    ModWriteCount%7lx   System Views   %8lx\n",
        FileObject,
        (USHORT) ReadField(ModifiedWriteCount),
        (USHORT) ReadField(NumberOfSystemCacheViews));

    dprintf ("  WaitForDel  %8p\n",
        ReadField(WaitingForDeletion));

    GetFieldValue(ControlAreaVa, "nt!_CONTROL_AREA", "u.LongFlags", ControlAreaFlags);

    dprintf ("  Flags (%lx) ", ControlAreaFlags);

    if (ControlAreaFlags.BeingDeleted) { dprintf("BeingDeleted "); }
    if (ControlAreaFlags.BeingCreated) { dprintf("BeingCreated "); }
    if (ControlAreaFlags.BeingPurged) { dprintf("BeingPurged "); }
    if (ControlAreaFlags.NoModifiedWriting) { dprintf("NoModifiedWriting "); }

    if (ControlAreaFlags.FailAllIo) { dprintf("FailAllIo "); }
    if (ControlAreaFlags.Image) { dprintf("Image "); }
    if (ControlAreaFlags.Based) { dprintf("Based "); }
    if (ControlAreaFlags.File) { dprintf("File "); }

    if (ControlAreaFlags.Networked) { dprintf("Networked "); }
    if (ControlAreaFlags.NoCache) { dprintf("NoCache "); }
    if (ControlAreaFlags.PhysicalMemory) { dprintf("PhysicalMemory "); }
    if (ControlAreaFlags.CopyOnWrite) { dprintf("CopyOnWrite "); }

    if (ControlAreaFlags.Reserve) { dprintf("Reserve "); }
    if (ControlAreaFlags.Commit) { dprintf("Commit "); }
    if (ControlAreaFlags.FloppyMedia) { dprintf("FloppyMedia "); }
    if (ControlAreaFlags.WasPurged) { dprintf("WasPurged "); }

    if (ControlAreaFlags.UserReference) { dprintf("UserReference "); }
    if (ControlAreaFlags.GlobalMemory) { dprintf("GlobalMemory "); }
    if (ControlAreaFlags.DeleteOnClose) { dprintf("DeleteOnClose "); }
    if (ControlAreaFlags.FilePointerNull) { dprintf("FilePointerNull "); }

    if (ControlAreaFlags.DebugSymbolsLoaded) { dprintf("DebugSymbolsLoaded "); }
    if (ControlAreaFlags.SetMappedFileIoComplete) { dprintf("SetMappedFileIoComplete "); }
    if (ControlAreaFlags.CollidedFlush) { dprintf("CollidedFlush "); }
    if (ControlAreaFlags.NoChange) { dprintf("NoChange "); }

    if (ControlAreaFlags.HadUserReference) { dprintf("HadUserReference "); }
    if (ControlAreaFlags.ImageMappedInSystemSpace) { dprintf("ImageMappedInSystemSpace "); }
    if (ControlAreaFlags.UserWritable) { dprintf("UserWritable "); }
    if (ControlAreaFlags.Accessed) { dprintf("Accessed "); }

    if (ControlAreaFlags.GlobalOnlyPerSession) { dprintf("GlobalOnlyPerSession "); }
    if (ControlAreaFlags.Rom) { dprintf("Rom "); }
    dprintf ("\n\n");

    MappedDataFile = FALSE;

    //
    // Dump the file object's name if there is one and it's resident.
    //

    if (FileObject != 0) {
        ULONG64 FileNameLength;
        ULONG64 FileNameBuffer;
        PUCHAR tempbuffer;
        ULONG result;
        UNICODE_STRING unicodeString;

        if (GetTypeSize("nt!_FILE_OBJECT") == 0) {
            dprintf("Type FILE_OBJECT not found.\n");
            return E_INVALIDARG;
        }
    
        InitTypeRead(FileObject, nt!_FILE_OBJECT);

        FileNameBuffer = ReadField(FileName.Buffer);

        unicodeString.Length = (USHORT) ReadField(FileName.Length);

        tempbuffer = LocalAlloc(LPTR, unicodeString.Length);

        unicodeString.Buffer = (PWSTR)tempbuffer;
        unicodeString.MaximumLength = unicodeString.Length;

        if (FileNameBuffer == 0) {
            dprintf("\tNo Name for File\n");
        }
        else if (!ReadMemory ( FileNameBuffer,
                          tempbuffer,
                          unicodeString.Length,
                          &result)) {
            dprintf("\tFile Name paged out\n");
        } else {
            dprintf("\tFile: %wZ\n", &unicodeString);
        }

        LocalFree(tempbuffer);

        if (ControlAreaFlags.Image == 0) {
            MappedDataFile = TRUE;
        }
    }

    //
    // Dump the segment information.
    //

    dprintf("\nSegment @ %08p:\n", Segment);

    if (MappedDataFile == FALSE) {
        if (GetTypeSize("nt!_SEGMENT") == 0) {
            dprintf("Type SEGMENT not found.\n");
            return E_INVALIDARG;
        }
        InitTypeRead(Segment, nt!_SEGMENT);
    }
    else {
        if (GetTypeSize("nt!_MAPPED_FILE_SEGMENT") == 0) {
            dprintf("Type MAPPED_FILE_SEGMENT not found.\n");
            return E_INVALIDARG;
        }
        InitTypeRead(Segment, nt!_MAPPED_FILE_SEGMENT);
    }

    dprintf("   ControlArea  %08p  Total Ptes  %8lx  NonExtendPtes   %8lx\n",
        ReadField(ControlArea),
        (ULONG) ReadField(TotalNumberOfPtes),
        (ULONG) ReadField(NonExtendedPtes));


    if (ControlAreaVa != ReadField(ControlArea)) {
        dprintf("SEGMENT is corrupt - bad control area backlink.\n");
        return E_INVALIDARG;
    }

    dprintf("   WriteUserRef %8lx  SizeOfSegment  %I64x  PTE Template %I64X\n",
        (ULONG) ReadField(WritableUserReferences),
        ReadField(SizeOfSegment),
        ReadField(SegmentPteTemplate.u.Long));

    dprintf("   Committed    %8p  Extend Info %8p  Image Base   %8p\n",
        ReadField(NumberOfCommittedPages),
        ReadField(ExtendInfo),
        ReadField(SystemImageBase));

    dprintf("   Based Addr   %8p\n",
        ReadField(BasedAddress));

    if (MappedDataFile == FALSE) {

        if (ControlAreaFlags.Image == 1) {
            dprintf("   Image commit %8p  Image Info.  %8p",
                ReadField(ImageCommitment),
                ReadField(ImageInformation));
        }
        else {
            dprintf("   CreatingProcess %8p  FirstMappedVa  %8p",
                ReadField(u1.CreatingProcess),
                ReadField(u2.FirstMappedVa));
        }

        dprintf("   ProtoPtes   %08p\n",
            ReadField(PrototypePte));
    }

    //
    // Dump the subsection(s).
    //

    SubsectionSize = GetTypeSize("nt!_SUBSECTION");

    if (SubsectionSize == 0) {
        dprintf("Type SUBSECTION not found.\n");
        return E_INVALIDARG;
    }

    LargeControlAreaSize = GetTypeSize("nt!_LARGE_CONTROL_AREA");

    if (LargeControlAreaSize == 0) {
        dprintf("Type LARGE_CONTROL_AREA not found.\n");
        return E_INVALIDARG;
    }

    if (ControlAreaFlags.GlobalOnlyPerSession) {
        SubsectionVa = ControlAreaVa + LargeControlAreaSize;
    }
    else {
        SubsectionVa = ControlAreaVa + ControlAreaSize;
    }

    SubsectionCount = 0;

    do {
        if (CheckControlC()) {
            return E_INVALIDARG;
        }

        InitTypeRead(SubsectionVa, nt!_SUBSECTION);

        SubsectionCount += 1;
        dprintf("\nSubsection %ld. @ %8p\n", SubsectionCount, SubsectionVa);

        GetFieldValue(SubsectionVa, "nt!_SUBSECTION", "u.LongFlags", SubsectionFlags);
        StartingSector.LowPart = (ULONG)ReadField(StartingSector);
        StartingSector.HighPart = (LONG)SubsectionFlags.StartingSector4132;

        dprintf("   ControlArea: %08p  Starting Sector %I64X Number Of Sectors %lx\n",
            ReadField(ControlArea),
            StartingSector,
            (ULONG) ReadField(NumberOfFullSectors));

        dprintf("   Base Pte     %08p  Ptes In subsect %8lx Unused Ptes   %8lx\n",
            ReadField(SubsectionBase),
            (ULONG) ReadField(PtesInSubsection),
            (ULONG) ReadField(UnusedPtes));

        dprintf("   Flags        %8lx  Sector Offset   %8lx Protection    %8lx\n",
            SubsectionFlags,
            SubsectionFlags.SectorEndOffset,
            SubsectionFlags.Protection);


        PrintedSomething = FALSE;
        if (SubsectionFlags.ReadOnly) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("ReadOnly ");
        }
        if (SubsectionFlags.ReadWrite) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("ReadWrite");
        }
        if (SubsectionFlags.CopyOnWrite) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("CopyOnWrite ");
        }
        if (SubsectionFlags.GlobalMemory) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("GlobalMemory ");
        }
        if (SubsectionFlags.LargePages) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("Large Pages");
        }

        if (PrintedSomething == TRUE) {
            dprintf("\n");
        }
    
        if (MappedDataFile == TRUE) {
            InitTypeRead(SubsectionVa, nt!_MSUBSECTION);
            dprintf("   Flink        %08p  Blink      %08p      MappedViews %8x\n",
                ReadField(DereferenceList.Flink),
                ReadField(DereferenceList.Blink),
                (ULONG) ReadField(NumberOfMappedViews));

            dprintf("   SubsectionDataFlags %8x\n",
                (ULONG) ReadField(u2.LongFlags2));
        }

        SubsectionVa = ReadField(NextSubsection);
    
    } while (SubsectionVa != 0);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kdlog\driver\kdlog.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    kdlog.c

Abstract:

    Kernel Debugger logging

Author:

    Neil Sandlin

Environment:

Notes:


Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#define _NTDDK_
#include "ntos.h"      // *** USES INTERNAL DEFINES ***
#include "hal.h"
#include "kdlog.h"
#include "kdlogctl.h"




NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
KdlogDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KdlogOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KdlogClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
KdlogUnload (
    IN PDRIVER_OBJECT DriverObject
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,KdlogDeviceControl)
#pragma alloc_text(PAGE,KdlogOpen)
#pragma alloc_text(PAGE,KdlogClose)
#pragma alloc_text(PAGE,KdlogUnload)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the stat driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    ULONG i;

    KdPrint(( "KDLOG: DriverEntry()\n" ));

    //
    // Create non-exclusive device object
    //

    RtlInitUnicodeString(&unicodeString, L"\\Device\\KdLog");

    status = IoCreateDevice(
                DriverObject,
                0,
                &unicodeString,
                FILE_DEVICE_UNKNOWN,    // DeviceType
                0,
                FALSE,
                &deviceObject
                );

    if (status != STATUS_SUCCESS) {
        KdPrint(( "Kdlog - DriverEntry: unable to create device object: %X\n", status ));
        return(status);
    }

    deviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = KdlogOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = KdlogClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KdlogDeviceControl;
    DriverObject->DriverUnload = KdlogUnload;

    return(STATUS_SUCCESS);
}



NTSTATUS
KdlogDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Kdlogus is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG   BufferLength;
    PULONG  Buffer;
    PKD_DBG_LOG_CONTEXT pContext;
    ULONG DataLength;

    PAGED_CODE();
    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    status = STATUS_SUCCESS;
    try {

        Buffer = (PULONG) irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        BufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
        
            case KDLOG_QUERY_LOG_CONTEXT:
                if (BufferLength < sizeof(KD_DBG_LOG_CONTEXT)) {
                    status = STATUS_BUFFER_TOO_SMALL;
                    break;
                }
                
                status = KdGetDebuggerLogContext(&pContext);
                
                if (NT_SUCCESS(status)) {
                    RtlCopyMemory(Buffer, pContext, sizeof(KD_DBG_LOG_CONTEXT));
                }                    
                break;
        
            case KDLOG_GET_LOG_DATA:
            
                status = KdGetDebuggerLogContext(&pContext);
                
                if (!NT_SUCCESS(status)) {
                    break;
                }
                
                DataLength = pContext->EntryLength * (pContext->LastIndex + 1);
            
                if (BufferLength < DataLength) {
                    status = STATUS_BUFFER_TOO_SMALL;
                    break;
                }
                
                RtlCopyMemory(Buffer, pContext->LogData, DataLength);
                break;

            default:
                status = STATUS_INVALID_PARAMETER;
                break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }


    //
    // Request is done...
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(status);
}



NTSTATUS
KdlogOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}



NTSTATUS
KdlogClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}



VOID
KdlogUnload (
    IN PDRIVER_OBJECT DriverObject
    )

{
    PAGED_CODE();

    //
    // Delete the device object.
    //
    IoDeleteDevice(DriverObject->DeviceObject);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kernprof\pooldump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pooldump.c

Abstract:

    This module contains the implementation of the temporary routine
    to dump non-paged pool usage.

Usage:

    Set TRACE_ALLOC to 1 in pool.c and rebuild the kernel.
    When pooldump is run, the colllected pool counts are returned
    and analyzed.

Author:

    Lou Perazzoli (loup) 22-Aug-1991

Envirnoment:


    User mode, debug version of the kernel.

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
//#define DBG_PROFILE  1


NTSTATUS
LoadSymbols (
    VOID
    );

NTSTATUS
LookupSymbolNameAndLocation (
    IN ULONG CodeAddress,
    OUT PSTRING SymbolName,
    OUT PULONG OffsetFromSymbol,
    OUT PULONG ImageIndex
    );

#define PAGE_SIZE 4096

typedef struct _IMAGE_BLOCK {
    ULONG ImageBase;  //actual base where mapped locally.
    PIMAGE_DEBUG_INFO DebugInfo;
    ULONG CodeStart;
    ULONG CodeEnd;
    ULONG TextNumber;
    BOOLEAN KernelCode;
    UNICODE_STRING ImageName;
} IMAGE_BLOCK;


#define MAX_PROFILE_COUNT 30

IMAGE_BLOCK ImageInformation[MAX_PROFILE_COUNT+1];

ULONG NumberOfImages = 0;

//
// Define map data file if the produced data file should be
// a mapped file (currently named "kernprof.dat").
//

// #define MAP_DATA_FILE

//
// Define map as image if the image to be profiled should be mapped
// as an image rather than as data.
//

// #define MAP_AS_IMAGE

#define MAX_POOL_ENTRIES 1024

typedef struct _POOLUSAGE {
    ULONG Caller;
    ULONG Allocations;
    ULONG Frees;
    ULONG Usage;
} POOLUSAGE;

POOLUSAGE Buffer[MAX_POOL_ENTRIES];
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS status;
    ULONG i, Offset;
    ULONG TotalAllocs = 0;
    ULONG TotalFrees = 0;
    ULONG TotalUsage = 0;
    ULONG Start;
    STRING SymbolName;
    UCHAR String[80];
    STRING OutString;
    ULONG ImageIndex;

    RtlZeroMemory (&Buffer, MAX_POOL_ENTRIES * sizeof (POOLUSAGE));

    SymbolName.MaximumLength = 80;
    SymbolName.Buffer = String;

    status = NtPartyByNumber (PARTY_DUMP_POOL_USAGE, &Buffer);
    if (!NT_SUCCESS (status)) {
        return(status);
    }
    LoadSymbols ();

    printf("Allocs  Frees   Used      At\n");

    for (i =0; i < MAX_POOL_ENTRIES ; i++ ) {
        if (Buffer[i].Caller == 0) {
            break;
        }

        String[0] = 0;
        SymbolName.MaximumLength = 80;
          SymbolName.Length = 0;
          Offset = Buffer[i].Caller;
        LookupSymbolNameAndLocation (Buffer[i].Caller,
                                     &SymbolName,
                                     &Offset,
                                     &ImageIndex);

        RtlUnicodeStringToAnsiString(&OutString,
                                     &ImageInformation[ImageIndex].ImageName,
                                     TRUE);

        printf("%6ld %6ld %6ld %s + 0x%lx (%s)\n",
                Buffer[i].Allocations,
                Buffer[i].Frees,
                Buffer[i].Usage,
                SymbolName.Buffer,
                Offset,
                OutString.Buffer
                );

        RtlFreeAnsiString(&OutString);
        TotalAllocs += Buffer[i].Allocations;
        TotalFrees += Buffer[i].Frees;
        TotalUsage += Buffer[i].Usage;
    }


    printf("Total: allocations %ld Frees %ld  Difference (A-F) %ld Usage %ld\n",
        TotalAllocs, TotalFrees, (TotalAllocs - TotalFrees), TotalUsage);

    return(status);
}

NTSTATUS
LoadSymbols (
    VOID
    )

/*++

Routine Description:

    This routine initializes symbols for the kernel.

Arguments:

    None.

Return Value:

    Status of operations.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    HANDLE FileHandle, KernelSection;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID ImageBase;
    ULONG ViewSize;
    ULONG CodeLength;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    ULONG DebugSize;
    PVOID KernelBase;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    UCHAR StringBuf[250];
    UNICODE_STRING NameString;
    ULONG TotalOffset;
    CHAR ModuleInfo[8000];
    ULONG ReturnedLength;
    PSYSTEM_LOAD_MODULE_INFORMATION Module;
    ANSI_STRING String;
    STRING SysdiskA;
    STRING SysrootA;
    UNICODE_STRING Sysdisk;
    UNICODE_STRING Sysroot;
    PIMAGE_DEBUG_INFO KernelDebugInfo;

    CurrentProcessHandle = NtCurrentProcess();

    //
    // Locate system drivers.
    //

    status = NtQuerySystemInformation (
                    SystemLoadModuleInformation,
                    ModuleInfo,
                    8000,
                    &ReturnedLength);

    if (!NT_SUCCESS(status)) {
        printf("query system info failed status - %lx\n",status);
        return(status);
    }

    RtlInitString (&SysdiskA,"\\SystemRoot");
    RtlAnsiStringToUnicodeString (&Sysdisk, (PANSI_STRING)&SysdiskA, TRUE);

    RtlInitString (&SysrootA,"\\SystemRoot\\Driver\\");
    RtlAnsiStringToUnicodeString (&Sysroot, (PANSI_STRING)&SysrootA, TRUE);

    NameString.Buffer = &StringBuf[0];
    NameString.Length = 0;
    NameString.MaximumLength = 250;

    Module = &ModuleInfo[0];
    TotalOffset = 0;
    while (TRUE) {

#if DBG_PROFILE
        printf("module base %lx\n",Module->BaseAddress);
        printf("module dll buffer address %lx %lx %lx\n",
                Module->ModuleDllName.Buffer,
                Module->ModuleFileName.Buffer, Module);
        RtlUnicodeStringToAnsiString(&String, &Module->ModuleDllName, TRUE);
        printf("module dll name %s\n",String.Buffer);
        RtlUnicodeStringToAnsiString(&String, &Module->ModuleFileName, TRUE);
        printf("module file name %s\n",String.Buffer);
#endif

        if ( Module->ModuleFileName.Buffer[0] == (WCHAR) '\\' ) {
            Module->ModuleFileName.Buffer++;
            Module->ModuleFileName.Length -= sizeof(WCHAR);
            Module->ModuleFileName.MaximumLength -= sizeof(WCHAR);
            while (Module->ModuleFileName.Buffer[0] != (WCHAR) '\\' ) {
                Module->ModuleFileName.Buffer++;
                Module->ModuleFileName.Length -= sizeof(WCHAR);
                Module->ModuleFileName.MaximumLength -= sizeof(WCHAR);
                }
            }

        NameString.Length = 0;
        status = RtlAppendStringToString (&NameString, (PSTRING)&Sysdisk);
        if (!NT_SUCCESS(status)) {
            printf("append string failed status - %lx\n",status);
            return(status);
        }

        status = RtlAppendStringToString (&NameString, (PSTRING)&Module->ModuleFileName);

        if (!NT_SUCCESS(status)) {
            printf("append string failed status - %lx\n",status);
            return(status);
        }

        InitializeObjectAttributes( &ObjectAttributes,
                                    &NameString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        //
        // Open the file as readable and executable.
        //

#if DBG_PROFILE
        RtlUnicodeStringToAnsiString(&String, &NameString, TRUE);
        printf("Opening file name %s\n",String.Buffer);
#endif

        status = NtOpenFile ( &FileHandle,
                              FILE_READ_DATA | FILE_EXECUTE,
                              &ObjectAttributes,
                              &IoStatus,
                              FILE_SHARE_READ,
                              0L);

        if (!NT_SUCCESS(status)) {

            //
            // Try a different name - in SystemRoot\Driver directory.
            //

            NameString.Length = 0;
            status = RtlAppendStringToString (&NameString, &Sysroot);
            if (!NT_SUCCESS(status)) {
                printf("append string failed status - %lx\n",status);
                return(status);
            }

            status = RtlAppendStringToString (&NameString, &Module->ModuleFileName);

            if (!NT_SUCCESS(status)) {
                printf("append string failed status - %lx\n",status);
                return(status);
            }

            InitializeObjectAttributes( &ObjectAttributes,
                                        &NameString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );

            //
            // Open the file as readable and executable.
            //

#if DBG_PROFILE
            RtlUnicodeStringToAnsiString(&String, &NameString, TRUE);
            printf("Opening file name %s\n",String.Buffer);
#endif
            status = NtOpenFile ( &FileHandle,
                                  FILE_READ_DATA,
                                  &ObjectAttributes,
                                  &IoStatus,
                                  FILE_SHARE_READ,
                                  0L);

            if (!NT_SUCCESS(status)) {
                RtlUnicodeStringToAnsiString(&String, &NameString, TRUE);
                DbgPrint("open file %s failed status %lx\n",
                          String.Buffer, status);
                return(status);
            }
        }

        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

        //
        // For normal images they would be mapped as an image, but
        // the kernel has no debug section (as yet) information, hence it
        // must be mapped as a file.
        //

        status = NtCreateSection (&KernelSection,
                                  SECTION_MAP_READ,
                                  &ObjectAttributes,
                                  0,
                                  PAGE_READONLY,
                                  SEC_COMMIT,
                                  FileHandle);

        if (!NT_SUCCESS(status)) {
            DbgPrint("create image section failed  status %lx\n", status);
            return(status);
        }

        ViewSize = 0;

        //
        // Map a view of the section into the address space.
        //

        KernelBase = NULL;

        status = NtMapViewOfSection (KernelSection,
                                     CurrentProcessHandle,
                                     &KernelBase,
                                     0L,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READONLY);

        if (!NT_SUCCESS(status)) {
            if (status != STATUS_IMAGE_NOT_AT_BASE) {
                DbgPrint("map section status %lx base %lx size %lx\n", status,
                    (ULONG)KernelBase, ViewSize);
            }
        }

        ImageBase = Module->BaseAddress;

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)RtlImageDirectoryEntryToData(
                    KernelBase, FALSE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);

        //printf("Mapped base %lx Debug dir %lx\n", (ULONG)KernelBase, DebugDirectory);

        if (!DebugDirectory) {
            DbgPrint("InitializeKernelProfile : No debug directory\n");
            return STATUS_INVALID_IMAGE_FORMAT;
        }


        KernelDebugInfo = (PIMAGE_DEBUG_INFO)((ULONG)KernelBase + DebugDirectory->PointerToRawData);
        CodeLength = KernelDebugInfo->RvaToLastByteOfCode - KernelDebugInfo->RvaToFirstByteOfCode;

        ImageInformation[NumberOfImages].KernelCode = TRUE;
        ImageInformation[NumberOfImages].DebugInfo = KernelDebugInfo;
        ImageInformation[NumberOfImages].CodeStart = ((ULONG)ImageBase +
                                        KernelDebugInfo->RvaToFirstByteOfCode);
        ImageInformation[NumberOfImages].CodeEnd =
                        ImageInformation[NumberOfImages].CodeStart + CodeLength;
        ImageInformation[NumberOfImages].TextNumber = 1;
        ImageInformation[NumberOfImages].ImageBase = ImageBase;
        ImageInformation[NumberOfImages].ImageName = Module->ModuleDllName;

        NumberOfImages += 1;
        if (NumberOfImages == MAX_PROFILE_COUNT) {
            return STATUS_SUCCESS;
        }

        if (Module->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += Module->NextEntryOffset;
        Module = (PSYSTEM_LOAD_MODULE_INFORMATION)&ModuleInfo[TotalOffset];
    }
    return status;
}


NTSTATUS
LookupSymbolNameAndLocation (
    IN ULONG CodeAddress,
    OUT PSTRING SymbolName,
    OUT PULONG OffsetFromSymbol,
    OUT PULONG ImageIndex
    )

/*++

Routine Description:

    Given a code address, this routine returns the nearest symbol
    name and the offset from the symbol to that name.  If the
    nearest symbol is not within 100k of the location, no name
    is returned and the offset is the value of the CodeAddress.

Arguments:

    CodeAddress - Supplies the address to lookup a symbol for.

    SymbolName - Returns the name of the symbol.

    OffsetFromSymbol - Returns the offset from the symbol to the
                       code address.

Return Value:

    Status of operations.

--*/

{

    ULONG j, nextSymbol, imageNumber;
    ULONG NewCodeAddress;
    IMAGE_SYMBOL PreviousSymbol;
    PIMAGE_DEBUG_INFO DebugInfo;
    PIMAGE_SYMBOL SymbolEntry;
    IMAGE_SYMBOL Symbol;
    PUCHAR StringTable;
    ULONG EightChar[3];
    BOOLEAN NoSymbols;

    for (imageNumber = 0; imageNumber < NumberOfImages; imageNumber++) {
        if ((CodeAddress >= ImageInformation[imageNumber].ImageBase) &&
           (CodeAddress <= ImageInformation[imageNumber].CodeEnd)) {
            break;
        }
    }
    *ImageIndex = imageNumber;

    if (imageNumber == NumberOfImages) {

        //
        // Address not found.
        //

        SymbolName->Length = 0;
        *OffsetFromSymbol = CodeAddress;
        return STATUS_SUCCESS;
    }

    NewCodeAddress = CodeAddress - ImageInformation[imageNumber].ImageBase;

    //
    // Locate debug section.
    //

    DebugInfo = ImageInformation[imageNumber].DebugInfo;

    //
    // Crack the symbol table.
    //

    SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
    StringTable = (PUCHAR)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol +
                                DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);

    //
    // Find the "header" symbol (skipping all the section names)
    //

    nextSymbol = 0;
//    printf("number of symbols %ld\n", DebugInfo->NumberOfSymbols);
    for (j = 0; j < DebugInfo->NumberOfSymbols; j++) {
        EightChar[0] = SymbolEntry->N.Name.Short;
        EightChar[1] = SymbolEntry->N.Name.Long;
        if (!strcmp((PSZ)&EightChar[0], "header")) {
            nextSymbol = j;
//            printf("found header at %ld\n",j);
            break;
        }
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                        IMAGE_SIZEOF_SYMBOL);
    }
    if (j >= DebugInfo->NumberOfSymbols) {
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
    }

    NoSymbols = TRUE;

    //
    // Loop through all symbols in the symbol table.  For each symbol,
    // if it is within the code section, subtract off the bias and
    // see if there are any hits within the profile buffer for
    // that symbol.
    //

//    printf("number of symbols %ld\n", DebugInfo->NumberOfSymbols);
    for (j = nextSymbol; j < DebugInfo->NumberOfSymbols; j++) {


        try {
//                printf("numberof aux symbols %ld\n",SymbolEntry->NumberOfAuxSymbols );
            while ( SymbolEntry->NumberOfAuxSymbols ) {
                j = j + 1 + SymbolEntry->NumberOfAuxSymbols;
                SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                                IMAGE_SIZEOF_SYMBOL +
                                SymbolEntry->NumberOfAuxSymbols*IMAGE_SIZEOF_SYMBOL);

            }
            RtlMoveMemory (&Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            printf("breaking excpt\n");
            break;
        }

//            printf("value %lx number %lx start %lx\n",Symbol.Value,Symbol.SectionNumber,CodeAddress);
        if (Symbol.SectionNumber == (SHORT)1) {

            //
            // This symbol is within the code.
            //

            if (Symbol.Value < NewCodeAddress) {
                PreviousSymbol = Symbol;
                NoSymbols = FALSE;
            } else {
                break;
            }
        }
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                                                    IMAGE_SIZEOF_SYMBOL);

    }

    if ((NoSymbols) || (NewCodeAddress - PreviousSymbol.Value) > 0x100000) {

      SymbolName->Length = 0;
      *OffsetFromSymbol = CodeAddress;
    } else {
        if (PreviousSymbol.N.Name.Short) {
            SymbolName->Length = 8;
            if (SymbolName->Length > SymbolName->MaximumLength) {
                SymbolName->Length = SymbolName->MaximumLength;
            }

            EightChar[0] = PreviousSymbol.N.Name.Short;
            EightChar[1] = PreviousSymbol.N.Name.Long;
            RtlMoveMemory (SymbolName->Buffer, EightChar, SymbolName->Length);

        } else {
            SymbolName->Length =
                    strlen(&StringTable[PreviousSymbol.N.Name.Long] ) + 1;
            if (SymbolName->Length > SymbolName->MaximumLength) {
                SymbolName->Length = SymbolName->MaximumLength;
            }
            RtlMoveMemory (SymbolName->Buffer,
                           &StringTable[PreviousSymbol.N.Name.Long],
                           SymbolName->Length);
            SymbolName->Buffer[SymbolName->Length] = 0;
        }
        *OffsetFromSymbol = NewCodeAddress - PreviousSymbol.Value;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kernprof\kernprof.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   kernprof.c

Abstract:

    This module contains the implementation of a kernel profiler.

    It uses dbghelp for symbols and image information and
    creates profile objects for each modules it finds loaded
    when it starts.

Usage:
        See below

Author:

    Lou Perazzoli (loup) 29-Sep-1990

Envirnoment:



Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <..\pperf\pstat.h>


#define SYM_HANDLE INVALID_HANDLE_VALUE
#define DBG_PROFILE 0
#define MAX_BYTE_PER_LINE  72
#define MAX_PROFILE_COUNT  100
#define MAX_BUCKET_SHIFT 31        // 2GBytes
#define MAX_BUCKET_SIZE 0x80000000U

typedef struct _PROFILE_BLOCK {
    HANDLE      Handle[MAXIMUM_PROCESSORS];
    PVOID       ImageBase;
    PULONG      CodeStart;
    SIZE_T      CodeLength;
    PULONG      Buffer[MAXIMUM_PROCESSORS];
    ULONG       BufferSize;
    ULONG       BucketSize;
    LPSTR       ModuleName;
    ULONG       ModuleHitCount[MAXIMUM_PROCESSORS];
    BOOLEAN     SymbolsLoaded;
} PROFILE_BLOCK;

//
// This really should go into a header file but....
//
typedef struct _PROFILE_CONTROL_BLOCK {
        BOOLEAN Stop;
        char FileName[MAX_PATH];
} PROFILE_CONTROL_BLOCK;
typedef PROFILE_CONTROL_BLOCK * PPROFILE_CONTROL_BLOCK;
#define PRFEVENT_START_EVENT "PrfEventStartedEvent"
#define PRFEVENT_STOP_EVENT "PrfEventStopEvent"
#define PRFEVENT_SHARED_MEMORY "PrfEventSharedMemory"
//
// End header file
//

#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL ThisSymbol = (PIMAGEHLP_SYMBOL) symBuffer;

CHAR LastSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL LastSymbol = (PIMAGEHLP_SYMBOL) LastSymBuffer;



VOID
InitializeProfileSourceMapping (
    VOID
    );

NTSTATUS
InitializeKernelProfile(
    VOID
    );

NTSTATUS
RunEventLoop(
    VOID
    );

NTSTATUS
RunStdProfile(
    VOID
    );

NTSTATUS
StartProfile(
    VOID
    );

NTSTATUS
StopProfile(
    VOID
    );

NTSTATUS
AnalyzeProfile(
    ULONG Threshold,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StartContext,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StopContext
    );

VOID
OutputSymbolCount(
    IN ULONG CountAtSymbol,
    IN ULONG TotalCount,
    IN PROFILE_BLOCK *ProfileObject,
    IN PIMAGEHLP_SYMBOL SymbolInfo,
    IN ULONG Threshold,
    IN PULONG CounterStart,
    IN PULONG CounterStop,
    IN ULONG Va,
    IN ULONG BytesPerBucket
    );

#ifdef _ALPHA_
#define PAGE_SIZE 8192
#else
#define PAGE_SIZE 4096
#endif


FILE *fpOut = NULL;

PROFILE_BLOCK ProfileObject[MAX_PROFILE_COUNT];
DWORD *UserModeBuffer[MAXIMUM_PROCESSORS];

ULONG NumberOfProfileObjects = 0;
ULONG MaxProcessors = 1;
ULONG ProfileInterval = 10000;

CHAR SymbolSearchPathBuf[4096];
LPSTR lpSymbolSearchPath = SymbolSearchPathBuf;

// display flags
BOOLEAN    bDisplayAddress=FALSE;
BOOLEAN    bDisplayDensity=FALSE;
BOOLEAN    bDisplayCounters=FALSE;
BOOLEAN    bDisplayContextSwitch=FALSE;
BOOLEAN    bPerProcessor = FALSE;
BOOLEAN    bWaitForInput = FALSE;
BOOLEAN    bEventLoop = FALSE;
BOOLEAN    bPrintPercentages = FALSE;
BOOLEAN    Verbose = FALSE;

//
// Image name to perform kernel mode analysis upon.
//

#define IMAGE_NAME "\\SystemRoot\\system32\\ntoskrnl.exe"

HANDLE DoneEvent;
HANDLE DelayEvent;

KPROFILE_SOURCE ProfileSource = ProfileTime;
ULONG Seconds = (ULONG)-1;
ULONG Threshold = 100;
ULONG DelaySeconds = (ULONG)-1;

//
// define the mappings between arguments and KPROFILE_SOURCE types
//

typedef struct _PROFILE_SOURCE_MAPPING {
    PCHAR   ShortName;
    PCHAR   Description;
    KPROFILE_SOURCE Source;
} PROFILE_SOURCE_MAPPING, *PPROFILE_SOURCE_MAPPING;

#if defined(_ALPHA_)

PROFILE_SOURCE_MAPPING ProfileSourceMapping[] = {
    {"align", "", ProfileAlignmentFixup},
    {"totalissues", "", ProfileTotalIssues},
    {"pipelinedry", "", ProfilePipelineDry},
    {"loadinstructions", "", ProfileLoadInstructions},
    {"pipelinefrozen", "", ProfilePipelineFrozen},
    {"branchinstructions", "", ProfileBranchInstructions},
    {"totalnonissues", "", ProfileTotalNonissues},
    {"dcachemisses", "", ProfileDcacheMisses},
    {"icachemisses", "", ProfileIcacheMisses},
    {"branchmispredicts", "", ProfileBranchMispredictions},
    {"storeinstructions", "", ProfileStoreInstructions},
    {NULL,0}
    };

#elif defined(_X86_)

PPROFILE_SOURCE_MAPPING ProfileSourceMapping;

#else

PROFILE_SOURCE_MAPPING ProfileSourceMapping[] = {
    {NULL,0}
    };
#endif

BOOL
CtrlcH(
    DWORD dwCtrlType
    )
{
    if ( dwCtrlType == CTRL_C_EVENT ) {
        SetEvent(DoneEvent);
        return TRUE;
        }
    return FALSE;
}

void PrintUsage (void)
{
    fputs ("Kernel Profiler Usage:\n\n"
           "Kernprof [-acdpnrx] [-w <wait time>] [-s Source] [-t <low threshold>] [<sample time>]\n"
           "      -a           - display function address and length and bucket size\n"
           "      -c           - display individual counters\n"
           "      -d           - compute hit Density for each function\n"
//UNDOC    "      -e                 - use special event syncronization for start and stop\n"
           "      -f filename  - output file (Default stdout)\n"
           "      -i <interval in 100ns> (Default 10000)\n"
           "      -n           - print hit percentages\n"
           "      -p           - Per-processor profile objects\n"
           "      -r           - wait for a <RETURN> before starting collection\n"
           "      -s Source    - use Source instead of clock as profile source\n"
           "                     ? lists Sources\n"
           "      -t <low threshold> - Minimum number of counts to report.\n"
           "                     Defaults is 100\n"
           "      -v           - Display verbose symbol information\n"
           "      -w           - wait for <wait time> before starting collection\n"
           "      -x           - display context switch counters\n"
           "   <sample time>   - Specify, in seconds, how long to collect\n"
           "                     profile information.\n"
           "                     Default is wait until Ctrl-C\n\n"
#if defined (_ALPHA_)
           "Currently supported profile sources are 'align', 'totalissues', 'pipelinedry'\n"
           "  'loadinstructions', 'pipelinefrozen', 'branchinstructions', 'totalnonissues',\n"
           "  'dcachemisses', 'icachemisses', 'branchmispredicts', 'storeinstructions'\n"
#endif
            , stderr);
}

__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    int j;
    NTSTATUS status;
    PPROFILE_SOURCE_MAPPING ProfileMapping;
    SYSTEM_INFO SystemInfo;

    fpOut = stdout;

    ThisSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    ThisSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
    LastSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    LastSymbol->MaxNameLength = MAX_SYMNAME_SIZE;

    SymSetOptions( SYMOPT_UNDNAME | SYMOPT_CASE_INSENSITIVE | SYMOPT_OMAP_FIND_NEAREST );
    SymInitialize( SYM_HANDLE, NULL, FALSE );
    SymGetSearchPath( SYM_HANDLE, SymbolSearchPathBuf, sizeof(SymbolSearchPathBuf) );

    //
    // Parse the input string.
    //

    DoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (argc > 1) {
        if (((argv[1][0] == '-') || (argv[1][0] == '/')) &&
            ((argv[1][1] == '?' ) ||
             (argv[1][1] == 'H') ||
             (argv[1][1] == 'H'))
            ) {

            PrintUsage();
            return ERROR_SUCCESS;
        }

        for (j = 1; j < argc; j++) {

            BOOLEAN NextArg;
            char *p;

            if (argv[j][0] == '-') {

                NextArg = FALSE;

                for (p = &argv[j][1] ; *p && !NextArg ; p++) {
                    switch (toupper(*p)) {
                        case 'A':
                            bDisplayAddress = TRUE;
                            break;

                        case 'C':
                            bDisplayCounters = TRUE;
                            break;

                        case 'D':
                            bDisplayDensity = TRUE;
                            break;

                        case 'E':
                            bEventLoop = TRUE;
                            break;

                        case 'F':
                            NextArg = TRUE;
                            fpOut = fopen(argv[++j], "w");
                            break;

                        case 'I':
                            NextArg = TRUE;
                            ProfileInterval = atoi(argv[++j]);
                            break;

                        case 'N':
                            bPrintPercentages = TRUE;
                            break;

                        case 'P':
                            GetSystemInfo(&SystemInfo);
                            MaxProcessors = SystemInfo.dwNumberOfProcessors;
                            bPerProcessor = TRUE;
                            break;

                        case 'R':
                            bWaitForInput = TRUE;
                            break;

                        case 'S':
                            NextArg = TRUE;
                            if (!ProfileSourceMapping) {
                                InitializeProfileSourceMapping();
                            }

                            if (!argv[j+1]) {
                                break;
                            }

                            if (argv[j+1][0] == '?') {
                                ProfileMapping = ProfileSourceMapping;
                                if (ProfileMapping) {
                                    fprintf (stderr, "kernprof: profile sources\n");
                                    while (ProfileMapping->ShortName != NULL) {
                                        fprintf (stderr, "  %-10s %s\n",
                                            ProfileMapping->ShortName,
                                            ProfileMapping->Description
                                            );
                                        ++ProfileMapping;
                                    }
                                } else {
                                    fprintf (stderr, "kernprof: no alternative profile sources\n");
                                }
                                return 0;
                            }

                            ProfileMapping = ProfileSourceMapping;
                            if (ProfileMapping) {
                                while (ProfileMapping->ShortName != NULL) {
                                    if (_stricmp(ProfileMapping->ShortName, argv[j+1])==0) {
                                        ProfileSource = ProfileMapping->Source;
                                        fprintf (stderr, "ProfileSource %x\n", ProfileMapping->Source);
                                        ++j;
                                        break;
                                    }
                                    ++ProfileMapping;
                                }
                            }
                            break;

                        case 'T':
                            NextArg = TRUE;
                            Threshold = atoi(argv[++j]);
                            break;

                        case 'V':
                            Verbose = TRUE;
                            break;

                        case 'W':
                            NextArg = TRUE;
                            DelaySeconds = atoi(argv[++j]);
                            DelayEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
                            break;

                        case 'X':
                            bDisplayContextSwitch = TRUE;
                            break;
                    }
                }
            } else {
                Seconds = atoi(argv[j]);
            }
        }
    }

    if (bEventLoop || (DelaySeconds != -1)) {
        SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    }

    status = InitializeKernelProfile ();
    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "initialize failed status - %lx\n",status);
        return(status);
    }

    if (bEventLoop)
        RunEventLoop();
    else
        RunStdProfile();

    return STATUS_SUCCESS;
}

NTSTATUS
RunEventLoop()
{
    NTSTATUS status;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StartContext;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StopContext;
    HANDLE hStartedEvent = NULL;
    HANDLE hStopEvent = NULL;
    HANDLE hMap = NULL;
    PPROFILE_CONTROL_BLOCK pShared = NULL;

    // Create the events and shared memory
    hStartedEvent = CreateEvent (NULL, FALSE, FALSE, PRFEVENT_START_EVENT);
    if (hStartedEvent == NULL) {
        fprintf(stderr, "Failed to create started event - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }
    hStopEvent = CreateEvent (NULL, FALSE, FALSE, PRFEVENT_STOP_EVENT);
    if (hStopEvent == NULL) {
        fprintf(stderr, "Failed to create stop event - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }
    hMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT,
                                    0, sizeof(PROFILE_CONTROL_BLOCK),
                                    PRFEVENT_SHARED_MEMORY);
    if (hMap == NULL) {
        fprintf(stderr, "Failed to create the file mapping - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }
    pShared = (PPROFILE_CONTROL_BLOCK) MapViewOfFile(hMap, FILE_MAP_WRITE,
                                                0,0, sizeof(PROFILE_CONTROL_BLOCK));
    if (pShared == NULL) {
        fprintf(stderr, "Failed to map the shared memory view - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }

    // Wait for start i.e., the stop event
    WaitForSingleObject(hStopEvent, INFINITE);

    while (TRUE) {
        if (bDisplayContextSwitch) {
            NtQuerySystemInformation(SystemContextSwitchInformation,
                                 &StartContext,
                                 sizeof(StartContext),
                                 NULL);
        }

        status = StartProfile ();
        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "start profile failed status - %lx\n",status);
            break;
        }

        // Signal started
        SetEvent(hStartedEvent);
        // Wait for stop
        WaitForSingleObject(hStopEvent, INFINITE);

        status = StopProfile ();
        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "stop profile failed status - %lx\n",status);
            break;
        }

        if (bDisplayContextSwitch) {
            status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                          &StopContext,
                                          sizeof(StopContext),
                                          NULL);
            if (!NT_SUCCESS(status)) {
                fprintf(stderr, "QuerySystemInformation for context switch information failed %08lx\n",status);
                bDisplayContextSwitch = FALSE;
            }
        }

        fpOut = fopen(pShared->FileName, "w");
        status = AnalyzeProfile (Threshold, &StartContext, &StopContext);
        fclose(fpOut);

        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "analyze profile failed status - %lx\n",status);
        }

        if (pShared->Stop == TRUE)
            break;
    }

    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    UnmapViewOfFile((void*)pShared);
    CloseHandle(hMap);
    CloseHandle(hStopEvent);
    CloseHandle(hStartedEvent);
    return(status);
}


NTSTATUS
RunStdProfile()
{
    NTSTATUS status;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StartContext;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StopContext;

    SetConsoleCtrlHandler(CtrlcH,TRUE);

    if (DelaySeconds != -1) {
        fprintf(stderr, "starting profile after %d seconds\n",DelaySeconds);
        WaitForSingleObject(DelayEvent, DelaySeconds*1000);
    }

    if (bDisplayContextSwitch) {
        NtQuerySystemInformation(SystemContextSwitchInformation,
                                 &StartContext,
                                 sizeof(StartContext),
                                 NULL);
    }

    status = StartProfile ();
    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "start profile failed status - %lx\n",status);
        return(status);
    }

    if ( Seconds == -1 ) {
        fprintf(stderr, "delaying until ^C\n");
    } else {
        fprintf(stderr, "delaying for %ld seconds... "
                        "report on values with %ld hits\n",
                        Seconds,
                        Threshold
                        );
    }

    if ( Seconds ) {
        if ( Seconds != -1 ) {
            Seconds = Seconds * 1000;
        }
        if ( DoneEvent ) {
            WaitForSingleObject(DoneEvent,Seconds);
        }
        else {
            Sleep(Seconds);
        }
    }
    else {
        getchar();
    }

    fprintf (stderr, "end of delay\n");

    status = StopProfile ();
    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "stop profile failed status - %lx\n",status);
        return(status);
    }

    SetConsoleCtrlHandler(CtrlcH,FALSE);

    if (bDisplayContextSwitch) {
        status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                          &StopContext,
                                          sizeof(StopContext),
                                          NULL);
        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "QuerySystemInformation for context switch information failed %08lx\n",status);
            bDisplayContextSwitch = FALSE;
        }
    }

    if (DelaySeconds != -1) {
        SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    }
    status = AnalyzeProfile (Threshold, &StartContext, &StopContext);

    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "analyze profile failed status - %lx\n",status);
    }

    return(status);
}


VOID
InitializeProfileSourceMapping (
    VOID
    )
{
#if defined(_X86_)
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       buffer[400];
    ULONG                       i, j, Count;
    PEVENTID                    Event;
    HANDLE                      DriverHandle;

    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        return ;
    }

    //
    // Initialize possible counters
    //

    // determine how many events there are

    Event = (PEVENTID) buffer;
    Count = 0;
    do {
        *((PULONG) buffer) = Count;
        Count += 1;

        status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    PSTAT_QUERY_EVENTS,
                    buffer,                 // input buffer
                    sizeof (buffer),
                    NULL,                   // output buffer
                    0
                    );
    } while (NT_SUCCESS(status));

    ProfileSourceMapping = malloc(sizeof(*ProfileSourceMapping) * Count);
    Count -= 1;
    for (i=0, j=0; i < Count; i++) {
        *((PULONG) buffer) = i;
        NtDeviceIoControlFile(
           DriverHandle,
           (HANDLE) NULL,          // event
           (PIO_APC_ROUTINE) NULL,
           (PVOID) NULL,
           &IOSB,
           PSTAT_QUERY_EVENTS,
           buffer,                 // input buffer
           sizeof (buffer),
           NULL,                   // output buffer
           0
           );

        if (Event->ProfileSource > ProfileTime) {
            ProfileSourceMapping[j].Source      = Event->ProfileSource;
            ProfileSourceMapping[j].ShortName   = _strdup (Event->Buffer);
            ProfileSourceMapping[j].Description = _strdup (Event->Buffer + Event->DescriptionOffset);
            j++;
        }
    }

    ProfileSourceMapping[j].Source      = (KPROFILE_SOURCE) 0;
    ProfileSourceMapping[j].ShortName   = NULL;
    ProfileSourceMapping[j].Description = NULL;

    NtClose (DriverHandle);
#endif
}


NTSTATUS
InitializeKernelProfile (
    VOID
    )

/*++

Routine Description:

    This routine initializes profiling for the kernel for the
    current process.

Arguments:

    None.

Return Value:

    Returns the status of the last NtCreateProfile.

--*/

{
    ULONG i;
    ULONG ModuleNumber;
    SIZE_T ViewSize;
    PULONG CodeStart;
    ULONG CodeLength;
    NTSTATUS LocalStatus;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    QUOTA_LIMITS QuotaLimits;
    PVOID Buffer;
    DWORD Cells;
    ULONG BucketSize;
    WCHAR StringBuf[500];
    PCHAR ModuleInfoBuffer;
    ULONG ModuleInfoBufferLength;
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    UNICODE_STRING Sysdisk;
    UNICODE_STRING Sysroot;
    UNICODE_STRING Sysdll;
    UNICODE_STRING NameString;
    BOOLEAN PreviousProfilePrivState;
    BOOLEAN PreviousQuotaPrivState;
    CHAR ImageName[256];
    HANDLE hFile;
    HANDLE hMap;
    PVOID MappedBase;
    PIMAGE_NT_HEADERS NtHeaders;


    CurrentProcessHandle = NtCurrentProcess();

    //
    // Locate system drivers.
    //
    ModuleInfoBufferLength = 0;
    ModuleInfoBuffer = NULL;
    while (1) {
        status = NtQuerySystemInformation (SystemModuleInformation,
                                           ModuleInfoBuffer,
                                           ModuleInfoBufferLength,
                                           &ReturnedLength);
        if (NT_SUCCESS (status)) {
            break;
        }

        if (ModuleInfoBuffer != NULL) {
            RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
        }

        if (status == STATUS_INFO_LENGTH_MISMATCH && ReturnedLength > ModuleInfoBufferLength) {
            ModuleInfoBufferLength = ReturnedLength;            
            ModuleInfoBuffer = RtlAllocateHeap (RtlProcessHeap(), 0, ModuleInfoBufferLength);
            if (ModuleInfoBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else if (!NT_SUCCESS(status)) {
            fprintf(stderr, "query system info failed status - %lx\n",status);
            return(status);
        }
    }

    RtlInitUnicodeString (&Sysdisk,L"\\SystemRoot\\");
    RtlInitUnicodeString (&Sysroot,L"\\SystemRoot\\System32\\Drivers\\");
    RtlInitUnicodeString (&Sysdll, L"\\SystemRoot\\System32\\");

    NameString.Buffer = StringBuf;
    NameString.Length = 0;
    NameString.MaximumLength = sizeof( StringBuf );

    status = RtlAdjustPrivilege(
                 SE_SYSTEM_PROFILE_PRIVILEGE,
                 TRUE,              //Enable
                 FALSE,             //not impersonating
                 &PreviousProfilePrivState
                 );

    if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
        fprintf(stderr, "Enable system profile privilege failed - status 0x%lx\n",
                        status);
    }

    status = RtlAdjustPrivilege(
                 SE_INCREASE_QUOTA_PRIVILEGE,
                 TRUE,              //Enable
                 FALSE,             //not impersonating
                 &PreviousQuotaPrivState
                 );

    if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
        fprintf(stderr, "Unable to increase quota privilege (status=0x%lx)\n",
                        status);
    }


    Modules = (PRTL_PROCESS_MODULES)ModuleInfoBuffer;
    Module = &Modules->Modules[ 0 ];
    for (ModuleNumber=0; ModuleNumber < Modules->NumberOfModules; ModuleNumber++,Module++) {

#if DBG_PROFILE
        fprintf(stderr, "module base %p\n",Module->ImageBase);
        fprintf(stderr, "module full path name: %s (%u)\n",
                Module->FullPathName,
                Module->OffsetToFileName);
#endif

        if (SymLoadModule(
                SYM_HANDLE,
                NULL,
                &Module->FullPathName[Module->OffsetToFileName],
                NULL,
                (ULONG_PTR)Module->ImageBase,
                Module->ImageSize
                )) {
            ProfileObject[NumberOfProfileObjects].SymbolsLoaded = TRUE;
            if (Verbose) {
                fprintf(stderr, "Symbols loaded: %p  %s\n",
                    Module->ImageBase,
                    &Module->FullPathName[Module->OffsetToFileName]
                    );
            }
        } else {
            ProfileObject[NumberOfProfileObjects].SymbolsLoaded = FALSE;
            if (Verbose) {
                fprintf(stderr, "*** Could not load symbols: %p  %s\n",
                    Module->ImageBase,
                    &Module->FullPathName[Module->OffsetToFileName]
                    );
            }
        }

        hFile = FindExecutableImage(
            &Module->FullPathName[Module->OffsetToFileName],
            lpSymbolSearchPath,
            ImageName
            );

        if (!hFile) {
            continue;
        }

        hMap = CreateFileMapping(
            hFile,
            NULL,
            PAGE_READONLY,
            0,
            0,
            NULL
            );
        if (!hMap) {
            CloseHandle( hFile );
            continue;
        }

        MappedBase = MapViewOfFile(
            hMap,
            FILE_MAP_READ,
            0,
            0,
            0
            );
        if (!MappedBase) {
            CloseHandle( hMap );
            CloseHandle( hFile );
            continue;
        }

        NtHeaders = ImageNtHeader( MappedBase );

        CodeLength = NtHeaders->OptionalHeader.SizeOfImage;

        CodeStart = (PULONG)Module->ImageBase;

        UnmapViewOfFile( MappedBase );
        CloseHandle( hMap );
        CloseHandle( hFile );

        if (CodeLength > 1024*512) {

            //
            // Just create a 512K byte buffer.
            //

            ViewSize = 1024 * 512;

        } else {
            ViewSize = CodeLength + PAGE_SIZE;
        }

        ProfileObject[NumberOfProfileObjects].CodeStart = CodeStart;
        ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;
        ProfileObject[NumberOfProfileObjects].ImageBase = Module->ImageBase;
        ProfileObject[NumberOfProfileObjects].ModuleName = _strdup(&Module->FullPathName[Module->OffsetToFileName]);

        for (i=0; i<MaxProcessors; i++) {

            Buffer = NULL;

            status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&Buffer,
                                              0,
                                              &ViewSize,
                                              MEM_RESERVE | MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(status)) {
                fprintf (stderr, "alloc VM failed %lx\n",status);
                RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
                return(status);
            }

            //
            // Calculate the bucket size for the profile.
            //

            Cells = (DWORD)((CodeLength / (ViewSize >> 2)) >> 2);
            BucketSize = 2;

            while (Cells != 0) {
                Cells = Cells >> 1;
                BucketSize += 1;
            }

            ProfileObject[NumberOfProfileObjects].Buffer[i] = Buffer;
            ProfileObject[NumberOfProfileObjects].BufferSize = 1 + (CodeLength >> (BucketSize - 2));
            ProfileObject[NumberOfProfileObjects].BucketSize = BucketSize;

            //
            // Increase the working set to lock down a bigger buffer.
            //

            status = NtQueryInformationProcess (CurrentProcessHandle,
                                                ProcessQuotaLimits,
                                                &QuotaLimits,
                                                sizeof(QUOTA_LIMITS),
                                                NULL );

            if (!NT_SUCCESS(status)) {
                fprintf (stderr, "query process info failed %lx\n",status);
                RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
                return(status);
            }

            QuotaLimits.MaximumWorkingSetSize += ViewSize;
            QuotaLimits.MinimumWorkingSetSize += ViewSize;

            status = NtSetInformationProcess (CurrentProcessHandle,
                                          ProcessQuotaLimits,
                                          &QuotaLimits,
                                          sizeof(QUOTA_LIMITS));

#if DBG_PROFILE
            fprintf(stderr, "code start %p len %p, bucksize %lx buffer %p bsize %08x\n",
                ProfileObject[NumberOfProfileObjects].CodeStart,
                ProfileObject[NumberOfProfileObjects].CodeLength,
                ProfileObject[NumberOfProfileObjects].BucketSize,
                ProfileObject[NumberOfProfileObjects].Buffer ,
                ProfileObject[NumberOfProfileObjects].BufferSize);
#endif

            if (bPerProcessor) {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            1 << i);
            } else {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            (KAFFINITY)-1);
            }

            if (status != STATUS_SUCCESS) {
                fprintf(stderr, "create kernel profile %s failed - status %lx\n",
                    ProfileObject[NumberOfProfileObjects].ModuleName, status);
            }

        }

        NumberOfProfileObjects += 1;
        if (NumberOfProfileObjects == MAX_PROFILE_COUNT) {
            RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
            return STATUS_SUCCESS;
        }
    }

    if (NumberOfProfileObjects < MAX_PROFILE_COUNT) {
        //
        // Add in usermode object
        //      0x00000000 -> SystemRangeStart
        //
        ULONG_PTR SystemRangeStart;
        ULONG UserModeBucketCount;

        status = NtQuerySystemInformation(SystemRangeStartInformation,
                                          &SystemRangeStart,
                                          sizeof(SystemRangeStart),
                                          NULL);
        //
        // How many buckets to cover the range
        //
        UserModeBucketCount = (ULONG)(1 + ((SystemRangeStart - 1) / MAX_BUCKET_SIZE));

        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "NtQuerySystemInformation failed - status %lx\n", status);
            RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
            return status;
        }

        ProfileObject[NumberOfProfileObjects].SymbolsLoaded = FALSE;
        ProfileObject[NumberOfProfileObjects].CodeStart = 0;
        ProfileObject[NumberOfProfileObjects].CodeLength = SystemRangeStart;

        ProfileObject[NumberOfProfileObjects].ImageBase = 0;
        ProfileObject[NumberOfProfileObjects].ModuleName = "User Mode";
        ProfileObject[NumberOfProfileObjects].BufferSize = UserModeBucketCount * sizeof(DWORD);
        ProfileObject[NumberOfProfileObjects].BucketSize = MAX_BUCKET_SHIFT;
        for (i=0; i<MaxProcessors; i++) {
            UserModeBuffer[i] = HeapAlloc(GetProcessHeap(),
                                         HEAP_ZERO_MEMORY,
                                         ProfileObject[NumberOfProfileObjects].BufferSize);

            if (UserModeBuffer[i] == NULL) {
                fprintf (stderr, "HeapAlloc failed\n");
                RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
                return(STATUS_NO_MEMORY);
            }

            ProfileObject[NumberOfProfileObjects].Buffer[i] = UserModeBuffer[i];
            ProfileObject[NumberOfProfileObjects].Handle[i] = NULL;
#if DBG_PROFILE
            fprintf(stderr, "code start %p len %lx, bucksize %lx buffer %p bsize %lx\n",
                ProfileObject[NumberOfProfileObjects].CodeStart,
                ProfileObject[NumberOfProfileObjects].CodeLength,
                ProfileObject[NumberOfProfileObjects].BucketSize,
                ProfileObject[NumberOfProfileObjects].Buffer ,
                ProfileObject[NumberOfProfileObjects].BufferSize);
#endif

            if (bPerProcessor) {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            1 << i);
            } else {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            (KAFFINITY)-1);
            }

            if (status != STATUS_SUCCESS) {
                fprintf(stderr, "create kernel profile %s failed - status %lx\n",
                    ProfileObject[NumberOfProfileObjects].ModuleName, status);
            }
        }
        NumberOfProfileObjects += 1;
    }

/*
    if (PreviousProfilePrivState == FALSE) {
        LocalStatus = RtlAdjustPrivilege(
                         SE_SYSTEM_PROFILE_PRIVILEGE,
                         FALSE,             //Disable
                         FALSE,             //not impersonating
                         &PreviousProfilePrivState
                         );
        if (!NT_SUCCESS(LocalStatus) || LocalStatus == STATUS_NOT_ALL_ASSIGNED) {
            fprintf(stderr, "Disable system profile privilege failed - status 0x%lx\n",
                LocalStatus);
        }
    }

    if (PreviousQuotaPrivState == FALSE) {
        LocalStatus = RtlAdjustPrivilege(
                         SE_SYSTEM_PROFILE_PRIVILEGE,
                         FALSE,             //Disable
                         FALSE,             //not impersonating
                         &PreviousQuotaPrivState
                         );
        if (!NT_SUCCESS(LocalStatus) || LocalStatus == STATUS_NOT_ALL_ASSIGNED) {
            fprintf(stderr, "Disable increate quota privilege failed - status 0x%lx\n",
                LocalStatus);
        }
    }
*/
    RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
    return status;
}


NTSTATUS
StartProfile (
    VOID
    )
/*++

Routine Description:

    This routine starts all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStartProfile.

--*/

{
    ULONG Object;
    ULONG Processor;
    NTSTATUS status;
    QUOTA_LIMITS QuotaLimits;

    NtSetIntervalProfile(ProfileInterval,ProfileSource);

    if (bWaitForInput) {
            fprintf(stderr, "Hit return to continue.\n");
            (void) getchar();
    }
    for (Object = 0; Object < NumberOfProfileObjects; Object++) {

        for (Processor = 0;Processor < MaxProcessors; Processor++) {
            status = NtStartProfile (ProfileObject[Object].Handle[Processor]);

            if (!NT_SUCCESS(status)) {
                fprintf(stderr, "start profile %s failed - status %lx\n",
                    ProfileObject[Object].ModuleName, status);
                return status;
            }
        }
    }
    return status;
}


NTSTATUS
StopProfile (
    VOID
    )

/*++

Routine Description:

    This routine stops all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStopProfile.

--*/

{
    ULONG i;
    ULONG Processor;
    NTSTATUS status;

    for (i = 0; i < NumberOfProfileObjects; i++) {
        for (Processor=0; Processor < MaxProcessors; Processor++) {
            status = NtStopProfile (ProfileObject[i].Handle[Processor]);
            if (status != STATUS_SUCCESS) {
                fprintf(stderr, "stop profile %s failed - status %lx\n",
                                    ProfileObject[i].ModuleName,status);
                return status;
            }
        }
    }
    return status;
}


NTSTATUS
AnalyzeProfile (
    ULONG Threshold,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StartContext,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StopContext
    )

/*++

Routine Description:

    This routine does the analysis of all the profile buffers and
    correlates hits to the appropriate symbol table.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG CountAtSymbol;
    ULONG_PTR Va;
    int i;
    PULONG Counter;
    ULONG_PTR Displacement;
    ULONG Processor;
    ULONG TotalHits = 0;
    ULONG ProcessorTotalHits[MAXIMUM_PROCESSORS] = {0};
    PULONG BufferEnd;
    PULONG Buffer;
    PULONG pInitialCounter;
    ULONG OffsetVa = 0;
    ULONG BytesPerBucket;
    STRING NoSymbolFound = {16,15,"No Symbol Found"};
    BOOLEAN UseLastSymbol = FALSE;


    for (i = 0; i < (int)NumberOfProfileObjects; i++) {
        for (Processor=0;Processor < MaxProcessors;Processor++) {
            NtStopProfile (ProfileObject[i].Handle[Processor]);
        }
    }

    for (Processor = 0; Processor < MaxProcessors; Processor++) {
        for (i = 0; i < (int)NumberOfProfileObjects; i++) {
            //
            // Sum the total number of cells written.
            //
            BufferEnd = ProfileObject[i].Buffer[Processor] + (
                        ProfileObject[i].BufferSize / sizeof(ULONG));
            Buffer = ProfileObject[i].Buffer[Processor];
            Counter = BufferEnd;

            ProfileObject[i].ModuleHitCount[Processor] = 0;
            while (Counter > Buffer) {
                Counter -= 1;
                ProfileObject[i].ModuleHitCount[Processor] += *Counter;
            }

            ProcessorTotalHits[Processor] += ProfileObject[i].ModuleHitCount[Processor];
        }
        if (bPerProcessor) {
            fprintf(fpOut, "Processor %d: %d Total hits\n",
                            Processor, ProcessorTotalHits[Processor]);
        }
        TotalHits += ProcessorTotalHits[Processor];
    }
    fprintf(fpOut, "%d Total hits\n",TotalHits);

    for (Processor = 0; Processor < MaxProcessors; Processor++) {
        if (bPerProcessor) {
            fprintf(fpOut, "\nPROCESSOR %d\n",Processor);
        }
        for (i = 0; i < (int)NumberOfProfileObjects; i++) {
            CountAtSymbol = 0;
            //
            // Sum the total number of cells written.
            //
            BufferEnd = ProfileObject[i].Buffer[Processor] + (
                        ProfileObject[i].BufferSize / sizeof(ULONG));
            Buffer = ProfileObject[i].Buffer[Processor];
            Counter = BufferEnd;

            if (ProfileObject[i].ModuleHitCount[Processor] < Threshold) {
                continue;
            }
            fprintf(fpOut, "\n%9d ",
                            ProfileObject[i].ModuleHitCount[Processor]);
            if (bPrintPercentages) {
                fprintf(fpOut, "%5.2f ",
                            (ProfileObject[i].ModuleHitCount[Processor] /
                             (double)ProcessorTotalHits[Processor]) * 100);
            }
            fprintf(fpOut, "%20s --Total Hits-- %s\n",
                            ProfileObject[i].ModuleName,
                            ((ProfileObject[i].SymbolsLoaded) ? "" :
                                                                "(NO SYMBOLS)")
                            );

            if (!ProfileObject[i].SymbolsLoaded) {
                RtlZeroMemory(ProfileObject[i].Buffer[Processor],
                                ProfileObject[i].BufferSize);
                continue;
            }
            BytesPerBucket = (1 << ProfileObject[i].BucketSize);

            pInitialCounter = Buffer;
            for ( Counter = Buffer; Counter < BufferEnd; Counter += 1 ) {
                if ( *Counter ) {
                    //
                    // Calculate the virtual address of the counter
                    //
                    Va = Counter - Buffer;                  // Calculate buckets #
                    Va = Va * BytesPerBucket;               // convert to bytes
                    Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart; // add in base address

                    if (SymGetSymFromAddr( SYM_HANDLE, Va, &Displacement, ThisSymbol )) {
                        if (UseLastSymbol &&
                            LastSymbol->Address &&
                            (LastSymbol->Address == ThisSymbol->Address))
                        {
                            CountAtSymbol += *Counter;
                        } else {
                            OutputSymbolCount(CountAtSymbol,
                                              ProcessorTotalHits[Processor],
                                              &ProfileObject[i],
                                              LastSymbol,
                                              Threshold,
                                              pInitialCounter,
                                              Counter,
                                              OffsetVa,
                                              BytesPerBucket);
                            pInitialCounter = Counter;
                            OffsetVa = (DWORD) Displacement;    // Images aren't > 2g so this cast s/b O.K.
                            CountAtSymbol = *Counter;
                            memcpy( LastSymBuffer, symBuffer, sizeof(symBuffer) );
                            UseLastSymbol = TRUE;
                        }
                    } else {
                        OutputSymbolCount(CountAtSymbol,
                                          ProcessorTotalHits[Processor],
                                          &ProfileObject[i],
                                          LastSymbol,
                                          Threshold,
                                          pInitialCounter,
                                          Counter,
                                          OffsetVa,
                                          BytesPerBucket);
                    }       // else !(NT_SUCCESS)
                }       // if (*Counter)
            }      // for (Counter)

            OutputSymbolCount(CountAtSymbol,
                              ProcessorTotalHits[Processor],
                              &ProfileObject[i],
                              LastSymbol,
                              Threshold,
                              pInitialCounter,
                              Counter,
                              OffsetVa,
                              BytesPerBucket);
            //
            // Clear after buffer's been checked and displayed
            //
            RtlZeroMemory(ProfileObject[i].Buffer[Processor], ProfileObject[i].BufferSize);
        }
    }

    if (bDisplayContextSwitch) {
        fprintf(fpOut, "\n");
        fprintf(fpOut, "Context Switch Information\n");
        fprintf(fpOut, "    Find any processor        %6ld\n", StopContext->FindAny - StartContext->FindAny);
        fprintf(fpOut, "    Find last processor       %6ld\n", StopContext->FindLast - StartContext->FindLast);
        fprintf(fpOut, "    Idle any processor        %6ld\n", StopContext->IdleAny - StartContext->IdleAny);
        fprintf(fpOut, "    Idle current processor    %6ld\n", StopContext->IdleCurrent - StartContext->IdleCurrent);
        fprintf(fpOut, "    Idle last processor       %6ld\n", StopContext->IdleLast - StartContext->IdleLast);
        fprintf(fpOut, "    Preempt any processor     %6ld\n", StopContext->PreemptAny - StartContext->PreemptAny);
        fprintf(fpOut, "    Preempt current processor %6ld\n", StopContext->PreemptCurrent - StartContext->PreemptCurrent);
        fprintf(fpOut, "    Preempt last processor    %6ld\n", StopContext->PreemptLast - StartContext->PreemptLast);
        fprintf(fpOut, "    Switch to idle            %6ld\n", StopContext->SwitchToIdle - StartContext->SwitchToIdle);
        fprintf(fpOut, "\n");
        fprintf(fpOut, "    Total context switches    %6ld\n", StopContext->ContextSwitches - StartContext->ContextSwitches);
    }
    return STATUS_SUCCESS;
}


VOID
OutputSymbolCount(
    IN ULONG CountAtSymbol,
    IN ULONG TotalCount,
    IN PROFILE_BLOCK *ProfileObject,
    IN PIMAGEHLP_SYMBOL SymbolInfo,
    IN ULONG Threshold,
    IN PULONG CounterStart,
    IN PULONG CounterStop,
    IN ULONG Va,
    IN ULONG BytesPerBucket
    )
{
    ULONG Density;
    ULONG i;

    if (CountAtSymbol < Threshold) {
        return;
    }

    fprintf(fpOut, "%9d ", CountAtSymbol);

    if (bPrintPercentages) {
        fprintf(fpOut, "%5.2f ", (CountAtSymbol / (double) TotalCount) * 100);
    }

    if (bDisplayDensity) {
        //
        // Compute hit density = hits * 100 / function length
        //
        if (!SymbolInfo || !SymbolInfo->Size) {
            Density = 0;
        } else {
            Density = CountAtSymbol * 100 / SymbolInfo->Size;
        }
        fprintf(fpOut, "%5d ",Density);
    }

    if (SymbolInfo->MaxNameLength) {
        fprintf(fpOut, "%20s %s",
               ProfileObject->ModuleName,
               SymbolInfo->Name);
    } else {
        fprintf(fpOut, "%20s 0x%x",
               ProfileObject->ModuleName,
               SymbolInfo->Address);
    }

    if (bDisplayAddress) {
        fprintf(fpOut, " 0x0%p %d %d",
               SymbolInfo->Address,
               SymbolInfo->Size,
               ProfileObject->BucketSize);
    }

    if (bDisplayCounters) {
        for (i = 0 ; CounterStart < CounterStop; i++, Va += BytesPerBucket, ++CounterStart) {
            if ((i % 16) == 0) {
                fprintf (fpOut, "\n0x%08x:", Va);
            }
            fprintf(fpOut, " %5d", *CounterStart);
        }
    }
    fprintf (fpOut, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\ext.cpp ===
//----------------------------------------------------------------------------
//
// Generic interface-style extension support.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <windows.h>
#define NOEXTAPI
#include <wdbgexts.h>

#include "ext.h"

int g_ExtRecurse;
PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

PDEBUG_DATA_SPACES2   g_ExtData2;

HANDLE g_hCurrentProcess;
HANDLE g_hCurrentThread;

WINDBG_EXTENSION_APIS   ExtensionApis;
WINDBG_EXTENSION_APIS32 ExtensionApis32;
WINDBG_EXTENSION_APIS64 ExtensionApis64;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if (++g_ExtRecurse > 1)
    {
        // Already queried.
        return S_OK;
    }
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    ULONG64 Cur;
    
    if ((Status = g_ExtSystem->GetCurrentProcessHandle(&Cur)) != S_OK)
    {
        goto Fail;
    }
    g_hCurrentProcess = (HANDLE)(ULONG_PTR)Cur;
    
    if ((Status = g_ExtSystem->GetCurrentThreadHandle(&Cur)) != S_OK)
    {
        goto Fail;
    }
    g_hCurrentThread = (HANDLE)(ULONG_PTR)Cur;
    
    ExtensionApis64.nSize = sizeof(ExtensionApis64);
    if ((Status = g_ExtControl->
         GetWindbgExtensionApis64(&ExtensionApis64)) != S_OK)
    {
        goto Fail;
    }
    ExtensionApis32.nSize = sizeof(ExtensionApis32);
    if ((Status = g_ExtControl->
         GetWindbgExtensionApis32(&ExtensionApis32)) != S_OK)
    {
        goto Fail;
    }
    
#ifdef _WIN64
    memcpy(&ExtensionApis, &ExtensionApis64, sizeof(ExtensionApis));
#else
    memcpy(&ExtensionApis, &ExtensionApis32, sizeof(ExtensionApis));
#endif

    // Check for version 2 interfaces.  Do not consider
    // it fatal if they can't be queried.  Extension code
    // must handle the potential lack of these interfaces.
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                         (void **)&g_ExtData2)) != S_OK)
    {
        g_ExtData2 = NULL;
    }
    
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    if (--g_ExtRecurse > 0)
    {
        // Recursive release so don't do anything.
        return;
    }
    
    g_ExtClient = NULL;
    g_hCurrentProcess = NULL;
    g_hCurrentThread = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
    EXT_RELEASE(g_ExtData2);
}

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}


ULONG GetCurrentThreadUserID(void)
{
    ULONG Id;
    if (!g_ExtSystem) {
        return 0;
    }

    if (g_ExtSystem->GetCurrentThreadId(&Id) != S_OK) {
        return 0;
    }
    return Id;
}
BOOL
EnumerateUModeThreads(
    PENUMERATE_UMODE_THREADS_CALLBACK Callback,
    PVOID UserContext
    )
{
    ULONG CurrentThreadId;
    ULONG ThreadId;

    if (!g_ExtSystem) {
        return FALSE;
    }

    // Remember thread we started with
    if (g_ExtSystem->GetCurrentThreadId(&CurrentThreadId) != S_OK) {
        return FALSE;
    }

    // Loop through all threads
    for (ThreadId=0;;ThreadId++) {

        // set ThreadId as current thread
        if (g_ExtSystem->SetCurrentThreadId(ThreadId) != S_OK) {
            // finished enumerateing threads
            break;
        }

        // call the callback routine
        if (!((*Callback)(ThreadId, UserContext))) {
            // callback failed, break out
            break;
        }

    }

    // Set current thread back to original value
    g_ExtSystem->SetCurrentThreadId(CurrentThreadId);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\ext.h ===
//----------------------------------------------------------------------------
//
// Generic interface-style extension support.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __EXT_H__
#define __EXT_H__

#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif
    
// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

HRESULT ExtQuery(PDEBUG_CLIENT Client);
void ExtRelease(void);
    
// Global variables initialized by ExtQuery.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Version 2 interfaces may be NULL.
extern PDEBUG_DATA_SPACES2   g_ExtData2;

extern HANDLE g_hCurrentProcess;
extern HANDLE g_hCurrentThread;
    
// Windbg-style extension interfaces queried at Initialize time.
extern WINDBG_EXTENSION_APIS   ExtensionApis;
extern WINDBG_EXTENSION_APIS32 ExtensionApis32;
extern WINDBG_EXTENSION_APIS64 ExtensionApis64;

typedef BOOL
(CALLBACK *PENUMERATE_UMODE_THREADS_CALLBACK)(
     ULONG ThreadUserId,
     PVOID UserContext
     );

ULONG GetCurrentThreadUserID(void);

BOOL
EnumerateUModeThreads(
    PENUMERATE_UMODE_THREADS_CALLBACK Callback,
    PVOID UserContext
    );

#ifdef __cplusplus
}
#endif

#endif // #ifndef __EXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\kernrate\kernrate.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

   kernrate.c

Abstract:

    This program records the rate of various events over a selected
    period of time. It uses the kernel profiling mechanism and iterates
    through the available profile sources to produce an overall profile
    for the various kernel components.

Usage:

    kernrate

Author:

    John Vert (jvert) 31-Mar-1995

Revision History:

    The original MS version has been extensively modified by Thierry Fevrier.

    01/12/2000 Thierry
    Kernrate is under the SD tree. From now on, please refer to filelog outputs for 
    details on modifications...

    01/11/2000 Thierry
    Ported to test IA64 Hardware Performance Counters.

    10/02/97 11:48a Thierry
    Fixed the format of RATE_SUMMARY TotalCount.
    Fixed outputs for large ULONG numbers.

    10/01/97 5:28p Thierry
    Added image file and debug file checksum/timestamp check using imagehlp
    callbacks.
    Modified processor times display using I64u formats.
    Defined UInt64PerCent() function.
    MODULE structures are allocated using calloc().
    Changed MODULE structure to contain FileName and FullName fields.
    Added ToDoList block to remind us about the current problems for this
    program.

    9/30/97 11:01a Thierry
    Added "-u" option to present undecorated symbols
    Usage(): Print version info

    9/05/97 2:41p tkjos
    Changed raw output to include all symbols associated with each bucket

    9/05/97 2:15p Thierry
    Added the '-j' option to specify a symbol path that will be prepended
    to the default IMAGEHLP sysmbol search path.

    9/05/97 11:37a Thierry
    Fixed Usage() string for -v and -b options.

    9/05/97 10:56a tkjos
    Added -v option for "verbose" output. This causes all data to be
    be evaluated by rounding the bucket counters both up and down to the
    nearest symbol.  By default, only the rounded down data is shown.  Also
    added a '-b BucketSize' option to allow the bucket size to be changed.

    9/05/97 1:49a Thierry
    no real modification. only a remote check-in.

    9/05/97 12:58a Thierry
    SetModuleName() definition.

    9/05/97 12:48a Thierry
    Fixed limitation that module name passed as a zoomed module name or by
    looking at the process modules should be limited with 7 characters.

    9/04/97 6:44p Thierry
    Added the possibility to use no source short name with the '-i' option.
    In this case, the default platform independant "Time" source is used.

    9/04/97 6:27p Thierry
    Added the options -lx and -r to the usage string.

    9/04/97 6:02p Thierry
    Added the update of source short name for the static and dynamic
    sources. This allows users to use these short names to disable sources.

    9/04/97 3:06p Thierry
    Added '-lx' option to list supported sources and exit immediately
    GetConfiguration(): option '-i Source 0' disables the source.

    9/04/97 10:40a tkjos
    Fixed defect in accumulation of counters for zoomed modules. The index
    for the end of each function was being calculated incorrectly causing
    counter information to be lost or to be assigned to the wrong functions.

    9/03/97 12:40p tkjos
    Added raw addresses to -r option.

    8/28/97 7:43a Thierry
    Added '-l' option to list available source types and their default
    interval rate.
    Added '-i' option to allow users the changing of default interval
    rates.

--*/

   // KERNRATE Implementation Notes:
   //
   // 01/10/2000 - Thierry
   // The following code assumes that a kernrate compiled for a specific
   // platform, executes and processes perf data only for that platform.
   //

   // KERNRATE ToDoList:
   //
   // Thierry 09/30/97:
   //     - KernRate does not clean the ImageHlp API in case of exceptions. I have
   //       just added a SymCleanup() call at the normal exit of this program but
   //       it is not sufficient. We should revisit this one day...
   //
   // Thierry 07/01/2000:
   //     - Kernrate and the Kernel Profiling objects code assume that code sections
   //       that we are profiling are not larger than 4GB.
   //

//
// If under our build environment'S', we want to get all our
// favorite debug macros defined.
//

#if DBG           // NTBE environment
   #if NDEBUG
      #undef NDEBUG     // <assert.h>: assert() is defined
   #endif // NDEBUG
   #define _DEBUG       // <crtdbg.h>: _ASSERT(), _ASSERTE() are defined.
   #define DEBUG   1    // our internal file debug flag
#elif _DEBUG      // VC++ environment
   #ifndef NEBUG
   #define NDEBUG
   #endif // !NDEBUG
   #define DEBUG   1    // our internal file debug flag
#endif


//
// Include System Header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>

#include <..\pperf\pstat.h>

#include ".\kernrate.rc"

#define FPRINTF (void)fprintf

#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL64)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL64 Symbol = (PIMAGEHLP_SYMBOL64)symBuffer;

typedef enum _VERBOSE_ENUM {
   VERBOSE_NONE      = 0,   //
   VERBOSE_IMAGEHLP  = 0x1, //
   VERBOSE_PROFILING = 0x2, //
   VERBOSE_INTERNALS = 0x4, //
   VERBOSE_MODULES   = 0x8, //
   VERBOSE_DEFAULT   = VERBOSE_IMAGEHLP
} VERBOSE_ENUM;

typedef struct _VERBOSE_DEFINITION {
   VERBOSE_ENUM        VerboseEnum;
   const char * const  VerboseString;
} VERBOSE_DEFINITION, *PVERBOSE_DEFINITION;

VERBOSE_DEFINITION VerboseDefinition[] = {
    { VERBOSE_NONE,       "None" },
    { VERBOSE_IMAGEHLP,   "Displays ImageHlp  operations" },
    { VERBOSE_PROFILING,  "Displays Profiling operations" },
    { VERBOSE_INTERNALS,  "Displays Internals operations" },
    { VERBOSE_MODULES,    "Displays Modules   operations" },
    { VERBOSE_NONE,       NULL }
};

ULONG Verbose        = VERBOSE_NONE;

BOOL RoundingVerboseOutput = FALSE;
ULONG ZoomBucket = 16;
ULONG Log2ZoomBucket = 4;
#define ZOOM_BUCKET ZoomBucket
#define LOG2_ZOOM_BUCKET Log2ZoomBucket

typedef enum _KERNRATE_NAMESPACE {
    cMAPANDLOAD_READONLY = TRUE,
    cDONOT_ALLOCATE_DESTINATION_STRING = FALSE,
} eKERNRATE_NAMESPACE;


//
// Type definitions
//

typedef struct _SOURCE {
    PCHAR           Name;                  // pstat EVENTID.Description
    KPROFILE_SOURCE ProfileSource;
    PCHAR           ShortName;             // pstat EVENTID.ShortName
    ULONG           DesiredInterval;
    ULONG           Interval;
} SOURCE, *PSOURCE;

typedef struct _RATE_DATA {
    ULONGLONG   StartTime;
    ULONGLONG   TotalTime;
    ULONGLONG   TotalCount;
    ULONGLONG   Rate;       // Events/Second
    HANDLE      ProfileHandle;
    ULONG       CurrentCount;
    PULONG      ProfileBuffer;
} RATE_DATA, *PRATE_DATA;

typedef enum _MODULE_NAMESPACE {
    cMODULE_NAME_STRLEN = 40,   // maximum module name, including '\0'
} eMODULE_NAMESPACE;

typedef struct _MODULE {
    struct _MODULE *Next;
    HANDLE          Process;
    ULONG64         Base;
    ULONG           Length;
    BOOLEAN         Zoom;
    CHAR            module_Name[cMODULE_NAME_STRLEN]; // filename w/o  its extension
    PCHAR           module_FileName;                  // filename with its extension
    PCHAR           module_FullName;                  // full pathname
    RATE_DATA       Rate[];
} MODULE, *PMODULE;

#define ModuleFileName( _Module ) \
   ( (_Module)->module_FileName ? (_Module)->module_FileName : (_Module)->module_Name )
#define ModuleFullName( _Module ) \
   ( (_Module)->module_FullName ? (_Module)->module_FullName : ModuleFileName( _Module ) )

typedef struct _RATE_SUMMARY {
    ULONGLONG   TotalCount;
    PMODULE    *Modules;
    ULONG       ModuleCount;
} RATE_SUMMARY, *PRATE_SUMMARY;

#define IsValidHandle( _Hdl ) ( ( (_Hdl) != (HANDLE)0 ) && ( (_Hdl) != INVALID_HANDLE_VALUE ) )

//
// Thierry - FIXFIX - These processor level enums should be defined in public headers.
//                    ntexapi.h - NtQuerySystemInformation( SystemProcessorInformation).
//
// Define them locally.
//

typedef enum _PROCESSOR_LEVEL   {
    IA64_MERCED    = 0x1,
    IA64_ITANIUM   = IA64_MERCED,
    IA64_MCKINLEY  = 0x2
} PROCESSOR_LEVEL;

//
// Global variables
//
HANDLE  DoneEvent;
DWORD   ChangeInterval = 1000;
DWORD   SleepInterval = 0;
ULONG   ModuleCount=0;
ULONG   ZoomCount;
PMODULE ZoomList = NULL;
PMODULE CallbackCurrent;
BOOLEAN RawData   = FALSE;
BOOLEAN RawDisasm = FALSE;
HANDLE  SymHandle = (HANDLE)-1;

static CHAR    gUserSymbolPath[256];
static CHAR    gSymbolPath[2*256];
static DWORD   gSymOptions;
static PMODULE gCurrentModule = (PMODULE)0;

//
// The desired intervals are computed to give approximately
// one interrupt per millisecond and be a nice even power of 2
//

enum _STATIC_SOURCE_TYPE  {
   SOURCE_TIME = 0,
};

#define SOURCE_ALIGN_FIXUP_DEFAULT_DESIRED_INTERVAL 0
#if defined(_ORIGINAL_CODE) && defined(_M_X86)
//
// The MS original code specifed that Alignment Fixup as a default source
// for X86, even if the Kernel/Hal do not support it for these platforms.
//
#undef  SOURCE_ALIGN_FIXUP_DEFAULT_DESIRED_INTERVAL
#define SOURCE_ALIGN_FIXUP_DEFAULT_DESIRED_INTERVAL  1
#endif

SOURCE StaticSources[] = {
   {"Time",                     ProfileTime,                 "time"       , 1000, 1000},
   {"Alignment Fixup",          ProfileAlignmentFixup,       "alignfixup" , SOURCE_ALIGN_FIXUP_DEFAULT_DESIRED_INTERVAL,0},
   {"Total Issues",             ProfileTotalIssues,          "totalissues", 131072,0},
   {"Pipeline Dry",             ProfilePipelineDry,          "pipelinedry", 131072,0},
   {"Load Instructions",        ProfileLoadInstructions,     "loadinst"   , 65536,0},
   {"Pipeline Frozen",          ProfilePipelineFrozen,       "pilelinefrz", 131072,0},
   {"Branch Instructions",      ProfileBranchInstructions,   "branchinst" , 65536,0},
   {"Total Nonissues",          ProfileTotalNonissues,       "totalnoniss", 131072,0},
   {"Dcache Misses",            ProfileDcacheMisses,         "dcachemiss" , 16384,0},
   {"Icache Misses",            ProfileIcacheMisses,         "icachemiss" , 16384,0},
   {"Cache Misses",             ProfileCacheMisses,          "cachemiss"  , 16384,0},
   {"Branch Mispredictions",    ProfileBranchMispredictions, "branchpred" , 16384,0},
   {"Store Instructions",       ProfileStoreInstructions,    "storeinst"  , 65536,0},
   {"Floating Point Instr",     ProfileFpInstructions,       "fpinst"     , 65536,0},
   {"Integer Instructions",     ProfileIntegerInstructions,  "intinst"    , 65536,0},
   {"Dual Issues",              Profile2Issue,               "2issue"     , 65536,0},
   {"Triple Issues",            Profile3Issue,               "3issue"     , 16384,0},
   {"Quad Issues",              Profile4Issue,               "4issue"     , 16384,0},
   {"Special Instructions",     ProfileSpecialInstructions,  "specinst"   , 16384,0},
   {"Cycles",                   ProfileTotalCycles,          "totalcycles", 655360,0},
   {"Icache Issues",            ProfileIcacheIssues,         "icacheissue", 65536,0},
   {"Dcache Accesses",          ProfileDcacheAccesses,       "dcacheacces", 65536,0},
   {"MB Stall Cycles",          ProfileMemoryBarrierCycles,  "membarcycle", 32767,0},
   {"Load Linked Instructions", ProfileLoadLinkedIssues,     "loadlinkiss", 16384,0},
   {NULL, ProfileMaximum, "", 0, 0}
   };

#if defined(_IA64_)
#include "merced.c"
#endif // _IA64_

PSOURCE Source        = NULL;
ULONG   SourceMaximum = 0;

//
// Print format for event strings
//

ULONG TokenMaxLen       = 12;   // strlen("dcacheacces")
ULONG DescriptionMaxLen = 25;   // strlen("Load Linked Instructions")

//
// Function prototypes local to this module
//

PMODULE
GetKernelModuleInformation(
    VOID
    );

PMODULE
GetProcessModuleInformation(
    IN HANDLE ProcessHandle
    );

VOID
CreateProfiles(
    IN PMODULE Root
    );

PMODULE
CreateNewModule(
    IN HANDLE  ProcessHandle,
    IN PCHAR   ModuleName,
    IN PCHAR   ModuleFullName,
    IN ULONG64 ImageBase,
    IN ULONG   ImageSize
    );

VOID
GetConfiguration(
    int argc,
    char *argv[]
    );

ULONG
InitializeProfileSourceInfo (
    VOID
    );

ULONG
NextSource(
    IN ULONG   CurrentSource,
    IN PMODULE ModuleList
    );

VOID
StopSource(
    IN ULONG   ProfileSourceIndex,
    IN PMODULE ModuleList
    );

VOID
StartSource(
    IN ULONG ProfileSource,
    IN PMODULE ModuleList
    );

VOID
OutputResults(
    IN FILE *Out,
    IN PMODULE ModuleList
    );

VOID
OutputModuleList(
    IN FILE *Out,
    IN PMODULE ModuleList,
    IN ULONG NumberModules
    );

BOOL
TkEnumerateSymbols(
    IN HANDLE SymHandle,
    IN PMODULE Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback
    );

VOID
CreateZoomedModuleList(
    IN PMODULE ZoomModule,
    IN ULONG   RoundDown
    );

BOOL
CreateZoomModuleCallback(
    IN LPSTR   szSymName,
    IN ULONG64 Address,
    IN ULONG   Size,
    IN PVOID   Cxt
    );

VOID
OutputLine(
    IN FILE          *Out,
    IN ULONG          ProfileSourceIndex,
    IN PMODULE        Module,
    IN PRATE_SUMMARY  RateSummary
    );

VOID
CreateDoneEvent(
    VOID
    );

VOID
OutputInterestingData(
    IN FILE *Out,
    IN RATE_DATA Data[],
    IN PCHAR Header
    );

static 
VOID
vVerbosePrint(
    ULONG  Level,
    PCCHAR Msg,
    ...
)
{
    if ( Verbose & Level )  {
        UCHAR verbosePrintBuffer[512];
        va_list ap;

        va_start( ap, Msg ); 
        _vsnprintf( verbosePrintBuffer, sizeof( verbosePrintBuffer ), Msg, ap );
        va_end(ap);
        (void)fprintf( stderr, verbosePrintBuffer );

    }
    return;

} // vVerbosePrint()

#define VerbosePrint( _x_ )  vVerbosePrint _x_

BOOL
CtrlcH(
    DWORD dwCtrlType
    )
{
    LARGE_INTEGER DueTime;

    if ( dwCtrlType == CTRL_C_EVENT ) {
        if (SleepInterval == 0) {
            SetEvent(DoneEvent);
        } else {
            DueTime.QuadPart = (ULONGLONG)-1;
            NtSetTimer(DoneEvent,
                       &DueTime,
                       NULL,
                       NULL,
                       FALSE,
                       0,
                       NULL);
        }
        return TRUE;
    }
    return FALSE;

} // CtrlcH()

static VOID
UsageVerbose(
    VOID
    )
{
  PVERBOSE_DEFINITION pdef = VerboseDefinition;

  FPRINTF( stderr, "  -v [VerboseLevels]      Verbose output where VerboseLevels:\n");
  while( pdef->VerboseString )    {
     FPRINTF( stderr, "                             - %x %s\n", pdef->VerboseEnum,
                                                                pdef->VerboseString
            );
     pdef++;
  }
  FPRINTF( stderr, "                             - Default value: %x\n", VERBOSE_DEFAULT);
  FPRINTF( stderr, "                          These verbose levels can be OR'ed.\n");

  return;

} // UsageVerbose()

static VOID
Usage(
   VOID
   )
{

  FPRINTF( stderr, "KERNRATE - Version: %s\n", VER_PRODUCTVERSION_STR );
  FPRINTF( stderr,
"KERNRATE [-l] [-lx] [-r] [-z ModuleName] [-j SymbolPath] [-c RateInMsec] [-s Seconds] [-p ProcessId] [-i [SrcShortName] Rate]\n"
"  -b BucketSize           Specify profiling bucket size (default = 16 bytes)\n"
"  -c RateInMsec           Change source after N milliseconds (default 1000)\n"
"  -d                      Generate output rounding buckets up and down\n"
"  -i [SrcShortName] Rate  Specify interrupt interval rate for the source specified by its ShortName\n"
"  -j SymbolPath           Prepend SymbolPath the default imagehlp search path\n"
"  -l                      List the default interval rates for the supported sources\n"
"  -lx                     List the default interval rates for the supported sources and exits\n"
"  -p ProcessId            Monitor process instead of kernel\n"
"  -r                      Raw data from zoomed modules\n"
"  -rd                     Raw data from zoomed modules with disassembly\n"
"  -s Seconds              Stop collecting data after N seconds\n"
"  -u                      Present symbols in undecorated form\n"
        );

  UsageVerbose();    // -v switches

  FPRINTF( stderr,
"  -z ModuleName           Zoom in on specified module\n"
"\nWith the '-i' option, specifying a Rate value = 0 disables the source.\n"
         );
#if defined(_M_IX86) || defined(_M_IA64)
   FPRINTF(stderr, "The default interrupt profiling source is Time @ %ld\n", Source[SOURCE_TIME].DesiredInterval);
#endif /* !_M_IX86 */

    exit(1);

} // Usage()

VOID
CreateDoneEvent(
    VOID
    )
{
    LARGE_INTEGER DueTime;
    NTSTATUS Status;
    DWORD Error;

    if (SleepInterval == 0) {
        //
        // Create event that will indicate the test is complete.
        //
        DoneEvent = CreateEvent(NULL,
                                TRUE,
                                FALSE,
                                NULL);
        if (DoneEvent == NULL) {
            Error = GetLastError();
            FPRINTF(stderr, "CreateEvent failed %d\n",Error);
            exit(Error);
        }
    } else {

        //
        // Create timer that will indicate the test is complete
        //
        Status = NtCreateTimer(&DoneEvent,
                               MAXIMUM_ALLOWED,
                               NULL,
                               NotificationTimer);

        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "NtCreateTimer failed %08lx\n",Status);
            exit(Status);
        }

        DueTime.QuadPart = (ULONGLONG)SleepInterval * -10000;
        Status = NtSetTimer(DoneEvent,
                            &DueTime,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL);

        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "NtSetTimer failed %08lx\n",Status);
            exit(Status);
        }
    }

} // CreateDoneEvent()

static void
CheckImageAndDebugFiles( IN PMODULE Module, IN PIMAGEHLP_DEFERRED_SYMBOL_LOAD Idsl  )
{
   LOADED_IMAGE image;

   assert( Module );
   assert( Idsl );

   if ( Module->module_FullName == (PCHAR)0 )   {
      FPRINTF( stderr, "KERNRATE: Failed checking module %s with its debug file %s...\n",
                       ModuleFileName( Module ),
                       Idsl->FileName
                   );
      return;
   }

   //
   // Map and Load the current image file
   //

   if ( !MapAndLoad( Module->module_FullName, (LPSTR)0, &image, FALSE, cMAPANDLOAD_READONLY ) )   {

      BOOL notMapped = TRUE;

      //
      // Is the fullname string a module alias?.
      //

      if ( strchr( Module->module_FullName, ':' ) == (char)0 )   {

         char path[_MAX_PATH + ( 3 * sizeof(char) )];
         int c;

         for ( c = 'C' ; c <= 'Z' ; c++ )   {
            path[0] = (char)c;
            path[1] = ':';
            path[2] = '\0';
            strcat( path, Module->module_FullName );
            if ( MapAndLoad( path, (LPSTR)0, &image, FALSE, cMAPANDLOAD_READONLY ) )   {
               notMapped = FALSE;
               break;
            }
         }

      }

      if ( notMapped )   {
         FPRINTF(stderr, "KERNRATE: Failed mapping and checking module %s with its debug file %s...\n",
                             ModuleFullName( Module ),
                             Idsl->FileName
                   );
         return;
      }
   }

   if ( Idsl->CheckSum )   {
        DWORD checkSum;
        DWORD idslCheckSum;
        DWORD timeStamp;

        idslCheckSum = Idsl->CheckSum;
        checkSum = image.FileHeader->OptionalHeader.CheckSum;
        if ( checkSum != idslCheckSum )   {
            FPRINTF( stderr, "*** WARNING: symbols checksum is wrong 0x%08x 0x%08x for %s\n",
                             checkSum,
                             idslCheckSum,
                             Idsl->FileName
                    );
            UnMapAndLoad( &image );
            return;
        }

        timeStamp = image.FileHeader->FileHeader.TimeDateStamp;
        if ( timeStamp != Idsl->TimeDateStamp )  {
            FPRINTF( stderr, "*** WARNING: symbols timestamp is wrong 0x%08x 0x%08x for %s\n",
                             timeStamp,
                             Idsl->TimeDateStamp,
                             Idsl->FileName
                    );
        }
   }

   UnMapAndLoad( &image );

   return;

} // CheckImageAndDebugFiles()


/* BEGIN_IMS  SymbolCallbackFunction
******************************************************************************
****
****   SymbolCallbackFunction (  )
****
******************************************************************************
*
* Function Description:
*
*    The user function is called by IMAGEHLP at the specified operations.
*    Refer to the CBA_xxx values.
*
* Arguments:
*
*    HANDLE hProcess :
*
*    ULONG ActionCode :
*
*    PVOID CallbackData :
*
*    PVOID UserContext :
*
* Return Value:
*
*    BOOL
*
* Algorithm:
*
*    ToBeSpecified
*
* Globals Referenced:
*
*    ToBeSpecified
*
* Exception Conditions:
*
*    ToBeSpecified
*
* In/Out Conditions:
*
*    ToBeSpecified
*
* Notes:
*
*    ToBeSpecified
*
* ToDo List:
*
*    ToBeSpecified
*
* Modification History:
*
*    9/30/97  TF  Initial version
*
******************************************************************************
* END_IMS  SymbolCallbackFunction */

BOOL
SymbolCallbackFunction(
    HANDLE    hProcess,
    ULONG     ActionCode,
    ULONG64   CallbackData,
    ULONG64   UserContext
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD   idsl;
    PIMAGEHLP_DUPLICATE_SYMBOL       idup;
    PMODULE                         *pmodule;
    PMODULE                          module;
    IMAGEHLP_MODULE                  mi;

    // Note TF 09/97:
    // The default return value for this function is FALSE.
    //

    assert( UserContext );

    switch( ActionCode ) {
        case CBA_DEBUG_INFO:
            VerbosePrint(( VERBOSE_IMAGEHLP, "%s", (LPSTR)CallbackData ));
            return TRUE;

        case CBA_DEFERRED_SYMBOL_LOAD_START:
            idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD)CallbackData;
            pmodule = (PMODULE *)UserContext;
            module = *pmodule;
            _strlwr( idsl->FileName );
            VerbosePrint(( VERBOSE_IMAGEHLP, "Loading symbols for 0x%Ix %s...\n",
                                             idsl->BaseOfImage,
                                             idsl->FileName
                        ));
            return ( ( module == (PMODULE)0 ) ? FALSE : TRUE );
#if 0
            //
            // For KernRate, we should be looping through the ZoomList
            // and look after the same base. However, because of KernRate
            // CreateNewModule() ZoomList manipulation, this list is broken.
            // We should revisit this.
            // For now, I am using the UserContext.
            //
            module = ZoomList;
            while ( module )   {
               if ( idsl->BaseOfImage == (ULONG)module->Base )   {
                  _strlwr( idsl->FileName );
                  FPRINTF( stderr,
                                 "Loading symbols for 0x%08x %s...",
                                 idsl->BaseOfImage,
                                 idsl->FileName
                               );
                  return TRUE;
               }
               module = module->Next;
            }
            break;
#endif // 0

        case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
            idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD) CallbackData;
            FPRINTF( stderr, "*** ERROR: Could not load symbols for 0x%Ix %s...\n",
                                    idsl->BaseOfImage,
                                    idsl->FileName
                         );
            return FALSE;

        case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
            idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD) CallbackData;
            pmodule = (PMODULE *)UserContext;
            module = *pmodule;
            if ( module && module->Base == idsl->BaseOfImage )    {
               FPRINTF(stderr, "Loaded  symbols for 0x%Ix %s -> %s\n",
                               idsl->BaseOfImage,
                               ModuleFullName( module ),
                               idsl->FileName
                      );

               CheckImageAndDebugFiles( module, idsl );

               if ( SymGetModuleInfo( SymHandle, idsl->BaseOfImage, &mi ) )   {
                  if ( mi.SymType == SymNone )   {
                     FPRINTF( stderr, "*** ERROR: Module load completed but symbols could not be loaded for %s\n",
                                      idsl->FileName
                            );
                  }
               }
               return TRUE;
            }
#if 0
            pImage = pProcessCurrent->pImageHead;
            while (pImage) {
                if ((idsl->BaseOfImage == (ULONG)pImage->lpBaseOfImage) || ((ULONG)pImage->lpBaseOfImage == 0)) {
                    pImage->szDebugPath[0] = 0;
                    strncpy( pImage->szDebugPath, idsl->FileName, sizeof(pImage->szDebugPath) );
                    _strlwr( pImage->szDebugPath );
                    printf( "XXXX: %s\n", pImage->szDebugPath );
                    if (idsl->CheckSum != pImage->dwCheckSum) {
                        printf( "XXX: *** WARNING: symbols checksum is wrong 0x%08x 0x%08x for %s\n",
                            pImage->dwCheckSum,
                            idsl->CheckSum,
                            pImage->szDebugPath
                            );
                    }
                    if (SymGetModuleInfo( pProcessCurrent->hProcess, idsl->BaseOfImage, &mi )) {
                        if (mi.SymType == SymNone) {
                            printf( "XXX: *** ERROR: Module load completed but symbols could not be loaded for %s\n",
                                pImage->szDebugPath
                                );
                        }
                    }
                    return TRUE;
                }
                pImage = pImage->pImageNext;
            }
            printf( "\n" );
#endif // 0
            break;

        case CBA_SYMBOLS_UNLOADED:
            idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD) CallbackData;
            FPRINTF( stderr, "Symbols unloaded for 0x%Ix %s\n",
                    idsl->BaseOfImage,
                    idsl->FileName
                    );
            return TRUE;

        case CBA_DUPLICATE_SYMBOL:
            idup = (PIMAGEHLP_DUPLICATE_SYMBOL) CallbackData;
            FPRINTF( stderr, "*** WARNING: Found %ld duplicate symbols for %s\n",
                                   idup->NumberOfDups,
                                   (idup->SelectedSymbol != (ULONG)-1) ? idup->Symbol[idup->SelectedSymbol].Name : "unknown symbol"
                         );
            return TRUE;

        default:
            return FALSE;
    }

    return FALSE;

} // SymbolCallBackFunction()

static PUCHAR
GetSymOptionsValues( DWORD SymOptions )
{
   static UCHAR values[160];

   values[0] = '\0';
   if ( SymOptions & SYMOPT_CASE_INSENSITIVE )   {
      (void)strcat( values, "CASE_INSENSITIVE " );
      SymOptions &= ~SYMOPT_CASE_INSENSITIVE;
   }
   if ( SymOptions & SYMOPT_UNDNAME )   {
      (void)strcat( values, "UNDNAME " );
      SymOptions &= ~SYMOPT_UNDNAME;
   }
   if ( SymOptions & SYMOPT_DEFERRED_LOADS )   {
      (void)strcat( values, "DEFERRED_LOADS " );
      SymOptions &= ~SYMOPT_DEFERRED_LOADS;
   }
   if ( SymOptions & SYMOPT_NO_CPP )   {
      (void)strcat( values, "NO_CPP " );
      SymOptions &= ~SYMOPT_NO_CPP;
   }
   if ( SymOptions & SYMOPT_LOAD_LINES )   {
      (void)strcat( values, "LOAD_LINES " );
      SymOptions &= ~SYMOPT_LOAD_LINES;
   }
   if ( SymOptions & SYMOPT_OMAP_FIND_NEAREST )   {
      (void)strcat( values, "OMAP_FIND_NEAREST " );
      SymOptions &= ~SYMOPT_OMAP_FIND_NEAREST;
   }
   if ( SymOptions & SYMOPT_DEBUG )   {
      (void)strcat( values, "DEBUG " );
      SymOptions &= ~SYMOPT_DEBUG;
   }
   if ( SymOptions )   {
      UCHAR uknValues[10];
      (void)sprintf( uknValues, "0x%x", SymOptions );
      (void)strcat( values, uknValues );
   }

   return( values );

} // GetSymOptionsValues()

typedef struct _uint64div  {
   unsigned __int64 quot;
   unsigned __int64 rem;
} uint64div_t;

typedef struct _int64div  {
   __int64 quot;
   __int64 rem;
} int64div_t;

void __cdecl UInt64Div (
	unsigned __int64  numer,
	unsigned __int64  denom,
   uint64div_t      *result
	)
{

   assert(result);

   if ( denom != (unsigned __int64)0 )   {
   	result->quot = numer / denom;
	   result->rem  = numer % denom;
   }
   else  {
      result->rem = result->quot = (unsigned __int64)0;
   }

	return;

} // UInt64Div()

void __cdecl Int64Div (
	__int64    numer,
	__int64    denom,
   int64div_t      *result
	)
{

   assert(result);

   if ( denom != (__int64)0 )   {
   	result->quot = numer / denom;
	   result->rem  = numer % denom;
	   if (numer < 0 && result->rem > 0) {
		   /* did division wrong; must fix up */
		   ++result->quot;
		   result->rem -= denom;
	   }
   }
   else  {
      result->rem = result->quot = (__int64)0;
   }

	return;

} // Int64Div()

#define UINT64_MAXDWORD    ((unsigned __int64)0xffffffff)

unsigned __int64 __cdecl
UInt64PerCent( unsigned __int64 Val, unsigned __int64 Denom )
{
   uint64div_t v;

   UInt64Div( 100*Val, Denom, &v );
//   printf("-%I64d-%I64d-%I64d-", UINT64_MAXDWORD, v.quot, v.rem );
   while ( v.rem > UINT64_MAXDWORD )   {
      v.quot++;
      v.rem -= UINT64_MAXDWORD;
   }
//   printf("-%I64d-%I64d-%I64d-", UINT64_MAXDWORD, v.quot, v.rem );
   return( v.quot );

} // UInt64PerCent()

//////////////////////////////////////////////////
//
// Main
//

int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    DWORD Error;
    PMODULE ModuleList;
    ULONG ActiveSource=(ULONG)-1;
    BOOLEAN Enabled;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoBegin[32];
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoEnd[32];
    NTSTATUS Status;
    TIME_FIELDS Time;
    LARGE_INTEGER Elapsed,Idle,Kernel,User;
    LARGE_INTEGER TotalElapsed, TotalIdle, TotalKernel, TotalUser;
    int i;
    PMODULE ZoomModule;

//// Beginning of Program-wide Assertions Section
//
//

    //
    // This code does not support UNICODE strings
    //

#if defined(UNICODE) || defined(_UNICODE)
#error This code does not support UNICODE strings!!!
#endif // UNICODE || _UNICODE

//
//
//// End of Program-wide Assertions Section

    //
    // Initialize profile source information & SourceMaximum
    //

    SourceMaximum = InitializeProfileSourceInfo();
    if ( ! SourceMaximum )   {
        FPRINTF( stderr, "KERNRATE: no profile source detected for this machine...\n" );
        return( (int)STATUS_NOT_IMPLEMENTED );
    }

    //
    // Get the default IMAGEHLP global option mask
    // NOTE: This global variable could be changed by GetConfigurations().
    //       It is required to initialize it before calling this function.
    //

    gSymOptions = SymGetOptions();
    if ( Verbose & VERBOSE_IMAGEHLP )   {
        FPRINTF( stderr, "KERNRATE: default IMAGEHLP SymOptions: %s\n", GetSymOptionsValues( gSymOptions ) );
    }

    //
    // Get initial parameters
    //

    GetConfiguration(argc, argv);

    //
    // Initialize dbghelp
    //
    // Note that gSymOptions could have been modified in GetConfiguration().
    //

    SymSetOptions( gSymOptions );
    if ( Verbose & VERBOSE_IMAGEHLP )   {
        FPRINTF( stderr, "KERNRATE: current IMAGEHLP SymOptions: %s\n", GetSymOptionsValues( gSymOptions ) );
    }

    Symbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL64);
    Symbol->MaxNameLength = MAX_SYMNAME_SIZE;
    SymInitialize( SymHandle, NULL, FALSE );

    if ( SymSetSearchPath(SymHandle, (LPSTR)0 ) == TRUE )   {

       // When SymSetSearchPath() is called with SearchPath as NULL, the following
       // symbol path default is used:
       //    .;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%;%WINDIR%

       if ( gUserSymbolPath[0] != '\0' )   {
          CHAR tmpPath[256];

          //
          // Note: We prepend the specified path to the current search path.
          //

          if ( SymGetSearchPath( SymHandle, tmpPath, sizeof( tmpPath ) ) == TRUE )   {

             strcpy( gSymbolPath, gUserSymbolPath );
             strcat( gSymbolPath, ";");
             strcat( gSymbolPath, tmpPath );
             if ( SymSetSearchPath( SymHandle, gSymbolPath ) != TRUE )   {
                FPRINTF( stderr, "KERNRATE: Failed to set the user specified symbol search path.\nUse default IMAGEHLP symbol search path...\n" );
             }

          }

       }

    }
    else  {
      FPRINTF( stderr, "KERNRATE: Failed to set the default symbol search path...\n" );

      //
      // Set the Symbol Search Path with "%WINDIR%" -
      // it was the behaviour of the original MS code...
      //

      GetEnvironmentVariable("windir", gSymbolPath, sizeof(gSymbolPath));
      SymSetSearchPath(SymHandle, gSymbolPath);

    }

    //
    // In any case [and it is redundant to do this in some of the previous cases],
    // but we want to be in sync, especially for the image and debug files checksum check.
    //

    if ( SymGetSearchPath( SymHandle, gSymbolPath, sizeof( gSymbolPath ) ) != TRUE )  {
       FPRINTF( stderr, "KERNRATE: Failed to get IMAGEHLP symbol files search path...\n" );
       //
       // The content of gSymbolPath is now undefined. so clean it...
       // gSymbolPath[] users have to check the content.
       //
       gSymbolPath[0] = '\0';
    }
    else if ( Verbose & VERBOSE_IMAGEHLP )  {
       FPRINTF( stderr, "KERNRATE: IMAGEHLP symbol search path: %s\n", gSymbolPath );
    }

    //
    // Register callbacks for some IMAGEHLP handle operations
    //

    if ( SymRegisterCallback64( SymHandle, SymbolCallbackFunction, (ULONG64)&gCurrentModule ) != TRUE )   {
       FPRINTF( stderr, "KERNRATE: Failed to register callback for IMAGEHLP handle operations...\n" );

    }

    //
    // Get information on kernel / process modules
    //

    if (SymHandle == (HANDLE)-1) {
        ModuleList = GetKernelModuleInformation();
    } else {
        ModuleList = GetProcessModuleInformation(SymHandle);
    }

    //
    // Any remaining entries on the ZoomList are liable to be errors.
    //

    ZoomModule = ZoomList;
    while (ZoomModule != NULL) {
        FPRINTF(stderr, "Zoomed module %s not found\n",ZoomModule->module_Name);
        ZoomModule = ZoomModule->Next;
    }
    ZoomList = NULL;

    //
    // Bypass any relevant security
    //

    RtlAdjustPrivilege(SE_SYSTEM_PROFILE_PRIVILEGE,
                       TRUE,
                       FALSE,
                       &Enabled);

    //
    // Create necessary profiles
    //

    CreateProfiles(ModuleList);

    //
    // Set priority up to realtime to minimize timing glitches.
    //

    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    //
    // Wait for test to complete.
    //

    SetConsoleCtrlHandler(CtrlcH,TRUE);
    CreateDoneEvent();

    if (SleepInterval == 0) {
        FPRINTF(stderr,"Waiting for ctrl-c\n");
    } else {
        FPRINTF(stderr, "Waiting for %d seconds\n", SleepInterval/1000);
    }
    Status = NtQuerySystemInformation(SystemBasicInformation,
                                      &BasicInfo,
                                      sizeof(BasicInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "Failed to query basic information %08lx\n",Status);
        exit(Status);
    }

    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      (PVOID)&SystemInfoBegin,
                                      sizeof(SystemInfoBegin),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "Failed to query starting processor performance information %08lx\n",Status);
        exit(Status);
    }
    do {
        ActiveSource = NextSource(ActiveSource, ModuleList);
        Error = WaitForSingleObject(DoneEvent, ChangeInterval);
    } while ( Error == WAIT_TIMEOUT );

    StopSource(ActiveSource, ModuleList);

    NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                             (PVOID)&SystemInfoEnd,
                             sizeof(SystemInfoEnd),
                             NULL);
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "Failed to query ending processor performance information %08lx\n",Status);
        exit(Status);
    }
    //
    // Reduce priority
    //

    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

    SetConsoleCtrlHandler(CtrlcH,FALSE);

    //
    // Restore privilege
    //

    RtlAdjustPrivilege(SE_SYSTEM_PROFILE_PRIVILEGE,
                       Enabled,
                       FALSE,
                       &Enabled);

    //
    // Output time information
    //

    TotalElapsed.QuadPart = 0;
    TotalIdle.QuadPart = 0;
    TotalKernel.QuadPart = 0;
    TotalUser.QuadPart = 0;
    for (i=0; i<BasicInfo.NumberOfProcessors; i++) {
        unsigned __int64 n;

        Idle.QuadPart    = SystemInfoEnd[i].IdleTime.QuadPart   - SystemInfoBegin[i].IdleTime.QuadPart;
        User.QuadPart    = SystemInfoEnd[i].UserTime.QuadPart   - SystemInfoBegin[i].UserTime.QuadPart;
        Kernel.QuadPart  = SystemInfoEnd[i].KernelTime.QuadPart - SystemInfoBegin[i].KernelTime.QuadPart;
        Elapsed.QuadPart = Kernel.QuadPart + User.QuadPart;
        Kernel.QuadPart -= Idle.QuadPart;

        TotalKernel.QuadPart  += Kernel.QuadPart;
        TotalUser.QuadPart    += User.QuadPart;
        TotalIdle.QuadPart    += Idle.QuadPart;
        TotalElapsed.QuadPart += Elapsed.QuadPart;
        printf("P%d   ",i);
        RtlTimeToTimeFields(&Kernel, &Time);
        n = UInt64PerCent( Kernel.QuadPart, Elapsed.QuadPart );
        printf("    K %ld:%02ld:%02ld.%03ld (%3I64u%%)",
               Time.Hour,
               Time.Minute,
               Time.Second,
               Time.Milliseconds,
               n );

        RtlTimeToTimeFields(&User, &Time);
        n = UInt64PerCent( User.QuadPart, Elapsed.QuadPart );
        printf("    U %ld:%02ld:%02ld.%03ld (%3I64u%%)",
               Time.Hour,
               Time.Minute,
               Time.Second,
               Time.Milliseconds,
               n );

        RtlTimeToTimeFields(&Idle, &Time);
        n = UInt64PerCent( Idle.QuadPart, Elapsed.QuadPart );
        printf("    I %ld:%02ld:%02ld.%03ld (%3I64u%%)\n",
               Time.Hour,
               Time.Minute,
               Time.Second,
               Time.Milliseconds,
               n );

    }

    if (BasicInfo.NumberOfProcessors > 1) {

       register int maxprocs = BasicInfo.NumberOfProcessors;
       unsigned __int64 n;

        // ULONG TotalElapsedTime = (ULONG)Elapsed.QuadPart * BasicInfo.NumberOfProcessors;
        printf("TOTAL");
        RtlTimeToTimeFields(&TotalKernel, &Time);
        n = UInt64PerCent( TotalKernel.QuadPart, TotalElapsed.QuadPart );
        printf("    K %ld:%02ld:%02ld.%03ld (%3I64u%%)",
               Time.Hour,
               Time.Minute,
               Time.Second,
               Time.Milliseconds,
               n );

        RtlTimeToTimeFields(&TotalUser, &Time);
        n = UInt64PerCent( TotalUser.QuadPart, TotalElapsed.QuadPart );
        printf("    U %ld:%02ld:%02ld.%03ld (%3I64u%%)",
               Time.Hour,
               Time.Minute,
               Time.Second,
               Time.Milliseconds,
               n );

        RtlTimeToTimeFields(&TotalIdle, &Time);
        n = UInt64PerCent( TotalIdle.QuadPart, TotalElapsed.QuadPart );
        printf("    I %ld:%02ld:%02ld.%03ld (%3I64u%%)\n",
               Time.Hour,
               Time.Minute,
               Time.Second,
               Time.Milliseconds,
               n );

    }

    //
    // Output results
    //

    OutputResults(stdout, ModuleList);

    //
    // Clean up allocated IMAGEHLP resources
    //

    (void)SymCleanup( SymHandle );

    //
    // Normal program exit
    //

    return(0);

} // main()

PMODULE
GetProcessModuleInformation(
    IN HANDLE ProcessHandle
    )
{
    PROCESS_BASIC_INFORMATION BasicInfo;
    PLIST_ENTRY LdrHead;
    PEB_LDR_DATA Ldr;
    PPEB_LDR_DATA LdrAddress;
    LDR_DATA_TABLE_ENTRY LdrEntry;
    PLDR_DATA_TABLE_ENTRY LdrEntryAddress;
    PLIST_ENTRY LdrNext;
    UNICODE_STRING Pathname;
    WCHAR PathnameBuffer[500];
    UNICODE_STRING fullPathName;
    WCHAR fullPathNameBuffer[_MAX_PATH*sizeof(WCHAR)];
    PEB Peb;
    NTSTATUS Status;
    BOOL Success;
    PMODULE NewModule;
    PMODULE Root=NULL;
    CHAR ModuleName[100];
    CHAR moduleFullName[_MAX_PATH];
    ANSI_STRING AnsiString;

    //
    // Get Peb address.
    //

    Status = NtQueryInformationProcess(ProcessHandle,
                                       ProcessBasicInformation,
                                       &BasicInfo,
                                       sizeof(BasicInfo),
                                       NULL
                                       );
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "NtQueryInformationProcess failed status %08lx\n",Status);
        return NULL;
    }
    if (BasicInfo.PebBaseAddress == NULL) {
        FPRINTF(stderr, "GetProcessModuleInformation: process has no Peb.\n");
        return NULL;
    }

    //
    // Read Peb to get Ldr.
    //

    Success = ReadProcessMemory(ProcessHandle,
                                BasicInfo.PebBaseAddress,
                                &Peb,
                                sizeof(Peb),
                                NULL);
    if (!Success) {
        FPRINTF(stderr, "ReadProcessMemory to get the PEB failed, error %d\n", GetLastError());
        return(NULL);
    }

    LdrAddress = Peb.Ldr;
    if (LdrAddress == NULL) {
        FPRINTF(stderr, "Process's LdrAddress is NULL\n");
        return(NULL);
    }

    //
    // Read Ldr to get Ldr entries.
    //

    Success = ReadProcessMemory(ProcessHandle,
                                LdrAddress,
                                &Ldr,
                                sizeof(Ldr),
                                NULL);
    if (!Success) {
        FPRINTF(stderr, "ReadProcessMemory to get Ldr entries failed, errror %d\n", GetLastError());
        return(NULL);
    }

    //
    // Read Ldr table entries to get image information.
    //

    if (Ldr.InLoadOrderModuleList.Flink == NULL) {
        FPRINTF(stderr, "Ldr.InLoadOrderModuleList == NULL\n");
        return(NULL);
    }
    LdrHead = &LdrAddress->InLoadOrderModuleList;
    Success = ReadProcessMemory(ProcessHandle,
                                &LdrHead->Flink,
                                &LdrNext,
                                sizeof(LdrNext),
                                NULL);
    if (!Success) {
        FPRINTF(stderr, "ReadProcessMemory to get Ldr head failed, errror %d\n", GetLastError());
        return(NULL);
    }

    //
    // Loop through InLoadOrderModuleList.
    //

    while (LdrNext != LdrHead) {
        LdrEntryAddress = CONTAINING_RECORD(LdrNext,
                                            LDR_DATA_TABLE_ENTRY,
                                            InLoadOrderLinks);
        Success = ReadProcessMemory(ProcessHandle,
                                    LdrEntryAddress,
                                    &LdrEntry,
                                    sizeof(LdrEntry),
                                    NULL);
        if (!Success) {
            FPRINTF(stderr, "ReadProcessMemory to get LdrEntry failed, errror %d\n", GetLastError());
            return(NULL);
        }

        //
        // Get copy of image name.
        //

        Pathname = LdrEntry.BaseDllName;
        Pathname.Buffer = &PathnameBuffer[0];
        Success = ReadProcessMemory(ProcessHandle,
                                    LdrEntry.BaseDllName.Buffer,
                                    Pathname.Buffer,
                                    Pathname.MaximumLength,
                                    NULL);
        if (!Success) {
            FPRINTF(stderr, "ReadProcessMemory to get image name failed, errror %d\n", GetLastError());
            return(NULL);
        }

        //
        // Get Copy of image full pathname
        //

        fullPathName = LdrEntry.FullDllName;
        fullPathName.Buffer = fullPathNameBuffer;
        Success = ReadProcessMemory( ProcessHandle,
                                     LdrEntry.FullDllName.Buffer,
                                     fullPathName.Buffer,
                                     fullPathName.MaximumLength,
                                     NULL
                                   );

        //
        // Create module
        //
        AnsiString.Buffer = ModuleName;
        AnsiString.MaximumLength = sizeof(ModuleName);
        AnsiString.Length = 0;
        RtlUnicodeStringToAnsiString(&AnsiString, &Pathname, cDONOT_ALLOCATE_DESTINATION_STRING);
        ModuleName[AnsiString.Length] = '\0';

        AnsiString.Buffer = moduleFullName;
        AnsiString.MaximumLength = sizeof(moduleFullName);
        AnsiString.Length = 0;
        RtlUnicodeStringToAnsiString(&AnsiString, &fullPathName, cDONOT_ALLOCATE_DESTINATION_STRING );

        NewModule = CreateNewModule(ProcessHandle,
                                    ModuleName,
                                    moduleFullName,
                                    (ULONG_PTR)LdrEntry.DllBase,
                                    LdrEntry.SizeOfImage);

        ModuleCount += 1;
        NewModule->Next = Root;
        Root = NewModule;

        LdrNext = LdrEntry.InLoadOrderLinks.Flink;
    }

    return(Root);

} // GetProcessModuleInformation()

PMODULE
GetKernelModuleInformation(
    VOID
    )
{
    PRTL_PROCESS_MODULES modules;
    PUCHAR buffer;
    ULONG bufferSize = 32*1024*1024;
    PMODULE root=NULL;
    PMODULE newModule;
    NTSTATUS status;
    ULONG i;
    PLIST_ENTRY ListEntry;
    SYSTEM_BASIC_INFORMATION SystemInformation;
    ULONG_PTR HighestUserAddress;

    while (TRUE) {
        buffer = malloc(bufferSize);
        if (buffer == NULL) {
            FPRINTF(stderr, "Module buffer allocation failed\n");
            exit(0);
        }

        status = NtQuerySystemInformation(SystemModuleInformation,
                                          buffer,
                                          bufferSize,
                                          &bufferSize);
        if (NT_SUCCESS(status)) {
            break;
        }
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            free(buffer);
            continue;
        }
    }

    status = NtQuerySystemInformation(SystemBasicInformation,
                                      &SystemInformation,
                                      sizeof(SystemInformation),
                                      NULL);
    if (!NT_SUCCESS(status)) {
        FPRINTF(stderr, "NtQuerySystemInformation failed status %08lx\n",status);
        return NULL;
    }
    HighestUserAddress = SystemInformation.MaximumUserModeAddress;

#ifdef _WIN64
#define VerboseModuleFormat "start            end              "
#else  // !_WIN64
#define VerboseModuleFormat "start        end          "
#endif // !_WIN64

VerbosePrint(( VERBOSE_MODULES, "Kernel Modules ========== System HighestUserAddress = 0x%Ix\n"
                                VerboseModuleFormat
                                "module name [full name]\n",
                                HighestUserAddress
            ));

#undef VerboseModuleFormat

    modules = (PRTL_PROCESS_MODULES)buffer;
    ModuleCount = modules->NumberOfModules;
    for (i=0; i < ModuleCount; i++) {
        PRTL_PROCESS_MODULE_INFORMATION Module;
        Module = &modules->Modules[i];

        if ((ULONG_PTR)Module->ImageBase > HighestUserAddress) {
            newModule = CreateNewModule(NULL,
                                        Module->FullPathName+Module->OffsetToFileName,
                                        Module->FullPathName,
                                        (ULONG_PTR)Module->ImageBase,
                                        Module->ImageSize);
            assert( newModule );
            newModule->Next = root;
            root = newModule;
        }
        else  {

#ifdef _WIN64
#define VerboseModuleFormat "0x%016x 0x%16x "
#else  // !_WIN64
#define VerboseModuleFormat "0x%08x 0x%08x "
#endif // !_WIN64

VerbosePrint(( VERBOSE_MODULES, VerboseModuleFormat " %s [%s] - Base > HighestUserAddress\n",
                                (ULONG_PTR)newModule->Base,
                                (ULONG_PTR)(newModule->Base + (ULONG64)newModule->Length),
                                newModule->module_Name,
                                ModuleFullName( newModule )
            ));

#undef VerboseModuleFormat

        }
    }

    return(root);

} // GetKernelModuleInformation()

VOID
CreateProfiles(
    IN PMODULE Root
    )
{
    PMODULE Current;
    KPROFILE_SOURCE ProfileSource;
    NTSTATUS Status;
    PRATE_DATA Rate;
    ULONG  ProfileSourceIndex;

    for (ProfileSourceIndex=0; ProfileSourceIndex  < SourceMaximum != 0; ProfileSourceIndex++) {
        ProfileSource = Source[ProfileSourceIndex].ProfileSource;
        if (Source[ProfileSourceIndex].Interval != 0) {
            Current = Root;
            while (Current != NULL) {
                Rate = &Current->Rate[ProfileSourceIndex];
                Rate->StartTime = 0;
                Rate->TotalTime = 0;
                Rate->TotalCount = 0;
                Rate->CurrentCount = 0;
                if (Current->Zoom) {
                    Rate->ProfileBuffer = malloc((Current->Length / ZOOM_BUCKET)*sizeof(ULONG));
                    if (Rate->ProfileBuffer == NULL) {
                        FPRINTF(stderr,
                                "Zoom buffer allocation for %s failed\n",
                                Current->module_Name);
                        exit(1);
                    }
                    ZeroMemory(Rate->ProfileBuffer, sizeof(ULONG)*(Current->Length / ZOOM_BUCKET));
                    Status = NtCreateProfile(&Rate->ProfileHandle,
                                             Current->Process,
                                             (PVOID)Current->Base,
                                             Current->Length,
                                             LOG2_ZOOM_BUCKET,
                                             Rate->ProfileBuffer,
                                             sizeof(ULONG)*(Current->Length / ZOOM_BUCKET),
                                             ProfileSource,
                                             (KAFFINITY)-1);
                    if (!NT_SUCCESS(Status)) {
                        FPRINTF(stderr,
                                "NtCreateProfile on zoomed module %s, source %d failed %08lx\n",
                                Current->module_Name,
                                ProfileSource,
                                Status);
                        FPRINTF(stderr,
                                "Base %p\nLength %08lx\nBufferLength %08lx\n",
                                 (PVOID)Current->Base,
                                 Current->Length,
                                 Current->Length / ZOOM_BUCKET);

                        exit(1);
                    }
                    else if ( Verbose & VERBOSE_PROFILING )   {
                        FPRINTF(stderr,
                                "Created zoomed profiling on module %s with source: %s\n",
                                Current->module_Name,
                                Source[ProfileSourceIndex].ShortName
                                );
                    }
                } else {
                    Status = NtCreateProfile(&Rate->ProfileHandle,
                                             Current->Process,
                                             (PVOID)Current->Base,
                                             Current->Length,
                                             31,
                                             &Rate->CurrentCount,
                                             sizeof(Rate->CurrentCount),
                                             ProfileSource,
                                             (KAFFINITY)-1);
                    if (!NT_SUCCESS(Status)) {
                        FPRINTF(stderr,
                                "NtCreateProfile on module %s, source %d failed %08lx\n",
                                Current->module_Name,
                                ProfileSource,
                                Status);
                        exit(1);
                    }
                    else if ( Verbose & VERBOSE_PROFILING )   {
                        FPRINTF(stderr,
                                "Created profiling on module %s with source: %s\n",
                                Current->module_Name,
                                Source[ProfileSourceIndex].ShortName
                                );
                    }
                }
                Current = Current->Next;
            }
        }
    }
}

static void
SetModuleName( PMODULE Module, PUCHAR szName )
{

    assert ( Module );
    assert ( szName );

    (void)strncpy( Module->module_Name, szName, sizeof(Module->module_Name) - 1 );
    Module->module_Name[strlen(Module->module_Name)] = '\0';

    return;

} // SetModuleName()

VOID
GetConfiguration(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Gets configuration for this run.

Arguments:

    None

Return Value:

    None, exits on failure.

--*/

{
    KPROFILE_SOURCE ProfileSource;
    NTSTATUS Status;
    PMODULE ZoomModule;
    DWORD Pid;
    int i;
    ULONG ProfileSourceIndex;

    for (i=1; i < argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch ( toupper(argv[i][1]) ) {

                case 'B':
                    //
                    // Set Zoom Bucket Size
                    //
                    if (++i == argc) {
                        FPRINTF(stderr,
                                "KERNRATE: '-b N' option requires bucket size\n");
                        Usage();
                    }
                    ZOOM_BUCKET = (ULONG)atoi(argv[i]);
                    if (ZOOM_BUCKET == 0) {
                        FPRINTF(stderr,
                                "KERNRATE: Invalid option '-b %s'\n",
                                argv[i]);
                        Usage();
                    }
                    for (LOG2_ZOOM_BUCKET=1; (1UL<<LOG2_ZOOM_BUCKET) < ZOOM_BUCKET; LOG2_ZOOM_BUCKET++)
                        // Empty Loop
                        ;
    
                    if (ZOOM_BUCKET != (1UL<<LOG2_ZOOM_BUCKET)) {
                        FPRINTF(stderr,
                                "KERNRATE: Bucket size must be power of 2\n");
                        Usage();
                    }
                    break;

                case 'C':
                    //
                    // Set change interval.
                    //
                    if (++i == argc) {
                        FPRINTF(stderr,
                                "KERNRATE: '-c N' option requires milliseconds\n");
                        Usage();
                    }
                    ChangeInterval = atoi(argv[i]);
                    if (ChangeInterval == 0) {
                        FPRINTF(stderr,
                                "KERNRATE: Invalid option '-c %s'\n",
                                argv[i]);
                        Usage();
                    }
                    break;

                case 'D':
                    //
                    // Output data rounding up and down
                    //
                    RoundingVerboseOutput = TRUE;
                    break;

                case 'I':
                   {
                     BOOLEAN found;
                     ULONG rate;

                     if ( ++i == argc )   {
                        FPRINTF(stderr,  "KERNRATE: '-i' option requires at least a rate value\n");
                        Usage();
                     }

                     //
                     // The user can specify '-i' with a rate only.
                     // In this case, SOURCE_TIME is used.
                     //

                     if ( !isalpha( argv[i][0] ) )   {
                        rate = (ULONG)atol(argv[i]);
                        if (rate == 0) {
                            FPRINTF(stderr,
                                    "KERNRATE: Invalid option '-i %s'\n",
                                    argv[i]);
                            Usage();
                        }
                        Source[SOURCE_TIME].Interval = rate;
                        break;
                     }

                     //
                     // Standard option processing:
                     // the source shortname string is specified.
                     //

                     if ( (i + 1) == argc )  {
                        FPRINTF(stderr,  "KERNRATE: '-i' option requires a source and a rate\n");
                        Usage();
                     }
                     found = FALSE;
                     for ( ProfileSourceIndex = 0; ProfileSourceIndex < SourceMaximum; ProfileSourceIndex++)   {
                        if ( !_stricmp(Source[ProfileSourceIndex].ShortName, argv[i]) )    {
                           rate = (ULONG)atol(argv[i + 1]);
                           Source[ProfileSourceIndex].Interval = rate;
                           found = TRUE;
                           i++;
                        }
                     }
                     if ( found == FALSE)   {
                        FPRINTF(stderr,
                        "KERNRATE: Invalid source name %s.\nRun KERNRATE with the '-l' option to list supported sources.\n", argv[i] );
                        Usage();
                     }
                   }
                   break;

                case 'J':
                    //
                    // User specified symbol search path.
                    // It is going to be prepend to the default image help symbol search path.
                    //

                    if (++i == argc)   {
                        FPRINTF(stderr,
                                "KERNRATE: '-j SymbolPath' option requires SymbolPath\n");
                        Usage();
                    }
                    strncpy( gUserSymbolPath, argv[i], sizeof( gUserSymbolPath ) - 1);
                    break;

                case 'L':
                     {
                        PSOURCE src;

                        printf("List of profile sources supported for this platform:\n\n");
                        printf("%*s - %-*s - %-10s\n\n", DescriptionMaxLen, "Name", TokenMaxLen, "ShortName", "Interval");

                        //
                        // Print the possible static sources.
                        // static in the sense of NT KE fixed sources.
                        //

                        for ( ProfileSourceIndex = 0; ProfileSourceIndex < ProfileMaximum; ProfileSourceIndex++ )   {

                            src = &Source[ProfileSourceIndex];

                            //
                            // Display the supported profile sources, only.
                            //

                            if ( src->DesiredInterval )  {
                                printf( "%*s - %-*s - %-10ld\n", DescriptionMaxLen,
                                                                 src->Name,
                                                                 TokenMaxLen,
                                                                 src->ShortName,
                                                                 src->DesiredInterval
                                      );
                            }
                        }

                        //
                        // Print the possible dynamic sources.
                        //

                        while( ProfileSourceIndex < SourceMaximum )   {

                            src = &Source[ProfileSourceIndex];

                            //
                            // Display the supported profile sources, only.
                            //

                            if ( src->DesiredInterval )  {
                                printf( "%*s - %-*s - %-10ld\n", DescriptionMaxLen,
                                                                 src->Name,
                                                                 TokenMaxLen,
                                                                 src->ShortName,
                                                                 src->DesiredInterval
                                      );
                            }

                            ProfileSourceIndex++;
                        }

                        //
                        // If the user specified '-lx', we exit immediately.
                        //

                        if ( ( argv[i][2] == 'x' ) || ( argv[i][2] == 'X' )) {
                           exit(0);
                        }

                        printf("\n");
                     }
                     break;

                case 'P':
                    //
                    // Monitor given process instead of kernel
                    //
                    if (++i == argc) {
                        FPRINTF(stderr,
                                "KERNRATE: '-p processid' option requires a process id\n");
                        Usage();
                    }
                    Pid = atoi(argv[i]);
                    SymHandle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
                                            FALSE,
                                            Pid);
                    if (SymHandle==NULL) {
                        FPRINTF(stderr, "KERNRATE: OpenProcess(%d) failed %d\n",Pid,GetLastError());
                        exit(0);
                    }
                    break;

                case 'R':
                    //
                    // Turn on RAW bucket dump
                    //
                    RawData = TRUE;

                    //
                    // If the user specified '-rd', we want to output disassembly with the raw data.
                    //

                    if ( ( argv[i][2] == 'd' ) || ( argv[i][2] == 'D' )) {
                        RawDisasm = TRUE;
                    }
                    break;

                case 'S':
                    //
                    // Set Sleep interval
                    //
                    if (++i == argc) {
                        FPRINTF(stderr,
                                "KERNRATE: '-s N' option requires seconds\n");
                        Usage();
                    }
                    SleepInterval = atoi(argv[i]) * 1000;
                    if (SleepInterval == 0) {
                        FPRINTF(stderr,
                                "KERNRATE: Invalid option '-s %s'\n",
                                argv[i]);
                        Usage();
                    }
                    break;

                case 'U':
                    //
                    // Requests IMAGEHLP to present undecorated symbol names
                    //
                    gSymOptions |= SYMOPT_UNDNAME;
                    break;

                case 'V':
                    //
                    // Verbose mode.
                    //

                    Verbose = VERBOSE_DEFAULT;
                    if ( ((i+1) < argc) && (argv[i+1][0] != '-') ) {
                        i++;
                        Verbose = atoi(argv[i]);
                    }
                    if ( Verbose & VERBOSE_IMAGEHLP )   {
                        gSymOptions |= SYMOPT_DEBUG;
                    }
                    break;

                case 'Z':
                    if (++i == argc) {
                        FPRINTF(stderr,
                                "KERNRATE: '-z modulename' option requires modulename\n");
                        Usage();
                    }
                    ZoomModule = calloc(1, sizeof(MODULE)+sizeof(RATE_DATA)*SourceMaximum);
                    if (ZoomModule==NULL) {
                        FPRINTF(stderr, "Allocation of zoom module %s failed\n",argv[i]);
                        exit(1);
                    }
                    SetModuleName( ZoomModule, argv[i] );
                    ZoomModule->Zoom = TRUE;
                    ZoomModule->Next = ZoomList;
                    ZoomList = ZoomModule;
                    break;

                case '?':
                    //
                    // Print Usage string and exits
                    //
                    Usage();
                    break;

                default:
                    //
                    // Specify the unknown option and print the Usage string. Then exists.
                    //
                    FPRINTF(stderr,
                            "KERNRATE: Unknown option %s\n",argv[i]);
                    Usage();
                    break;
            }
        } else {
            FPRINTF(stderr,
                    "KERNRATE: Invalid switch %s\n",argv[i]);
            Usage();
        }
    }

    //
    // Determine supported sources
    //

    for (ProfileSourceIndex = 0; ProfileSourceIndex < SourceMaximum; ProfileSourceIndex++) {
      if ( Source[ProfileSourceIndex].DesiredInterval && Source[ProfileSourceIndex].Interval )   {
         ULONG ThisInterval;

         ProfileSource = Source[ProfileSourceIndex].ProfileSource;
         NtSetIntervalProfile(Source[ProfileSourceIndex].DesiredInterval, ProfileSource);
         Status = NtQueryIntervalProfile(ProfileSource, &ThisInterval);
         if ((NT_SUCCESS(Status)) && (ThisInterval > 0)) {
            printf("Recording %s at %d events/hit\n", Source[ProfileSourceIndex].Name, ThisInterval);
            Source[ProfileSourceIndex].Interval = ThisInterval;
         } else {
            Source[ProfileSourceIndex].Interval = 0;
         }
      }
      else   {
         Source[ProfileSourceIndex].Interval = 0;
      }
    }

    return;

} /* GetConfiguration() */

PSOURCE
InitializeStaticSources(
    VOID
    )
{
#if defined(_IA64_)
    NTSTATUS                     status;
    SYSTEM_PROCESSOR_INFORMATION sysProcInfo;

    status = NtQuerySystemInformation( SystemProcessorInformation,
                                       &sysProcInfo,
                                       sizeof(SYSTEM_PROCESSOR_INFORMATION),
                                       NULL);

    if (NT_SUCCESS(status) && (sysProcInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) ) {

        switch( sysProcInfo.ProcessorLevel ) {
            case IA64_MERCED:
                {
                    //
                    // Patch the last entry as defined with convention used to initialize
                    // SourceMaximum.
                    //

                    ULONG n = sizeof(mercedStaticSources)/sizeof(mercedStaticSources[0]);
                    mercedStaticSources[n-1].Name       = NULL;
                    mercedStaticSources[n-1].ShortName  = "";
                }
                return mercedStaticSources;
                break;

            case IA64_MCKINLEY:
                // Thierry - 02/08/2000 - use default for now.
                break;
        }

    }

    //
    // NtQuerySystemInformation() failure and default case:
    //
#endif // _IA64_

    return StaticSources;

} // InitializeStaticSources()

ULONG
InitializeProfileSourceInfo (
    VOID
    )
/*++

Function Description:

    This function initializes the Profile sources.

Argument:

    None.

Return Value:

    None.

Algorithm:

    ToBeSpecified

In/Out Conditions:

    ToBeSpecified

Globals Referenced:

    ToBeSpecified

Exception Conditions:

    ToBeSpecified

MP Conditions:

    ToBeSpecified

Notes:

    This function has been enhanced from its original version
    to support and use the static profiling sources even if the
    pstat driver is not present or returned no active profiling
    event.

ToDo List:

    ToBeSpecified

Modification History:

    3/17/2000  TF  Initial version

--*/
{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       buffer[400];
    ULONG                       i, j;
    PEVENTID                    Event;
    HANDLE                      DriverHandle;
    PEVENTS_INFO                eventInfo;
    PSOURCE                     staticSource, src;
    ULONG                       staticCount, driverCount, totalCount;

    //
    // Initializations
    //

    DriverHandle = INVALID_HANDLE_VALUE;
    staticCount = driverCount = 0;

    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if ( NT_SUCCESS(status) ) {

        //
        // Determine how many events the driver provides
        //

        eventInfo = (PEVENTS_INFO)buffer;

        status = NtDeviceIoControlFile( DriverHandle,
                                        (HANDLE) NULL,          // event
                                        (PIO_APC_ROUTINE) NULL,
                                        (PVOID) NULL,
                                        &IOSB,
                                        PSTAT_QUERY_EVENTS_INFO,
                                        buffer,                 // input buffer
                                        sizeof (buffer),
                                        NULL,                   // output buffer
                                        0
                                      );

        driverCount = eventInfo->Events;
        if ( NT_SUCCESS(status) && driverCount ) {
            if ( eventInfo->TokenMaxLength > TokenMaxLen )  {
               TokenMaxLen = eventInfo->TokenMaxLength;
            }
            if ( eventInfo->DescriptionMaxLength > DescriptionMaxLen )  {
               DescriptionMaxLen = eventInfo->DescriptionMaxLength;
            }
        }

    }

    //
    // Determine how many static events there are and
    // re-initialize the format specifiers if needed.
    //

    src = staticSource = InitializeStaticSources();
    assert( staticSource );
    while( src->Name != NULL ) {
        if ( strlen( src->Name ) > DescriptionMaxLen )   {
            DescriptionMaxLen = strlen( src->Name );
        }
        if ( strlen( src->ShortName ) > TokenMaxLen )   {
            TokenMaxLen = strlen( src->ShortName );
        }
        staticCount++;
        src++;
    }

    //
    // Allocate memory for static events, plus the driver
    // provided events
    //

    totalCount = driverCount + staticCount;
    Source = malloc(sizeof(SOURCE) * totalCount);
    if ( Source == NULL )   {
        FPRINTF(stderr, "KERNRATE: Events memory allocation failed\n" );
        if ( IsValidHandle( DriverHandle ) )    {
            NtClose (DriverHandle);
        }
        exit(1);
    }
    ZeroMemory (Source, sizeof(SOURCE) * totalCount);

    //
    // copy static events to new list
    //

    for (j=0; j < staticCount; j++) {
        Source[j] = staticSource[j];
    }

    //
    // Append the driver provided events to new list
    //

    if ( IsValidHandle( DriverHandle ) ) {
        Event = (PEVENTID) buffer;
        for (i=0; i < driverCount; i++) {
            *((PULONG) buffer) = i;
            NtDeviceIoControlFile(
               DriverHandle,
               (HANDLE) NULL,          // event
               (PIO_APC_ROUTINE) NULL,
               (PVOID) NULL,
               &IOSB,
               PSTAT_QUERY_EVENTS,
               buffer,                 // input buffer
               sizeof (buffer),
               NULL,                   // output buffer
               0
               );

            //
            // Source Names:
            //   - For the Name, we use the description
            //   - For the short Name, we use the token string stored
            //     in the first string of the buffer
            //

            Source[j].Name = _strdup (Event->Buffer + Event->DescriptionOffset);
            Source[j].ShortName = _strdup(Event->Buffer);

            Source[j].ProfileSource = Event->ProfileSource;
            Source[j].DesiredInterval = Event->SuggestedIntervalBase;
            j++;
        }

        NtClose (DriverHandle);
    }

    return( totalCount );

} // InitializeProfileSourceInfo()

ULONG
NextSource(
    IN ULONG CurrentSource,
    IN PMODULE ModuleList
    )

/*++

Routine Description:

    Stops the current profile source and starts the next one.

    If a CurrentSource of -1 is passed in, no source will
    be stopped and the first active source will be started.

Arguments:

    CurrentSource - Supplies the current profile source

    ModuleList - Supplies the list of modules whose soruces are to be changed

Return Value:

    Returns the new current profile source

--*/

{
    if (CurrentSource != (ULONG) -1) {
        StopSource(CurrentSource, ModuleList);
    }

    //
    // Iterate through the available sources to find the
    // next active source to be started.
    //
    do {
        if (CurrentSource == (ULONG) -1) {
            CurrentSource = 0;
        } else {
            CurrentSource = CurrentSource+1;
            if (CurrentSource == SourceMaximum) {
                CurrentSource = 0;
            }
        }
    } while ( Source[CurrentSource].Interval == 0);

    StartSource(CurrentSource,ModuleList);

    return(CurrentSource);
}


VOID
StopSource(
    IN ULONG ProfileSourceIndex,
    IN PMODULE ModuleList
    )

/*++

Routine Description:

    Stops all profile objects for a given source

Arguments:

    ProfileSource - Supplies the source to be stopped.

    ModuleList - Supplies the list of modules whose profiles are to be stopped

Return Value:

    None.

--*/

{
    PMODULE Current;
    NTSTATUS Status;
    ULONGLONG StopTime;
    ULONGLONG ElapsedTime;

    Current = ModuleList;
    while (Current != NULL) {
        Status = NtStopProfile(Current->Rate[ProfileSourceIndex].ProfileHandle);
        GetSystemTimeAsFileTime((LPFILETIME)&StopTime);
        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr,
                    "NtStopProfile on source %s failed, %08lx\n",
                    Source[ProfileSourceIndex].Name,
                    Status);
        } else {
            ElapsedTime = StopTime - Current->Rate[ProfileSourceIndex].StartTime;
            Current->Rate[ProfileSourceIndex].TotalTime += ElapsedTime;
            Current->Rate[ProfileSourceIndex].TotalCount += Current->Rate[ProfileSourceIndex].CurrentCount;
            Current->Rate[ProfileSourceIndex].CurrentCount = 0;
        }
        Current = Current->Next;
    }
}


VOID
StartSource(
    IN ULONG ProfileSourceIndex,
    IN PMODULE ModuleList
    )

/*++

Routine Description:

    Starts all profile objects for a given source

Arguments:

    ProfileSource - Supplies the source to be started.

    ModuleList - Supplies the list of modules whose profiles are to be stopped

Return Value:

    None.

--*/

{
    PMODULE Current;
    NTSTATUS Status;
    ULONGLONG StopTime;
    ULONGLONG ElapsedTime;

    Current = ModuleList;
    while (Current != NULL) {
        GetSystemTimeAsFileTime((LPFILETIME)&Current->Rate[ProfileSourceIndex].StartTime);
        Status = NtStartProfile(Current->Rate[ProfileSourceIndex].ProfileHandle);
        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr,
                    "NtStartProfile on source %s failed, %08lx\n",
                    Source[ProfileSourceIndex].Name,
                    Status);
        }
        Current = Current->Next;
    }
}


VOID
OutputResults(
    IN FILE *Out,
    IN PMODULE ModuleList
    )

/*++

Routine Description:

    Outputs the collected data.

Arguments:

    Out - Supplies the FILE * where the output should go.

    ModuleList - Supplies the list of modules to output

Return Value:

    None.

--*/

{
    PMODULE Current;
    PRATE_DATA RateData;
    ULONG i, j, ProfileSourceIndex;
    ULONG RoundDown;

    //
    // Sum up the total buffers of any zoomed modules
    //
    Current = ModuleList;
    while (Current != NULL) {
        if (Current->Zoom) {
            for (ProfileSourceIndex=0; ProfileSourceIndex < SourceMaximum; ProfileSourceIndex++) {
                if (Source[ProfileSourceIndex].Interval != 0) {
                    //
                    // Sum the entire profile buffer for this module/source
                    //
                    RateData = &Current->Rate[ProfileSourceIndex];
                    RateData->TotalCount = 0;
                    for (i=0; i < Current->Length/ZOOM_BUCKET; i++) {
                        RateData->TotalCount += RateData->ProfileBuffer[i];
                    }
                }
            }
        }
        Current = Current->Next;
    }

    //
    // Output the results ordered by profile source.
    //
    OutputModuleList(Out, ModuleList, ModuleCount);

    //
    // For any zoomed modules, create and output a module list
    // consisting of the functions in the module.
    //
    Current = ModuleList;
    while (Current != NULL) {
        if (Current->Zoom) {
            ZoomCount = 0;
            ZoomList = NULL;
            for (RoundDown = 0; RoundDown <= (RoundingVerboseOutput ? 1UL:0UL); RoundDown++) {
                CreateZoomedModuleList(Current,RoundDown);
            if (ZoomList == NULL) {
                FPRINTF(stderr, "No symbols found for module %s\n",Current->module_Name);
            } else {
                PMODULE Temp;

                FPRINTF(Out, "\n----- Zoomed module %s (Bucket size = %d bytes, Rounding %s) --------\n",
                        Current->module_Name,
                        ZOOM_BUCKET,
                        (RoundDown ? "Up" : "Down" ) );
                OutputModuleList(Out, ZoomList, ZoomCount);
                Temp = ZoomList;
                while (Temp != NULL) {
                    ZoomList = ZoomList->Next;
                    free(Temp);
                    Temp = ZoomList;
                }
            }

           }
        }
        Current = Current->Next;
    }

    if (RawData) {
        //
        // Display the raw bucket counts for all zoomed modules
        //
        Current = ModuleList;
        while (Current != NULL) {
            if (Current->Zoom) {
                for (ProfileSourceIndex=0; ProfileSourceIndex < SourceMaximum; ProfileSourceIndex++) {
                    if (Source[ProfileSourceIndex].Interval != 0) {
                        FPRINTF(Out,
                                "\n---- RAW %s Profile Source %s\n",
                                Current->module_Name,
                                Source[ProfileSourceIndex].Name);
                        RateData = &Current->Rate[ProfileSourceIndex];
                        for (i=0; i < (Current->Length/ZOOM_BUCKET) ; i++) {

                            ULONG hits = RateData->ProfileBuffer[i];

                            if ( hits > 0 ) {

                                // TF - FIXFIX - 07/2000.
                                // The current version of kernrate and kernel profiling objects code 
                                // assume code section < 4GB.
                                //

                                ULONG64 ip = Current->Base + (ULONG64)(i * ZOOM_BUCKET);
                                ULONG64 disp = 0;

                                if ( !SymGetSymFromAddr64(SymHandle, ip, &disp, Symbol ) ) {
                                    FPRINTF( stderr, "No symbol found for bucket at 0x%I64x\n", ip );
                                } 
                                else {

                                    CHAR symName[80];
                                    ULONG64 ipMax;

                                    _snprintf( symName, 80, "%s+0x%I64x[0x%I64x]", Symbol->Name, disp, ip );
                                    if ( RawDisasm )   {
                                        CHAR sourceCode[320];

#ifndef DISASM_AVAILABLE
// Thierry - FIXFIX - 07/2000.
// dbg is not helping... The old disassembly APIs no longer work.
// I have to re-write a full disassembly wrapper.
#define Disasm( IpAddr, Buffer, Flag ) 0
#endif // !DISASM_AVAILABLE

                                        if ( Disasm( &ip, sourceCode, FALSE ) ) {
                                           FPRINTF( Out,"%-40s %10d %s\n", symName, hits, sourceCode );
                                        }
                                        else {
                                           FPRINTF( Out,"%-40s %10d <disasm:?????>\n", symName, hits );

                                        }

                                    }
                                    else    {
                                        FPRINTF( Out,"%-40s %10d\n", symName, hits );
                                    }
                                    
                                    //
                                    // Print other symbols in this bucket by incrementing
                                    // by 2 bytes at a time.
                                    //

                                    ipMax  = ip + (ULONG64)ZOOM_BUCKET;
                                    ip    += (ULONG64)2;
                                    while( ip < ipMax ) {

                                        UCHAR lastSym[80];

                                        strcpy( lastSym, Symbol->Name );
                                        if ( SymGetSymFromAddr64(SymHandle, ip, &disp , Symbol ) ) {
                                            if ( strcmp( lastSym,Symbol->Name ) ) {
                                                FPRINTF( Out, "    %s+0x%I64x[0x%I64x]\n", Symbol->Name, disp, ip );
                                                strcpy( lastSym,Symbol->Name );
                                            }
                                        }
                                        ip += (ULONG64)2;

                                    } // End of while( ip < ipMax )
                                }
                            }
                        }
                    }
                }
            }
            Current = Current->Next;
        }
    }

    return;

} // OutputResults()

BOOL
CreateZoomModuleCallback(
    IN LPSTR szSymName,
    IN ULONG64 Address,
    IN ULONG Size,
    IN PVOID Cxt
    )
{
    PMODULE Module;
    PRATE_DATA RateData;
    ULONG64 i, StartIndex, EndIndex;
    ULONG ProfileSourceIndex;
    BOOLEAN HasHits;

    Module = calloc(1, sizeof(MODULE)+sizeof(RATE_DATA)*SourceMaximum);
    if (Module == NULL) {
        FPRINTF(stderr, "CreateZoomModuleCallback: failed to allocate Zoom module\n");
        exit(1);
    }
    Module->Base = Address;
    Module->Length = Size;
    Module->Zoom = FALSE;
    SetModuleName( Module, szSymName );

    //
    // Compute range in profile buffer to sum.
    //
    StartIndex = (ULONG)((Module->Base - CallbackCurrent->Base) / ZOOM_BUCKET);
#ifdef BUGBUG
    EndIndex = StartIndex + (Module->Length / ZOOM_BUCKET);
#else
    EndIndex = (Module->Base + Module->Length - CallbackCurrent->Base) / ZOOM_BUCKET;
#endif

    HasHits = FALSE;
    for (ProfileSourceIndex=0; ProfileSourceIndex < SourceMaximum; ProfileSourceIndex++) {
        if (Source[ProfileSourceIndex].Interval != 0) {
            RateData = &Module->Rate[ProfileSourceIndex];
            RateData->StartTime = CallbackCurrent->Rate[ProfileSourceIndex].StartTime;
            RateData->TotalTime = CallbackCurrent->Rate[ProfileSourceIndex].TotalTime;
            RateData->TotalCount = 0;
            RateData->ProfileHandle = NULL;
            RateData->CurrentCount = 0;
            RateData->ProfileBuffer = NULL;

            for (i=StartIndex; i < EndIndex; i++) {
                RateData->TotalCount += CallbackCurrent->Rate[ProfileSourceIndex].ProfileBuffer[i];
            }
            if (RateData->TotalCount > 0) {
                HasHits = TRUE;
            }
        }
    }

    //
    // If the routine has hits add it to the list, otherwise
    // ignore it.
    //
    if (HasHits) {
        Module->Next = ZoomList;
        ZoomList = Module;
        ++ZoomCount;
    } else {
        free(Module);
    }
    return(TRUE);
}


/* BEGIN_IMS  TkEnumerateSymbols
******************************************************************************
****
****   TkEnumerateSymbols (  )
****
******************************************************************************
*
* Function Description:
*
*    Calls the specified function for every symbol in the Current module.
*    The algorithm results in a round-up behavior for the output --
*    for each bucket, the symbol corresponding to the first byte of the
*    bucket is used.
*
* Arguments:
*
*    IN HANDLE SymHandle : ImageHelp handle
*
*    IN PMODULE Current : Pointer to current module structure
*
*    IN PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback : Routine to call for each symbol
*
* Return Value:
*
*    BOOL
*
* Algorithm:
*
*    ToBeSpecified
*
* Globals Referenced:
*
*    ToBeSpecified
*
* Exception Conditions:
*
*    ToBeSpecified
*
* In/Out Conditions:
*
*    ToBeSpecified
*
* Notes:
*
*    ToBeSpecified
*
* ToDo List:
*
*    ToBeSpecified
*
* Modification History:
*
*    9/5/97  TF  Initial version
*
******************************************************************************
* END_IMS  TkEnumerateSymbols */

BOOL
TkEnumerateSymbols(
    IN HANDLE                      SymHandle,
    IN PMODULE                     Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback
    )
{
    UCHAR   CurrentSym[80];
    DWORD64 CurrentAddr = 0;
    ULONG i;
    DWORD64 Displacement;

    CurrentSym[0] = '\0';

    for (i=0; i<Current->Length/ZOOM_BUCKET; i++) {

        // Check if this bucket will be assigned to a different symbol...
        if (SymGetSymFromAddr64(SymHandle, Current->Base+i*ZOOM_BUCKET, &Displacement, Symbol )) {

            // It will... Invoke the callback for the old one
            if (CurrentSym[0] == '\0' ||
                strncmp(Symbol->Name,CurrentSym,strlen(CurrentSym))) {

                if (CurrentAddr != 0) {
                    ULONG64 Size = (Current->Base+i*ZOOM_BUCKET) - CurrentAddr;
if ( Size == 0 )    {
FPRINTF( stderr, "XXTF Size==0 - %s = %s\n", Symbol->Name, CurrentSym );
}
else {
                    if (!EnumSymbolsCallback(CurrentSym,CurrentAddr,(ULONG)Size,NULL))  {
                        break;
                    }
}
                }


                // Save the new info
                CurrentAddr = Current->Base+i*ZOOM_BUCKET;
                strcpy(CurrentSym,Symbol->Name);
            }
        }
    }

    // Cleanup for the last symbol
    if (CurrentAddr != 0) {
        ULONG64 Size = (Current->Base+i*ZOOM_BUCKET) - CurrentAddr;
        (VOID) EnumSymbolsCallback(CurrentSym,CurrentAddr,(ULONG)Size,NULL);
    }

    return(TRUE);

} // TkEnumerateSymbols()



VOID
CreateZoomedModuleList(
    IN PMODULE ZoomModule,
    IN ULONG RoundDown
    )

/*++

Routine Description:

    Creates a module list from the functions in a given module

Arguments:

    ZoomModule - Supplies the module whose zoomed module list is to be created

Return Value:

    Pointer to the zoomed module list
    NULL on error.

--*/

{
    BOOL Success;

    CallbackCurrent = ZoomModule;
    if (RoundDown == 0)  {
        Success = SymEnumerateSymbols64( SymHandle,
                                         ZoomModule->Base,
                                         CreateZoomModuleCallback, NULL );
    }
    else {
        Success = TkEnumerateSymbols( SymHandle,
                                      ZoomModule,
                                      CreateZoomModuleCallback );
    }
    if (!Success) {
        FPRINTF(stderr,
                "SymEnumerateSymbols64 failed module %s\n",
                ZoomModule->module_Name);
    }

    return;

} // CreateZoomedModuleList()

VOID
OutputModuleList(
    IN FILE *Out,
    IN PMODULE ModuleList,
    IN ULONG NumberModules
    )

/*++

Routine Description:

    Outputs the given module list

Arguments:

    Out - Supplies the FILE * where the output should go.

    ModuleList - Supplies the list of modules to output

    NumberModules - Supplies the number of modules in the list

Return Value:

    None.

--*/

{
    CHAR HeaderString[128];
    PRATE_DATA RateData;
    PRATE_SUMMARY RateSummary;
    PRATE_DATA SummaryData;
    BOOLEAN Header;
    ULONG i, ProfileSourceIndex;
    PMODULE *ModuleArray;
    PMODULE Current;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfoBegin;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfoEnd;
    float Ratio;

//// Beginning of Function Assertions Section:
//
//

//
// It is not really a bug but we are printing only the first 32 characters of the module name.
// This assertion will remind us this.
//

assert( sizeof(Current->module_Name) >= 32 );

//
//
//// End of Function Assertions Section

    RateSummary = malloc(SourceMaximum * sizeof (RATE_SUMMARY));
    if (RateSummary == NULL) {
        FPRINTF(stderr, "KERNRATE: Buffer allocation failed while doing output of Module list\n");
        exit(1);
    }

    SummaryData = malloc(SourceMaximum * sizeof (RATE_DATA));
    if (SummaryData == NULL) {
        FPRINTF(stderr, "KERNRATE: Buffer allocation failed while doing output of Module list\n");
        free(RateSummary);
        exit(1);
    }

    ZeroMemory(SummaryData, SourceMaximum * sizeof (RATE_SUMMARY));

    for (ProfileSourceIndex=0; ProfileSourceIndex < SourceMaximum; ProfileSourceIndex++) {
        SummaryData[ProfileSourceIndex].Rate = 0;
        if (Source[ProfileSourceIndex].Interval != 0) {
            //
            // Walk through the module list and compute the summary
            // and collect the interesting per-module data.
            //
            RateSummary[ProfileSourceIndex].Modules = malloc(NumberModules * sizeof(PMODULE));
            if (RateSummary[ProfileSourceIndex].Modules == NULL) {
                FPRINTF(stderr, "KERNRATE: Buffer allocation failed while doing output of Module list\n");
                exit(1);
            }

            RateSummary[ProfileSourceIndex].ModuleCount = 0;
            RateSummary[ProfileSourceIndex].TotalCount = 0;
            ModuleArray = RateSummary[ProfileSourceIndex].Modules;
            Current = ModuleList;
            while (Current != NULL) {
                RateData = &Current->Rate[ProfileSourceIndex];
                if (RateData->TotalCount > 0) {
                    RateSummary[ProfileSourceIndex].TotalCount += RateData->TotalCount;
                    //
                    // Insert it in sorted position in the array.
                    //
                    ModuleArray[RateSummary[ProfileSourceIndex].ModuleCount] = Current;
                    RateSummary[ProfileSourceIndex].ModuleCount++;
                    if (RateSummary[ProfileSourceIndex].ModuleCount > NumberModules) {
                        DbgPrint("error, ModuleCount %d > NumberModules %d for Source %s\n",
                                RateSummary[ProfileSourceIndex].ModuleCount,
                                NumberModules,
                                Source[ProfileSourceIndex].Name);
                        DbgBreakPoint();
                    }
                    for (i=0; i<RateSummary[ProfileSourceIndex].ModuleCount; i++) {
                        if (RateData->TotalCount > ModuleArray[i]->Rate[ProfileSourceIndex].TotalCount) {
                            //
                            // insert here
                            //
                            MoveMemory(&ModuleArray[i+1],
                                       &ModuleArray[i],
                                       sizeof(PMODULE)*(RateSummary[ProfileSourceIndex].ModuleCount-i-1));
                            ModuleArray[i] = Current;
                            break;
                        }
                    }
                }
                Current = Current->Next;
            }

            if (RateSummary[ProfileSourceIndex].TotalCount > (ULONGLONG)0) {
                //
                // Output the result
                //
                PSOURCE s;
                s = &Source[ProfileSourceIndex];
                FPRINTF(Out, "\n%s   %I64u hits, %ld events per hit --------\n",
                             s->Name,
                             RateSummary[ProfileSourceIndex].TotalCount,
                             s->Interval
                       );
                FPRINTF(Out," Module                                Hits       msec  %%Total  Events/Sec\n");
                for (i=0; i < RateSummary[ProfileSourceIndex].ModuleCount; i++) {
                    Current = ModuleArray[i];
                    FPRINTF(Out, "%-32s",Current->module_Name); // Note TF 09/97: the first only 32 characters are printed.
                    OutputLine(Out,
                               ProfileSourceIndex,
                               Current,
                               &RateSummary[ProfileSourceIndex]);
                    SummaryData[ProfileSourceIndex].Rate += Current->Rate[ProfileSourceIndex].Rate;
                }
            }
        }
    }

    //
    // Output interesting data for the summary.
    //
    sprintf(HeaderString, "\n-------------- INTERESTING SUMMARY DATA ----------------------\n");
    OutputInterestingData(Out, SummaryData, HeaderString);

    //
    // Output the results ordered by module
    //
    Current = ModuleList;
    while (Current != NULL) {
        Header = FALSE;
        for (ProfileSourceIndex = 0; ProfileSourceIndex < SourceMaximum; ProfileSourceIndex++) {
            if ((Source[ProfileSourceIndex].Interval != 0) &&
                (Current->Rate[ProfileSourceIndex].TotalCount > 0)) {
                if (!Header) {
                    FPRINTF(Out,"\nMODULE %s   --------\n",Current->module_Name);
                    FPRINTF(Out," %-*s      Hits       msec  %%Total  Events/Sec\n", DescriptionMaxLen, "Source");
                    Header = TRUE;
                }
                FPRINTF(Out, "%-*s", DescriptionMaxLen, Source[ProfileSourceIndex].Name);
                OutputLine(Out,
                           ProfileSourceIndex,
                           Current,
                           &RateSummary[ProfileSourceIndex]);
            }
        }
        //
        // Output interesting data for the module.
        //
        sprintf(HeaderString, "\n-------------- INTERESTING MODULE DATA FOR %s---------------------- \n",Current->module_Name);
        OutputInterestingData(Out, &Current->Rate[0], HeaderString);
        Current = Current->Next;
    }

    return;

} // OutputModuleList()


VOID
OutputLine(
    IN FILE *Out,
    IN ULONG ProfileSourceIndex,
    IN PMODULE Module,
    IN PRATE_SUMMARY RateSummary
    )

/*++

Routine Description:

    Outputs a line corresponding to the particular module/source

Arguments:

    Out - Supplies the file pointer to output to.

    ProfileSource - Supplies the source to use

    Module - Supplies the module to be output

    RateSummary - Supplies the rate summary for this source

Return Value:

    None.

--*/

{
    ULONG Msec;
    ULONGLONG Events;

    Msec = (ULONG)(Module->Rate[ProfileSourceIndex].TotalTime/10000);
    Events = Module->Rate[ProfileSourceIndex].TotalCount * Source[ProfileSourceIndex].Interval * 1000;

    FPRINTF(Out,
            " %10Ld %10d    %2d %%  ",
            (ULONG) Module->Rate[ProfileSourceIndex].TotalCount,
            (ULONG) Msec,
            (ULONG)(100*Module->Rate[ProfileSourceIndex].TotalCount/
                    RateSummary->TotalCount));
    if (Msec > 0) {
        Module->Rate[ProfileSourceIndex].Rate = (ULONGLONG)Events/Msec;
        FPRINTF(Out,"%10Ld\n",Module->Rate[ProfileSourceIndex].Rate);
    } else {
        Module->Rate[ProfileSourceIndex].Rate = 0;
        FPRINTF(Out,"---\n");
    }
}


VOID
OutputInterestingData(
    IN FILE *Out,
    IN RATE_DATA Data[],
    IN PCHAR Header
    )

/*++

Routine Description:

    Computes interesting numbers and outputs them.

Arguments:

    Out - Supplies the file pointer to output to.

    Data - Supplies an array of RATE_DATA. The Rate field is the only interesting part.

    Header - Supplies header to be printed.

Return Value:

    None.

--*/

{
    ULONGLONG Temp1,Temp2;
    LONGLONG Temp3;
    float Ratio;
    BOOLEAN DidHeader = FALSE;

    //
    // Note that we have to do a lot of funky (float)(LONGLONG) casts in order
    // to prevent the weenie x86 compiler from choking.
    //

    //
    // Compute cycles/instruction and instruction mix data.
    //
    if ((Data[ProfileTotalIssues].Rate != 0) &&
        (Data[ProfileTotalIssues].TotalCount > 10)) {
        if (Data[ProfileTotalCycles].Rate != 0) {
            Ratio = (float)(LONGLONG)(Data[ProfileTotalCycles].Rate)/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            if (!DidHeader) {
                FPRINTF(Out, Header);
                DidHeader = TRUE;
            }
            FPRINTF(Out, "Cycles per instruction\t\t%6.2f\n", Ratio);
        }

        Ratio = (float)(LONGLONG)(Data[ProfileLoadInstructions].Rate)/
                (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
        if (Ratio >= 0.01) {
            if (!DidHeader) {
                FPRINTF(Out, Header);
                DidHeader = TRUE;
            }
            FPRINTF(Out, "Load instruction percentage\t%6.2f %%\n",Ratio*100);
        }

        Ratio = (float)(LONGLONG)(Data[ProfileStoreInstructions].Rate)/
                (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
        if (Ratio >= 0.01) {
            if (!DidHeader) {
                FPRINTF(Out, Header);
                DidHeader = TRUE;
            }
            FPRINTF(Out, "Store instruction percentage\t%6.2f %%\n",Ratio*100);
        }

        Ratio = (float)(LONGLONG)(Data[ProfileBranchInstructions].Rate)/
                (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
        if (Ratio >= 0.01) {
            if (!DidHeader) {
                FPRINTF(Out, Header);
                DidHeader = TRUE;
            }
            FPRINTF(Out, "Branch instruction percentage\t%6.2f %%\n",Ratio*100);
        }

        Ratio = (float)(LONGLONG)(Data[ProfileFpInstructions].Rate)/
                (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
        if (Ratio >= 0.01) {
            if (!DidHeader) {
                FPRINTF(Out, Header);
                DidHeader = TRUE;
            }
            FPRINTF(Out, "FP instruction percentage\t%6.2f %%\n",Ratio*100);
        }

        Ratio = (float)(LONGLONG)(Data[ProfileIntegerInstructions].Rate)/
                (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
        if (Ratio >= 0.01) {
            if (!DidHeader) {
                FPRINTF(Out, Header);
                DidHeader = TRUE;
            }
            FPRINTF(Out, "Integer instruction percentage\t%6.2f %%\n",Ratio*100);
        }

        //
        // Compute icache hit rate
        //
        if (Data[ProfileIcacheMisses].Rate != 0) {
            Temp3 = (LONGLONG)(Data[ProfileTotalIssues].Rate - Data[ProfileIcacheMisses].Rate);
            Ratio = (float)Temp3/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            if (!DidHeader) {
                FPRINTF(Out, Header);
                DidHeader = TRUE;
            }
            FPRINTF(Out, "Icache hit rate\t\t\t%6.2f %%\n", Ratio*100);
        }

    }

    //
    // Compute dcache hit rate
    //
    Temp1 = Data[ProfileLoadInstructions].Rate + Data[ProfileStoreInstructions].Rate;
    if ((Data[ProfileDcacheMisses].Rate != 0) &&
        (Temp1 != 0) &&
        (Data[ProfileDcacheMisses].TotalCount > 10)) {

        Temp2 = Temp1 - Data[ProfileDcacheMisses].Rate;
        Temp3 = (LONGLONG) Temp2;
        Ratio = (float)Temp3/(float)(LONGLONG)Temp1;
        if (!DidHeader) {
            FPRINTF(Out, Header);
            DidHeader = TRUE;
        }
        FPRINTF(Out, "Dcache hit rate\t\t\t%6.2f %%\n", Ratio*100);
    }

    //
    // Compute branch prediction hit percentage
    //
    if ((Data[ProfileBranchInstructions].Rate != 0) &&
        (Data[ProfileBranchMispredictions].Rate != 0) &&
        (Data[ProfileBranchInstructions].TotalCount > 10)) {
        Temp3 = (LONGLONG)(Data[ProfileBranchInstructions].Rate-Data[ProfileBranchMispredictions].Rate);
        Ratio = (float)Temp3 /
                (float)(LONGLONG)(Data[ProfileBranchInstructions].Rate);
        if (!DidHeader) {
            FPRINTF(Out, Header);
            DidHeader = TRUE;
        }
        FPRINTF(Out, "Branch predict hit percentage\t%6.2f %%\n", Ratio*100);
    }
} // OutputInterestingData()

/* BEGIN_IMS  CreateNewModule
******************************************************************************
****
****   CreateNewModule (  )
****
******************************************************************************
*
* Function Description:
*
*    This function allocates and initializes a module entry.
*
* Arguments:
*
*    IN HANDLE ProcessHandle :
*
*    IN PCHAR ModuleName :
*
*    IN PCHAR ModuleFullName :
*
*    IN ULONG ImageBase :
*
*    IN ULONG ImageSize :
*
* Return Value:
*
*    PMODULE
*
* Algorithm:
*
*    ToBeSpecified
*
* Globals Referenced:
*
*    ToBeSpecified
*
* Exception Conditions:
*
*    ToBeSpecified
*
* In/Out Conditions:
*
*    ToBeSpecified
*
* Notes:
*
*    ToBeSpecified
*
* ToDo List:
*
*    ToBeSpecified
*
* Modification History:
*
*    9/8/97  TF  Initial version
*
******************************************************************************
* END_IMS  CreateNewModule */

PMODULE
CreateNewModule(
    IN HANDLE   ProcessHandle,
    IN PCHAR    ModuleName,
    IN PCHAR    ModuleFullName,
    IN ULONG64  ImageBase,
    IN ULONG    ImageSize
    )
{
    PMODULE NewModule;
    PMODULE ZoomModule;
    PMODULE *ZoomPrevious;

    NewModule = calloc(1, sizeof(MODULE)+sizeof(RATE_DATA)*SourceMaximum);
    if (NewModule == NULL) {
        FPRINTF(stderr,"Memory allocation of NewModule for %s failed\n",ModuleName);
        exit(1);
    }
    NewModule->Zoom = FALSE;
    SetModuleName( NewModule, ModuleName );
    //
    // Following WinDbg's rule: module names are filenames without their extension.
    //
    if (strchr(NewModule->module_Name, '.')) {
        *strchr(NewModule->module_Name, '.') = '\0';
    }

    //
    // See if this module is on the zoom list.
    // If so we will use the MODULE that was allocated when
    // the zoom list was created.
    //

    ZoomModule = ZoomList;
    ZoomPrevious = &ZoomList;
    while ( ZoomModule != NULL ) {
        if ( _stricmp(ZoomModule->module_Name,NewModule->module_Name) == 0 ) {

            //
            // found a match
            //

            free(NewModule);
            NewModule = ZoomModule;
            *ZoomPrevious = ZoomModule->Next;

            NewModule->Base = ImageBase;
            NewModule->Length = ImageSize;
            NewModule->module_FileName = _strdup( ModuleName );
            if ( ModuleFullName )   {
               NewModule->module_FullName = _strdup( ModuleFullName );
            }
            gCurrentModule = NewModule;

            //
            // Load symbols
            //
            // Note 15/09/97 TF: do not be confused here...
            // In this routine, the ModuleName variable is a filename with its
            // extension: File.exe or File.dll
            //
            // Note 30/09/97 TF: The current kernrate version does not change
            // the default IMAGEHLP behaviour in terms of symbol file loading:
            // It is synchronous ( and not deferred ) with the SymLoadModule
            // call. Our registered callback will be called with the standard
            // symbol file operations.
            // If the kernrate behaviour changes, we will have to revisit this
            // assumption.
            //
            // Also, I decided to keep temporarely the kernrate "_OLD_CODE"
            // in case the registered callback does not work as it should.
            // We are still in the learning curve, here -).
            //


#if defined(_OLD_CODE)

            //
            //
            //

            if ( SymLoadModule(ProcessHandle ? ProcessHandle : (HANDLE)-1, // hProcess
                               NULL,                                       // hFile [for Debugger]
                               ModuleName,                                 // ImageName
                               NULL,                                       // ModuleName
                               ImageBase,                                  // BaseOfDll
                               ImageSize                                   // SizeOfDll
                              ))  {
                FPRINTF(stderr,
                        "Symbols loaded %08lx  %s\n",
                        ImageBase,
                        ModuleName);

            } else {
                FPRINTF(stderr,
                        "*** Could not load symbols %08lx  %s\n",
                        ImageBase,
                        ModuleName);
            }

#else  // _NEW_CODE

        (void)SymLoadModule64( ProcessHandle ? ProcessHandle : (HANDLE)-1, // hProcess
                               NULL,                                       // hFile [for Debugger]
                               ModuleName,                                 // ImageName
                               NULL,                                       // ModuleName
                               ImageBase,                                  // BaseOfDll
                               ImageSize                                   // SizeOfDll
                               );

#endif // _NEW_CODE

            gCurrentModule = (PMODULE)0;

            break;
        }
        ZoomPrevious = &ZoomModule->Next;
        ZoomModule = ZoomModule->Next;
    }
    NewModule->Process = ProcessHandle;
    NewModule->Base = ImageBase;   // Note TF: I know for zoomed it is a redone...
    NewModule->Length = ImageSize; // Note TF: I know for zoomed it is a redone...
    assert( ModuleName );
    if ( NewModule->module_FileName == (PCHAR)0 )   {
      NewModule->module_FileName = _strdup( ModuleName );
    }
    if ( ModuleFullName && NewModule->module_FullName == (PCHAR)0 )   {
      NewModule->module_FullName = _strdup( ModuleFullName );
    }
    ZeroMemory(NewModule->Rate, sizeof(RATE_DATA) * SourceMaximum);

#ifdef _WIN64
#define VerboseModuleFormat "0x%016x 0x%16x "
#else  // !_WIN64
#define VerboseModuleFormat "0x%08x 0x%08x "
#endif // !_WIN64

VerbosePrint(( VERBOSE_MODULES, VerboseModuleFormat " %s [%s]\n",
                                NewModule->Base,
                                NewModule->Base + (ULONG64)NewModule->Length,
                                NewModule->module_Name,
                                ModuleFullName( NewModule )
            ));

#undef VerboseModuleFormat

    return(NewModule);

} // CreateNewModule()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\leak.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:


Revision History:

--*/


//
// Lists threads sorted by CPU time consumed, in order to 
// track runaway threads
//

typedef struct _INTERESTING_THREAD_INFO {
    ULONG_PTR       ThreadId ;
    ULONG_PTR       Flags ;
    LARGE_INTEGER   UserTime ;
    LARGE_INTEGER   KernelTime ;
    LARGE_INTEGER   ElapsedTime ;
} INTERESTING_THREAD_INFO, * PINTERESTING_THREAD_INFO ;

#define ITI_USER_DONE       0x00000001
#define ITI_KERNEL_DONE     0x00000002
#define ITI_ELAPSED_DONE    0x00000004

DECLARE_API( runaway )
{
    PROCESS_BASIC_INFORMATION ProcessInfo ;
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    PSYSTEM_THREAD_INFORMATION ThreadInfo ;
    PINTERESTING_THREAD_INFO Threads ;
    NTSTATUS Status ;
    ULONG Flags = 1 ;
    ULONG i, j, Found ;
    LARGE_INTEGER Now ;
    LARGE_INTEGER Compare ;
    TIME_FIELDS Time ;

    INIT_API();

    if (sscanf( args, "%x", &Flags ) == 0) {
        goto Exit;
    }

    Status = NtQueryInformationProcess(
                    g_hCurrentProcess,
                    ProcessBasicInformation,
                    &ProcessInfo,
                    sizeof( ProcessInfo ),
                    NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        dprintf( "could not get process information, %d\n",
                 RtlNtStatusToDosError( Status ) );
        goto Exit;
    }

    SystemInfo = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    1024 * sizeof( SYSTEM_PROCESS_INFORMATION ) );

    if ( !SystemInfo )
    {
        dprintf( "not enough memory\n" );
        goto Exit;
    }

    Status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    SystemInfo,
                    1024 * sizeof( SYSTEM_PROCESS_INFORMATION ),
                    NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        dprintf( "unable to get system information\n" );

        RtlFreeHeap(
                RtlProcessHeap(),
                0,
                SystemInfo );

        goto Exit;
    }

    //
    // First, find the process:
    //
    
    Walk = SystemInfo ;

    while ( HandleToUlong( Walk->UniqueProcessId ) != ProcessInfo.UniqueProcessId )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        dprintf( "unable to find process\n" );

        RtlFreeHeap( RtlProcessHeap(), 0, SystemInfo );

        goto Exit;
    }

    //
    // Now, walk the threads
    //

    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) (Walk + 1);

    Threads = RtlAllocateHeap( 
                    RtlProcessHeap(),
                    0,
                    sizeof( INTERESTING_THREAD_INFO ) * Walk->NumberOfThreads );

    if ( !Threads )
    {
        dprintf( "not enough memory\n" );

        RtlFreeHeap(
                RtlProcessHeap(),
                0,
                SystemInfo );

        goto Exit;
    }

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
    {
        Threads[ i ].Flags = 0 ;
        Threads[ i ].ThreadId = HandleToUlong( ThreadInfo[ i ].ClientId.UniqueThread );
        Threads[ i ].ElapsedTime.QuadPart = Now.QuadPart - ThreadInfo[ i ].CreateTime.QuadPart ;
        Threads[ i ].KernelTime = ThreadInfo[ i ].KernelTime ;
        Threads[ i ].UserTime = ThreadInfo[ i ].UserTime ;

    }

    //
    // Scan through the list of threads (in an ugly, bubble-ish sort
    // of way), and display the threads in order of time, once per time
    // field, by way of the flags:
    //

    if ( Flags & ITI_USER_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " User Mode Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_USER_DONE ) == 0 ) && 
                     ( Threads[ i ].UserTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].UserTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_USER_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( Flags & ITI_KERNEL_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " Kernel Mode Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_KERNEL_DONE ) == 0 ) && 
                     ( Threads[ i ].KernelTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].KernelTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_KERNEL_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( Flags & ITI_ELAPSED_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " Elapsed Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_ELAPSED_DONE ) == 0 ) && 
                     ( Threads[ i ].ElapsedTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].ElapsedTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_ELAPSED_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( SystemInfo )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, SystemInfo );
    }

 Exit:
    EXIT_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\ntsdextp.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <heap.h>
#include <stktrace.h>
#include <lmerr.h>

#include <ntcsrsrv.h>

#include "ext.h"

#undef DECLARE_API

#define DECLARE_API(extension) \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API() if (ExtQuery(Client) != S_OK) return E_OUTOFMEMORY
#define EXIT_API() ExtRelease(); return S_OK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\hleak.c ===
#define REASONABLE_NUMBER   8


typedef BOOL (_ID_MATCH_FN)(
    PVOID   A,
    PVOID   B);
typedef _ID_MATCH_FN * PID_MATCH_FN;

typedef VOID (_ID_BANNER_FN)(
    PVOID   Id
    );
typedef _ID_BANNER_FN * PID_BANNER_FN;

typedef VOID (_HANDLE_CALLBACK_FN)(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    );
typedef _HANDLE_CALLBACK_FN * PHANDLE_CALLBACK_FN;


#define MATCH_LARGE_INT     ((PID_MATCH_FN)1)

typedef struct _HANDLE_TRACK {
    LIST_ENTRY  List ;
    ULONG       Flags ;
    ULONG       Count ;
    ULONG       Size ;
    PHANDLE     Handles ;
    HANDLE      HandleList[ REASONABLE_NUMBER ];
    UCHAR       IdData[ 1 ];
} HANDLE_TRACK, * PHANDLE_TRACK ;

typedef struct _HANDLE_TRACK_ARRAY {
    ULONG       Count ;
    ULONG       Size ;
    ULONG       IdDataSize ;
    PID_MATCH_FN MatchFunc ;
    LIST_ENTRY  List ;
} HANDLE_TRACK_ARRAY, * PHANDLE_TRACK_ARRAY ;

typedef struct _THREAD_TRACK_INFO {
    CLIENT_ID   Id ;
    PVOID       Win32StartAddress ;
    DWORD       Status ;
} THREAD_TRACK_INFO ;

typedef struct _HANDLE_LEAK_HELPER {
    PWSTR               Type ;
    PID_BANNER_FN       Banner ;
    PHANDLE_CALLBACK_FN Filter ;
    ULONG               ArraySize ;
    PID_MATCH_FN        Match ;
} HANDLE_LEAK_HELPER, * PHANDLE_LEAK_HELPER ;

_ID_BANNER_FN       ThreadBanner ;
_ID_BANNER_FN       TokenBanner ;
_HANDLE_CALLBACK_FN ThreadCallback ;
_HANDLE_CALLBACK_FN TokenCallback ;

HANDLE_LEAK_HELPER HandleLeakHelpers[] = {
    { L"Thread", ThreadBanner, ThreadCallback, sizeof( THREAD_TRACK_INFO ), MATCH_LARGE_INT },
    { L"Token", TokenBanner, TokenCallback, sizeof( TOKEN_CONTROL ), MATCH_LARGE_INT }
};


PHANDLE_TRACK_ARRAY
CreateArray(
    ULONG   IdDataSize,
    PID_MATCH_FN MatchFn
    )
{
    PHANDLE_TRACK_ARRAY    Array ;

    Array = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( HANDLE_TRACK_ARRAY ) );

    if ( Array )
    {
        Array->Count = 0 ;
        Array->Size = 0;
        Array->IdDataSize = IdDataSize ;
        Array->MatchFunc = MatchFn ;

        InitializeListHead( &Array->List );

        return Array ;
    }

    return NULL ;
}

VOID
DeleteArray(
    PHANDLE_TRACK_ARRAY Array
    )
{
    ULONG i ;
    PHANDLE_TRACK Track ;

    while ( !IsListEmpty( &Array->List ) )
    {
        Track = (PHANDLE_TRACK) RemoveHeadList( &Array->List );

        if ( Track->Handles != Track->HandleList )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, Track->Handles );
        }

        RtlFreeHeap( RtlProcessHeap(), 0, Track );
    }

    RtlFreeHeap( RtlProcessHeap(), 0, Array );
}


VOID
ExtendTrack(
    PHANDLE_TRACK Track
    )
{
    PHANDLE NewHandle ;

    NewHandle = RtlAllocateHeap( RtlProcessHeap(), 0, (Track->Size + REASONABLE_NUMBER ) *
                        sizeof( HANDLE ) );

    if ( NewHandle )
    {
        CopyMemory( NewHandle,
                    Track->Handles,
                    Track->Count * sizeof( HANDLE ) );

        if ( Track->Handles != Track->HandleList )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, Track->Handles );
        }

        Track->Handles = NewHandle ;
        Track->Size += REASONABLE_NUMBER ;
    }
}

VOID
AddHandleToArray(
    PHANDLE_TRACK_ARRAY Array,
    PVOID IdData,
    HANDLE Handle
    )
{
    ULONG i;
    ULONG j;
    BOOL Match ;
    PHANDLE_TRACK Track ;
    PLIST_ENTRY Scan ;

    Scan = Array->List.Flink ;

    while ( Scan != &Array->List )
    {
        Track = (PHANDLE_TRACK) Scan ;

        if ( Array->MatchFunc == MATCH_LARGE_INT )
        {
            Match = ((PLARGE_INTEGER) Track->IdData)->QuadPart ==
                    ((PLARGE_INTEGER) IdData)->QuadPart ;
        }
        else
        {
            Match = Array->MatchFunc( Track->IdData, IdData );
        }

        if ( Match )
        {
            //
            // We have a match:
            //

            if ( Track->Count == Track->Size )
            {
                ExtendTrack( Track );
            }

            if ( Track->Count < Track->Size )
            {
                Track->Handles[
                        Track->Count ] = Handle ;

                Track->Count++;
            }

            return ;
        }

        Scan = Scan->Flink ;
    }

    //
    // No match, gotta add a new tid
    //

    Track = RtlAllocateHeap( RtlProcessHeap(), 0,
                sizeof( HANDLE_TRACK ) + Array->IdDataSize );

    if ( Track )
    {
        Track->Size = REASONABLE_NUMBER ;
        Track->Count = 1 ;
        Track->Handles = Track->HandleList ;
        Track->HandleList[0] = Handle ;

        CopyMemory( Track->IdData, IdData, Array->IdDataSize );

        InsertTailList( &Array->List, &Track->List );
    }

}

VOID
DumpArray(
    PHANDLE_TRACK_ARRAY Array,
    PID_BANNER_FN   Banner
    )
{
    ULONG j;
    PHANDLE_TRACK Track ;
    PLIST_ENTRY Scan ;

    Scan = Array->List.Flink ;

    while ( Scan != &Array->List )
    {
        Track = (PHANDLE_TRACK) Scan ;

        Banner( Track->IdData );

        dprintf("  Handles  \t%d:  ", Track->Count );
        for ( j = 0 ; j < Track->Count ; j++ )
        {
            dprintf("%x, ", Track->Handles[j] );
        }

        dprintf("\n");

        Scan = Scan->Flink ;
    }

}

VOID
HandleScanner(
    HANDLE  hCurrentProcess,
    PWSTR   Type,
    PVOID   Context,
    PHANDLE_CALLBACK_FN Callback
    )
{
    DWORD   HandleCount;
    NTSTATUS Status;
    DWORD   Total;
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    HANDLE  hHere ;
    PHANDLE_TRACK_ARRAY Array ;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    UCHAR   Buffer[1024];

    Status = NtQueryInformationProcess( hCurrentProcess,
                                        ProcessHandleCount,
                                        &HandleCount,
                                        sizeof( HandleCount ),
                                        NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return;
    }

    Hits = 0;
    Handle = 0;
    Matches = 0;

    while ( Hits < HandleCount )
    {
        Status = NtDuplicateObject( hCurrentProcess, (HANDLE)(DWORD_PTR)Handle,
                                    NtCurrentProcess(), &hHere,
                                    0, 0,
                                    DUPLICATE_SAME_ACCESS );

        if ( NT_SUCCESS( Status ) )
        {

            pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;

            ZeroMemory( Buffer, 1024 );

            Status = NtQueryObject( hHere, ObjectTypeInformation, pTypeInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                if ( wcscmp( pTypeInfo->TypeName.Buffer, Type ) == 0 )
                {
                    //
                    // Score!
                    //

                    Callback( Context, hHere, (HANDLE)(DWORD_PTR)Handle );

                    Matches++ ;

                }
            }

            Hits++ ;

            NtClose( hHere );

        }

        Handle += 4;
    }

    dprintf("%d handles to objects of type %ws\n", Matches, Type );
}


VOID
ThreadBanner(
    PVOID Id
    )
{
    UCHAR Symbol[ MAX_PATH ];
    DWORD_PTR Disp ;
    THREAD_TRACK_INFO * Info ;
    UCHAR ExitStatus[ 32 ];

    Info = (THREAD_TRACK_INFO *) Id ;

    Symbol[0] = '\0';

    GetSymbol( Info->Win32StartAddress, Symbol, &Disp );

    if ( Info->Status != STILL_ACTIVE )
    {
        sprintf(ExitStatus, " Stopped, %#x", Info->Status );
    }
    else
    {
        strcpy( ExitStatus, "<Running>");
    }

    if ( Symbol[0] )
    {
        dprintf("Thread %x.%x (%s) %s\n", Info->Id.UniqueProcess,
                        Info->Id.UniqueThread,
                        Symbol,
                        ExitStatus );
    }
    else
    {
        dprintf("Thread %x.%x %s\n", Info->Id.UniqueProcess,
                        Info->Id.UniqueThread,
                        ExitStatus );

    }
}

VOID
ThreadCallback(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    )
{
    NTSTATUS Status ;
    THREAD_BASIC_INFORMATION Info;

    THREAD_TRACK_INFO ThdInfo ;

    ZeroMemory( &ThdInfo, sizeof( ThdInfo ) );

    Status = NtQueryInformationThread( Here,
                                       ThreadBasicInformation,
                                       &Info,
                                       sizeof( Info ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        ThdInfo.Id = Info.ClientId ;
        ThdInfo.Status = Info.ExitStatus ;

        Status = NtQueryInformationThread( Here,
                                           ThreadQuerySetWin32StartAddress,
                                           &ThdInfo.Win32StartAddress,
                                           sizeof( PVOID ),
                                           NULL );

        AddHandleToArray( Context, &ThdInfo , There );
    }
}

VOID
TokenCallback(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    )
{
    NTSTATUS Status ;
    TOKEN_CONTROL Control ;
    TOKEN_STATISTICS Stats ;
    ULONG Size ;

    Status = NtQueryInformationToken(   Here,
                                        TokenStatistics,
                                        &Stats,
                                        sizeof( Stats ),
                                        &Size );

    if ( NT_SUCCESS( Status ) )
    {
        Control.TokenId = Stats.TokenId ;
        Control.AuthenticationId = Stats.AuthenticationId ;
        Control.ModifiedId = Stats.ModifiedId ;
        NtQueryInformationToken( Here, TokenSource, &Control.TokenSource, sizeof( TOKEN_SOURCE ), &Size );

        AddHandleToArray( Context, &Control, There );
    }
    else
    {
        dprintf("Unable to query token information, %x\n", Status );
    }
}

VOID
TokenBanner(
    PVOID Id
    )
{
    PTOKEN_CONTROL Control ;

    Control = (PTOKEN_CONTROL) Id ;

    dprintf("Token   Id %x:%x, LogonId = %x:%x, Source = %s\n",
                Control->TokenId.HighPart, Control->TokenId.LowPart,
                Control->AuthenticationId.HighPart, Control->AuthenticationId.LowPart,
                Control->TokenSource.SourceName );
}


DECLARE_API( hleak )
{
    UNICODE_STRING String ;
    PHANDLE_LEAK_HELPER Helper = NULL ;
    PHANDLE_TRACK_ARRAY Array ;
    int i ;

    INIT_API();

    if ( !args ||
         (*args == '\0' ) )
    {
        dprintf( "!hleak <typename>\n" );
        goto Exit;
    }

    while ( *args == ' ' )
    {
        args++ ;
    }

    if ( !RtlCreateUnicodeStringFromAsciiz( &String, args ) )
    {
        goto Exit;
    }

    for ( i = 0 ; 
          i < sizeof( HandleLeakHelpers ) / sizeof( HANDLE_LEAK_HELPER ) ; 
          i++ )
    {
        if ( _wcsicmp( String.Buffer, HandleLeakHelpers[ i ].Type ) == 0 )
        {
            Helper = &HandleLeakHelpers[ i ];
            break;
        }
    }

    if ( Helper == NULL )
    {
        dprintf( "The type '%ws' was not recognized.  Valid types are:\n", String.Buffer );
        for ( i = 0 ; 
              i < sizeof( HandleLeakHelpers ) / sizeof( HANDLE_LEAK_HELPER ) ; 
              i++ )
        {
            dprintf( "\t%ws\n", HandleLeakHelpers[ i ].Type );
        }
        RtlFreeUnicodeString( &String );
        goto Exit;
    }

    RtlFreeUnicodeString( &String );

    Array = CreateArray( Helper->ArraySize, Helper->Match );

    if ( !Array )
    {
        dprintf( "not enough memory\n" );
    }

    HandleScanner( g_hCurrentProcess,
                   Helper->Type,
                   Array,
                   Helper->Filter );

    DumpArray( Array, Helper->Banner );

    DeleteArray( Array );

 Exit:
    EXIT_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\ntsdexts.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Revision History:

    Daniel Mihai (DMihai) 18-Feb-2001

    Add !htrace - useful for dumping handle trace information.
--*/

#include "ntsdextp.h"


VOID
DecodeError(
    PSTR    Banner,
    ULONG   Code,
    BOOL    TreatAsStatus
    )
{
    HANDLE Dll ;
    PSTR Source ;
    UCHAR Message[ 512 ];
    PUCHAR s;

    if ( !TreatAsStatus )
    {
        //
        // The value "type" is not known.  Try and figure out what it
        // is.
        //

        if ( (Code & 0xC0000000) == 0xC0000000 )
        {
            //
            // Easy:  NTSTATUS failure case
            //

            Dll = GetModuleHandle( "NTDLL.DLL" );

            Source = "NTSTATUS" ;

            TreatAsStatus = TRUE ;

        }
        else if ( ( Code & 0xF0000000 ) == 0xD0000000 )
        {
            //
            // HRESULT from NTSTATUS
            //

            Dll = GetModuleHandle( "NTDLL.DLL" );

            Source = "NTSTATUS" ;

            Code &= 0xCFFFFFFF ;

            TreatAsStatus = TRUE ;

        }
        else if ( ( Code & 0x80000000 ) == 0x80000000 )
        {
            //
            // Note, this can overlap with NTSTATUS warning area.  In that
            // case, force the NTSTATUS.
            //

            Dll = GetModuleHandle( "KERNEL32.DLL" );

            Source = "HRESULT" ;

        }
        else
        {
            //
            // Sign bit is off.  Explore some known ranges:
            //

            if ( (Code >= WSABASEERR) && (Code <= WSABASEERR + 1000 ))
            {
                Dll = LoadLibrary( "wsock32.dll" );

                Source = "Winsock" ;
            }
            else if ( ( Code >= NERR_BASE ) && ( Code <= MAX_NERR ) )
            {
                Dll = LoadLibrary( "netmsg.dll" );

                Source = "NetAPI" ;
            }
            else
            {
                Dll = GetModuleHandle( "KERNEL32.DLL" );

                Source = "Win32" ;
            }

        }
    }
    else
    {
        Dll = GetModuleHandle( "NTDLL.DLL" );

        Source = "NTSTATUS" ;
    }

    if (!FormatMessage(  FORMAT_MESSAGE_IGNORE_INSERTS |
                    FORMAT_MESSAGE_FROM_HMODULE,
                    Dll,
                    Code,
                    0,
                    Message,
                    sizeof( Message ),
                    NULL ) )
    {
        strcpy( Message, "No mapped error code" );
    }

    s = Message ;

    while (*s) {
        if (*s < ' ') {
            *s = ' ';
            }
        s++;
        }

    if ( !TreatAsStatus )
    {
        dprintf( "%s: (%s) %#x (%u) - %s\n",
                    Banner,
                    Source,
                    Code,
                    Code,
                    Message );

    }
    else
    {
        dprintf( "%s: (%s) %#x - %s\n",
                    Banner,
                    Source,
                    Code,
                    Message );

    }

}

DECLARE_API( error )
{
    ULONG err ;

    INIT_API();

    err = (ULONG) GetExpression( args );

    DecodeError( "Error code", err, FALSE );

    EXIT_API();
}

BOOL
DumpLastErrorForTeb(
    ULONG64 Address
    )
{

    TEB Teb;

    if (ReadMemory( (ULONG_PTR)Address,
                    &Teb,
                    sizeof(Teb),
                    NULL
                    )
        ) {

        DecodeError( "LastErrorValue", Teb.LastErrorValue, FALSE );

        DecodeError( "LastStatusValue", Teb.LastStatusValue, TRUE );

        return TRUE;
    }


    dprintf("Unable to read TEB at %p\n", Address );

    return FALSE;
}

BOOL
DumpCurrentThreadLastError(
    ULONG CurrThreadID,
    PVOID Context
    )
{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadInformation;
    ULONGLONG Address;
    TEB Teb;

    if (Context) {
        dprintf("Last error for thread %lx:\n", CurrThreadID);
    }
    GetTebAddress(&Address);

    if (Address) {
        DumpLastErrorForTeb(Address);
    } else {
        dprintf("Unable to read thread %lx's TEB\n", CurrThreadID );
    }
    if (Context) {
        dprintf("\n");
    }

    return TRUE;
}

DECLARE_API( gle )
{
    INIT_API();
    
    if (!strcmp(args, "-all")) {
        EnumerateUModeThreads(&DumpCurrentThreadLastError, Client);
    } else {
        DumpCurrentThreadLastError(GetCurrentThreadUserID(), NULL);
    }
    EXIT_API();
}

DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        dprintf("GetVersionEx failed - %u\n", GetLastError());
        goto Exit;
        }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_READ,
                     &hkey
                    ) == NO_ERROR
       ) {
        cb = sizeof(szCurrentType);
        if (hkey) {
            if (RegQueryValueEx(hkey, "CurrentType", NULL, &dwType, szCurrentType, &cb ) != 0) {
                szCurrentType[0] = '\0';
            }
            RegCloseKey(hkey);
        }
    }

    if (VersionInformation.szCSDVersion[0]) {
        sprintf(szCSDString, ": %s", VersionInformation.szCSDVersion);
        }
    else {
        szCSDString[0] = '\0';
        }

    dprintf("Version %d.%d (Build %d%s) %s\n",
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          szCSDString,
          szCurrentType
         );

 Exit:
    EXIT_API();
}

DECLARE_API( help )
{
    INIT_API();

    while (*args == ' ')
        args++;

    if (*args == '\0') {
        dprintf("ntsdexts help:\n\n");
        dprintf("!critSec csAddress           - Dump a critical section\n");
        dprintf("!dp [v] [pid | pcsr_process] - Dump CSR process\n");
        dprintf("!dreg -[d|w] <keyPath>[![<valueName> | *]]  - Dump registry information\n");
        dprintf("!dt [v] pcsr_thread          - Dump CSR thread\n");
        dprintf("!error value                 - Decode error value\n");
        dprintf("!gatom                       - Dump the global atom table\n");
        dprintf("!gle [-all]                  - Dump GetLastError value for current/all thread\n");
        dprintf("!handle [handle]             - Dump handle information\n");
        dprintf("!help [cmd]                  - Displays this list or gives details on command\n");
        dprintf("!locks [-v][-o]              - Dump all Critical Sections in process\n");
        dprintf("!version                     - Dump system version and build number\n");
        dprintf("!vprot [address]             - Dump the virtual protect settings\n");

    } else {
        if (*args == '!')
            args++;
        if (strcmp( args, "handle") == 0) {
            dprintf("!handle [handle [flags [type]]] - Dump handle information\n");
            dprintf("       If no handle specified, all handles are dumped.\n");
            dprintf("       Flags are bits indicating greater levels of detail.\n");
            dprintf("If the handle is 0 or -1, all handles are scanned.  If the handle is not\n");
            dprintf("zero, that particular handle is examined.  The flags are as follows:\n");
            dprintf("    1   - Get type information (default)\n");
            dprintf("    2   - Get basic information\n");
            dprintf("    4   - Get name information\n");
            dprintf("    8   - Get object specific info (where available)\n");
            dprintf("\n");
            dprintf("If Type is specified, only object of that type are scanned.  Type is a\n");
            dprintf("standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of\n");
            dprintf("course.\n");
            dprintf("\n");
            dprintf("Examples:\n");
            dprintf("\n");
            dprintf("    !handle     -- dumps the types of all the handles, and a summary table\n");
            dprintf("    !handle 0 0 -- dumps a summary table of all the open handles\n");
            dprintf("    !handle 0 f -- dumps everything we can find about a handle.\n");
            dprintf("    !handle 0 f Event\n");
            dprintf("                -- dumps everything we can find about open events\n");
        } else if (strcmp( args, "gflag") == 0) {
            dprintf("If a value is not given then displays the current bits set in\n");
            dprintf("NTDLL!NtGlobalFlag variable.  Otherwise value can be one of the\n");
            dprintf("following:\n");
            dprintf("\n");
            dprintf("    -? - displays a list of valid flag abbreviations\n");
            dprintf("    number - 32-bit number that becomes the new value stored into\n");
            dprintf("             NtGlobalFlag\n");
            dprintf("    +number - specifies one or more bits to set in NtGlobalFlag\n");
            dprintf("    +abbrev - specifies a single bit to set in NtGlobalFlag\n");
            dprintf("    -number - specifies one or more bits to clear in NtGlobalFlag\n");
            dprintf("    -abbrev - specifies a single bit to clear in NtGlobalFlag\n");
        } else {
            dprintf("Invalid command.  No help available\n");
        }
    }

    EXIT_API();
}

VOID
DumpStackBackTraceIndex(
    IN USHORT BackTraceIndex
    )
{
#if i386
    BOOL b;
    PRTL_STACK_TRACE_ENTRY pBackTraceEntry;
    RTL_STACK_TRACE_ENTRY BackTraceEntry;
    ULONG i;
    CHAR Symbol[ 1024 ];
    ULONG_PTR Displacement;

    ULONG NumberOfEntriesAdded;
    PRTL_STACK_TRACE_ENTRY *EntryIndexArray;    // Indexed by [-1 .. -NumberOfEntriesAdded]

    PSTACK_TRACE_DATABASE *pRtlpStackTraceDataBase;
    PSTACK_TRACE_DATABASE RtlpStackTraceDataBase;
    STACK_TRACE_DATABASE StackTraceDataBase;



    pRtlpStackTraceDataBase = (PSTACK_TRACE_DATABASE *)GetExpression( "NTDLL!RtlpStackTraceDataBase" );

    if (pRtlpStackTraceDataBase == NULL) {

        dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpStackTraceDataBase\n" );
    }

    if ((BackTraceIndex != 0) && (pRtlpStackTraceDataBase != NULL)) {

        b = ReadMemory( (ULONG_PTR)pRtlpStackTraceDataBase,
                        &RtlpStackTraceDataBase,
                        sizeof( RtlpStackTraceDataBase ),
                        NULL
                      );

        if (!b || RtlpStackTraceDataBase == NULL) {

            return;
        }

        b = ReadMemory( (ULONG_PTR)RtlpStackTraceDataBase,
                        &StackTraceDataBase,
                        sizeof( StackTraceDataBase ),
                        NULL
                      );
        if (!b) {

            return;
        }


        if (BackTraceIndex < StackTraceDataBase.NumberOfEntriesAdded) {

            b = ReadMemory( (ULONG_PTR)(StackTraceDataBase.EntryIndexArray - BackTraceIndex),
                            &pBackTraceEntry,
                            sizeof( pBackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace index (%x) entry at %p\n",
                         BackTraceIndex,
                         (StackTraceDataBase.EntryIndexArray - BackTraceIndex)
                         );
                return;
            }

            b = ReadMemory( (ULONG_PTR)pBackTraceEntry,
                            &BackTraceEntry,
                            sizeof( BackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace entry at %p\n",
                         BackTraceIndex,
                         pBackTraceEntry
                         );
                return;
            }

            dprintf( "\n    Stack trace (%u) at %x:\n", BackTraceIndex, pBackTraceEntry );

            for (i=0; i<BackTraceEntry.Depth; i++) {

                GetSymbol( (LPVOID)BackTraceEntry.BackTrace[ i ],
                           Symbol,
                           &Displacement
                           );

                dprintf( "        %08x: %s", BackTraceEntry.BackTrace[ i ], Symbol );

                if (Displacement != 0) {
                    dprintf( "+0x%p", Displacement );
                }

                dprintf( "\n" );
            }
        }
    }
#endif
    return;
}


PLIST_ENTRY
DumpCritSec(
    DWORD_PTR dwAddrCritSec,
    DWORD_PTR dwAddrDebugInfo,
    BOOLEAN bDumpIfUnowned,
    BOOLEAN bOrphaned
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of the specified critical section.

Arguments:


    dwAddrCritSec - Supplies the address of the critical section to
        be dumped or NULL if dumping via debug info

    dwAddrDebugInfo - Supllies the address of a critical section debug info
        struct to be dumped or NULL if the critical section address is passed in

    bDumpIfUnowned - TRUE means to dump the critical section even if
        it is currently unowned.

    bOrphaned - TRUE: means that the caller only wants to know if the debuginfo does
        not point to a valid critical section

Return Value:

    Pointer to the next critical section in the list for the process or
    NULL if no more critical sections.

--*/

{
    USHORT i;
    CHAR Symbol[1024];
    DWORD_PTR Displacement;
    CRITICAL_SECTION CriticalSection;
    CRITICAL_SECTION_DEBUG DebugInfo;
    BOOL b;
    PLIST_ENTRY              Next=NULL;


    if (dwAddrDebugInfo != (DWORD_PTR)NULL) {
        //
        //  the address of the debug info was passes in, read it in from the debugged process
        //
        b = ReadMemory( dwAddrDebugInfo,
                        &DebugInfo,
                        sizeof(DebugInfo),
                        NULL
                      );
        if ( !b ) {

            dprintf(" NTSDEXTS: Unable to read RTL_CRITICAL_SECTION_DEBUG at %p\n", dwAddrDebugInfo );
            return NULL;
        }

        //
        //  get the critical section from the debug info
        //
        dwAddrCritSec=(DWORD_PTR)DebugInfo.CriticalSection;

        //
        //  set the next pointer now. It is only used when the debuginfo is passed in
        //
        Next=DebugInfo.ProcessLocksList.Flink;

    } else {
        //
        //  the debug info address was zero, the critical section address better not be too
        //
        if (dwAddrCritSec == (DWORD_PTR)NULL) {
            //
            //  If the debuginfo value was not valid, then the critical section value must be
            //
            return NULL;
        }
    }

    //
    //  we should now have a pointer to the critical section, either passed in or read from
    //  the debug info
    //
    //
    // Read the critical section from the debuggees address space into our
    // own.
    //
    b = ReadMemory( dwAddrCritSec,
            &CriticalSection,
               sizeof(CriticalSection),
               NULL
            );

    if ( !b ) {

        if (bDumpIfUnowned || bOrphaned) {

            dprintf("\nCritSec at %p could not be read\n",dwAddrCritSec);
            dprintf("Perhaps the critical section was a global variable in a dll that was unloaded?\n");

            if (dwAddrDebugInfo != (DWORD_PTR)NULL) {

                if (bOrphaned) {

                    DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                }
            }
        }
        return Next;

    }

    if (dwAddrDebugInfo != (DWORD_PTR)NULL) {
        //
        //  the debug info address was passed in, make sure the critical section that
        //  it pointed to points back to it.
        //
        if ((DWORD_PTR)CriticalSection.DebugInfo != dwAddrDebugInfo) {
            //
            //  this critical section does not point back to debug info that we got it from
            //
            CRITICAL_SECTION_DEBUG OtherDebugInfo;

            //
            //  now lets try to read in the debug info that this critical section points to,
            //  to see if it does point back the critical section in question
            //
            ZeroMemory(&OtherDebugInfo,sizeof(OtherDebugInfo));

            b = ReadMemory( (ULONG_PTR)CriticalSection.DebugInfo,
                            &OtherDebugInfo,
                            sizeof(DebugInfo),
                            NULL
                          );
            if ( !b ) {
                //
                //  we could not read the debug info pointed to by the critical section,
                //  probably means the critical section has been trashed
                //
                if (bDumpIfUnowned || bOrphaned) {

                    dprintf("\nCritSec at %p does not point back to the debug info at %p\n",dwAddrCritSec,dwAddrDebugInfo);
                    dprintf("Perhaps the memory that held the critical section has been reused without calling DeleteCriticalSection() ?\n");

                    if (bOrphaned) {

                        DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                    }
                }

            } else {
                //
                //  we were able to read in the debug info, see if it points to this new
                //  critical section
                //
                if ((DWORD_PTR)OtherDebugInfo.CriticalSection == dwAddrCritSec) {
                    //
                    //  the debug info points back to the critical section.
                    //  The definitely means that it was re-initialized.
                    //
                    if (bDumpIfUnowned || bOrphaned) {

                        GetSymbol((LPVOID)dwAddrCritSec,Symbol,&Displacement);
                        dprintf(
                            "\nThe CritSec %s+%lx at %p has been RE-INITIALIZED.\n",
                            Symbol,
                            Displacement,
                            dwAddrCritSec
                            );

                        dprintf("The critical section points to DebugInfo at %p instead of %p\n",(DWORD_PTR)CriticalSection.DebugInfo,dwAddrDebugInfo);

                        if (bOrphaned) {

                            DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                        }

                    }

                } else {
                    //
                    //  The debug info does not point back the critical section, probably means that
                    //  the critical section was trashed
                    //
                    if (bDumpIfUnowned || bOrphaned) {

                        dprintf("\nCritSec at %p does not point back to the debug info at %p\n",dwAddrCritSec,dwAddrDebugInfo);
                        dprintf("Perhaps the memory that held the critical section has been reused without calling DeleteCriticalSection() ?\n");

                        if (bOrphaned) {

                            DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                        }
                    }
                }
            }
        }

    } else {
        //
        //  we need to read in the debug info from the critical section since it was not passed in
        //
        ZeroMemory(&DebugInfo,sizeof(DebugInfo));

        b = ReadMemory( (ULONG_PTR)CriticalSection.DebugInfo,
                        &DebugInfo,
                        sizeof(DebugInfo),
                        NULL
                      );
        if ( !b ) {
            //
            //  use this to signal that we could not read the debuginfo for the critical section
            //
            CriticalSection.DebugInfo=NULL;

            dprintf("\nDebugInfo for CritSec at %p could not be read\n",dwAddrCritSec);
            dprintf("Probably NOT an initialized critical section.\n");

        } else {
            //
            //  we were able to read in the debug info, see if it valid
            //
            if ((DWORD_PTR)DebugInfo.CriticalSection != dwAddrCritSec) {
                //
                //  The debug info does not point back to the critical section
                //
                dprintf("\nDebugInfo for CritSec at %p does not point back to the critical section\n",dwAddrCritSec);
                dprintf("NOT an initialized critical section.\n");
            }
        }
    }

    //
    //  we should now have read in both the critical section and debug info for that critical section
    //
    if (bOrphaned) {
        //
        //  the user only wanted to check for orphaned critical sections
        //
        return Next;
    }

    //
    // Dump the critical section
    //

    if ( CriticalSection.LockCount == -1 && !bDumpIfUnowned) {
        //
        //  Lock is not held and the user does not want verbose output
        //
        return Next;
    }

    //
    // Get the symbolic name of the critical section
    //

    dprintf("\n");
    GetSymbol((LPVOID)dwAddrCritSec,Symbol,&Displacement);
    dprintf(
        "CritSec %s+%lx at %p\n",
        Symbol,
        Displacement,
        dwAddrCritSec
        );

    if ( CriticalSection.LockCount == -1) {

        dprintf("LockCount          NOT LOCKED\n");

    } else {

        dprintf("LockCount          %ld\n",CriticalSection.LockCount);
    }

    dprintf("RecursionCount     %ld\n",CriticalSection.RecursionCount);
    dprintf("OwningThread       %lx\n",CriticalSection.OwningThread);

    if (CriticalSection.DebugInfo != NULL) {
        //
        //  we have the debug info
        //
        dprintf("EntryCount         %lx\n",DebugInfo.EntryCount);
        dprintf("ContentionCount    %lx\n",DebugInfo.ContentionCount);

    }

    if ( CriticalSection.LockCount != -1) {

        dprintf("*** Locked\n");
    }

    return Next;
}

DECLARE_API( critsec )
{
    DWORD_PTR dwAddrCritSec;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the critical section to dump.
    //

    dwAddrCritSec = GetExpression(args);
    if ( !dwAddrCritSec ) {
        goto Exit;
        }

    DumpCritSec(dwAddrCritSec,0,TRUE,FALSE);

 Exit:
    EXIT_API();
}


DECLARE_API( locks )

/*++

Routine Description:

    This function is called as an NTSD extension to display all
    critical sections in the target process.

Return Value:

    None.

--*/

{
    BOOL b;
    CRITICAL_SECTION_DEBUG DebugInfo;
    PVOID AddrListHead;
    LIST_ENTRY ListHead;
    PLIST_ENTRY Next;
    BOOLEAN Verbose;
    BOOLEAN Orphaned=FALSE;
    LPCSTR p;
    DWORD   NumberOfCriticalSections;

    INIT_API();

    Verbose = FALSE;
    p = (LPSTR)args;
    while ( p != NULL && *p ) {
        if ( *p == '-' ) {
            p++;
            switch ( *p ) {
                case 'V':
                case 'v':
                    Verbose = TRUE;
                    p++;
                    break;

                case 'o':
                case 'O':
                    Orphaned=TRUE;
                    p++;
                    break;


                case ' ':
                    goto gotBlank;

                default:
                    dprintf( "NTSDEXTS: !locks invalid option flag '-%c'\n", *p );
                    break;

                }
            }
        else {
gotBlank:
            p++;
            }
        }

    if (Orphaned) {

        dprintf( "Looking for orphaned critical sections\n" );
    }
    //
    // Locate the address of the list head.
    //

    AddrListHead = (PVOID)GetExpression("ntdll!RtlCriticalSectionList");
    if ( !AddrListHead ) {
        dprintf( "NTSDEXTS: Unable to resolve ntdll!RtlCriticalSectionList\n" );
        dprintf( "NTSDEXTS: Please check your symbols\n" );
        goto Exit;
        }

    //
    // Read the list head
    //

    b = ReadMemory( (ULONG_PTR)AddrListHead,
                    &ListHead,
                    sizeof(ListHead),
                    NULL
                  );
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read memory at ntdll!RtlCriticalSectionList\n" );
        goto Exit;
        }

    Next = ListHead.Flink;

    (CheckControlC)();

    NumberOfCriticalSections=0;
    //
    // Walk the list of critical sections
    //
    while ( Next != AddrListHead ) {

        Next=DumpCritSec(
            0,
            (DWORD_PTR)CONTAINING_RECORD( Next, RTL_CRITICAL_SECTION_DEBUG, ProcessLocksList),
            Verbose,
            Orphaned
            );


        if (Next == NULL) {

            dprintf( "\nStopped scanning because of problem reading critical section debug info\n");

            break;
        }

        NumberOfCriticalSections++;

        if ((CheckControlC)()) {

            dprintf( "\nStopped scanning because of control-C\n");

            break;
        }

    }

    dprintf( "\nScanned %d critical sections\n",NumberOfCriticalSections);

 Exit:
    EXIT_API();
}


//
// Simple routine to convert from hex into a string of characters.
// Used by debugger extensions.
//
// by scottlu
//

char *
HexToString(
    ULONG_PTR dw,
    CHAR *pch
    )
{
    if (dw > 0xf) {
        pch = HexToString(dw >> 4, pch);
        dw &= 0xf;
    }

    *pch++ = ((dw >= 0xA) ? ('A' - 0xA) : '0') + (CHAR)dw;
    *pch = 0;

    return pch;
}


//
// dt == dump thread
//
// dt [v] pcsr_thread
// v == verbose (structure)
//
// by scottlu
//

DECLARE_API( dt )
{
    char chVerbose;
    CSR_THREAD csrt;
    ULONG_PTR dw;
    BOOL b;

    INIT_API();

    while (*args == ' ')
        args++;

    chVerbose = ' ';
    if (*args == 'v')
        chVerbose = *args++;

    dw = GetExpression(args);

    b = ReadMemory( dw, &csrt, sizeof(csrt), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read memory\n" );
        goto Exit;
    }

    //
    // Print simple thread info if the user did not ask for verbose.
    //
    if (chVerbose == ' ') {
        dprintf("Thread %08lx, Process %08lx, ClientId %lx.%lx, Flags %lx, Ref Count %lx\n",
                dw,
                csrt.Process,
                csrt.ClientId.UniqueProcess,
                csrt.ClientId.UniqueThread,
                csrt.Flags,
                csrt.ReferenceCount);
        goto Exit;
    }

    dprintf("PCSR_THREAD @ %08lx:\n"
            "\t+%04lx Link.Flink                %08lx\n"
            "\t+%04lx Link.Blink                %08lx\n"
            "\t+%04lx Process                   %08lx\n",
            dw,
            FIELD_OFFSET(CSR_THREAD, Link.Flink), csrt.Link.Flink,
            FIELD_OFFSET(CSR_THREAD, Link.Blink), csrt.Link.Blink,
            FIELD_OFFSET(CSR_THREAD, Process), csrt.Process);

    dprintf(
            "\t+%04lx WaitBlock                 %08lx\n"
            "\t+%04lx ClientId.UniqueProcess    %08lx\n"
            "\t+%04lx ClientId.UniqueThread     %08lx\n"
            "\t+%04lx ThreadHandle              %08lx\n",
            FIELD_OFFSET(CSR_THREAD, WaitBlock), csrt.WaitBlock,
            FIELD_OFFSET(CSR_THREAD, ClientId.UniqueProcess), csrt.ClientId.UniqueProcess,
            FIELD_OFFSET(CSR_THREAD, ClientId.UniqueThread), csrt.ClientId.UniqueThread,
            FIELD_OFFSET(CSR_THREAD, ThreadHandle), csrt.ThreadHandle);

    dprintf(
            "\t+%04lx Flags                     %08lx\n"
            "\t+%04lx ReferenceCount            %08lx\n"
            "\t+%04lx HashLinks.Flink           %08lx\n"
            "\t+%04lx HashLinks.Blink           %08lx\n",
            FIELD_OFFSET(CSR_THREAD, Flags), csrt.Flags,
            FIELD_OFFSET(CSR_THREAD, ReferenceCount), csrt.ReferenceCount,
            FIELD_OFFSET(CSR_THREAD, HashLinks.Flink), csrt.HashLinks.Flink,
            FIELD_OFFSET(CSR_THREAD, HashLinks.Blink), csrt.HashLinks.Blink);

 Exit:
    EXIT_API();
}

//
// dp == dump process
//
// dp [v] [pid | pcsr_process]
//      v == verbose (structure + thread list)
//      no process == dump process list
//
// by scottlu
//

DECLARE_API( dp )
{
    PLIST_ENTRY ListHead, ListNext;
    char ach[80];
    char chVerbose;
    PCSR_PROCESS pcsrpT;
    CSR_PROCESS csrp;
    PCSR_PROCESS pcsrpRoot;
    PCSR_THREAD pcsrt;
    ULONG_PTR dwProcessId;
    ULONG_PTR dw;
    DWORD_PTR dwRootProcess;
    BOOL b;

    INIT_API();

    while (*args == ' ')
        args++;

    chVerbose = ' ';
    if (*args == 'v')
        chVerbose = *args++;

    dwRootProcess = GetExpression("csrsrv!CsrRootProcess");
    if ( !dwRootProcess ) {
        goto Exit;
        }

    b = ReadMemory( dwRootProcess, &pcsrpRoot, sizeof(pcsrpRoot), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read RootProcess\n" );
        goto Exit;
    }
    //
    // See if user wants all processes. If so loop through them.
    //
    if (*args == 0) {
        ListHead = &pcsrpRoot->ListLink;
        b = ReadMemory( (ULONG_PTR)(&ListHead->Flink), &ListNext, sizeof(ListNext), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        while (ListNext != ListHead) {
            pcsrpT = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);

            ach[0] = chVerbose;
            ach[1] = ' ';
            HexToString((ULONG_PTR)pcsrpT, &ach[2]);

            dp(Client, ach);

            b = ReadMemory( (ULONG_PTR)(&ListNext->Flink), &ListNext, sizeof(ListNext), NULL);
            if ( !b ) {
                dprintf( "NTSDEXTS: Unable to read ListNext\n" );
                goto Exit;
            }
        }

        dprintf("---\n");
        goto Exit;
    }

    //
    // User wants specific process structure. Evaluate to find id or process
    // pointer.
    //
    dw = (ULONG)GetExpression(args);

    ListHead = &pcsrpRoot->ListLink;
    b = ReadMemory( (ULONG_PTR)(&ListHead->Flink), &ListNext, sizeof(ListNext), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read ListNext\n" );
        goto Exit;
    }

    while (ListNext != ListHead) {
        pcsrpT = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);
        b = ReadMemory( (ULONG_PTR)(&ListNext->Flink), &ListNext, sizeof(ListNext), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        b = ReadMemory( (ULONG_PTR)(&pcsrpT->ClientId.UniqueProcess), &dwProcessId, sizeof(dwProcessId), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        if (dw == dwProcessId) {
            dw = (ULONG_PTR)pcsrpT;
            break;
        }
    }

    pcsrpT = (PCSR_PROCESS)dw;
    b = ReadMemory( (ULONG_PTR)pcsrpT, &csrp, sizeof(csrp), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read RootProcess\n" );
        goto Exit;
    }

    //
    // If not verbose, print simple process info.
    //
    if (chVerbose == ' ') {
        dprintf("Process %08lx, Id %p, Seq# %lx, Flags %lx, Ref Count %lx\n",
                pcsrpT,
                csrp.ClientId.UniqueProcess,
                csrp.SequenceNumber,
                csrp.Flags,
                csrp.ReferenceCount);
        goto Exit;
    }

    dprintf("PCSR_PROCESS @ %08lx:\n"
            "\t+%04lx ListLink.Flink            %08lx\n"
            "\t+%04lx ListLink.Blink            %08lx\n"
            "\t+%04lx Parent                    %08lx\n",
            pcsrpT,
            FIELD_OFFSET(CSR_PROCESS, ListLink.Flink), csrp.ListLink.Flink,
            FIELD_OFFSET(CSR_PROCESS, ListLink.Blink), csrp.ListLink.Blink,
            FIELD_OFFSET(CSR_PROCESS, Parent), csrp.Parent);

    dprintf(
            "\t+%04lx ThreadList.Flink          %08lx\n"
            "\t+%04lx ThreadList.Blink          %08lx\n"
            "\t+%04lx NtSession                 %08lx\n"
            "\t+%04lx ExpectedVersion           %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ThreadList.Flink), csrp.ThreadList.Flink,
            FIELD_OFFSET(CSR_PROCESS, ThreadList.Blink), csrp.ThreadList.Blink,
            FIELD_OFFSET(CSR_PROCESS, NtSession), csrp.NtSession,
            FIELD_OFFSET(CSR_PROCESS, ExpectedVersion), csrp.ExpectedVersion);

    dprintf(
            "\t+%04lx ClientPort                %08lx\n"
            "\t+%04lx ClientViewBase            %08lx\n"
            "\t+%04lx ClientViewBounds          %08lx\n"
            "\t+%04lx ClientId.UniqueProcess    %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ClientPort), csrp.ClientPort,
            FIELD_OFFSET(CSR_PROCESS, ClientViewBase), csrp.ClientViewBase,
            FIELD_OFFSET(CSR_PROCESS, ClientViewBounds), csrp.ClientViewBounds,
            FIELD_OFFSET(CSR_PROCESS, ClientId.UniqueProcess), csrp.ClientId.UniqueProcess);

    dprintf(
            "\t+%04lx ProcessHandle             %08lx\n"
            "\t+%04lx SequenceNumber            %08lx\n"
            "\t+%04lx Flags                     %08lx\n"
            "\t+%04lx DebugFlags                %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ProcessHandle), csrp.ProcessHandle,
            FIELD_OFFSET(CSR_PROCESS, SequenceNumber), csrp.SequenceNumber,
            FIELD_OFFSET(CSR_PROCESS, Flags), csrp.Flags,
            FIELD_OFFSET(CSR_PROCESS, DebugFlags), csrp.DebugFlags);

    dprintf(
            "\t+%04lx DebugUserInterface        %08lx\n"
            "\t+%04lx ReferenceCount            %08lx\n"
            "\t+%04lx ProcessGroupId            %08lx\n"
            "\t+%04lx ProcessGroupSequence      %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, DebugUserInterface.UniqueProcess), csrp.DebugUserInterface.UniqueProcess,
            FIELD_OFFSET(CSR_PROCESS, ReferenceCount), csrp.ReferenceCount,
            FIELD_OFFSET(CSR_PROCESS, ProcessGroupId), csrp.ProcessGroupId,
            FIELD_OFFSET(CSR_PROCESS, ProcessGroupSequence), csrp.ProcessGroupSequence);

    dprintf(
            "\t+%04lx fVDM                      %08lx\n"
            "\t+%04lx ThreadCount               %08lx\n"
            "\t+%04lx PriorityClass             %08lx\n"
            "\t+%04lx ShutdownLevel             %08lx\n"
            "\t+%04lx ShutdownFlags             %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, fVDM), csrp.fVDM,
            FIELD_OFFSET(CSR_PROCESS, ThreadCount), csrp.ThreadCount,
            FIELD_OFFSET(CSR_PROCESS, PriorityClass), csrp.PriorityClass,
            FIELD_OFFSET(CSR_PROCESS, ShutdownLevel), csrp.ShutdownLevel,
            FIELD_OFFSET(CSR_PROCESS, ShutdownFlags), csrp.ShutdownFlags);

    //
    // Now dump simple thread info for this processes' threads.
    //

    ListHead = &pcsrpT->ThreadList;
    b = ReadMemory( (ULONG_PTR)(&ListHead->Flink), &ListNext, sizeof(ListNext), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read ListNext\n" );
        goto Exit;
    }

    dprintf("Threads:\n");

    while (ListNext != ListHead) {
        pcsrt = CONTAINING_RECORD(ListNext, CSR_THREAD, Link);

        //
        // Make sure this pcsrt is somewhat real so we don't loop forever.
        //
        b = ReadMemory( (ULONG_PTR)(&pcsrt->ClientId.UniqueProcess), &dwProcessId, sizeof(dwProcessId), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        if (dwProcessId != (DWORD_PTR)csrp.ClientId.UniqueProcess) {
            dprintf("Invalid thread. Probably invalid argument to this extension.\n");
            goto Exit;
        }

        HexToString((ULONG_PTR)pcsrt, ach);
        dt(Client, ach);

        b = ReadMemory( (ULONG_PTR)(&ListNext->Flink), &ListNext, sizeof(ListNext), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }
    }

 Exit:
    EXIT_API();
}



VOID
DllsExtension(
    PCSTR args,
    PPEB ProcessPeb
    );

DECLARE_API( gatom )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the global atom table
    kept in kernel mode

    Called as:

        !gatom

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ATOM_TABLE_INFORMATION TableInfo;
    PATOM_TABLE_INFORMATION pTableInfo;
    PATOM_BASIC_INFORMATION pBasicInfo;
    ULONG RequiredLength, MaxLength, i;

    INIT_API();

    dprintf("\nGlobal atom table ");
    Status = NtQueryInformationAtom( RTL_ATOM_INVALID_ATOM,
                                     AtomTableInformation,
                                     &TableInfo,
                                     sizeof( TableInfo ),
                                     &RequiredLength
                                   );
    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        dprintf( " - cant get information - %x\n", Status );
        goto Exit;
        }

    RequiredLength += 100 * sizeof( RTL_ATOM );
    pTableInfo = LocalAlloc( 0, RequiredLength );
    if (pTableInfo == NULL) {
        dprintf( " - cant allocate memory for %u atoms\n", RequiredLength / sizeof( RTL_ATOM ) );
        goto Exit;
        }

    Status = NtQueryInformationAtom( RTL_ATOM_INVALID_ATOM,
                                     AtomTableInformation,
                                     pTableInfo,
                                     RequiredLength,
                                     &RequiredLength
                                   );
    if (!NT_SUCCESS( Status )) {
        dprintf( " - cant get information about %x atoms - %x\n", RequiredLength / sizeof( RTL_ATOM ), Status );
        LocalFree( pTableInfo );
        goto Exit;
        }

    MaxLength = sizeof( *pBasicInfo ) + RTL_ATOM_MAXIMUM_NAME_LENGTH;
    pBasicInfo = LocalAlloc( 0, MaxLength );
    
    if (!pBasicInfo) {
        dprintf("LocalAlloc failed.\n");
        goto Exit;
    }
    
    for (i=0; i<pTableInfo->NumberOfAtoms; i++) {
        Status = NtQueryInformationAtom( pTableInfo->Atoms[ i ],
                                         AtomBasicInformation,
                                         pBasicInfo,
                                         MaxLength,
                                         &RequiredLength
                                       );
        if (!NT_SUCCESS( Status )) {
            dprintf( "%hx *** query failed (%x)\n", Status );
            }
        else {
            dprintf( "%hx(%2d) = %ls (%d)%s\n",
                     pTableInfo->Atoms[ i ],
                     pBasicInfo->UsageCount,
                     pBasicInfo->Name,
                     pBasicInfo->NameLength,
                     pBasicInfo->Flags & RTL_ATOM_PINNED ? " pinned" : ""
                   );
            }
        }

 Exit:
    EXIT_API();
}

#include "hleak.c"

#include "secexts.c"



/*++

Routine Description:

    This function is called as an NTSD extension to mimic the !handle
    kd command.  This will walk through the debuggee's handle table
    and duplicate the handle into the ntsd process, then call NtQueryobjectInfo
    to find out what it is.

    Called as:

        !handle [handle [flags [Type]]]

    If the handle is 0 or -1, all handles are scanned.  If the handle is not
    zero, that particular handle is examined.  The flags are as follows
    (corresponding to secexts.c):
        1   - Get type information (default)
        2   - Get basic information
        4   - Get name information
        8   - Get object specific info (where available)

    If Type is specified, only object of that type are scanned.  Type is a
    standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of
    course.

    Examples:

        !handle     -- dumps the types of all the handles, and a summary table
        !handle 0 0 -- dumps a summary table of all the open handles
        !handle 0 f -- dumps everything we can find about a handle.
        !handle 0 f Event
                    -- dumps everything we can find about open events

--*/
DECLARE_API( handle )
{
    HANDLE  hThere;
    DWORD   Type;
    DWORD   Mask;
    DWORD   HandleCount;
    NTSTATUS Status;
    DWORD   Total;
    DWORD   TypeCounts[TYPE_MAX];
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    DWORD   ObjectType;
    BOOL    GetDirect;
    ULONG   SessionType;
    ULONG   SessionQual;

    INIT_API();

    Mask = GHI_TYPE ;
    hThere = INVALID_HANDLE_VALUE;
    Type = 0;

    while (*args == ' ') {
        args++;
    }

    if ( strcmp( args, "-?" ) == 0 )
    {
        help(Client, "handle" );

        goto Exit;
    }

    hThere = (PVOID) GetExpression( args );

    while (*args && (*args != ' ') ) {
        args++;
    }
    while (*args == ' ') {
        args++;
    }

    if (*args) {
        Mask = (DWORD)GetExpression( args );
    }

    while (*args && (*args != ' ') ) {
        args++;
    }
    while (*args == ' ') {
        args++;
    }

    if (*args) {
        Type = GetObjectTypeIndex( (LPSTR)args );
        if (Type == (DWORD) -1 ) {
            dprintf("Unknown type '%s'\n", args );
            goto Exit;
        }
    }

    //
    // if they specified 0, they just want the summary.  Make sure nothing
    // sneaks out.
    //

    if ( Mask == 0 ) {
        Mask = GHI_SILENT;
    }

    //
    // If this is a dump debug session,
    // check and see whether we can retrieve handle
    // information through the engine interface.
    //

    if (g_ExtControl == NULL ||
        g_ExtControl->lpVtbl->
        GetDebuggeeType(g_ExtControl, &SessionType, &SessionQual) != S_OK) {
        SessionType = DEBUG_CLASS_USER_WINDOWS;
        SessionQual = DEBUG_USER_WINDOWS_PROCESS;
    }

    if (SessionType == DEBUG_CLASS_USER_WINDOWS &&
        SessionQual != DEBUG_USER_WINDOWS_PROCESS) {

        // This is a dump or remote session so we have to use
        // the stored handle information accessible
        // through the interface.
        if (g_ExtData2 == NULL ||
            g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, 0, DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT,
                           &HandleCount, sizeof(HandleCount),
                           NULL) != S_OK) {
            dprintf("Unable to read handle information\n");
            goto Exit;
        }

        GetDirect = FALSE;
        
    } else {

        // This is a live session so we can make direct NT calls.
        // More information is available this way so we use it
        // whenever we can.
        GetDirect = TRUE;
    }
    
    //
    // hThere of 0 indicates all handles.
    //
    if ((hThere == 0) || (hThere == INVALID_HANDLE_VALUE)) {

        if (GetDirect) {
            Status = NtQueryInformationProcess( g_hCurrentProcess,
                                                ProcessHandleCount,
                                                &HandleCount,
                                                sizeof( HandleCount ),
                                                NULL );

            if ( !NT_SUCCESS( Status ) ) {
                goto Exit;
            }
        }

        Hits = 0;
        Handle = 0;
        Matches = 0;
        ZeroMemory( TypeCounts, sizeof(TypeCounts) );

        while ( Hits < HandleCount ) {
            if ( Type ) {
                if (GetHandleInfo( GetDirect, g_hCurrentProcess,
                                   (HANDLE) (DWORD_PTR) Handle,
                                   GHI_TYPE | GHI_SILENT,
                                   &ObjectType ) ) {
                    Hits++;
                    if ( ObjectType == Type ) {
                        GetHandleInfo( GetDirect, g_hCurrentProcess,
                                       (HANDLE)(DWORD_PTR)Handle,
                                       Mask,
                                       &ObjectType );
                        Matches ++;
                    }

                }
            } else {
                if (GetHandleInfo(  GetDirect, g_hCurrentProcess,
                                    (HANDLE)(DWORD_PTR)Handle,
                                    GHI_TYPE | GHI_SILENT,
                                    &ObjectType) ) {
                    Hits++;
                    TypeCounts[ ObjectType ] ++;

                    GetHandleInfo(  GetDirect, g_hCurrentProcess,
                                    (HANDLE)(DWORD_PTR)Handle,
                                    Mask,
                                    &ObjectType );

                }
            }

            Handle += 4;
        }

        if ( Type == 0 ) {
            dprintf( "%d Handles\n", Hits );
            dprintf( "Type           \tCount\n");
            for (Type = 0; Type < TYPE_MAX ; Type++ ) {
                if (TypeCounts[Type]) {
                    dprintf("%-15ws\t%d\n", pszTypeNames[Type], TypeCounts[Type]);
                }
            }
        } else {
            dprintf("%d handles of type %ws\n", Matches, pszTypeNames[Type] );
        }


    } else {
        GetHandleInfo( GetDirect, g_hCurrentProcess, hThere, Mask, &Type );
    }

 Exit:
    EXIT_API();
}


DECLARE_API( threadtoken )
{
    HANDLE hToken ;
    NTSTATUS Status ;

    INIT_API();

    Status = NtOpenThreadToken(
                    g_hCurrentThread,
                    TOKEN_READ,
                    TRUE,
                    &hToken );

    if ( !NT_SUCCESS( Status ) )
    {
        if ( Status == STATUS_ACCESS_DENIED )
        {
            //
            // Try to get around the ACL:
            //
        }

        if ( Status != STATUS_NO_TOKEN )
        {
            dprintf( "Can't open token, %d\n", RtlNtStatusToDosError( Status ) );
            goto Exit;
        }

        Status = NtOpenProcessToken(
                    g_hCurrentProcess,
                    TOKEN_READ,
                    &hToken );

        if ( !NT_SUCCESS( Status ) )
        {
            dprintf( "Can't open any token, %d\n", RtlNtStatusToDosError( Status ) );
            goto Exit;
        }

        dprintf( "\n***Thread is not impersonating, using process token***\n" );
    }

    TokenInfo( hToken, 0xFFF );

    NtClose( hToken );

 Exit:
    EXIT_API();
}



#define PAGE_ALL (PAGE_READONLY|\
                  PAGE_READWRITE|\
                  PAGE_WRITECOPY|\
                  PAGE_EXECUTE|\
                  PAGE_EXECUTE_READ|\
                  PAGE_EXECUTE_READWRITE|\
                  PAGE_EXECUTE_WRITECOPY|\
                  PAGE_NOACCESS)

VOID
printflags(
    DWORD Flags
    )
{
    switch (Flags & PAGE_ALL) {
        case PAGE_READONLY:
            dprintf("PAGE_READONLY");
            break;
        case PAGE_READWRITE:
            dprintf("PAGE_READWRITE");
            break;
        case PAGE_WRITECOPY:
            dprintf("PAGE_WRITECOPY");
            break;
        case PAGE_EXECUTE:
            dprintf("PAGE_EXECUTE");
            break;
        case PAGE_EXECUTE_READ:
            dprintf("PAGE_EXECUTE_READ");
            break;
        case PAGE_EXECUTE_READWRITE:
            dprintf("PAGE_EXECUTE_READWRITE");
            break;
        case PAGE_EXECUTE_WRITECOPY:
            dprintf("PAGE_EXECUTE_WRITECOPY");
            break;
        case PAGE_NOACCESS:
            if ((Flags & ~PAGE_NOACCESS) == 0) {
                dprintf("PAGE_NOACCESS");
                break;
            } // else fall through
        default:
            dprintf("*** Invalid page protection ***\n");
            return;
            break;
    }

    if (Flags & PAGE_NOCACHE) {
        dprintf(" + PAGE_NOCACHE");
    }
    if (Flags & PAGE_GUARD) {
        dprintf(" + PAGE_GUARD");
    }
    dprintf("\n");
}



DECLARE_API( vprot )
/*++

Routine Description:

    This debugger extension dumps the virtual memory info for the
    address specified.

Arguments:


Return Value:

--*/
{
    PVOID Address;
    MEMORY_BASIC_INFORMATION mbi;

    INIT_API();

    while (*args == ' ') {
        args++;
    }

    Address = (PVOID)GetExpression( args );


    if (!VirtualQueryEx( g_hCurrentProcess, Address, &mbi, sizeof(mbi))) {
        dprintf("vprot: VirtualQueryEx failed, error = %d\n", GetLastError());
        goto Exit;
    }

    dprintf("BaseAddress:       %p\n",   mbi.BaseAddress);
    dprintf("AllocationBase:    %08x\n", mbi.AllocationBase);
    dprintf("AllocationProtect: %08x  ", mbi.AllocationProtect);
    printflags(mbi.AllocationProtect);

    dprintf("RegionSize:        %08x\n", mbi.RegionSize);
    dprintf("State:             %08x  ", mbi.State);
    switch (mbi.State) {
        case MEM_COMMIT:
            dprintf("MEM_COMMIT\n");
            break;
        case MEM_FREE:
            dprintf("MEM_FREE\n");
            break;
        case MEM_RESERVE:
            dprintf("MEM_RESERVE\n");
            break;
        default:
            dprintf("*** Invalid page state ***\n");
            break;
    }

    dprintf("Protect:           %08x  ", mbi.Protect);
    printflags(mbi.Protect);

    dprintf("Type:              %08x  ", mbi.Type);
    switch(mbi.Type) {
        case MEM_IMAGE:
            dprintf("MEM_IMAGE\n");
            break;
        case MEM_MAPPED:
            dprintf("MEM_MAPPED\n");
            break;
        case MEM_PRIVATE:
            dprintf("MEM_PRIVATE\n");
            break;
        default:
            dprintf("*** Invalid page type ***\n");
            break;
    }

 Exit:
    EXIT_API();
}


#include "leak.c"


#include "regexts.c"
/*++

Routine Description:

    This function is called as an NTSD extension to dump registry information

    Called as:

        !dreg -[d|w] <keyPath>[![<valueName> | *]]

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

DECLARE_API( dreg )
{
    DWORD    opts = 1;

    INIT_API();


    // Skip past leading spaces
    while (*args == ' ')
    {
        args++;
    }

    if (*args == '-')
    {
        args++;
        switch (*args)
        {
        case 'd':
            opts = 4;
            break;
        case 'w':
            opts = 2;
            break;
        default:
            opts = 1;
            break;
        }

        if (*args)
        {
            // expect a space between options
            args++;

            // Skip past leading spaces
            while (*args == ' ')
            {
                args++;
            }
        }
    }

    Idreg(opts, (LPSTR)args);

    EXIT_API();
}


/*++

Routine Description:

    This function is called as an NTSD extension to dump handle tracing information

    Called as:

        !htrace [handle]

Arguments:

    args - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

DECLARE_API( htrace )
{
    HANDLE Handle;
    PPROCESS_HANDLE_TRACING_QUERY Info;
    ULONG_PTR Displacement;
    NTSTATUS Status;
    ULONG CurrentBufferSize;
    ULONG CrtStackTrace;
    ULONG EntriesDisplayed;
    ULONG CapturedAddressIndex;
    PVOID *CrtStack;
    PVOID CapturedAddress;
    SYSTEM_BASIC_INFORMATION SysBasicInfo;
    CHAR Symbol[ 1024 ];

    INIT_API();

    Info = NULL;
    CrtStackTrace = 0;
    EntriesDisplayed = 0;

    //
    // Did the user ask for some help?
    //

    if (strcmp (args, "-?") == 0 ||
        strcmp (args, "?") == 0  ||
        strcmp (args, "-h") == 0) {

        dprintf ("!htrace [handle]\n");
        goto DoneAll;
    }
    
    //
    // Get the handle from the command line
    //

    Handle = (HANDLE)GetExpression (args);

    //
    // Get the stack traces using NtQueryInformationProcess
    //

    CurrentBufferSize = sizeof (PROCESS_HANDLE_TRACING_QUERY);

    while (TRUE) {

        //
        // Allocate a new buffer
        //

        Info = (PPROCESS_HANDLE_TRACING_QUERY)malloc (CurrentBufferSize);

        if (Info == NULL) {

            dprintf ("ERROR: Cannot allocate buffer with size 0x%p\n",
                     CurrentBufferSize);
            goto DoneAll;
        }

        ZeroMemory( Info, 
                    CurrentBufferSize );

        Status = NtQueryInformationProcess (g_hCurrentProcess,
                                            ProcessHandleTracing,
                                            Info,
                                            CurrentBufferSize,
                                            NULL );

        if( NT_SUCCESS (Status) ) {

            //
            // We have all the information ready
            //

            break;
        }

        CurrentBufferSize = sizeof (PROCESS_HANDLE_TRACING_QUERY) + Info->TotalTraces * sizeof (Info->HandleTrace[ 0 ]);
        
        free (Info);
        Info = NULL;

        if( CheckControlC() ) {

            goto DoneAll;
        }

        if (Status != STATUS_INFO_LENGTH_MISMATCH) {

            //
            // No reason to try querying again
            //

            dprintf ("Query process information failed, status 0x%X\n",
                     Status);

            goto DoneAll;
        }

        //
        // Try allocating another buffer with the new size
        //
    }

    //
    // If we have 0 stack traces there is nothing we can dump
    //

    if (Info->TotalTraces == 0) {

        dprintf( "No stack traces available.\n" );
        goto DoneAll;
    }

    //
    // Find out the highest user address because
    // we will skip kernel mode addresses from the stack traces.
    //

    
    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &SysBasicInfo,
                                       sizeof (SysBasicInfo),
                                       NULL);

    if (!NT_SUCCESS (Status)) {

        dprintf ("Query system basic information failed, status 0x%X\n",
                 Status);

        goto DoneAll;
    }

    //
    // Dump all the stack traces.
    //

    for (CrtStackTrace = 0; CrtStackTrace < Info->TotalTraces; CrtStackTrace += 1) {

        if( CheckControlC() ) {

            CrtStackTrace += 1;
            goto DoneDumping;
        }

        if (Handle == 0 || Handle == Info->HandleTrace[ CrtStackTrace ].Handle) {

            EntriesDisplayed += 1;

            dprintf ("--------------------------------------\n"
                     "Handle = 0x%p - ",
                     Info->HandleTrace[ CrtStackTrace ].Handle);
                 
            switch( Info->HandleTrace[ CrtStackTrace ].Type ) {

            case HANDLE_TRACE_DB_OPEN:
                dprintf( "OPEN:\n" );
                break;

            case HANDLE_TRACE_DB_CLOSE:
                dprintf( "CLOSE:\n" );
                break;

            case HANDLE_TRACE_DB_BADREF:
                dprintf( "*** BAD REFERENCE ***:\n" );
                break;

            default:
                dprintf( "Invalid operation type: %u\n",
                         Info->HandleTrace[ CrtStackTrace ].Type );
                goto DoneDumping;
            }

            for (CapturedAddressIndex = 0, CrtStack = &Info->HandleTrace[ CrtStackTrace ].Stacks[ 0 ];
                 CapturedAddressIndex < (sizeof(Info->HandleTrace[ CrtStackTrace ].Stacks) /
                                         sizeof(Info->HandleTrace[ CrtStackTrace ].Stacks[0]));
                 CapturedAddressIndex += 1, CrtStack += 1) {

                if( CheckControlC() ) {

                    CrtStackTrace += 1;
                    goto DoneDumping;
                }

                CapturedAddress = *CrtStack;

                if (CapturedAddress == NULL) {

                    //
                    // Done with dumping this stack trace
                    //

                    break;
                }

                if ((ULONG_PTR)CapturedAddress > SysBasicInfo.MaximumUserModeAddress) {

                    //
                    // Skip kernel-mode addresses
                    //

                    continue;
                }

                GetSymbol (CapturedAddress,
                           Symbol,
                           &Displacement);

                dprintf ("0x%p: %s+0x%p\n",
                         CapturedAddress,
                         Symbol,
                         Displacement );
            }
        }
    }

DoneDumping:

    dprintf ("\n--------------------------------------\n"
            "Parsed 0x%X stack traces.\n"
            "Dumped 0x%X stack traces.\n",
            CrtStackTrace,
            EntriesDisplayed);

DoneAll:

    if (Info != NULL) {

        free (Info);
    }

    EXIT_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\regexts.c ===
/*******************************************************************
*
*    Copyright (c) 1999  Microsoft Corporation
*
*    DESCRIPTION: an extension to dump the contents of registry keys and values
*
*    AUTHOR:
*         Based on Code by : danielwe (Dan Weisman)
*         ntsd addition by : kksharma (Kshitiz K. Sharma)
*
*    DATE:4/20/1999
*
*******************************************************************/


#ifndef KERNEL

#ifndef Print
#define Print dprintf
#endif


#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define LINE_NUMBER     0
#define NUM_ASCII_CHARS 16
#define NUM_HEX_CHARS   (NUM_ASCII_CHARS * 3)
#define SPACE           7
#define PB_BUFFER_SIZE  (NUM_ASCII_CHARS * 50)

VOID dregHelp() {
   dprintf("!dreg -[d|w] <keyPath>[![<valueName> | *]]  - Dumps registry information\n");
   dprintf("!dreg -d ...                                - Prints binary values as DWORDs\n");
   dprintf("!dreg -w ...                                - Prints binary values as WORDs\n");
   dprintf("!dreg <keyPath>!*                           - Prints all values under <keyPath>\n");
   dprintf("!dreg <keyPath>                             - Prints all subkeys of <keyPath>\n");
   dprintf("\n");
   dprintf("<keypath> can begin with any of the following:\n");
   dprintf("\thklm - HKEY_LOCAL_MACHINE\n");
   dprintf("\thkcu - HKEY_CURRENT_USER\n");
   dprintf("\thkcr - HKEY_CLASSES_ROOT\n");
   dprintf("\thku  - HKEY_USERS\n");
   dprintf("\tif absent, hklm is assumed\n");
   dprintf("\n");
   dprintf("Ex:\n");
   dprintf("!dreg hkcu\\Software\\Microsoft\n");
   dprintf("!dreg System\\CurrentControlSet\\Services\\Tcpip!*\n");
   dprintf("!dreg System\\CurrentControlSet\\Services\\Tcpip!Start\n");
}

VOID PrintBinary(PBYTE pbData, DWORD cbData, USHORT uWidth)
{
    CHAR    line[80];
    INT     i;
    INT     ascii = 0;
    PBYTE   temp = pbData;
    BOOL    fDone = FALSE;
    DWORD   cbCount = 0;

    CHAR hex_digits[] = "0123456789ABCDEF";

    while (!fDone)
    {
        DWORD   cb;

        memset(line, 0x20, sizeof(line));
        Print("%04X:  ", cbCount);
        for (ascii = 0,i = LINE_NUMBER, cb = 0;
             ascii < NUM_ASCII_CHARS;
             ascii++, temp++)
        {
            if ((DWORD)(temp - pbData) >= cbData)
            {
                if (cbData < PB_BUFFER_SIZE)
                {
                    fDone = TRUE;
                    break;
                }
                else
                    return;
            }
            line[i] = hex_digits[(*temp & 0xF0) >> 4];
            line[i + 1] = hex_digits[(*temp & 0x0F)];
            cb++;
            if ((ascii + 1) % uWidth == 0)
            {
                line[i + 2] = 0x20;
                i++;
                if (uWidth > 1)
                {
                    line[i + 3] = 0x20;
                    i++;
                }
                else if (uWidth == 1 && (!(cb % 4)))
                {
                    line[i + 3] = 0x20;
                    line[i + 4] = 0x20;
                    i += 2;
                }
            }
            i += 2;
            line[ascii + NUM_HEX_CHARS + SPACE + LINE_NUMBER] =
                (isprint(*temp) ? *temp : '.');
            cbCount++;
        }

        line[79] = 0;
        Print("%s\n", line);
    }
}

VOID PrintMultiSz(PBYTE pbData)
{
    LPSTR   sz = (LPSTR)pbData;
    DWORD   csz = 0;

    while (*sz)
    {
        Print("%d: \"%s\"\n", csz, *sz ? sz : "<empty>");
        csz++;
        sz += lstrlenA(sz) + 1;
    }
}

VOID PrintRegistryValue(DWORD dwType, PBYTE pbData, DWORD cbData, USHORT uWidth)
{
    switch (dwType)
    {
    case REG_SZ:
        Print("REG_SZ: \"%s\"\n", *pbData ? pbData : "<empty>");
        break;

    case REG_EXPAND_SZ:
        {
            CHAR    szExpanded[MAX_PATH + 1];

            Print("REG_EXPAND_SZ: \"%s\"\n", pbData);
            ExpandEnvironmentStringsA((LPCSTR)pbData, (LPSTR)&szExpanded,
                                      MAX_PATH);
            Print("expanded = \"%s\"\n", szExpanded);
            break;
        }

    case REG_DWORD:
        {
            DWORD   dwData = * ((DWORD *)pbData);

            Print("REG_DWORD: %lu = 0x%08X\n", dwData, dwData);
            break;
        }

    case REG_BINARY:
        {
            Print("REG_BINARY:\n");
            PrintBinary(pbData, cbData, uWidth);
            break;
        }

    case REG_MULTI_SZ:
        {
            Print("REG_MULTI_SZ:\n");
            PrintMultiSz(pbData);
            break;
        }
    }
}

VOID EnumSubKeys(HKEY hkeyRoot, LPSTR szKey)
{
    HKEY    hkey;
    LONG    l;
    BOOL    fFound = FALSE;

    l = RegOpenKeyExA(hkeyRoot, szKey, 0, KEY_READ, &hkey);
    if (ERROR_SUCCESS == l)
    {
        FILETIME    ft;
        DWORD       cbName;
        CHAR        szName[MAX_PATH + 1];
        DWORD       dwIndex;

        for (dwIndex = 0; l == ERROR_SUCCESS; dwIndex++)
        {
            cbName = MAX_PATH;
            l = RegEnumKeyExA(hkey, dwIndex, szName, &cbName, NULL,
                              NULL, NULL,&ft);
            if (ERROR_SUCCESS == l)
            {
                Print("Subkey: %s\n", szName);
                fFound = TRUE;
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        Print("Could not open subkey %s. Error (%d).\n", szKey, l);
    }

    if (!fFound)
    {
        Print("No subkeys\n");
    }
}

VOID EnumValues(HKEY hkeyRoot, LPSTR szKey, USHORT uWidth)
{
    HKEY    hkey;
    LONG    l;
    BOOL    fFound = FALSE;

    l = RegOpenKeyExA(hkeyRoot, szKey, 0, KEY_READ, &hkey);
    if (ERROR_SUCCESS == l)
    {
        DWORD   cbMax;

        l = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                             NULL, &cbMax, NULL, NULL);
        if (ERROR_SUCCESS == l)
        {
            DWORD       cbName;
            CHAR        szName[MAX_PATH + 1];
            DWORD       dwIndex;
            PBYTE       pbData;
            DWORD       dwType;
            DWORD       cbData;

            pbData = (PBYTE)LocalAlloc(LPTR, cbMax);

            if (pbData)
            {
                for (dwIndex = 0; l == ERROR_SUCCESS; dwIndex++)
                {
                    cbName = MAX_PATH;
                    cbData = cbMax;
                    l = RegEnumValueA(hkey, dwIndex, szName, &cbName, NULL,
                                      &dwType, pbData, &cbData);
                    if (ERROR_SUCCESS == l)
                    {
                        Print("Value: \"%s\" - ", szName);
                        PrintRegistryValue(dwType, pbData, cbData, uWidth);
                        Print("------------------------------------------------------------------------\n");
                        fFound = TRUE;
                    }
                }

                LocalFree(pbData);
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        Print("Could not open subkey %s. Error (%d).\n", szKey, l);
    }

    if (!fFound)
    {
        Print("No values\n");
    }
}

/************************************************************************\
* Procedure: Idreg
*
* Description: Dumps registry value
*
* Returns: fSuccess
*
* 4/14/1999 Created DanielWe
*
\************************************************************************/
BOOL Idreg(
DWORD opts,
LPCSTR InString)
{
    LONG    l;
    HKEY    hkey;
    DWORD   cbData = 0;
    DWORD   dwType;
    LPBYTE  pbData = NULL;
    LPSTR   szKey = NULL;
    LPSTR   szValue = NULL;
    CHAR    String[512];
    LPTSTR  lpas = String;
    LPTSTR  lpasOrig = String;
    HKEY    hkeyRoot;

    strcpy(String, InString);

    // Eat leading spaces first
    while (*lpas && *lpas == ' ')
    {
        lpas++;
    }

    while (*lpas && *lpas != '\\')
    {
        lpas++;
    }

    if (!*lpas)
    {
        // Corner case.. no backslash at all. Assume HKLM and start over
        hkeyRoot = HKEY_LOCAL_MACHINE;
        lpas = lpasOrig;
    }
    else
    {
        // Figure out which hive they want to open
        *lpas = 0;
        if (!lstrcmpiA(lpasOrig, "hkcu"))
        {
            hkeyRoot = HKEY_CURRENT_USER;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "hklm"))
        {
            hkeyRoot = HKEY_LOCAL_MACHINE;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "hku"))
        {
            hkeyRoot = HKEY_USERS;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "hkcr"))
        {
            hkeyRoot = HKEY_CLASSES_ROOT;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "help"))
        {
           dregHelp();
           return FALSE;
        }
        else
        {
            hkeyRoot = HKEY_LOCAL_MACHINE;

            // Restore the backslash because we assume if they don't use these
            // keywords, then they want HKLM
            *lpas = '\\';
            lpas = lpasOrig;
        }
    }

    szKey = (LPSTR)lpas;

    while (*lpas && *lpas != '!')
    {
        lpas++;
    }

    if (*lpas)
    {
        // Null terminate the !
        *lpas++ = 0;

        // mark beginning of new string
        szValue = (LPSTR)lpas;
    }

    if (szKey == NULL || *szKey == 0)
    {
        Print("Expected subkey name\n");
        dregHelp();
        return FALSE;
    }
    if (szValue == NULL || *szValue == 0)
    {
        EnumSubKeys(hkeyRoot, szKey);
    }
    else if (!lstrcmpA(szValue, "*"))
    {
        EnumValues(hkeyRoot, szKey, (USHORT)opts);
    }
    else
    {
        l = RegOpenKeyExA(hkeyRoot, (LPCSTR)szKey, 0, KEY_READ, &hkey);
        if (ERROR_SUCCESS == l)
        {
            l = RegQueryValueExA(hkey, (LPCSTR)szValue, NULL, &dwType, NULL,
                                &cbData);
            if (ERROR_SUCCESS == l)
            {
                pbData = (LPBYTE)LocalAlloc(LPTR, cbData);
                l = RegQueryValueExA(hkey, (LPCSTR)szValue, NULL, &dwType, pbData,
                                    &cbData);
                if (ERROR_SUCCESS == l)
                {
                    PrintRegistryValue(dwType, pbData, cbData, (USHORT)opts);
                }

                LocalFree(pbData);
            }
            else
            {
                Print("Could not query value %s!%s. Error (%d).\n", szKey, szValue, l);
            }
            RegCloseKey(hkey);
        }
        else
        {
            Print("Could not open subkey %s. Error (%d).\n", szKey, l);
        }
    }

    return TRUE;
}

#endif // !KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\ntsdexts\secexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:


Abstract:

    This function contains the default ntsd debugger extensions

Author:


Revision History:

--*/


char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * TokenRights[] = {"AssignPrimary", "Duplicate", "Impersonate", "Query",
                        "QuerySource", "AdjustPriv", "AdjustGroup", "AdjustDef"};

char * KeyRights[] = {  "QueryValue", "SetValue", "CreateSubKey", "EnumSubKey",
                        "Notify", "CreateLink", "", "" };

char * EventRights[] = {"QueryState", "ModifyState" };

char * MutantRights[]={ "QueryState" };

char * SemaphoreRights[] = { "QueryState", "ModifyState" };

char * TimerRights[] = {"QueryState", "ModifyState" };

char * ProfileRights[]={"Control"};

char * ProcessRights[]={"Terminate", "CreateThread", "", "VMOp",
                        "VMRead", "VMWrite", "DupHandle", "CreateProcess",
                        "SetQuota", "SetInfo", "QueryInfo", "SetPort" };

char * ThreadRights[] ={"Terminate", "Suspend", "Alert", "GetContext",
                        "SetContext", "SetInfo", "QueryInfo", "SetToken",
                        "Impersonate", "DirectImpersonate" };

char * SectionRights[]={"Query", "MapWrite", "MapRead", "MapExecute",
                        "Extend"};

char * FileRights[] = { "Read/List", "Write/Add", "Append/SubDir/CreatePipe", "ReadEA",
                        "WriteEA", "Execute/Traverse", "DelChild", "ReadAttr",
                        "WriteAttr"};

char * PortRights[] = { "Connect" };

char * DirRights[]  = { "Query", "Traverse", "Create", "CreateSubdir" };

char * SymLinkRights[]={"Query" };

char * WinstaRights[]={ "EnumDesktops", "ReadAttr", "Clipboard", "CreateDesktop",
                        "WriteAttr", "GlobalAtom", "ExitWindows", "",
                        "Enumerate", "ReadScreen" };

char * DesktopRights[]={"ReadObjects", "CreateWindow", "CreateMenu", "HookControl",
                        "JournalRecord", "JournalPlayback", "Enumerate", "WriteObjects",
                        "SwitchDesktop" };

char * CompletionRights[] = { "Query", "Modify" };

char * ChannelRights[] = { "ReadMessage", "WriteMessage", "Query", "SetInfo" };

char * JobRights[] = { "AssignProcess", "SetAttr", "Query", "Terminate", "SetSecAttr" };

TCHAR * PrivNames[] = {
            TEXT("Invalid"),
            TEXT("Invalid"),
            SE_CREATE_TOKEN_NAME,
            SE_ASSIGNPRIMARYTOKEN_NAME,
            SE_LOCK_MEMORY_NAME,
            SE_MACHINE_ACCOUNT_NAME,
            SE_TCB_NAME,
            SE_SECURITY_NAME,
            SE_TAKE_OWNERSHIP_NAME,
            SE_LOAD_DRIVER_NAME,
            SE_SYSTEM_PROFILE_NAME,
            SE_PROF_SINGLE_PROCESS_NAME,
            SE_INC_BASE_PRIORITY_NAME,
            SE_CREATE_PAGEFILE_NAME,
            SE_CREATE_PERMANENT_NAME,
            SE_BACKUP_NAME,
            SE_RESTORE_NAME,
            SE_SHUTDOWN_NAME,
            SE_DEBUG_NAME,
            SE_AUDIT_NAME,
            SE_SYSTEM_ENVIRONMENT_NAME,
            SE_CHANGE_NOTIFY_NAME,
            SE_REMOTE_SHUTDOWN_NAME,
            SE_UNDOCK_NAME,
            SE_SYNC_AGENT_NAME,
            SE_ENABLE_DELEGATION_NAME
        };

///////////////////////////////

char *  TokenImpLevels[] = { "Anonymous", "Identification", "Impersonation", "Delegation" };
#define GetTokenImpersonationLevel( x ) \
                ( x <= SecurityDelegation ? TokenImpLevels[ x ] : "Invalid" )


#define GHI_TYPE        0x00000001
#define GHI_BASIC       0x00000002
#define GHI_NAME        0x00000004
#define GHI_SPECIFIC    0x00000008
#define GHI_VERBOSE     0x00000010
#define GHI_NOLOOKUP    0x00000020
#define GHI_SILENT      0x00000100

#define TYPE_NONE       0
#define TYPE_EVENT      1
#define TYPE_SECTION    2
#define TYPE_FILE       3
#define TYPE_PORT       4
#define TYPE_DIRECTORY  5
#define TYPE_LINK       6
#define TYPE_MUTANT     7
#define TYPE_WINSTA     8
#define TYPE_SEM        9
#define TYPE_KEY        10
#define TYPE_TOKEN      11
#define TYPE_PROCESS    12
#define TYPE_THREAD     13
#define TYPE_DESKTOP    14
#define TYPE_COMPLETE   15
#define TYPE_CHANNEL    16
#define TYPE_TIMER      17
#define TYPE_JOB        18
#define TYPE_WPORT      19
#define TYPE_MAX        20

LPWSTR   pszTypeNames[TYPE_MAX] = { L"None", L"Event", L"Section", L"File",
                                L"Port", L"Directory", L"SymbolicLink",
                                L"Mutant", L"WindowStation", L"Semaphore",
                                L"Key", L"Token", L"Process", L"Thread",
                                L"Desktop", L"IoCompletion", L"Channel",
                                L"Timer", L"Job", L"WaitablePort" };

LPSTR   pszTypeNamesA[TYPE_MAX] = { "None", "Event", "Section", "File",
                                "Port", "Directory", "SymbolicLink",
                                "Mutant", "WindowStation", "Semaphore",
                                "Key", "Token", "Process", "Thread",
                                "Desktop", "IoCompletion", "Channe",
                                "Timer", "Job", "WaitablePort" };

typedef VOID
( * TYPEINFOFN)(HANDLE hObject, DWORD Flags);

VOID EventInfo(HANDLE, ULONG);
VOID MutantInfo(HANDLE, ULONG);
VOID SemaphoreInfo(HANDLE, ULONG);
VOID TimerInfo(HANDLE, ULONG);
VOID SectionInfo(HANDLE, ULONG);
VOID KeyInfo(HANDLE, ULONG);
VOID ProcessInfo(HANDLE, ULONG);
VOID ThreadInfo(HANDLE, ULONG);
VOID TokenInfo(HANDLE, ULONG);
VOID IoCompleteInfo(HANDLE, ULONG);
VOID JobInfo( HANDLE, ULONG );

typedef struct _TYPEINFO {
    PWSTR       pszName;
    char * *    AccessRights;
    DWORD       NumberRights;
    TYPEINFOFN  Func;
} TYPEINFO, * PTYPEINFO;

TYPEINFO TypeNames[TYPE_MAX] = {
    { L"None", NULL, 0, 0 },
    { L"Event", EventRights, 2, EventInfo },
    { L"Section", SectionRights, 5, SectionInfo },
    { L"File", FileRights, 9, 0 },
    { L"Port", PortRights, 1, 0 },
    { L"Directory", DirRights, 4, 0 },
    { L"SymbolicLink", SymLinkRights, 1, 0 },
    { L"Mutant", MutantRights, 2, MutantInfo },
    { L"WindowStation", WinstaRights, 10, 0 },
    { L"Semaphore", SemaphoreRights, 2, SemaphoreInfo },
    { L"Key", KeyRights, 6, KeyInfo },
    { L"Token", TokenRights, 8, TokenInfo },
    { L"Process", ProcessRights, 12, ProcessInfo },
    { L"Thread", ThreadRights, 10, ThreadInfo },
    { L"Desktop", DesktopRights, 10, 0 },
    { L"IoCompletion", CompletionRights, 2, IoCompleteInfo },
    { L"Channel", ChannelRights, 4, 0},
    { L"Timer", TimerRights, 2, TimerInfo },
    { L"Job", JobRights, 5, JobInfo },
    { L"WaitablePort", PortRights, 1, 0 }
    };

void DisplayFlags(  DWORD       Flags,
                    DWORD       FlagLimit,
                    char        *flagset[],
                    UCHAR *      buffer)
{
   char *         offset;
   DWORD          mask, test, i;
   DWORD          scratch;

   if (!Flags) {
      strcpy((CHAR *)buffer, "None");
      return;
   }

   mask = 0;
   offset = (CHAR *) buffer;
   test = 1;
   for (i = 0 ; i < FlagLimit ; i++ ) {
      if (Flags & test) {
         scratch = sprintf(offset, "%s", flagset[i]);
         offset += scratch;
         mask |= test;
         if (Flags & (~mask)) {
            *offset++ = ',';
         }
      }
      test <<= 1;
   }
}

VOID
EventInfo(
    HANDLE  hEvent,
    DWORD   Flags)
{
    EVENT_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryEvent(  hEvent,
                            EventBasicInformation,
                            &Info,
                            sizeof( Info ),
                            NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Event Type %s\n", Info.EventType == SynchronizationEvent ?
                                    "Auto Reset" : "Manual Reset" );
        dprintf("    Event is %s\n", Info.EventState ? "Set" : "Waiting" );
    }
}

VOID
SemaphoreInfo(
    HANDLE  hSem,
    DWORD   Flags)
{
    SEMAPHORE_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQuerySemaphore(  hSem,
                                SemaphoreBasicInformation,
                                &Info,
                                sizeof( Info ),
                                NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Semaphore Count %d\n", Info.CurrentCount );
        dprintf("    Semaphore Limit %d\n", Info.MaximumCount );
    }

}

VOID
MutantInfo(
    HANDLE  hMutant,
    DWORD   Flags)
{
    MUTANT_BASIC_INFORMATION    Info;
    NTSTATUS Status;

    Status = NtQueryMutant( hMutant,
                            MutantBasicInformation,
                            &Info,
                            sizeof( Info ),
                            NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Mutex is %s\n", Info.CurrentCount ? "Free" : "Owned" );
        if ( Info.AbandonedState )
        {
            dprintf("    Mutex is abandoned\n");
        }
    }
}

VOID
TimerInfo(
    HANDLE  hTimer,
    DWORD   Flags)
{
    TIMER_BASIC_INFORMATION Info;
    NTSTATUS    Status;

    Status = NtQueryTimer( hTimer,
                           TimerBasicInformation,
                           &Info,
                           sizeof( Info ),
                           NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Timer is %s\n", Info.TimerState ? "signalled" : "waiting" );
        dprintf("    Remaining time %d\n", (DWORD) Info.RemainingTime.QuadPart );
    }
}

VOID
SectionInfo(
    HANDLE  hSection,
    DWORD   Flags)
{
    SECTION_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQuerySection(    hSection,
                                SectionBasicInformation,
                                &Info,
                                sizeof( Info ),
                                NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Section base address %#x\n", Info.BaseAddress );
        dprintf("    Section attributes %#x\n", Info.AllocationAttributes );
        dprintf("    Section max size %#x\n", (DWORD) Info.MaximumSize.QuadPart );
    }
}

VOID
KeyInfo(
    HANDLE  hKey,
    DWORD   Flags)
{
    PKEY_BASIC_INFORMATION  pInfo;
    NTSTATUS Status;
    SYSTEMTIME st;
    FILETIME lft;
    ULONG   Length;

    pInfo = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 1024);
    if ( pInfo )
    {
        Status = NtQueryKey( hKey,
                             KeyBasicInformation,
                             pInfo,
                             1024,
                             &Length );

        if ( NT_SUCCESS( Status ) )
        {
            FileTimeToLocalFileTime( (FILETIME *) &pInfo->LastWriteTime,
                                     & lft );
            FileTimeToSystemTime( &lft, &st );

            dprintf("    Key last write time:  %02d:%02d:%02d. %d/%d/%d\n",
                    st.wHour, st.wMinute, st.wSecond, st.wMonth,
                    st.wDay, st.wYear );

            dprintf("    Key name %ws\n", pInfo->Name );
        }

        LocalFree( pInfo );
    }
}

VOID
ProcessInfo(
    HANDLE  hProcess,
    DWORD   Flags)
{
    PROCESS_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryInformationProcess( hProcess,
                                        ProcessBasicInformation,
                                        &Info,
                                        sizeof( Info ),
                                        NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Process Id  %d\n", Info.UniqueProcessId );
        dprintf("    Parent Process  %d\n", Info.InheritedFromUniqueProcessId );
        dprintf("    Base Priority %d\n", Info.BasePriority );
    }

}

VOID
ThreadInfo(
    HANDLE hThread,
    DWORD   Flags)
{
    THREAD_BASIC_INFORMATION Info;
    NTSTATUS Status;
    PVOID StartAddr ;
    CHAR Buffer[ 128 ];
    DWORD_PTR Offset ;

    Status = NtQueryInformationThread( hThread,
                                       ThreadBasicInformation,
                                       &Info,
                                       sizeof( Info ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Thread Id  %d.%d\n", Info.ClientId.UniqueProcess, Info.ClientId.UniqueThread );
        dprintf("    Priority %d\n", Info.Priority );
        dprintf("    Base Priority %d\n", Info.BasePriority );
    }

    Status = NtQueryInformationThread( hThread,
                                       ThreadQuerySetWin32StartAddress,
                                       &StartAddr,
                                       sizeof( PVOID ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        Buffer[0] = '\0';
        GetSymbol( StartAddr, Buffer, &Offset );
        dprintf("    Start Address %x %s\n",
                StartAddr, Buffer[0] ? Buffer : "" );
    }
}

VOID
IoCompleteInfo(
    HANDLE  hIoCompletionPort,
    DWORD   Flags)
{
    IO_COMPLETION_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryIoCompletion(   hIoCompletionPort,
                                    IoCompletionBasicInformation,
                                    &Info,
                                    sizeof( Info ),
                                    NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Depth  %d\n", Info.Depth );
    }

}

VOID
TokenInfo(
    HANDLE  hToken,
    DWORD   Flags)
{
    TOKEN_STATISTICS    Stats;
    UCHAR               Buffer[ 1024 ];
    PTOKEN_USER         pUser;
    PTOKEN_GROUPS       pGroups;
    PTOKEN_PRIVILEGES   pPrivs ;
    ULONG               Size;
    NTSTATUS            Status;
    UNICODE_STRING      s;
    WCHAR               Name[ 64 ];
    WCHAR               Domain[ 64 ];
    DWORD               NameSize;
    DWORD               DomainSize;
    SID_NAME_USE        Use;
    BOOL                FoundName;
    ULONG               Index;



    Status = NtQueryInformationToken(   hToken,
                                        TokenStatistics,
                                        &Stats,
                                        sizeof(Stats),
                                        &Size );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Auth Id    %#x : %#x\n", Stats.AuthenticationId.HighPart, Stats.AuthenticationId.LowPart );
        dprintf("    Type       %s\n", Stats.TokenType == TokenPrimary ? "Primary" : "Impersonation" );
        dprintf("    Imp Level  %s\n", GetTokenImpersonationLevel( Stats.ImpersonationLevel ) );

        if ( Flags & GHI_VERBOSE )
        {
            dprintf("     Token Id  %#x : %#x \n", Stats.TokenId.HighPart, Stats.TokenId.LowPart );
            dprintf("     Mod Id    %#x : %#x \n", Stats.ModifiedId.HighPart, Stats.ModifiedId.LowPart );
            dprintf("     Dyn Chg   %#x\n", Stats.DynamicCharged );
            dprintf("     Dyn Avail %#x\n", Stats.DynamicAvailable );
            dprintf("     Groups    %d\n",  Stats.GroupCount );
            dprintf("     Privs     %d\n",  Stats.PrivilegeCount );

            pUser = (PTOKEN_USER) Buffer;
            Status = NtQueryInformationToken(   hToken,
                                                TokenUser,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if (NT_SUCCESS( Status ) )
            {
                FoundName = FALSE ;

                if ( !(Flags & GHI_NOLOOKUP) )
                {
                    NameSize = 64 ;
                    DomainSize = 64 ;

                    if ( LookupAccountSidW( NULL,
                                            pUser->User.Sid,
                                            Name,
                                            &NameSize,
                                            Domain,
                                            &DomainSize,
                                            &Use ) )
                    {
                        dprintf("     User      %ws\\%ws\n", Domain, Name );
                        FoundName = TRUE;
                    }
                }

                if ( (Flags & GHI_NOLOOKUP) || (!FoundName) )
                {
                    RtlConvertSidToUnicodeString( &s, pUser->User.Sid, TRUE );
                    dprintf("     User      %ws\n", s.Buffer );
                    RtlFreeUnicodeString( &s );
                }
            }

            pGroups = (PTOKEN_GROUPS) Buffer;
            Status = NtQueryInformationToken(   hToken,
                                                TokenGroups,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if ( NT_SUCCESS( Status ) )
            {
                dprintf("     Groups    %d\n", pGroups->GroupCount );
                for ( Index = 0 ; Index < pGroups->GroupCount ; Index++ )
                {
                    FoundName = FALSE ;

                    if ( !(Flags & GHI_NOLOOKUP) )
                    {
                        NameSize = 64 ;
                        DomainSize = 64 ;

                        if ( LookupAccountSidW( NULL,
                                                pGroups->Groups[Index].Sid,
                                                Name,
                                                &NameSize,
                                                Domain,
                                                &DomainSize,
                                                &Use ) )
                        {
                            dprintf("               %ws\\%ws\n", Domain, Name );
                            FoundName = TRUE;
                        }
                    }
                    if ( ( Flags & GHI_NOLOOKUP ) || ( !FoundName ) )
                    {
                        RtlConvertSidToUnicodeString( &s,
                                                    pGroups->Groups[Index].Sid,
                                                    TRUE );

                        dprintf("               %ws\n", s.Buffer );

                        RtlFreeUnicodeString( &s );
                        
                    }
                }
            }

            pPrivs = (PTOKEN_PRIVILEGES) Buffer ;
            Status = NtQueryInformationToken(   hToken,
                                                TokenPrivileges,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if ( NT_SUCCESS( Status ) )
            {
                dprintf("     Privileges    %d\n", pPrivs->PrivilegeCount );
                for ( Index = 0 ; Index < pPrivs->PrivilegeCount ; Index++ )
                {
                    dprintf("               %s (%s%s)\n", 
                            PrivNames[ pPrivs->Privileges[ Index ].Luid.LowPart ], 
                            pPrivs->Privileges[ Index ].Attributes & SE_PRIVILEGE_ENABLED ? " Enabled " : " ",
                            pPrivs->Privileges[ Index ].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT ? "Default " : "" 
                            );
                }

            }
        }
    }

}

VOID
JobInfo(
    HANDLE Job,
    ULONG Flags 
    )
{
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo ;
    UCHAR Buffer[ 128 * sizeof( ULONG_PTR ) ];
    PJOBOBJECT_BASIC_PROCESS_ID_LIST ProcList ;
    NTSTATUS Status ;
    ULONG Size ;
    TIME_FIELDS Time ;

    //
    // Delay load this API since it does not exist on NT 4
    //

    typedef NTSTATUS (NTAPI* PNTQUERYJOB)(HANDLE, JOBOBJECTINFOCLASS, PVOID, LONG, PULONG);

    HMODULE hNtdll;
    PNTQUERYJOB pNtQueryJob;

    hNtdll = GetModuleHandle( "ntdll.dll" );
    if (!hNtdll) {
        dprintf("Unable to get module handle for ntdll.dll\n");
        return;
    }

    pNtQueryJob =
        (PNTQUERYJOB)GetProcAddress( hNtdll, "NtQueryInformationJobObject" );

    if (pNtQueryJob == NULL) {
        dprintf("Unable to get address of NtQueryInformationJobObject\n");
        return;
    }

    Status = pNtQueryJob(
                    Job,
                    JobObjectBasicAccountingInformation,
                    &BasicInfo,
                    sizeof( BasicInfo ),
                    &Size );

    if ( NT_SUCCESS( Status ) )
    {
        RtlTimeToElapsedTimeFields( &BasicInfo.TotalUserTime, &Time );
        dprintf( "    TotalUserTime     \t%3ld:%02ld:%02ld.%04ld\n",
                 Time.Hour,
                 Time.Minute,
                 Time.Second,
                 Time.Milliseconds );
        RtlTimeToElapsedTimeFields( &BasicInfo.TotalKernelTime, &Time );
        dprintf( "    TotalKernelTime   \t%3ld:%02ld:%02ld.%04ld\n",
                 Time.Hour,
                 Time.Minute,
                 Time.Second,
                 Time.Milliseconds );

        dprintf( "    TotalProcesses    \t%x\n", 
                 BasicInfo.TotalProcesses );
        dprintf( "    ActiveProcesses   \t%x\n",
                 BasicInfo.ActiveProcesses );
        dprintf( "    TotalPageFaultCount\t%x\n",
                 BasicInfo.TotalPageFaultCount );

        if ( BasicInfo.ActiveProcesses )
        {
            ProcList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST) Buffer ;

            Status = pNtQueryJob(
                            Job,
                            JobObjectBasicProcessIdList,
                            ProcList,
                            sizeof( Buffer ),
                            &Size );

            if ( NT_SUCCESS( Status ) )
            {
                ULONG i ;

                dprintf( "    Processes:\n" );

                for (i = 0 ; i < ProcList->NumberOfProcessIdsInList ; i++ )
                {
                    dprintf( "    %x\n", ProcList->ProcessIdList[ i ] );
                }
            }
        }

    }
}


DWORD
GetObjectTypeIndex(
    LPCSTR  pszTypeName )
{
    WCHAR   TypeName[ MAX_PATH ];
    DWORD   i;

    mbstowcs( TypeName, pszTypeName, strlen( pszTypeName ) + 1 );

    for ( i = 1 ; i < TYPE_MAX ; i++ )
    {
        if (_wcsicmp( TypeNames[i].pszName, TypeName ) == 0 )
        {
            return( i );
        }
    }

    return( (DWORD) -1 );
}

DWORD
GetHandleInfoDirect(
    HANDLE  hProcess,
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type)
{
    HANDLE  hHere;
    NTSTATUS    Status;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    POBJECT_NAME_INFORMATION    pNameInfo;
    POBJECT_BASIC_INFORMATION   pBasicInfo;
    UCHAR   Buffer[1024];
    DWORD   SuccessCount = 0;
    DWORD   i;
    UCHAR   szBuf[256];


    if (!DuplicateHandle(   hProcess, hThere,
                            GetCurrentProcess(), &hHere,
                            0, FALSE,
                            DUPLICATE_SAME_ACCESS) )
    {
        if ( (Flags & GHI_SILENT) == 0)
        {
            dprintf("Could not duplicate handle %x, error %d\n",
                            hThere, GetLastError() );
        }
        return( 0 );
    }


    pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;
    pNameInfo = (POBJECT_NAME_INFORMATION) Buffer;
    pBasicInfo = (POBJECT_BASIC_INFORMATION) Buffer;

    if ( (Flags & GHI_SILENT) == 0)
    {
        dprintf("Handle %x\n", hThere );
    }

    if (Flags & GHI_TYPE)
    {
        ZeroMemory( Buffer, 1024 );
        Status = NtQueryObject( hHere, ObjectTypeInformation, pTypeInfo, 1024, NULL );

        if (NT_SUCCESS(Status))
        {
            if ((Flags & GHI_SILENT) == 0)
            {
                dprintf("  Type         \t%ws\n", pTypeInfo->TypeName.Buffer );
            }
            for (i = 1; i < TYPE_MAX ; i++ )
            {
                if (wcscmp(pTypeInfo->TypeName.Buffer, TypeNames[i].pszName) == 0)
                {
                    *Type = i;
                    break;
                }
            }
            if (i == TYPE_MAX)
            {
                *Type = 0;
            }
            SuccessCount++;
        }
    }

    if (Flags & GHI_BASIC)
    {
        ZeroMemory( Buffer, 1024 );

        Status = NtQueryObject(hHere, ObjectBasicInformation, pBasicInfo,
                        sizeof( OBJECT_BASIC_INFORMATION), NULL);
        if (NT_SUCCESS(Status))
        {
            dprintf("  Attributes   \t%#x\n", pBasicInfo->Attributes );
            dprintf("  GrantedAccess\t%#x:\n", pBasicInfo->GrantedAccess );
            DisplayFlags( pBasicInfo->GrantedAccess >> 16,
                          16,
                          AccessMask,
                          szBuf);
            dprintf("         %s\n", szBuf);
            DisplayFlags( pBasicInfo->GrantedAccess & 0xFFFF,
                          TypeNames[ *Type ].NumberRights,
                          TypeNames[ *Type ].AccessRights,
                          szBuf);
            dprintf("         %s\n", szBuf);
            dprintf("  HandleCount  \t%d\n", pBasicInfo->HandleCount );
            dprintf("  PointerCount \t%d\n", pBasicInfo->PointerCount );
            SuccessCount++;
        }
        else
        {
            if ( Status != STATUS_INVALID_HANDLE )
            {
                dprintf("unable to query object information\n");
            }
        }
    }

    if ( (Flags & GHI_NAME) &&
         (*Type != TYPE_FILE ) )
    {
        ZeroMemory( Buffer, 1024 );
        Status = NtQueryObject( hHere, ObjectNameInformation, pNameInfo, 1024, NULL );

        if (NT_SUCCESS(Status))
        {
            dprintf("  Name         \t%ws\n", pNameInfo->Name.Buffer ?
                                        pNameInfo->Name.Buffer : L"<none>" );
            SuccessCount++;
        }
        else
        {
            if ( Status != STATUS_INVALID_HANDLE )
            {
                dprintf("unable to query object information\n");
            }
        }
    }

    if ( Flags & GHI_SPECIFIC )
    {
        if ( TypeNames[ *Type ].Func )
        {
            dprintf("  Object Specific Information\n");
            TypeNames[ *Type ].Func( hHere, Flags );
        }
    }

    NtClose( hHere );

    return( SuccessCount );

}

DWORD
GetHandleInfoInterface(
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type)
{
    ULONG64 IfHandle = (ULONG_PTR)hThere;
    HRESULT Status;
    DWORD   SuccessCount = 0;
    DWORD   i;
    UCHAR   Buffer[1024];
    UCHAR   szBuf[256];

    if ( (Flags & GHI_SILENT) == 0)
    {
        dprintf("Handle %I64x\n", IfHandle );
    }

    if (Flags & GHI_TYPE)
    {
        if (g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, IfHandle,
                           DEBUG_HANDLE_DATA_TYPE_TYPE_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            if ((Flags & GHI_SILENT) == 0)
            {
                dprintf("  Type         \t%s\n", Buffer);
            }
            for (i = 1; i < TYPE_MAX ; i++ )
            {
                if (strcmp((LPSTR)Buffer, pszTypeNamesA[i]) == 0)
                {
                    *Type = i;
                    break;
                }
            }
            if (i == TYPE_MAX)
            {
                *Type = 0;
            }
            SuccessCount++;
        }
    }

    if (Flags & GHI_BASIC)
    {
        DEBUG_HANDLE_DATA_BASIC Basic;

        if (g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, IfHandle,
                           DEBUG_HANDLE_DATA_TYPE_BASIC,
                           &Basic, sizeof(Basic), NULL) == S_OK)
        {
            dprintf("  Attributes   \t%#x\n", Basic.Attributes );
            dprintf("  GrantedAccess\t%#x:\n", Basic.GrantedAccess );
            DisplayFlags( Basic.GrantedAccess >> 16,
                          16,
                          AccessMask,
                          szBuf);
            dprintf("         %s\n", szBuf);
            DisplayFlags( Basic.GrantedAccess & 0xFFFF,
                          TypeNames[ *Type ].NumberRights,
                          TypeNames[ *Type ].AccessRights,
                          szBuf);
            dprintf("         %s\n", szBuf);
            dprintf("  HandleCount  \t%d\n", Basic.HandleCount );
            dprintf("  PointerCount \t%d\n", Basic.PointerCount );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ( (Flags & GHI_NAME) &&
         (*Type != TYPE_FILE ) )
    {
        if (g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, IfHandle,
                           DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            dprintf("  Name         \t%s\n",
                    Buffer[0] ? Buffer : "<none>" );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ( Flags & GHI_SPECIFIC )
    {
        dprintf("  No object specific information available\n");
    }

    return( SuccessCount );

}

DWORD
GetHandleInfo(
    BOOL    Direct,
    HANDLE  hProcess,
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type)
{
    if (Direct) {
        return GetHandleInfoDirect(hProcess, hThere, Flags, Type);
    } else {
        return GetHandleInfoInterface(hThere, Flags, Type);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\app\calcperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Enstrom (marke) 28-Mar-1991

Revision History:

--*/

#ifndef _CALCPERFH_INCLUDED_
#define _CALCPERFH_INCLUDED_

#define MAX_PROCESSORS   32
#define DATA_LIST_LENGTH 100
#define DELAY_SECONDS    2

//
// display const
//

#define BORDER_WIDTH   2
#define INDENT_WIDTH   8
#define GRAPH_WIDTH    130
#define GRAPH_HEIGHT   40

//
//  time constant for sampling performance
//

#define PERF_TIME_DELAY 1000

//
//  types of display modes
//

#define DISPLAY_MODE_TOTAL          0
#define DISPLAY_MODE_BREAKDOWN      1
#define DISPLAY_MODE_PER_PROCESSOR  2

//
//  This info packet is associated with each
//  performance item
//

typedef struct tagDISPLAYITEM
{
    HDC     MemoryDC;
    HBITMAP MemoryBitmap;
    struct  tagDISPLAYITEM  *Next;
    ULONG   sort;
    PULONG  MaxToUse;
    ULONG   Max;
    ULONG   PositionX;
    ULONG   PositionY;
    ULONG   Width;
    ULONG   Height;
    ULONG   CurrentDrawingPos;
    ULONG   Mega;
    RECT    Border;
    RECT    GraphBorder;
    RECT    TextBorder;
    BOOL    ChangeScale;
    BOOL    DeleteMe;
    BOOL    Display;
    BOOL    AutoTotal;
    BOOL    IsPercent;
    BOOL    IsCalc;
    UCHAR   na[2];
    ULONG   DisplayMode;
    struct  tagDISPLAYITEM  *CalcPercent[2];
    ULONG   CalcPercentId[2];
    ULONG   CalcId;
    UCHAR   PerfName[80];
    UCHAR   DispName[80];
    ULONG   DispNameLen;
    VOID    (*SnapData)(struct tagDISPLAYITEM *pItem);
    ULONG   SnapParam1;
    ULONG   SnapParam2;
    ULONG   LastAccumulator     [MAX_PROCESSORS+1];
    ULONG   CurrentDataPoint    [MAX_PROCESSORS+1];
    PULONG  DataList            [MAX_PROCESSORS+1];

} DISPLAY_ITEM,*PDISPLAY_ITEM;

//
// flag to activate each menu selection
//

#define DISPLAY_INACTIVE 0
#define DISPLAY_ACTIVE   1

VOID
SetCounterEvents (PVOID Events, ULONG length);

// this function is really found in pperf.h but is
// used in calcperf.c so it'd prototyped here
VOID
InitPossibleEventList();

BOOL
UpdatePerfInfo(
   PULONG   DataPointer,
   ULONG    NewDataValue,
   PULONG   OldMaxValue
   );

VOID
UpdatePerfInfo1(
   PULONG    DataPointer,
   ULONG     NewDataValue
   );

VOID
UpdateInternalStats (
    VOID
);


VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   );

#endif /* _CALCPERFH_INCLUDED */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\app\draw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Draw.c

Abstract:

   Win32 application to display performance statictics. This routine implements
   graphics output for display windows.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-07-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <math.h>
#include <errno.h>
#include "pperf.h"

extern WINPERF_INFO    WinperfInfo;
extern ULONG           NumberOfProcessors, LogIt;



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems
    )

/*++

Routine Description:

    Calculate all parameters to fit the given number of
    windows into the app window. Fill out the data structure
    for each sub-window

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/

{
    RECT    ClientRect;
    int     cx,cy;
    UINT    Index;
    int     ActiveWindows,IndexX,IndexY;
    int     WindowsX,WindowsY,WindowWidth,WindowHeight;
    int     LastRowWidth,LoopWidth;
    double  fWindowsX,fActiveWindows,fcx,fcy;
    PDISPLAY_ITEM   pPerf;

    //
    //  Find out the client area bounds
    //

    GetClientRect(hWnd,&ClientRect);

    cx = ClientRect.right;
    cy = ClientRect.bottom - 2;   // subtract 2 to give a little more border

    //
    //  Find out how many perf windows are active
    //

    ActiveWindows = 0;

    for (pPerf=DisplayItems; pPerf; pPerf = pPerf->Next) {
        if (pPerf->Display == TRUE) {
            ActiveWindows++;
        }
    }

    //
    // Return if there are no active windows to display
    //

    if (ActiveWindows == 0) {
        return(TRUE);
    }


    //
    //  Now convert the window dimensions to floating point and
    //  then take the square root of the window dimension to find
    //  out the number of windows in the x direction
    //

    fActiveWindows = 1.0 * ActiveWindows;

    fcx = 1.0 * cx;
    fcy = 1.0 * cy;

    if (fcy != 0.0) {
        fWindowsX = sqrt((fcx * fActiveWindows) / fcy);
    }   else {

        //
        // If fcy = 0 then return since this is an error condition that
        // would cause a divide by zero.
        //

        return(FALSE);
    }

    //
    // convert back to integer
    //

    WindowsX = (int)fWindowsX;

    if (WindowsX == 0) {
        WindowsX = 1;
    } else if (WindowsX > ActiveWindows) {
        WindowsX = ActiveWindows;
    }

    WindowsY = ActiveWindows / WindowsX;

    //
    //  Add on extra line to Y to take care of the left over windows ie:
    //  if there are 15 active windows and the x number = 7 then y = 2 with 1
    //  left over.
    //

    Index = ActiveWindows - (WindowsX * WindowsY);

    if (Index > 0) {
        WindowsY++;
        LastRowWidth = cx / Index;
    } else {
        LastRowWidth = cx / WindowsX;
    }

    WindowWidth  = cx / WindowsX;
    WindowHeight = cy / WindowsY;

    //
    // Assign positions for each active window
    //

    pPerf = DisplayItems;
    for (IndexY=0;IndexY<WindowsY;IndexY++) {
        for (IndexX=0;IndexX<WindowsX;IndexX++) {

            //
            // Find the next active display item
            //

            while (pPerf->Display != TRUE  &&  pPerf) {
                pPerf = pPerf->Next;
            }
            if (!pPerf) {
                break;
            }

            //
            //  Add y fixup for last row
            //

            if (IndexY == WindowsY - 1) {
                LoopWidth = LastRowWidth;
            } else {
                LoopWidth = WindowWidth;
            }


            pPerf->PositionX = LoopWidth  * IndexX;
            pPerf->PositionY = WindowHeight * IndexY + 1;  // +1 for more top border
            pPerf->Width     = LoopWidth - 1;
            pPerf->Height    = WindowHeight - 1;

            //
            // Last Column fix-up to use all of window.
            //

            if (IndexX == WindowsX - 1) {
                pPerf->Width = cx - pPerf->PositionX - 1;
            }

            pPerf = pPerf->Next;
            if (!pPerf) {
                break;
            }

        }

        if (!pPerf) {
            break;
        }
    }

    return(TRUE);
}



VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Calculate all borders for graphics windows

Arguments:

    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;
    LONG    GraphHeight,TextHeight;
    BOOLEAN TextWindow;

    double  fx1,fx2,fy1;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->PositionX + 2;
    x2 = DisplayItem->PositionX + DisplayItem->Width - 2;
    y1 = DisplayItem->PositionY + 2;
    y2 = DisplayItem->PositionY + DisplayItem->Height - 2;

    //
    // find out in there is enough space for a text window
    //

    if ((y2 - y1 - 12) > 30) {

        TextWindow = TRUE;

        //
        // Calculate dimensions for a text window and a graphics window
        //
        // fx1 = portion of the window - bordres and free space
        //
        // fx2 = fraction of window used for graphics
        //
        // fy1 = fraction of winddow used for text
        //

        fx1 = (y2 - y1 - 10);

        fx2 = fx1 * 0.6666;
        fy1 = fx1 * 0.3333;

        GraphHeight = (LONG)fx2;
        TextHeight  = (LONG)fy1;

        if (TextHeight > 20) {
            GraphHeight += TextHeight-20;
            TextHeight = 20;
        }

        //
        // Calculate window boundaries
        //

        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y1 + 4 + GraphHeight + 1;

        tx1 = x1 + 4;
        tx2 = x2 - 4;
        ty1 = gy2 + 1 + 2 + 1;  // border,free space,border
        ty2 = gy2 + TextHeight + 1;

    }   else {

        TextWindow = FALSE;
        GraphHeight = y2 - y1 - 10;
        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y2 - 4;
        tx1 = tx2 = ty1 = ty2 = 0;

    }

    //
    // Fill in structures for drawing text and graphics
    //

    DisplayItem->Border.left        = x1;
    DisplayItem->Border.right       = x2;
    DisplayItem->Border.top         = y1;
    DisplayItem->Border.bottom      = y2;

    DisplayItem->GraphBorder.left   = gx1;
    DisplayItem->GraphBorder.right  = gx2;
    DisplayItem->GraphBorder.top    = gy1;
    DisplayItem->GraphBorder.bottom = gy2;

    DisplayItem->TextBorder.left    = tx1;
    DisplayItem->TextBorder.right   = tx2;
    DisplayItem->TextBorder.top     = ty1;
    DisplayItem->TextBorder.bottom  = ty2;
}




VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw the window frame for a performance window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    DrawRect;
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->Border.left;
    x2 = DisplayItem->Border.right;
    y1 = DisplayItem->Border.top;
    y2 = DisplayItem->Border.bottom;

    gx1 = DisplayItem->GraphBorder.left;
    gx2 = DisplayItem->GraphBorder.right;
    gy1 = DisplayItem->GraphBorder.top;
    gy2 = DisplayItem->GraphBorder.bottom;

    tx1 = DisplayItem->TextBorder.left;
    tx2 = DisplayItem->TextBorder.right;
    ty1 = DisplayItem->TextBorder.top;
    ty2 = DisplayItem->TextBorder.bottom;

    //
    // Draw top border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y1 + 2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw Left border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x1 + 2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw right border in dark shade
    //


    DrawRect.left   = x2 - 2;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // draw bottom in dark shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y2-2;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw graphics area single border
    //

    //
    // Draw top border in dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy1+1;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw Left border in Dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx1 + 1;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw right border in Light shade
    //


    DrawRect.left   = gx2 - 1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // draw bottom in Light shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy2-1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    if (tx2 > 0) {

        //
        // Draw top border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty1 + 1;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw Left border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx1 + 1;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw right border in Light shade
        //


        DrawRect.left   = tx2 - 1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

        //
        // draw bottom in Light shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty2-1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    }
}




VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw text into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    TextRect;
    UCHAR   TextStr[50];
    ULONG   j;
    UINT    FontSize;

    //
    // Check that text display is enabled
    //

    if (DisplayItem->TextBorder.right == 0) {
        return;
    }

    TextRect.left = DisplayItem->TextBorder.left +1;
    TextRect.right = DisplayItem->TextBorder.right -1;
    TextRect.top = DisplayItem->TextBorder.top +1;
    TextRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&TextRect,WinperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  TextRect.bottom - TextRect.top;

    if (FontSize >= 15) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.LargeFont);
    } else if (FontSize > 10) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.MediumFont);
    } else {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.SmallFont);
    }

    DrawText(
                hDC,
                DisplayItem->DispName,
                DisplayItem->DispNameLen,
                &TextRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );


    //
    // Build the numeric value
    //

    if (DisplayItem->Mega) {
        wsprintf(TextStr,"   %liK",DisplayItem->DataList[0][0]);
    } else {
        if (DisplayItem->IsPercent) {
            j = wsprintf(TextStr,"   %03li", DisplayItem->DataList[0][0]);
            TextStr[j+1] = 0;
            TextStr[j-0] = TextStr[j-1];
            TextStr[j-1] = TextStr[j-2];
            TextStr[j-2] = '.';
        } else {
            wsprintf(TextStr,"   %li",DisplayItem->DataList[0][0]);
        }
    }

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &TextRect,
                DT_RIGHT | DT_VCENTER | DT_SINGLELINE
             );


    SelectObject(hDC,WinperfInfo.hOldFont);

}





VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw graphics into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect;
    ULONG   Scale,i,j,GraphWidth,GraphHeight,Max;
    PULONG  pDL;
    HPEN    pen;

    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth +1;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&MemGraphRect,WinperfInfo.hBackground);

    MemGraphRect.right  = GraphWidth;
    MemGraphRect.bottom = GraphHeight;

    Max = *DisplayItem->MaxToUse;
    if (Max == 0) {
        Max = 1;
    }

    //
    // calculate scale from data to perf window
    //

    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    if (DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN  ||
        DisplayItem->DisplayMode == DISPLAY_MODE_PER_PROCESSOR) {

        for (j=0; j < NumberOfProcessors; j++) {
            pen = WinperfInfo.hPPen[j];
            SelectObject(DisplayItem->MemoryDC,pen);

            pDL = DisplayItem->DataList[j+1];
            MoveToEx(DisplayItem->MemoryDC,
                     MemGraphRect.right,
                     MemGraphRect.bottom - (pDL[0] * GraphHeight) / Max,
                     (LPPOINT)NULL);

            for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
                LineTo(DisplayItem->MemoryDC,
                       MemGraphRect.right - Scale * i,
                       MemGraphRect.bottom - (pDL[i] * GraphHeight)/Max);
            }
        }
    }


    if (DisplayItem->DisplayMode == DISPLAY_MODE_TOTAL  ||
        DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN) {

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);
        pDL = DisplayItem->DataList[0];

        MoveToEx(DisplayItem->MemoryDC,
                 MemGraphRect.right,
                 MemGraphRect.bottom - (pDL[0] * GraphHeight)/Max,
                 (LPPOINT)NULL);



        for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
                   MemGraphRect.right - Scale * i,
                   MemGraphRect.bottom - (pDL[i] * GraphHeight)/Max);
        }
    }

    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);
}

VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Shift memory bitmap 1 location left then draw the 1 new data point.
    BitBlt this to the screen.


Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect,FillArea;
    ULONG   Scale,j,GraphWidth,GraphHeight,Max;
    PULONG  pDL;
    HPEN    pen;


    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight;

    Max = *DisplayItem->MaxToUse;
    if (Max == 0) {
        Max = 1;
    }

    //
    // calculate scale from data to perf window
    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    //
    // Shift memory image left by scale
    //


    BitBlt( DisplayItem->MemoryDC,
            0,
            0,
            GraphWidth+1 - Scale,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            Scale,
            0,
            SRCCOPY);


    //
    // Fill The new area on the right of the screen
    //

    FillArea.left   = GraphWidth +1 - Scale;
    FillArea.right  = GraphWidth +1;
    FillArea.top    = 0;
    FillArea.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&FillArea,WinperfInfo.hBackground);



    if (DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN ||
        DisplayItem->DisplayMode == DISPLAY_MODE_PER_PROCESSOR) {

        for (j=0; j < NumberOfProcessors; j++) {
            pen = WinperfInfo.hPPen[j];
            SelectObject(DisplayItem->MemoryDC,pen);

            pDL = DisplayItem->DataList[j+1];
            MoveToEx(DisplayItem->MemoryDC,
                     MemGraphRect.right,
                     MemGraphRect.bottom - (pDL[0] * GraphHeight)/ Max,
                     (LPPOINT)NULL);

            LineTo(DisplayItem->MemoryDC,
                    MemGraphRect.right - Scale,
                    MemGraphRect.bottom - (pDL[1] * GraphHeight)/ Max);
        }
    }

    if (DisplayItem->DisplayMode == DISPLAY_MODE_TOTAL  ||
        DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN) {

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);

        pDL = DisplayItem->DataList[0];
        MoveToEx(DisplayItem->MemoryDC,
                 MemGraphRect.right,
                 MemGraphRect.bottom - (pDL[0] * GraphHeight)/Max,
                 (LPPOINT)NULL);

        LineTo(DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (pDL[1] * GraphHeight)/Max);
    }

    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);

}



BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Create a memory context and a memory bitmap for each perf window



Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    int     Width;
    int     Height;

    if (DisplayItem->Display == TRUE) {

        //
        //  Calculate width of memory bitmap needed
        //

        Width  = DisplayItem->GraphBorder.right - DisplayItem->GraphBorder.left;
        Height = DisplayItem->GraphBorder.bottom - DisplayItem->GraphBorder.top;

        if ((Width<=0) || (Height <= 0)) {

            //
            // Disable this window that is to small to be seen
            //

            //DisplayItem->Display = FALSE;

            //return(TRUE);

            //
            // make a fake width and height
            //

            Width  = 1;
            Height = 1;
        }

        //
        //  Create DC and Bitmap
        //

        DisplayItem->MemoryDC     = CreateCompatibleDC(hDC);

        if (DisplayItem->MemoryDC == NULL) {
            return(FALSE);
        }


        DisplayItem->MemoryBitmap = CreateCompatibleBitmap(hDC,Width,Height);

        if (DisplayItem->MemoryBitmap == 0) {
            return(FALSE);
        }

        SelectObject(DisplayItem->MemoryDC,DisplayItem->MemoryBitmap);

    }

    return(TRUE);
}



VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Delete memory bitmap and context

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    if (DisplayItem->MemoryDC != NULL) {
        DeleteDC(DisplayItem->MemoryDC);
    }

    if (DisplayItem->MemoryBitmap != NULL) {
        DeleteObject(DisplayItem->MemoryBitmap);
    }

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\app\calc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdio.h>
#include "pperf.h"
#include "..\pstat.h"

extern UCHAR            Buffer[];
extern PDISPLAY_ITEM    Calc1, Calc2;
extern PDISPLAY_ITEM    PerfGraphList;
extern ULONG            NumberOfProcessors;
extern BOOL             LazyOp;

VOID AssignCalcId (PDISPLAY_ITEM pPerf);
PDISPLAY_ITEM LookUpCalcId (IN ULONG id);


VOID SnapPercent (PDISPLAY_ITEM);
VOID SnapSum (PDISPLAY_ITEM);
VOID InitPercent (PDISPLAY_ITEM);
VOID InitSum (PDISPLAY_ITEM);

ULONG   StaticPercentScale = 10000;
ULONG   CalcSort = 300000;

VOID   (*InitCalc[])(PDISPLAY_ITEM) = {
            InitPercent, InitSum, InitPercent, InitPercent
            };


BOOL
APIENTRY CalcDlgProc(
   HWND hDlg,
   unsigned message,
   DWORD wParam,
   LONG lParam
   )
{
    PDISPLAY_ITEM   pPerf;
    UINT            ButtonState;
    UINT            Index, i;

    switch (message) {
    case WM_INITDIALOG:
        sprintf (Buffer, "A. %s", Calc1->PerfName);
        SetDlgItemText(hDlg, IDM_CALC_TEXTA, Buffer);

        sprintf (Buffer, "B. %s", Calc2->PerfName);
        SetDlgItemText(hDlg, IDM_CALC_TEXTB, Buffer);
        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {
           case IDOK:
                if (Calc1 && Calc2) {
                    for (i=IDM_CALC_FORM1; i <= IDM_CALC_FORM4; i++) {
                        if (SendDlgItemMessage(hDlg,i,BM_GETCHECK,0,0)) {
                            // found selected form type
                            i = i - IDM_CALC_FORM1;

                            AssignCalcId (Calc1);
                            AssignCalcId (Calc2);

                            pPerf = AllocateDisplayItem();
                            pPerf->CalcPercentId[0] = Calc1->CalcId;
                            pPerf->CalcPercentId[1] = Calc2->CalcId;
                            pPerf->SnapParam1 = i;
                            pPerf->IsCalc = TRUE;
                            InitCalc[i](pPerf);

                            SetDisplayToTrue (pPerf, CalcSort++);
                            RefitWindows(NULL, NULL);
                            break;
                        }
                    }
                }
                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);

           case IDCANCEL:
                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);
        }
    }
    return (FALSE);
}


VOID
AssignCalcId (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    PDISPLAY_ITEM p;
    ULONG   l;

    if (pPerf->CalcId) {
        return ;
    }

    l = 0;
    for (p=PerfGraphList; p; p=p->Next) {
        if (p->CalcId > l) {
            l = p->CalcId;
        }
    }

    pPerf->CalcId = l + 1;
    sprintf (pPerf->DispName, "%d. %s", l+1, pPerf->PerfName);
    pPerf->DispNameLen = strlen(pPerf->DispName);
}


PDISPLAY_ITEM
LookUpCalcId (
    IN ULONG id
    )
{
    PDISPLAY_ITEM p;

    for (p=PerfGraphList; p; p=p->Next) {
        if (p->CalcId == id) {
            return p;
        }
    }
    return NULL;
}



VOID
InitPercent (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    // bugbug.. for now use same type
    sprintf (pPerf->PerfName, "%d %%of %d",
        Calc1->CalcId, Calc2->CalcId);

    pPerf->SnapData   = SnapPercent;
    pPerf->IsPercent  = TRUE;
    pPerf->AutoTotal  = FALSE;
    pPerf->MaxToUse   = &StaticPercentScale;
    pPerf->DisplayMode= DISPLAY_MODE_TOTAL;
}


VOID
InitSum (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    // bugbug.. for now use same type
    sprintf (pPerf->PerfName, "Sum %d+%d",
        Calc1->CalcId, Calc2->CalcId);

    pPerf->SnapData = SnapSum;
}


VOID
SnapPercent (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    PDISPLAY_ITEM   p1, p2;
    ULONG   i, l, l1, l2;

    p1 = pPerf->CalcPercent[0];
    p2 = pPerf->CalcPercent[1];
    if (p1 == NULL  ||  p2 == NULL) {
        p1 = pPerf->CalcPercent[0] = LookUpCalcId (pPerf->CalcPercentId[0]);
        p2 = pPerf->CalcPercent[1] = LookUpCalcId (pPerf->CalcPercentId[1]);

        if (p1 == NULL || p2 == NULL) {
            LazyOp = TRUE;
            pPerf->DeleteMe = TRUE;
            return;
        }
    }

    l1 = p1->DataList[0][0];
    l2 = p2->DataList[0][0];

    if (l1 > 0x60000) {
        l2 = l2 / 10000;
    } else {
        l1 = l1 * 10000;
    }

    if (l2) {
        pPerf->CurrentDataPoint[0] = l1 / l2;
    } else {
        pPerf->CurrentDataPoint[0] = 0;
    }
}


VOID
SnapSum (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    PDISPLAY_ITEM   p1, p2;
    ULONG   i, l, l1, l2;

    p1 = pPerf->CalcPercent[0];
    p2 = pPerf->CalcPercent[1];
    if (p1 == NULL  ||  p2 == NULL) {
        p1 = pPerf->CalcPercent[0] = LookUpCalcId (pPerf->CalcPercentId[0]);
        p2 = pPerf->CalcPercent[1] = LookUpCalcId (pPerf->CalcPercentId[1]);

        if (p1 == NULL || p2 == NULL) {
            LazyOp = TRUE;
            pPerf->DeleteMe = TRUE;
            return;
        }
    }

    for (i=0; i < NumberOfProcessors; i++) {
        pPerf->CurrentDataPoint[i+1] =
            p1->CurrentDataPoint[i+1] + p2->CurrentDataPoint[i+1];
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\pstat.h ===
#ifndef _PSTAT_INCLUDED_
#define _PSTAT_INCLUDED_

//
//
// MAX_CESRS  - maximum number of event selection registers
//              This is a softwate limit. NoCESR is the runtime value.
// MAX_EVENTS - maximum number of active performance counter registers.
//              This is a softwate limit. NoCounters is the runtime value.
//
// Note - We could define these values as processor independent and
//        use a maximum denominator. 
//        Mostly to limit the size of data structures and arrays based
//        on these values, we are defining 

#if defined(_X86_)
#define MAX_EVENTS              2  // sw: max number of active perf. counters.
#define MAX_CESRS               2  // sw: max number of event selection registers.
#else // !_X86_
// include _IA64_ ...
#define MAX_EVENTS              4  // sw: max number of active perf. counters.
#define MAX_CESRS               4  // sw: max number of event selection registers.
#endif // !_X86_

#define MAX_THUNK_COUNTERS     64
#define MAX_PROCESSORS         32


#define PSTAT_READ_STATS         CTL_CODE (FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_SET_CESR           CTL_CODE (FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_HOOK_THUNK         CTL_CODE (FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_REMOVE_HOOK        CTL_CODE (FILE_DEVICE_UNKNOWN, 3, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_QUERY_EVENTS       CTL_CODE (FILE_DEVICE_UNKNOWN, 4, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_QUERY_EVENTS_INFO  CTL_CODE (FILE_DEVICE_UNKNOWN, 5, METHOD_NEITHER, FILE_ANY_ACCESS)

#define OFFSET(type, field) ((LONG_PTR)(&((type *)0)->field))

//
//
//

typedef struct {
    ULONGLONG       Counters[MAX_EVENTS];
    ULONG           EventId[MAX_EVENTS];
    ULONGLONG       TSC;
    ULONG           reserved;
// FIXFIX - Thierry - 01/2000: 
// To virtualize these counters, we should use ULONGLONG types and not polymorphic types.
    ULONG_PTR       SpinLockAcquires;     
    ULONG_PTR       SpinLockCollisions;
    ULONG_PTR       SpinLockSpins;
    ULONG_PTR       Irqls;
    ULONGLONG       ThunkCounters[MAX_THUNK_COUNTERS];
} PSTATS, *pPSTATS;

typedef struct {
    ULONG           EventId;
    BOOLEAN         Active;
    BOOLEAN         UserMode;
    BOOLEAN         KernelMode;
    BOOLEAN         EdgeDetect;
    ULONG           AppReserved;
    ULONG           reserved;
} SETEVENT, *PSETEVENT;

typedef struct {
    PUCHAR          SourceModule;
    ULONG_PTR       ImageBase;
    PUCHAR          TargetModule;
    PUCHAR          Function;
    ULONG           TracerId;
} HOOKTHUNK, *PHOOKTHUNK;

typedef struct {
    ULONG           EventId;
    KPROFILE_SOURCE ProfileSource;
    ULONG           DescriptionOffset;
    ULONG           SuggestedIntervalBase;
    UCHAR           Buffer[];
} EVENTID, *PEVENTID;

typedef struct _EVENTS_INFO {
    ULONG           Events;
    ULONG           TokenMaxLength;
    ULONG           DescriptionMaxLength;
    ULONG           OfficialTokenMaxLength;
    ULONG           OfficialDescriptionMaxLength;
} EVENTS_INFO, *PEVENTS_INFO;

#if defined(ExAllocatePool)
#undef ExAllocatePool
#endif
#define ExAllocatePool(Type,Size)   ExAllocatePoolWithTag((Type),(Size),'ttsp')

#endif /* _PSTAT_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\app\calcperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   CalcPerf.c

Abstract:

   calculate perfoemance statistics

Author:



Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include "calcperf.h"
#include "..\pstat.h"

//SYSTEM_PERFORMANCE_INFORMATION              PerfInfo;
//SYSTEM_PERFORMANCE_INFORMATION              PreviousPerfInfo;

#define     INFSIZE     60000

HANDLE      DriverHandle;

ULONG                                       NumberOfProcessors;
ULONG                                       Buffer[INFSIZE/4];

extern  ULONG   UseGlobalMax, GlobalMax;

ULONG
InitPerfInfo()
/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return(0);
    }


    //
    // Open P5Stat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    InitPossibleEventList();

    return(NumberOfProcessors);
}


BOOL
CalcPerf(
   PDISPLAY_ITEM    pPerf1
   )

/*++

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{
    ULONG           i;
    ULONG           TotalDataPoint;
    ULONG           OldGlobalMax;
    PDISPLAY_ITEM   pPerf;

    //
    // get system performance info
    //

    OldGlobalMax = GlobalMax;
    GlobalMax = 0;
    UpdateInternalStats();

    for (pPerf = pPerf1; pPerf; pPerf = pPerf->Next) {

        TotalDataPoint = 0;
        pPerf->SnapData (pPerf);

        if (pPerf->AutoTotal) {
            //
            // Automatically calc system total by summing each processor
            //

            switch (pPerf->DisplayMode) {
                case DISPLAY_MODE_TOTAL:
                case DISPLAY_MODE_BREAKDOWN:
                default:

                    for (i=0; i < NumberOfProcessors; i++) {
                        TotalDataPoint += pPerf->CurrentDataPoint[i + 1];

                        UpdatePerfInfo1 (
                            pPerf->DataList[i + 1],
                            pPerf->CurrentDataPoint[i + 1]
                            );
                    }

                    pPerf->ChangeScale = UpdatePerfInfo (
                                            pPerf->DataList[0],
                                            TotalDataPoint,
                                            &pPerf->Max
                                            );

                    break;

                case DISPLAY_MODE_PER_PROCESSOR:
                    for (i=0; i < NumberOfProcessors; i++) {

                        TotalDataPoint += pPerf->CurrentDataPoint[i + 1];

                        pPerf->ChangeScale = UpdatePerfInfo (
                            pPerf->DataList[i + 1],
                            pPerf->CurrentDataPoint[i + 1],
                            &pPerf->Max
                            );

                    }

                    UpdatePerfInfo1 (pPerf->DataList[0], TotalDataPoint);
                    break;
            }
        } else {
            for (i=0; i < NumberOfProcessors+1; i++) {
                pPerf->ChangeScale = UpdatePerfInfo (
                    pPerf->DataList[i],
                    pPerf->CurrentDataPoint[i],
                    &pPerf->Max
                    );
            }
        }

    }

    if (UseGlobalMax  &&  OldGlobalMax != GlobalMax) {
        for (pPerf = pPerf1; pPerf; pPerf = pPerf->Next) {
            pPerf->ChangeScale = TRUE;
        }
    }

    return(TRUE);
}

VOID
UpdateInternalStats(VOID)
{
    IO_STATUS_BLOCK             IOSB;

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_READ_STATS,
        Buffer,                 // input buffer
        INFSIZE,
        NULL,                   // output buffer
        0
    );
}

VOID
SetCounterEvents (PVOID Events, ULONG length)
{
    IO_STATUS_BLOCK             IOSB;

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_SET_CESR,
        Events,                 // input buffer
        length,
        NULL,                   // output buffer
        0
    );
}

VOID
SnapNull (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    ULONG   i;

    for (i=0; i < NumberOfProcessors; i++) {
        pPerf->CurrentDataPoint[i + 1] = 0;
    }
}


VOID
SnapInterrupts (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfo[MAX_PROCESSORS];
    ULONG   i, l;

    NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSORS,
       NULL
    );

    for (i=0; i < NumberOfProcessors; i++) {
        l = ProcessorInfo[i].InterruptCount - pPerf->LastAccumulator[i+1];
        pPerf->LastAccumulator[i+1] = ProcessorInfo[i].InterruptCount;
        pPerf->CurrentDataPoint[i+1] = l / DELAY_SECONDS;
    }
}

VOID
SnapPrivateInfo (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    ULONG   i, j, l, len;
    PULONG  PrivateStat;


    len = *((PULONG) Buffer);
    PrivateStat = (PULONG) ((PUCHAR) Buffer + sizeof(ULONG) + pPerf->SnapParam1);

    // accumlating data, take delta

    for (i=0; i < NumberOfProcessors; i++) {
        if (pPerf->Mega) {
            PULONGLONG li = (PULONGLONG) PrivateStat;

            *li = *li >> 10;
        }

        j = *PrivateStat / DELAY_SECONDS;
        l = j - pPerf->LastAccumulator[i+1];
        pPerf->LastAccumulator[i+1] = j;

        if (l > 0) {
            pPerf->CurrentDataPoint[i+1] = l;

        } else {
            // item wrapped
            pPerf->CurrentDataPoint[i+1] = 0 - l;
        }

        PrivateStat = (PULONG)((PUCHAR)PrivateStat + len);
    }
}



BOOL
UpdatePerfInfo(
   PULONG    DataPointer,
   ULONG     NewDataValue,
   PULONG    OldMaxValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //


    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;

    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {

        DataPointer[Index] = DataPointer[Index-1];



        if (DataPointer[Index] > ScanMax) {
            ScanMax = DataPointer[Index];
        }
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;

    if (NewDataValue > ScanMax) {
        ScanMax = NewDataValue;
    }

    //
    //  If Max values changed then undate the new max
    //  value and return TRUE.
    //

    if (ScanMax > GlobalMax) {
        GlobalMax = ScanMax;
    }

    if (ScanMax != *OldMaxValue) {
        if (ScanMax < *OldMaxValue  &&
            *OldMaxValue - ScanMax <= *OldMaxValue / 10) {
                //
                // New ScanMax is smaller, but only by a tiny amount
                //

                return (FALSE);
        }

        *OldMaxValue = ScanMax;
        return(TRUE);
    }

    return(FALSE);

}

VOID
UpdatePerfInfo1(
   PULONG    DataPointer,
   ULONG     NewDataValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //


    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;

    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {

        DataPointer[Index] = DataPointer[Index-1];
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;

    return ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\makefile.inc ===
DoAlways :
    binplace   p5ctrnam.h
    binplace   p5ctrs.ini
    binplace   p5perf.txt
    binplace   ..\p5perf.reg

.\msg00001.bin : DoAlways p5ctrmsg.mc
    erase .\p5ctrmsg.h
    erase .\msg00001.bin
    erase .\p5ctrmsg.rc
    mc -v -s p5ctrmsg.mc

.\p5ctrmsg.rc : p5ctrmsg.mc 
    erase .\p5ctrmsg.h
    erase .\msg00001.bin
    erase .\p5ctrmsg.rc
    mc -v -s p5ctrmsg.mc

.\p5ctrmsg.h: p5ctrmsg.mc
    erase .\p5ctrmsg.h
    erase .\msg00001.bin
    erase .\p5ctrmsg.rc
    mc -v -s p5ctrmsg.mc

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\app\pperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.h

Abstract:

   This module contains the definit

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _WINPERFH_INCLUDED_
#define _WINPERFH_INCLUDED_

#define DIALOG_SUCCESS  100
#define DIALOG_CANCEL   0

#define IDM_EXIT        1100
#define IDM_SELECT      1101
#define IDM_THUNK       1102
#define IDM_ALL         1103
#define IDM_HACK        1104
#define TIMER_ID        1001
#define IDM_SEL_DLG     1004
#define IDM_THUNK_DLG   1005
#define IDM_CALC_DLG    1006

#define IDM_DISPLAY_TOTAL           1106
#define IDM_DISPLAY_BREAKDOWN       1107
#define IDM_DISPLAY_PER_PROCESSOR   1108
#define IDM_TOPMOST                 1109

#define IDM_ACCEPT                  1200

#define IDM_P5_GEN1                 1206
#define IDM_P5_R0_0                 1207
#define IDM_P5_R3_0                 1208
#define IDM_P5_K_0                  1209

#define IDM_P5_GEN2                 1210
#define IDM_P5_R0_1                 1211
#define IDM_P5_R3_1                 1212
#define IDM_P5_K_1                  1213

#define IDM_PERCENT                 1214

#define IDM_SPIN_ACQUIRE            1250
#define IDM_SPIN_COLL               1251
#define IDM_SPIN_SPIN               1252
#define IDM_IRQL                    1253
#define IDM_INT                     1254

#define IDM_LOGIT                   1260
#define IDM_SCALE                   1261

#define IDM_THUNK_LIST              1301
#define IDM_THUNK_SOURCE            1302
#define IDM_THUNK_IMPORT            1303
#define IDM_THUNK_FUNCTION          1304
#define IDM_THUNK_ADD               1305
#define IDM_THUNK_REMOVE            1306
#define IDM_THUNK_CLEAR_ALL         1307

#define IDM_CALC_TEXTA              1350
#define IDM_CALC_TEXTB              1351
#define IDM_CALC_FORM1              1352
#define IDM_CALC_FORM2              1353
#define IDM_CALC_FORM3              1354
#define IDM_CALC_FORM4              1355


#define WINPERF_ICON 1011
#define CPUTHERM_ICON 1012
#define BALL_BITMAP 1011


#include "calcperf.h"




typedef struct _WINPERF_INFO
{
    DWORD   WindowPositionX;
    DWORD   WindowPositionY;
    DWORD   WindowSizeX;
    DWORD   WindowSizeY;
    DWORD   DisplayMode;
    HPEN    hBluePen;               // total pen
    HPEN    hPPen[MAX_PROCESSORS];
    HPEN    hDotPen;
    HBRUSH  hBackground;
    HBRUSH  hRedBrush;
    HBRUSH  hGreenBrush;
    HBRUSH  hBlueBrush;
    HBRUSH  hLightBrush;
    HBRUSH  hDarkBrush;
    HFONT   LargeFont;
    HFONT   MediumFont;
    HFONT   SmallFont;
    HFONT   hOldFont;
    HMENU   hMenu;
    HWND    hWndMain;
    UINT    TimerId;
    UINT    NumberOfProcessors;
    BOOL    DisplayMenu;
} WINPERF_INFO,*PWINPERF_INFO;






BOOL
InitApplication(
   HANDLE hInstance,
   HBRUSH hBackground
   );


BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    );



LONG APIENTRY
MainWndProc(
   HWND  hWnd,
   UINT  message,
   DWORD DWORD,
   LONG  lParam
   );



LONG APIENTRY
CpuWndProc(
   HWND  hWnd,
   UINT  message,
   DWORD DWORD,
   LONG  lParam
   );


BOOL
APIENTRY About(
   HWND     hDlg,
   unsigned message,
   WORD     DWORD,
   LONG     lParam
   );


BOOL    APIENTRY MGetWindowExt(HDC hdc, INT * pcx, INT * pcy);
BOOL    APIENTRY MGetCurrentPosition(HDC hdc, INT * px, INT * py);
HANDLE  APIENTRY MGetInstHandle(VOID);

LPSTR   MGetCmdLine(VOID);


VOID
UpdateCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient
   );

VOID
DrawCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient,
   IN   ULONG DisplayItem
   );

VOID
ReScalePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   );

ULONG
InitPerfInfo(VOID);


VOID
InitProfileData(PWINPERF_INFO pWinperfInfo);







VOID
DrawPerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );


VOID
UpdatePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

//
//  change style constants
//

#define STYLE_ENABLE_MENU  WS_OVERLAPPEDWINDOW
#define STYLE_DISABLE_MENU (WS_THICKFRAME+WS_BORDER)


LONG APIENTRY
DbgWndProc(
   HWND   hWnd,
   UINT   message,
   DWORD  wParam,
   LONG   lParam
   );

BOOL
APIENTRY ThunkDlgProc(
   HWND hDlg,
   unsigned message,
   DWORD wParam,
   LONG lParam
   );

BOOL
APIENTRY CalcDlgProc(
   HWND hDlg,
   unsigned message,
   DWORD wParam,
   LONG lParam
   );


BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems
    );

VOID
RefitWindows (
    IN  HWND hWnd,
    IN  HDC CurhDC
);

BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );



BOOL
APIENTRY SelectDlgProc(
   HWND hDlg,
   unsigned message,
   DWORD wParam,
   LONG lParam
   );

VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcPerf(
   PDISPLAY_ITEM    pPerf1
   );

VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );


BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    );


VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );


PDISPLAY_ITEM AllocateDisplayItem(VOID);

VOID
SetDefaultDisplayMode (
    IN  HWND hWnd,
    IN  ULONG mode
);

VOID
DoCSTest(
    IN  HWND hWnd
);

VOID
FreeDisplayItem(
    PDISPLAY_ITEM pPerf
);

VOID
SetP5Perf (
    HWND hDlg,
    ULONG IdCombo,
    ULONG p5counter
);

VOID
ClearGraph (
    PDISPLAY_ITEM   pPerf
);

VOID
SetP5CounterEncodings (
    PVOID encoding
);

VOID
SetDisplayToTrue (
    PDISPLAY_ITEM   pPerf,
    ULONG           sort
);

PDISPLAY_ITEM
SetDisplayToFalse (
    PDISPLAY_ITEM pPerf
);


#endif /* _WINPERFH_INCLUDED_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\app\pperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Ken Reneris  hacked into pperf.exe

   original code from Mark Enstrom

Environment:

   Win32

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include "pperf.h"
#include "..\pstat.h"



//
// global handles
//

HANDLE  hInst;

extern UCHAR Buffer[];
extern HANDLE   DriverHandle;

//
// Selected Display Mode (read from wp2.ini), default set here.
//

DISPLAY_ITEM    *PerfGraphList;
WINPERF_INFO    WinperfInfo;


VOID SnapNull (PDISPLAY_ITEM);
VOID SnapPrivateInfo (PDISPLAY_ITEM);
VOID SnapInterrupts (PDISPLAY_ITEM);
VOID SnapCsTest (PDISPLAY_ITEM);

ULONG   DefaultDisplayMode = DISPLAY_MODE_TOTAL;
ULONG   UseGlobalMax, LogIt;
ULONG   GlobalMax;
PDISPLAY_ITEM   Calc1, Calc2;
BOOLEAN LazyOp;

#define MAX_EVENTS         2

struct {
    ULONG   EventId;
    PUCHAR  ShortName;
    PUCHAR  PerfName;
} *Counters;

struct {
    ULONG           WhichCounter;
    ULONG           ComboBoxIndex;
    PDISPLAY_ITEM   pWhichGraph;
    BOOLEAN         R0;
    BOOLEAN         R3;
    UCHAR           na[2];
} ActiveCounters [MAX_EVENTS];

SETEVENT CounterEvents[MAX_EVENTS];


typedef struct {
    ULONG           IdSel;
    PDISPLAY_ITEM   WhichGraph;
    ULONG           State;
    VOID            (*Fnc)(PDISPLAY_ITEM);
    ULONG           Param;
    PUCHAR          Name;
} GENCOUNTER, *PGENCOUNTER;

GENCOUNTER GenCounts[] = {
    IDM_SCALE,          NULL, 0, NULL,            0, NULL,
    IDM_LOGIT,          NULL, 0, NULL,            0, NULL,

    IDM_SPIN_ACQUIRE,   NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, SpinLockAcquires),   "KRes[0]",
    IDM_SPIN_COLL,      NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, SpinLockCollisions), "KRes[1]",
    IDM_SPIN_SPIN,      NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, SpinLockSpins),      "KRes[2]",
    IDM_IRQL,           NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, Irqls),              "KRes[3]",
    IDM_INT,            NULL, 0, SnapInterrupts,  0, "Interrupts",
//  IDM_PERCENT,        NULL, 0, SnapPercent,     0, "Percent 1-2",

// to track checked state
    IDM_P5_R0_0,         NULL, 0, NULL,           0, NULL,
    IDM_P5_R3_0,         NULL, 0, NULL,           0, NULL,
    IDM_P5_K_0,          NULL, 0, NULL,           0, NULL,

    IDM_P5_R0_1,         NULL, 0, NULL,           0, NULL,
    IDM_P5_R3_1,         NULL, 0, NULL,           0, NULL,
    IDM_P5_K_1,          NULL, 0, NULL,           0, NULL,

// eol
    0, NULL, 0, NULL, 0, NULL
};


VOID
InitComboBox (
    HWND hDlg,
    ULONG id,
    ULONG counter
);

VOID
SetGenPerf (
    HWND hDlg,
    PGENCOUNTER GenCount
);


int
__cdecl
main(USHORT argc, CHAR **argv)
/*++

Routine Description:

   Windows entry point routine


Arguments:

Return Value:

   status of operation

Revision History:

      03-21-91      Initial code

--*/
{

//
//
//

   HANDLE   hInstance     = GetModuleHandle(NULL);
   HANDLE   hPrevInstance = (HANDLE)NULL;
   INT      nCmdShow      = SW_SHOWDEFAULT;
   USHORT   _argc         = argc;
   CHAR     **_argv       = argv;
   MSG      msg;
   HBRUSH   BackBrush;


    //
    // check for other instances of this program
    //

    BackBrush = CreateSolidBrush(RGB(192,192,192));

    if (!InitApplication(hInstance,BackBrush)) {
        //DbgPrint("Init Application fails\n");
        return (FALSE);
    }


    //
    // Perform initializations that apply to a specific instance
    //

    if (!InitInstance(hInstance, nCmdShow)){
        //DbgPrint("Init Instance fails\n");
        return (FALSE);
    }

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //


    while (GetMessage(&msg,        // message structure
            (HWND)NULL,            // handle of window receiving the message
            (UINT)NULL,            // lowest message to examine
            (UINT)NULL))           // highest message to examine
        {
        TranslateMessage(&msg);    // Translates virtual key codes
        DispatchMessage(&msg);     // Dispatches message to window
    }

    DeleteObject(BackBrush);

    return (msg.wParam);           // Returns the value from PostQuitMessage
}




BOOL
InitApplication(
    HANDLE  hInstance,
    HBRUSH  hBackground)

/*++

Routine Description:

   Initializes window data and registers window class.

Arguments:

   hInstance   - current instance
   hBackground - background fill brush

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{
    WNDCLASS  wc;
    BOOL      ReturnStatus;

    //
    // Fill in window class structure with parameters that describe the
    // main window.
    //

    wc.style         = CS_DBLCLKS;                          // Class style(s).
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;                // Function to retrieve messages for
                                                            // windows of this class.
    wc.cbClsExtra    = 0;                                   // No per-class extra data.
    wc.cbWndExtra    = 0;                                   // No per-window extra data.
    wc.hInstance     = hInstance;                           // Application that owns the class.
    wc.hIcon         = LoadIcon(hInstance,                  //
                            MAKEINTRESOURCE(WINPERF_ICON)); // Load Winperf icon
    wc.hCursor       = LoadCursor((HANDLE)NULL, IDC_ARROW); // Load default cursor
    wc.hbrBackground = hBackground;;                        // Use background passed to routine
    wc.lpszMenuName  = "pperfMenu";                         // Name of menu resource in .RC file.
    wc.lpszClassName = "PPerfClass";                        // Name used in call to CreateWindow.

    ReturnStatus = RegisterClass(&wc);

    return(ReturnStatus);

}





BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    )

/*++

Routine Description:

   Save instance handle and create main window. This function performs
   initialization tasks that cannot be shared by multiple instances.

Arguments:

    hInstance - Current instance identifier.
    nCmdShow  - Param for first ShowWindow() call.

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{


    DWORD   WindowStyle;

    //
    // Save the instance handle in a static variable, which will be used in
    // many subsequent calls from this application to Windows.
    //

    hInst = hInstance;

    //
    // init the window position and size to be in the upper corner of
    // the screen, 200x100
    //


    //
    //  What I want here is a way to get the WINDOW dimensions
    //

    WinperfInfo.WindowPositionX = 640 - 250;
    WinperfInfo.WindowPositionY = 0;
    WinperfInfo.WindowSizeX	= 250;
    WinperfInfo.WindowSizeY     = 100;

    //
    //  read profile data from .ini file
    //

    // InitProfileData(&WinperfInfo);

    WinperfInfo.hMenu = LoadMenu(hInstance,"pperfMenu");

    //
    // Create a main window for this application instance.
    //

    WinperfInfo.hWndMain = CreateWindow(
        "PPerfClass",                   // See RegisterClass() call.
        "x86 Perf Meter",               // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // window style
        WinperfInfo.WindowPositionX,    // Default horizontal position.
        WinperfInfo.WindowPositionY,    // Default vertical position.
        WinperfInfo.WindowSizeX,        // Default width.
        WinperfInfo.WindowSizeY,        // Default height.
        (HWND)NULL,                     // Overlapped windows have no parent.
        (HMENU)NULL,                    // Use the window class menu.
        hInstance,                      // This instance owns this window.
        (LPVOID)NULL                    // Pointer not needed.
    );

    //
    // Show menu initially
    //

    WindowStyle = GetWindowLong(WinperfInfo.hWndMain,GWL_STYLE);
    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
    SetMenu(WinperfInfo.hWndMain,WinperfInfo.hMenu);
    SetWindowLong(WinperfInfo.hWndMain,GWL_STYLE,WindowStyle);
    SetWindowPos(WinperfInfo.hWndMain, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
    ShowWindow(WinperfInfo.hWndMain,SW_SHOW);
    WinperfInfo.DisplayMode=STYLE_ENABLE_MENU;
    WinperfInfo.DisplayMenu = TRUE;


    //
    // If window could not be created, return "failure"
    //

    if (!WinperfInfo.hWndMain) {
      return (FALSE);
    }

    //
    // Make the window visible; update its client area; and return "success"
    //

    SetFocus(WinperfInfo.hWndMain);
    ShowWindow(WinperfInfo.hWndMain, SW_SHOWNORMAL);
    UpdateWindow(WinperfInfo.hWndMain);

    return (TRUE);

}


VOID
InitPossibleEventList()
{
    UCHAR               buffer[400];
    ULONG               i, Count;
    NTSTATUS            status;
    PEVENTID            Event;
    IO_STATUS_BLOCK     IOSB;


    //
    // Initialize possible counters
    //

    // determine how many events there are

    Event = (PEVENTID) buffer;
    Count = 0;
    do {
        *((PULONG) buffer) = Count;
        Count += 1;

        status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    PSTAT_QUERY_EVENTS,
                    buffer,                 // input buffer
                    sizeof (buffer),
                    NULL,                   // output buffer
                    0
                    );
    } while (NT_SUCCESS(status));

    Counters = malloc(sizeof(*Counters) * Count);
    if (Counters == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Count -= 1;
    for (i=0; i < Count; i++) {
        *((PULONG) buffer) = i;
        NtDeviceIoControlFile(
           DriverHandle,
           (HANDLE) NULL,          // event
           (PIO_APC_ROUTINE) NULL,
           (PVOID) NULL,
           &IOSB,
           PSTAT_QUERY_EVENTS,
           buffer,                 // input buffer
           sizeof (buffer),
           NULL,                   // output buffer
           0
           );

        Counters[i].EventId   = Event->EventId;
        Counters[i].ShortName = _strdup (Event->Buffer);
        Counters[i].PerfName  = _strdup (Event->Buffer + Event->DescriptionOffset);
    }

    Counters[i].EventId   = 0;
    Counters[i].ShortName = NULL;
    Counters[i].PerfName  = NULL;
}



LONG APIENTRY
MainWndProc(
   HWND   hWnd,
   UINT   message,
   DWORD  wParam,
   LONG   lParam
   )

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   message - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/

{
    int             DialogResult;
    PAINTSTRUCT     ps;
    PDISPLAY_ITEM   pPerf, p;
    ULONG           l, i, x, y;
    HDC             hDC;

    //
    //   process each message
    //

    switch (message) {

        //
        // create window
        //

        case WM_CREATE:
        {
            HDC hDC = GetDC(hWnd);
            BOOLEAN   Fit;
            UINT      Index;


            //
            // make brushes and pens
            //

            WinperfInfo.hBluePen     = CreatePen(PS_SOLID,1,RGB(0,0,128));
            WinperfInfo.hDotPen      = CreatePen(PS_DOT,1,RGB(0,0,0));

            WinperfInfo.hPPen[0] = CreatePen(PS_SOLID,1,RGB(255,  0,    0));
            WinperfInfo.hPPen[1] = CreatePen(PS_SOLID,1,RGB(  0, 255,   0));
            WinperfInfo.hPPen[2] = CreatePen(PS_SOLID,1,RGB(255, 255,   0));
            WinperfInfo.hPPen[3] = CreatePen(PS_SOLID,1,RGB(255,   0, 255));
            WinperfInfo.hPPen[4] = CreatePen(PS_SOLID,1,RGB(128,   0,   0));
            WinperfInfo.hPPen[5] = CreatePen(PS_SOLID,1,RGB(  0, 128,   0));
            WinperfInfo.hPPen[6] = CreatePen(PS_SOLID,1,RGB(128, 128,   0));
            WinperfInfo.hPPen[7] = CreatePen(PS_SOLID,1,RGB(128,   0, 128));
            WinperfInfo.hPPen[8] = CreatePen(PS_SOLID,1,RGB(  0,   0, 128));
            WinperfInfo.hPPen[9] = CreatePen(PS_SOLID,1,RGB(  0, 128, 128));
            WinperfInfo.hPPen[10]= CreatePen(PS_SOLID,1,RGB(128, 128, 128));
            // the other 20 pens will just reuse these handles

            WinperfInfo.hBackground  = CreateSolidBrush(RGB(192,192,192));
            WinperfInfo.hLightBrush  = CreateSolidBrush(RGB(255,255,255));
            WinperfInfo.hDarkBrush   = CreateSolidBrush(RGB(128,128,128));
            WinperfInfo.hRedBrush    = CreateSolidBrush(RGB(255,000,000));
            WinperfInfo.hGreenBrush  = CreateSolidBrush(RGB(000,255,000));
            WinperfInfo.hBlueBrush   = CreateSolidBrush(RGB(000,000,255));

            //
            //  create thee fonts using NT default font families
            //

            WinperfInfo.SmallFont      = CreateFont(8,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Small Fonts");

            WinperfInfo.MediumFont      = CreateFont(10,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");

            WinperfInfo.LargeFont      = CreateFont(14,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");


            //
            // create a system timer event to call performance gathering routines by.
            //

            WinperfInfo.TimerId = SetTimer(hWnd,(UINT)TIMER_ID,(UINT)1000 * DELAY_SECONDS,(TIMERPROC)NULL);

            //
            // init performance routines
            //

            WinperfInfo.NumberOfProcessors = InitPerfInfo();

            // copy pen's for remaining processor breakout
            for (i=11; i < WinperfInfo.NumberOfProcessors; i++) {
                WinperfInfo.hPPen[i] = WinperfInfo.hPPen[i % 12];
            }

            if (!WinperfInfo.NumberOfProcessors) {
                MessageBox(hWnd,"P5Stat driver not installed","Winperf",MB_OK);
                DestroyWindow(hWnd);
            }

            //
            // init display variables
            //

            RefitWindows (hWnd, hDC);

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);

      }
      break;

      //
      // re-size
      //

      case WM_SIZE:

      {
            int     i;
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;
            BOOLEAN Fit;

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            RefitWindows(hWnd, NULL);
      }
      break;

      case WM_MOVE:
      {
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;


            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            ReleaseDC(hWnd,hDC);

      }

      break;


      //
      // command from application menu
      //

    case WM_COMMAND:



            switch (wParam){

               //
               // exit window
               //

               case IDM_EXIT:

                  DestroyWindow(hWnd);
                  break;

               //
               // about command
               //

            case IDM_SELECT:
                DialogResult = DialogBox(hInst,MAKEINTRESOURCE(IDM_SEL_DLG),hWnd,(DLGPROC)SelectDlgProc);
                if (DialogResult == DIALOG_SUCCESS) {
                    RefitWindows(hWnd, NULL);
                }
                break;

            case IDM_DISPLAY_TOTAL:
                SetDefaultDisplayMode (hWnd, DISPLAY_MODE_TOTAL);
                break;
            case IDM_DISPLAY_BREAKDOWN:
                SetDefaultDisplayMode (hWnd, DISPLAY_MODE_BREAKDOWN);
                break;
            case IDM_DISPLAY_PER_PROCESSOR:
                SetDefaultDisplayMode (hWnd, DISPLAY_MODE_PER_PROCESSOR);
                break;

            case IDM_TOPMOST:
                //SetWindowPos( hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                //                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                SetWindowPos( hWnd, HWND_TOPMOST, 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                break;

            case IDM_THUNK:
                DialogBox(hInst,MAKEINTRESOURCE(IDM_THUNK_DLG),hWnd,(DLGPROC)ThunkDlgProc);
                break;

            case IDM_HACK:
                DoCSTest(hWnd);
                RefitWindows(hWnd, NULL);
                break;

            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
            }

            break;

        case WM_PAINT:

            //
            // repaint the window
            //

            {

                int i;
                HDC hDC = BeginPaint(hWnd,&ps);

                SelectObject(hDC,GetStockObject(NULL_BRUSH));
                for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                    DrawFrame(hDC,pPerf);
                    DrawPerfText(hDC,pPerf);
                    DrawPerfGraph(hDC,pPerf);
                }

                EndPaint(hWnd,&ps);

            }
            break;


        case WM_TIMER:
        {
            int i;
            HDC hDC = GetDC(hWnd);

            //
            // Calc new information
            //

            CalcPerf(PerfGraphList);

            //
            // If some lazy op, then perform it
            //

            if (LazyOp) {
                pPerf=PerfGraphList;
                while (pPerf) {
                    if (pPerf->DeleteMe) {
                        pPerf = SetDisplayToFalse (pPerf);
                    } else {
                        pPerf = pPerf->Next;
                    }
                }
                RefitWindows(hWnd, hDC);
                LazyOp = FALSE;
            }

            //
            // update all performance information
            //

            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                if (pPerf->ChangeScale) {
                    DrawPerfText(hDC,pPerf);
                    DrawPerfGraph(hDC,pPerf);
                } else {
                    DrawPerfText(hDC,pPerf);
                    ShiftPerfGraph(hDC,pPerf);
                }
            }
            ReleaseDC(hWnd,hDC);
        }
        break;

        //
        // right double click
        //

        case WM_NCRBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            Calc1 = NULL;

            y = HIWORD(lParam);
            x = LOWORD(lParam);
            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                if (x > pPerf->PositionX  &&  x < pPerf->PositionX+pPerf->Width  &&
                    y > pPerf->PositionY  &&  y < pPerf->PositionY+pPerf->Height) {

                    if (pPerf->IsCalc) {
                        SetDisplayToFalse (pPerf);
                        FreeDisplayItem (pPerf);
                        RefitWindows (hWnd, NULL);
                        break;
                    }


                    switch (pPerf->DisplayMode) {
                        case DISPLAY_MODE_TOTAL:            l = DISPLAY_MODE_BREAKDOWN;     break;
                        case DISPLAY_MODE_BREAKDOWN:        l = DISPLAY_MODE_PER_PROCESSOR; break;
                        case DISPLAY_MODE_PER_PROCESSOR:    l = DISPLAY_MODE_TOTAL;         break;
                    }

                    pPerf->DisplayMode = l;
                    hDC = BeginPaint(hWnd,&ps);
                    DrawPerfGraph(hDC,pPerf);       // redraw graph in new mode
                    EndPaint(hWnd,&ps);
                    break;
                }
            }
            break;

            switch (DefaultDisplayMode) {
                case DISPLAY_MODE_TOTAL:            l = DISPLAY_MODE_BREAKDOWN;     break;
                case DISPLAY_MODE_BREAKDOWN:        l = DISPLAY_MODE_PER_PROCESSOR; break;
                case DISPLAY_MODE_PER_PROCESSOR:    l = DISPLAY_MODE_TOTAL;         break;
            }

            DefaultDisplayMode = l;
            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                pPerf->DisplayMode = l;
                hDC = BeginPaint(hWnd,&ps);
                DrawPerfGraph(hDC,pPerf);       // redraw graph in new mode
                EndPaint(hWnd,&ps);
            }
            break;

        //
        // handle a double click
        //

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            DWORD   WindowStyle;


            //
            // get old window style, take out caption and menu
            //

            Calc1 = NULL;
            if (!IsIconic(hWnd)) {

                if (WinperfInfo.DisplayMenu) {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
                    SetMenu(hWnd,NULL);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_DISABLE_MENU;
                    WinperfInfo.DisplayMenu = FALSE;

                } else {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
                    SetMenu(hWnd,WinperfInfo.hMenu);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_ENABLE_MENU;
                    WinperfInfo.DisplayMenu = TRUE;
                }
            } else {
                DefWindowProc(hWnd, message, wParam, lParam);
            }


        }
        break;

        case WM_NCRBUTTONDOWN:
        case WM_RBUTTONDOWN:
            y = HIWORD(lParam);
            x = LOWORD(lParam);
            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                if (x > pPerf->PositionX  &&  x < pPerf->PositionX+pPerf->Width  &&
                    y > pPerf->PositionY  &&  y < pPerf->PositionY+pPerf->Height) {

                    if (!Calc1) {
                        Calc1 = pPerf;
                        break;
                    }

                    if (Calc1 != pPerf) {
                        Calc2 = pPerf;
                        DialogBox(hInst,MAKEINTRESOURCE(IDM_CALC_DLG),hWnd,(DLGPROC)CalcDlgProc);
                        Calc1 = Calc2 = NULL;
                        break;
                    }
                    break;
                }
            }
            break;


        //
        //  enable dragging with mouse in non-client
        //

        case WM_NCHITTEST:
        {
            lParam = DefWindowProc(hWnd, message, wParam, lParam);
            if ((WinperfInfo.DisplayMenu==FALSE) && (lParam == HTCLIENT)) {
                return(HTCAPTION);
            } else {
                return(lParam);
            }


        }
        break;

        case WM_DESTROY:
        {
            UINT    Index;

            //
            // Save profile info
            //

            // SaveProfileData(&WinperfInfo);

            //
            // Delete Windows Objects
            //

            KillTimer(hWnd,TIMER_ID);

            DeleteObject(WinperfInfo.hBluePen);
            for (i=0; i < 12; i++) {
                DeleteObject(WinperfInfo.hPPen[i]);
            }

            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                DeleteMemoryContext(pPerf);
            }

            //
            // Destroy window
            //

            PostQuitMessage(0);
         }
         break;


        default:

            //
            // Passes message on if unproccessed
            //

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return ((LONG)NULL);
}




BOOL
APIENTRY SelectDlgProc(
   HWND hDlg,
   unsigned message,
   DWORD wParam,
   LONG lParam
   )

/*++

Routine Description:

   Process message for select dialog box.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    PDISPLAY_ITEM   pPerf;
    UINT            ButtonState;
    UINT            Index, i;

    switch (message) {
    case WM_INITDIALOG:
        InitComboBox (hDlg, IDM_P5_GEN1, 0);
        InitComboBox (hDlg, IDM_P5_GEN2, 1);

        for (i=0; GenCounts[i].IdSel; i++) {
            SendDlgItemMessage(
                    hDlg,
                    GenCounts[i].IdSel,
                    BM_SETCHECK,
                    GenCounts[i].State,
                    0
                );
        }

        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {

               //
               // end function
               //


           case IDOK:
           case IDM_ACCEPT:
                SetP5Perf  (hDlg, IDM_P5_GEN1, 0);
                SetP5Perf  (hDlg, IDM_P5_GEN2, 1);
                for (i=0; GenCounts[i].IdSel; i++) {
                    SetGenPerf (hDlg, GenCounts+i);
                }

                UseGlobalMax = GenCounts[0].State;
                LogIt        = GenCounts[1].State;

                for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                    pPerf->MaxToUse =
                        UseGlobalMax ? &GlobalMax : &pPerf->Max;
                }

                if (wParam == IDOK) {
                    EndDialog(hDlg, DIALOG_SUCCESS);
                } else {
                    RefitWindows (NULL, NULL);
                }
                return (TRUE);

           case IDCANCEL:

                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);
        }

    }
    return (FALSE);
}


VOID
RefitWindows (HWND hWnd, HDC CurhDC)
{
    PDISPLAY_ITEM   pPerf;
    BOOLEAN         fit;
    ULONG           Index;
    HDC             hDC;

    hWnd = WinperfInfo.hWndMain;

    hDC = CurhDC;
    if (!CurhDC) {
        hDC = GetDC(hWnd);
    }

    fit = FitPerfWindows(hWnd,hDC,PerfGraphList);
    if (!fit) {
        //DbgPrint("Fit Fails\n");
    }

    for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
        DeleteMemoryContext(pPerf);
        CalcDrawFrame(pPerf);

        if (!CreateMemoryContext(hDC,pPerf)) {
            MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
            DestroyWindow(hWnd);
            break;
        }
    }
    InvalidateRect(hWnd,(LPRECT)NULL,TRUE);

    if (!CurhDC) {
        ReleaseDC(hWnd,hDC);
    }
}

VOID
InitComboBox (HWND hDlg, ULONG id, ULONG counter)
{
    HWND    ComboList;
    ULONG   i, nIndex;

    ComboList = GetDlgItem(hDlg, id);
    SendMessage(ComboList, CB_RESETCONTENT, 0, 0);
    SendMessage(ComboList, CB_SETITEMDATA, 0L, 0L);

    if (Counters) {
        for (i=0; Counters[i].PerfName; i++) {
            nIndex = SendMessage(
                            ComboList,
                            CB_ADDSTRING,
                            0,
                            (DWORD) Counters[i].PerfName
                            );

            SendMessage(
                ComboList,
                CB_SETITEMDATA,
                nIndex,
                (DWORD) i
                );
        }
    }

    SendMessage(ComboList, CB_SETCURSEL, ActiveCounters[counter].ComboBoxIndex, 0L);
}

VOID
SetP5Perf (HWND hDlg, ULONG IdCombo, ULONG counter)
{
    static  PUCHAR NameSuffix[] = { "", " (R0)", " (R3)", "" };
    HWND    ComboList;
    ULONG   nIndex, Mega, DU, BSEncoding, flag;
    PDISPLAY_ITEM   pPerf;
    PUCHAR  name;
    SETEVENT   Event;

    ComboList = GetDlgItem(hDlg, IdCombo);
    nIndex = (int)SendMessage(ComboList, CB_GETCURSEL, 0, 0);
    ActiveCounters[counter].ComboBoxIndex = nIndex;

    memset (&Event, 0, sizeof (Event));
    Event.Active = TRUE;
    Event.KernelMode = SendDlgItemMessage(hDlg,IdCombo+1,BM_GETCHECK,0,0) ? TRUE : FALSE;
    Event.UserMode = SendDlgItemMessage(hDlg,IdCombo+2,BM_GETCHECK,0,0) ? TRUE : FALSE;
    BSEncoding = (Event.UserMode << 1) | Event.KernelMode;

    Mega = SendDlgItemMessage(hDlg,IdCombo+3,BM_GETCHECK,0,0) ? 1 : 0;
    //DU = SendDlgItemMessage(hDlg,IdCombo+3,BM_GETCHECK,0,0) ? 1 : 0;
    DU = 0;

    // get encoding for counter
    if ((!Event.KernelMode && !Event.UserMode)  ||  nIndex == -1) {

        // no counter selected, done
        if (ActiveCounters[counter].pWhichGraph != NULL) {
            ClearGraph (ActiveCounters[counter].pWhichGraph);
        }
        return ;
    }

    // select counter
    nIndex = SendMessage(ComboList, CB_GETITEMDATA, nIndex, 0);
    Event.EventId = Counters[nIndex].EventId;

    ActiveCounters[counter].WhichCounter = nIndex;
    if (ActiveCounters[counter].pWhichGraph == NULL) {
        ActiveCounters[counter].pWhichGraph = AllocateDisplayItem();
    }

    pPerf = ActiveCounters[counter].pWhichGraph;    // which window
    sprintf (pPerf->PerfName, "%s%s", Counters[nIndex].PerfName, NameSuffix[BSEncoding]);

    flag = TRUE;
    if (Mega != pPerf->Mega || memcmp (&Event, CounterEvents+counter, sizeof (Event))) {

        flag = FALSE;
        CounterEvents[counter] = Event;
        SetCounterEvents (CounterEvents, sizeof CounterEvents);
    }

    pPerf->SnapData   = SnapPrivateInfo;                // generic snap
    pPerf->SnapParam1 = OFFSET(PSTATS, Counters[ counter ]);
    pPerf->Mega       = Mega;
    SetDisplayToTrue (pPerf, IdCombo);

    if (flag) {
        // didn't change types
        return ;
    }

    // clear graph
    flag = pPerf->CalcId;
    ClearGraph (pPerf);
    pPerf->Mega   = Mega;
    pPerf->CalcId = flag;
    SetDisplayToTrue (pPerf, IdCombo);

    UpdateInternalStats ();
    pPerf->SnapData (pPerf);

    UpdateInternalStats ();
    pPerf->SnapData (pPerf);
}

VOID
ClearGraph (
    PDISPLAY_ITEM   pPerf
)
{
    ULONG   i, j;
    PULONG  pDL;

    SetDisplayToFalse (pPerf);
    pPerf->Mega = FALSE;

    for (i=0 ; i < WinperfInfo.NumberOfProcessors+1; i++) {
        pDL = pPerf->DataList[i];

        for (j=0; j<DATA_LIST_LENGTH; j++) {
            *(pDL++) = 0;
        }
    }

    pPerf->Max = 1;
    pPerf->CurrentDrawingPos = 0;
    pPerf->ChangeScale = TRUE;
}

VOID
SetGenPerf (HWND hDlg, PGENCOUNTER GenCount)
{
    PDISPLAY_ITEM   pPerf;
    ULONG   ButtonState;

    GenCount->State = SendDlgItemMessage(hDlg,GenCount->IdSel,BM_GETCHECK,0,0);
    if (GenCount->Fnc == NULL) {
        return ;
    }

    if (GenCount->WhichGraph == NULL) {
        GenCount->WhichGraph = AllocateDisplayItem();
    }
    pPerf = GenCount->WhichGraph;

    if (!GenCount->State) {
        ClearGraph (pPerf);
        return ;
    }

    strcpy (pPerf->PerfName, GenCount->Name);

    pPerf->SnapData   = GenCount->Fnc;
    pPerf->SnapParam1 = GenCount->Param;
    pPerf->SnapData  (pPerf);
    SetDisplayToTrue (pPerf, GenCount->IdSel);
}

VOID
SetDisplayToTrue (
    PDISPLAY_ITEM   pPerf,
    ULONG           sort
)
{
    PDISPLAY_ITEM   p, *pp;

    Calc1 = NULL;
    if (pPerf->Display) {                           // already displayed
        return ;                                    // just return
    }

    if (pPerf->CalcId) {
        sprintf (pPerf->DispName, "%d. %s", pPerf->CalcId, pPerf->PerfName);
    } else {
        strcpy (pPerf->DispName, pPerf->PerfName);
    }
    pPerf->DispNameLen = strlen (pPerf->DispName);

    pPerf->Display = TRUE;                          // set to display
    pPerf->sort = sort;

    // check to see if grap is already listed
    for (p = PerfGraphList; p; p = p->Next) {
        if (p == pPerf) {
            // already in the active list, ret
            return ;
        }
    }

    // put graph in perfered sorting order
    for (pp = &PerfGraphList; *pp; pp = &(*pp)->Next) {
        if ((*pp)->sort > sort) {
            break;
        }
    }

    pPerf->Next = *pp;
    *pp = pPerf;
}

PDISPLAY_ITEM
SetDisplayToFalse (
    PDISPLAY_ITEM   pPerf
)
{
    PDISPLAY_ITEM   *p, p1;

    for (p = &PerfGraphList; *p; p = &(*p)->Next) {     // remove graph from
        if (*p == pPerf) {                              // active list
            *p = pPerf->Next;
            break;
        }
    }

    if (pPerf->CalcId) {
        Calc1 = Calc2 = NULL;
        for (p1 = PerfGraphList; p1; p1 = p1->Next) {
            p1->CalcPercent[0] = NULL;
            p1->CalcPercent[1] = NULL;
        }
    }

    pPerf->CalcId  = 0;
    pPerf->Display = FALSE;                             // clear flag
    return *p;
}

VOID
SetDefaultDisplayMode (HWND hWnd, ULONG mode)
{
    HDC hDC;
    PDISPLAY_ITEM pPerf;
    PAINTSTRUCT     ps;

    hDC = BeginPaint(hWnd,&ps);
    DefaultDisplayMode = mode;
    for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
        if (pPerf->IsPercent) {
            continue;
        }

        pPerf->DisplayMode = DefaultDisplayMode;
        DrawPerfGraph(hDC,pPerf);       // redraw graph in new mode
    }

    EndPaint(hWnd,&ps);
}


PDISPLAY_ITEM
AllocateDisplayItem()
{
    PDISPLAY_ITEM   pPerf;
    UINT    Index1, Index2;
    PULONG  pDL;

    pPerf = malloc(sizeof (DISPLAY_ITEM));
    if (pPerf == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    RtlZeroMemory (pPerf, sizeof (DISPLAY_ITEM));

    pPerf->Display      = FALSE;
    pPerf->Max          = 1;
    pPerf->SnapData     = SnapNull;
    pPerf->DisplayMode  = DefaultDisplayMode;
    pPerf->AutoTotal    = TRUE;
    pPerf->MaxToUse     = &pPerf->Max;
    strcpy (pPerf->PerfName, "?");
    strcpy (pPerf->DispName, "?");
    pPerf->DispNameLen = 1;

    for (Index1=0 ; Index1 < WinperfInfo.NumberOfProcessors+1; Index1++) {
        pDL = malloc (DATA_LIST_LENGTH * sizeof (ULONG));
        if (pDL == NULL) {
            printf("Memory allocation failed.\n");
            exit(1);
        }

        pPerf->DataList[Index1] = pDL;

        RtlZeroMemory (pDL, sizeof(ULONG) * DATA_LIST_LENGTH);
    }

    return pPerf;
}

VOID
FreeDisplayItem(PDISPLAY_ITEM pPerf)
{
    ULONG   i;

    for (i=0 ; i < WinperfInfo.NumberOfProcessors+1; i++) {
        free (pPerf->DataList[i]);
    }

    free (pPerf);
}


//
// ************** HACKTEST
//

ULONG CsCount[32*32];

struct s_ThreadInfo {
    PULONG  Counter;
    HDC     MemoryDC;
    HWND    hWnd;
} ThreadInfo[32];

DWORD
WorkerCsTestThread (
    struct s_ThreadInfo *TInfo
)
{
    HDC     hDC;
    HDC     hDCmem;
    HBITMAP hbm;
    ULONG   i;

    hDC = GetDC(TInfo->hWnd);
    hDCmem= CreateCompatibleDC(hDC);
    hbm = CreateCompatibleBitmap(hDC,100,100);
    SelectObject(hDCmem,hbm);

    for (i = 0; i < (ULONG)-1 ; i++) {
        (*TInfo->Counter)++;

        //GetPixel(hDC, 9999, 9999);
        //BitBlt(hDC, 1, 1, 20, 20, TInfo->MemoryDC, 0, 0, SRCCOPY);
         PatBlt(hDCmem,0,0,20,20,PATCOPY);
    }

    ReleaseDC(TInfo->hWnd,hDC);

    return 0;
}


VOID
DoCSTest(HWND hWnd)
{
    static  ULONG   ThreadCount = 0;
    PDISPLAY_ITEM   pPerf;
    DWORD           junk;

    if (ThreadCount >= 32) {
        return ;
    }

    pPerf = AllocateDisplayItem();

    ThreadInfo[ThreadCount].Counter = &CsCount[ThreadCount];
    ThreadInfo[ThreadCount].MemoryDC = pPerf->MemoryDC;
    ThreadInfo[ThreadCount].hWnd = hWnd;

    CreateThread (NULL, 0,
        (LPTHREAD_START_ROUTINE) WorkerCsTestThread,
        (LPVOID) &ThreadInfo[ThreadCount],
        0,
        &junk);

    pPerf->SnapData = SnapCsTest;
    pPerf->SnapParam1 = ThreadCount;
    ThreadCount++;

    sprintf (pPerf->PerfName, "CS trans %ld", ThreadCount);
    SetDisplayToTrue (pPerf, 1);
}


VOID
SnapCsTest (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    ULONG   i;

    pPerf->CurrentDataPoint[1] = CsCount[pPerf->SnapParam1];
    CsCount[pPerf->SnapParam1] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\p5ctrnam.h ===
//
//  p5ctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define PENTIUM                           0
#define DATA_READ                         2
#define DATA_WRITE                        4
#define DATA_TLB_MISS                     6
#define DATA_READ_MISS                    8
#define DATA_WRITE_MISS                   10
#define WRITE_HIT_TO_ME_LINE              12
#define DATA_CACHE_LINE_WB                14
#define DATA_CACHE_SNOOPS                 16
#define DATA_CACHE_SNOOP_HITS             18
#define MEMORY_ACCESSES_IN_PIPES          20
#define BANK_CONFLICTS                    22
#define MISADLIGNED_DATA_REF              24
#define CODE_READ                         26
#define CODE_TLB_MISS                     28
#define CODE_CACHE_MISS                   30
#define SEGMENT_LOADS                     32
#define BRANCHES                          38
#define BTB_HITS                          40
#define TAKEN_BRANCH_OR_BTB_HITS          42
#define PIPELINE_FLUSHES                  44
#define INSTRUCTIONS_EXECUTED             46
#define INSTRUCTIONS_EXECUTED_IN_VPIPE    48
#define BUS_UTILIZATION                   50
#define PIPE_STALLED_ON_WRITES            52
#define PIPE_STALLED_ON_READ              54
#define STALLED_WHILE_EWBE                56
#define LOCKED_BUS_CYCLE                  58
#define IO_RW_CYCLE                       60
#define NON_CACHED_MEMORY_REF             62
#define PIPE_STALLED_ON_ADDR_GEN          64
#define FLOPS                             70
#define DR0                               72
#define DR1                               74
#define DR2                               76
#define DR3                               78
#define INTERRUPTS                        80
#define DATA_RW                           82
#define DATA_RW_MISS                      84
#define PCT_DATA_READ_MISS                86
#define PCT_DATA_WRITE_MISS               88
#define PCT_DATA_RW_MISS                  90
#define PCT_DATA_TLB_MISS                 92
#define PCT_DATA_SNOOP_HITS               94
#define PCT_CODE_READ_MISS                96
#define PCT_CODE_TLB_MISS                 98
#define PCT_SEGMENT_CACHE_HITS           100
#define PCT_BTB_HITS                     102
#define PCT_VPIPE_INST                   104
#define PCT_BRANCHES                     106
#define P6_LD_BLOCKS                     108
#define P6_SB_DRAINS                     110
#define P6_MISALIGN_MEM_REF              112
#define P6_SEGMENT_REG_LOADS             114
#define P6_FP_COMP_OPS_EXE               116
#define P6_FP_ASSIST                     118
#define P6_MUL                           120
#define P6_DIV                           122
#define P6_CYCLES_DIV_BUSY               124
#define P6_L2_ADS                        126
#define P6_L2_DBUS_BUSY                  128
#define P6_L2_DBUS_BUSY_RD               130
#define P6_L2_LINES_IN                   132
#define P6_L2_M_LINES_IN                 134
#define P6_L2_LINES_OUT                  136
#define P6_L2_M_LINES_OUT                138
#define P6_L2_IFETCH                     140
#define P6_L2_LD                         142
#define P6_L2_ST                         144
#define P6_L2_RQSTS                      146
#define P6_DATA_MEM_REFS                 148
#define P6_DCU_LINES_IN                  150
#define P6_DCU_M_LINES_IN                152
#define P6_DCU_M_LINES_OUT               154
#define P6_DCU_MISS_OUTSTANDING          156
#define P6_BUS_REQ_OUTSTANDING           158
#define P6_BUS_BNR_DRV                   160
#define P6_BUS_DRDY_CLOCKS               162
#define P6_BUS_LOCK_CLOCKS               164
#define P6_BUS_DATA_RCV                  166
#define P6_BUS_TRANS_BRD                 168
#define P6_BUS_TRANS_RFO                 170
#define P6_BUS_TRANS_WB                  172
#define P6_BUS_TRANS_IFETCH              174
#define P6_BUS_TRANS_INVAL               176
#define P6_BUS_TRANS_PWR                 178
#define P6_BUS_TRANS_P                   180
#define P6_BUS_TRANS_IO                  182
#define P6_BUS_TRANS_DEF                 184
#define P6_BUS_TRANS_BURST               186
#define P6_BUS_TRANS_MEM                 188
#define P6_BUS_TRANS_ANY                 190
#define P6_CPU_CLK_UNHALTED              192
#define P6_BUS_HIT_DRV                   194
#define P6_BUS_HITM_DRV                  196
#define P6_BUS_SNOOP_STALL               198
#define P6_IFU_IFETCH                    200
#define P6_IFU_IFETCH_MISS               202
#define P6_ITLB_MISS                     204
#define P6_IFU_MEM_STALL                 206
#define P6_ILD_STALL                     208
#define P6_RESOURCE_STALLS               210
#define P6_INST_RETIRED                  212
#define P6_FLOPS                         214
#define P6_UOPS_RETIRED                  216
#define P6_BR_INST_RETIRED               218
#define P6_BR_MISS_PRED_RETIRED          220
#define P6_CYCLES_INT_MASKED             222
#define P6_CYCLES_INT_PENDING_AND_MASKED 224
#define P6_HW_INT_RX                     226
#define P6_BR_TAKEN_RETIRED              228
#define P6_BR_MISS_PRED_TAKEN_RET        230
#define P6_INST_DECODED                  232
#define P6_PARTIAL_RAT_STALLS            234
#define P6_BR_INST_DECODED               236
#define P6_BTB_MISSES                    238
#define P6_BR_BOGUS                      240
#define P6_BACLEARS                      242
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\app\thunk.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include "pperf.h"
#include "..\pstat.h"


extern HANDLE   DriverHandle;
extern UCHAR    Buffer[];
#define BufferSize      60000

typedef struct NameList {
    struct NameList     *Next;
    ULONG               Parm;
    struct NameList     *ChildList;
    PUCHAR              Name;
} NAME_LIST, *PNAME_LIST;

PNAME_LIST  DriverList;
PNAME_LIST  ActiveThunks;

PNAME_LIST  SourceModule, ImportModule;

#define COMBOCMD(a,b)  ((a << 16) | b)


NTSTATUS
openfile (
    IN PHANDLE  filehandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
);

VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
);

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
);

VOID ThunkCreateDriverList (VOID);
#define IMPADDRESS(a)  ConvertImportAddress((ULONG)a, (ULONG)Buffer, &SectionHeader)

ULONG HookThunk (PNAME_LIST, PNAME_LIST, PNAME_LIST);
VOID SnapPrivateInfo (PDISPLAY_ITEM);
VOID NameList2ComboBox (HWND hDlg, ULONG id, PNAME_LIST List);
PNAME_LIST AddNameEntry (PNAME_LIST *head, PUCHAR name, ULONG Parm);
VOID FreeNameList (PNAME_LIST  List);
PNAME_LIST GetComboSelection (HWND h, ULONG id);
VOID NameList2ListBox (HWND hDlg, ULONG id, PNAME_LIST List);
VOID loadimagedir (PUCHAR, ULONG, PIMAGE_SECTION_HEADER);
VOID RemoveHook (HWND hDlg);
VOID ClearAllHooks (HWND hDlg);
VOID AddThunk (HWND hDlg);
VOID loadexports (PNAME_LIST Driver, PNAME_LIST Item);



//#define IDM_THUNK_LIST              301
//#define IDM_THUNK_SOURCE            302
//#define IDM_THUNK_IMPORT            303
//#define IDM_THUNK_FUNCTION          304
//#define IDM_THUNK_ADD               305
//#define IDM_THUNK_REMOVE            306

BOOL
APIENTRY ThunkDlgProc(
   HWND hDlg,
   unsigned message,
   DWORD wParam,
   LONG lParam
   )
{
    PNAME_LIST      Item;

    switch (message) {
    case WM_INITDIALOG:
        SourceModule = NULL;
        ImportModule = NULL;
        ThunkCreateDriverList ();
        NameList2ComboBox (hDlg, IDM_THUNK_SOURCE, DriverList);
        NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);
        return (TRUE);

    case WM_COMMAND:
        switch(wParam) {

               //
               // end function
               //

           case COMBOCMD (CBN_SELCHANGE, IDM_THUNK_SOURCE):
           case COMBOCMD (CBN_SELCHANGE, IDM_THUNK_IMPORT):
                Item = GetComboSelection (hDlg, IDM_THUNK_SOURCE);
                if (Item  &&  Item != SourceModule) {
                    SourceModule = Item;
                    NameList2ComboBox (hDlg, IDM_THUNK_IMPORT, Item->ChildList);
                }

                Item = GetComboSelection (hDlg, IDM_THUNK_IMPORT);
                if (Item  &&  Item != ImportModule) {
                    ImportModule = Item;
                    NameList2ComboBox (hDlg, IDM_THUNK_FUNCTION, Item->ChildList);
                }

                break;

           case IDM_THUNK_REMOVE:
                RemoveHook (hDlg);
                break;

           case IDM_THUNK_CLEAR_ALL:
                ClearAllHooks (hDlg);
                break;

           case IDM_THUNK_ADD:
                AddThunk (hDlg);
                break;

           case IDOK:
           case IDCANCEL:
                //DlgThunkData (hDlg);
                FreeNameList (DriverList);
                DriverList = NULL;
                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);
        }

    }
    return (FALSE);
}

VOID AddThunk (HWND hDlg)
{
    PDISPLAY_ITEM   pPerf;
    PNAME_LIST      Item;
    ULONG           id, i;
    PUCHAR          p;
    HWND            thunklist;

    id = 0;
    Item = GetComboSelection (hDlg, IDM_THUNK_FUNCTION);
    if (Item && SourceModule && ImportModule) {
        id = HookThunk (SourceModule, ImportModule, Item);
    }

    if (!id) {
        MessageBox(hDlg,"Thunk was not hooked","Hook error",MB_OK);
        return;
    }

    pPerf = AllocateDisplayItem();

    //
    // build name (the hard way?)
    //

    strcpy (pPerf->PerfName, Item->Name);
    strcat (pPerf->PerfName, "(");
    strcat (pPerf->PerfName, SourceModule->Name);
    for (p=pPerf->PerfName; *p; p++) {
        if (*p == '.')
            *p = 0;
    }
    strcat (pPerf->PerfName, ">");
    strcat (pPerf->PerfName, ImportModule->Name);
    for (p=pPerf->PerfName; *p; p++) {
        if (*p == '.')
            *p = 0;
    }
    strcat (pPerf->PerfName, ")");

    //
    // Add to thunk list
    //

    Item = malloc (sizeof (NAME_LIST));
    if (Item == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Item->Name = _strdup (pPerf->PerfName);
    Item->Parm = (ULONG) pPerf;
    Item->ChildList = NULL;
    Item->Next = ActiveThunks;
    ActiveThunks = Item;
    pPerf->SnapParam2 = id;

    // bugbug
    NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);

    //
    // Add graph to windows
    //

    pPerf->SnapData   = SnapPrivateInfo;        // generic snap
    pPerf->SnapParam1 = OFFSET(PSTATS, ThunkCounters[id-1]);

    SetDisplayToTrue (pPerf, 99);
    RefitWindows(NULL, NULL);
    UpdateInternalStats ();
    pPerf->SnapData (pPerf);
    UpdateInternalStats ();
    pPerf->SnapData (pPerf);
}

VOID ClearAllHooks (HWND hDlg)
{
    PDISPLAY_ITEM   pPerf;
    IO_STATUS_BLOCK IOSB;
    ULONG           id;
    PNAME_LIST      Item;

    while (ActiveThunks) {
        pPerf = (PDISPLAY_ITEM) ActiveThunks->Parm;
        Item = ActiveThunks;
        ActiveThunks = ActiveThunks->Next;

        free (Item->Name);
        free (Item);

        id = pPerf->SnapParam2;

        SetDisplayToFalse (pPerf);          // remove window
        FreeDisplayItem (pPerf);

        // notify driver
        NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            PSTAT_REMOVE_HOOK,
            &id,                    // input buffer
            sizeof (ULONG),
            NULL,                   // output buffer
            0
        );
    }

    NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);
    RefitWindows (NULL, NULL);
}

VOID RemoveHook (HWND hDlg)
{
    ULONG           i, id;
    HWND            ListBox;
    PNAME_LIST      Item, *pp;
    PDISPLAY_ITEM   pPerf;
    IO_STATUS_BLOCK IOSB;

    ListBox = GetDlgItem(hDlg, IDM_THUNK_LIST);
    i =  SendMessage(ListBox, LB_GETCURSEL, 0, 0);
    if (i == -1) {
        return;
    }

    pPerf = (PDISPLAY_ITEM) SendMessage(ListBox, LB_GETITEMDATA, i, 0);

    Item = NULL;
    for (pp = &ActiveThunks; *pp; pp = &(*pp)->Next) {
        if ((*pp)->Parm == (ULONG)pPerf) {
            Item = *pp;
            *pp = (*pp)->Next;          // remove from list
            break ;
        }
    }

    if (!Item) {
        return ;
    }

    free (Item->Name);
    free (Item);

    id = pPerf->SnapParam2;
    SetDisplayToFalse (pPerf);          // remove window
    FreeDisplayItem (pPerf);

    // notify driver
    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_REMOVE_HOOK,
        &id,                    // input buffer
        sizeof (ULONG),
        NULL,                   // output buffer
        0
    );

    NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);
    RefitWindows (NULL, NULL);
}

VOID
NameList2ListBox (HWND hDlg, ULONG id, PNAME_LIST List)
{
    HWND    ListBox;
    ULONG   nIndex;

    ListBox = GetDlgItem(hDlg, id);
    SendMessage(ListBox, LB_RESETCONTENT, 0, 0);
    SendMessage(ListBox, LB_SETITEMDATA, 0L, 0L);

    while (List) {
        nIndex = SendMessage(ListBox, LB_ADDSTRING, 0, (LPARAM)List->Name);
        SendMessage(ListBox, LB_SETITEMDATA, nIndex, List->Parm);
        List = List->Next;
    }
}

VOID
NameList2ComboBox (HWND hDlg, ULONG id, PNAME_LIST List)
{
    HWND    ComboList;
    ULONG   nIndex;

    ComboList = GetDlgItem(hDlg, id);
    SendMessage(ComboList, CB_RESETCONTENT, 0, 0);
    SendMessage(ComboList, CB_SETITEMDATA, 0L, 0L);

    while (List) {
        nIndex = SendMessage(ComboList, CB_ADDSTRING, 0, (LPARAM)List->Name);
        SendMessage(ComboList, CB_SETITEMDATA, nIndex, (ULONG) List);
        List = List->Next;
    }

    SendMessage(ComboList, CB_SETCURSEL, 0, 0L);
}

PNAME_LIST
GetComboSelection (HWND hDlg, ULONG id)
{
    ULONG   i;
    HWND    ComboList;

    ComboList = GetDlgItem(hDlg, id);
    i =  SendMessage(ComboList, CB_GETCURSEL, 0, 0);
    if (i == -1) {
        return NULL;
    }
    return (PNAME_LIST) SendMessage(ComboList, CB_GETITEMDATA, i, 0);
}

VOID
FreeNameList (PNAME_LIST  List)
{
    PNAME_LIST  p1;

    while (List) {
        if (List->ChildList)
            FreeNameList (List->ChildList);

        p1 = List->Next;
        free (List->Name);
        free (List);
        List = p1;
    }
}


ULONG
HookThunk (PNAME_LIST HookSource, PNAME_LIST TargetModule, PNAME_LIST Function)
{
    PNAME_LIST          SourceModule;
    IO_STATUS_BLOCK     IOSB;
    HOOKTHUNK           HookData;
    ULONG               TracerId;
    NTSTATUS            status;


    TracerId = 0;
    for (SourceModule=DriverList; SourceModule; SourceModule = SourceModule->Next) {
        if (SourceModule->Parm == -1) {
            continue;
        }
        if (SourceModule->Parm != HookSource->Parm  &&
            HookSource->Parm != -1) {
                continue;
        }

        HookData.SourceModule = SourceModule->Name;
        HookData.ImageBase    = SourceModule->Parm;
        HookData.TargetModule = TargetModule->Name;
        HookData.Function     = Function->Name;
        HookData.TracerId     = TracerId;

        //
        // Ask driver to hook this thunk
        //

        status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            PSTAT_HOOK_THUNK,
            &HookData,              // input buffer
            sizeof (HookData),
            NULL,                   // output buffer
            0
        );

        if (NT_SUCCESS(status)) {
            TracerId = HookData.TracerId;
        }
    }

    return TracerId;
}

VOID
ThunkCreateDriverList ()
{
    ULONG                               i;
    PRTL_PROCESS_MODULES                Modules;
    PRTL_PROCESS_MODULE_INFORMATION     Module;
    NTSTATUS                            status;
    PNAME_LIST                          Driver, Import, Item, AbortState;
    PIMAGE_IMPORT_DESCRIPTOR            ImpDescriptor;
    IMAGE_SECTION_HEADER                SectionHeader;
    ULONG                               ThunkAddr, ThunkData;

    //
    // Query driver list
    //

    status = NtQuerySystemInformation (
                    SystemModuleInformation,
                    Buffer,
                    BufferSize,
                    &i);

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Add drivers
    //

    Modules = (PRTL_PROCESS_MODULES) Buffer;
    Module  = &Modules->Modules[ 0 ];
    for (i = 0; i < Modules->NumberOfModules; i++) {
        Driver = AddNameEntry (
                    &DriverList,
                    Module->FullPathName + Module->OffsetToFileName,
                    (ULONG) Module->ImageBase
                    );
        Module++;
    }

    //
    // Add imports for each driver
    //

    for (Driver = DriverList; Driver; Driver = Driver->Next) {
        try {

            //
            // Read in source image's headers
            //
            AbortState = Driver;
            loadimagedir (Driver->Name, IMAGE_DIRECTORY_ENTRY_IMPORT, &SectionHeader);

            //
            // Go through each import module
            //

            ImpDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) Buffer;
            while (ImpDescriptor->Characteristics) {

                AbortState = Driver;

                //
                // Add this import to driver's list
                //

                Import = AddNameEntry (
                            &Driver->ChildList,
                            (PUCHAR) IMPADDRESS(ImpDescriptor->Name),
                            1
                            );

                AbortState = Import;

                //
                // Go through each function for the import module
                //

                ThunkAddr = IMPADDRESS (ImpDescriptor->OriginalFirstThunk);
                for (; ;) {
                    ThunkData = (ULONG)((PIMAGE_THUNK_DATA) ThunkAddr)->u1.AddressOfData;
                    if (ThunkData == 0) {
                        // end of table
                        break;
                    }

                    //
                    // Add this function to import list
                    //

                    AddNameEntry (
                         &Import->ChildList,
                         ((PIMAGE_IMPORT_BY_NAME) IMPADDRESS(ThunkData))->Name,
                         0
                         );

                    // next thunk
                    ThunkAddr += sizeof (IMAGE_THUNK_DATA);
                }

                // next import table
                ImpDescriptor++;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            AddNameEntry(&AbortState->ChildList, "* ERROR *", 1);
        }
        // next driver
    }

    //
    // Add "Any driver" selection
    //

    Driver = AddNameEntry(&DriverList, "*Any", (ULONG)-1);

    //
    // For child module list use complete driver list, which is
    // now on the next pointer of Driver.
    //

    for (Item = Driver->Next; Item; Item = Item->Next) {

        // bogus compiler - need to make a subfunction here to keep
        // the compiler happy

        loadexports (Driver, Item);
    }
}

VOID loadexports (PNAME_LIST Driver, PNAME_LIST Item)
{
    IMAGE_SECTION_HEADER                SectionHeader;
    PIMAGE_EXPORT_DIRECTORY             ExpDirectory;
    PULONG                              ExpNameAddr;
    PNAME_LIST                          Import;
    ULONG                               i;


    try {
        loadimagedir (
            Item->Name,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &SectionHeader
        );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return ;
    }

    Import = AddNameEntry (&Driver->ChildList, Item->Name, Item->Parm);

    try {
        ExpDirectory = (PIMAGE_EXPORT_DIRECTORY) Buffer;
        ExpNameAddr  = (PULONG)IMPADDRESS (ExpDirectory->AddressOfNames);
        for (i=0; i < ExpDirectory->NumberOfNames; i++) {
            AddNameEntry (
                 &Import->ChildList,
                 (PUCHAR) IMPADDRESS(*ExpNameAddr),
                 0
                 );
            ExpNameAddr++;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        AddNameEntry(&Import->ChildList, "* ERROR *", 1);
    }
}

VOID
loadimagedir (
    IN PUCHAR filename,
    IN ULONG  dirno,
    OUT PIMAGE_SECTION_HEADER SectionHeader
)
{
    HANDLE                      filehandle;
    ULONG                       i, j, Dir;
    NTSTATUS                    status;
    IMAGE_DOS_HEADER            DosImageHeader;
    IMAGE_NT_HEADERS            NtImageHeader;
    PIMAGE_SECTION_HEADER       pSectionHeader;

    status = openfile (&filehandle, "\\SystemRoot\\", filename);
    if (!NT_SUCCESS(status)) {
        status = openfile (&filehandle, "\\SystemRoot\\System32\\", filename);
    }
    if (!NT_SUCCESS(status)) {
        status = openfile (&filehandle, "\\SystemRoot\\System32\\Drivers\\", filename);
    }

    if (!NT_SUCCESS(status)) {
        RtlRaiseStatus (1);
    }

    try {
        readfile (
            filehandle,
            0,
            sizeof (DosImageHeader),
            (PVOID) &DosImageHeader
            );

        if (DosImageHeader.e_magic != IMAGE_DOS_SIGNATURE) {
            RtlRaiseStatus (1);
        }

        readfile (
            filehandle,
            DosImageHeader.e_lfanew,
            sizeof (NtImageHeader),
            (PVOID) &NtImageHeader
            );

        if (NtImageHeader.Signature != IMAGE_NT_SIGNATURE) {
            RtlRaiseStatus (1);
        }

        //
        // read in complete sections headers from image
        //

        i = NtImageHeader.FileHeader.NumberOfSections
                * sizeof (IMAGE_SECTION_HEADER);

        j = ((ULONG) IMAGE_FIRST_SECTION (&NtImageHeader)) -
                ((ULONG) &NtImageHeader) +
                DosImageHeader.e_lfanew;

        if (i > BufferSize) {
            RtlRaiseStatus (1);
        }

        readfile (
            filehandle,
            j,                  // file offset
            i,                  // length
            Buffer
            );

        //
        // Find section with import directory
        //

        Dir = NtImageHeader.OptionalHeader.DataDirectory[dirno].VirtualAddress;
        i = 0;
        pSectionHeader = (PIMAGE_SECTION_HEADER)Buffer;
        for (; ;) {
            if (i >= NtImageHeader.FileHeader.NumberOfSections) {
                RtlRaiseStatus (1);
            }
            if (pSectionHeader->VirtualAddress <= Dir  &&
                pSectionHeader->VirtualAddress + pSectionHeader->SizeOfRawData > Dir) {
                break;
            }
            i += 1;
            pSectionHeader += 1;
        }

        Dir -= pSectionHeader->VirtualAddress;
        pSectionHeader->VirtualAddress   += Dir;
        pSectionHeader->PointerToRawData += Dir;
        pSectionHeader->SizeOfRawData    -= Dir;

        *SectionHeader = *pSectionHeader;

        //
        // read in complete export section from image
        //

        if (SectionHeader->SizeOfRawData > BufferSize) {
            RtlRaiseStatus (1);
        }

        readfile (
            filehandle,
            SectionHeader->PointerToRawData,
            SectionHeader->SizeOfRawData,
            Buffer
            );
    } finally {

        //
        // Clean up
        //

        NtClose (filehandle);
    }
}

PNAME_LIST
AddNameEntry (PNAME_LIST *head, PUCHAR name, ULONG Parm)
{
    PNAME_LIST  Entry;

    Entry = malloc (sizeof (NAME_LIST));
    if (Entry == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Entry->Name = _strdup (name);
    if (Entry->Name == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Entry->Parm = Parm;
    Entry->ChildList = NULL;

    if (Parm) {
        _strlwr (Entry->Name);
    }

    Entry->Next = *head;
    *head = Entry;

    return Entry;
}

NTSTATUS
openfile (
    IN PHANDLE  filehandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
)
{
    ANSI_STRING    AscBasePath, AscName;
    UNICODE_STRING UniPathName, UniName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       StringBuf[500];

    //
    // Build name
    //

    UniPathName.Buffer = (PWCHAR)StringBuf;
    UniPathName.Length = 0;
    UniPathName.MaximumLength = sizeof( StringBuf );

    RtlInitString(&AscBasePath, BasePath);
    status = RtlAnsiStringToUnicodeString( &UniPathName, &AscBasePath, FALSE );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitString(&AscName, Name);
    status = RtlAnsiStringToUnicodeString( &UniName, &AscName, TRUE );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlAppendUnicodeStringToString (&UniPathName, &UniName);
    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString (&UniName);
        return status;
    }

    InitializeObjectAttributes(
            &ObjA,
            &UniPathName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    //
    // open file
    //

    status = NtOpenFile (
            filehandle,                         // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    RtlFreeUnicodeString (&UniName);
    return status;
}




VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
    )
{
    NTSTATUS            status;
    IO_STATUS_BLOCK     iosb;
    LARGE_INTEGER       foffset;

    foffset = RtlConvertUlongToLargeInteger(offset);

    status = NtReadFile (
        handle,
        NULL,               // event
        NULL,               // apc routine
        NULL,               // apc context
        &iosb,
        buffer,
        len,
        &foffset,
        NULL
        );

    if (!NT_SUCCESS(status)) {
        RtlRaiseStatus (1);
    }
}

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
)
{
    ULONG   EffectiveAddress;

    EffectiveAddress = PoolAddress + ImageRelativeAddress -
            SectionHeader->VirtualAddress;

    if (EffectiveAddress < PoolAddress ||
        EffectiveAddress > PoolAddress + SectionHeader->SizeOfRawData) {

        RtlRaiseStatus (1);
    }

    return EffectiveAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\p5data.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    p5data.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the P5 Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the P5 Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake  24 Dec 93

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include "p5ctrnam.h"
#include "pentdata.h"

//
//  Constant structure initializations for the sturcture defined in p5data.h
//

P5_DATA_DEFINITION P5DataDefinition = {

   {
      sizeof(P5_DATA_DEFINITION) + sizeof(P5_COUNTER_DATA),
      sizeof(P5_DATA_DEFINITION),
      sizeof(PERF_OBJECT_TYPE),
      PENTIUM,
      0,
      PENTIUM,
      0,
      PERF_DETAIL_WIZARD,
      (sizeof(P5_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
         sizeof(PERF_COUNTER_DEFINITION),
      62,
      0,
      0
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_READ,
      0,
      DATA_READ,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_read),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_read
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_WRITE,
      0,
      DATA_WRITE,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_write),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_write
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_TLB_MISS,
      0,
      DATA_TLB_MISS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_tlb_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_tlb_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_READ_MISS,
      0,
      DATA_READ_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_read_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_read_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_WRITE_MISS,
      0,
      DATA_WRITE_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_write_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_write_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      WRITE_HIT_TO_ME_LINE,
      0,
      WRITE_HIT_TO_ME_LINE,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llWrite_hit_to_me_line),
      (DWORD)&((PP5_COUNTER_DATA)0)->llWrite_hit_to_me_line
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_CACHE_LINE_WB,
      0,
      DATA_CACHE_LINE_WB,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_cache_line_wb),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_cache_line_wb
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_CACHE_SNOOPS,
      0,
      DATA_CACHE_SNOOPS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_cache_snoops),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_cache_snoops
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_CACHE_SNOOP_HITS,
      0,
      DATA_CACHE_SNOOP_HITS,
      0,
      -1,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_cache_snoop_hits),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_cache_snoop_hits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      MEMORY_ACCESSES_IN_PIPES,
      0,
      MEMORY_ACCESSES_IN_PIPES,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llMemory_accesses_in_pipes),
      (DWORD)&((PP5_COUNTER_DATA)0)->llMemory_accesses_in_pipes
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BANK_CONFLICTS,
      0,
      BANK_CONFLICTS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBank_conflicts),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBank_conflicts
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      MISADLIGNED_DATA_REF,
      0,
      MISADLIGNED_DATA_REF,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llMisaligned_data_ref),
      (DWORD)&((PP5_COUNTER_DATA)0)->llMisaligned_data_ref
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      CODE_READ,
      0,
      CODE_READ,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llCode_read),
      (DWORD)&((PP5_COUNTER_DATA)0)->llCode_read
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      CODE_TLB_MISS,
      0,
      CODE_TLB_MISS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llCode_tlb_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llCode_tlb_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      CODE_CACHE_MISS,
      0,
      CODE_CACHE_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llCode_cache_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llCode_cache_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      SEGMENT_LOADS,
      0,
      SEGMENT_LOADS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llSegment_loads),
      (DWORD)&((PP5_COUNTER_DATA)0)->llSegment_loads
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BRANCHES,
      0,
      BRANCHES,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBranches),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBranches
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BTB_HITS,
      0,
      BTB_HITS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBtb_hits),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBtb_hits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      TAKEN_BRANCH_OR_BTB_HITS,
      0,
      TAKEN_BRANCH_OR_BTB_HITS,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llTaken_branch_or_btb_hits),
      (DWORD)&((PP5_COUNTER_DATA)0)->llTaken_branch_or_btb_hits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPELINE_FLUSHES,
      0,
      PIPELINE_FLUSHES,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipeline_flushes),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipeline_flushes
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      INSTRUCTIONS_EXECUTED,
      0,
      INSTRUCTIONS_EXECUTED,
      0,
      -5,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llInstructions_executed),
      (DWORD)&((PP5_COUNTER_DATA)0)->llInstructions_executed
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      INSTRUCTIONS_EXECUTED_IN_VPIPE,
      0,
      INSTRUCTIONS_EXECUTED_IN_VPIPE,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llInstructions_executed_in_vpipe),
      (DWORD)&((PP5_COUNTER_DATA)0)->llInstructions_executed_in_vpipe
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BUS_UTILIZATION,
      0,
      BUS_UTILIZATION,
      0,
      -5,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBus_utilization),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBus_utilization
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPE_STALLED_ON_WRITES,
      0,
      PIPE_STALLED_ON_WRITES,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipe_stalled_on_writes),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_writes
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPE_STALLED_ON_READ,
      0,
      PIPE_STALLED_ON_READ,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipe_stalled_on_read),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_read
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      STALLED_WHILE_EWBE,
      0,
      STALLED_WHILE_EWBE,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llStalled_while_ewbe),
      (DWORD)&((PP5_COUNTER_DATA)0)->llStalled_while_ewbe
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      LOCKED_BUS_CYCLE,
      0,
      LOCKED_BUS_CYCLE,
      0,
      -1,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llLocked_bus_cycle),
      (DWORD)&((PP5_COUNTER_DATA)0)->llLocked_bus_cycle
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      IO_RW_CYCLE,
      0,
      IO_RW_CYCLE,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llIo_rw_cycle),
      (DWORD)&((PP5_COUNTER_DATA)0)->llIo_rw_cycle
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      NON_CACHED_MEMORY_REF,
      0,
      NON_CACHED_MEMORY_REF,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llNon_cached_memory_ref),
      (DWORD)&((PP5_COUNTER_DATA)0)->llNon_cached_memory_ref
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPE_STALLED_ON_ADDR_GEN,
      0,
      PIPE_STALLED_ON_ADDR_GEN,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipe_stalled_on_addr_gen),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_addr_gen
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      FLOPS,
      0,
      FLOPS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llFlops),
      (DWORD)&((PP5_COUNTER_DATA)0)->llFlops
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR0,
      0,
      DR0,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister0),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister0
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR1,
      0,
      DR1,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister1),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister1
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR2,
      0,
      DR2,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister2),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister2
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR3,
      0,
      DR3,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister3),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister3
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      INTERRUPTS,
      0,
      INTERRUPTS,
      0,
      -1,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llInterrupts),
      (DWORD)&((PP5_COUNTER_DATA)0)->llInterrupts
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_RW,
      0,
      DATA_RW,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_rw),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_rw
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_RW_MISS,
      0,
      DATA_RW_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_rw_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_rw_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_READ_MISS,
      0,
      PCT_DATA_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataReadMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataReadMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_READ_MISS,
      0,
      PCT_DATA_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataReadBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataReadBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_WRITE_MISS,
      0,
      PCT_DATA_WRITE_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_WRITE_MISS,
      0,
      PCT_DATA_WRITE_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataWriteBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataWriteBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_RW_MISS,
      0,
      PCT_DATA_RW_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataRWMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataRWMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_RW_MISS,
      0,
      PCT_DATA_RW_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataRWBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataRWBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_TLB_MISS,
      0,
      PCT_DATA_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_TLB_MISS,
      0,
      PCT_DATA_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataTLBBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataTLBBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_SNOOP_HITS,
      0,
      PCT_DATA_SNOOP_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_SNOOP_HITS,
      0,
      PCT_DATA_SNOOP_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_READ_MISS,
      0,
      PCT_CODE_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_READ_MISS,
      0,
      PCT_CODE_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeReadBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeReadBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_TLB_MISS,
      0,
      PCT_CODE_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_TLB_MISS,
      0,
      PCT_CODE_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BTB_HITS,
      0,
      PCT_BTB_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBTBHits),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBTBHits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BTB_HITS,
      0,
      PCT_BTB_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBTBBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBTBBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_VPIPE_INST,
      0,
      PCT_VPIPE_INST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctVpipeInst),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctVpipeInst
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_VPIPE_INST,
      0,
      PCT_VPIPE_INST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctVpipeBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctVpipeBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BRANCHES,
      0,
      PCT_BRANCHES,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBranches),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBranches
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BRANCHES,
      0,
      PCT_BRANCHES,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBranchesBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBranchesBase
   }
};

//
// initialize the event Id to direct counter data field
// the index of the element in the array is the event Id of the
// data and the value of the array element is the offset to the 
// LONGLONG data location from the start of the counter data
//

DWORD   P5IndexToData[] = {
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_read),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_write),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_tlb_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_read_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_write_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llWrite_hit_to_me_line),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_cache_line_wb),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_cache_snoops),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_cache_snoop_hits),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llMemory_accesses_in_pipes),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBank_conflicts),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llMisaligned_data_ref),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llCode_read),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llCode_tlb_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llCode_cache_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llSegment_loads),
    PENT_INDEX_NOT_USED,
    PENT_INDEX_NOT_USED,
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBranches),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBtb_hits),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llTaken_branch_or_btb_hits),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipeline_flushes),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llInstructions_executed),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llInstructions_executed_in_vpipe),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBus_utilization),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_writes),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_read),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llStalled_while_ewbe),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llLocked_bus_cycle),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llIo_rw_cycle),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llNon_cached_memory_ref),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_addr_gen),
    PENT_INDEX_NOT_USED,
    PENT_INDEX_NOT_USED,
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llFlops),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister0),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister1),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister2),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister3),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llInterrupts),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_rw),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_rw_miss)
};

// define the limit value
DWORD P5IndexMax = sizeof(P5IndexToData) / sizeof (P5IndexToData[0]);

//
// load the table of direct counters used by derived counters. As in the above
// table, the index of the array is the Event Id and the value of the array element
// indicates that the counter is used in a derived counter.
//
BOOL dwDerivedp5Counters[] = {
    TRUE,   // 0x00
    TRUE,   // 0x01
    TRUE,   // 0x02
    TRUE,   // 0x03
    TRUE,   // 0x04
    FALSE,  // 0x05
    FALSE,  // 0x06
    TRUE,   // 0x07
    TRUE,   // 0x08
    FALSE,  // 0x09
    FALSE,  // 0x0a
    FALSE,  // 0x0b
    TRUE,   // 0x0c
    TRUE,   // 0x0d
    TRUE,   // 0x0e
    FALSE,  // 0x0f
    FALSE,  // 0x10
    FALSE,  // 0x11
    TRUE,   // 0x12
    TRUE,   // 0x13
    FALSE,  // 0x14
    FALSE,  // 0x15
    TRUE,   // 0x16
    TRUE,   // 0x17
    FALSE,  // 0x18
    FALSE,  // 0x19
    FALSE,  // 0x1a
    FALSE,  // 0x1b
    FALSE,  // 0x1c
    FALSE,  // 0x1d
    FALSE,  // 0x1e
    FALSE,  // 0x1f
    FALSE,  // 0x20
    FALSE,  // 0x21
    FALSE,  // 0x22
    FALSE,  // 0x23
    FALSE,  // 0x24
    FALSE,  // 0x25
    FALSE,  // 0x26
    FALSE,  // 0x27
    TRUE,   // 0x28
    TRUE   // 0x29
};

//
// this table maps the direct counter event Id's to the derived counters 
// that use the data. Both event ID's must match for the data to be stored.
//
DERIVED_P5_COUNTER_DEF P5DerivedCounters[] = {
    {0x00, 0x03, 
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadMiss)},
    {0x01, 0x04,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss)},
    {0x02, 0x28, 
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBBase)},
    {0x03, 0x00,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadBase)},
    {0x04, 0x01,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteBase)},
    {0x07, 0x08,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits)},
    {0x08, 0x07,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase)},
    {0x0c, 0x0d,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss)},
    {0x0c, 0x0e,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss)},
    {0x0d, 0x0c,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBBase)},
    {0x0e, 0x0c,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadBase)},
    {0x12, 0x13,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBHits)},
    {0x12, 0x16,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranches),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranchesBase)},
    {0x13, 0x12,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBHits),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBBase)},
    {0x16, 0x12,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranchesBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranches)},
    {0x16, 0x17,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeInst)},
    {0x17, 0x16,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeInst),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeBase)},
    {0x28, 0x02,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss)},
    {0x28, 0x29,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWMiss)},
    {0x29, 0x28,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWBase)}
};

//
// define the number of derived counter entries
//
DWORD    dwP5DerivedCountersCount = sizeof (P5DerivedCounters) /
                                    sizeof (P5DerivedCounters[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\p5ctrs.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    p5ctrs.c

Abstract:

    This file implements the Extensible Objects for  the P5 object type

Created:

    Russ Blake  24 Feb 93

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "p5ctrmsg.h" // error message definition
#include "p5ctrnam.h"
#include "p5msg.h"
#include "perfutil.h"
#include "pentdata.h"
#include "..\pstat.h"

//
//  References to constants which initialize the Object type definitions
//

extern P5_DATA_DEFINITION P5DataDefinition;


//
// P5 data structures
//

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK
BOOL    bP6notP5 = FALSE;        // true for P6 processors, false for P5 CPUs

HANDLE  DriverHandle;           // handle of opened device driver

UCHAR   NumberOfProcessors;

#define     INFSIZE     60000
ULONG       Buffer[INFSIZE/4];


//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC    OpenP5PerformanceData;
PM_COLLECT_PROC CollectP5PerformanceData;
PM_CLOSE_PROC   CloseP5PerformanceData;

static
ULONG
InitPerfInfo()
/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    SYSTEM_PROCESSOR_INFORMATION CpuInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return(0);
    }


    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    NtQuerySystemInformation (
        SystemProcessorInformation,
        &CpuInfo,
        sizeof(CpuInfo),
        NULL);

    if ((CpuInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) &&
        (CpuInfo.ProcessorLevel == 6)) {
        // then this is a P6 so set the global flag
        bP6notP5 = TRUE;
    }

    return(NumberOfProcessors);
}

static
long
GetPerfRegistryInitialization
(
    HKEY     *phKeyDriverPerf,
    DWORD    *pdwFirstCounter,
    DWORD    *pdwFirstHelp
)
{
    long     status;
    DWORD    size;
    DWORD    type;

    // get counter and help index base values from registry
    //      Open key to registry entry
    //      read First Counter and First Help values
    //      update static data strucutures by adding base to
    //          offset value in structure.

    status = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        "SYSTEM\\CurrentControlSet\\Services\\PStat\\Performance",
        0L,
        KEY_ALL_ACCESS,
        phKeyDriverPerf);

    if (status != ERROR_SUCCESS) {
        REPORT_ERROR_DATA (P5PERF_UNABLE_OPEN_DRIVER_KEY, LOG_USER,
            &status, sizeof(status));
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        return(status);
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx(
                *phKeyDriverPerf,
                "First Counter",
                0L,
                &type,
                (LPBYTE)pdwFirstCounter,
                &size);

    if (status != ERROR_SUCCESS) {
        REPORT_ERROR_DATA (P5PERF_UNABLE_READ_FIRST_COUNTER, LOG_USER,
            &status, sizeof(status));
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        return(status);
    }
    size = sizeof (DWORD);
    status = RegQueryValueEx(
                *phKeyDriverPerf,
                "First Help",
                0L,
                &type,
                (LPBYTE)pdwFirstHelp,
                &size);

    if (status != ERROR_SUCCESS) {
        REPORT_ERROR_DATA (P5PERF_UNABLE_READ_FIRST_HELP, LOG_USER,
            &status, sizeof(status));
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
    }
    return(status);
}

DWORD APIENTRY
OpenP5PerformanceData(
    LPWSTR lpDeviceNames
)

/*++

Routine Description:

    This routine will open the driver which gets performance data on the
    P5.  This routine also initializes the data structures used to
    pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (P5)


Return Value:

    None.

--*/

{
    DWORD ctr;
    LONG status;
    HKEY hKeyDriverPerf;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PPERF_COUNTER_DEFINITION pPerfCounterDef;
    P5_COUNTER_DATA p5Data;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount) {
        // open Eventlog interface

        hEventLog = MonOpenEventLog();

        // open device driver to retrieve performance values

        NumberOfProcessors = (UCHAR)InitPerfInfo();

        // log error if unsuccessful

        if (!NumberOfProcessors) {
            REPORT_ERROR (P5PERF_OPEN_FILE_ERROR, LOG_USER);
            // this is fatal, if we can't get data then there's no
            // point in continuing.
            status = GetLastError(); // return error
            goto OpenExitPoint;
        }

        status = GetPerfRegistryInitialization(&hKeyDriverPerf,
                                               &dwFirstCounter,
                                               &dwFirstHelp);
        if (status == ERROR_SUCCESS) {
            // initialize P5 data
            P5DataDefinition.P5PerfObject.ObjectNameTitleIndex +=
                dwFirstCounter;

            P5DataDefinition.P5PerfObject.ObjectHelpTitleIndex +=
                dwFirstHelp;

            pPerfCounterDef = &P5DataDefinition.Data_read;

            for (ctr=0;
                 ctr < P5DataDefinition.P5PerfObject.NumCounters;
                 ctr++, pPerfCounterDef++) {

                pPerfCounterDef->CounterNameTitleIndex += dwFirstCounter;
                pPerfCounterDef->CounterHelpTitleIndex += dwFirstHelp;
            }
            // initialize P6 data
            P6DataDefinition.P6PerfObject.ObjectNameTitleIndex +=
                dwFirstCounter;

            P6DataDefinition.P6PerfObject.ObjectHelpTitleIndex +=
                dwFirstHelp;

            pPerfCounterDef = &P6DataDefinition.StoreBufferBlocks;

            for (ctr=0;
                 ctr < P6DataDefinition.P6PerfObject.NumCounters;
                 ctr++, pPerfCounterDef++) {

                pPerfCounterDef->CounterNameTitleIndex += dwFirstCounter;
                pPerfCounterDef->CounterHelpTitleIndex += dwFirstHelp;
            }
            RegCloseKey (hKeyDriverPerf); // close key to registry

            bInitOK = TRUE; // ok to use this function
        }
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}

static
void 
UpdateInternalStats()
{
    IO_STATUS_BLOCK             IOSB;

    // clear the buffer first

    memset (Buffer, 0, sizeof(Buffer));

    // get the stat's from the driver
    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_READ_STATS,
        Buffer,                  // input buffer
        INFSIZE,
        NULL,                    // output buffer
        0
    );

}

DWORD APIENTRY
CollectP5PerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the P5 counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    DWORD    CurProc;
    DWORD    SpaceNeeded;
    DWORD    dwQueryType;
    pPSTATS  pPentStats;
    DWORD    cReg0;               // pperf Register 0
    DWORD    cReg1;               // pperf Register 1
    DWORD    dwDerivedIndex;
    PVOID    pCounterData;

    WCHAR               ProcessorNameBuffer[11];
    UNICODE_STRING      ProcessorName;
    PP5_DATA_DEFINITION pP5DataDefinition;
    PP5_COUNTER_DATA    pP5Data;

    PP6_DATA_DEFINITION pP6DataDefinition;
    PP6_COUNTER_DATA    pP6Data;

    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;

    UpdateInternalStats();      // get stats as early as possible

    pPentStats = (pPSTATS)((LPBYTE)Buffer + sizeof(ULONG));

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType(lpValueName);

    if ((dwQueryType == QUERY_FOREIGN) ||
        (dwQueryType == QUERY_COSTLY)) {
        // this routine does not service requests for data from
        // Non-NT computers nor is this a "costly" counter
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        // both p5 & p6 counters use the same object id
        if ( !(IsNumberInUnicodeList(
                   P5DataDefinition.P5PerfObject.ObjectNameTitleIndex,
                   lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    if (bP6notP5) {
        pP6DataDefinition = (P6_DATA_DEFINITION *) *lppData;

        SpaceNeeded = sizeof(P6_DATA_DEFINITION) +
                      NumberOfProcessors *
                      (sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_INSTANCE_NAME+1) * sizeof(WCHAR) +
                       sizeof(P6_COUNTER_DATA));
    } else {
        pP5DataDefinition = (P5_DATA_DEFINITION *) *lppData;

        SpaceNeeded = sizeof(P5_DATA_DEFINITION) +
                      NumberOfProcessors *
                      (sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_INSTANCE_NAME+1) * sizeof(WCHAR) +
                       sizeof(P5_COUNTER_DATA));
    }

    if (*lpcbTotalBytes < SpaceNeeded) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    // ******************************************************************
    // ****                                                          ****
    // **** If here, then the data request includes this performance ****
    // ****  object and there's enough room for the data so continue ****
    // ****                                                          ****
    // ******************************************************************

    //
    // Copy the (constant and initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    if (bP6notP5) {
        memmove(pP6DataDefinition,
                &P6DataDefinition,
                sizeof(P6_DATA_DEFINITION));

        pP6DataDefinition->P6PerfObject.NumInstances = NumberOfProcessors;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                          &pP6DataDefinition[1];
    } else {
        memmove(pP5DataDefinition,
                &P5DataDefinition,
                sizeof(P5_DATA_DEFINITION));

        pP5DataDefinition->P5PerfObject.NumInstances = NumberOfProcessors;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pP5DataDefinition[1];
    }

    //
    //  Format and collect P5 data from the system for each processor
    //


    for (CurProc = 0;
         CurProc < NumberOfProcessors;
         CurProc++, pPentStats++) {

        // get the index of the two counters returned by the pentium
        // performance register interface device driver

        cReg0 = pPentStats->EventId[0];
        cReg1 = pPentStats->EventId[1];

        // build the processor intstance structure

        ProcessorName.Length = 0;
        ProcessorName.MaximumLength = 11;
        ProcessorName.Buffer = ProcessorNameBuffer;

        // convert processor instance to a string for use as the instance
        // name
        RtlIntegerToUnicodeString(CurProc, 10, &ProcessorName);

        // initialize the instance structure and return a pointer to the
        // base of the data block for this instance
        MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                   &pCounterData,
                                   0,
                                   0,
                                   CurProc,
                                   &ProcessorName);
        if (bP6notP5) {
            // do P6 data
            pP6Data = (PP6_COUNTER_DATA)pCounterData;

            // define the length of the data
            pP6Data->CounterBlock.ByteLength = sizeof(P6_COUNTER_DATA);

            // clear area so unused counters are 0
        
            memset((PVOID) &pP6Data->llStoreBufferBlocks, // start with 1st data field
                   0,
                   sizeof(P6_COUNTER_DATA) - sizeof(PERF_COUNTER_BLOCK));

            // load the 64bit values in the appropriate counter fields
            // all other values will remain zeroed

            if ((cReg0 < P6IndexMax) &&
                (P6IndexToData[cReg0] != PENT_INDEX_NOT_USED)) {
                *(LONGLONG *)((LPBYTE)pP6Data + P6IndexToData[cReg0]) = 
                    (pPentStats->Counters[0] & 0x000000FFFFFFFFFF);
            }
            if ((cReg1 < P6IndexMax) &&
                (P6IndexToData[cReg1] != PENT_INDEX_NOT_USED)) {
                *(LONGLONG *)((LPBYTE)pP6Data + P6IndexToData[cReg1]) = 
                    (pPentStats->Counters[1] & 0x000000FFFFFFFFFF);

            }

            // set the instance pointer to the first byte after this instance's 
            // counter data
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                       ((PBYTE) pP6Data +
                                        sizeof(P6_COUNTER_DATA));
        } else {
            // do P5 data
            pP5Data = (PP5_COUNTER_DATA)pCounterData;

            // define the length of the data
            pP5Data->CounterBlock.ByteLength = sizeof(P5_COUNTER_DATA);

            // clear area so unused counters are 0
        
            memset((PVOID) &pP5Data->llData_read, // start with 1st data field
                   0,
                   sizeof(P5_COUNTER_DATA) - sizeof(PERF_COUNTER_BLOCK));

            // load the 64bit values in the appropriate counter fields
            // all other values will remain zeroed

            if ((cReg0 < P5IndexMax) &&
                (P5IndexToData[cReg0] != PENT_INDEX_NOT_USED)) {
                // only the low order 40 bits are valid so mask off the
                // others to prevent spurious values
                *(LONGLONG *)((LPBYTE)pP5Data + P5IndexToData[cReg0]) = 
                    (pPentStats->Counters[0] & 0x000000FFFFFFFFFF);
            }
            if ((cReg1 < P5IndexMax) &&
                (P5IndexToData[cReg1] != PENT_INDEX_NOT_USED)) {
                // only the low order 40 bits are valid so mask off the
                // others to prevent spurious values
                *(LONGLONG *)((LPBYTE)pP5Data + P5IndexToData[cReg1]) = 
                    (pPentStats->Counters[1] & 0x000000FFFFFFFFFF);
            }

            // see if the selected counters are part of a derived counter and 
            // update if necessary

            if ((cReg0 < P5IndexMax) && (cReg1 < P5IndexMax) &&
                (dwDerivedp5Counters[cReg0] && dwDerivedp5Counters[cReg1])) {
                for (dwDerivedIndex = 0; 
                     dwDerivedIndex < dwP5DerivedCountersCount;
                     dwDerivedIndex++) {
                    if ((cReg0 == P5DerivedCounters[dwDerivedIndex].dwCR0Index) &&
                        (cReg1 == P5DerivedCounters[dwDerivedIndex].dwCR1Index)) {
                        *(DWORD *)((LPBYTE)pP5Data + 
                            P5DerivedCounters[dwDerivedIndex].dwCR0FieldOffset) =
                                (DWORD)(pPentStats->Counters[0] & 0x00000000FFFFFFFF);
                        *(DWORD *)((LPBYTE)pP5Data + 
                            P5DerivedCounters[dwDerivedIndex].dwCR1FieldOffset) =
                                (DWORD)(pPentStats->Counters[1] & 0x00000000FFFFFFFF);
                        break; // out of loop
                    }
                }
            }

            // set the instance pointer to the first byte after this instance's 
            // counter data
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                       ((PBYTE) pP5Data +
                                        sizeof(P5_COUNTER_DATA));
        }
    }
    // update arguments for return


    // update the object's length in the object def structure
    if (bP6notP5) {
        *lpcbTotalBytes = (DWORD)((PBYTE)pPerfInstanceDefinition -
                (PBYTE)pP6DataDefinition);
        pP6DataDefinition->P6PerfObject.TotalByteLength = *lpcbTotalBytes;
    } else {
    // return the size of this object's data
        *lpcbTotalBytes = (DWORD)((PBYTE)pPerfInstanceDefinition -
                (PBYTE)pP5DataDefinition);
        pP5DataDefinition->P5PerfObject.TotalByteLength = *lpcbTotalBytes;
    }
    // return the pointer to the next available byte in the data block
    *lppData = (PBYTE) pPerfInstanceDefinition;

    // return the number of objects returned in this data block
    *lpNumObjectTypes = PENT_NUM_PERF_OBJECT_TYPES;

    // always return success, unless there was not enough room in the 
    // buffer passed in by the caller
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseP5PerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to P5 device performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (!(--dwOpenCount)) { // when this is the last thread...

        CloseHandle(DriverHandle);

        MonCloseEventLog();
    }

    return ERROR_SUCCESS;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\p5data.h ===
/*++ BUILD Version: 0001  // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

   p5data.h

Abstract:

  Header file for the p5 Extensible Object data definitions

  This file contains definitions to construct the dynamic data
  which is returned by the Configuration Registry. Data from
  various system API calls is placed into the structures shown
  here.

Author:

  Russ Blake 12/23/93

Revision History:


--*/

#ifndef _P5DATA_H_
#define _P5DATA_H_

#pragma pack(4)

//----------------------------------------------------------------------------
//
//  This structure defines the definition header for this performance object
//  This data is initialized in p5data.c and is more or less constant after
//  that. Organizationally, it is followed by an instance definition 
//  structure and a counter data structure for each processor on the system.
//

typedef struct _P5_DATA_DEFINITION
{
    PERF_OBJECT_TYPE          P5PerfObject;
    PERF_COUNTER_DEFINITION   Data_read;
    PERF_COUNTER_DEFINITION   Data_write;
    PERF_COUNTER_DEFINITION   Data_tlb_miss;
    PERF_COUNTER_DEFINITION   Data_read_miss;
    PERF_COUNTER_DEFINITION   Data_write_miss;
    PERF_COUNTER_DEFINITION   Write_hit_to_me_line;
    PERF_COUNTER_DEFINITION   Data_cache_line_wb;
    PERF_COUNTER_DEFINITION   Data_cache_snoops;
    PERF_COUNTER_DEFINITION   Data_cache_snoop_hits;
    PERF_COUNTER_DEFINITION   Memory_accesses_in_pipes;
    PERF_COUNTER_DEFINITION   Bank_conflicts;
    PERF_COUNTER_DEFINITION   Misaligned_data_ref;
    PERF_COUNTER_DEFINITION   Code_read;
    PERF_COUNTER_DEFINITION   Code_tlb_miss;
    PERF_COUNTER_DEFINITION   Code_cache_miss;
    PERF_COUNTER_DEFINITION   Segment_loads;
    PERF_COUNTER_DEFINITION   Branches;
    PERF_COUNTER_DEFINITION   Btb_hits;
    PERF_COUNTER_DEFINITION   Taken_branch_or_btb_hits;
    PERF_COUNTER_DEFINITION   Pipeline_flushes;
    PERF_COUNTER_DEFINITION   Instructions_executed;
    PERF_COUNTER_DEFINITION   Instructions_executed_in_vpipe;
    PERF_COUNTER_DEFINITION   Bus_utilization;
    PERF_COUNTER_DEFINITION   Pipe_stalled_on_writes;
    PERF_COUNTER_DEFINITION   Pipe_stalled_on_read;
    PERF_COUNTER_DEFINITION   Stalled_while_ewbe;
    PERF_COUNTER_DEFINITION   Locked_bus_cycle;
    PERF_COUNTER_DEFINITION   Io_rw_cycle;
    PERF_COUNTER_DEFINITION   Non_cached_memory_ref;
    PERF_COUNTER_DEFINITION   Pipe_stalled_on_addr_gen;
    PERF_COUNTER_DEFINITION   Flops;
    PERF_COUNTER_DEFINITION   DebugRegister0;
    PERF_COUNTER_DEFINITION   DebugRegister1;
    PERF_COUNTER_DEFINITION   DebugRegister2;
    PERF_COUNTER_DEFINITION   DebugRegister3;
    PERF_COUNTER_DEFINITION   Interrupts;
    PERF_COUNTER_DEFINITION   Data_rw;
    PERF_COUNTER_DEFINITION   Data_rw_miss;

    //  Derived Counters

    PERF_COUNTER_DEFINITION   PctDataReadMiss;
    PERF_COUNTER_DEFINITION   PctDataReadBase;
    PERF_COUNTER_DEFINITION   PctDataWriteMiss;
    PERF_COUNTER_DEFINITION   PctDataWriteBase;
    PERF_COUNTER_DEFINITION   PctDataRWMiss;
    PERF_COUNTER_DEFINITION   PctDataRWBase;
    PERF_COUNTER_DEFINITION   PctDataTLBMiss;
    PERF_COUNTER_DEFINITION   PctDataTLBBase;
    PERF_COUNTER_DEFINITION   PctDataSnoopHits;
    PERF_COUNTER_DEFINITION   PctDataSnoopBase;
    PERF_COUNTER_DEFINITION   PctCodeReadMiss;
    PERF_COUNTER_DEFINITION   PctCodeReadBase;
    PERF_COUNTER_DEFINITION   PctCodeTLBMiss;
    PERF_COUNTER_DEFINITION   PctCodeTLBBase;
    PERF_COUNTER_DEFINITION   PctBTBHits;
    PERF_COUNTER_DEFINITION   PctBTBBase;
    PERF_COUNTER_DEFINITION   PctVpipeInst;
    PERF_COUNTER_DEFINITION   PctVpipeBase;
    PERF_COUNTER_DEFINITION   PctBranches;
    PERF_COUNTER_DEFINITION   PctBranchesBase;

} P5_DATA_DEFINITION, *PP5_DATA_DEFINITION;

extern P5_DATA_DEFINITION P5DataDefinition;

//  this structure defines the data block that follows each instance
//  definition structure for each processor

typedef struct _P5_COUNTER_DATA {               // driver index
	PERF_COUNTER_BLOCK	CounterBlock;     

    //  direct counters

    LONGLONG    llData_read;                    // 0x00
    LONGLONG    llData_write;                   // 0x01
    LONGLONG    llData_tlb_miss;                // 0x02
    LONGLONG    llData_read_miss;               // 0x03
    LONGLONG    llData_write_miss;              // 0x04
    LONGLONG    llWrite_hit_to_me_line;         // 0x05
    LONGLONG    llData_cache_line_wb;           // 0x06            
    LONGLONG    llData_cache_snoops;            // 0x07
    LONGLONG    llData_cache_snoop_hits;        // 0x08
    LONGLONG    llMemory_accesses_in_pipes;     // 0x09
    LONGLONG    llBank_conflicts;               // 0x0a
    LONGLONG    llMisaligned_data_ref;          // 0x0b
    LONGLONG    llCode_read;                    // 0x0c
    LONGLONG    llCode_tlb_miss;                // 0x0d
    LONGLONG    llCode_cache_miss;              // 0x0e
    LONGLONG    llSegment_loads;                // 0x0f
    LONGLONG    llBranches;                     // 0x12
    LONGLONG    llBtb_hits;                     // 0x13
    LONGLONG    llTaken_branch_or_btb_hits;     // 0x14
    LONGLONG    llPipeline_flushes;             // 0x15
    LONGLONG    llInstructions_executed;        // 0x16
    LONGLONG    llInstructions_executed_in_vpipe;//0x17
    LONGLONG    llBus_utilization;              // 0x18
    LONGLONG    llPipe_stalled_on_writes;       // 0x19
    LONGLONG    llPipe_stalled_on_read;         // 0x1a
    LONGLONG    llStalled_while_ewbe;           // 0x1b
    LONGLONG    llLocked_bus_cycle;             // 0x1c
    LONGLONG    llIo_rw_cycle;                  // 0x1d
    LONGLONG    llNon_cached_memory_ref;        // 0x1e
    LONGLONG    llPipe_stalled_on_addr_gen;     // 0x1f
    LONGLONG    llFlops;                        // 0x22
    LONGLONG    llDebugRegister0;               // 0x23
    LONGLONG    llDebugRegister1;               // 0x24
    LONGLONG    llDebugRegister2;               // 0x25
    LONGLONG    llDebugRegister3;               // 0x26
    LONGLONG    llInterrupts;                   // 0x27
    LONGLONG    llData_rw;                      // 0x28
    LONGLONG    llData_rw_miss;                 // 0x29

    //  Derived Counters                        // counter index used

    DWORD    dwPctDataReadMiss;                 // 0x03                 
    DWORD    dwPctDataReadBase;                 // 0x00
    DWORD    dwPctDataWriteMiss;                // 0x04
    DWORD    dwPctDataWriteBase;                // 0x01
    DWORD    dwPctDataRWMiss;                   // Ox29
    DWORD    dwPctDataRWBase;                   // 0x28
    DWORD    dwPctDataTLBMiss;                  // 0x02
    DWORD    dwPctDataTLBBase;                  // 0x28
    DWORD    dwPctDataSnoopHits;                // 0x08
    DWORD    dwPctDataSnoopBase;                // 0x07
    DWORD    dwPctCodeReadMiss;                 // 0x0e
    DWORD    dwPctCodeReadBase;                 // 0x0c
    DWORD    dwPctCodeTLBMiss;                  // 0x0d
    DWORD    dwPctCodeTLBBase;                  // 0x0c
    DWORD    dwPctBTBHits;                      // 0x13
    DWORD    dwPctBTBBase;                      // 0x12
    DWORD    dwPctVpipeInst;                    // 0x17
    DWORD    dwPctVpipeBase;                    // 0x16
    DWORD    dwPctBranches;                     // 0x12
    DWORD    dwPctBranchesBase;                 // 0x16
} P5_COUNTER_DATA, *PP5_COUNTER_DATA;

extern DWORD    P5IndexToData[];    // table to find data field
extern DWORD    P5IndexMax;         // number of direct counters

extern BOOL     dwDerivedp5Counters[];  // table to find counters used in derived ctrs.

// table entry to map direct counters to derived counter fields
typedef struct _DERIVED_P5_COUNTER_DEF {
    DWORD   dwCR0Index;         // if the EventId[0] == this field
    DWORD   dwCR1Index;         // and EventId[1] == this field then store 
    DWORD   dwCR0FieldOffset;   // the Low DWORD of Counter[0] at this offset and
    DWORD   dwCR1FieldOffset;   // the low DWORD of Counter[1] at this offset
} DERIVED_P5_COUNTER_DEF, *PDERIVED_P5_COUNTER_DEF;

extern DERIVED_P5_COUNTER_DEF P5DerivedCounters[];  // table of derived counters
extern DWORD    dwP5DerivedCountersCount;           // count of derived counter ref's

#pragma pack ()

#endif //_P5DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\p5msg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    p5msg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:

      Russ Blake 12/93 adapted for P5 usage


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "p5ctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\pentdata.h ===
/*++ BUILD Version: 0001  // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

   Pentdata.h

Abstract:

  Header file for the pentium Extensible Object data definitions

  This file contains definitions to construct the dynamic data
  which is returned by the Configuration Registry. Data from
  various system API calls is placed into the structures shown
  here.

Author:

  Russ Blake 12/23/93

Revision History:


--*/

#ifndef _PENTDATA_H_
#define _PENTDATA_H_

#define MAX_INSTANCE_NAME 9

//
// The routines that load these structures assume that all fields
// are packed and aligned on DWORD boundries. Alpha support may
// change this assumption so the pack pragma is used here to insure
// the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
// Extensible Object definitions
//

// Update the following sort of define when adding an object type.

#define PENT_NUM_PERF_OBJECT_TYPES 1

#define PENT_INDEX_NOT_USED ((DWORD)-1)     // value to indicate unused index

#include "p5data.h"
#include "p6data.h"

#endif // _PENTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\p6data.h ===
/*++ BUILD Version: 0001  // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

   p6data.h

Abstract:

  Header file for the p5 Extensible Object data definitions

  This file contains definitions to construct the dynamic data
  which is returned by the Configuration Registry. Data from
  various system API calls is placed into the structures shown
  here.

Author:

  Russ Blake 12/23/93

Revision History:


--*/

#ifndef _P6DATA_H_
#define _P6DATA_H_

#pragma pack(4)

//----------------------------------------------------------------------------
//
//  This structure defines the definition header for this performance object
//  This data is initialized in p6data.c and is more or less constant after
//  that. Organizationally, it is followed by an instance definition 
//  structure and a counter data structure for each processor on the system.
//

typedef struct _P6_DATA_DEFINITION {
    PERF_OBJECT_TYPE        P6PerfObject;
    PERF_COUNTER_DEFINITION StoreBufferBlocks;
    PERF_COUNTER_DEFINITION StoreBufferDrainCycles;
    PERF_COUNTER_DEFINITION MisalignedDataRef;
    PERF_COUNTER_DEFINITION SegmentLoads;
    PERF_COUNTER_DEFINITION FLOPSExecuted;
    PERF_COUNTER_DEFINITION MicrocodeFPExceptions;
    PERF_COUNTER_DEFINITION Multiplies;
    PERF_COUNTER_DEFINITION Divides;
    PERF_COUNTER_DEFINITION DividerBusyCycles;
    PERF_COUNTER_DEFINITION L2AddressStrobes;
    PERF_COUNTER_DEFINITION L2DataBusBusyCycles;
    PERF_COUNTER_DEFINITION L2DataBusToCpuBusyCycles;
    PERF_COUNTER_DEFINITION L2LinesAllocated;
    PERF_COUNTER_DEFINITION L2LinesMState;
    PERF_COUNTER_DEFINITION L2LinesRemoved;
    PERF_COUNTER_DEFINITION L2LinesMStateRemoved;
    PERF_COUNTER_DEFINITION L2InstructionFetches;
    PERF_COUNTER_DEFINITION L2DataLoads;
    PERF_COUNTER_DEFINITION L2DataStores;
    PERF_COUNTER_DEFINITION L2Requests;
    PERF_COUNTER_DEFINITION DataMemoryReferences;
    PERF_COUNTER_DEFINITION DCULinesAllocated;
    PERF_COUNTER_DEFINITION DCUMStateLinesAllocated;
    PERF_COUNTER_DEFINITION DCUMStateLinesEvicted;
    PERF_COUNTER_DEFINITION WeightedDCUMissesOutstd;
    PERF_COUNTER_DEFINITION BusRequestsOutstanding;
    PERF_COUNTER_DEFINITION BusBNRPinDriveCycles;
    PERF_COUNTER_DEFINITION BusDRDYAssertedClocks;
    PERF_COUNTER_DEFINITION BusLockAssertedClocks;
    PERF_COUNTER_DEFINITION BusClocksReceivingData;
    PERF_COUNTER_DEFINITION BusBurstReadTransactions;
    PERF_COUNTER_DEFINITION BusReadForOwnershipTrans;
    PERF_COUNTER_DEFINITION BusWritebackTransactions;
    PERF_COUNTER_DEFINITION BusInstructionFetches;
    PERF_COUNTER_DEFINITION BusInvalidateTransactions;
    PERF_COUNTER_DEFINITION BusPartialWriteTransactions;
    PERF_COUNTER_DEFINITION BusPartialTransactions;
    PERF_COUNTER_DEFINITION BusIOTransactions;
    PERF_COUNTER_DEFINITION BusDeferredTransactions;
    PERF_COUNTER_DEFINITION BusBurstTransactions;
    PERF_COUNTER_DEFINITION BusMemoryTransactions;
    PERF_COUNTER_DEFINITION BusAllTransactions;
    PERF_COUNTER_DEFINITION CPUWasNotHaltedCycles;
    PERF_COUNTER_DEFINITION BusCPUDrivesHitCycles;
    PERF_COUNTER_DEFINITION BusCPUDrivesHITMCycles;
    PERF_COUNTER_DEFINITION BusSnoopStalledCycles;
    PERF_COUNTER_DEFINITION InstructionFetches;
    PERF_COUNTER_DEFINITION InstructionFetchMisses;
    PERF_COUNTER_DEFINITION InstructionTLBMisses;
    PERF_COUNTER_DEFINITION InstructionFetcthStalledCycles;
    PERF_COUNTER_DEFINITION InstructionLenDecoderStalledCycles;
    PERF_COUNTER_DEFINITION ResourceRelatedStalls;
    PERF_COUNTER_DEFINITION InstructionsRetired;
    PERF_COUNTER_DEFINITION FPComputeOpersRetired;
    PERF_COUNTER_DEFINITION UOPsRetired;
    PERF_COUNTER_DEFINITION BranchesRetired;
    PERF_COUNTER_DEFINITION BranchMissPredictionsRetired;
    PERF_COUNTER_DEFINITION InterruptsMaskedCycles;
    PERF_COUNTER_DEFINITION IntPendingWhileMaskedCycles;
    PERF_COUNTER_DEFINITION HardwareInterruptsReceived;
    PERF_COUNTER_DEFINITION TakenBranchesRetired;
    PERF_COUNTER_DEFINITION TakenBranchMissPredRetired;
    PERF_COUNTER_DEFINITION InstructionsDecoded;
    PERF_COUNTER_DEFINITION PartialRegisterStalls;
    PERF_COUNTER_DEFINITION BranchesDecoded;
    PERF_COUNTER_DEFINITION BTBMisses;
    PERF_COUNTER_DEFINITION BogusBranches;
    PERF_COUNTER_DEFINITION BACLEARSAsserted;
} P6_DATA_DEFINITION, *PP6_DATA_DEFINITION;

extern P6_DATA_DEFINITION P6DataDefinition;


typedef struct _P6_COUNTER_DATA {
    PERF_COUNTER_BLOCK  CounterBlock;

    // direct counters

    LONGLONG            llStoreBufferBlocks;                    // 0x03
    LONGLONG            llStoreBufferDrainCycles;               // 0x04
    LONGLONG            llMisalignedDataRef;                    // 0x05
    LONGLONG            llSegmentLoads;                         // 0x06
    LONGLONG            llFLOPSExecuted;                        // 0x10
    LONGLONG            llMicrocodeFPExceptions;                // 0x11
    LONGLONG            llMultiplies;                           // 0x12
    LONGLONG            llDivides;                              // 0x13
    LONGLONG            llDividerBusyCycles;                    // 0x14
    LONGLONG            llL2AddressStrobes;                     // 0x21
    LONGLONG            llL2DataBusBusyCycles;                  // 0x22
    LONGLONG            llL2DataBusToCpuBusyCycles;             // 0x23
    LONGLONG            llL2LinesAllocated;                     // 0x24
    LONGLONG            llL2LinesMState;                        // 0x25
    LONGLONG            llL2LinesRemoved;                       // 0x26
    LONGLONG            llL2LinesMStateRemoved;                 // 0x27
    LONGLONG            llL2InstructionFetches;                 // 0x28
    LONGLONG            llL2DataLoads;                          // 0x29
    LONGLONG            llL2DataStores;                         // 0x2a
    LONGLONG            llL2Requests;                           // 0x2e
    LONGLONG            llDataMemoryReferences;                 // 0x43
    LONGLONG            llDCULinesAllocated;                    // 0x45
    LONGLONG            llDCUMStateLinesAllocated;              // 0x46
    LONGLONG            llDCUMStateLinesEvicted;                // 0x47
    LONGLONG            llWeightedDCUMissesOutstd;              // 0x48
    LONGLONG            llBusRequestsOutstanding;               // 0x60
    LONGLONG            llBusBNRPinDriveCycles;                 // 0x61
    LONGLONG            llBusDRDYAssertedClocks;                // 0x62
    LONGLONG            llBusLockAssertedClocks;                // 0x63
    LONGLONG            llBusClocksReceivingData;               // 0x64
    LONGLONG            llBusBurstReadTransactions;             // 0x65
    LONGLONG            llBusReadForOwnershipTrans;             // 0x66
    LONGLONG            llBusWritebackTransactions;             // 0x67
    LONGLONG            llBusInstructionFetches;                // 0x68
    LONGLONG            llBusInvalidateTransactions;            // 0x69
    LONGLONG            llBusPartialWriteTransactions;          // 0x6a
    LONGLONG            llBusPartialTransactions;               // 0x6b
    LONGLONG            llBusIOTransactions;                    // 0x6c
    LONGLONG            llBusDeferredTransactions;              // 0x6d
    LONGLONG            llBusBurstTransactions;                 // 0x6e
    LONGLONG            llBusMemoryTransactions;                // 0x6f
    LONGLONG            llBusAllTransactions;                   // 0x70
    LONGLONG            llCPUWasNotHaltedCycles;                // 0x79
    LONGLONG            llBusCPUDrivesHitCycles;                // 0x7a
    LONGLONG            llBusCPUDrivesHITMCycles;               // 0x7b
    LONGLONG            llBusSnoopStalledCycles;                // 0x7e
    LONGLONG            llInstructionFetches;                   // 0x80
    LONGLONG            llInstructionFetchMisses;               // 0x81
    LONGLONG            llInstructionTLBMisses;                 // 0x85
    LONGLONG            llInstructionFetcthStalledCycles;       // 0x86
    LONGLONG            llInstructionLenDecoderStalledCycles;   // 0x87
    LONGLONG            llResourceRelatedStalls;                // 0xa2
    LONGLONG            llInstructionsRetired;                  // 0xc0
    LONGLONG            llFPComputeOpersRetired;                // 0xc1
    LONGLONG            llUOPsRetired;                          // 0xc2
    LONGLONG            llBranchesRetired;                      // 0xc4
    LONGLONG            llBranchMissPredictionsRetired;         // 0xc5
    LONGLONG            llInterruptsMaskedCycles;               // 0xc6
    LONGLONG            llIntPendingWhileMaskedCycles;          // 0xc7
    LONGLONG            llHardwareInterruptsReceived;           // 0xc8
    LONGLONG            llTakenBranchesRetired;                 // 0xc9
    LONGLONG            llTakenBranchMissPredRetired;           // 0xca
    LONGLONG            llInstructionsDecoded;                  // 0xd0
    LONGLONG            llPartialRegisterStalls;                // 0xd2
    LONGLONG            llBranchesDecoded;                      // 0xe0
    LONGLONG            llBTBMisses;                            // 0xe2
    LONGLONG            llBogusBranches;                        // 0xe4
    LONGLONG            llBACLEARSAsserted;                     // 0xe6
} P6_COUNTER_DATA, *PP6_COUNTER_DATA;


extern DWORD    P6IndexToData[];    // table to find data field
extern DWORD    P6IndexMax;         // number of direct counters

#endif //_P6DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\p6data.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    p6data.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the P5 Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the P5 Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake  24 Dec 93

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include "p5ctrnam.h"
#include "pentdata.h"

//
//  Constant structure initializations for the structure defined in p6data.h
//
P6_DATA_DEFINITION P6DataDefinition = {
    {
      sizeof(P6_DATA_DEFINITION) + sizeof(P6_COUNTER_DATA),
      sizeof(P6_DATA_DEFINITION),
      sizeof(PERF_OBJECT_TYPE),
      PENTIUM,
      0,
      PENTIUM,
      0,
      PERF_DETAIL_WIZARD,
      (sizeof(P6_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
         sizeof(PERF_COUNTER_DEFINITION),
      0,
      0,
      0
    },
    { // 1
      sizeof(PERF_COUNTER_DEFINITION),
      P6_LD_BLOCKS,
      0,
      P6_LD_BLOCKS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llStoreBufferBlocks),
      (DWORD)&((PP6_COUNTER_DATA)0)->llStoreBufferBlocks
    },
    { // 2
      sizeof(PERF_COUNTER_DEFINITION),
      P6_SB_DRAINS,
      0,
      P6_SB_DRAINS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llStoreBufferDrainCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llStoreBufferDrainCycles
    },
    { // 3
      sizeof(PERF_COUNTER_DEFINITION),
      P6_MISALIGN_MEM_REF,
      0,
      P6_MISALIGN_MEM_REF,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llMisalignedDataRef),
      (DWORD)&((PP6_COUNTER_DATA)0)->llMisalignedDataRef
    },
    { // 4
      sizeof(PERF_COUNTER_DEFINITION),
      P6_SEGMENT_REG_LOADS,
      0,
      P6_SEGMENT_REG_LOADS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llSegmentLoads),
      (DWORD)&((PP6_COUNTER_DATA)0)->llSegmentLoads
    },
    { // 5
      sizeof(PERF_COUNTER_DEFINITION),
      P6_FP_COMP_OPS_EXE,
      0,
      P6_FP_COMP_OPS_EXE,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llFLOPSExecuted),
      (DWORD)&((PP6_COUNTER_DATA)0)->llFLOPSExecuted
    },
    { // 6
      sizeof(PERF_COUNTER_DEFINITION),
      P6_FP_ASSIST,
      0,
      P6_FP_ASSIST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llMicrocodeFPExceptions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llMicrocodeFPExceptions
    },
    { // 7
      sizeof(PERF_COUNTER_DEFINITION),
      P6_MUL,
      0,
      P6_MUL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llMultiplies),
      (DWORD)&((PP6_COUNTER_DATA)0)->llMultiplies
    },
    { // 8
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DIV,
      0,
      P6_DIV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDivides),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDivides
    },
    { // 9
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CYCLES_DIV_BUSY,
      0,
      P6_CYCLES_DIV_BUSY,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDividerBusyCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDividerBusyCycles
    },
    { // 10
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_ADS,
      0,
      P6_L2_ADS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2AddressStrobes),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2AddressStrobes
    },
    { // 11
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_DBUS_BUSY,
      0,
      P6_L2_DBUS_BUSY,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataBusBusyCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataBusBusyCycles
    },
    { // 12
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_DBUS_BUSY_RD,
      0,
      P6_L2_DBUS_BUSY_RD,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataBusToCpuBusyCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataBusToCpuBusyCycles
    },
    { // 13
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_LINES_IN,
      0,
      P6_L2_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesAllocated),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesAllocated
    },
    { // 14
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_M_LINES_IN,
      0,
      P6_L2_M_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesMState),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesMState
    },
    { //15
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_LINES_OUT,
      0,
      P6_L2_LINES_OUT,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesRemoved),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesRemoved
    },
    { // 16
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_M_LINES_OUT,
      0,
      P6_L2_M_LINES_OUT,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesMStateRemoved),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesMStateRemoved
    },
    { // 17
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_IFETCH,
      0,
      P6_L2_IFETCH,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2InstructionFetches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2InstructionFetches
    },
    { // 18
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_LD,
      0,
      P6_L2_LD,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataLoads),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataLoads
    },
    { // 19
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_ST,
      0,
      P6_L2_ST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataStores),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataStores
    },
    { // 20
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_RQSTS,
      0,
      P6_L2_RQSTS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2Requests),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2Requests
    },
    { // 21
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DATA_MEM_REFS,
      0,
      P6_DATA_MEM_REFS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDataMemoryReferences),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDataMemoryReferences
    },
    { // 22
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_LINES_IN,
      0,
      P6_DCU_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDCULinesAllocated),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDCULinesAllocated
    },
    { //23
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_M_LINES_IN,
      0,
      P6_DCU_M_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDCUMStateLinesAllocated),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesAllocated
    },
    { // 24
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_M_LINES_OUT,
      0,
      P6_DCU_M_LINES_OUT,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDCUMStateLinesEvicted),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesEvicted
    },
    { // 25
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_MISS_OUTSTANDING,
      0,
      P6_DCU_MISS_OUTSTANDING,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llWeightedDCUMissesOutstd),
      (DWORD)&((PP6_COUNTER_DATA)0)->llWeightedDCUMissesOutstd
    },
    { // 26
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_REQ_OUTSTANDING,
      0,
      P6_BUS_REQ_OUTSTANDING,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusRequestsOutstanding),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusRequestsOutstanding
    },
    { // 27
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_BNR_DRV,
      0,
      P6_BUS_BNR_DRV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusBNRPinDriveCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusBNRPinDriveCycles
    },
    { // 28
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_DRDY_CLOCKS,
      0,
      P6_BUS_DRDY_CLOCKS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusDRDYAssertedClocks),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusDRDYAssertedClocks
    },
    { // 29
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_LOCK_CLOCKS,
      0,
      P6_BUS_LOCK_CLOCKS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusLockAssertedClocks),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusLockAssertedClocks
    },
    { //30
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_DATA_RCV,
      0,
      P6_BUS_DATA_RCV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusClocksReceivingData),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusClocksReceivingData
    },
    { // 31
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_BRD,
      0,
      P6_BUS_TRANS_BRD,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusBurstReadTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusBurstReadTransactions
    },
    { // 32
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_RFO,
      0,
      P6_BUS_TRANS_RFO,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusReadForOwnershipTrans),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusReadForOwnershipTrans
    },
    { // 33
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_WB,
      0,
      P6_BUS_TRANS_WB,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusWritebackTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusWritebackTransactions
    },
    { // 34
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_IFETCH,
      0,
      P6_BUS_TRANS_IFETCH,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusInstructionFetches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusInstructionFetches
    },
    { // 35
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_INVAL,
      0,
      P6_BUS_TRANS_INVAL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusInvalidateTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusInvalidateTransactions
    },
    { // 36
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_PWR,
      0,
      P6_BUS_TRANS_PWR,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusPartialWriteTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusPartialWriteTransactions
    },
    { // 37
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_P,
      0,
      P6_BUS_TRANS_P,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusPartialTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusPartialTransactions
    },
    { // 38
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_IO,
      0,
      P6_BUS_TRANS_IO,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusIOTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusIOTransactions
    },
    { // 39
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_DEF,
      0,
      P6_BUS_TRANS_DEF,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusDeferredTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusDeferredTransactions
    },
    { // 40
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_BURST,
      0,
      P6_BUS_TRANS_BURST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusBurstTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusBurstTransactions
    },
    { // 41
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_MEM,
      0,
      P6_BUS_TRANS_MEM,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusMemoryTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusMemoryTransactions
    },
    { // 42
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_ANY,
      0,
      P6_BUS_TRANS_ANY,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusAllTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusAllTransactions
    },
    { // 43
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CPU_CLK_UNHALTED,
      0,
      P6_CPU_CLK_UNHALTED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llCPUWasNotHaltedCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llCPUWasNotHaltedCycles
    },
    { // 44
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_HIT_DRV,
      0,
      P6_BUS_HIT_DRV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusCPUDrivesHitCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHitCycles
    },
    { // 45
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_HITM_DRV,
      0,
      P6_BUS_HITM_DRV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusCPUDrivesHITMCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHITMCycles
    },
    { // 46
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_SNOOP_STALL,
      0,
      P6_BUS_SNOOP_STALL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusSnoopStalledCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusSnoopStalledCycles
    },
    { // 47
      sizeof(PERF_COUNTER_DEFINITION),
      P6_IFU_IFETCH,
      0,
      P6_IFU_IFETCH,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionFetches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionFetches
    },
    { // 48
      sizeof(PERF_COUNTER_DEFINITION),
      P6_IFU_IFETCH_MISS,
      0,
      P6_IFU_IFETCH_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionFetchMisses),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionFetchMisses
    },
    { // 49
      sizeof(PERF_COUNTER_DEFINITION),
      P6_ITLB_MISS,
      0,
      P6_ITLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionTLBMisses),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionTLBMisses
    },
    { // 50
      sizeof(PERF_COUNTER_DEFINITION),
      P6_IFU_MEM_STALL,
      0,
      P6_IFU_MEM_STALL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionFetcthStalledCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionFetcthStalledCycles
    },
    { // 51
      sizeof(PERF_COUNTER_DEFINITION),
      P6_ILD_STALL,
      0,
      P6_ILD_STALL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionLenDecoderStalledCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionLenDecoderStalledCycles
    },
    { // 52
      sizeof(PERF_COUNTER_DEFINITION),
      P6_RESOURCE_STALLS,
      0,
      P6_RESOURCE_STALLS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llResourceRelatedStalls),
      (DWORD)&((PP6_COUNTER_DATA)0)->llResourceRelatedStalls
    },
    { // 53
      sizeof(PERF_COUNTER_DEFINITION),
      P6_INST_RETIRED,
      0,
      P6_INST_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionsRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionsRetired
    },
    { // 54
      sizeof(PERF_COUNTER_DEFINITION),
      P6_FLOPS,
      0,
      P6_FLOPS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llFPComputeOpersRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llFPComputeOpersRetired
    },
    { // 55
      sizeof(PERF_COUNTER_DEFINITION),
      P6_UOPS_RETIRED,
      0,
      P6_UOPS_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llUOPsRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llUOPsRetired
    },
    { // 56
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_INST_RETIRED,
      0,
      P6_BR_INST_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBranchesRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBranchesRetired
    },
    { // 57
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_MISS_PRED_RETIRED,
      0,
      P6_BR_MISS_PRED_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBranchMissPredictionsRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBranchMissPredictionsRetired
    },
    { // 58
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CYCLES_INT_MASKED,
      0,
      P6_CYCLES_INT_MASKED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInterruptsMaskedCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInterruptsMaskedCycles
    },
    { // 59
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CYCLES_INT_PENDING_AND_MASKED,
      0,
      P6_CYCLES_INT_PENDING_AND_MASKED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llIntPendingWhileMaskedCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llIntPendingWhileMaskedCycles
    },
    { // 60
      sizeof(PERF_COUNTER_DEFINITION),
      P6_HW_INT_RX,
      0,
      P6_HW_INT_RX,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llHardwareInterruptsReceived),
      (DWORD)&((PP6_COUNTER_DATA)0)->llHardwareInterruptsReceived
    },
    { // 61
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_TAKEN_RETIRED,
      0,
      P6_BR_TAKEN_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llTakenBranchesRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llTakenBranchesRetired
    },
    { // 62
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_MISS_PRED_TAKEN_RET,
      0,
      P6_BR_MISS_PRED_TAKEN_RET,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llTakenBranchMissPredRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llTakenBranchMissPredRetired
    },
    { // 63
      sizeof(PERF_COUNTER_DEFINITION),
      P6_INST_DECODED,
      0,
      P6_INST_DECODED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionsDecoded),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionsDecoded
    },
    { // 64
      sizeof(PERF_COUNTER_DEFINITION),
      P6_PARTIAL_RAT_STALLS,
      0,
      P6_PARTIAL_RAT_STALLS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llPartialRegisterStalls),
      (DWORD)&((PP6_COUNTER_DATA)0)->llPartialRegisterStalls
    },
    { // 65
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_INST_DECODED,
      0,
      P6_BR_INST_DECODED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBranchesDecoded),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBranchesDecoded
    },
    { // 66
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BTB_MISSES,
      0,
      P6_BTB_MISSES,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBTBMisses),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBTBMisses
    },
    { // 67
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_BOGUS,
      0,
      P6_BR_BOGUS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBogusBranches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBogusBranches
    },
    { // 68
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BACLEARS,
      0,
      P6_BACLEARS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBACLEARSAsserted),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBACLEARSAsserted
    }
};

// load look-up table that maps counter event ID to data field in the
// perf data block
//

DWORD P6IndexToData[] = {
/*  0x00  */	PENT_INDEX_NOT_USED,
/*  0x01  */	PENT_INDEX_NOT_USED,
/*  0x02  */	PENT_INDEX_NOT_USED,
/*  0x03  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llStoreBufferBlocks),
/*  0x04  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llStoreBufferDrainCycles),
/*  0x05  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llMisalignedDataRef),
/*  0x06  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llSegmentLoads),
/*  0x07  */	PENT_INDEX_NOT_USED,
/*  0x08  */	PENT_INDEX_NOT_USED,
/*  0x09  */	PENT_INDEX_NOT_USED,
/*  0x0a  */	PENT_INDEX_NOT_USED,
/*  0x0b  */	PENT_INDEX_NOT_USED,
/*  0x0c  */	PENT_INDEX_NOT_USED,
/*  0x0d  */	PENT_INDEX_NOT_USED,
/*  0x0e  */	PENT_INDEX_NOT_USED,
/*  0x0f  */	PENT_INDEX_NOT_USED,
/*  0x10  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llFLOPSExecuted),
/*  0x11  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llMicrocodeFPExceptions),
/*  0x12  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llMultiplies),
/*  0x13  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDivides),
/*  0x14  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDividerBusyCycles),
/*  0x15  */	PENT_INDEX_NOT_USED,
/*  0x16  */	PENT_INDEX_NOT_USED,
/*  0x17  */	PENT_INDEX_NOT_USED,
/*  0x18  */	PENT_INDEX_NOT_USED,
/*  0x19  */	PENT_INDEX_NOT_USED,
/*  0x1a  */	PENT_INDEX_NOT_USED,
/*  0x1b  */	PENT_INDEX_NOT_USED,
/*  0x1c  */	PENT_INDEX_NOT_USED,
/*  0x1d  */	PENT_INDEX_NOT_USED,
/*  0x1e  */	PENT_INDEX_NOT_USED,
/*  0x1f  */	PENT_INDEX_NOT_USED,
/*  0x20  */	PENT_INDEX_NOT_USED,
/*  0x21  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2AddressStrobes),
/*  0x22  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataBusBusyCycles),
/*  0x23  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataBusToCpuBusyCycles),
/*  0x24  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesAllocated),
/*  0x25  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesMState),
/*  0x26  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesRemoved),
/*  0x27  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesMStateRemoved),
/*  0x28  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2InstructionFetches),
/*  0x29  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataLoads),
/*  0x2a  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataStores),
/*  0x2b  */	PENT_INDEX_NOT_USED,
/*  0x2c  */	PENT_INDEX_NOT_USED,
/*  0x2d  */	PENT_INDEX_NOT_USED,
/*  0x2e  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2Requests),
/*  0x2f  */	PENT_INDEX_NOT_USED,
/*  0x30  */	PENT_INDEX_NOT_USED,
/*  0x31  */	PENT_INDEX_NOT_USED,
/*  0x32  */	PENT_INDEX_NOT_USED,
/*  0x33  */	PENT_INDEX_NOT_USED,
/*  0x34  */	PENT_INDEX_NOT_USED,
/*  0x35  */	PENT_INDEX_NOT_USED,
/*  0x36  */	PENT_INDEX_NOT_USED,
/*  0x37  */	PENT_INDEX_NOT_USED,
/*  0x38  */	PENT_INDEX_NOT_USED,
/*  0x39  */	PENT_INDEX_NOT_USED,
/*  0x3a  */	PENT_INDEX_NOT_USED,
/*  0x3b  */	PENT_INDEX_NOT_USED,
/*  0x3c  */	PENT_INDEX_NOT_USED,
/*  0x3d  */	PENT_INDEX_NOT_USED,
/*  0x3e  */	PENT_INDEX_NOT_USED,
/*  0x3f  */	PENT_INDEX_NOT_USED,
/*  0x40  */	PENT_INDEX_NOT_USED,
/*  0x41  */	PENT_INDEX_NOT_USED,
/*  0x42  */	PENT_INDEX_NOT_USED,
/*  0x43  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDataMemoryReferences),
/*  0x44  */	PENT_INDEX_NOT_USED,
/*  0x45  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDCULinesAllocated),
/*  0x46  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesAllocated),
/*  0x47  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesEvicted),
/*  0x48  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llWeightedDCUMissesOutstd),
/*  0x49  */	PENT_INDEX_NOT_USED,
/*  0x4a  */	PENT_INDEX_NOT_USED,
/*  0x4b  */	PENT_INDEX_NOT_USED,
/*  0x4c  */	PENT_INDEX_NOT_USED,
/*  0x4d  */	PENT_INDEX_NOT_USED,
/*  0x4e  */	PENT_INDEX_NOT_USED,
/*  0x4f  */	PENT_INDEX_NOT_USED,
/*  0x50  */	PENT_INDEX_NOT_USED,
/*  0x51  */	PENT_INDEX_NOT_USED,
/*  0x52  */	PENT_INDEX_NOT_USED,
/*  0x53  */	PENT_INDEX_NOT_USED,
/*  0x54  */	PENT_INDEX_NOT_USED,
/*  0x55  */	PENT_INDEX_NOT_USED,
/*  0x56  */	PENT_INDEX_NOT_USED,
/*  0x57  */	PENT_INDEX_NOT_USED,
/*  0x58  */	PENT_INDEX_NOT_USED,
/*  0x59  */	PENT_INDEX_NOT_USED,
/*  0x5a  */	PENT_INDEX_NOT_USED,
/*  0x5b  */	PENT_INDEX_NOT_USED,
/*  0x5c  */	PENT_INDEX_NOT_USED,
/*  0x5d  */	PENT_INDEX_NOT_USED,
/*  0x5e  */	PENT_INDEX_NOT_USED,
/*  0x5f  */	PENT_INDEX_NOT_USED,
/*  0x60  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusRequestsOutstanding),
/*  0x61  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusBNRPinDriveCycles),
/*  0x62  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusDRDYAssertedClocks),
/*  0x63  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusLockAssertedClocks),
/*  0x64  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusClocksReceivingData),
/*  0x65  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusBurstReadTransactions),
/*  0x66  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusReadForOwnershipTrans),
/*  0x67  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusWritebackTransactions),
/*  0x68  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusInstructionFetches),
/*  0x69  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusInvalidateTransactions),
/*  0x6a  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusPartialWriteTransactions),
/*  0x6b  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusPartialTransactions),
/*  0x6c  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusIOTransactions),
/*  0x6d  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusDeferredTransactions),
/*  0x6e  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusBurstTransactions),
/*  0x6f  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusMemoryTransactions),
/*  0x70  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusAllTransactions),
/*  0x71  */	PENT_INDEX_NOT_USED,
/*  0x72  */	PENT_INDEX_NOT_USED,
/*  0x73  */	PENT_INDEX_NOT_USED,
/*  0x74  */	PENT_INDEX_NOT_USED,
/*  0x75  */	PENT_INDEX_NOT_USED,
/*  0x76  */	PENT_INDEX_NOT_USED,
/*  0x77  */	PENT_INDEX_NOT_USED,
/*  0x78  */	PENT_INDEX_NOT_USED,
/*  0x79  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llCPUWasNotHaltedCycles),
/*  0x7a  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHitCycles),
/*  0x7b  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHITMCycles),
/*  0x7c  */	PENT_INDEX_NOT_USED,
/*  0x7d  */	PENT_INDEX_NOT_USED,
/*  0x7e  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusSnoopStalledCycles),
/*  0x7f  */	PENT_INDEX_NOT_USED,
/*  0x80  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionFetches),
/*  0x81  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionFetchMisses),
/*  0x82  */	PENT_INDEX_NOT_USED,
/*  0x83  */	PENT_INDEX_NOT_USED,
/*  0x84  */	PENT_INDEX_NOT_USED,
/*  0x85  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionTLBMisses),
/*  0x86  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionFetcthStalledCycles),
/*  0x87  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionLenDecoderStalledCycles),
/*  0x88  */	PENT_INDEX_NOT_USED,
/*  0x89  */	PENT_INDEX_NOT_USED,
/*  0x8a  */	PENT_INDEX_NOT_USED,
/*  0x8b  */	PENT_INDEX_NOT_USED,
/*  0x8c  */	PENT_INDEX_NOT_USED,
/*  0x8d  */	PENT_INDEX_NOT_USED,
/*  0x8e  */	PENT_INDEX_NOT_USED,
/*  0x8f  */	PENT_INDEX_NOT_USED,
/*  0x90  */	PENT_INDEX_NOT_USED,
/*  0x91  */	PENT_INDEX_NOT_USED,
/*  0x92  */	PENT_INDEX_NOT_USED,
/*  0x93  */	PENT_INDEX_NOT_USED,
/*  0x94  */	PENT_INDEX_NOT_USED,
/*  0x95  */	PENT_INDEX_NOT_USED,
/*  0x96  */	PENT_INDEX_NOT_USED,
/*  0x97  */	PENT_INDEX_NOT_USED,
/*  0x98  */	PENT_INDEX_NOT_USED,
/*  0x99  */	PENT_INDEX_NOT_USED,
/*  0x9a  */	PENT_INDEX_NOT_USED,
/*  0x9b  */	PENT_INDEX_NOT_USED,
/*  0x9c  */	PENT_INDEX_NOT_USED,
/*  0x9d  */	PENT_INDEX_NOT_USED,
/*  0x9e  */	PENT_INDEX_NOT_USED,
/*  0x9f  */	PENT_INDEX_NOT_USED,
/*  0xa0  */	PENT_INDEX_NOT_USED,
/*  0xa1  */	PENT_INDEX_NOT_USED,
/*  0xa2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llResourceRelatedStalls),
/*  0xa3  */	PENT_INDEX_NOT_USED,
/*  0xa4  */	PENT_INDEX_NOT_USED,
/*  0xa5  */	PENT_INDEX_NOT_USED,
/*  0xa6  */	PENT_INDEX_NOT_USED,
/*  0xa7  */	PENT_INDEX_NOT_USED,
/*  0xa8  */	PENT_INDEX_NOT_USED,
/*  0xa9  */	PENT_INDEX_NOT_USED,
/*  0xaa  */	PENT_INDEX_NOT_USED,
/*  0xab  */	PENT_INDEX_NOT_USED,
/*  0xac  */	PENT_INDEX_NOT_USED,
/*  0xad  */	PENT_INDEX_NOT_USED,
/*  0xae  */	PENT_INDEX_NOT_USED,
/*  0xaf  */	PENT_INDEX_NOT_USED,
/*  0xb0  */	PENT_INDEX_NOT_USED,
/*  0xb1  */	PENT_INDEX_NOT_USED,
/*  0xb2  */	PENT_INDEX_NOT_USED,
/*  0xb3  */	PENT_INDEX_NOT_USED,
/*  0xb4  */	PENT_INDEX_NOT_USED,
/*  0xb5  */	PENT_INDEX_NOT_USED,
/*  0xb6  */	PENT_INDEX_NOT_USED,
/*  0xb7  */	PENT_INDEX_NOT_USED,
/*  0xb8  */	PENT_INDEX_NOT_USED,
/*  0xb9  */	PENT_INDEX_NOT_USED,
/*  0xba  */	PENT_INDEX_NOT_USED,
/*  0xbb  */	PENT_INDEX_NOT_USED,
/*  0xbc  */	PENT_INDEX_NOT_USED,
/*  0xbd  */	PENT_INDEX_NOT_USED,
/*  0xbe  */	PENT_INDEX_NOT_USED,
/*  0xbf  */	PENT_INDEX_NOT_USED,
/*  0xc0  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionsRetired),
/*  0xc1  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llFPComputeOpersRetired),
/*  0xc2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llUOPsRetired),
/*  0xc3  */	PENT_INDEX_NOT_USED,
/*  0xc4  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBranchesRetired),
/*  0xc5  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBranchMissPredictionsRetired),
/*  0xc6  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInterruptsMaskedCycles),
/*  0xc7  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llIntPendingWhileMaskedCycles),
/*  0xc8  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llHardwareInterruptsReceived),
/*  0xc9  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llTakenBranchesRetired),
/*  0xca  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llTakenBranchMissPredRetired),
/*  0xcb  */	PENT_INDEX_NOT_USED,
/*  0xcc  */	PENT_INDEX_NOT_USED,
/*  0xcd  */	PENT_INDEX_NOT_USED,
/*  0xce  */	PENT_INDEX_NOT_USED,
/*  0xcf  */	PENT_INDEX_NOT_USED,
/*  0xd0  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionsDecoded),
/*  0xd1  */	PENT_INDEX_NOT_USED,
/*  0xd2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llPartialRegisterStalls),
/*  0xd3  */	PENT_INDEX_NOT_USED,
/*  0xd4  */	PENT_INDEX_NOT_USED,
/*  0xd5  */	PENT_INDEX_NOT_USED,
/*  0xd6  */	PENT_INDEX_NOT_USED,
/*  0xd7  */	PENT_INDEX_NOT_USED,
/*  0xd8  */	PENT_INDEX_NOT_USED,
/*  0xd9  */	PENT_INDEX_NOT_USED,
/*  0xda  */	PENT_INDEX_NOT_USED,
/*  0xdb  */	PENT_INDEX_NOT_USED,
/*  0xdc  */	PENT_INDEX_NOT_USED,
/*  0xdd  */	PENT_INDEX_NOT_USED,
/*  0xde  */	PENT_INDEX_NOT_USED,
/*  0xdf  */	PENT_INDEX_NOT_USED,
/*  0xe0  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBranchesDecoded),
/*  0xe1  */	PENT_INDEX_NOT_USED,
/*  0xe2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBTBMisses),
/*  0xe3  */	PENT_INDEX_NOT_USED,
/*  0xe4  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBogusBranches),
/*  0xe5  */	PENT_INDEX_NOT_USED,
/*  0xe6  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBACLEARSAsserted),
/*  0xe7  */	PENT_INDEX_NOT_USED,
/*  0xe8  */	PENT_INDEX_NOT_USED,
/*  0xe9  */	PENT_INDEX_NOT_USED,
/*  0xea  */	PENT_INDEX_NOT_USED,
/*  0xeb  */	PENT_INDEX_NOT_USED,
/*  0xec  */	PENT_INDEX_NOT_USED,
/*  0xed  */	PENT_INDEX_NOT_USED,
/*  0xee  */	PENT_INDEX_NOT_USED,
/*  0xef  */	PENT_INDEX_NOT_USED,
/*  0xf0  */	PENT_INDEX_NOT_USED,
/*  0xf1  */	PENT_INDEX_NOT_USED,
/*  0xf2  */	PENT_INDEX_NOT_USED,
/*  0xf3  */	PENT_INDEX_NOT_USED,
/*  0xf4  */	PENT_INDEX_NOT_USED,
/*  0xf5  */	PENT_INDEX_NOT_USED,
/*  0xf6  */	PENT_INDEX_NOT_USED,
/*  0xf7  */	PENT_INDEX_NOT_USED,
/*  0xf8  */	PENT_INDEX_NOT_USED,
/*  0xf9  */	PENT_INDEX_NOT_USED,
/*  0xfa  */	PENT_INDEX_NOT_USED,
/*  0xfb  */	PENT_INDEX_NOT_USED,
/*  0xfc  */	PENT_INDEX_NOT_USED,
/*  0xfd  */	PENT_INDEX_NOT_USED,
/*  0xfe  */	PENT_INDEX_NOT_USED,
/*  0xff  */	PENT_INDEX_NOT_USED
};

// define number of direct counters
DWORD    P6IndexMax = sizeof(P6IndexToData) / sizeof(P6IndexToData[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
        common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92

Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "p5ctrmsg.h"     // error message definition
#include "p5msg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    WCHAR *pName;

    //
    //  Include trailing null in name size
    //

    NameLength = Name->Length;
    if ( !NameLength ||
         Name->Buffer[(NameLength/sizeof(WCHAR))-1] != UNICODE_NULL ) {
        NameLength += sizeof(WCHAR);
    }

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    pName = (PWCHAR)&pBuffer[1];
    RtlMoveMemory(pName,Name->Buffer,Name->Length);

    //  Always null terminated.  Space for this reserved above.

    pName[(NameLength/sizeof(WCHAR))-1] = UNICODE_NULL;

    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\dll\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// This routine builds part of a
// performance data instance (PERF_INSTANCE_DEFINITION) as described in
// winperf.h
//

HANDLE MonOpenEventLog ();

VOID MonCloseEventLog ();

DWORD GetQueryType (IN LPWSTR);

BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL MonBuildInstanceDefinition(PERF_INSTANCE_DEFINITION *, PVOID, DWORD,
                                DWORD, DWORD, PUNICODE_STRING);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\driver\i386\p5.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    p5.c

Abstract:

    Counted events for P5 processor

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "ntddk.h"
#include "..\..\pstat.h"
#include "stat.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

  char  dsc5_0x00[] = "Data Memory Reads.";
  char  dsc5_0x01[] = "Data Memory Write.";
  char  dsc5_0x02[] = "Data TLB Misses.";
  char  dsc5_0x03[] = "Data Read Misses.";
  char  dsc5_0x04[] = "Data Write Misses.";
  char  dsc5_0x05[] = "Write (Hit) to M# or E#.";
  char  dsc5_0x06[] = "Data Cache Line Write Back.";
  char  dsc5_0x07[] = "External Snoops.";
  char  dsc5_0x08[] = "Data Cache Snoop Hits.";
  char  dsc5_0x09[] = "Memory Access In Both Pipes.";
  char  dsc5_0x0A[] = "Actual Bank Conflicts.";
  char  dsc5_0x0B[] = "Misaligned Data References.";
  char  dsc5_0x0C[] = "Code Read (Cache Fetches).";
  char  dsc5_0x0D[] = "Code TLB Misses.";
  char  dsc5_0x0E[] = "Code Cache Misses.";
  char  dsc5_0x0F[] = "Segment Register Loads.";
  char  dsc5_0x12[] = "Total Branches.";
  char  dsc5_0x13[] = "BTB Hits (Actually Exec'd).";
  char  dsc5_0x14[] = "Taken Branch or BTB Hits.";
  char  dsc5_0x15[] = "Pipeline Flushes.";
  char  dsc5_0x16[] = "Instructions Executed.";
  char  dsc5_0x17[] = "Instruction Exec'd in V-Pipe.";
  char  dsc5_0x18[] = "Bus Utilization.";
  char  dsc5_0x19[] = "Write Buffers Full- Pipe Stalled.";
  char  dsc5_0x1A[] = "Wait Mem Read - Pipe Stalled.";
  char  dsc5_0x1B[] = "Stalled Due To Write To M/E#.";
  char  dsc5_0x1C[] = "Locked Bus Cycles.";
  char  dsc5_0x1D[] = "I/O Read or Write Cycles.";
  char  dsc5_0x1E[] = "Non-Cachable Memory Refs.";
  char  dsc5_0x1F[] = "Pipe Stalled Due To AGI.";
  char  dsc5_0x22[] = "Floating-Point Operations.";
  char  dsc5_0x23[] = "Breakpoint on DR0.";
  char  dsc5_0x24[] = "Breakpoint on DR1.";
  char  dsc5_0x25[] = "Breakpoint on DR2.";
  char  dsc5_0x26[] = "Breakpoint on DR3.";
  char  dsc5_0x27[] = "Hardware Interrupts Taken.";
  char  dsc5_0x28[] = "Data Read or Data Writes.";
  char  dsc5_0x29[] = "Data Read/Write Misses.";

COUNTED_EVENTS P5Events[] = {
    0x00,   "rdata",        0, "Data Read",               "DMEMR",    dsc5_0x00,
    0x01,   "wdata",        0, "Data Write",              "DMEMW",    dsc5_0x01,
    0x02,   "dtlbmiss",     0, "Data TLB miss",           "DTLBM",    dsc5_0x02,
    0x03,   "rdmiss",       0, "Data Read miss",          "DCACHERM", dsc5_0x03,
    0x04,   "wdmiss",       0, "Data Write miss",         "DCACHEWM", dsc5_0x04,
    0x05,   "meline",       0, "Write hit to M/E line",   "DCACHEWH", dsc5_0x05,
    0x06,   "dwb",          0, "Data cache line WB",      "DCACHEWB", dsc5_0x06,
    0x07,   "dsnoop",       0, "Data cache snoops",       "EXTSNOOP", dsc5_0x07,
    0x08,   "dsnoophit",    0, "Data cache snoop hits",   "DCACHESH", dsc5_0x08,
    0x09,   "mempipe",      0, "Memory accesses in pipes","DUALMEMA", dsc5_0x09,
    0x0a,   "bankconf",     0, "Bank conflicts",          "BANKCONF", dsc5_0x0A,
    0x0b,   "misalign",     0, "Misadligned data ref",    "UNALIGN",  dsc5_0x0B,
    0x0c,   "iread",        0, "Code Read",               "ICACHER",  dsc5_0x0C,
    0x0d,   "itldmiss",     0, "Code TLB miss",           "ITLBM",    dsc5_0x0D,
    0x0e,   "imiss",        0, "Code cache miss",         "ICACHERM", dsc5_0x0E,
    0x0f,   "segloads",     0, "Segment loads",           "SEGLOAD",  dsc5_0x0F,
    0x12,   "branch",       0, "Branches",                "BRANCHES", dsc5_0x12,
    0x13,   "btbhit",       0, "BTB hits",                "BTBHITS",  dsc5_0x13,
    0x14,   "takenbranck",  0, "Taken branch or BTB hits","TAKENBR",  dsc5_0x14,
    0x15,   "pipeflush",    0, "Pipeline flushes",        "FLUSHES",  dsc5_0x15,
    0x16,   "iexec",        0, "Instructions executed",   "INST",     dsc5_0x16,
    0x17,   "iexecv",       0, "Instructions executed in vpipe", "INSTV", dsc5_0x17,
    0x18,   "busutil",      0, "Bus utilization (clks)",  "BUS",      dsc5_0x18,
    0x19,   "wpipestall",   0, "Pipe stalled on writes (clks)", "WBSTALL", dsc5_0x19,
    0x1a,   "rpipestall",   0, "Pipe stalled on read (clks)", "MEMRSTALL", dsc5_0x1A,
    0x1b,   "stallEWBE",    0, "Stalled while EWBE#",    "MEMWSTALL", dsc5_0x1B,
    0x1c,   "lock",         0, "Locked bus cycle",       "LOCKBUS",   dsc5_0x1C,
    0x1d,   "io",           0, "IO r/w cycle",           "IORW",      dsc5_0x1D,
    0x1e,   "noncachemem",  0, "non-cached memory ref",  "NONCACHE",  dsc5_0x1E,
    0x1f,   "agi",          0, "Pipe stalled on addr gen (clks)", "AGISTALL", dsc5_0x1F,
    0x22,   "flops",        0, "FLOPs",                  "FLOPS",     dsc5_0x22,
    0x23,   "dr0",          0, "Debug Register 0",       "BRKDR0",    dsc5_0x23,
    0x24,   "dr1",          0, "Debug Register 1",       "BRKDR1",    dsc5_0x24,
    0x25,   "dr2",          0, "Debug Register 2",       "BRKDR2",    dsc5_0x25,
    0x26,   "dr3",          0, "Debug Register 3",       "BRKDR3",    dsc5_0x26,
    0x27,   "int",          0, "Interrupts",             "HINTS",     dsc5_0x27,
    0x28,   "rwdata",       0, "Data R/W",               "DMEMRW",    dsc5_0x28,
    0x29,   "rwdatamiss",   0, "Data R/W miss",          "MEMRWM",    dsc5_0x29,
    0x00,   NULL,           0, NULL,                     NULL,        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\driver\i386\pstat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    stat.c

Abstract:

    Pentium stat driver.

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#define _NTDDK_
#include "ntos.h"      // *** USES INTERNAL DEFINES ***
#include "..\..\pstat.h"
#include "stat.h"
#include "zwapi.h"



typedef
VOID
(*pHalProfileInterrupt) (
     KPROFILE_SOURCE ProfileSource
     );

//
// Global data (not in device extension)
//

//
// stats
//
PACCUMULATORS   StatProcessorAccumulators[MAXIMUM_PROCESSORS];
ACCUMULATORS    StatGlobalAccumulators   [MAXIMUM_PROCESSORS];
PKPCR           KiProcessorControlRegister [MAXIMUM_PROCESSORS];

//
// hooked thunks
//
ULONG           KeUpdateSystemTimeThunk;
ULONG           KeUpdateRunTimeThunk;
pHalProfileInterrupt        HaldStartProfileInterrupt;
pHalProfileInterrupt        HaldStopProfileInterrupt;
pHalQuerySystemInformation  HaldQuerySystemInformation;
pHalSetSystemInformation    HaldSetSystemInformation;


//
// hardware control
//
ULONG           NoCESR;
ULONG           MsrCESR;
ULONG           MsrCount;
#define MsrTSC  0x10
#define NoCount 2
ULONG           CESR[MAX_EVENTS];
ULONG           EventID[MAX_EVENTS];

FAST_MUTEX      HookLock;
ULONG           StatMaxThunkCounter;
LIST_ENTRY      HookedThunkList;
LIST_ENTRY      LazyFreeList;

ULONG           LazyFreeCountdown;
KTIMER          LazyFreeTimer;
KDPC            LazyFreeDpc;
WORK_QUEUE_ITEM LazyFreePoolWorkItem;

extern COUNTED_EVENTS P5Events[];
extern COUNTED_EVENTS P6Events[];
ULONG           MaxEvent;
PCOUNTED_EVENTS Events;

ULONG           ProcType;
#define GENERIC_X86     0
#define INTEL_P5        1
#define INTEL_P6        2

//
// Profile support
//

#define PROFILE_SOURCE_BASE     0x1000

typedef struct {
    ULONG               CESR;
    KPROFILE_SOURCE     Source;
    ULONGLONG           InitialCount;
} PROFILE_EVENT, *PPROFILE_EVENT;

BOOLEAN         DisableRDPMC;
BOOLEAN         ProfileSupported;
PPROFILE_EVENT  ProfileEvents, CurrentProfileEvent;

ULONGLONG   FASTCALL RDMSR(ULONG);
VOID        WRMSR(ULONG, ULONGLONG);
VOID        StatSystemTimeHook(VOID);
VOID        StatRunTimeHook(VOID);
VOID        SystemTimeHook(VOID);
VOID        RunTimeHook(VOID);
PKPCR       CurrentPcr(VOID);
ULONG       GetCR4(VOID);
VOID        SetCR4(ULONG);


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
StatDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
StatQueryEvents (
    ULONG       Index,
    PEVENTID    Buffer,
    ULONG       Length
    );

NTSTATUS
StatQueryEventsInfo (
    PEVENTS_INFO  Buffer,
    ULONG         Length
    );

NTSTATUS
StatHookGenericThunk (
    IN PHOOKTHUNK Buffer
    );

VOID
StatRemoveGenericHook (
    IN PULONG   pTracerId
);

NTSTATUS
StatOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
StatClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
StatHookTimer (VOID);

VOID StatReadStats (PULONG Buffer);
VOID StatSetCESR (PSETEVENT);
ULONG StatGetP5CESR (PSETEVENT);
ULONG StatGetP6CESR (PSETEVENT, BOOLEAN);
VOID RemoveAllHookedThunks (VOID);
VOID FASTCALL TimerHook (ULONG p);
VOID FASTCALL TimerHook (ULONG p);
VOID SetMaxThunkCounter (VOID);
VOID RemoveAllHookedThunks (VOID);
VOID LazyFreePoolDPC (PKDPC, PVOID, PVOID, PVOID);
VOID LazyFreePool (PVOID);


VOID
StatEnableRDPMC(
    );

PPROFILE_EVENT
StatProfileEvent (
    KPROFILE_SOURCE     Source
    );

VOID
StatStartProfileInterrupt (
    KPROFILE_SOURCE     Source
    );

VOID
StatStopProfileInterrupt (
    KPROFILE_SOURCE     Source
    );

NTSTATUS
FASTCALL
StatProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    );

NTSTATUS
StatQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    );

NTSTATUS
StatSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

VOID
CreateHook (
    IN  PVOID   HookCode,
    IN  PVOID   HookAddress,
    IN  ULONG   HitCounters,
    IN  ULONG   HookType
);

NTSTATUS
openfile (
    IN PHANDLE  FileHandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
);

VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
);

ULONG
ImportThunkAddress (
    IN  PUCHAR      SourceModule,
    IN  ULONG_PTR   ImageBase,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName,
    IN  PVOID       ModuleList
    );

ULONG
ImportThunkAddressModule (
    IN  PRTL_PROCESS_MODULE_INFORMATION  SourceModule,
    IN  PUCHAR  ImportModule,
    IN  PUCHAR  ThunkName
    );

ULONG
ImportThunkAddressProcessFile(
    IN  ULONG_PTR   ImageBase,
    IN  HANDLE      FileHandle,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName
    );

ULONG_PTR
LookupImageBase (
    IN  PUCHAR  SourceModule,
    IN  PVOID   ModuleList
    );

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
    );

#if 0
PRTL_PROCESS_MODULE_INFORMATION
GetModuleInformationFuzzy(
    IN  PUCHAR                  StartsWith,
    IN  PUCHAR                  EndsWith,
    IN  PRTL_PROCESS_MODULES    Modules
    );
#endif

PVOID
GetLoadedModuleList(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,StatHookTimer)
#pragma alloc_text(PAGE,StatDeviceControl)
#pragma alloc_text(PAGE,StatOpen)
#pragma alloc_text(PAGE,StatClose)
#pragma alloc_text(PAGE,StatReadStats)
#pragma alloc_text(PAGE,StatSetCESR)
#pragma alloc_text(PAGE,StatGetP5CESR)
#pragma alloc_text(PAGE,StatGetP6CESR)
#pragma alloc_text(PAGE,StatDeviceControl)
#pragma alloc_text(PAGE,StatQueryEvents)
#pragma alloc_text(PAGE,ImportThunkAddress)
#pragma alloc_text(PAGE,ImportThunkAddressModule)
#pragma alloc_text(PAGE,ImportThunkAddressProcessFile)
#pragma alloc_text(PAGE,StatHookGenericThunk)
#pragma alloc_text(PAGE,StatRemoveGenericHook)
#pragma alloc_text(PAGE,SetMaxThunkCounter)
#pragma alloc_text(PAGE,LazyFreePool)
#pragma alloc_text(PAGE,StatQuerySystemInformation)
#pragma alloc_text(PAGE,StatSetSystemInformation)
#pragma alloc_text(PAGE,openfile)
#pragma alloc_text(PAGE,readfile)
#pragma alloc_text(PAGE,LookupImageBase)
#pragma alloc_text(PAGE,ConvertImportAddress)
#pragma alloc_text(PAGE,StatEnableRDPMC)
#pragma alloc_text(PAGE,GetLoadedModuleList)
#endif


VOID
StatEnableRDPMC()
{
    ULONG Cr4;
    PKPRCB Prcb;

    Prcb = CurrentPcr()->Prcb;
    if (strcmp(Prcb->VendorString, "GenuineIntel") == 0) {

        //
        // Profiling only supported on family 6 or above.
        //

        if (Prcb->CpuType < 6) {
            DisableRDPMC = TRUE;
            return;
        }

        //
        // Check for busted parts.   Anything below stepping 6,1,9
        // is subject to errata 26 which says RDPMC cannot be used
        // with SMM.   As we have know way of knowing if SMM is in
        // use (but it probably is), we must disable on those chips.
        //

        if ((Prcb->CpuType == 6) &&
            (Prcb->CpuStep < 0x0109)) {
            DisableRDPMC = TRUE;
            return;
        }

        //
        // This processor is believed to be able to handle RDPMC
        // from user mode.  Enable it by setting CR4.PCE (bit 8).
        //

        Cr4 = GetCR4();

        Cr4 |= 0x100;

        SetCR4(Cr4);
    }
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the stat driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    ULONG i;

    KdPrint(( "STAT: DriverEntry()\n" ));

    //
    // Create non-exclusive device object for beep device.
    //

    RtlInitUnicodeString(&unicodeString, L"\\Device\\PStat");

    status = IoCreateDevice(
                DriverObject,
                0,
                &unicodeString,
                FILE_DEVICE_UNKNOWN,    // DeviceType
                0,
                FALSE,
                &deviceObject
                );

    if (status != STATUS_SUCCESS) {
        KdPrint(( "Stat - DriverEntry: unable to create device object: %X\n", status ));
        return(status);
    }

    deviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = StatOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = StatClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = StatDeviceControl;

    //
    // Initialize globals
    //

    for (i = 0; i < MAXIMUM_PROCESSORS; i++) {
        StatProcessorAccumulators[i] =
            &StatGlobalAccumulators[i];
    }
    ExInitializeFastMutex (&HookLock);
    KeInitializeDpc (&LazyFreeDpc, LazyFreePoolDPC, 0);
    ExInitializeWorkItem (&LazyFreePoolWorkItem, LazyFreePool, NULL)
    KeInitializeTimer (&LazyFreeTimer);

    if (strcmp (CurrentPcr()->Prcb->VendorString, "GenuineIntel") == 0) {
        switch (CurrentPcr()->Prcb->CpuType) {
            case 5:
                NoCESR    = 1;
                MsrCESR   = 0x11;
                MsrCount  = 0x12;
                Events    = P5Events;
                ProcType  = INTEL_P5;
                ProfileSupported = FALSE;
                DisableRDPMC = TRUE;
                break;

            case 6:
                NoCESR    = 2;
                MsrCESR   = 0x186;
                MsrCount  = 0xc1;
                Events    = P6Events;
                ProcType  = INTEL_P6;
                ProfileSupported = TRUE;
                DisableRDPMC = FALSE;
                break;

        }
    }

    if (Events) {
        while (Events[MaxEvent].Description) {
            MaxEvent += 1;
        }
    }

    if (ProfileSupported) {
        i = (ULONG) StatProfileInterrupt;
        status = HalSetSystemInformation (
                    HalProfileSourceInterruptHandler,
                    sizeof (i),
                    &i
                    );

        if (!NT_SUCCESS(status)) {
            // hal did not support hooking the performance interrupt
            ProfileSupported = FALSE;
        }
    }

    if (ProfileSupported) {
        //
        // Allocate ProfileEvents
        //

        ProfileEvents = ExAllocatePool (NonPagedPool, sizeof (PROFILE_EVENT) * MaxEvent);

        if (!ProfileEvents) {

            ProfileSupported = FALSE;

        } else {

            RtlZeroMemory (ProfileEvents, sizeof (PROFILE_EVENT) * MaxEvent);

        }
    }


    if (!StatHookTimer()) {
        IoDeleteDevice(DriverObject->DeviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    InitializeListHead (&HookedThunkList);
    InitializeListHead (&LazyFreeList);

    return(STATUS_SUCCESS);
}

NTSTATUS
StatDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG   BufferLength;
    PULONG  Buffer;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    status = STATUS_SUCCESS;
    try {

        Buffer = (PULONG) irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        BufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

            case PSTAT_READ_STATS:
                //
                // read stats
                //
                StatReadStats (Buffer);
                break;


            case PSTAT_SET_CESR:
                //
                // Set MSRs to collect stats
                //
                StatSetCESR ((PSETEVENT) Buffer);
                break;

            case PSTAT_HOOK_THUNK:
                //
                // Hook an import entry point
                //
                status = StatHookGenericThunk ((PHOOKTHUNK) Buffer);
                break;

            case PSTAT_REMOVE_HOOK:
                //
                // Remove a hook from an entry point
                //
                StatRemoveGenericHook (Buffer);
                break;

            case PSTAT_QUERY_EVENTS:
                //
                // Query possible stats which can be collected
                //
                status = StatQueryEvents (*Buffer, (PEVENTID) Buffer, BufferLength);
                break;

            case PSTAT_QUERY_EVENTS_INFO:
                //
                // Query events info
                //
                status = StatQueryEventsInfo( (PEVENTS_INFO) Buffer, BufferLength );
                break;

            default:
                status = STATUS_INVALID_PARAMETER;
                break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }


    //
    // Request is done...
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(status);
}

NTSTATUS
StatOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}


NTSTATUS
StatClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    RemoveAllHookedThunks ();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}

#if 0
VOID
StatUnload (
    IN PDRIVER_OBJECT DriverObject
    )

{
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    RemoveAllHookedThunks ();
    KeCancelTimer (&LazyFreeTimer);
    LazyFreePool (NULL);

    //
    // Restore hooked addresses
    //
    *((PULONG) HalThunkForKeUpdateSystemTime) = KeUpdateSystemTimeThunk;
    if (HalThunkForKeUpdateRunTime) {
        *((PULONG) HalThunkForKeUpdateRunTime)    = KeUpdateRunTimeThunk;
    }


    //
    // Delete the device object.
    //
    IoDeleteDevice(DriverObject->DeviceObject);
    return;
}
#endif


VOID
StatReadStats (PULONG Buffer)
{
    PACCUMULATORS   Accum;
    ULONG           i, r1;
    pPSTATS         Inf;
    PKPCR           Pcr;

    PAGED_CODE();

    Buffer[0] = sizeof (PSTATS);
    Inf = (pPSTATS)(Buffer + 1);

    for (i = 0; i < MAXIMUM_PROCESSORS; i++, Inf++) {
        Pcr = KiProcessorControlRegister[i];
        if (Pcr == NULL) {
            continue;
        }

        Accum = StatProcessorAccumulators[i];

        do {
            r1 = Accum->CountStart;
            Inf->TSC = Accum->TSC;

            for (i=0; i < MAX_EVENTS; i++) {
                Inf->Counters[i] = Accum->Counters[i];
                Inf->EventId[i]  = EventID[i];
            }

            Inf->SpinLockAcquires   = Pcr->KernelReserved[0];
            Inf->SpinLockCollisions = Pcr->KernelReserved[1];
            Inf->SpinLockSpins      = Pcr->KernelReserved[2];
            Inf->Irqls              = Pcr->KernelReserved[3];

        } while (r1 != Accum->CountEnd);

        RtlMoveMemory (Inf->ThunkCounters, (CONST VOID *)(Accum->ThunkCounters),
            StatMaxThunkCounter * sizeof (ULONG));

    }
}

NTSTATUS
StatQueryEvents (
    ULONG       Index,
    PEVENTID    Buffer,
    ULONG       Length
    )
{
    ULONG   i;


    if (Index >= MaxEvent) {
        return STATUS_NO_MORE_ENTRIES;
    }

    i = sizeof (EVENTID) +
        strlen(Events[Index].Token) + 1 +
        strlen(Events[Index].Description) + 1;

    if (Length < i) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    memset (Buffer, 0, i);
    Buffer->EventId = Events[Index].Encoding;
    Buffer->DescriptionOffset = strlen (Events[Index].Token) + 1;
    Buffer->SuggestedIntervalBase = Events[Index].SuggestedIntervalBase;
    strcpy (Buffer->Buffer, Events[Index].Token);
    strcpy (Buffer->Buffer + Buffer->DescriptionOffset, Events[Index].Description);

    if (ProfileSupported) {
        Buffer->ProfileSource = PROFILE_SOURCE_BASE + Index;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
StatQueryEventsInfo (
    PEVENTS_INFO   Buffer,
    ULONG          Length
    )
{
    size_t maxLenToken, maxLenOfficialToken;
    size_t maxLenDescription, maxLenOfficialDescription;

PAGED_CODE();

    if ( Length < sizeof(*Buffer) ) {
        return STATUS_INVALID_PARAMETER;
    }
    
    maxLenToken = maxLenOfficialToken = 0;
    maxLenDescription = maxLenOfficialDescription = 0;
    if ( MaxEvent ) {
        ULONG i;
        size_t len;
        for ( i = 0; i < MaxEvent; i++ ) {
            len = ( Events[i].Token ) ? strlen( Events[i].Token ) : 0;
            if ( len > maxLenToken ) {
                maxLenToken = len;
            }
            len = ( Events[i].OfficialToken ) ? strlen( Events[i].OfficialToken ) : 0;
            if ( len > maxLenToken ) {
                maxLenOfficialToken = len;
            }
            len = ( Events[i].Description ) ? strlen( Events[i].Description ) : 0;
            if ( len > maxLenDescription ) {
                maxLenDescription = len;
            }
            len = ( Events[i].OfficialDescription ) ? strlen( Events[i].OfficialDescription ) : 0;
            if ( len > maxLenOfficialDescription ) {
                maxLenOfficialDescription = len;
            }
        }
    }

    Buffer->Events = MaxEvent;
    Buffer->TokenMaxLength = maxLenToken;
    Buffer->DescriptionMaxLength = maxLenDescription;
    Buffer->OfficialTokenMaxLength = maxLenOfficialToken;
    Buffer->OfficialDescriptionMaxLength = maxLenOfficialDescription;

    return STATUS_SUCCESS;

} // StatQueryEventsInfo()


ULONG
StatGetP5CESR (
    PSETEVENT   NewEvent
    )
{
    ULONG   NewCESR;

    if (!NewEvent->Active) {
        return 0;
    }

    NewCESR  = NewEvent->EventId & 0x3f;
    NewCESR |= NewEvent->UserMode ? 0x80 : 0;
    NewCESR |= NewEvent->KernelMode ? 0x40 : 0;
    return NewCESR;
}

ULONG
StatGetP6CESR (
    PSETEVENT   NewEvent,
    BOOLEAN     Profile
    )
{
    ULONG   NewCESR;

    NewCESR  = NewEvent->EventId & 0xffff;
    NewCESR |= NewEvent->Active ? (1 << 22) : 0;
    NewCESR |= NewEvent->UserMode ? (1 << 16) : 0;
    NewCESR |= NewEvent->KernelMode ? (1 << 17) : 0;
    NewCESR |= NewEvent->EdgeDetect ? (1 << 18) : 0;
    NewCESR |= Profile ? (1 << 20) : 0;
    return NewCESR;
}


VOID
StatSetCESR (
    PSETEVENT       NewEvent
    )
{
    ULONG   i, j, NoProc;
    ULONG   NewCESR[MAX_EVENTS];

    PAGED_CODE();

    switch (ProcType) {
        case INTEL_P5:
            NewCESR[0]  = StatGetP5CESR(NewEvent+0);
            NewCESR[0] |= StatGetP5CESR(NewEvent+1) << 16;
            break;

        case INTEL_P6:
            NewCESR[0] = StatGetP6CESR(NewEvent+0, FALSE);
            NewCESR[1] = StatGetP6CESR(NewEvent+1, FALSE);
            break;
    }

    //
    // Check if CESR changed
    //

    for (i=0; i < NoCESR; i++) {
        if (NewCESR[i] != CESR[i]) {
            break;
        }
    }

    if (i == NoCESR) {
        // no change, all done
        return;
    }

    //
    // Set new events
    //

    for (i=0; i < MAX_EVENTS; i++) {
        EventID[i] = NewEvent[i].EventId;
    }

    //
    // Set new CESR values
    //

    for (i=0; i < NoCESR; i++) {
        CESR[i] = NewCESR[i];
    }

    //
    // Clear each processors Pcr pointer so they will reset.
    // Also count how many processors there are.
    //

    for (i = 0, NoProc = 0; i < MAXIMUM_PROCESSORS; i++) {
        if (KiProcessorControlRegister[i]) {
            KiProcessorControlRegister[i] = NULL;
            NoProc++;
        }
    }

    //
    // wait for each processor to get the new Pcr value
    //

    do {
        //Sleep (0);      // yield
        j = 0;
        for (i = 0; i < MAXIMUM_PROCESSORS; i++) {
            if (KiProcessorControlRegister[i]) {
                j++;
            }
        }
    } while (j < NoProc);
}


VOID
FASTCALL
StatTimerHook (
    IN ULONG processor
)
{
    PACCUMULATORS  Total;
    ULONG          i;


    if (KiProcessorControlRegister[processor] == NULL) {
        for (i=0; i < NoCESR; i++) {
            WRMSR (MsrCESR+i, 0);           // clear old CESR
        }

        for (i=0; i < NoCESR; i++) {
            WRMSR (MsrCESR+i, CESR[i]);     // write new CESR
        }

        KiProcessorControlRegister[processor] = CurrentPcr();

        //
        // Enable RDPMC from Rings 1, 2 and 3.
        //

        StatEnableRDPMC();
    }

    Total = StatProcessorAccumulators[ processor ];
    Total->CountStart += 1;

    for (i=0; i < NoCount; i++) {
        Total->Counters[i] = RDMSR(MsrCount+i);
    }

    Total->TSC         = RDMSR(MsrTSC);
    Total->CountEnd   += 1;
}


VOID
FASTCALL
TimerHook (
    IN ULONG processor
)
{

    // for compatibility
	 //
    if (KiProcessorControlRegister[processor] == NULL) {
        KiProcessorControlRegister[processor] = CurrentPcr();
    }
}

PVOID
GetLoadedModuleList(
    VOID
    )
{
    NTSTATUS                        Status;
    ULONG                           BufferSize;
    ULONG                           NeededSize;
    ULONG                           ModuleNumber;
    PRTL_PROCESS_MODULES            Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;

    //
    // 64K should be plenty,... if it isn't we'll come around again.
    //

    BufferSize = 64000;

    while (TRUE) {
        Modules = ExAllocatePool (PagedPool, BufferSize);
        if (!Modules) {
            return NULL;
        }

        //
        // Get system loaded module list.
        //

        Status = ZwQuerySystemInformation (
                        SystemModuleInformation,
                        Modules,
                        BufferSize,
                        &NeededSize
                        );

        if (NeededSize > BufferSize) {

            //
            // Buffer not big enough, try again.
            //

            ExFreePool(Modules);
            BufferSize = NeededSize;
            continue;
        }

        if (!NT_SUCCESS(Status)) {

            //
            // Not good, give up.
            //

            ExFreePool(Modules);
            return NULL;
        }

        //
        // All is good.
        //

        break;
    }

    return Modules;
}


#if 0
PRTL_PROCESS_MODULE_INFORMATION
GetModuleInformationFuzzy(
    IN  PUCHAR                  StartsWith,
    IN  PUCHAR                  EndsWith,
    IN  PRTL_PROCESS_MODULES    Modules
    )

/*++

Routine Description:

    Run Down the loaded module list looking for a module
    whos name begins with StartWith and ends with EndsWith.
    (What's in the middle doesn't matter).  This is useful
    for finding the kernel and the hal which are of the
    form
        nt*.exe     for the kernel
        hal*.dll    for the hal.

Arguments:

    StartsWith  Beginning string match.
    EndsWith    Ending string match.
    ModuleList  List of loaded modules.

Returns:

    Pointer to the loaded module information for the matching
    module or null if no match is found.

--*/

{
    ULONG                           StartLength = 0;
    ULONG                           EndLength = 0;
    ULONG                           ModulesRemaining;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    PUCHAR                          FileName;
    ULONG                           FileNameLength;

    if (StartsWith) {
        StartLength = strlen(StartsWith);
    }

    if (EndsWith) {
        EndLength = strlen(EndsWith);
    }

    if ((!StartsWith) && (!EndsWith)) {

        //
        // In theory we could claim this matches anything,.. in reality
        // the caller doesn't know what they're doing.
        //

        return NULL;
    }

    for (ModulesRemaining = Modules->NumberOfModules, Module = Modules->Modules;
         ModulesRemaining;
         ModulesRemaining--, Module++) {

        FileName = Module->FullPathName + Module->OffsetToFileName;

        //
        // Check start.
        //

        if (StartLength) {
            if (_strnicmp(FileName, StartsWith, StartLength) != 0) {

                //
                // No match.
                //

                continue;
            }
        }

        FileNameLength = strlen(FileName);

        if (FileNameLength < (StartLength + EndLength)) {

            //
            // FileName is too short to contain both strings.
            //

            continue;
        }

        if (!EndLength) {

            //
            // Not checking the end but the start matches, success.
            //

            return Module;
        }

        //
        // Check end.
        //

        if (_stricmp(FileName + FileNameLength - EndLength, EndsWith) == 0) {

            //
            // Tail matches!
            //

            return Module;
        }
    }

    //
    // No match found.
    //

    return NULL;
}
#endif


BOOLEAN
StatHookTimer (VOID)
{
    PULONG                          Address;
    ULONG                           HalThunkForKeUpdateSystemTime;
    ULONG                           HalThunkForKeUpdateRunTime;
    ULONG                           HalThunkForStartProfileInterrupt;
    ULONG                           HalThunkForStopProfileInterrupt;
    PRTL_PROCESS_MODULES            ModuleList;
    PRTL_PROCESS_MODULE_INFORMATION Kernel;
    PRTL_PROCESS_MODULE_INFORMATION Hal;

    ModuleList = GetLoadedModuleList();
    if (!ModuleList) {

        //
        // No loaded module list, we aren't going to make much
        // progress, give up.
        //

        return FALSE;
    }

#if 0
    Kernel = GetModuleInformationFuzzy("nt",  ".exe", ModuleList);
    Hal    = GetModuleInformationFuzzy("hal", ".dll", ModuleList);

    if ((!Kernel) || (!Hal)) {
        ExFreePool(ModuleList);
        return FALSE;
    }

#endif

    //
    // The kernel is always the first entry on the loaded module
    // list, the hal is always the second.  If this ever changes
    // we'll need to come up with another approach.
    //

    if (ModuleList->NumberOfModules < 2) {

        //
        // Something's very wrong with this module list.
        //

        return 0;
    }

    Kernel = ModuleList->Modules;
    Hal    = Kernel + 1;


    HalThunkForKeUpdateSystemTime =
        ImportThunkAddressModule(
                Hal,
                "ntoskrnl.exe",
                "KeUpdateSystemTime"
            );

    //
    // KeUpdateRunTime is not always available.
    //

    HalThunkForKeUpdateRunTime =
        ImportThunkAddressModule(
                Hal,
                "ntoskrnl.exe",
                "KeUpdateRunTime"
            );

    HalThunkForStartProfileInterrupt =
        ImportThunkAddressModule(
                Kernel,
                "hal.dll",
                "HalStartProfileInterrupt"
            );

    HalThunkForStopProfileInterrupt =
        ImportThunkAddressModule(
                Kernel,
                "hal.dll",
                "HalStopProfileInterrupt"
            );

    ExFreePool(ModuleList);

    if (!HalThunkForKeUpdateSystemTime    ||
        !HalThunkForStartProfileInterrupt ||
        !HalThunkForStopProfileInterrupt) {

        //
        // Imports not found.
        //

        return FALSE;
    }

    //
    // Patch in timer hooks, Read current values
    //

    KeUpdateSystemTimeThunk = *((PULONG) HalThunkForKeUpdateSystemTime);

    if (HalThunkForKeUpdateRunTime) {
        KeUpdateRunTimeThunk = *((PULONG) HalThunkForKeUpdateRunTime);
    }

    HaldStartProfileInterrupt = (pHalProfileInterrupt) *((PULONG) HalThunkForStartProfileInterrupt);
    HaldStopProfileInterrupt  = (pHalProfileInterrupt) *((PULONG) HalThunkForStopProfileInterrupt);
    HaldQuerySystemInformation =  HalQuerySystemInformation;
    HaldSetSystemInformation =  HalSetSystemInformation;

    //
    // Set Stat hook functions
    //

    switch (ProcType) {
        case INTEL_P6:
        case INTEL_P5:
            Address  = (PULONG) HalThunkForKeUpdateSystemTime;
            *Address = (ULONG) StatSystemTimeHook;

            if (HalThunkForKeUpdateRunTime) {
                Address  = (PULONG) HalThunkForKeUpdateRunTime;
                *Address = (ULONG)StatRunTimeHook;
            }

            if (ProfileSupported) {
                Address  = (PULONG) HalThunkForStartProfileInterrupt;
                *Address = (ULONG) StatStartProfileInterrupt;

                Address  = (PULONG) HalThunkForStopProfileInterrupt;
                *Address = (ULONG) StatStopProfileInterrupt;

                HalQuerySystemInformation = StatQuerySystemInformation;
                HalSetSystemInformation = StatSetSystemInformation;
            }
            break;

        default:
            Address  = (PULONG) HalThunkForKeUpdateSystemTime;
            *Address = (ULONG)SystemTimeHook;

            if (HalThunkForKeUpdateRunTime) {
                Address  = (PULONG) HalThunkForKeUpdateRunTime;
                *Address = (ULONG)RunTimeHook;
            }
            break;
    }

    return TRUE;

}

PPROFILE_EVENT
StatProfileEvent(
    KPROFILE_SOURCE     Source
    )
{
    ULONG           Index;

    Index = (ULONG) Source;

    if (Index < PROFILE_SOURCE_BASE) {
        return NULL;
    }

    Index -= PROFILE_SOURCE_BASE;
    if (Index > MaxEvent) {
        return NULL;
    }

    return ProfileEvents + Index;
}


VOID
StatStartProfileInterrupt (
    KPROFILE_SOURCE     Source
    )
{
    ULONG           i;
    PPROFILE_EVENT  ProfileEvent;

    //
    // If this isn't a profile source we're supporting, pass it on
    //

    ProfileEvent = StatProfileEvent(Source);
    if (!ProfileEvent) {
        HaldStartProfileInterrupt (Source);
        return;
    }

    if (CurrentPcr()->Number == 0) {

        if (!ProfileEvent->Source) {
            return ;
        }

        CurrentProfileEvent = ProfileEvent;
    }


    //
    // Set the CESR
    //

    WRMSR (MsrCESR, ProfileEvent->CESR);

    //
    // Prime the interval counter
    //

    WRMSR (MsrCount, ProfileEvent->InitialCount);
}

VOID
StatStopProfileInterrupt (
    KPROFILE_SOURCE     Source
    )
{
    ULONG           i;
    PPROFILE_EVENT  ProfileEvent;

    //
    // If this isn't a profile source we're supporting, pass it on
    //

    ProfileEvent = StatProfileEvent(Source);
    if (!ProfileEvent) {
        HaldStopProfileInterrupt (Source);
        return ;
    }


    if (CurrentPcr()->Number == 0) {

        if (ProfileEvent == CurrentProfileEvent) {
            //
            // Stop calling the kernel
            //

            CurrentProfileEvent = NULL;
        }

    }
}

_declspec(naked)
VOID
FASTCALL
NakedCallToKeProfileInterruptWithSource(
    IN PKTRAP_FRAME TrapFrame,
    IN KPROFILE_SOURCE Source
    )
{
    _asm {
        push    ebp     ; Save these as KeProfileInterrupt nukes them
        push    ebx
        push    esi
        push    edi
    }

    KeProfileInterruptWithSource (TrapFrame, Source);

    _asm {
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        ret
    }
}

NTSTATUS
FASTCALL
StatProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    )
{
    ULONG           i;
    ULONG           current;
    PPROFILE_EVENT  ProfileEvent;

    ProfileEvent = CurrentProfileEvent;
    if (ProfileEvent) {
        current = (ULONG) RDMSR(MsrCount);

        //
        // Did this event fire?
        //

        if (current < ProfileEvent->InitialCount) {

            //
            // Notify kernel
            //

            NakedCallToKeProfileInterruptWithSource( TrapFrame, ProfileEvent->Source );

            //
            // Reset trigger counter
            //

            WRMSR (MsrCount, ProfileEvent->InitialCount);

        }

    }

    return STATUS_SUCCESS;
}

NTSTATUS
StatQuerySystemInformation (
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    PHAL_PROFILE_SOURCE_INFORMATION     ProfileSource;
    ULONG                               i;
    PPROFILE_EVENT                      ProfileEvent;

    if (InformationClass == HalProfileSourceInformation) {
        ProfileSource = (PHAL_PROFILE_SOURCE_INFORMATION) Buffer;
        *ReturnedLength = sizeof (HAL_PROFILE_SOURCE_INFORMATION);

        if (BufferSize < sizeof (HAL_PROFILE_SOURCE_INFORMATION)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        ProfileEvent = StatProfileEvent(ProfileSource->Source);
        if (ProfileEvent) {
            ProfileSource->Interval  = 0 - (ULONG) ProfileEvent->InitialCount;
            ProfileSource->Supported = TRUE;
            return STATUS_SUCCESS;
        }
    }

    //
    // Not our QuerySystemInformation request, pass it on
    //

    return  HaldQuerySystemInformation (InformationClass, BufferSize, Buffer, ReturnedLength);
}


NTSTATUS
StatSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    PHAL_PROFILE_SOURCE_INTERVAL    ProfileInterval;
    SETEVENT                        SetEvent;
    PPROFILE_EVENT                  ProfileEvent;


    if (InformationClass == HalProfileSourceInterval) {
        ProfileInterval = (PHAL_PROFILE_SOURCE_INTERVAL) Buffer;
        if (BufferSize < sizeof (HAL_PROFILE_SOURCE_INTERVAL)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        ProfileEvent = StatProfileEvent(ProfileInterval->Source);
        if (ProfileEvent) {

            ProfileEvent->Source = ProfileInterval->Source;
            ProfileEvent->InitialCount = 0;
            ProfileEvent->InitialCount -= (ULONGLONG) ProfileInterval->Interval;

            SetEvent.EventId    = Events[ProfileEvent->Source - PROFILE_SOURCE_BASE].Encoding;
            SetEvent.Active     = TRUE;
            SetEvent.UserMode   = TRUE;
            SetEvent.KernelMode = TRUE;

            switch (ProcType) {
                case INTEL_P6:
                    ProfileEvent->CESR = StatGetP6CESR (&SetEvent, TRUE);
                    break;
            }

            return STATUS_SUCCESS;
        }
    }

    //
    // Not our SetSystemInforamtion request, pass it on
    //

    return HaldSetSystemInformation (InformationClass, BufferSize, Buffer);
}


NTSTATUS
StatHookGenericThunk (
    IN PHOOKTHUNK   ThunkToHook
)
{
    ULONG           HookAddress;
    ULONG           i, TracerId;
    UCHAR           sourcename[50];
    ULONG           HitCounterOffset;
    PLIST_ENTRY     Link;
    PHOOKEDTHUNK    HookRecord;
    UCHAR           IdInUse[MAX_THUNK_COUNTERS];

    PAGED_CODE();

    i = strlen (ThunkToHook->SourceModule);
    if (i >= 50) {
        return STATUS_UNSUCCESSFUL;
    }
    strcpy (sourcename, ThunkToHook->SourceModule);

    HookAddress = ImportThunkAddress (
        sourcename,
        ThunkToHook->ImageBase,
        ThunkToHook->TargetModule,
        ThunkToHook->Function,
        NULL
        );

    if (!HookAddress) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Hook this thunk
    //

    //
    // If counting bucket is not known (also tracerid), then allocate one
    //

    TracerId = ThunkToHook->TracerId;

    ExAcquireFastMutex (&HookLock);
    if (TracerId == 0) {
        RtlZeroMemory (IdInUse, MAX_THUNK_COUNTERS);

        for (Link = HookedThunkList.Flink;
             Link != &HookedThunkList;
             Link = Link->Flink) {

            HookRecord = CONTAINING_RECORD (Link, HOOKEDTHUNK, HookList);
            IdInUse[HookRecord->TracerId-1] = 1;
        }

        while (IdInUse[TracerId]) {
            if (++TracerId >= MAX_THUNK_COUNTERS) {
                goto Abort;
            }
        }

        TracerId += 1;
    }

    if (TracerId >= MAX_THUNK_COUNTERS) {
        goto Abort;
    }

    if (TracerId > StatMaxThunkCounter) {
        StatMaxThunkCounter = TracerId;
    }


    HookRecord = ExAllocatePool (NonPagedPool, sizeof (HOOKEDTHUNK));
    if (!HookRecord) {
        goto Abort;
    }

    HitCounterOffset =
        ((ULONG) &StatGlobalAccumulators[0].ThunkCounters[TracerId-1]
        - (ULONG) StatGlobalAccumulators);

    HookRecord->HookAddress = HookAddress;
    HookRecord->OriginalDispatch = *((PULONG) HookAddress);
    HookRecord->TracerId = TracerId;
    InsertHeadList (&HookedThunkList, &HookRecord->HookList);

    CreateHook (HookRecord->HookCode, (PVOID)HookAddress, HitCounterOffset, 0);
    SetMaxThunkCounter ();

    ExReleaseFastMutex (&HookLock);
    ThunkToHook->TracerId = TracerId;
    return STATUS_SUCCESS;

Abort:
    ExReleaseFastMutex (&HookLock);
    return STATUS_UNSUCCESSFUL;
}

VOID
StatRemoveGenericHook (
    IN PULONG   pTracerId
)
{
    PLIST_ENTRY     Link, NextLink, Temp, NextTemp;
    PHOOKEDTHUNK    HookRecord, AltRecord;
    ULONG           HitCounterOffset;
    LIST_ENTRY      DisabledHooks;
    ULONG           TracerId;
    PULONG          HookAddress;

    PAGED_CODE();

    //
    // Run list of hooks undo-ing any hook which matches this tracerid.
    // Note: that hooks are undone in the reverse order for which they
    // were applied.
    //

    TracerId = *pTracerId;
    InitializeListHead (&DisabledHooks);

    ExAcquireFastMutex (&HookLock);
    Link = HookedThunkList.Flink;
    while (Link != &HookedThunkList) {
        NextLink = Link->Flink;
        HookRecord = CONTAINING_RECORD (Link, HOOKEDTHUNK, HookList);

        if (HookRecord->TracerId == TracerId) {

            //
            // Found a hook with a matching ID
            // Scan for any hooks which need to be temporaly removed
            // in order to get this hook removed
            //

            HookAddress = (PULONG) HookRecord->HookAddress;
            Temp = HookedThunkList.Flink;
            while (Temp != Link) {
                NextTemp = Temp->Flink;
                AltRecord = CONTAINING_RECORD (Temp, HOOKEDTHUNK, HookList);
                if (AltRecord->HookAddress == HookRecord->HookAddress) {
                    RemoveEntryList(&AltRecord->HookList);
                    *HookAddress = AltRecord->OriginalDispatch;
                    InsertTailList (&DisabledHooks, &AltRecord->HookList);
                }

                Temp = NextTemp;
            }

            //
            // Remove this hook
            //

            RemoveEntryList(&HookRecord->HookList);
            HookAddress = (PULONG) HookRecord->HookAddress;
            *HookAddress = HookRecord->OriginalDispatch;
            InsertTailList (&LazyFreeList, &HookRecord->HookList);
        }

        Link = NextLink;
    }

    //
    // Re-hook any hooks which were disabled for the remove operation
    //

    while (DisabledHooks.Flink != &DisabledHooks) {

        HookRecord = CONTAINING_RECORD (DisabledHooks.Flink, HOOKEDTHUNK, HookList);

        AltRecord = ExAllocatePool (NonPagedPool, sizeof (HOOKEDTHUNK));
        if (!AltRecord) {
            goto OutOfMemory;
        }
        RemoveEntryList(&HookRecord->HookList);

        HookAddress = (PULONG) HookRecord->HookAddress;
        AltRecord->HookAddress = HookRecord->HookAddress;
        AltRecord->OriginalDispatch = *HookAddress;
        AltRecord->TracerId = HookRecord->TracerId;
        InsertHeadList (&HookedThunkList, &AltRecord->HookList);

        HitCounterOffset =
            (ULONG) &StatGlobalAccumulators[0].ThunkCounters[AltRecord->TracerId-1]
            - (ULONG) StatGlobalAccumulators;

        CreateHook (AltRecord->HookCode, (PVOID)HookAddress, HitCounterOffset, 0);

        InsertTailList (&LazyFreeList, &HookRecord->HookList);
    }
    SetMaxThunkCounter();
    ExReleaseFastMutex (&HookLock);
    return ;


OutOfMemory:
    while (DisabledHooks.Flink != &DisabledHooks) {
        HookRecord = CONTAINING_RECORD (DisabledHooks.Flink, HOOKEDTHUNK, HookList);
        RemoveEntryList(&HookRecord->HookList);
        InsertTailList (&LazyFreeList, &HookRecord->HookList);
    }
    ExReleaseFastMutex (&HookLock);
    RemoveAllHookedThunks ();
    return ;
}

VOID RemoveAllHookedThunks ()
{
    PHOOKEDTHUNK    HookRecord;
    PULONG          HookAddress;

    PAGED_CODE();

    ExAcquireFastMutex (&HookLock);
    while (!IsListEmpty(&HookedThunkList)) {
        HookRecord = CONTAINING_RECORD (HookedThunkList.Flink, HOOKEDTHUNK, HookList);
        RemoveEntryList(&HookRecord->HookList);
        HookAddress = (PULONG) HookRecord->HookAddress;
        *HookAddress = HookRecord->OriginalDispatch;

        InsertTailList (&LazyFreeList, &HookRecord->HookList);
    }
    SetMaxThunkCounter();
    ExReleaseFastMutex (&HookLock);
}


VOID SetMaxThunkCounter ()
{
    LARGE_INTEGER   duetime;
    PLIST_ENTRY     Link;
    PHOOKEDTHUNK    HookRecord;
    ULONG   Max;


    PAGED_CODE();

    Max = 0;
    for (Link = HookedThunkList.Flink;
         Link != &HookedThunkList;
         Link = Link->Flink) {

        HookRecord = CONTAINING_RECORD (Link, HOOKEDTHUNK, HookList);
        if (HookRecord->TracerId > Max) {
            Max = HookRecord->TracerId;
        }
    }

    StatMaxThunkCounter = Max;
    LazyFreeCountdown = 2;
    duetime.QuadPart = -10000000;
    KeSetTimer (&LazyFreeTimer, duetime, &LazyFreeDpc);
}

VOID LazyFreePoolDPC (PKDPC dpc, PVOID a, PVOID b, PVOID c)
{
    ExQueueWorkItem (&LazyFreePoolWorkItem, DelayedWorkQueue);
}

VOID LazyFreePool (PVOID conext)
{
    PHOOKEDTHUNK    HookRecord;
    LARGE_INTEGER   duetime;

    PAGED_CODE();

    ExAcquireFastMutex (&HookLock);
    if (--LazyFreeCountdown == 0) {
        while (!IsListEmpty(&LazyFreeList)) {
            HookRecord = CONTAINING_RECORD (LazyFreeList.Flink, HOOKEDTHUNK, HookList);
            RemoveEntryList(&HookRecord->HookList);
            RtlFillMemory(HookRecord, sizeof(HOOKEDTHUNK), 0xCC);
            ExFreePool (HookRecord) ;
        }
    } else {
        duetime.QuadPart = -10000000;
        KeSetTimer (&LazyFreeTimer, duetime, &LazyFreeDpc);
    }
    ExReleaseFastMutex (&HookLock);
}

#define IMPKERNELADDRESS(a)  ((ULONG)a + ImageBase)
#define IMPIMAGEADDRESS(a)   ConvertImportAddress((ULONG)a, (ULONG)Pool, &SectionHeader)
#define INITIAL_POOLSIZE       0x7000

ULONG
ImportThunkAddressProcessFile(
    IN  ULONG_PTR   ImageBase,
    IN  HANDLE      FileHandle,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName
    )
{
    ULONG                           i, j;
    ULONG                           Dir;
    PVOID                           Pool;
    ULONG                           PoolSize;
    IMAGE_DOS_HEADER                DosImageHeader;
    IMAGE_NT_HEADERS                NtImageHeader;
    PIMAGE_NT_HEADERS               LoadedNtHeader;
    PIMAGE_IMPORT_BY_NAME           pImportNameData;
    PIMAGE_SECTION_HEADER           pSectionHeader;
    IMAGE_SECTION_HEADER            SectionHeader;
    PIMAGE_IMPORT_DESCRIPTOR        ImpDescriptor;
    PULONG                          pThunkAddr, pThunkData;

    PAGED_CODE();

    try {

        //
        // Find module in loaded module list
        //

        PoolSize = INITIAL_POOLSIZE;
        Pool = ExAllocatePool (PagedPool, PoolSize);

        try {

            //
            // Read in source image's headers
            //

            readfile (
                FileHandle,
                0,
                sizeof (DosImageHeader),
                (PVOID) &DosImageHeader
                );

            if (DosImageHeader.e_magic != IMAGE_DOS_SIGNATURE) {
                return 0;
            }

            readfile (
                FileHandle,
                DosImageHeader.e_lfanew,
                sizeof (NtImageHeader),
                (PVOID) &NtImageHeader
                );

            if (NtImageHeader.Signature != IMAGE_NT_SIGNATURE) {
                return 0;
            }

            if (!ImageBase) {
                ImageBase = NtImageHeader.OptionalHeader.ImageBase;
            }

            //
            // Check in read in copy header against loaded image
            //

            LoadedNtHeader = (PIMAGE_NT_HEADERS) ((ULONG) ImageBase +
                                DosImageHeader.e_lfanew);

            if (LoadedNtHeader->Signature != IMAGE_NT_SIGNATURE ||
                LoadedNtHeader->FileHeader.TimeDateStamp !=
                    NtImageHeader.FileHeader.TimeDateStamp) {
                        return 0;
            }

            //
            // read in complete sections headers from image
            //

            i = NtImageHeader.FileHeader.NumberOfSections
                    * sizeof (IMAGE_SECTION_HEADER);

            j = ((ULONG) IMAGE_FIRST_SECTION (&NtImageHeader)) -
                    ((ULONG) &NtImageHeader) +
                    DosImageHeader.e_lfanew;

            if (i > PoolSize) {
                ExFreePool(Pool);
                PoolSize = i;
                Pool = ExAllocatePool(PagedPool, PoolSize);
            }

            readfile (
                FileHandle,
                j,                  // file offset
                i,                  // length
                Pool
                );


            //
            // Find section with import directory
            //

            Dir = NtImageHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
            i = 0;
            pSectionHeader = Pool;
            for (; ;) {
                if (i >= NtImageHeader.FileHeader.NumberOfSections) {
                    return 0;
                }
                if (pSectionHeader->VirtualAddress <= Dir  &&
                    pSectionHeader->VirtualAddress + pSectionHeader->SizeOfRawData > Dir) {

                    break;
                }
                i += 1;
                pSectionHeader += 1;
            }

            //
            // read in complete import section from image
            //

            Dir -= pSectionHeader->VirtualAddress;
            pSectionHeader->VirtualAddress   += Dir;
            pSectionHeader->PointerToRawData += Dir;
            pSectionHeader->SizeOfRawData    -= Dir;
            SectionHeader = *pSectionHeader;

            if (SectionHeader.SizeOfRawData > PoolSize) {
                ExFreePool (Pool);
                PoolSize = SectionHeader.SizeOfRawData;
                Pool = ExAllocatePool (PagedPool, PoolSize);
            }

            readfile (
                FileHandle,
                SectionHeader.PointerToRawData,
                SectionHeader.SizeOfRawData,
                Pool
                );

            //
            // Find imports from specified module
            //

            ImpDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) Pool;
            while (ImpDescriptor->Characteristics) {
                if (_stricmp((PUCHAR)IMPIMAGEADDRESS((ULONG)(ImpDescriptor->Name)), ImportModule) == 0) {
                    break;
                }
                ImpDescriptor += 1;
            }

            //
            // Find thunk for imported ThunkName
            //
            pThunkData = (PULONG) IMPIMAGEADDRESS  (ImpDescriptor->OriginalFirstThunk);
            pThunkAddr = (PULONG) IMPKERNELADDRESS (ImpDescriptor->FirstThunk);
            for (; ;) {
                if (*pThunkData == 0L) {
                    // end of table
                    break;
                }
                pImportNameData = (PIMAGE_IMPORT_BY_NAME) IMPIMAGEADDRESS (*pThunkData);

                if (_stricmp(pImportNameData->Name, ThunkName) == 0) {

                    //
                    // Success, return this address.
                    //

                    return (ULONG)pThunkAddr;
                }

                // check next thunk
                pThunkData += 1;
                pThunkAddr += 1;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return 0;
        }
    } finally {

        //
        // Clean up
        //

        if (Pool) {
            ExFreePool (Pool);
        }
    }
    return 0;
}

ULONG
ImportThunkAddress (
    IN  PUCHAR      SourceModule,
    IN  ULONG_PTR   ImageBase,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName,
    IN  PVOID       ModuleList
    )
{
    NTSTATUS                        Status;
    HANDLE                          FileHandle;
    ULONG                           ImportAddress;

    PAGED_CODE();

    Status = openfile (&FileHandle, "\\SystemRoot\\", SourceModule);
    if (!NT_SUCCESS(Status)) {
        Status = openfile (&FileHandle, "\\SystemRoot\\System32\\", SourceModule);
    }
    if (!NT_SUCCESS(Status)) {
        Status = openfile (&FileHandle, "\\SystemRoot\\System32\\Drivers\\", SourceModule);
    }
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    if (!ImageBase) {
        ImageBase = LookupImageBase (SourceModule, ModuleList);
    }

    ImportAddress = ImportThunkAddressProcessFile(ImageBase,
                                                  FileHandle,
                                                  ImportModule,
                                                  ThunkName);
    NtClose (FileHandle);
    return ImportAddress;
}

ULONG
ImportThunkAddressModule (
    IN  PRTL_PROCESS_MODULE_INFORMATION  SourceModule,
    IN  PUCHAR  ImportModule,
    IN  PUCHAR  ThunkName
    )
{
    NTSTATUS                        Status;
    HANDLE                          FileHandle;
    ULONG                           ImportAddress;
    PUCHAR                          SubPath;

    PAGED_CODE();

    //
    // Strip the system root from the file path so we can use
    // the \SystemRoot object as the head of the path.
    //

    SubPath = strchr(SourceModule->FullPathName + 1, '\\');
    if (!SubPath) {

        //
        // If we got here we don't know what we're doing,
        // bail out.
        //

        return 0;
    }

    Status = openfile (&FileHandle, "\\SystemRoot", SubPath);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    ImportAddress = ImportThunkAddressProcessFile(
                        (ULONG_PTR)SourceModule->ImageBase,
                        FileHandle,
                        ImportModule,
                        ThunkName);

    NtClose(FileHandle);
    return ImportAddress;
}

ULONG_PTR
LookupImageBase (
    IN  PUCHAR  SourceModule,
    IN  PVOID   ModuleList
    )
{
    NTSTATUS                        status;
    ULONG                           BufferSize;
    ULONG                           junk, ModuleNumber;
    ULONG_PTR                       ImageBase;
    PRTL_PROCESS_MODULES            Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;

    ImageBase = 0;

    if (ModuleList) {
        Modules = ModuleList;
    } else {
        BufferSize = 64000;
        Modules = ExAllocatePool (PagedPool, BufferSize);
        if (!Modules) {
            return 0;
        }

        //
        // Locate system drivers.
        //

        status = ZwQuerySystemInformation (
                        SystemModuleInformation,
                        Modules,
                        BufferSize,
                        &junk
                        );
        if (!NT_SUCCESS(status)) {
            ExFreePool(Modules);
            return 0;
        }
    }

    Module = &Modules->Modules[ 0 ];
    for (ModuleNumber = 0;
         ModuleNumber < Modules->NumberOfModules;
         ModuleNumber++,Module++) {
        if (_stricmp(Module->FullPathName + Module->OffsetToFileName,
                     SourceModule) == 0) {
            ImageBase = (ULONG_PTR)Module->ImageBase;
            break;
        }
    }

    if (!ModuleList) {
        ExFreePool (Modules);
    }
    return ImageBase;
}


NTSTATUS
openfile (
    IN PHANDLE  FileHandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
)
{
    ANSI_STRING    AscBasePath, AscName;
    UNICODE_STRING UniPathName, UniName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       StringBuf[500];

    //
    // Build name
    //
    UniPathName.Buffer = (PWCHAR)StringBuf;
    UniPathName.Length = 0;
    UniPathName.MaximumLength = sizeof( StringBuf );

    RtlInitString(&AscBasePath, BasePath);

    status = RtlAnsiStringToUnicodeString( &UniPathName, &AscBasePath, FALSE );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitString(&AscName, Name);

    status = RtlAnsiStringToUnicodeString( &UniName, &AscName, TRUE );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlAppendUnicodeStringToString (&UniPathName, &UniName);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    InitializeObjectAttributes(
            &ObjA,
            &UniPathName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    //
    // open file
    //

    status = ZwOpenFile (
            FileHandle,                         // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    RtlFreeUnicodeString (&UniName);
    return status;
}

VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
    )
{
    NTSTATUS            status;
    IO_STATUS_BLOCK     iosb;
    LARGE_INTEGER       foffset;


    foffset = RtlConvertUlongToLargeInteger(offset);

    status = ZwReadFile (
        handle,
        NULL,               // event
        NULL,               // apc routine
        NULL,               // apc context
        &iosb,
        buffer,
        len,
        &foffset,
        NULL
        );

    if (!NT_SUCCESS(status)) {
        ExRaiseStatus (1);
    }
}

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
)
{
    ULONG   EffectiveAddress;

    EffectiveAddress = PoolAddress + ImageRelativeAddress -
            SectionHeader->VirtualAddress;

    if (EffectiveAddress < PoolAddress ||
        EffectiveAddress > PoolAddress + SectionHeader->SizeOfRawData) {

        ExRaiseStatus (1);
    }

    return EffectiveAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\driver\i386\misc.asm ===
.586p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        EXTRNP  StatTimerHook,1,,FASTCALL
        EXTRNP  TimerHook,1,,FASTCALL
        extrn   _KeUpdateSystemTimeThunk:DWORD
        extrn   _KeUpdateRunTimeThunk:DWORD
        extrn   _StatProcessorAccumulators:DWORD

_TEXT$00   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME  CS:NOTHING, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc _CurrentPcr, 0
        mov     eax, fs:[PcSelfPcr]
        stdRet  _CurrentPcr
stdENDP _CurrentPcr


cPublicProc _StatSystemTimeHook, 0
        mov     ecx, fs:[PcPrcb]
        push    eax
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall StatTimerHook
        pop     eax
        jmp     dword ptr [_KeUpdateSystemTimeThunk]
stdENDP _StatSystemTimeHook


cPublicProc _StatRunTimeHook, 0
        mov     ecx, fs:[PcPrcb]
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall StatTimerHook
        jmp     dword ptr [_KeUpdateRunTimeThunk]
stdENDP _StatRunTimeHook

cPublicProc _SystemTimeHook, 0
        mov     ecx, fs:[PcPrcb]
        push    eax
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall TimerHook
        pop     eax
        jmp     dword ptr [_KeUpdateSystemTimeThunk]
stdENDP _SystemTimeHook

cPublicProc _RunTimeHook, 0
        mov     ecx, fs:[PcPrcb]
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall TimerHook
        jmp     dword ptr [_KeUpdateRunTimeThunk]
stdENDP _RunTimeHook

cPublicProc _WRMSR,3
        mov     ecx, [esp+4]
        mov     eax, [esp+8]
        mov     edx, [esp+12]

    ; ecx = MSR
    ; edx:eax = value

        db      0fh, 30h
        stdRet  _WRMSR
stdENDP  _WRMSR

cPublicFastCall RDMSR,1
        db      0fh, 32h
        fstRet  RDMSR
fstENDP RDMSR

HookTemplate    proc
        push    eax
        mov     eax, fs:[PcPrcb]
        movzx   eax, byte ptr [eax].PbNumber
        mov     eax, _StatProcessorAccumulators [eax*4]
        db      0ffh, 80h           ; inc dword ptr [eax + tt1]
tt1:    dd      0
        pop     eax
        db      0e9h                ; jmp near tt2
tt2:    dd      ?
HookTemplateEnd: dd  0
HookTemplate    endp


cPublicProc _CreateHook, 4
;
; (ebp+8) = HookCode
; (ebp+12) = HookAddress
; (ebp+16) = HitCounters
; (ebp+20) = Type of hook
;
        push    ebp
        mov     ebp, esp

        push    edi
        push    esi
        push    ebx

        mov     edi, [ebp+8]        ; spot to create hook code into
        mov     esi, offset HookTemplate
        mov     ecx, HookTemplateEnd - HookTemplate
        rep     movsb               ; copy template

        mov     edi, [ebp+8]        ; new hook

        mov     eax, [ebp+16]       ; hit counter offset
        mov     ebx, tt1 - HookTemplate
        mov     [edi+ebx], eax

        mov     eax, [ebp+12]       ; image's thunk
        mov     eax, [eax]          ; original thunk's value
        mov     ebx, tt2 - HookTemplate
        sub     eax, edi            ; adjust address to be relative to eip
        sub     eax, ebx
        sub     eax, 4
        mov     [edi+ebx], eax

        mov     eax, [ebp+12]       ; image's thunk
        mov     [eax], edi          ; patch it to be our hook

        pop     ebx
        pop     esi
        pop     edi
        pop     ebp
        stdRET  _CreateHook
stdENDP _CreateHook


cPublicProc _GetCR4, 0
        mov     eax, cr4
        stdRet  _GetCR4
stdENDP _GetCR4

cPublicProc _SetCR4, 1
        mov     eax, [esp+4]
        mov     cr4, eax
        stdRet  _SetCR4
stdENDP _SetCR4


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\driver\i386\p6.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    p6.c

Abstract:

    Counted events for P6 processor

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "ntddk.h"
#include "..\..\pstat.h"
#include "stat.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
// Official descriptions
//

char    desc_0x03[] = "Number of store buffer blocks.";
char    desc_0x04[] = "Number of store buffer drains cycles.";
char    desc_0x05[] = "Number of misaligned data memory references.";
char    desc_0x06[] = "Number of segment register loads.";
char    desc_0x10[] = "Number of computational floating point operations "
                      "executed.";
char    desc_0x11[] = "Number of floating point exception cases handled by "
                          "microcode.";
char    desc_0x12[] = "Number of multiplies.";
char    desc_0x13[] = "Number of divides.";
char    desc_0x14[] = "Number of cycles the divider is busy.";
char    desc_0x21[] = "Number of L2 address strobes.";
char    desc_0x22[] = "Number of cycles in which the data bus is busy.";
char    desc_0x23[] = "Number of cycles in which the data bus is busy "
                          "transfering data from L2 to the processor.";
char    desc_0x24[] = "Number of lines allocated in the L2.";
char    desc_0x25[] = "Number of modified lines allocated in the L2.";
char    desc_0x26[] = "Number of lines removed from the L2 for any reason.";
char    desc_0x27[] = "Number of Modified lines removed from the L2 for any "
                           "reason.";
char    desc_0x28[] = "Number of L2 instruction fetches.";
char    desc_0x29[] = "Number of L2 data loads.";
char    desc_0x2A[] = "Number of L2 data stores.";
char    desc_0x2E[] = "Total number of L2 requests.";
char    desc_0x43[] = "Total number of all memory references, both cacheable "
                          "and non-cacheable.";
char    desc_0x45[] = "Number of total lines allocated in the DCU.";
char    desc_0x46[] = "Number of M state lines allocated in the DCU.";
char    desc_0x47[] = "Number of M state lines evicted from the DCU.  This "
                          "includes evictions via snoop HITM, intervention "
                          "or replacement.";
char    desc_0x48[] = "Weighted number of cycles while a DCU miss is "
                          "outstanding.";
char    desc_0x60[] = "Number of bus requests outstanding.";
char    desc_0x61[] = "Number of bus clock cycles that this processor is "
                          "driving the BNR pin.";
char    desc_0x62[] = "Number of clocks in which DRDY is asserted.";
char    desc_0x63[] = "Number of clocks in which LOCK is asserted.";
char    desc_0x64[] = "Number of bus clock cycles that this processor is "
                          "receiving data.";
char    desc_0x65[] = "Number of Burst Read transactions.";
char    desc_0x66[] = "Number of Read For Ownership transactions.";
char    desc_0x67[] = "Number of Write Back transactions.";
char    desc_0x68[] = "Number of Instruction Fetch transactions.";
char    desc_0x69[] = "Number of Invalidate transactions.";
char    desc_0x6A[] = "Number of Partial Write transactions.";
char    desc_0x6B[] = "Number of Partial transactions.";
char    desc_0x6C[] = "Number of I/O transations.";
char    desc_0x6D[] = "Number of Deferred transactions.";
char    desc_0x6E[] = "Number of Burst transactions.";
char    desc_0x6F[] = "Number of memory transactions.";
char    desc_0x70[] = "Total number of all transactions.";
char    desc_0x79[] = "Number of cycles for which the processor is not halted.";
char    desc_0x7A[] = "Number of bus clock cycles that this processor is "
                          "driving the HIT pin, including cycles due to "
                          "snoop stalls.";
char    desc_0x7B[] = "Number of bus clock cycles that this processor is "
                          "driving the HITM pin, including cycles due to "
                          "snoop stalls.";
char    desc_0x7E[] = "Number of clock cycles for which the bus is snoop "
                      "stalled.";
char    desc_0x80[] = "Total number of instruction fetches, both cacheable "
                          "and uncacheable.";
char    desc_0x81[] = "Total number of instruction fetch misses.";
char    desc_0x85[] = "Number of ITLB misses.";
char    desc_0x86[] = "The number of cycles that instruction fetch "
                          "pipestage is stalled (includes cache "
                          "misses, ITLB misses, ITLB faults and "
                          "Victem Cache evictions.)";
char    desc_0x87[] = "Number of cycles for which the instruction "
                           "length decoder is stalled.";
char    desc_0xA2[] = "Number of cycles for which there are resource related "
                           "stalls.";
char    desc_0xC0[] = "Number of instructions retired.";
char    desc_0xC1[] = "Number of computational floating point operations "
                          "retired.";
char    desc_0xC2[] = "Number of UOPs retired.";
char    desc_0xC4[] = "Number of branch instructions retired.";
char    desc_0xC5[] = "Number of mispredicted branches retired.";
char    desc_0xC6[] = "Number of processor cycles for which interrupts are "
                          "disabled.";
char    desc_0xC7[] = "Number of processor cycles for which interrupts are "
                          "disabled and interrupts are pending.";
char    desc_0xC8[] = "Number of hardware interrupts received.";
char    desc_0xC9[] = "Number of taken branchs retired.";
char    desc_0xCA[] = "Number of taken mispredicted branchs retired.";
char    desc_0xD0[] = "Number of instructions decoded.";
char    desc_0xD2[] = "Number of cycles or events for partial stalls.";
char    desc_0xE0[] = "Number of branch instructions decoded.";
char    desc_0xE2[] = "Number of branchs that miss the BTB.";
char    desc_0xE4[] = "Number of bogus branches.";
char    desc_0xE6[] = "Number of times BACLEAR is asserted.";

#define RARE     100

// suggested counts are set to be around .1ms

                                  //          1         2         3*        4
COUNTED_EVENTS P6Events[] = {     // 1234567890123456789012345678901234567890

// Memory Ordering

    // LD_BLOCKS - Number of store buffer blocks.
    0x03,   "sbb",            1000, "Store buffer blocks",
            "LD_BLOCKS",            desc_0x03,

    // SB_DRAINS - Number of store buffer drain cycles.
    0x04,   "sbd",            RARE, "Store buffer drain cycles",
            "SB_DRAINS",            desc_0x04,

    // MISALIGN_MEM_REF - Number of misaligned data memory references
    0x05,   "misalign",       1000, "Misadligned data ref",
            "MISALIGN_MEM_REF",     desc_0x05,

// Segment Register Loads

    // SEGMENT_REG_LOADS - Number of segment register loads.
    0x06,   "segloads",      10000, "Segment loads",
            "SEGMENT_REG_LOADS",    desc_0x06,

// Floating Point

    // FP_COMP_OPS_EXE - Number of computatonal floating point operations
    // executed.
    0x10,   "flops",          1000, "FLOPs (computational) executed",
            "FP_COMP_OPS_EXE",      desc_0x10,

    // FP_ASSIST - Number of floating point exception cases handled by
    // microcode.
    0x11,   "eflops",         RARE, "FP exceptions handled by ucode",
            "FP_ASSIST",            desc_0x11,

    // MUL - Number of multiplies.
    0x12,   "mul",            1000, "Multiplies",
            "MUL",                  desc_0x12,

    // DIV - Number of divides.
    0x13,   "div",            1000, "Divides",
            "DIV",                  desc_0x13,

    // CYCLES_DIV_BUSY - Number of cycles the divider is busy.
    0x14,   "divb",          10000, "Divider busy cycles",
            "CYCLES_DIV_BUSY",      desc_0x14,

    // see also 0xC1 below 

// Secondary Cache (L2)

    // L2_ADS - Number of L2 address strobes.
    0x21,   "l2astrobe",      1000, "L2 address stobes",
            "L2_ADS",               desc_0x21,

    // L2_DBUS_BUSY - Number of cycles in which the data bus was busy.
    0x22,   "l2busy",        10000, "L2 data bus busy cycles",
            "L2_DBUS_BUSY",         desc_0x22,

    // L2_DBUS_BUSY_RD - Number of cycles in which the data bus was busy
    // transfering data from L2 to processor.
    0x23,   "l2busyrd",      10000, "L2 data bus to cpu busy cycles",
            "L2_DBUS_BUSY_RD",      desc_0x23,

    // L2_LINES_IN - Number of lines allocated in the L2.
    0x24,   "l2all",          1000, "L2 lines allocated",
            "L2_LINES_IN",          desc_0x24,

    // L2LINEINM - Number of Modified lines allocated in the L2.
    0x25,   "l2m",            1000, "L2 lines M state",
            "L2_M_LINES_IN",        desc_0x25,

    // L2_LINES_OUT - Number of lines removed from the L2 for any reason.
    0x26,   "l2evict",        1000, "L2 lines removed",
            "L2_LINES_OUT",         desc_0x26,

    // L2_M_LINES_OUT - Number of Modified lines removed from the L2 for
    // any reason.
    0x27,   "l2mevict",        100, "L2 lines M state removed",
            "L2_M_LINES_OUT",       desc_0x27,

    // L2_IFETCH - L2 instruction fetches - "MESI" (0Fh)
    0x28,   "l2inst",            0, "L2 instruction fetches",
            "L2_IFETCH",            desc_0x28,

    // L2_LD - L2 data loads - "MESI" (0Fh)
    0x29,   "l2load",            0, "L2 data loads",
            "L2_LD",                desc_0x29,

    // L2_ST - L2 data stores - "MESI" (0Fh)
    0x2a,   "l2store",           0, "L2 data stores",
            "L2_ST",                desc_0x2A,

    // L2_RQSTS - Total Number of L2 Requests - "MESI" (0Fh)
    0x2e,   "l2req",             0, "L2 requests (all)",
            "L2_RQSTS",             desc_0x2E,

// Data Cache Unit (DCU)  

    // DATA_MEM_REFS - Total number of all memory referenced both cacheable
    // and non-cachable
    0x43,   "memref",        10000, "Data memory references",
            "DATA_MEM_REFS",        desc_0x43,

    // DCU_LINES_IN - Number of total lines allocated in the DCU
    0x45,   "dculines",       1000, "DCU lines allocated",
            "DCU_LINES_IN",         desc_0x45,

    // DCU_M_LINES_IN - Number of M state lines allocated in the DCU
    0x46,   "dcumlines",       100, "DCU M state lines allocated",
            "DCU_M_LINES_IN",       desc_0x46,

    // DCU_M_LINES_OUT - Number of M state lines evicted from the DCU.
    // This includes evictions via snoop HITM, intervention or replacement.
    0x47,   "dcumevicted",     100, "DCU M state lines evicted",
            "DCU_M_LINES_OUT",      desc_0x47,

    // DCU_MISS_OUTSTANDING - Weighted number of cycles while a DCU miss is
    // outstanding. Note - An access that also misses the L2 is short-changed
    // by 2 cycles. i.e. - if counts N cycles, should be N+2 cycles. 
    // Count value not precise, but still usful.
    0x48,   "dcuout",       100000, "Weighted DCU misses outstd",
            "DCU_MISS_OUTSTANDING", desc_0x48,

// External Bus Logic (EBL)

    // BUS_REQ_OUTSTANDING - Total number of bus requests outstanding.
    // Note - Counts only DCU full-line cacheable reads (not RFO's, writes,
    // ifetches or anything else.  Counts "waiting for bus" to "Complete"
    // (last data chunk received).
    0x60,   "bus",            1000, "Bus requests outstanding",
            "BUS_REQ_OUTSTANDING",  desc_0x60,

    // BUS_BRN_DRV - Number of bus clock cycles that this processor is driving
    // the corresponding pin.
    0x61,   "bnr",               0, "Bus BNR pin drive cycles",
            "BUS_BNR_DRV",          desc_0x61,

    // BUS_DRDY_CLOCKS - Number of clocks in which DRDY is asserted.
    // Note - UMSK =  0h counts bus clocks when PPP is driving DRDY.
    //        UMSK = 20h counts in processor clocks when any agent is
    //               driving DRDY.
    0x62,   "drdy",              0, "Bus DRDY asserted clocks",
            "BUS_DRDY_CLOCKS",      desc_0x62,

    // BUS_LOCK_CLOCKS - Number of clocks LOCK is asserted.
    // Note - always counts in processor clocks.
    0x63,   "lock",              0, "Bus LOCK asserted clocks",
            "BUS_LOCK_CLOCKS",      desc_0x63,

    // BUS_DATA_RCV - Number of bus clock cycles that this p6 is receiving data.
    0x64,   "rdata",         10000, "Bus clocks receiving data",
            "BUS_DATA_RCV",         desc_0x64,

    // BUS_TRANS_BRD - Total number of Burst Read transactions.
    0x65,   "bread",         10000, "Bus burst read transactions",
            "BUS_TRANS_BRD",        desc_0x65,

    // BUS_TRANS_RFO - Total number of Read For Ownership transactions.
    0x66,   "owner",          1000, "Bus read for ownership trans",
            "BUS_TRANS_RFO",        desc_0x66,

    // BUS_TRANS_WB - Total number of Write Back transactions
    0x67,   "writeback",      1000, "Bus writeback transactions",
            "BUS_TRANS_WB",         desc_0x67,

    // BUS_TRANS_IFETCH - Total number of instruction fetch transactions.
    0x68,   "binst",         10000, "Bus instruction fetches",
            "BUS_TRANS_IFETCH",     desc_0x68,

    // BUS_TRANS_INVAL - Total number of invalidate transactions.
    0x69,   "binvalid",       1000, "Bus invalidate transactions",
            "BUS_TRANS_INVAL",      desc_0x69,

    // BUS_TRANS_PWR - Total number of Partial Write transactions.
    0x6a,   "bpwrite",        1000, "Bus partial write transactions",
            "BUS_TRANS_PWR",        desc_0x6A,

    // BUS_TRANS_P - Total number of Partial transactions
    0x6b,   "bptrans",        1000, "Bus partial transactions",
            "BUS_TRANS_P",          desc_0x6B,

    // BUS_TRANS_IO - Total number of IO transactions
    0x6c,   "bio",           10000, "Bus IO transactions",
            "BUS_TRANS_IO",         desc_0x6C,

    // BUS_TRANS_DEF - Total number of deferred transactions.
    0x6d,   "bdeferred",     10000, "Bus deferred transactions",
            "BUS_TRANS_DEF",        desc_0x6D,

    // BUS_TRANS_BURST - Total number of Burst transactions.
    0x6e,   "bburst",        10000, "Bus burst transactions (total)",
            "BUS_TRANS_BURST",      desc_0x6E,

    // BUS_TRANS_MEM - Total number of memory transactions.
    0x6f,   "bmemory",       10000, "Bus memory transactions (total)",
            "BUS_TRANS_MEM",        desc_0x6F,

    // BUS_TRANS_ANY - Total number of all transactions.
    0x70,   "btrans",        10000, "Bus all transactions",
            "BUS_TRANS_ANY",        desc_0x70,

    // continued at 0x7a below

// Clocks

    // CPU_CLK_UNHALTED - Number of cycles for which the processor is not
    // halted.
    0x79,   "nhalt",        100000, "CPU was not HALTED cycles",
            "CPU_CLK_UNHALTED",     desc_0x79,

// External Bus Logic (EBL) (continued from 0x70 above)

    // BUS_HIT_DRV - Number of bus clock cycles that this processor is driving
    // the corresponding pin.
    // Note - includes cycles due to snoop stalls
    0x7a,   "hit",            1000, "Bus CPU drives HIT cycles",
            "BUS_HIT_DRV",          desc_0x7A,

    // BUS_HITM_DRV - Number of bus clock cycles that this processor is driving
    // the cooresponding pin.
    // Note - includes cycles due to snoop stalls
    0x7b,   "hitm",           1000, "Bus CPU drives HITM cycles",
            "BUS_HITM_DRV",         desc_0x7B,

    // BUS_SNOOP_STALL - Number of clock cycles for which the bus is snoop
    // stalled.
    0x7e,   "bsstall",           0, "Bus snoop stalled cycles",
            "BUS_SNOOP_STALL",      desc_0x7E,

// Instruction Fetch Unit (IFU)

    // IFU_IFETCH - Total number of instruction fetches (cacheable and
    // uncacheable).
    0x80,   "ifetch",       100000, "Instruction fetches",
            "IFU_IFETCH",           desc_0x80,

    // IFU_IFETCH_MISS _ Total number of instruction fetch misses.
    0x81,   "imfetch",       10000, "Instrection fetch Misses",
            "IFU_IFETCH_MISS",      desc_0x81,

    // ITLB_MISS - Number of ITLB misses
    0x85,   "itlbmiss",        100, "Instruction TLB misses",
            "ITLB_MISS",            desc_0x85,

    // IFU_MEM_STALL - The number of cycles that instruction fetch pipestage
    // is stalled (includes cache misses, ITLB misses, ITLB faults and
    // Victim Cache evictions).
    0x86,   "ifstall",        1000, "Inst fetch stalled cycles",
            "IFU_MEM_STALL",        desc_0x86,

    // ILD_STALL - Number of cycles for which the instruction length decoder
    // is stalled.
    0x87,   "ildstall",       1000, "Inst len decoder stalled cycles",
            "ILD_STALL",            desc_0x87,

// Stalls

    // RESOURCE_STALLS - Number of cycles for which there are resouce related 
    // stalls.
    0xa2,   "rstall",        10000, "Resource related stalls",
            "RESOURCE_STALLS",      desc_0xA2,

    // see also 0xd2 below 

// Instruction Decode and Retirement

    // INST_RETIRED - Number of instructions retired.
    0xc0,   "instr",        100000, "Instructions retired",
            "INST_RETIRED",         desc_0xC0,

    // continued at 0xc2 below

// Floating Point (continued from 0x14 above)

    // FLOPS - Number of computational floating point operations retired.
    0xc1,   "fpr",            RARE, "FP compute opers retired",
            "FLOPS",                desc_0xC1,

// Instruction Decode and Retirement (continued from 0xc0 above)

    // UOPS_RETIRED - Number of Uops retired
    0xc2,   "ur",           100000, "UOPs retired",
            "UOPS_RETIRED",         desc_0xC2,

    // see also 0xd0 below

// Branches

    // BR_INST_RETIRED - Number of branch instructions that retire.
    0xc4,   "br",            10000, "Branches retired",
            "BR_INST_RETIRED",      desc_0xC4,

    // BR_MISS_PRED_RETIRED - Number of mispredicted branches that retire.
    0xc5,   "brm",            1000, "Branch miss predictions retired",
            "BR_MISS_PRED_RETIRED", desc_0xC5,

    // continued at 0xc9 below

// Interrupts

    // CYCLES_INT_MASKED - Number of processor cycles for which interrupts
    // are disabled.
    0xc6,   "intm",          10000, "Interrupts masked cycles",
            "CYCLES_INT_MASKED",    desc_0xC6,

    // CYCLES_INT_PENDING_AND_MASKED - Number of processor cycles for which
    // interrupts are disabled and interrupts are pending.
    0xc7,   "intmp",          1000, "Int pending while masked cycles",
            "CYCLES_INT_PENDING_AND_MASKED",   desc_0xC7,

    // HW_INT_RX - Number of hardware interrupts received.
    0xc8,   "int",               0, "Hardware interrupts received",
            "HW_INT_RX",            desc_0xC8,

// Branches (continued from 0xc5 above)

    // BR_TAKEN_RETIRED - Number of taken branches that are retired.
    0xc9,   "brt",           10000, "Taken branches retired",
            "BR_TAKEN_RETIRED",     desc_0xC9,

    // BR_MISS_PRED_TAKEN_RET - Number of Mispredictions that are retired.
    0xca,   "brtm",              0, "Taken branch miss pred retired",
            "BR_MISS_PRED_TAKEN_RET",  desc_0xCA,

    // continued at 0xe0 below

// Instruction Decode and Retirement (continued from 0xc2 above)

    // INST_DECODED - Number of Instructions decoded.
    0xd0,   "idecode",      100000, "Instructions decoded",
            "INST_DECODED",         desc_0xD0,

// Stalls (continued from 0xa2 above)

    // PARTIAL_RAT_STALLS - Number of cycles or events for partial stalls.
    0xd2,   "pstall",         1000, "Partial register stalls",
            "PARTIAL_RAT_STALLS",   desc_0xD2,

// Branches (continued from 0xca above)

    // BR_INST_DECODED - Number of branch instructions that are decoded.
    0xe0,   "ibdecode",          0, "Branches decoded",
            "BR_INST_DECODED",      desc_0xE0,

    // BTB_MISSES - Number of branches that miss the BTB
    0xe2,   "btbmiss",        1000, "BTB misses",
            "BTB_MISSES",           desc_0xE2,

    // BR_BOGUS - Number of bogus branches.
    0xe4,   "brbogus",        1000, "Bogus branches",
            "BR_BOGUS",             desc_0xE4,

    // BACLEARS - Number of times BACLEAR is asserted.
    0xe6,   "baclear",        1000, "BACLEARS Asserted",
            "BACLEARS",             desc_0xE6,

    // Terminator
    0,      NULL,                0, NULL,
            NULL,                   NULL
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\pdump\pdump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>

#include "..\pstat.h"


//
// global handles
//

extern  UCHAR Buffer[];
#define     INFSIZE             1024

UCHAR Usage[] = "pdump: [-p] [-t] second-delay [counter] [counter]...\n";

UCHAR       NumberOfProcessors;

HANDLE      DriverHandle;
ULONG       BufferStart [INFSIZE/4];
ULONG       BufferEnd   [INFSIZE/4];

//
// Selected Display Mode (read from wp2.ini), default set here.
//

struct {
    ULONG   EventId;
    PUCHAR  ShortName;
    PUCHAR  PerfName;
} *Counters;

SETEVENT  CounterEvent[MAX_EVENTS];

//
// Protos..
//

VOID    GetInternalStats (PVOID Buffer);
VOID    SetCounterEncodings (VOID);
LONG    FindShortName (PSZ);
VOID    LI2Str (PSZ, ULONGLONG);
BOOLEAN SetCounter (LONG CounterID, ULONG counter);
BOOLEAN InitDriver ();
VOID    InitPossibleEventList();




int
__cdecl
main(USHORT argc, CHAR **argv)
{
    ULONG           i, j, len, pos, Delay;
    LONG            cnttype;
    BOOLEAN         CounterSet;
    pPSTATS         ProcStart, ProcEnd;
    ULONGLONG       ETime, ECount;
    UCHAR           s1[40], s2[40];
    BOOLEAN         Fail, DumpAll, ProcessorBreakout, ProcessorTotal;

    //
    // Locate pentium perf driver
    //

    if (!InitDriver ()) {
        printf ("pstat.sys is not installed\n");
        exit (1);
    }

    //
    // Initialize supported event list
    //

    InitPossibleEventList();
    if (!Counters) {
        printf ("No events to monitor\n");
        exit (1);
    }

    //
    // Check args
    //

    if (argc < 2) {
        printf (Usage);
        for (i=0; Counters[i].ShortName; i++) {
            printf ("    %-20s\t%s\n", Counters[i].ShortName, Counters[i].PerfName);
        }
        exit (1);
    }

    pos  = 1;

    Fail = FALSE;
    Delay = 0;
    DumpAll = FALSE;
    ProcessorBreakout = FALSE;
    ProcessorTotal = FALSE;

    while (pos < argc  &&  argv[pos][0] == '-') {
        switch (argv[pos][1]) {
            case 't':
                ProcessorTotal = TRUE;
                break;

            case 'p':
                ProcessorBreakout = TRUE;
                break;

            default:
                printf ("pdump: unkown switch '%c'\n", argv[pos][1]);
                Fail = TRUE;
                break;
        }
        pos += 1;
    }

    if (pos < argc) {
        Delay = atoi (argv[pos]) * 1000;
        pos += 1;
    }

    if (Fail  /* ||  Delay == 0 */) {
        printf (Usage);
        exit (1);
    }

    //
    // Raise to highest priority
    //

    if (!SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS)) {
        printf("Failed to raise to realtime priority\n");
    }

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);


    //
    // Loop for every pentium count desired
    //

    if (pos >= argc) {
        pos = 0;
        DumpAll = TRUE;
    }

    printf ("    %-30s %17s   %17s\n", "", "Cycles", "Count");

    for (; ;) {
        //
        // Set MAX_EVENTS
        //

        CounterSet = FALSE;
        i = 0;
        while (i < MAX_EVENTS) {
            cnttype = -1;
            if (DumpAll) {
                //
                // Dump all - get next counter
                //

                if (Counters[pos].ShortName) {
                    cnttype = pos;
                    pos++;
                }

            } else {

                //
                // process command line args
                //

                if (pos < argc) {
                    cnttype = FindShortName (argv[pos]);
                    if (cnttype == -1) {
                        printf ("Counter '%s' not found\n", argv[pos]);
                        pos++;
                        continue;
                    }
                    pos++;
                }
            }

            CounterSet |= SetCounter (cnttype, i);
            i++;
        }

        if (!CounterSet) {
            // done
            exit (1);
        }

        //
        // Call driver and perform the setting
        //

        SetCounterEncodings ();
        if ( Delay == 0 )   {
            printf( "Counters set\n" );
            // done
            exit(1);
        }

        //
        // Snap begining & ending counts
        //

        Sleep (50);                         // slight settle
        GetInternalStats (BufferStart);     // snap current values
        Sleep (Delay);                      // sleep desired time
        GetInternalStats (BufferEnd);       // snap ending values

        //
        // Calculate each counter and print it
        //

        for (i=0; i < MAX_EVENTS; i++) {
            if (!CounterEvent[i].Active) {
                continue;
            }

            len = *((PULONG) BufferStart);

            if (ProcessorBreakout) {
                //
                // Print stat for each processor
                //

                ProcStart = (pPSTATS) ((PUCHAR) BufferStart + sizeof(ULONG));
                ProcEnd   = (pPSTATS) ((PUCHAR) BufferEnd   + sizeof(ULONG));

                for (j=0; j < NumberOfProcessors; j++) {
                    ETime = ProcEnd->TSC - ProcStart->TSC;
                    ECount = ProcEnd->Counters[i] - ProcStart->Counters[i];

                    ProcStart = (pPSTATS) (((PUCHAR) ProcStart) + len);
                    ProcEnd   = (pPSTATS) (((PUCHAR) ProcEnd)   + len);

                    LI2Str (s1, ETime);
                    LI2Str (s2, ECount);
                    printf (" P%d %-30s %s   %s\n",
                        j,
                        Counters[CounterEvent[i].AppReserved].PerfName,
                        s1, s2
                        );
                }
            }

            if (!ProcessorBreakout || ProcessorTotal) {
                //
                // Sum processor's and print it
                //

                ProcStart = (pPSTATS) ((PUCHAR) BufferStart + sizeof(ULONG));
                ProcEnd   = (pPSTATS) ((PUCHAR) BufferEnd   + sizeof(ULONG));

                ETime  = 0;
                ECount = 0;

                for (j=0; j < NumberOfProcessors; j++) {
                    ETime = ETime + ProcEnd->TSC;
                    ETime = ETime - ProcStart->TSC;

                    ECount = ECount + ProcEnd->Counters[i];
                    ECount = ECount - ProcStart->Counters[i];

                    ProcStart = (pPSTATS) (((PUCHAR) ProcStart) + len);
                    ProcEnd   = (pPSTATS) (((PUCHAR) ProcEnd)   + len);
                }

                LI2Str (s1, ETime);
                LI2Str (s2, ECount);
                printf ("    %-30s %s   %s\n",
                    Counters[CounterEvent[i].AppReserved].PerfName,
                    s1, s2
                    );
            }
        }
    }

    return 0;
}

BOOLEAN
InitDriver ()
{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return FALSE;
    }

    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    return NT_SUCCESS(status) ? TRUE : FALSE;
    return TRUE;
}

VOID
InitPossibleEventList()
{
    UCHAR               buffer[400];
    ULONG               i, Count;
    NTSTATUS            status;
    PEVENTID            Event;
    IO_STATUS_BLOCK     IOSB;


    //
    // Initialize possible counters
    //

    // determine how many events there are

    Event = (PEVENTID) buffer;
    Count = 0;
    do {
        *((PULONG) buffer) = Count;
        Count += 1;

        status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    PSTAT_QUERY_EVENTS,
                    buffer,                 // input buffer
                    sizeof (buffer),
                    NULL,                   // output buffer
                    0
                    );
    } while (NT_SUCCESS(status));

    Counters = malloc(sizeof(*Counters) * Count);
    if (Counters == NULL) {
        printf ("Memory allocation failure initializing event list\n");
        exit(1);
    }

    Count -= 1;
    for (i=0; i < Count; i++) {
        *((PULONG) buffer) = i;
        NtDeviceIoControlFile(
           DriverHandle,
           (HANDLE) NULL,          // event
           (PIO_APC_ROUTINE) NULL,
           (PVOID) NULL,
           &IOSB,
           PSTAT_QUERY_EVENTS,
           buffer,                 // input buffer
           sizeof (buffer),
           NULL,                   // output buffer
           0
           );

        Counters[i].EventId   = Event->EventId;
        Counters[i].ShortName = _strdup (Event->Buffer);
        Counters[i].PerfName  = _strdup (Event->Buffer + Event->DescriptionOffset);
    }

    Counters[i].EventId   = 0;
    Counters[i].ShortName = NULL;
    Counters[i].PerfName  = NULL;
}


VOID LI2Str (PSZ s, ULONGLONG li)
{
    if (li > 0xFFFFFFFF) {
        sprintf (s, "%08x:%08x", (ULONG) (li >> 32), (ULONG) li);
    } else {
        sprintf (s, "         %08x", (ULONG) li);
    }
}


LONG FindShortName (PSZ name)
{
    LONG   i;

    for (i=0; Counters[i].ShortName; i++) {
        if (strcmp (Counters[i].ShortName, name) == 0) {
            return i;
        }
    }

    return -1;
}


VOID GetInternalStats (PVOID Buffer)
{
    IO_STATUS_BLOCK             IOSB;

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_READ_STATS,
        Buffer,                 // input buffer
        INFSIZE,
        NULL,                   // output buffer
        0
    );
}


VOID SetCounterEncodings (VOID)
{
    IO_STATUS_BLOCK             IOSB;

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_SET_CESR,
        CounterEvent,           // input buffer
        sizeof (CounterEvent),
        NULL,                   // output buffer
        0
    );
}


BOOLEAN SetCounter (LONG CounterId, ULONG counter)
{
    if (CounterId == -1) {
        CounterEvent[counter].Active = FALSE;
        return FALSE;
    }

    CounterEvent[counter].EventId = Counters[CounterId].EventId;
    CounterEvent[counter].AppReserved = (ULONG) CounterId;
    CounterEvent[counter].Active = TRUE;
    CounterEvent[counter].UserMode = TRUE;
    CounterEvent[counter].KernelMode = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\qsys\qsys.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

   qsys.c

Abstract:

    This program simply interfaces with NtQuerySystemInformation()
    and dumps the data structures.

Usage:

    qsys

Author:

    Thierry Fevrier 26-Feb-2000

Revision History:

    02/26/2000 Thierry
    Created.
   
--*/

// If under our build environment'S', we want to get all our
// favorite debug macros defined.
//

#if DBG           // NTBE environment
   #if NDEBUG
      #undef NDEBUG     // <assert.h>: assert() is defined
   #endif // NDEBUG
   #define _DEBUG       // <crtdbg.h>: _ASSERT(), _ASSERTE() are defined.
   #define DEBUG   1    // our internal file debug flag
#elif _DEBUG      // VC++ environment
   #ifndef NEBUG
   #define NDEBUG
   #endif // !NDEBUG
   #define DEBUG   1    // our internal file debug flag
#endif

//
// Include System Header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>

#include ".\qsys.rc"

#define FPRINTF (void)fprintf

#include ".\basic.c"
#include ".\proc.c"
#include ".\sysperf.c"
#include ".\procperf.c"
#include ".\procidle.c"
#include ".\tod.c"
#include ".\qtimeadj.c"
#include ".\flags.c"
#include ".\filecache.c"
#include ".\dev.c"
#include ".\crashdump.c"
#include ".\except.c"
#include ".\crashstate.c"
#include ".\kdbg.c"
#include ".\ctxswitch.c"
#include ".\regquota.c"
#include ".\dpc.c"
#include ".\verifier.c"
#include ".\legaldrv.c"

#define QUERY_INFO( _Info_Class, _Type )  \
{ \
   _Type info; \
   status = NtQuerySystemInformation( _Info_Class,                           \
                                       &info,                                \
                                       sizeof(info),                         \
                                       NULL                                  \
                                    );                                       \
   if ( !NT_SUCCESS(status) )   {                                            \
      printf( "\n%s: %s failed...\n", VER_INTERNALNAME_STR, # _Info_Class ); \
   }                                                                         \
   Print##_Type##(&info);                                                    \
}

int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;

    // 
    // Print version of the Build environment to identify
    // the data structures definitions.
    //

    printf( "qsys v%s\n", VER_PRODUCTVERSION_STR );

    //
    // First, dump fixed data structures.
    //

    QUERY_INFO( SystemBasicInformation,                SYSTEM_BASIC_INFORMATION );
    QUERY_INFO( SystemProcessorInformation,            SYSTEM_PROCESSOR_INFORMATION );
    QUERY_INFO( SystemPerformanceInformation,          SYSTEM_PERFORMANCE_INFORMATION );
    QUERY_INFO( SystemProcessorPerformanceInformation, SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION );
    QUERY_INFO( SystemProcessorIdleInformation,        SYSTEM_PROCESSOR_IDLE_INFORMATION );
    QUERY_INFO( SystemTimeOfDayInformation,            SYSTEM_TIMEOFDAY_INFORMATION );
    QUERY_INFO( SystemTimeAdjustmentInformation,       SYSTEM_QUERY_TIME_ADJUST_INFORMATION );
    QUERY_INFO( SystemFlagsInformation,                SYSTEM_FLAGS_INFORMATION );
    QUERY_INFO( SystemFileCacheInformation,            SYSTEM_FILECACHE_INFORMATION );
    QUERY_INFO( SystemDeviceInformation,               SYSTEM_DEVICE_INFORMATION );
//    QUERY_INFO( SystemCrashDumpInformation,            SYSTEM_CRASH_DUMP_INFORMATION );
    QUERY_INFO( SystemExceptionInformation,            SYSTEM_EXCEPTION_INFORMATION );
//    QUERY_INFO( SystemCrashDumpStateInformation,       SYSTEM_CRASH_STATE_INFORMATION );
    QUERY_INFO( SystemKernelDebuggerInformation,       SYSTEM_KERNEL_DEBUGGER_INFORMATION );
    QUERY_INFO( SystemContextSwitchInformation,        SYSTEM_CONTEXT_SWITCH_INFORMATION );
    QUERY_INFO( SystemRegistryQuotaInformation,        SYSTEM_REGISTRY_QUOTA_INFORMATION );
    QUERY_INFO( SystemDpcBehaviorInformation,          SYSTEM_DPC_BEHAVIOR_INFORMATION );
//  QUERY_INFO( SystemCurrentTimeZoneInformation,      RTL_TIME_ZONE_INFORMATION );
    QUERY_INFO( SystemLegacyDriverInformation,         SYSTEM_LEGACY_DRIVER_INFORMATION );

// SystemRangeStartInformation

    //
    // Second, dump dynamic data structures.
    //

    // not done, yet...
// QUERY_INFO( SystemVerifierInformation,             SYSTEM_VERIFIER_INFORMATION );
// _SYSTEM_CALL_COUNT_INFORMATION
// _SYSTEM_MODULE_INFORMATION
// _SYSTEM_LOCKS_INFORMATION
// _SYSTEM_PAGED_POOL_INFORMATION
// _SYSTEM_NONPAGED_POOL_INFORMATION
// _SYSTEM_OBJECT_INFORMATION
// _SYSTEM_OBJECTTYPE_INFORMATION
// _SYSTEM_HANDLE_INFORMATION
// _SYSTEM_HANDLE_TABLE_ENTRY_INFO
// _SYSTEM_PAGEFILE_INFORMATION
// _SYSTEM_POOL_INFORMATION
// _SYSTEM_POOLTAG
// _SYSTEM_POOLTAG_INFORMATION
//    QUERY_INFO( SystemInterruptInformation,            SYSTEM_INTERRUPT_INFORMATION );
//    SystemLookasideInformation
// _SYSTEM_SESSION_PROCESS_INFORMATION
// _SYSTEM_THREAD_INFORMATION
// _SYSTEM_PROCESS_INFORMATION

    return 0;

} // qsys:main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\pperf\driver\stat.h ===
//
// counter/accumulators
//

typedef struct {
    volatile ULONG          CountStart;
    volatile ULONG          CountEnd;
    volatile ULONGLONG      Counters[MAX_EVENTS];
    volatile ULONGLONG      TSC;
    volatile ULONG          ThunkCounters[MAX_THUNK_COUNTERS];
} ACCUMULATORS, *PACCUMULATORS;

//
// Per hook record
//

typedef struct ThunkHookInfo {
    LIST_ENTRY  HookList;
    ULONG       HookAddress;
    ULONG       OriginalDispatch;
    ULONG       TracerId;

    UCHAR       HookCode[80];

} HOOKEDTHUNK, *PHOOKEDTHUNK;

//
// Define the device extension
//

typedef struct _DEVICE_EXTENSION {

    ULONG   na;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// Define for counted events
//

typedef struct _COUNTED_EVENTS {
    ULONG       Encoding;
    PUCHAR      Token;
    ULONG       SuggestedIntervalBase;
    PUCHAR      Description;
    PUCHAR      OfficialToken;
    PUCHAR      OfficialDescription;
} COUNTED_EVENTS, *PCOUNTED_EVENTS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\qsys\makefile.inc ===
$(O)\qsys.res: qsys.rc

basic.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_BASIC_INFORMATION > $@

proc.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PROCESSOR_INFORMATION > $@

sysperf.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PERFORMANCE_INFORMATION > $@

procperf.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION > $@

procidle.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PROCESSOR_IDLE_INFORMATION > $@

tod.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_TIMEOFDAY_INFORMATION > $@

qtimeadj.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_QUERY_TIME_ADJUST_INFORMATION > $@

flags.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_FLAGS_INFORMATION > $@

filecache.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_FILECACHE_INFORMATION > $@

dev.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_DEVICE_INFORMATION > $@

crashdump.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_CRASH_DUMP_INFORMATION > $@

except.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_EXCEPTION_INFORMATION > $@

crashstate.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_CRASH_STATE_INFORMATION > $@

kdbg.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_KERNEL_DEBUGGER_INFORMATION > $@

ctxswitch.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_CONTEXT_SWITCH_INFORMATION > $@

regquota.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_REGISTRY_QUOTA_INFORMATION > $@

dpc.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_DPC_BEHAVIOR_INFORMATION > $@

verifier.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_VERIFIER_INFORMATION > $@

legaldrv.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_LEGACY_DRIVER_INFORMATION > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\analog.c ===
/*
 * Title: analog.c - main file for log analyzer
 *
 * Description: This file is a tool to analyze sorted memsnap and poolsnap log
 *              files.  It reads in the log files and records each of the
 *              fields for each process or tag.  It then does a trend analysis
 *              of each field.  If any field increases every period, it reports
 *              a definite leak.  If the difference of increase count and
 *              decrease count for any field is more than half the periods, it
 *              reports a probable leak.
 *
 * Functions:
 *
 *     Usage             Prints usage message
 *     DetermineFileType Determines type of log file (mem/pool) & longest entry
 *     AnalyzeMemLog     Reads and analyzes sorted memsnap log
 *     AnalyzePoolLog    Reads and analyzes sorted poolsnap log
 *     AnalyzeFile       Opens file, determines type and calls analysis function
 *     main              Loops on each command arg and calls AnalyzeFile
 *
 * Copyright (c) 1998-1999  Microsoft Corporation
 *
 * ToDo:
 *    1. Way to ignore some of the periods at the beginning.
 *    2. Exceptions file to ignore tags or processes.
 *    3. Pick up comments from file and print them as notes.
 *    *4. switch to just show definites.
 *    5. Output computername, build number,checked/free, arch. etc
 *    6. option to ignore process that weren't around the whole time
 *
 * Revision history: LarsOp 12/8/1998 - Created
 *                   ChrisW 3/22/1999 - HTML, Calculate rates
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "analog.h"

#include "htmprint.c"   // all the HTML procs and variables


INT   g_iMaxPeriods=0;          // Global for max periods
BOOL  g_fVerbose=FALSE;         // Global verbosity for deltas on memlogs
BOOL  g_fShowExtraInfo=FALSE;   // If true, show computer names, and comments
DWORD g_dwElapseTickCount=0;    // Total elapse time for these logs
CHAR* g_pszComputerName=NULL;   // name of computer the log file came from
CHAR* g_pszBuildNumber=NULL;    // build number
CHAR* g_pszBuildType=NULL;      // build type (retail/debug)
CHAR* g_pszSystemTime=NULL;     // last time
CHAR* g_pszComments=NULL;
INT   g_ReportLevel=9;          // 0= only definite, 9=all inclusive

#define TAGCHAR '!' /* character that starts tag line */

/*
 *  Usage prints the usage message.
 */
void Usage()
{
    printf("Usage: AnaLog [-v] [-h] [-t] [-d] <file1> [<file2>] [<file3>] [...]\n");
    printf("           **no wild card support yet**\n\n");
    printf("AnaLog will analyze SortLog output of MemSnap or PoolSnap files.\n\n");
    printf("-v  Print deltas>%d%% for all processes to be written to stderr\n", PERCENT_TO_PRINT);
    printf("-h  Produce HTML tables\n");
    printf("-t  Show Extra info like computer name, and comments\n");
    printf("-d  Show only definite leaks\n");
    printf("\n");
    printf("Definite leak means that the value increased every period.\n");
    printf("Probable leak means that it increased more than half the periods.\n" );
}

DWORD Trick( LONG amount, DWORD ticks )
{
    _int64 temp;


    temp= amount;
    temp= temp * 3600;

    temp= temp * 1000;
    temp= temp/(ticks);

    return( (DWORD) temp );
}


// GetLocalString
//
// Allocate a heap block and copy string into it.
//
// return: pointer to heap block
//

CHAR* GetLocalString( CHAR* pszString )
{
   INT len;
   CHAR* pszTemp;

   len= strlen( pszString ) + 1;

   pszTemp= (CHAR*) LocalAlloc( LPTR, len );

   if( !pszTemp ) return NULL;

   strcpy( pszTemp, pszString );

   return( pszTemp );

}

/*
 * ProcessTag
 *
 * Args: char* - pointer to something like 'tag=value'
 *
 * return: nothing (but may set global variables)
 *
 */

#define BREAKSYM "<BR>"

VOID ProcessTag( CHAR* pBuffer )
{
    CHAR* pszTagName;
    CHAR* pszEqual;
    CHAR* pszValue;
    INT   len;

    // eliminate trailing newline

    len= strlen( pBuffer );

    if( len ) {
        if( pBuffer[len-1] == '\n' ) {
            pBuffer[len-1]= 0;
        }
    }

    pszTagName= pBuffer;

    pszEqual= pBuffer;

    while( *pszEqual && (*pszEqual != '=' ) ) {
        pszEqual++;
    }

    if( !*pszEqual ) {
        return;
    }

    *pszEqual= 0;   // zero terminate the tag name
 
    pszValue= pszEqual+1;

    if( _stricmp( pszTagName, "elapsetickcount" ) == 0 ) {
       g_dwElapseTickCount= atol( pszValue );
    }

    else if( _stricmp( pszTagName, "computername" ) == 0 ) {
        g_pszComputerName= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "buildnumber" ) == 0 ) {
        g_pszBuildNumber= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "buildtype" ) == 0 ) {
        g_pszBuildType= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "systemtime" ) == 0 ) {
        g_pszSystemTime= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "logtype" ) == 0 ) {
        // just ignore
    }

    else {
        INT   len;
        CHAR* pBuf;
        BOOL  bIgnoreTag= FALSE;

        if( _stricmp(pszTagName,"comment")==0 ) {
            bIgnoreTag=TRUE;
        }
        
        if( g_pszComments == NULL ) {
           len= strlen(pszTagName) + 1 + strlen(pszValue) + 1 +1;
           pBuf= (CHAR*) LocalAlloc( LPTR, len );
           if( pBuf ) {
               if( bIgnoreTag ) {
                   sprintf(pBuf,"%s\n",pszValue);
               }
               else {
                   sprintf(pBuf,"%s %s\n",pszTagName,pszValue);
               }
               g_pszComments= pBuf;
           }
        }
        else {
           len= strlen(g_pszComments)+strlen(pszTagName)+1+strlen(pszValue)+sizeof(BREAKSYM)+1 +1;
           pBuf= (CHAR*) LocalAlloc( LPTR, len );
           if( pBuf ) {
               if( bIgnoreTag ) {
                   sprintf(pBuf,"%s%s%s\n",g_pszComments,BREAKSYM,pszValue);
               }
               else {
                   sprintf(pBuf,"%s%s%s=%s\n",g_pszComments,BREAKSYM,pszTagName,pszValue);
               }
               LocalFree( g_pszComments );
               g_pszComments= pBuf;
           }
        }
    }

}

/*
 * DetermineFileType
 *
 * Args: pFile - File pointer to check
 *
 * Returns: The type of log of given file. UNKNOWN_LOG_TYPE is the error return.
 *
 * This function scans the file to determine the log type (based on the first
 * word) and the maximum number of lines for any process or tag.
 *
 */
LogType DetermineFileType(FILE *pFile)
{
    char buffer[BUF_LEN];           // buffer for reading lines
    char idstring[BUF_LEN];         // ident string (1st word of 1st line)
    LogType retval=UNKNOWN_LOG_TYPE;// return value (default to error case)
    fpos_t savedFilePosition;       // file pos to reset after computing max
    int iTemp;                      // temporary used for computing max entries
    int iStatus;

    //
    // Read the first string of the first line to identify the type
    //
    if (fgets(buffer, BUF_LEN, pFile)) {
        iStatus= sscanf(buffer, "%s", idstring);
        if( iStatus == 0  ) {
            return UNKNOWN_LOG_TYPE;
        }
        if (0==_strcmpi(idstring, "Tag")) {
            retval=POOL_LOG;
        } else if (0==_strcmpi(idstring, "Process")) {
            retval=MEM_LOG;
        } else {
            return UNKNOWN_LOG_TYPE;
        }
    } else {
        return UNKNOWN_LOG_TYPE;
    }

    //
    // Save the position to reset after counting the number of polling periods
    //
    fgetpos(pFile, &savedFilePosition);

    //
    // Loop until you get a blank line or end of file
    //
    g_iMaxPeriods=0;
    while (TRUE) {
        iTemp=0;
        while (TRUE) {
            //
            // Blank line actually has length 1 for LF character.
            //
            if( (NULL==fgets(buffer, BUF_LEN, pFile)) ||
                (*buffer == TAGCHAR )                 ||
                (strlen(buffer)<2)) {
                break;
            }
            iTemp++;
        }
        g_iMaxPeriods=MAX(g_iMaxPeriods, iTemp);

        if( *buffer == TAGCHAR ) {
            ProcessTag( buffer+1 );
        }
        if (feof(pFile)) {
            break;
        }
    }

    //
    // Reset position to first record for reading/analyzing data
    //
    (void) fsetpos(pFile, &savedFilePosition);

    return retval;
}

/*
 * AnalyzeMemLog
 *
 * Args: pointer to sorted memsnap log file
 *
 * Returns: nothing
 *
 * This function reads a sorted memsnap logfile.  For each process in the file,
 * it records each column for every period and then analyzes the memory trends
 * for leaks.
 *
 * If any column increases for each period, that is flagged as a definite leak.
 * If any column increases significatnly more often than decrease, it is a
 * flagged as a probable leak.
 *
 */
void AnalyzeMemLog(FILE *pFile)
{
    int iPeriod;          // index for which period being read
    MemLogRec Delta;      // Record to track increase from first to last entry
    MemLogRec TrendInfo;  // Record to track period increases
    MemLogRec* pLogArray; // Array of records for each process
    char buffer[BUF_LEN]; // Buffer for reading each line from pFile

    //
    // Allocate enough space for the largest set
    //
    pLogArray=malloc(g_iMaxPeriods*sizeof(MemLogRec));
    if (NULL==pLogArray) {
        fprintf(stderr,"Out of memory, aborting file.\n");
        return;
    }

    PRINT_HEADER();
    //
    // Read the entire file
    //
    while( !feof(pFile) ) {

        //
        // Reset trend and period info for each new process
        //
        memset(&TrendInfo, 0, sizeof(TrendInfo));
        iPeriod=0;

        //
        // Loop until you've read all the entries for this process or tag.
        //
        // Note: Empty line includes LF character that fgets doesn't eat.
        //
        while (TRUE) {

            if( iPeriod >= g_iMaxPeriods ) break;       // done

            if ((NULL==fgets(buffer, BUF_LEN, pFile)) ||
               (strlen(buffer)<2)                     ||
               (*buffer == TAGCHAR)                   ||
               (0==sscanf(buffer,
                   "%lx %s %ld %ld %ld %ld %ld %ld %ld",
                   &pLogArray[iPeriod].Pid,
                   pLogArray[iPeriod].Name,
                   &pLogArray[iPeriod].WorkingSet,
                   &pLogArray[iPeriod].PagedPool,
                   &pLogArray[iPeriod].NonPagedPool,
                   &pLogArray[iPeriod].PageFile,
                   &pLogArray[iPeriod].Commit,
                   &pLogArray[iPeriod].Handles,
                   &pLogArray[iPeriod].Threads))) {
                break;
            }
            //
            // Calculate TrendInfo:
            //
            // TrendInfo is a running tally of the periods a value went up vs.
            // the periods it went down.  See macro in analog.h
            //
            // if (curval>oldval) {
            //    trend++;
            // } else if (curval<oldval) {
            //    trend--;
            // } else {
            //    trend=trend;  // stay same
            // }
            //
            if (iPeriod>0) {
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, WorkingSet);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PagedPool);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, NonPagedPool);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PageFile);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Commit);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Handles);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Threads);
            }
            iPeriod++;
        }

        if (iPeriod>1) {
            //
            // GET_DELTA simply records the difference (end-begin) for each field
            //
            // Macro in analog.h
            //
            GET_DELTA(Delta, pLogArray, iPeriod, WorkingSet);
            GET_DELTA(Delta, pLogArray, iPeriod, PagedPool);
            GET_DELTA(Delta, pLogArray, iPeriod, NonPagedPool);
            GET_DELTA(Delta, pLogArray, iPeriod, PageFile);
            GET_DELTA(Delta, pLogArray, iPeriod, Commit);
            GET_DELTA(Delta, pLogArray, iPeriod, Handles);
            GET_DELTA(Delta, pLogArray, iPeriod, Threads);

            //
            // PRINT_IF_TREND reports probable or definite leaks for any field.
            //
            // Definite leak is where the value goes up every period
            // Probable leak is where the value goes up most of the time
            //
            // Macro in analog.h
            //
            // if (trend==numperiods-1) {
            //     definite_leak;
            // } else if (trend>=numperiods/2) {
            //     probable_leak;
            // }
            //
//            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, WorkingSet);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PagedPool);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, NonPagedPool);
//            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PageFile);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Commit);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Handles);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Threads);
            if (g_fVerbose && ANY_PERCENT_GREATER(Delta, pLogArray)) {
                printf("%-12s:WS=%4ld%% PP=%4ld%% NP=%4ld%% "
                   "PF=%4ld%% C=%4ld%% H=%4ld%% T=%4ld%%\n",
                    pLogArray[0].Name,
                    PERCENT(Delta.WorkingSet  , pLogArray[0].WorkingSet  ),
                    PERCENT(Delta.PagedPool   , pLogArray[0].PagedPool   ),
                    PERCENT(Delta.NonPagedPool, pLogArray[0].NonPagedPool),
                    PERCENT(Delta.PageFile    , pLogArray[0].PageFile    ),
                    PERCENT(Delta.Commit      , pLogArray[0].Commit      ),
                    PERCENT(Delta.Handles     , pLogArray[0].Handles     ),
                    PERCENT(Delta.Threads     , pLogArray[0].Threads     ));
            }
        }
    }

    PRINT_TRAILER();
}

/*
 * AnalyzePoolLog
 *
 * Args: pointer to sorted poolsnap log file
 *
 * Returns: nothing
 *
 * This function reads a sorted poolsnap logfile. For each pool tag in the file,
 * it records each column for every period and then analyzes the memory trends
 * for leaks.
 *
 * If any column increases for each period, that is flagged as a definite leak.
 * If any column increases significatnly more often than decrease, it is a
 * flagged as a probable leak.
 *
 */
void AnalyzePoolLog(FILE *pFile)
{
    int iPeriod;          // index for which period being read
    PoolLogRec Delta,     // Record to track increase from first to last entry
               TrendInfo, // Record to track period increases
               *pLogArray;// Array of records for each pool tag
    char buffer[BUF_LEN]; // Buffer for reading each line from pFile

    //
    // Allocate enough space for the largest set
    //
    pLogArray=malloc(g_iMaxPeriods*sizeof(PoolLogRec));
    if (NULL==pLogArray) {
        fprintf(stderr,"Out of memory, aborting file.\n");
        return;
    }

    PRINT_HEADER();

    //
    // Read the entire file
    //
    while( !feof(pFile) ) {

        //
        // Reset trend and period info for each new pool tag
        //
        memset(&TrendInfo, 0, sizeof(TrendInfo));
        iPeriod=0;

        //
        // Loop until you've read all the entries for this process or tag.
        //
        // Note: Empty line includes LF character that fgets doesn't eat.
        //
        while( TRUE ) {
     
            if( iPeriod >= g_iMaxPeriods ) break;         // done

            if ((NULL==fgets(buffer, BUF_LEN, pFile)) ||
               (strlen(buffer)<2)                     ||
               (*buffer == TAGCHAR )                  ||
               (0==sscanf(buffer,
                   " %4c %s %ld %ld %ld %ld %ld",
                   pLogArray[iPeriod].Name,
                   pLogArray[iPeriod].Type,
                   &pLogArray[iPeriod].Allocs,
                   &pLogArray[iPeriod].Frees,
                   &pLogArray[iPeriod].Diff,
                   &pLogArray[iPeriod].Bytes,
                   &pLogArray[iPeriod].PerAlloc))) {
                break;
            }
            pLogArray[iPeriod].Name[4]='\0'; // Terminate the tag

            //
            // Calculate TrendInfo:
            //
            // TrendInfo is a running tally of the periods a value went up vs.
            // the periods it went down.  See macro in analog.h
            //
            // if (curval>oldval) {
            //    trend++;
            // } else if (curval<oldval) {
            //    trend--;
            // } else {
            //    trend=trend;  // stay same
            // }
            //
            if (iPeriod>0) {
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Allocs);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Frees);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Diff);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Bytes);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PerAlloc);
            }
            iPeriod++;
        }

        //
        // skip rest of loop if a blank line or useless line
        //

        if( iPeriod == 0 ) continue;


        strcpy(TrendInfo.Name,pLogArray[0].Name);

        //
        // GET_DELTA simply records the difference (end-begin) for each field
        //
        // Macro in analog.h
        //
        GET_DELTA(Delta, pLogArray, iPeriod, Allocs);
        GET_DELTA(Delta, pLogArray, iPeriod, Frees);
        GET_DELTA(Delta, pLogArray, iPeriod, Diff);
        GET_DELTA(Delta, pLogArray, iPeriod, Bytes);
        GET_DELTA(Delta, pLogArray, iPeriod, PerAlloc);

        //
        // PRINT_IF_TREND reports probable or definite leaks for any field.
        //
        // Definite leak is where the value goes up every period
        // Probable leak is where the value goes up most of the time
        //
        // Macro in analog.h
        //
        // if (trend==numperiods-1) {
        //     definite_leak;
        // } else if (trend>=numperiods/2) {
        //     probable_leak;
        // }
        //
        // Note: Allocs, Frees and PerAlloc don't make sense to report trends.
        //
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Allocs);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Frees);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PerAlloc);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Diff);
        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Bytes);
    }


    PRINT_TRAILER();
}

/*
 * AnalyzeFile
 *
 * Args: pFileName - filename to analyze
 *
 * Returns: nothing
 *
 * This function opens the specified file, determines the file type and calls
 * the appropriate analyze function.
 *
 */
void AnalyzeFile(char *pFileName)
{
    FILE *pFile;                        // using fopen for fgets functionality
    LogType WhichType=UNKNOWN_LOG_TYPE; // which type of log (pool/mem)

    pFile=fopen(pFileName, "r");
    if (NULL==pFile) {
        fprintf(stderr,"Unable to open %s, Error=%d\n", pFileName, GetLastError());
        return;
    }

    WhichType=DetermineFileType(pFile);

    switch (WhichType)
        {
        case MEM_LOG:
            AnalyzeMemLog(pFile);
            break;
        case POOL_LOG:
            AnalyzePoolLog(pFile);
            break;
        default:
            ;
        }

    fclose(pFile);
}

/*
 * main
 *
 * Args: argc - count of command line args
 *       argv - array of command line args
 *
 * Returns: 0 if called correctly, 1 if not.
 *
 * This is the entry point for analog.  It simply parses the command line args
 * and then calls AnalyzeFile on each file.
 *
 */
int _cdecl main(int argc, char *argv[])
{
    int ArgIndex;
    if (argc<2) {
        Usage();
        return 1;
    }

    for( ArgIndex=1; ArgIndex<argc; ArgIndex++) {
        if( (*argv[ArgIndex] == '/') || (*argv[ArgIndex]=='-') ) {
           CHAR chr;

           chr= argv[ArgIndex][1];
           switch( chr ) {
               case 'v': case 'V':          // verbose
                   g_fVerbose= TRUE;
                   break;
               case 'h': case 'H':          // output HTML
                   bHtmlStyle= TRUE;
                   break;
               case 't': case 'T':          // show all the extra info
                   g_fShowExtraInfo=TRUE;
                   break;
               case 'd': case 'D':          // print definite only
                   g_ReportLevel= 0;   
                   break; 
               default:
                    Usage();
                    break;
           }
        }
        else {
            AnalyzeFile(argv[ArgIndex]);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\dh.c ===
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <memory.h>
#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>

//
// Include umdh stuff
//

#define _PART_OF_DH_ 1
#include "..\umdh\database.c"
#include "..\umdh\miscellaneous.c"
#include "..\umdh\symbols.c"
#include "..\umdh\umdh.c"
#include "..\umdh\dhcmp.c"
#include "..\umdh\heapwalk.c"


#define MAXDWORD    0xffffffff  //this is the max value for a DWORD

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//

#define BUFFER_SIZE_STEP    65536

//
// Globals
//

BOOL fVerbose;
BOOL fDumpModules;
BOOL fDumpBackTraces;
BOOL fIgnoreBackTraces;
BOOL fDumpHeapSummaries;
BOOL fDumpHeapTags;
BOOL fDumpHeapEntries;
BOOL fDumpHeapHogs;
BOOL fDumpLocks;
BOOL fDumpSystemObjects;
BOOL fDumpSystemProcesses;
BOOL fDumpKernelModeInformation;
ULONG BufferSize ;

BOOL fRepetitive;       // Are we in repetitive mode
DWORD dwTimeInterval;   // what is the repetitive time interval
DWORD dwCurrentIteration;   // how many iterations have we done in repetitive mode
CHAR SavedFileName[ MAX_PATH ];   // what would the file name be if we didnt iterate
HANDLE hCtrlCEvent;               // The ctrl-c event - only for repetitive mode

ULONG_PTR ProcessId;   // -1=win32.sys, 0= kernel, +n= Process ID
HANDLE OutputFile;
CHAR DumpLine[512];
CHAR OutputFileName[ MAX_PATH ];

//
// Prototypes
//

// (this is local even though it looks like it should be in ntos\rtl)

PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    );

BOOLEAN
ComputeSymbolicBackTraces(
    PRTL_PROCESS_BACKTRACES BackTraces1
    );


BOOLEAN
LoadSymbolsForModules(
    PRTL_PROCESS_MODULES Modules
    );

VOID
DumpModules(
    PRTL_PROCESS_MODULES Modules
    );

VOID
DumpBackTraces( VOID );

VOID
DumpHeaps(
    PRTL_PROCESS_HEAPS Heaps,
    BOOL fDumpSummary,
    BOOL fDumpHogs,
    BOOL fDumpTags,
    BOOL fDumpEntries
    );

VOID
DumpLocks(
    PRTL_PROCESS_LOCKS Locks
    );

VOID
DumpSystemProcesses( VOID );

VOID
DumpObjects( VOID );

VOID
DumpHandles( VOID );

ULONG
GetDhSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );


////////////////////////////////////////////////////////////////////////////////////////////
//
// CtrlCHandler
//
// Function:
//
// This function is made the control-c handleris the -r option is used.  This
// allows a final snap to be taken when you are done without waiting for the next
// iteration of the loop.
BOOL
CtrlCHandler(DWORD nCtrlType)
{
    if (nCtrlType == CTRL_C_EVENT) {
        if (hCtrlCEvent) {
            SetEvent(hCtrlCEvent);
            return TRUE;
        }
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// AdjustFileName
//
// Function:
//
// Adds the iteration number to the OutputFileName and increments the value
// if fRepetitive has been set.  Otherwise it returns
//
VOID
AdjustFileName(VOID)
{
    CHAR *pPeriod = NULL;

    if ((!fRepetitive)||(!strcmp(SavedFileName, "(stdout)"))||(dwCurrentIteration <= 0))
        return;

    pPeriod = strrchr(SavedFileName, '.');

    if (pPeriod) {
        pPeriod[0] = '\0';
        sprintf(OutputFileName, "%s_%u.%s", SavedFileName, dwCurrentIteration, (pPeriod+1));
        pPeriod[0] = '.';
    }
    else
        sprintf(OutputFileName, "%s_%u.dmp", SavedFileName, dwCurrentIteration, pPeriod);

    dwCurrentIteration++;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// DumpOutputString
//
// Function:
//
// Writes 'DumpLine' to 'OutputFile' converting newlines to End-Of-Line sequences.
// Closes OutputFile if there are any errors.
//

VOID
DumpOutputString( VOID )
{
    ULONG d;
    PCHAR s, s1;

    if (OutputFile == NULL) {
        return;
        }

    s = DumpLine;
    while (*s) {
        s1 = s;
        while (*s1 && *s1 != '\n') {
            s1 += 1;
            }

        if (s1 != s && !WriteFile( OutputFile, s, (ULONG)(s1 - s), &d, NULL )) {
            CloseHandle( OutputFile );
            OutputFile = NULL;
            return;
            }

        if (*s1 == '\n') {
            s1 += 1;
            if (!WriteFile( OutputFile, "\r\n", 2, &d, NULL )) {
                CloseHandle( OutputFile );
                OutputFile = NULL;
                return;
                }
            }
        s = s1;
        }
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// Usage
//
// Function: prints usage info to stderr and exits.
//

VOID
Usage( VOID )
{
    fputs( "Usage: DH [-p n | -p -1 | -p 0 [-k] [-o]] [-l] [-m] [-s] [-g] [-h] [-t] [r n][-f fileName]\n"
           "where: -p n - displays information about process with ClientId of n in DH_n.dmp\n"
           "       -p -1 - displays information about Win32 Subsystem process in DH_WIN32.DMP.\n"
           "       -l - displays information about locks.\n"
           "       -m - displays information about module table.\n"
           "       -s - displays summary information about heaps.\n"
           "       -g - displays information about memory hogs.\n"
           "       -h - displays information about heap entries for each heap.\n"
           "       -t - displays information about heap tags for each heap.\n"
           "       -b - displays information about stack back trace database.\n"
           "       -i - ignore information about stack back trace database.\n"
           "       -p 0 - displays information about kernel memory and objects in DH_SYS.DMP.\n"
           "       -o - displays information about object handles (only valid with -p 0).\n"
           "       -k - displays information about processes and threads (only valid with -p 0).\n"
           "       -f fileName - specifies the name of the file to write the dump to.\n"
           "       -# n - sets buffer size to n Meg\n"
           "       -- specifies the dump output should be written to stdout.\n"
           "       -r n - generates an log every n minutes with _# appended to filename\n"
           "       -umdh umdh_options (use -umdh ? for help) \n"
           "\n"
           "       Default flags for -p n are -s -g\n"
           "       Default flags for -p 0 are -m -s -g -t -k -o\n"
           , stderr);

    exit( 1 );
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// InitializeSymbolPathEnvVar
//
//
// Function: Sets _NT_SYMBOLS_PATH to point to where the symbols should be.
//

VOID
InitializeSymbolPathEnvVar( VOID )
{
    ULONG n;
    CHAR Buffer[ MAX_PATH ];

    n = GetEnvironmentVariable( "_NT_SYMBOL_PATH", Buffer, sizeof( Buffer ) );
    if (n == 0) {
        n = GetEnvironmentVariable( "SystemRoot", Buffer, sizeof( Buffer ) );
        if (n != 0) {
            strcat( Buffer, "\\Symbols" );
            SetEnvironmentVariable( "_NT_SYMBOL_PATH", Buffer );
            fprintf( stderr, "DH: Default _NT_SYMBOL_PATH to %s\n", Buffer );
            }
        }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_PROCESS_MODULES Modules;
PRTL_PROCESS_BACKTRACES BackTraces;
PUCHAR SymbolicInfoBase;
PUCHAR SymbolicInfoCurrent;
PUCHAR SymbolicInfoCommitNext;

typedef struct _PROCESS_INFO {
    LIST_ENTRY Entry;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo[ 1 ];
} PROCESS_INFO, *PPROCESS_INFO;

LIST_ENTRY ProcessListHead;

PSYSTEM_OBJECTTYPE_INFORMATION ObjectInformation;
PSYSTEM_HANDLE_INFORMATION_EX HandleInformation;
PSYSTEM_PROCESS_INFORMATION ProcessInformation;

#define MAX_TYPE_NAMES 128
PUNICODE_STRING *TypeNames;
UNICODE_STRING UnknownTypeIndex;

////////////////////////////////////////////////////////////////////////////////////////////
//
// main
//
////////////////////////////////////////////////////////////////////////////////////////////

int __cdecl
main(
    int argc,
    CHAR *argv[],
    CHAR *envp[]
    )
{
    CHAR FileNameBuffer[ 32 ];
    CHAR *FilePart;
    CHAR *s;
    NTSTATUS Status;
    PRTL_DEBUG_INFORMATION p;
    ULONG QueryDebugProcessFlags;
    ULONG HeapNumber;
    PRTL_HEAP_INFORMATION HeapInfo;
    BOOLEAN WasEnabled;
    BOOL    bSta;
    DWORD dwEventState = WAIT_TIMEOUT;
    SYSTEMTIME st;
    DWORD CompNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    CHAR CompName[MAX_COMPUTERNAME_LENGTH + 1];

    //
    // Before anything else check if we need to dispatch the command line
    // to the umdh parser.
    //

    if (argc >= 2 && _stricmp (argv[1], "-umdh") == 0) {

        UmdhMain (argc - 1, argv + 1);
    }
       

    //
    // Boost our priority in case a service is higher than us.
    //

    //EnablePrivilege( SE_INC_BASE_PRIORITY_NAME );

    bSta= SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );
    if( !bSta ) printf("SetPriorityClass failed: %d\n",GetLastError());
    bSta= SetThreadPriority( GetCurrentProcess(), THREAD_PRIORITY_HIGHEST );;
    if( !bSta ) printf("SetThreadPriority failed: %d\n",GetLastError());


    InitializeSymbolPathEnvVar();

    ProcessId = 0xFFFFFFFF;
    OutputFile = NULL;
    OutputFileName[ 0 ] = '\0';

    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (*++s) {
                switch (tolower(*s)) {
                    case 'v':
                    case 'V':
                        fVerbose = TRUE;
                        break;

                    case 'i':
                    case 'I':
                        fIgnoreBackTraces = TRUE;
                        break;

                    case 'b':
                    case 'B':
                        fDumpBackTraces = TRUE;
                        break;

                    case 'g':
                    case 'G':
                        fDumpHeapHogs = TRUE;
                        break;

                    case 'h':
                    case 'H':
                        fDumpHeapEntries = TRUE;
                        break;

                    case 't':
                    case 'T':
                        fDumpHeapTags = TRUE;
                        break;

                    case 'l':
                    case 'L':
                        fDumpLocks = TRUE;
                        break;

                    case 'm':
                    case 'M':
                        fDumpModules = TRUE;
                        break;

                    case 'o':
                    case 'O':
                        fDumpSystemObjects = TRUE;
                        break;

                    case 'k':
                    case 'K':
                        fDumpSystemProcesses = TRUE;
                        break;

                    case 's':
                    case 'S':
                        fDumpHeapSummaries = TRUE;
                        break;

                    case 'p':
                    case 'P':
                        if (--argc) {
                            ProcessId = atoi( *++argv );
                            if (ProcessId == 0) {
                                fDumpKernelModeInformation = TRUE;
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    case 'r':
                    case 'R':
                        if (--argc) {
                            dwTimeInterval = atoi( *++argv );
                            if (dwTimeInterval) {
                                fRepetitive = TRUE;
                                dwCurrentIteration = 1;

                                if (dwTimeInterval > (MAXDWORD/60000))
                                    dwTimeInterval = (MAXDWORD/60000);

                                hCtrlCEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                                SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlCHandler, TRUE);
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    case '-':
                        OutputFile = GetStdHandle( STD_OUTPUT_HANDLE );
                        break;

                    case 'f':
                    case 'F':
                        if (--argc) {
                            strcpy( OutputFileName, *++argv );
                            }
                        else {
                            Usage();
                            }
                        break;

                    case '#':
                        if (--argc)
                        {
                            BufferSize = atoi( *++argv ) * 1024 * 1024 ;
                        }
                        else
                        {
                            Usage();
                        }
                        break;

                    default:
                        Usage();
                    }
                }
            }
        else {
            Usage();
            }
        }

    if (!fDumpModules && !fDumpHeapSummaries &&
        !fDumpHeapTags && !fDumpHeapHogs && !fDumpLocks
       ) {
        if (fDumpKernelModeInformation) {
            if (!fDumpSystemObjects &&
                !fDumpSystemProcesses
               ) {
                fDumpModules = TRUE;
                fDumpHeapSummaries = TRUE;
                fDumpHeapTags = TRUE;
                fDumpHeapHogs = TRUE;
                fDumpSystemObjects = TRUE;
                fDumpSystemProcesses = TRUE;
                }
            }
        else {
            fDumpHeapSummaries = TRUE;
            fDumpHeapHogs = TRUE;
            }
        }

    if ((fDumpSystemObjects || fDumpSystemProcesses) && !fDumpKernelModeInformation) {
        Usage();
        }

    if (OutputFile == NULL) {
        if (OutputFileName[ 0 ] == '\0') {
            if ( ProcessId == -1 ) {
                    sprintf( FileNameBuffer, "DH_win32.dmp" );
                }
            else if ( ProcessId == 0 ) {
                sprintf( FileNameBuffer, "DH_sys.dmp" );
                }
            else {
                sprintf( FileNameBuffer, "DH_%u.dmp", (USHORT)ProcessId );
                }

            GetFullPathName( FileNameBuffer,
                             sizeof( OutputFileName ),
                             OutputFileName,
                             &FilePart
                           );
            }
        }
    else {
        strcpy( OutputFileName, "(stdout)" );
        }

    if (fRepetitive) {
        strcpy(SavedFileName, OutputFileName);
        AdjustFileName();
    }

    Status= RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE,
                                TRUE, FALSE, &WasEnabled );

    if( !NT_SUCCESS(Status) ) {
        fprintf(stderr,"RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE) failed: %08x\n",Status);
    }

    //
    // Get the real process id for the windows sub-system
    //

    if (ProcessId == -1) {
        HANDLE Process;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        PROCESS_BASIC_INFORMATION BasicInfo;

        RtlInitUnicodeString( &UnicodeString, L"\\WindowsSS" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &UnicodeString,
                                    0,
                                    NULL,
                                    NULL
                                  );
        Status = NtOpenProcess( &Process,
                                PROCESS_ALL_ACCESS,
                                &ObjectAttributes,
                                NULL
                              );
        if (NT_SUCCESS(Status)) {
            Status = NtQueryInformationProcess( Process,
                                                ProcessBasicInformation,
                                                (PVOID)&BasicInfo,
                                                sizeof(BasicInfo),
                                                NULL
                                              );
            NtClose( Process );
        }

        if (!NT_SUCCESS(Status)) {
            fprintf( stderr,"Unable to access Win32 server process - %08x", Status );
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                fprintf( stderr,"\nUse GFLAGS.EXE to ""Enable debugging of Win32 Subsystem"" and reboot.\n" );
            }
            exit( 1 );
        }

        ProcessId = BasicInfo.UniqueProcessId;
    }


    //
    // Compute QueryDebugProcessFlags
    //

    QueryDebugProcessFlags = 0;
    if (fDumpModules) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_MODULES;
    }

    if (fDumpBackTraces || fDumpHeapHogs) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_BACKTRACES | RTL_QUERY_PROCESS_MODULES;
    }

    if (fDumpHeapSummaries) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_HEAP_SUMMARY;
    }

    if (fDumpHeapTags) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_HEAP_TAGS;
    }

    if (fDumpHeapEntries || fDumpHeapHogs) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_HEAP_ENTRIES;
    }

    if (fDumpLocks) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_LOCKS;
    }

    // Starting the main loop that does most of the work.  This will only
    // execute once unless fRepetitive is set
    do {
        //
        // Open the output file
        //
        fprintf( stderr, "DH: Writing dump output to %s", OutputFileName );
        if (OutputFile == NULL) {
            OutputFile = CreateFile( OutputFileName,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL
                                    );
            if ( OutputFile == INVALID_HANDLE_VALUE ) {
                fprintf( stderr, " - unable to open, error == %u\n", GetLastError() );
                exit( 1 );
            }
        }
        fprintf( stderr, "\n" );

        //Output a Timestamp to the first line of the file
        GetLocalTime(&st);
        GetComputerName(CompName, &CompNameLength);
        sprintf( DumpLine, "DH: Logtime %02u/%02u/%4u-%02u:%02u - Machine=%s - PID=%u\n", st.wMonth,
                 st.wDay, st.wYear, (st.wHour <= 12) ? st.wHour : (st.wHour - 12), st.wMinute,
                 CompName, ProcessId);
        DumpOutputString();

        if (fDumpKernelModeInformation) {
            p = RtlQuerySystemDebugInformation( QueryDebugProcessFlags );
            if (p == NULL) {
                fprintf( stderr, "DH: Unable to query kernel mode information.\n" );
                exit( 1 );
            }
            Status = STATUS_SUCCESS;
        }
        else {
            p = RtlCreateQueryDebugBuffer( BufferSize, FALSE );
            printf("RtlCreateQueryDebugBuffer returns: %p\n",p);
            Status = RtlQueryProcessDebugInformation( (HANDLE)ProcessId,
                                                    QueryDebugProcessFlags,
                                                    p
                                                    );

            if (NT_SUCCESS( Status )) {
                printf("RtpQueryProcessDebugInformation\n");
                printf("  ProcessId: %d  ProcessFlags: %08x  Status %08x\n",
                    ProcessId, QueryDebugProcessFlags, Status );
                if ((fDumpBackTraces || fDumpHeapHogs) && p->BackTraces == NULL) {
                    printf("p->BackTraces: %p\n",p->BackTraces);
                    fputs( "DH: Unable to query stack back trace information\n"
                            "    Be sure target process was launched with the\n"
                            "    'Create user mode stack trace DB' enabled\n"
                            "    Use the GFLAGS.EXE application to do this.\n"
                            , stderr);
                }

                if (fDumpHeapTags) {
                    HeapInfo = &p->Heaps->Heaps[ 0 ];
                    for (HeapNumber = 0; HeapNumber < p->Heaps->NumberOfHeaps; HeapNumber++) {
                        if (HeapInfo->Tags != NULL && HeapInfo->NumberOfTags != 0) {
                            break;
                        }
                    }

                    if (HeapNumber == p->Heaps->NumberOfHeaps) {
                        fputs( "DH: Unable to query heap tag information\n"
                                "    Be sure target process was launched with the\n"
                                "    'Enable heap tagging' option enabled.\n"
                                "    Use the GFLAGS.EXE application to do this.\n"
                                , stderr);
                    }
                }
            }
            else {
                fprintf(stderr,"RtlQueryProcessDebugInformation failed: %08x\n",Status);
            }
        }

        if (NT_SUCCESS( Status )) {
            if (!fIgnoreBackTraces &&
                p->Modules != NULL &&
                LoadSymbolsForModules( p->Modules ) &&
                p->BackTraces != NULL
            ) {
                ComputeSymbolicBackTraces( p->BackTraces );
            }

            if (fDumpModules) {
                DumpModules( p->Modules );
            }

            if (!fIgnoreBackTraces && fDumpBackTraces) {
                DumpBackTraces();
            }

            if (p->Heaps) {
                DumpHeaps( p->Heaps, fDumpHeapSummaries, fDumpHeapHogs, fDumpHeapTags, fDumpHeapEntries );
            }

            if (fDumpLocks) {
                DumpLocks( p->Locks );
            }

            if (fDumpSystemObjects) {
                DumpObjects();
                DumpHandles();
            }

            if (fDumpSystemProcesses) {
                DumpSystemProcesses();
            }
        }
        else {
            fprintf( stderr, "Failed to query process, %x\n", Status );
        }

        RtlDestroyQueryDebugBuffer( p );

        // Are we in repetitive mode
        if (fRepetitive) {
            if (hCtrlCEvent)
                dwEventState = WaitForSingleObject(hCtrlCEvent,0);

            if (dwEventState == WAIT_OBJECT_0)
                fRepetitive = FALSE;
            else {
                // Lets let the user know we are not hung
                GetLocalTime(&st);
                printf("Starting at %u:%02u - Sleeping for %u Minute(s)\n",
                        (st.wHour <= 12) ? st.wHour : (st.wHour - 12), st.wMinute, dwTimeInterval);

                // lets sleep for our time interval unless signaled with a ctrl-c
                if (hCtrlCEvent)
                    dwEventState = WaitForSingleObject(hCtrlCEvent,(dwTimeInterval * 60000));
                else
                    Sleep(dwTimeInterval * 60000);

                // Don't want to close our handle to stdout
                if (strcmp(SavedFileName, "(stdout)")){
                    CloseHandle( OutputFile );
                    OutputFile = NULL;
                }

                // Set up for the next iteration.
                AdjustFileName();

                //Adjust the pointers to this nasty global memory blob
                VirtualFree(SymbolicInfoBase, 4096*4096, MEM_DECOMMIT);
                SymbolicInfoCurrent = SymbolicInfoBase;
                SymbolicInfoCommitNext = SymbolicInfoBase;
            }
        }
    } while (fRepetitive); //do loop


    CloseHandle( OutputFile );
    VirtualFree(SymbolicInfoBase, 0, MEM_RELEASE);

    if (hCtrlCEvent)
        CloseHandle(hCtrlCEvent);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////

BOOL
SymbolCallbackFunction(
    HANDLE  hProcess,
    ULONG   ActionCode,
#ifdef _WIN64
    ULONG_PTR  CallbackData,
    ULONG_PTR  UserContext
#else
    PVOID   CallbackData,
    PVOID   UserContext
#endif
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD  idsl;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD) CallbackData;

    switch( ActionCode ) {
        case CBA_DEFERRED_SYMBOL_LOAD_START:
            _strlwr( idsl->FileName );
            fprintf( stderr, "Loading symbols for 0x%08x %16s - ",
                    idsl->BaseOfImage,
                    idsl->FileName
                  );
            fflush( stderr );
            return TRUE;

        case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
            fprintf( stderr, "*** Error: could not load symbols\n", idsl->FileName );
            fflush( stderr );
            return TRUE;

        case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
            fprintf( stderr, "done\n" );
            fflush( stderr );
            return TRUE;

        case CBA_SYMBOLS_UNLOADED:
            fprintf( stderr, "Symbols unloaded for 0x%08x %s\n",
                    idsl->BaseOfImage,
                    idsl->FileName
                  );
            fflush( stderr );
            return TRUE;

        default:
            return FALSE;
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////


#define MAX_SYMNAME_SIZE  1024
#define SYM_BUFFER_SIZE   (sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE)
CHAR symBuffer[SYM_BUFFER_SIZE];
PIMAGEHLP_SYMBOL sym;
PIMAGEHLP_SYMBOL sym = (PIMAGEHLP_SYMBOL) symBuffer;

BOOLEAN
LoadSymbolsForModules(
    PRTL_PROCESS_MODULES Modules1
    )
{
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    ULONG ModuleNumber;
    PVOID MaxUserModeAddress;

    SymSetOptions( SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_NO_CPP );
    sym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    sym->MaxNameLength = MAX_SYMNAME_SIZE;
    SymInitialize( (HANDLE)ProcessId, NULL, FALSE );
    SymRegisterCallback( (HANDLE)ProcessId, SymbolCallbackFunction, 0 );

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &MaxUserModeAddress,
                                             sizeof(MaxUserModeAddress),
                                             NULL))) {
        // assume usermode is the low half of the address space
        MaxUserModeAddress = (PVOID)MAXLONG_PTR;
    }

    Modules = Modules1;
    ModuleInfo = &Modules->Modules[ 0 ];
    for (ModuleNumber=0; ModuleNumber<Modules->NumberOfModules; ModuleNumber++) {
        if (!fDumpKernelModeInformation || ModuleInfo->ImageBase >= MaxUserModeAddress) {
            SymLoadModule( (HANDLE)ProcessId,
                           NULL,
                           ModuleInfo->FullPathName,
                           NULL,
                           (ULONG_PTR)ModuleInfo->ImageBase,
                           ModuleInfo->ImageSize
                         );
        }

        ModuleInfo += 1;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////


static CHAR DllNameBuffer[ MAX_PATH ];

PCHAR
FindDllHandleName(
    PVOID DllHandle
    )
{
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    LPSTR DllName;
    ULONG ModuleNumber;

    ModuleInfo = &Modules->Modules[ 0 ];
    for (ModuleNumber=0; ModuleNumber<Modules->NumberOfModules; ModuleNumber++) {
        if (ModuleInfo->ImageBase == DllHandle) {
            strcpy( DllNameBuffer, &ModuleInfo->FullPathName[ ModuleInfo->OffsetToFileName ] );
            if ((DllName = strchr( DllNameBuffer, '.' )) != NULL) {
                *DllName = '\0';
            }
            return DllNameBuffer;
        }

        ModuleInfo += 1;
    }

    return "UNKNOWN";
}

////////////////////////////////////////////////////////////////////////////////////////////


PUCHAR
SaveSymbolicBackTrace(
    IN ULONG Depth,
    IN PVOID BackTrace[]
    )
{
    NTSTATUS Status;
    ULONG i, FileNameLength, SymbolOffset;
    PCHAR s, SymbolicBackTrace;

    if (Depth == 0) {
        return NULL;
    }

    if (SymbolicInfoBase == NULL) {
        SymbolicInfoBase = (PUCHAR)VirtualAlloc( NULL,
                                                 4096 * 4096,
                                                 MEM_RESERVE,
                                                 PAGE_READWRITE
                                               );
        if (SymbolicInfoBase == NULL) {
            fprintf(stderr,"DH: VirtualAlloc(4096*4096...) failed: GetLastError()= %d\n",GetLastError());
            return NULL;
        }

        SymbolicInfoCurrent = SymbolicInfoBase;
        SymbolicInfoCommitNext = SymbolicInfoBase;
    }


    i = 4096;
    if ((SymbolicInfoCurrent + i - 1) > SymbolicInfoCommitNext) {
        if (!VirtualAlloc( SymbolicInfoCommitNext,
                           i,
                           MEM_COMMIT,
                           PAGE_READWRITE
                         )
           ) {
            fprintf( stderr, "DH: Exceeded 16MB of space for symbolic stack back traces.\n" );
            fprintf( stderr, "DH: virtualalloc(%p,%d...)\n",SymbolicInfoCommitNext,i);
            return NULL;
        }
        SymbolicInfoCommitNext += i;
    }

    s = SymbolicInfoCurrent;
    SymbolicBackTrace = s;
    for (i=0; i<Depth; i++) {
        if (BackTrace[ i ] == 0) {
            break;
        }

        s += GetDhSymbolicNameForAddress( (HANDLE)ProcessId, (ULONG_PTR)BackTrace[ i ], s, MAX_PATH );
        *s++ = '\0';
    }

    *s++ = '\0';
    SymbolicInfoCurrent = s;

    return SymbolicBackTrace;
}


////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
ComputeSymbolicBackTraces(
    PRTL_PROCESS_BACKTRACES BackTraces1
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    ULONG BackTraceIndex, NumberOfBackTraces;

    BackTraces = BackTraces1;

    NumberOfBackTraces = BackTraces->NumberOfBackTraces;
    BackTraceInfo = &BackTraces->BackTraces[ 0 ];
    BackTraceIndex = 0;
    while (NumberOfBackTraces--) {
        if (!(BackTraceIndex++ % 50)) {
            printf( "Getting symbols for Stack Back Trace %05u\r", BackTraceIndex );
        }
        BackTraceInfo->SymbolicBackTrace = SaveSymbolicBackTrace( BackTraceInfo->Depth,
                                                                  &BackTraceInfo->BackTrace[ 0 ]
                                                                );
        BackTraceInfo += 1;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_PROCESS_BACKTRACE_INFORMATION
FindBackTrace(
    IN ULONG BackTraceIndex
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;

    if (!BackTraceIndex ||
        BackTraces == NULL ||
        BackTraceIndex >= BackTraces->NumberOfBackTraces
       ) {
        return( NULL );
    }

    return &BackTraces->BackTraces[ BackTraceIndex-1 ];
}


////////////////////////////////////////////////////////////////////////////////////////////

VOID
FormatHeapHeader(
    PRTL_HEAP_INFORMATION HeapInfo,
    PCHAR Title
    )
{
    CHAR TempBuffer[ 64 ];
    PCHAR s;

    if (HeapInfo->BaseAddress == (PVOID)IntToPtr(SystemPagedPoolInformation)) {
        s = "Paged Pool";
    }
    else
    if (HeapInfo->BaseAddress == (PVOID)IntToPtr(SystemNonPagedPoolInformation)) {
        s = "NonPaged Pool";
    }
    else {
        sprintf( TempBuffer, "Heap %p", HeapInfo->BaseAddress );
        s = TempBuffer;
    }

    sprintf( DumpLine, "\n\n*********** %s %s ********************\n\n", s, Title );
    DumpOutputString();
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpModules(
    PRTL_PROCESS_MODULES Modules
    )
{
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    ULONG ModuleNumber;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping module information.\n" );
    }

    ModuleInfo = &Modules->Modules[ 0 ];
    sprintf( DumpLine, "\n\n*********** Module Information ********************\n\n" );
    DumpOutputString();
    sprintf( DumpLine, "Number of loaded modules: %u\n", Modules->NumberOfModules );
    DumpOutputString();

    ModuleNumber = 0;
    while (ModuleNumber++ < Modules->NumberOfModules) {
        sprintf( DumpLine, "Module%02u (%02u,%02u,%02u): [%p .. %p] %s\n",
                 ModuleNumber,
                 (ULONG)ModuleInfo->LoadOrderIndex,
                 (ULONG)ModuleInfo->InitOrderIndex,
                 (ULONG)ModuleInfo->LoadCount,
                 ModuleInfo->ImageBase,
                 (ULONG_PTR)ModuleInfo->ImageBase + ModuleInfo->ImageSize - 1,
                 ModuleInfo->FullPathName
               );
        DumpOutputString();

        ModuleInfo++;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpBackTraces( VOID )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    ULONG BackTraceIndex;
    CHAR *s;

    if (BackTraces == NULL) {
        return;
    }

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping back trace information.\n" );
    }

    sprintf( DumpLine, "\n\n*********** BackTrace Information ********************\n\n" );
    DumpOutputString();
    sprintf( DumpLine, "Number of back traces: %u  Looked Up Count: %u\n",
             BackTraces->NumberOfBackTraces - 1,
             BackTraces->NumberOfBackTraceLookups
           );
    DumpOutputString();
    sprintf( DumpLine, "Reserved Memory: %08x  Committed Memory: %08x\n",
             BackTraces->ReservedMemory,
             BackTraces->CommittedMemory
           );
    DumpOutputString();



    BackTraceInfo = BackTraces->BackTraces;
    for (BackTraceIndex=0; BackTraceIndex<BackTraces->NumberOfBackTraces; BackTraceIndex++) {
        sprintf( DumpLine, "BackTrace%05lu\n", BackTraceInfo->Index );
        DumpOutputString();
        if (BackTraceInfo->SymbolicBackTrace == NULL) {
            BackTraceInfo->SymbolicBackTrace = SaveSymbolicBackTrace( BackTraceInfo->Depth,
                                                                      &BackTraceInfo->BackTrace[ 0 ]
                                                                    );
        }

        if (s = BackTraceInfo->SymbolicBackTrace) {
            while (*s) {
                sprintf( DumpLine, "        %s\n", s );
                DumpOutputString();
                while (*s++) {
                }
            }
        }

        BackTraceInfo += 1;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////

typedef struct _VA_CHUNK {
    ULONG_PTR Base;
    ULONG_PTR End;
    ULONG_PTR Committed;
} VA_CHUNK, *PVA_CHUNK;

VOID
DumpHeapSummary(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PUCHAR s;
    PRTL_HEAP_ENTRY p;
    PCHAR HeapEntryAddress;
    ULONG i, HeapEntryNumber;
    SIZE_T AddressSpaceUsed;
    ULONG NumberOfChunks;
    ULONG MaxNumberOfChunks;
    PVA_CHUNK Chunks, NewChunks;

    MaxNumberOfChunks = 0;
    NumberOfChunks = 0;
    Chunks = NULL;
    p = HeapInfo->Entries;
    if (p != NULL && HeapInfo->NumberOfEntries != 0) {
        HeapEntryAddress = NULL;
        for (HeapEntryNumber=0; HeapEntryNumber<HeapInfo->NumberOfEntries; HeapEntryNumber++) {
            if (p->Flags != 0xFF && p->Flags & RTL_HEAP_SEGMENT) {
                if (NumberOfChunks == MaxNumberOfChunks) {
                    MaxNumberOfChunks += 16;
                    NewChunks = RtlAllocateHeap( RtlProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 MaxNumberOfChunks * sizeof( VA_CHUNK )
                                               );
                    if (Chunks != NULL) {
                        if (NewChunks != NULL) {
                            RtlMoveMemory( NewChunks, Chunks, NumberOfChunks * sizeof( VA_CHUNK ) );
                        }
                        RtlFreeHeap( RtlProcessHeap(), 0, Chunks );
                    }
                    Chunks = NewChunks;

                    if (Chunks == NULL) {
                        NumberOfChunks = 0;
                        break;
                    }
                }

                HeapEntryAddress = (PCHAR)p->u.s2.FirstBlock;
                Chunks[ NumberOfChunks ].Base = (ULONG_PTR)HeapEntryAddress & ~(4096-1);
                if (((ULONG_PTR)HeapEntryAddress - (ULONG_PTR)Chunks[ NumberOfChunks ].Base) < 32) {
                    HeapEntryAddress = (PCHAR)Chunks[ NumberOfChunks ].Base;
                }
                Chunks[ NumberOfChunks ].Committed = p->u.s2.CommittedSize;
                NumberOfChunks += 1;
            }
            else {
                HeapEntryAddress += p->Size;
                if (NumberOfChunks > 0) {
                    Chunks[ NumberOfChunks-1 ].End = (ULONG_PTR)HeapEntryAddress;
                }
            }

            p += 1;
        }
    }

    sprintf( DumpLine, "    Flags: %08x\n", HeapInfo->Flags );
    DumpOutputString();

    sprintf( DumpLine, "    Number Of Entries: %u\n", HeapInfo->NumberOfEntries );
    DumpOutputString();

    sprintf( DumpLine, "    Number Of Tags: %u\n", HeapInfo->NumberOfTags );
    DumpOutputString();

    sprintf( DumpLine, "    Bytes Allocated: %08x\n", HeapInfo->BytesAllocated );
    DumpOutputString();

    sprintf( DumpLine, "    Bytes Committed: %08x\n", HeapInfo->BytesCommitted );
    DumpOutputString();

    sprintf( DumpLine, "    Total FreeSpace: %08x\n", HeapInfo->BytesCommitted -
                                                      HeapInfo->BytesAllocated );
    DumpOutputString();

    sprintf( DumpLine, "    Number of Virtual Address chunks used: %u\n", NumberOfChunks );
    DumpOutputString();

    AddressSpaceUsed = 0;
    for (i=0; i<NumberOfChunks; i++) {
        sprintf( DumpLine, "        Chunk[ %2u ]: [%08x .. %08x) %08x committed\n",
                           i+1,
                           Chunks[i].Base,
                           Chunks[i].End,
                           Chunks[i].Committed
               );
        DumpOutputString();
        AddressSpaceUsed += (Chunks[i].End - Chunks[i].Base);
    }

    sprintf( DumpLine, "    Address Space Used: %08x\n", AddressSpaceUsed );
    DumpOutputString();

    sprintf( DumpLine, "    Entry Overhead: %u\n", HeapInfo->EntryOverhead );
    DumpOutputString();

    sprintf( DumpLine, "    Creator:  (Backtrace%05lu)\n", HeapInfo->CreatorBackTraceIndex );
    DumpOutputString();
    BackTraceInfo = FindBackTrace( HeapInfo->CreatorBackTraceIndex );
    if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
        while (*s) {
            sprintf( DumpLine, "        %s\n", s );
            DumpOutputString();
            while (*s++) {
            }
        }
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

__inline int DiffSizeT(SIZE_T s1, SIZE_T s2)
{
    if (s1 == s2)
        return 0;

    if (s1 > s2)
        return -1;
    else
        return 1;
}


////////////////////////////////////////////////////////////////////////////////////////////

int
__cdecl
CmpTagsRoutine(
    const void *Element1,
    const void *Element2
    )
{
    return( DiffSizeT((*(PRTL_HEAP_TAG *)Element2)->BytesAllocated,
                      (*(PRTL_HEAP_TAG *)Element1)->BytesAllocated)
          );

}

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_HEAP_TAG
FindTagEntry(
    PRTL_HEAP_INFORMATION HeapInfo,
    ULONG TagIndex
    )
{
    if (TagIndex == 0 || (TagIndex & ~HEAP_PSEUDO_TAG_FLAG) >= HeapInfo->NumberOfTags) {
        return NULL;
    }
    else {
        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {
            return HeapInfo->Tags + (TagIndex & ~HEAP_PSEUDO_TAG_FLAG);
        }
        else {
            return HeapInfo->Tags + HeapInfo->NumberOfPseudoTags + TagIndex;
        }
    }
}



////////////////////////////////////////////////////////////////////////////////////////////


VOID
DumpHeapTags(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_HEAP_TAG *TagEntries, TagEntry;
    ULONG TagIndex;
    PUCHAR s;
    UCHAR HeapName[ 64 ];

    if (HeapInfo->Tags == NULL || HeapInfo->NumberOfTags == 0) {
        return;
    }

    TagEntries = RtlAllocateHeap( RtlProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  HeapInfo->NumberOfTags * sizeof( PRTL_HEAP_TAG )
                                );
    if (TagEntries == NULL) {
        fprintf(stderr,"DH: RtlAllocateHeap failed at %d\n",__LINE__ );
        return;
    }

    for (TagIndex=1; TagIndex<HeapInfo->NumberOfTags; TagIndex++) {
        TagEntries[ TagIndex-1 ] = &HeapInfo->Tags[ TagIndex ];
    }

    qsort( (void *)TagEntries,
           HeapInfo->NumberOfTags - 1,
           sizeof( PRTL_HEAP_TAG ),
           CmpTagsRoutine
    );

    TagEntry = &HeapInfo->Tags[ HeapInfo->NumberOfPseudoTags ];
    if (HeapInfo->NumberOfTags > HeapInfo->NumberOfPseudoTags &&
        TagEntry->TagName[ 0 ] != UNICODE_NULL
       ) {
        sprintf( HeapName, "Tags for %ws heap", TagEntry->TagName );
    }
    else {
        sprintf( HeapName, "Tags" );
    }
    FormatHeapHeader( HeapInfo, HeapName );

    sprintf( DumpLine, "     Allocs     Frees     Diff     Bytes    Tag\n" );
    DumpOutputString();
    for (TagIndex=1; TagIndex<(HeapInfo->NumberOfTags-1); TagIndex++) {
        TagEntry = TagEntries[ TagIndex ];
        if (TagEntry->BytesAllocated != 0) {
            sprintf( DumpLine, "    %08x  %08x  %08x  %08x  %ws\n",
                     TagEntry->NumberOfAllocations,
                     TagEntry->NumberOfFrees,
                     TagEntry->NumberOfAllocations - TagEntry->NumberOfFrees,
                     TagEntry->BytesAllocated,
                     TagEntry->TagName
                   );
            DumpOutputString();
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, TagEntries );
    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

typedef struct _HEAP_CALLER {
    SIZE_T TotalAllocated;
    USHORT NumberOfAllocations;
    USHORT CallerBackTraceIndex;
    PRTL_HEAP_TAG TagEntry;
} HEAP_CALLER, *PHEAP_CALLER;

int
__cdecl
CmpCallerRoutine(
    const void *Element1,
    const void *Element2
    )
{
    return( DiffSizeT(((PHEAP_CALLER)Element2)->TotalAllocated,
                      ((PHEAP_CALLER)Element1)->TotalAllocated)
          );
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpHeapHogs(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PUCHAR s;
    ULONG BackTraceNumber, HeapEntryNumber;
    USHORT TagIndex;
    PRTL_HEAP_ENTRY p;
    PHEAP_CALLER HogList;

    if (BackTraces == NULL) {
        return;
    }

    HogList = (PHEAP_CALLER)VirtualAlloc( NULL,
                                          BackTraces->NumberOfBackTraces *
                                            sizeof( HEAP_CALLER ),
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    if (HogList == NULL) {
        fprintf(stderr,"DH: VirtualAlloc failed at %d  size: %d\n",__LINE__,
                        BackTraces->NumberOfBackTraces * sizeof( HEAP_CALLER ) );
        return;
    }

    p = HeapInfo->Entries;
    if (p == NULL) {
        VirtualFree( HogList, 0, MEM_RELEASE );
        return;
    }

    for (HeapEntryNumber=0; HeapEntryNumber<HeapInfo->NumberOfEntries; HeapEntryNumber++) {
        if (p->Flags & RTL_HEAP_BUSY) {
            if (p->AllocatorBackTraceIndex >= BackTraces->NumberOfBackTraces) {
                p->AllocatorBackTraceIndex = 0;
            }

            HogList[ p->AllocatorBackTraceIndex ].NumberOfAllocations++;
            HogList[ p->AllocatorBackTraceIndex ].TotalAllocated += p->Size;
            if (p->u.s1.Tag != 0) {
                HogList[ p->AllocatorBackTraceIndex ].TagEntry = FindTagEntry( HeapInfo, p->u.s1.Tag );
            }
            else
            if (HeapInfo->NumberOfPseudoTags != 0) {
                TagIndex = HEAP_PSEUDO_TAG_FLAG;
                if (p->Size < (HeapInfo->NumberOfPseudoTags * HeapInfo->PseudoTagGranularity)) {
                    TagIndex |= (p->Size /  HeapInfo->PseudoTagGranularity);
                }

                HogList[ p->AllocatorBackTraceIndex ].TagEntry = FindTagEntry( HeapInfo, TagIndex );
            }
        }

        p++;
    }

    for (BackTraceNumber = 1;
         BackTraceNumber < BackTraces->NumberOfBackTraces;
         BackTraceNumber++
        ) {
        HogList[ BackTraceNumber ].CallerBackTraceIndex = (USHORT)BackTraceNumber;
    }

    qsort( (void *)HogList,
           BackTraces->NumberOfBackTraces,
           sizeof( HEAP_CALLER ),
           CmpCallerRoutine
         );

    FormatHeapHeader( HeapInfo, "Hogs" );

    for (BackTraceNumber=0;
         BackTraceNumber<BackTraces->NumberOfBackTraces;
         BackTraceNumber++
        ) {
        if (HogList[ BackTraceNumber ].TotalAllocated != 0) {
            BackTraceInfo = FindBackTrace( HogList[ BackTraceNumber ].CallerBackTraceIndex );
            sprintf( DumpLine, "%08x bytes",
                     HogList[ BackTraceNumber ].TotalAllocated
                   );
            DumpOutputString();

            if (HogList[ BackTraceNumber ].NumberOfAllocations > 1) {
                sprintf( DumpLine, " in %04lx allocations (@ %04lx)",
                             HogList[ BackTraceNumber ].NumberOfAllocations,
                             HogList[ BackTraceNumber ].TotalAllocated /
                                HogList[ BackTraceNumber ].NumberOfAllocations
                       );
                DumpOutputString();
            }

            sprintf( DumpLine, " by: BackTrace%05lu",
                     BackTraceInfo ? BackTraceInfo->Index : 99999
                   );
            DumpOutputString();

            if (HogList[ BackTraceNumber ].TagEntry != NULL) {
                sprintf( DumpLine, "  (%ws)\n", HogList[ BackTraceNumber ].TagEntry->TagName );
            }
            else {
                sprintf( DumpLine, "\n" );
            }
            DumpOutputString();

            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    sprintf( DumpLine, "        %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }

            sprintf( DumpLine, "    \n" );
            DumpOutputString();
        }
    }

    VirtualFree( HogList, 0, MEM_RELEASE );
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpHeapEntries(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PUCHAR s;
    PRTL_HEAP_ENTRY p;
    PRTL_HEAP_TAG TagEntry;
    PCHAR HeapEntryAddress;
    SIZE_T HeapEntrySize;
    ULONG HeapEntryNumber;

    p = HeapInfo->Entries;
    if (p == NULL || HeapInfo->NumberOfEntries == 0) {
        return;
    }

    FormatHeapHeader( HeapInfo, "Entries" );

    HeapEntryAddress = NULL;
    for (HeapEntryNumber=0; HeapEntryNumber<HeapInfo->NumberOfEntries; HeapEntryNumber++) {
        if (p->Flags != 0xFF && p->Flags & RTL_HEAP_SEGMENT) {
            HeapEntryAddress = (PCHAR)p->u.s2.FirstBlock;
            sprintf( DumpLine, "\n[%p : %p]\n",
                     (ULONG_PTR)HeapEntryAddress & ~(4096-1),
                     p->u.s2.CommittedSize
                   );

            DumpOutputString();
        }
        else {
            HeapEntrySize = p->Size;
            if (p->Flags == RTL_HEAP_UNCOMMITTED_RANGE) {
                sprintf( DumpLine, "%p: %p - UNCOMMITTED\n",
                         HeapEntryAddress,
                         HeapEntrySize
                       );
                DumpOutputString();
            }
            else
            if (p->Flags & RTL_HEAP_BUSY) {
                s = DumpLine;
                s += sprintf( s, "%p: %p - BUSY [%02x]",
                              HeapEntryAddress,
                              HeapEntrySize,
                              p->Flags
                            );


                TagEntry = FindTagEntry( HeapInfo, p->u.s1.Tag );
                if (TagEntry != NULL) {
                    s += sprintf( s, "(%ws)", TagEntry->TagName );
                }

                if (BackTraces != NULL) {
                    s += sprintf( s, " (BackTrace%05lu)",
                                  p->AllocatorBackTraceIndex
                                );
                }

                if (p->Flags & RTL_HEAP_SETTABLE_VALUE &&
                    p->Flags & RTL_HEAP_SETTABLE_FLAG1
                   ) {
                    s += sprintf( s, " (Handle: %x)", p->u.s1.Settable );
                }

                if (p->Flags & RTL_HEAP_SETTABLE_FLAG2) {
                    s += sprintf( s, " (DDESHARE)" );
                }

                if (p->Flags & RTL_HEAP_PROTECTED_ENTRY) {
                    s += sprintf( s, " (Protected)" );
                }

                sprintf( s, "\n" );
                DumpOutputString();
            }
            else {
                sprintf( DumpLine, "%p: %p - FREE\n",
                         HeapEntryAddress,
                         HeapEntrySize
                       );
                DumpOutputString();
            }

            sprintf( DumpLine, "\n" );
            DumpOutputString();

            HeapEntryAddress += HeapEntrySize;
        }

        p++;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpHeaps(
    PRTL_PROCESS_HEAPS Heaps,
    BOOL fDumpSummary,
    BOOL fDumpHogs,
    BOOL fDumpTags,
    BOOL fDumpEntries
    )
{
    ULONG HeapNumber;
    PRTL_HEAP_INFORMATION HeapInfo;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping heap information.\n" );
    }

    HeapInfo = &Heaps->Heaps[ 0 ];
    for (HeapNumber = 0; HeapNumber < Heaps->NumberOfHeaps; HeapNumber++) {
        FormatHeapHeader( HeapInfo, "Information" );

        if (fDumpSummary) {
            DumpHeapSummary( HeapInfo );
        }

        if (fDumpTags) {
            DumpHeapTags( HeapInfo );
        }

        if (fDumpHogs) {
            DumpHeapHogs( HeapInfo );
        }

        if (fDumpEntries) {
            DumpHeapEntries( HeapInfo );
        }

        HeapInfo += 1;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpLocks(
    PRTL_PROCESS_LOCKS Locks
    )
{
    PRTL_PROCESS_LOCK_INFORMATION LockInfo;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    ULONG LockNumber;
    PUCHAR s;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping lock information.\n" );
    }

    sprintf( DumpLine, "\n\n*********** Lock Information ********************\n\n" );
    DumpOutputString();
    if (Locks == NULL) {
        return;
    }

    sprintf( DumpLine, "NumberOfLocks == %u\n", Locks->NumberOfLocks );
    DumpOutputString();
    LockInfo = &Locks->Locks[ 0 ];
    LockNumber = 0;
    while (LockNumber++ < Locks->NumberOfLocks) {
        sprintf( DumpLine, "Lock%u at %p (%s)\n",
                 LockNumber,
                 LockInfo->Address,
                 LockInfo->Type == RTL_CRITSECT_TYPE ? "CriticalSection" : "Resource"
               );
        DumpOutputString();

        sprintf( DumpLine, "    Contention: %u\n", LockInfo->ContentionCount );
        DumpOutputString();
        sprintf( DumpLine, "    Usage: %u\n", LockInfo->EntryCount );
        DumpOutputString();
        if (LockInfo->CreatorBackTraceIndex != 0) {
            sprintf( DumpLine, "    Creator:  (Backtrace%05lu)\n", LockInfo->CreatorBackTraceIndex );
            DumpOutputString();
            BackTraceInfo = FindBackTrace( LockInfo->CreatorBackTraceIndex );
            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    sprintf( DumpLine, "        %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }
        }

        if (LockInfo->OwningThread) {
            sprintf( DumpLine, "    Owner:   (ThreadID == %p)\n", LockInfo->OwningThread );
            DumpOutputString();
        }

        sprintf( DumpLine, "\n" );
        DumpOutputString();
        LockInfo++;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////

#define RTL_NEW( p ) RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *p ) )

BOOLEAN
LoadSystemModules(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemBackTraces(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemPools(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemTags(
    PRTL_HEAP_INFORMATION PagedPoolInfo,
    PRTL_HEAP_INFORMATION NonPagedPoolInfo
    );

BOOLEAN
LoadSystemPool(
    PRTL_HEAP_INFORMATION HeapInfo,
    SYSTEM_INFORMATION_CLASS SystemInformationClass
    );

BOOLEAN
LoadSystemLocks(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    );

PSYSTEM_PROCESS_INFORMATION
FindProcessInfoForCid(
    IN HANDLE UniqueProcessId
    );

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    )
{
    PRTL_DEBUG_INFORMATION Buffer;

    Buffer = RTL_NEW( Buffer );
    if (Buffer == NULL) {
        fprintf(stderr,"DH: allocation failure for %d byte at line %d\n",sizeof(*Buffer),__LINE__);
        return NULL;
    }

    if ((Flags & RTL_QUERY_PROCESS_MODULES) != 0 && !LoadSystemModules( Buffer )) {
        fputs( "DH: Unable to query system module list.\n", stderr );
    }

    if ((Flags & RTL_QUERY_PROCESS_BACKTRACES) != 0 && !LoadSystemBackTraces( Buffer )) {
        fputs( "DH: Unable to query system back trace information.\n"
               "    Be sure the system was booted with the\n"
               "    'Create kernel mode stack trace DB' enabled\n"
               "    Use the GFLAGS.EXE application to do this.\n"
               , stderr);
    }

    if ((Flags & (RTL_QUERY_PROCESS_HEAP_SUMMARY |
                  RTL_QUERY_PROCESS_HEAP_TAGS |
                  RTL_QUERY_PROCESS_HEAP_ENTRIES
                 )
        ) != 0 &&
        !LoadSystemPools( Buffer )
       ) {
        fputs( "DH: Unable to query system pool information.\n", stderr );
    }

    if ((Flags & RTL_QUERY_PROCESS_LOCKS) != 0 && !LoadSystemLocks( Buffer )) {
        fputs( "DH: Unable to query system lock information.\n", stderr);
    }

    if (fDumpSystemObjects && !LoadSystemObjects( Buffer )) {
        fputs( "DH: Unable to query system object information.\n", stderr );
    }

    if (fDumpSystemObjects && !LoadSystemHandles( Buffer )) {
        fputs( "DH: Unable to query system handle information.\n", stderr );
    }

    if (!LoadSystemProcesses( Buffer )) {
        fputs( "DH: Unable to query system process information.\n", stderr );
    }

    return Buffer;
}

////////////////////////////////////////////////////////////////////////////////////////////


PVOID
BufferAlloc(
    IN OUT SIZE_T *Length
    )
{
    PVOID Buffer;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    Buffer = VirtualAlloc( NULL,
                           *Length,
                           MEM_COMMIT,
                           PAGE_READWRITE
                         );

    if (Buffer != NULL &&
        VirtualQuery( Buffer, &MemoryInformation, sizeof( MemoryInformation ) )
       ) {
        *Length = MemoryInformation.RegionSize;
    }

    if( Buffer == NULL ) {
        fprintf(stderr,"DH: VirtualAlloc failed for %d bytes at line %d\n",*Length,__LINE__);
    }

    return Buffer;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemModules(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    PVOID BufferToFree;
    RTL_PROCESS_MODULES ModulesBuffer;
    PRTL_PROCESS_MODULES Modules;
    SIZE_T RequiredLength;

    Modules = &ModulesBuffer;
    RequiredLength = sizeof( ModulesBuffer );
    BufferToFree = NULL;
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemModuleInformation,
                                           Modules,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (Modules != &ModulesBuffer) {
                break;
            }

            Modules = BufferAlloc( &RequiredLength );
            if (Modules == NULL) {
                break;
            }

            BufferToFree = Modules;
        }
        else
        if (NT_SUCCESS( Status )) {
            Buffer->Modules = Modules;
            return TRUE;
        }
        else {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",
                Status,__LINE__);
            break;
        }
    }

    if (Modules != &ModulesBuffer) {
        VirtualFree( Modules, 0, MEM_RELEASE );
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemBackTraces(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    RTL_PROCESS_BACKTRACES BackTracesBuffer;
    SIZE_T RequiredLength;

    BackTraces = &BackTracesBuffer;
    RequiredLength = sizeof( BackTracesBuffer );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemStackTraceInformation,
                                           BackTraces,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (BackTraces != &BackTracesBuffer) {
                break;
            }

            RequiredLength += 4096; // slop, since we may trigger more allocs.
            BackTraces = BufferAlloc( &RequiredLength );
            if (BackTraces == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            Buffer->BackTraces = BackTraces;
            return TRUE;
        }
    }

    if (BackTraces != &BackTracesBuffer) {
        VirtualFree( BackTraces, 0, MEM_RELEASE );
        }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemPools(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    PRTL_PROCESS_HEAPS Heaps;

    SIZE_T Size;

    Size= FIELD_OFFSET( RTL_PROCESS_HEAPS, Heaps) + 2 * sizeof( RTL_HEAP_INFORMATION );

    Heaps = RtlAllocateHeap( RtlProcessHeap(),
                             HEAP_ZERO_MEMORY,
                             Size );
    if (Heaps == NULL) {
        fprintf(stderr,"DH: AllocateHeap failed for %d bytes at line %d\n",Size,__LINE__);
        return FALSE;
    }

    Buffer->Heaps = Heaps;
    if (LoadSystemTags( &Heaps->Heaps[ 0 ], &Heaps->Heaps[ 1 ] )) {
        if (LoadSystemPool( &Heaps->Heaps[ 0 ], SystemPagedPoolInformation )) {
            Heaps->NumberOfHeaps = 1;
            if (LoadSystemPool( &Heaps->Heaps[ 1 ], SystemNonPagedPoolInformation )) {
                Heaps->NumberOfHeaps = 2;
                return TRUE;
            }
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS
QueryPoolTagInformationIterative(
    PVOID *CurrentBuffer,
    SIZE_T *CurrentBufferSize
    )
{
    SIZE_T NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        //
        // there is no buffer allocated yet
        //

        NewBufferSize = sizeof( UCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = VirtualAlloc(
            NULL,
            NewBufferSize,
            MEM_COMMIT,
            PAGE_READWRITE
            );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;

        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // iterate by buffer's size
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // free the current buffer
            //

            VirtualFree(
                *CurrentBuffer,
                0,
                MEM_RELEASE );

            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // try with a greater buffer size
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = VirtualAlloc(
                    NULL,
                    NewBufferSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if( *CurrentBuffer != NULL ) {

                    //
                    // allocated new buffer
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // insufficient memory
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success
            //

            break;

        }
    }

    return ReturnedStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemTags(
    PRTL_HEAP_INFORMATION PagedPoolInfo,
    PRTL_HEAP_INFORMATION NonPagedPoolInfo
    )
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    PSYSTEM_POOLTAG_INFORMATION Tags;
    PSYSTEM_POOLTAG TagInfo;
    PRTL_HEAP_TAG pPagedPoolTag, pNonPagedPoolTag;
    ULONG n, TagIndex;

    PagedPoolInfo->NumberOfTags = 0;
    PagedPoolInfo->Tags = NULL;
    NonPagedPoolInfo->NumberOfTags = 0;
    NonPagedPoolInfo->Tags = NULL;

    Tags = NULL;
    RequiredLength = 0;

    while (TRUE) {

        Status = QueryPoolTagInformationIterative(
                    &Tags,
                    &RequiredLength
                    );

        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            PagedPoolInfo->NumberOfTags = Tags->Count + 1;
            NonPagedPoolInfo->NumberOfTags = Tags->Count + 1;
            n = (Tags->Count + 1) * sizeof( RTL_HEAP_TAG );
            PagedPoolInfo->Tags = RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, n );
            NonPagedPoolInfo->Tags = RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, n );

            TagInfo = &Tags->TagInfo[ 0 ];
            pPagedPoolTag = PagedPoolInfo->Tags + 1;
            pNonPagedPoolTag = NonPagedPoolInfo->Tags + 1;

            for (TagIndex=1; TagIndex<=Tags->Count; TagIndex++) {
                UNICODE_STRING UnicodeString;
                ANSI_STRING AnsiString;

                pPagedPoolTag->TagIndex = (USHORT)TagIndex;
                pPagedPoolTag->NumberOfAllocations = TagInfo->PagedAllocs;
                pPagedPoolTag->NumberOfFrees = TagInfo->PagedFrees;
                pPagedPoolTag->BytesAllocated = TagInfo->PagedUsed;
                UnicodeString.Buffer = pPagedPoolTag->TagName;
                UnicodeString.MaximumLength = sizeof( pPagedPoolTag->TagName );
                AnsiString.Buffer = TagInfo->Tag;
                AnsiString.Length = sizeof( TagInfo->Tag );
                AnsiString.MaximumLength = AnsiString.Length;
                RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
                pNonPagedPoolTag->TagIndex = (USHORT)TagIndex;
                pNonPagedPoolTag->NumberOfAllocations = TagInfo->NonPagedAllocs;
                pNonPagedPoolTag->NumberOfFrees = TagInfo->NonPagedFrees;
                pNonPagedPoolTag->BytesAllocated = TagInfo->NonPagedUsed;
                wcscpy( pNonPagedPoolTag->TagName, pPagedPoolTag->TagName );
                pPagedPoolTag += 1;
                pNonPagedPoolTag += 1;
                TagInfo += 1;
            }

            break;
        }
    }

    if (Tags != NULL) {
        VirtualFree( Tags, 0, MEM_RELEASE );
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////


USHORT
FindPoolTagIndex(
    PRTL_HEAP_TAG Tags,
    ULONG NumberOfTags,
    PCHAR Tag
    )
{
    ULONG i;
    UCHAR AnsiTagName[ 5 ];
    WCHAR UnicodeTagName[ 5 ];
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    strncpy( AnsiTagName, Tag, 4 );
    UnicodeString.Buffer = UnicodeTagName;
    UnicodeString.MaximumLength = sizeof( UnicodeTagName );
    AnsiString.Buffer = AnsiTagName;
    AnsiString.Length = (USHORT)strlen( AnsiTagName );
    AnsiString.MaximumLength = AnsiString.Length;
    RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );

    Tags += 1;
    for (i=1; i<NumberOfTags; i++) {
        if (!_wcsicmp( UnicodeTagName, Tags->TagName )) {
            return (USHORT)i;
        }
        Tags += 1;
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemPool(
    PRTL_HEAP_INFORMATION HeapInfo,
    SYSTEM_INFORMATION_CLASS SystemInformationClass
    )
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    SYSTEM_POOL_INFORMATION PoolInfoBuffer;
    PSYSTEM_POOL_INFORMATION PoolInfo;
    PSYSTEM_POOL_ENTRY PoolEntry;
    PRTL_HEAP_ENTRY p;
    ULONG n;
    BOOLEAN Result;

    HeapInfo->BaseAddress = (PVOID)SystemInformationClass;
    PoolInfo = &PoolInfoBuffer;
    RequiredLength = sizeof( PoolInfoBuffer );
    Result = FALSE;

    while (TRUE) {
        Status = NtQuerySystemInformation( SystemInformationClass,
                                           PoolInfo,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (PoolInfo != &PoolInfoBuffer) {
                break;
            }

            RequiredLength += 4096; // slop, since we may trigger more allocs.
            PoolInfo = BufferAlloc( &RequiredLength );
            if (PoolInfo == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            n = PoolInfo->NumberOfEntries;
            HeapInfo->NumberOfEntries = n + 1;
            HeapInfo->EntryOverhead = PoolInfo->EntryOverhead;
            HeapInfo->Entries = RtlAllocateHeap( RtlProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 HeapInfo->NumberOfEntries * sizeof( RTL_HEAP_ENTRY )
                                               );
            if( HeapInfo->Entries == NULL ) {
                fprintf(stderr,"DH: Alloc failed for %d bytes at line %d\n",
                            HeapInfo->NumberOfEntries * sizeof( RTL_HEAP_ENTRY),__LINE__);
                break;
            }

            p = HeapInfo->Entries;
            p->Flags = RTL_HEAP_SEGMENT;
            p->u.s2.CommittedSize = PoolInfo->TotalSize;
            p->u.s2.FirstBlock = PoolInfo->FirstEntry;
            p += 1;
            PoolEntry = &PoolInfo->Entries[ 0 ];
            while (n--) {
                p->Size = PoolEntry->Size;
                if (PoolEntry->TagUlong & PROTECTED_POOL) {
                    p->Flags |= RTL_HEAP_PROTECTED_ENTRY;
                    PoolEntry->TagUlong &= ~PROTECTED_POOL;
                }

                p->u.s1.Tag = FindPoolTagIndex( HeapInfo->Tags,
                                                HeapInfo->NumberOfTags,
                                                PoolEntry->Tag
                                              );
                HeapInfo->BytesCommitted += p->Size;
                if (PoolEntry->Allocated) {
                    p->Flags |= RTL_HEAP_BUSY;
                    p->AllocatorBackTraceIndex = PoolEntry->AllocatorBackTraceIndex;
                    HeapInfo->BytesAllocated += p->Size;
                }

                p += 1;
                PoolEntry += 1;
            }

            Result = TRUE;
            break;
        }
    }

    if (PoolInfo != &PoolInfoBuffer) {
        VirtualFree( PoolInfo, 0, MEM_RELEASE );
    }

    return Result;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemLocks(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    RTL_PROCESS_LOCKS LocksBuffer;
    PRTL_PROCESS_LOCKS Locks;
    SIZE_T RequiredLength;

    Locks = &LocksBuffer;
    RequiredLength = sizeof( LocksBuffer );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemLocksInformation,
                                           Locks,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (Locks != &LocksBuffer) {
                break;
            }

            Locks = BufferAlloc( &RequiredLength );
            if (Locks == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            Buffer->Locks = Locks;
            return TRUE;
        }
    }

    if (Locks != &LocksBuffer) {
        VirtualFree( Locks, 0, MEM_RELEASE );
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SYSTEM_OBJECTTYPE_INFORMATION ObjectInfoBuffer;
    SIZE_T RequiredLength;
    ULONG i;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;

    ObjectInformation = &ObjectInfoBuffer;
    RequiredLength = sizeof( *ObjectInformation );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemObjectInformation,
                                           ObjectInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (ObjectInformation != &ObjectInfoBuffer) {
                return FALSE;
             }

            RequiredLength += 4096; // slop, since we may trigger more object creations.
            ObjectInformation = BufferAlloc( &RequiredLength );
            if (ObjectInformation == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            return FALSE;
        }
        else {
            break;
        }
    }

    TypeNames = RtlAllocateHeap( RtlProcessHeap(),
                                 HEAP_ZERO_MEMORY,
                                 sizeof( PUNICODE_STRING ) * (MAX_TYPE_NAMES+1)
                               );
    if (TypeNames == NULL) {
        fprintf(stderr,"DH: Alloc failed for %d bytes at line %d\n",
                       sizeof( PUNICODE_STRING ) * (MAX_TYPE_NAMES+1) ,__LINE__);
        return FALSE;
    }

    TypeInfo = ObjectInformation;
    while (TRUE) {
        if (TypeInfo->TypeIndex < MAX_TYPE_NAMES) {
            TypeNames[ TypeInfo->TypeIndex ] = &TypeInfo->TypeName;
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    RtlInitUnicodeString( &UnknownTypeIndex, L"Unknown Type Index" );
    for (i=0; i<=MAX_TYPE_NAMES; i++) {
        if (TypeNames[ i ] == NULL) {
            TypeNames[ i ] = &UnknownTypeIndex;
        }
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION_EX HandleInfoBuffer;
    SIZE_T RequiredLength;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;

    HandleInformation = &HandleInfoBuffer;
    RequiredLength = sizeof( *HandleInformation );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemExtendedHandleInformation,
                                           HandleInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (HandleInformation != &HandleInfoBuffer) {
                return FALSE;
            }

            RequiredLength += 4096; // slop, since we may trigger more handle creations.
            HandleInformation = (PSYSTEM_HANDLE_INFORMATION_EX)BufferAlloc( &RequiredLength );
            if (HandleInformation == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            return FALSE;
        }
        else {
            break;
        }
    }

    TypeInfo = ObjectInformation;
    while (TRUE) {
        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
            ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (TRUE) {
            if (ObjectInfo->HandleCount != 0) {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
                ULONG HandleNumber;

                HandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles) {
                    if (!(HandleEntry->HandleAttributes & 0x80) &&
                        HandleEntry->Object == ObjectInfo->Object
                       ) {
                        HandleEntry->Object = ObjectInfo;
                        HandleEntry->HandleAttributes |= 0x80;
                    }

                    HandleEntry++;
                }
            }

            if (ObjectInfo->NextEntryOffset == 0) {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    ULONG i, TotalOffset;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer[ MAX_PATH ];
    ANSI_STRING AnsiString;
    SIZE_T Size;

    RequiredLength = 64 * 1024;
    ProcessInformation = BufferAlloc( &RequiredLength );
    if (ProcessInformation == NULL) {
        return FALSE;
     }

    Status = NtQuerySystemInformation( SystemProcessInformation,
                                       ProcessInformation,
                                       (ULONG)RequiredLength,
                                       (ULONG *)&RequiredLength
                                     );
    if (!NT_SUCCESS( Status )) {
        fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
        return FALSE;
    }

    InitializeListHead( &ProcessListHead );
    ProcessInfo = ProcessInformation;
    TotalOffset = 0;
    while (TRUE) {
        if (ProcessInfo->ImageName.Buffer == NULL) {
            sprintf( NameBuffer, "System Process (%p)", ProcessInfo->UniqueProcessId );
        }
        else {
            sprintf( NameBuffer, "%wZ (%p)",
                     &ProcessInfo->ImageName,
                     ProcessInfo->UniqueProcessId
                   );
        }
        RtlInitAnsiString( &AnsiString, NameBuffer );
        RtlAnsiStringToUnicodeString( &ProcessInfo->ImageName, &AnsiString, TRUE );

        Size = sizeof( *ProcessEntry ) + (sizeof( ThreadInfo ) * ProcessInfo->NumberOfThreads);
        ProcessEntry = RtlAllocateHeap( RtlProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        Size );
        if (ProcessEntry == NULL) {
            fprintf(stderr,"DH: Alloc failed for %d bytes at line %d\n",Size,__LINE__);
            return FALSE;
        }

        InitializeListHead( &ProcessEntry->Entry );
        ProcessEntry->ProcessInfo = ProcessInfo;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        for (i = 0; i < ProcessInfo->NumberOfThreads; i++) {
            ProcessEntry->ThreadInfo[ i ] = ThreadInfo++;
        }

        InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PCHAR)ProcessInformation + TotalOffset);
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////


PSYSTEM_PROCESS_INFORMATION
FindProcessInfoForCid(
    IN HANDLE UniqueProcessId
    )
{
    PLIST_ENTRY Next, Head;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer[ 64 ];
    ANSI_STRING AnsiString;

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessEntry = CONTAINING_RECORD( Next,
                                          PROCESS_INFO,
                                          Entry
                                        );

        ProcessInfo = ProcessEntry->ProcessInfo;
        if (ProcessInfo->UniqueProcessId == UniqueProcessId) {
            return ProcessInfo;
        }

        Next = Next->Flink;
    }

    ProcessEntry = RtlAllocateHeap( RtlProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    sizeof( *ProcessEntry ) +
                                        sizeof( *ProcessInfo )
                                  );
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessEntry+1);

    ProcessEntry->ProcessInfo = ProcessInfo;
    sprintf( NameBuffer, "Unknown Process (%p)", UniqueProcessId );
    RtlInitAnsiString( &AnsiString, NameBuffer );
    RtlAnsiStringToUnicodeString( (PUNICODE_STRING)&ProcessInfo->ImageName, &AnsiString, TRUE );
    ProcessInfo->UniqueProcessId = UniqueProcessId;

    InitializeListHead( &ProcessEntry->Entry );
    InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

    return ProcessInfo;
}

////////////////////////////////////////////////////////////////////////////////////////////


VOID
DumpSystemThread(
    PSYSTEM_THREAD_INFORMATION ThreadInfo
    )
{
    UCHAR Buffer[ MAX_PATH ];

    Buffer[ 0 ] = '\0';
    GetDhSymbolicNameForAddress( NULL, (ULONG_PTR)ThreadInfo->StartAddress, Buffer, sizeof( Buffer ) );
    sprintf( DumpLine, "        Thread Id: %p   Start Address: %p (%s)\n",
             ThreadInfo->ClientId.UniqueThread,
             ThreadInfo->StartAddress,
             Buffer
           );
    DumpOutputString();

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpSystemProcess(
    PPROCESS_INFO ProcessEntry
    )
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG ThreadNumber;

    ProcessInfo = ProcessEntry->ProcessInfo;
    sprintf( DumpLine, "\n\n*********** %p (%wZ) Information ********************\n\n",
             ProcessInfo->UniqueProcessId,
             &ProcessInfo->ImageName
           );
    DumpOutputString();

    if (ProcessInfo->InheritedFromUniqueProcessId) {
        sprintf( DumpLine, "    Parent Process: %p (%wZ)\n",
                 ProcessInfo->InheritedFromUniqueProcessId,
                 &(FindProcessInfoForCid( ProcessInfo->InheritedFromUniqueProcessId )->ImageName)
               );
        DumpOutputString();
    }

    sprintf( DumpLine, "    BasePriority:       %u\n",
             ProcessInfo->BasePriority
           );
    DumpOutputString();
    sprintf( DumpLine, "    VirtualSize:        %08x\n",
             ProcessInfo->VirtualSize
           );
    DumpOutputString();
    sprintf( DumpLine, "    PeakVirtualSize:    %08x\n",
             ProcessInfo->PeakVirtualSize
           );
    DumpOutputString();
    sprintf( DumpLine, "    WorkingSetSize:     %08x\n",
             ProcessInfo->WorkingSetSize
           );
    DumpOutputString();
    sprintf( DumpLine, "    PeakWorkingSetSize: %08x\n",
             ProcessInfo->PeakWorkingSetSize
           );
    DumpOutputString();
    sprintf( DumpLine, "    PagefileUsage:      %08x\n",
             ProcessInfo->PagefileUsage
           );
    DumpOutputString();
    sprintf( DumpLine, "    PeakPagefileUsage:  %08x\n",
             ProcessInfo->PeakPagefileUsage
           );
    DumpOutputString();
    sprintf( DumpLine, "    PageFaultCount:     %08x\n",
             ProcessInfo->PageFaultCount
           );
    DumpOutputString();
    sprintf( DumpLine, "    PrivatePageCount:   %08x\n",
             ProcessInfo->PrivatePageCount
           );
    DumpOutputString();

    sprintf( DumpLine, "    Number of Threads:  %u\n",
             ProcessInfo->NumberOfThreads
           );
    DumpOutputString();
    for (ThreadNumber=0; ThreadNumber<ProcessInfo->NumberOfThreads; ThreadNumber++) {
        DumpSystemThread( ProcessEntry->ThreadInfo[ ThreadNumber ] );
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpSystemProcesses( VOID )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO ProcessEntry;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping object information.\n" );
    }

    sprintf( DumpLine, "\n\n*********** Process Information ********************\n\n" );
    DumpOutputString();

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessEntry = CONTAINING_RECORD( Next,
                                          PROCESS_INFO,
                                          Entry
                                        );

        DumpSystemProcess( ProcessEntry );
        Next = Next->Flink;
    }

    return;
}


////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpObjects( VOID )
{
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    UNICODE_STRING ObjectName;
    PUCHAR s;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping object information.\n" );
    }

    sprintf( DumpLine, "\n\n*********** Object Information ********************\n\n" );
    DumpOutputString();

    TypeInfo = ObjectInformation;
    while (TRUE) {
        sprintf( DumpLine, "\n\n*********** %wZ Object Type ********************\n\n",
                           &TypeInfo->TypeName
               );
        DumpOutputString();

        sprintf( DumpLine, "    NumberOfObjects: %u\n", TypeInfo->NumberOfObjects );
        DumpOutputString();

        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
            ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (TRUE) {
            ObjectName = ObjectInfo->NameInfo.Name;
            try {
                if (ObjectName.Length != 0 && *ObjectName.Buffer == UNICODE_NULL) {
                    ObjectName.Length = 0;
                }
                sprintf( DumpLine, "    Object: %p  Name: %wZ  Creator: %wZ (Backtrace%05lu)\n",
                         ObjectInfo->Object,
                         &ObjectName,
                         &(FindProcessInfoForCid( ObjectInfo->CreatorUniqueProcess )->ImageName),
                         ObjectInfo->CreatorBackTraceIndex
                       );
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                sprintf( DumpLine, "    Object: %p  Name: [%04x, %04x, %p]\n",
                         ObjectInfo->Object,
                         ObjectName.MaximumLength,
                         ObjectName.Length,
                         ObjectName.Buffer
                       );
            }
            DumpOutputString();

            BackTraceInfo = FindBackTrace( ObjectInfo->CreatorBackTraceIndex );
            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    sprintf( DumpLine, "        %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }

            s = DumpLine;
            s += sprintf( s, "\n        PointerCount: %u  HandleCount: %u",
                          ObjectInfo->PointerCount,
                          ObjectInfo->HandleCount
                        );

            if (ObjectInfo->SecurityDescriptor != NULL) {
                s += sprintf( s, "  Security: %p", ObjectInfo->SecurityDescriptor );
            }

            if (ObjectInfo->ExclusiveProcessId) {
                s += sprintf( s, "  Exclusive by Process: %p", ObjectInfo->ExclusiveProcessId );
            }

            s += sprintf( s, "  Flags: %02x", ObjectInfo->Flags );

            if (ObjectInfo->Flags & OB_FLAG_NEW_OBJECT) {
                s += sprintf( s, " New" );
            }

            if (ObjectInfo->Flags & OB_FLAG_KERNEL_OBJECT) {
                s += sprintf( s, " KernelMode" );
            }

            if (ObjectInfo->Flags & OB_FLAG_PERMANENT_OBJECT) {
                s += sprintf( s, " Permanent" );
            }

            if (ObjectInfo->Flags & OB_FLAG_DEFAULT_SECURITY_QUOTA) {
                s += sprintf( s, " DefaultSecurityQuota" );
            }

            if (ObjectInfo->Flags & OB_FLAG_SINGLE_HANDLE_ENTRY) {
                s += sprintf( s, " Single Handle Entry" );
            }

            s += sprintf( s, "\n" );
            DumpOutputString();

            if (ObjectInfo->HandleCount != 0) {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
                ULONG HandleNumber;

                HandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles) {
                    if (((HandleEntry->HandleAttributes & 0x80) && HandleEntry->Object == ObjectInfo) ||
                        (!(HandleEntry->HandleAttributes & 0x80) && HandleEntry->Object == ObjectInfo->Object)
                       ) {
                        sprintf( DumpLine, "        Handle: %08lx  Access:%08lx  Process: %wZ\n",
                                 HandleEntry->HandleValue,
                                 HandleEntry->GrantedAccess,
                                 &(FindProcessInfoForCid( (HANDLE)HandleEntry->UniqueProcessId )->ImageName)
                               );
                        DumpOutputString();
                    }

                    HandleEntry++;
                }
            }
            sprintf( DumpLine, "\n" );
            DumpOutputString();

            if (ObjectInfo->NextEntryOffset == 0) {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////


VOID
DumpHandles( VOID )
{
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
    HANDLE PreviousUniqueProcessId;
    ULONG HandleNumber;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    PVOID Object;
    PUCHAR s;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping handle information.\n" );
    }

    sprintf( DumpLine, "\n\n*********** Object Handle Information ********************\n\n" );
    DumpOutputString();
    sprintf( DumpLine, "Number of handles: %u\n", HandleInformation->NumberOfHandles );
    DumpOutputString();

    HandleEntry = &HandleInformation->Handles[ 0 ];
    HandleNumber = 0;
    PreviousUniqueProcessId = INVALID_HANDLE_VALUE;
    while (HandleNumber++ < HandleInformation->NumberOfHandles) {
        if (PreviousUniqueProcessId != (HANDLE)HandleEntry->UniqueProcessId) {
            PreviousUniqueProcessId = (HANDLE)HandleEntry->UniqueProcessId;
            sprintf( DumpLine, "\n\n*********** Handles for %wZ ********************\n\n",
                               &(FindProcessInfoForCid( PreviousUniqueProcessId )->ImageName)
                   );
            DumpOutputString();
        }

        if (HandleEntry->HandleAttributes & 0x80) {
            ObjectInfo = HandleEntry->Object;
            Object = ObjectInfo->Object;
        }
        else {
            ObjectInfo = NULL;
            Object = HandleEntry->Object;
        }

        sprintf( DumpLine, "    Handle: %08lx%c  Type: %wZ  Object: %p  Access: %08lx\n",
                 HandleEntry->HandleValue,
                 HandleEntry->HandleAttributes & OBJ_INHERIT ? 'i' : ' ',
                 TypeNames[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ? HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ],
                 Object,
                 HandleEntry->GrantedAccess
               );
        DumpOutputString();

        if (ObjectInfo != NULL) {
            UNICODE_STRING ObjectName;

            ObjectName = ObjectInfo->NameInfo.Name;
            try {
                if (ObjectName.Length != 0 && *ObjectName.Buffer == UNICODE_NULL) {
                    ObjectName.Length = 0;
                    }
                sprintf( DumpLine, "        Name: %wZ\n",
                         &ObjectName
                   );
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                sprintf( DumpLine, "        Name: [%04x, %04x, %p]\n",
                         ObjectName.MaximumLength,
                         ObjectName.Length,
                         ObjectName.Buffer
                       );
            }

            DumpOutputString();
        }

        if (HandleEntry->CreatorBackTraceIndex != 0) {
            sprintf( DumpLine, "        Creator:  (Backtrace%05lu)\n", HandleEntry->CreatorBackTraceIndex );
            DumpOutputString();
            BackTraceInfo = FindBackTrace( HandleEntry->CreatorBackTraceIndex );
            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    sprintf( DumpLine, "            %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }
        }

        sprintf( DumpLine, "    \n" );
        DumpOutputString();
        HandleEntry++;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

ULONG
GetDhSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    )
{
    IMAGEHLP_MODULE ModuleInfo;
    ULONG i, ModuleNameLength, Result;
    ULONG_PTR Offset;
    LPSTR s;
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    ModuleNameLength = 0;
    if (SymGetModuleInfo( UniqueProcess, Address, &ModuleInfo )) {
        ModuleNameLength = strlen( ModuleInfo.ModuleName );
    }

    if (SymGetSymFromAddr( UniqueProcess, Address, &Offset, sym )) {
        s = sym->Name;
        i = 1;
        while ( sym->MaxNameLength > i &&
               isdigit( s[ sym->MaxNameLength - i ] )
              ) {
            i += 1;
        }

        if (s[ sym->MaxNameLength - i ] == '@') {
            sym->MaxNameLength = sym->MaxNameLength - i;
        }

        s = Name;
        Result = _snprintf( s, MaxNameLength,
                            "%.*s!%s",
                            ModuleNameLength,
                            ModuleInfo.ModuleName,
                            sym->Name
                          );
        if (Offset != 0) {
            Result += _snprintf( s + Result, MaxNameLength - Result, "+0x%x", Offset );
        }
    }
    else {
        if (ModuleNameLength != 0) {
            Result = _snprintf( Name, MaxNameLength,
                                "%.*s!0x%08x",
                                ModuleNameLength,
                                ModuleInfo.ModuleName,
                                Address
                              );
        }
        else {
            Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\dhcmp.c ===
/*****************************************************************************\
* DHCMP - Compare DH.EXE outputs.
*
* Copyright (c) 1995-2000 Microsoft Corporation.  All rights reserved.
*
* DHCMP is a character-mode tool which processes DH output file(s) into forms
* which may be more useful in investigate memory leaks etc.
*
* DH is a useful tool which displays heap allocations in a properly enabled
* system, but the output is sometimes hard to analyze and interpret.
* The output is a list of allocation backtraces:  each backtrace contains up to
* MAX_BT call-sites, and is accompanied by the number of bytes allocated.
*
* 02-01-95 IanJa    bugfixes and handle BackTraceNNNNN identifiers from dh.exe
* 03/22/95 IanJa    modify to cope with current DH output format.
* 07/27/98 t-mattba added -v switch
\*****************************************************************************/



char *pszHow =
" DHCMP has two modes:\n"
"\n"
" 1)  DHCMP [-d] dh_dump1.txt dh_dump2.txt\n"
"     This compares two DH dumps, useful for finding leaks.\n"
"     dh_dump1.txt & dh_dump2.txt are obtained before and after some test\n"
"     scenario.  DHCMP matches the backtraces from each file and calculates\n"
"     the increase in bytes allocated for each backtrace. These are then\n"
"     displayed in descending order of size of leak\n"
"     The first line of each backtrace output shows the size of the leak in\n"
"     bytes, followed by the (last-first) difference in parentheses.\n"
"     Leaks of size 0 are not shown.\n"
"\n"
" 2)  DHCMP [-d] dh_dump.txt\n"
"     For each allocation backtrace, the number of bytes allocated will be\n"
"     attributed to each callsite (each line of the backtrace).  The number\n"
"     of bytes allocated per callsite are summed and the callsites are then\n"
"     displayed in descending order of bytes allocated.  This is useful for\n"
"     finding a leak that is reached via many different codepaths.\n"
"     ntdll!RtlAllocateHeap@12 will appear first when analyzing DH dumps of\n"
"     csrss.exe, since all allocation will have gone through that routine.\n"
"     Similarly, ProcessApiRequest will be very prominent too, since that\n"
"     appears in most allocation backtraces.  Hence the useful thing to do\n"
"     with mode 2 output is to use dhcmp to comapre two of them:\n"
"         dhcmp dh_dump1.txt > tmp1.txt\n"
"         dhcmp dh_dump2.txt > tmp2.txt\n"
"         dhcmp tmp1.txt tmp2.txt\n"
"     the output will show the differences.\n"
"\n"
" Flags:\n"
"     -d   Output in decimal (default is hexadecimal)\n"
// "     -t   Find Totals (NOT YET IMPLEMENTED)\n"
"     -v   Verbose output: include the actual backtraces as well as summary information\n"
"          (Verbose output is only interesting in mode 1 above.)\n"
"     -?   This help\n";


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NHASH 47
#define TRUE 1
#define FALSE 0
typedef int BOOL;

#define TYPE_WHOLESTACK 0
#define TYPE_FUNCTIONS  1

#define MAXLINELENGTH       4096
#define MAXFUNCNAMELENGTH   1024
#define MAX_BT 48                   /* max length of back trace stack */

void AddToName(char *fnname, unsigned __int64 nb, int sign);
void SetAllocs(char *fnname, unsigned __int64 nb, int sign);
void Process(char *fnam, int sign, int type);
void SortAll();
void AddToStackTrace(char *fnname, char *line);
void ResetStackTrace(char *fnname);

/*
 * Hashing
 */

int MakeHash(char *pName);
void InitHashTab();

#define DUMPF_FIRST   (1)
#define DUMPF_SECOND  (2)
#define DUMPF_RESULT  (4)
#define DUMPF_ALL     (DUMPF_FIRST | DUMPF_SECOND | DUMPF_RESULT)

void DumpNodes(int Flags);

#define F_DECIMAL 0x0001
#define F_TOTAL   0x0002
#define F_VERBOSE 0x0004

//
// Globals
//

int gFlags = 0;

int cdecl main(int argc, char *argv[]) {
    int n, DumpType;

    InitHashTab();

    for (n = 1; n < argc; n++) {
        if ((argv[n][0] == '-') || (argv[n][0] == '/')) {
            /*
             * Flags
             */
            switch (argv[n][1]) {
            case 'd':
                gFlags |= F_DECIMAL;
                break;
            //NOT YET IMPLEMENTED
            //case 't':
            //    gFlags |= F_TOTAL;
            //    break;
            case 'v':
                gFlags |= F_VERBOSE;
                break;
            case '?':
            default:
                printf("%s\n", pszHow);
                return 1;
            }
        } else {
            /*
             * No more flags
             */

            break;
        }
    }

    if ((argc - n) == 2) {
        DumpType = DUMPF_ALL;
        Process(argv[n],   -1, TYPE_WHOLESTACK);
        Process(argv[n+1], +1, TYPE_WHOLESTACK);
    } else if ((argc - n) == 1) {
        //
        // F_VERBOSE is not meaningful when groveling only one dump.
        //

        gFlags &= ~F_VERBOSE;

        DumpType = DUMPF_RESULT;
        Process(argv[n], +1, TYPE_FUNCTIONS);
    } else {
        printf("%s\n", pszHow);
        return 1;
    }

    // printf("==================== BEFORE SORTING ====================\n");
    // DumpNodes(DUMPF_ALL);
    SortAll();
    // printf("==================== AFTER SORTING ====================\n");
    DumpNodes(DumpType);
    return 0;
}


void Process(char *fname, int sign, int type) {
    FILE *stream;
    char linebuff[MAXLINELENGTH];
    char fnnamebuff[MAXFUNCNAMELENGTH];
    char BackTraceBuff[MAXFUNCNAMELENGTH * MAX_BT] = {0};
    char *p;
    int lineno = 0;
    BOOL skip = TRUE;       // start out skipping lines

    int iT;
    unsigned __int64 ulT = 0L;
    unsigned __int64 nBytes = 0L;
    unsigned __int64 ulConsumed;
    unsigned __int64 lAllocs;

    // printf("PROCESS %s %d %d\n", fname, sign, type);

    stream = fopen(fname, "r");
    if (stream == NULL) {
        fprintf(stderr, "Can't open %s for reading\n", fname);
        exit (2);
    }

    nBytes = 0;

    while (fgets(linebuff, sizeof(linebuff), stream) != NULL) {
        lineno++;

        //fprintf(stderr, "Line #%d\r", lineno);

        if (linebuff[0] == '*') {
            //
            // If we find a "hogs" line, stack traces follow, any other line
            // started by "*" should cause us to go back to searching for a
            // hogs block.
            //

            if (strstr(linebuff,
                       "Hogs")) {
                skip = FALSE;
            } else {
                skip = TRUE;
            }

            continue;
        }

        if (skip) {
            //
            // Skip is enabled, skip this line, it is data about the heap
            // between 'heap information' and 'heap hogs' lines.
            //

            continue;
        }

        if (linebuff[0] != ' ') 
        {
            //
            // Scan for byte count and find out how many characters have
            // been consumed by this action.
            // 

            ulConsumed = 0;
            iT = sscanf(linebuff, "%I64x bytes in %I64x", &ulT, &lAllocs);

            if (iT > 0) 
            {
                nBytes = ulT;
                p = strstr(linebuff, "BackTrace");
                if (!p) 
                {
                    //
                    // What's this ?
                    //

                    continue;
                } 

                strcpy(BackTraceBuff, p);
                p = strchr(BackTraceBuff, '\n');
                if (p) 
                {
                    *p = '\0';
                }

                if (type == TYPE_FUNCTIONS) 
                {
                    //
                    // BackTraceBuff is now saved for use with the rest of the
                    // trace.
                    //

                    continue;
                }

                AddToName(BackTraceBuff, nBytes, sign);

                if(iT == 1)
                {
                    lAllocs = 1;
                }

                SetAllocs(BackTraceBuff, lAllocs, sign);
                                                
                ResetStackTrace(BackTraceBuff);
            }
        } 
        else if (nBytes != 0) 
        {
            /*
             * If TYPE_WHOLESTACK, then add the count to each line of the
             * stack backtrace.
             */
            
            if (sscanf(linebuff, "        %[^+]+0x", fnnamebuff) == 1) {
                if (type == TYPE_FUNCTIONS) {
                    AddToName(fnnamebuff, nBytes, sign);
                }
                if ((gFlags & F_VERBOSE) == F_VERBOSE) {
                    AddToStackTrace(BackTraceBuff, linebuff);
                }
                continue;
            } else {
                nBytes = 0;
            }
        }
    }

    /*
     * make sure to account for the final one.
     */
    if (type == TYPE_WHOLESTACK) {
        AddToName(BackTraceBuff, nBytes, sign);
    }

    if (fname != NULL) {
        fclose(stream);
    }
}

/*
 * Hashing
 */

typedef struct tagNODE {
    char *pName;
    __int64  lValue;
    __int64 lFirst;
    __int64 lSecond;
    char BackTrace[MAX_BT][MAXFUNCNAMELENGTH];
    long lPosition;
    __int64 lAllocsFirst;
    __int64 lAllocsSecond;
    struct tagNODE *pNext;
} NODE, *PNODE;

void DumpStackTrace(PNODE pNode);

PNODE HashTab[NHASH];

void InitHashTab() {
    int i;
    for (i = 0; i < NHASH; i++) {
        HashTab[i] = NULL;
    }
}

int MakeHash(char *pName) {
    int hash = 0;

    while (*pName) {
        hash += *pName;
        pName++;
    }
    return hash % NHASH;
}

void DumpNodes(int Flags) {
    PNODE pNode;
    int i;
    unsigned __int64 ulTotal = 0;
    char *fmt1;
    char *fmt2;
    char *fmt3;
    char *fmt4;
    char *fmt5;
    char *fmt6;
    char *fmt7;

    if ((gFlags & F_VERBOSE) == F_VERBOSE) {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64d\n";
            fmt6 = "+% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
            fmt7 = "-% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64x\n";
            fmt6 = "+% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
            fmt7 = "-% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
        }        
    } else {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "\n-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s";
            fmt5 = "\nTotal increase == %I64d\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "\n-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s";
            fmt5 = "\nTotal increase == %I64x\n";
        }
    }

    for (i = 0; i < NHASH; i++) {
        // printf("========= HASH %d ==========\n", i);
        for (pNode = HashTab[i]; pNode != NULL; pNode = pNode->pNext) {
            switch (Flags) {
            case DUMPF_FIRST:
                printf(fmt1, pNode->lFirst, pNode->pName);
                break;

            case DUMPF_SECOND:
                printf(fmt1, pNode->lSecond, pNode->pName);
                break;

            case DUMPF_RESULT:
                printf(fmt2, pNode->lValue, pNode->pName);
                break;

            case DUMPF_ALL:
                if (pNode->lValue > 0) {
                    printf(fmt3, pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                } else if (pNode->lValue < 0) {
                    printf(fmt4, -pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                }
                if((gFlags & F_VERBOSE) == F_VERBOSE) {
                    if(pNode->lAllocsSecond-pNode->lAllocsFirst > 0) {
                        printf(fmt6, pNode->lAllocsSecond-pNode->lAllocsFirst,
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    } else if(pNode->lAllocsSecond-pNode->lAllocsFirst < 0) {
                        printf(fmt7, -(pNode->lAllocsSecond-pNode->lAllocsFirst),
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    }
                }

                break;
            }
            ulTotal += pNode->lValue;
            if(((gFlags & F_VERBOSE) == F_VERBOSE) && (pNode->lValue != 0)) {
                DumpStackTrace(pNode);
            }
        }
    }
    if (Flags == DUMPF_ALL) {
        printf(fmt5, ulTotal);
    }
}

PNODE FindNode(char *pName) {
    int i;
    PNODE pNode;

    i = MakeHash(pName);
    pNode = HashTab[i];
    while (pNode) {
        if (strcmp(pName, pNode->pName) == 0) {
            return pNode;
        }
        pNode = pNode->pNext;
    }

    // Not found

    // fprintf(stderr, "NEW %s\n", pName);

    pNode = malloc(sizeof(NODE));
    if (!pNode) {
        fprintf(stderr, "malloc failed in FindNode\n");
        exit(2);
    }

    pNode->pName = _strdup(pName);
    if (!pNode->pName) {
        fprintf(stderr, "strdup failed in FindNode\n");
        exit(2);
    }

    pNode->pNext = HashTab[i];
    HashTab[i] = pNode;
    pNode->lValue = 0L;
    pNode->lFirst = 0L;
    pNode->lSecond = 0L;
    pNode->lPosition = 0L;
    pNode->lAllocsFirst = 0L;
    pNode->lAllocsSecond = 0L;

    return pNode;
}
    
void AddToName(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
    pNode->lValue += nb * sign;
    if (sign == -1) {
        pNode->lFirst += nb;
    } else {
        pNode->lSecond += nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void SetAllocs(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
 
    if (sign == -1) {
        pNode->lAllocsFirst = nb;
    } else {
        pNode->lAllocsSecond = nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void ResetStackTrace(char *fnname) {   
    PNODE pNode;
    
    pNode = FindNode(fnname);
    pNode->lPosition = 0L;    
}

void AddToStackTrace(char *fnname, char *line)
{
    PNODE pNode;
    
    pNode = FindNode(fnname);

    //
    // Make sure we don't write too much data in the BackTrace field.
    //

    if (pNode -> lPosition >= MAX_BT) {
        //
        // MAX_BT should be the number of entries in a stack trace that
        // DH/UMDH captures.  If we trigger this we have tried to attach
        // more than MAX_BT entries in this stack.
        //

        fprintf(stderr,
                "More than %d entries in this stack trace, "
                "did the max change ?\n",
                MAX_BT);

        exit(EXIT_FAILURE);
    }

    strcpy(pNode->BackTrace[pNode->lPosition++], line);
}

/*
 * Insert pNode into the list at ppNodeHead.
 * Sort in ascending order.
 * Insert pNode BEFORE the first item >= pNode.
 */
void Reinsert(PNODE pNode, PNODE *ppNodeHead) {
    PNODE *ppT;
    ppT = ppNodeHead;
    while (*ppT && (pNode->lValue < (*ppT)->lValue)) {
        ppT = &((*ppT)->pNext);
    }
    /*
     * Insert pNode before *ppT
     */
    pNode->pNext = *ppT;
    *ppT = pNode;
}

void SortList(PNODE *ppNodeHead) {
    PNODE pNode;
    PNODE pNext;

    pNode = *ppNodeHead;
    if (pNode == NULL) {
        return;
    }
    pNext = pNode->pNext;
    if (pNext == NULL) {
        return;
    }

    while (TRUE) {
        while (pNext != NULL) {
            if (pNode->lValue < pNext->lValue) {
    
                /*
                 * cut the unordered node from the list
                 */
                pNode->pNext = pNext->pNext;
                Reinsert(pNext, ppNodeHead);
                break;
            }
            pNode = pNext;
            pNext = pNode->pNext;
        }
        if (pNext == NULL) {
            return;
        }
        pNode = *ppNodeHead;
        pNext = pNode->pNext;
    }
}

/*
 * Merge ordered list 1 into ordered list 2
 * Leaves list 1 empty; list 2 ordered
 */
void MergeLists(PNODE *ppNode1, PNODE *ppNode2) {
    PNODE *pp1;
    PNODE *pp2;
    PNODE p1;
    PNODE p2;

    pp1 = ppNode1;
    pp2 = ppNode2;
    while (TRUE) {
        p1 = *pp1;
        p2 = *pp2;

        if (p1 == NULL) {
           return;
        }
        if (p2 == NULL) {
            *pp2 = *pp1;
            *pp1 = NULL;
            return;
        }

        if (p1->lValue > p2->lValue) {
            *pp1 = p1->pNext;
            p1->pNext = p2;
            *pp2 = p1;
            pp2 = &(p1->pNext);
        } else {
            pp2 = &(p2->pNext);
        }
    }
}

void SortAll() {
    int i;

    for (i = 0; i < NHASH; i++) {
        SortList(&HashTab[i]);
    }
    // printf(" ======================== SORTED ========================\n");
    // DumpNodes(DUMPF_ALL);
    for (i = 0; i < NHASH-1; i++) {
        // printf(" ======================== MERGING %d and %d ======================== \n", i, i+1);
        MergeLists(&HashTab[i], &HashTab[i+1]);
        // DumpNodes(DUMPF_ALL);
    }
}

void DumpStackTrace(PNODE pNode)
{
    int n;
    
    for(n = 0; n < pNode->lPosition; n++) {
        printf("%s", pNode->BackTrace[n]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\makefile.inc ===
$(O)\dh.res: dh.rc

$(O)\oh.res: oh.rc

$(O)\ohcmp.res: ohcmp.rc

$(O)\heapmon.res: heapmon.rc

$(O)\objmon.res: objmon.rc

$(O)\resmon.res: resmon.rc

$(O)\dhcmp.res: dhcmp.rc

$(O)\analog.res: analog.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\analog.h ===
/*
 * Title: analog.h - header file for log analyzer
 *
 * Description: This file provides structures and macros for log analyzer.
 *
 * Types:
 *     PoolLogRec Poolsnap structure
 *     MemLogRec  Memsnap structure
 *     LogType    Enumeration of known log types
 *
 * Macros:
 *
 *     GET_DELTA             Computes the difference between first & last entry
 *     GREATER_LESS_OR_EQUAL Increments trend if cur>prv, decrements if cur<prv
 *     PRINT_IF_TREND        Prints definite or probable leaks based on trend
 *     MAX                   Returns the larger value
 *
 * Copyright (c) 1998  Microsoft Corporation
 *
 * Revision history: LarsOp (created) 12/8/98
 *
 */

//
// Structure for poolsnap logs
//
typedef struct _PoolLogRec {
    char  Name[32];
    char  Type[32];
    long Allocs;
    long Frees;
    long Diff;
    long Bytes;
    long PerAlloc;
} PoolLogRec;

//
// Structure for memsnap logs
//
typedef struct _MemLogRec {
    DWORD Pid;
    char  Name[64];
    long WorkingSet;
    long PagedPool;
    long NonPagedPool;
    long PageFile;
    long Commit;
    long Handles;
    long Threads;
} MemLogRec;

//
// Enumeration of the known log types
//
typedef enum {
    MEM_LOG=0,        // must be zero (see LogTypeLabels)
    POOL_LOG,         // must be 1 (see LogTypeLabels)
    UNKNOWN_LOG_TYPE
} LogType;

//
// Array of labels to simplify printing the enumerated type
//
char *LogTypeLabels[]={"MemSnap", "PoolSnap", "Unknown"};

//
// Arbitrary buffer length
//
#define BUF_LEN 256

#define PERCENT_TO_PRINT 10

//
// GET_DELTA simply records the difference (end-begin) for specified field
//
// Args:
//   delta - record to receive result values
//   ptr   - array of records (used to compare first and last)
//   max   - number of entries in the array
//   field - field name to compute
//
// Returns: nothing (treat like void function)
//
#define GET_DELTA(delta, ptr, max, field) delta.field = ptr[max-1].field - ptr[0].field

//
// GREATER_LESS_OR_EQUAL calculates TrendInfo.
//
// Args:
//   trend - record containing running tally
//   ptr   - array of records (used to compare curr and prev)
//   i     - index of current entry in the array
//   field - field name to compare
//
// Returns: nothing (treat like void function)
//
// TrendInfo is a running tally of the periods a value went up vs.
// the periods it went down.  See macro in analog.h
//
// if (curval>oldval) {
//    trend++;
// } else if (curval<oldval) {
//    trend--;
// } else {
//    trend=trend;  // stay same
// }
//
#define GREATER_LESS_OR_EQUAL(trend, ptr, i, field) \
    if (ptr[i].field - ptr[i-1].field) \
        trend.field += (((ptr[i].field - ptr[i-1].field) > 0) ? 1 : -1);

//
// MAX returns the larger value of the two
//
// Args: x,y: arguments of the same type where '>' is defined.
//
// Returns: the larger value
//
#define MAX(x, y) (x>y?x:y)

//
// PERCENT returns the percentage
//
// Args:
//     delta - value of increase
//     base  - initial value
//
// Returns: the percent if base!=0, else 0
//
#define PERCENT(delta, base) (base!=0?(100*delta)/base:0)


#define VAL_AND_PERCENT(delta, ptr, field) delta.field, PERCENT(delta.field, ptr[0].field)

//
// PRINT_IF_TREND reports probable or definite leaks for any field.
//
// Args:
//   ptr   - array of records (used to display first and last)
//   trend - record containing running tally
//   delta - record containing raw differences of first and last
//   max   - number of entries in the array
//   field - field name to compare
//
// Returns: nothing (treat like void function)
//
// Definite leak is where the value goes up every period
// Probable leak is where the value goes up most of the time
//
//
// PRINT_HEADER and PRINT_IF_TREND must agree on field widths.
//
#define PRINT_HEADER() {                                              \
        TableHeader();                                                \
        if( bHtmlStyle ) {                                            \
           TableStart();                                              \
           printf("<TH COLSPAN=2> %s </TH>\n",g_pszComputerName);     \
           printf("<TH COLSPAN=6>\n");                                \
           if( g_fShowExtraInfo ) {                                   \
               printf("BuildNumber=%s\n",g_pszBuildNumber);           \
               printf("<BR>BuildType=%s\n",g_pszBuildType);           \
               printf("<BR>Last SystemTime=%s\n",g_pszSystemTime);    \
               printf("<BR>%s\n",g_pszComments);                      \
           }                                                          \
           printf("</TH>\n");                                         \
           TableEnd();                                                \
        }                                            \
        TableStart();                                \
        TableField("%-15s", "Name" );                \
        TableField("%-12s", "Probability");          \
        TableField("%-12s", "Object" );              \
        TableField("%10s", "Change" );               \
        TableField("%10s", "Start"  );               \
        TableField("%10s", "End"    );               \
        TableField("%8s",  "Percent");               \
        TableField("%10s", "Rate/hour" );            \
        TableEnd(); }                              

#define PRINT_TRAILER() { \
        TableTrailer(); }

#define PRINT_IF_TREND(ptr, trend, delta, max, field)                        \
    if (trend.field >= max/2) {                                               \
        BOOL bDefinite= (trend.field==max-1) ? 1 : 0;                        \
        if( bDefinite || (g_ReportLevel>0) ) { \
        TableStart();                                                        \
        TableField("%-15s", ptr[0].Name);                                    \
        TableField("%-12s", bDefinite ? "Definite" : "Probable");            \
        TableField("%-12s", #field);                                         \
        TableNum("%10ld", delta.field);                                      \
        TableNum("%10ld", ptr[0].field);                                     \
        TableNum("%10ld", ptr[max-1].field);                                 \
        TableNum("%8ld",  PERCENT(delta.field,ptr[0].field));                \
        if( g_dwElapseTickCount ) {                                          \
           TableNum("%10d",Trick( delta.field ,g_dwElapseTickCount) );     \
        } else {                                                             \
           TableField("%-10s"," ");                                          \
        };                                                                   \
        TableEnd();                                                          \
        } \
    }   


#define ANY_PERCENT_GREATER(delta, ptr) (\
    (PERCENT(delta.WorkingSet   , ptr[0].WorkingSet  ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.PagedPool    , ptr[0].PagedPool   ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.NonPagedPool , ptr[0].NonPagedPool) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.PageFile     , ptr[0].PageFile    ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Commit       , ptr[0].Commit      ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Handles      , ptr[0].Handles     ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Threads      , ptr[0].Threads     ) > PERCENT_TO_PRINT))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\heapmon.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heapmon.c

Abstract:

    This program monitors the heap usage of another process and updates
    its display every 10 seconds

Author:

    Steve Wood (stevewo) 01-Nov-1994

Revision History:

--*/

#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <stdio.h>
#include <stdlib.h>

void
Usage( void )
{
    fputs( "Usage: HEAPMON [-?] [-1] [-p id] [-t | -a | -f | -d | [-u | -b]] [-( | -)] [-e]\n"
           "where: -? displays this message.\n"
           "       -1 specifies to monitor the Win32 subsystem\n"
           "       -p specifies the process to monitor\n"
           "          Default is to monitor the Win32 subsystem\n"
           "       -t sort output by tag name\n"
           "       -a sort output by #allocations\n"
           "       -f sort output by #frees\n"
           "       -d sort output by #allocations - #frees\n"
           "       -u sort output by bytes used\n"
           "       -b same as -u\n"
           "       -( Changes #allocations and #frees above to be #bytes\n"
           "          allocated and freed\n"
           "       -) same as -(\n"
           "       -e enables display of total lines\n"
           "       -l enables highlighing of changed lines\n"
           "\n"
           "While HEAPMON is running you can type any of the following\n"
           "switch characters to change the output:\n"
           "       t - sort output by tag name\n"
           "       a - sort output by #allocations\n"
           "       f - sort output by #frees\n"
           "       d - sort output by #allocations - #frees\n"
           "       u or b - specifies the sort output by bytes used\n"
           "       ( or ) - toggles interpretation of #allocations and #frees above\n"
           "                to be #bytes allocated and freed.\n"
           "       e - toggles display of total lines.\n"
           "       l - toggles highlighing of changed lines\n"
           "       ? or h - displays help text\n"
           "       q - quit the program.\n"
           , stderr);
    ExitProcess( 1 );
}

#define TAG 0
#define ALLOC 1
#define FREE 2
#define DIFF 3
#define BYTES 4

BOOL fFirstTimeThrough;
BOOL fDisplayTotals;
BOOL fHighlight = TRUE;
BOOL fParen;
BOOL fInteractive;
BOOL fQuit;
BOOL fHelp;
ULONG DelayTimeMsec = 5000;
ULONG SortBy = TAG;
HANDLE InputHandle;
DWORD OriginalInputMode;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
COORD ConsoleBufferSize;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;

typedef struct _HEAP_ENTRY {
    struct _HEAP_ENTRY *Next;
    BOOL  Changed;
    PVOID HeapBase;
    PCHAR HeapName;
    SIZE_T BytesAllocated;
    SIZE_T BytesCommitted;
} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _TAG_COUNTS {
    SIZE_T Allocs;
    SIZE_T Frees;
    SIZE_T Used;
    SIZE_T Allocs_Frees;
    SIZE_T UsedPerAlloc;
} TAG_COUNTS, *PTAG_COUNTS;

typedef struct _TAG_TOTALS {
    BOOL Changed;
    TAG_COUNTS Counts;
    TAG_COUNTS Differences;
} TAG_TOTALS, *PTAG_TOTALS;

typedef struct _TAG_ENTRY {
    struct _TAG_ENTRY *Next;
    PCHAR HeapName;
    PCHAR TagName;
    PVOID HeapBase;
    USHORT TagIndex;
    BOOL Changed;
    TAG_COUNTS Counts;
    TAG_COUNTS PrevCounts;
    TAG_COUNTS Differences;
} TAG_ENTRY, *PTAG_ENTRY;


ULONG HeapListLength;
PHEAP_ENTRY HeapListHead;
ULONG TagListLength;
PTAG_ENTRY TagListHead, *TagArray;
TAG_TOTALS TagTotals;

VOID
ShowHelpPopup( VOID );

VOID
UpdateDisplay( VOID );

VOID
DumpTagDataBase( VOID );

BOOLEAN
UpdateTagDataBase(
    PRTL_DEBUG_INFORMATION DebugInfo
    );

BOOLEAN
UpdateHeapDataBase(
    PRTL_DEBUG_INFORMATION DebugInfo
    );

PCHAR
GetNameForHeapBase(
    PVOID HeapBase
    );

PVOID
CreateNameTable(
    IN ULONG NumberOfBuckets
    );

PCHAR
AddNameToNameTable(
    IN PVOID pNameTable,
    IN PCHAR Name
    );

PVOID NameTable;

BOOL
ProcessOptionCharacter(
    IN CHAR c
    );

VOID
ScreenUpdateLoop(
    PRTL_DEBUG_INFORMATION p
    );

int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    DWORD_PTR ProcessId;
    PCHAR s, s1;
    NTSTATUS Status;
    PRTL_DEBUG_INFORMATION p;
    SMALL_RECT NewWindowRect;

    NameTable = CreateNameTable( 37 );

    ProcessId = 0xFFFFFFFF;
    fHelp = FALSE;
    fInteractive = TRUE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                if (!ProcessOptionCharacter( *s )) {
                    switch( toupper( *s ) ) {
                        case '1':
                            fQuit = TRUE;
                            fInteractive = FALSE;
                            break;

                        case 'P':
                            if (--argc) {
                                ProcessId = atoi( *++argv );
                                }
                            else {
                                fprintf( stderr, "HEAPMON: missing argument to -p switch\n" );
                                fHelp = TRUE;
                                }
                            break;

                        default:
                            fprintf( stderr, "HEAPMON: invalid switch - /%c\n", *s );
                            fHelp = TRUE;
                            break;
                        }
                    }
                }
            }
        else {
            fprintf( stderr, "HEAPMON: invalid argument - %s\n", s );
            fHelp = TRUE;
            }
        }

    if (fHelp) {
        Usage();
        }

    if (ProcessId == -1) {
        HANDLE Process;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        PROCESS_BASIC_INFORMATION BasicInfo;

        RtlInitUnicodeString( &UnicodeString, L"\\WindowsSS" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &UnicodeString,
                                    0,
                                    NULL,
                                    NULL
                                  );
        Status = NtOpenProcess( &Process,
                                PROCESS_ALL_ACCESS,
                                &ObjectAttributes,
                                NULL
                              );
        if (NT_SUCCESS(Status)) {
            Status = NtQueryInformationProcess( Process,
                                                ProcessBasicInformation,
                                                (PVOID)&BasicInfo,
                                                sizeof(BasicInfo),
                                                NULL
                                              );
            NtClose( Process );
            }

        if (!NT_SUCCESS(Status)) {
            fprintf( stderr, "HEAPMON: Unable to access Win32 server process - %08x", Status );
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                fprintf( stderr, "\nUse GFLAGS.EXE to ""Enable debugging of Win32 Subsystem"" and reboot.\n" );
                }
            ExitProcess( 1 );
            }

        ProcessId = BasicInfo.UniqueProcessId;
        }

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if (fInteractive) {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           ) {
            fInteractive = FALSE;
            }
        else {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               ) {
                if (OutputHandle != NULL) {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                    }

                fInteractive = FALSE;
                }
            else {
                NormalAttribute = 0x1F;
                HighlightAttribute = 0x71;
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows;
                }
            }
        }

    p = RtlCreateQueryDebugBuffer( 0, TRUE );
    if (p == NULL) {
        fprintf( stderr, "HEAPMON: Unable to create query buffer.\n" );
        ExitProcess( 1 );
        }

    if (GetPriorityClass( GetCurrentProcess() ) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );
        }

    Status = RtlQueryProcessDebugInformation( (HANDLE)ProcessId,
                                              RTL_QUERY_PROCESS_MODULES |
                                              RTL_QUERY_PROCESS_HEAP_SUMMARY |
                                              RTL_QUERY_PROCESS_HEAP_TAGS,
                                              p
                                            );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "HEAPMON: Unable to query heap tags from Process %u (%x)\n", ProcessId, Status );
        fprintf( stderr, "         Be sure target process was launched with the\n" );
        fprintf( stderr, "         'Enable heap tagging' option enabled.\n" );
        fprintf( stderr, "         Use the GFLAGS.EXE application to do this.\n" );
        ExitProcess( 1 );
        }

    ScreenUpdateLoop( p );

    RtlDestroyQueryDebugBuffer( p );

    if (fInteractive) {
        SetConsoleActiveScreenBuffer( OriginalOutputHandle );
        SetConsoleMode( InputHandle, OriginalInputMode );
        CloseHandle( OutputHandle );
        }

    ExitProcess( 0 );
    return 0;
}


VOID
ScreenUpdateLoop(
    PRTL_DEBUG_INFORMATION p
    )
{
    NTSTATUS Status;
    COORD cp;
    COORD newcp;
    COORD originalCp;
    LONG ScrollDelta;
    ULONG i, MaxLines;
    UCHAR LastKey = 0;

    fFirstTimeThrough = TRUE;
    while (TRUE) {
        if (!UpdateTagDataBase( p )) {
            fprintf( stderr, "HEAPMON: Unable to compute tag data base\n" );
            break;
            }
        fFirstTimeThrough = FALSE;

        if (fInteractive) {
            UpdateDisplay();
            while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {
                //
                // Check for input record
                //
                if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                    InputRecord.EventType == KEY_EVENT &&
                    InputRecord.Event.KeyEvent.bKeyDown
                   ) {
                    LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                    if (!ProcessOptionCharacter( LastKey )
                       ) {
                        if (LastKey < ' ') {
                            ScrollDelta = 0;
                            if (LastKey == 'C'-'A'+1) {
                                fQuit = TRUE;
                                }
                            else
                            switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                                case VK_ESCAPE:
                                    fQuit = TRUE;
                                    break;

                                case VK_PRIOR:
                                    ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                                    break;

                                case VK_NEXT:
                                    ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                                    break;

                                case VK_UP:
                                    ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                                    break;

                                case VK_DOWN:
                                    ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                                    break;

                                case VK_HOME:
                                    FirstDetailLine = 0;
                                    break;

                                case VK_END:
                                    FirstDetailLine = TagListLength - NumberOfDetailLines;
                                    break;
                                }

                            if (ScrollDelta != 0) {
                                if (ScrollDelta < 0) {
                                    if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                        FirstDetailLine = 0;
                                        ScrollDelta = 0;
                                        }
                                    }
                                FirstDetailLine += ScrollDelta;
                                if (FirstDetailLine >= (TagListLength - NumberOfDetailLines)) {
                                    FirstDetailLine = TagListLength - NumberOfDetailLines;
                                    }
                                }

                            if (FirstDetailLine > TagListLength) {
                                FirstDetailLine = TagListLength;
                                }
                            }
                        else {
                            switch (toupper( LastKey )) {
                                case 'Q':
                                    //
                                    //  Go to the bottom of the current screen when
                                    //  we quit.
                                    //
                                    fQuit = TRUE;
                                    break;
                                }
                            }
                        }
                    else {
                        FirstDetailLine = 0;
                        }

                    break;
                    }
                }

            if (fQuit) {
                break;
                }

            if (fHelp) {
                fHelp = FALSE;
                ShowHelpPopup();
                }
            }
        else {
            DumpTagDataBase();

            if (fQuit) {
                break;
                }

            Sleep( DelayTimeMsec );
            }

        Status = RtlQueryProcessDebugInformation( p->TargetProcessId,
                                                  p->Flags,
                                                  p
                                                );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr, "HEAPMON: Unable to update heap tags from Process %p (%x)\n", p->TargetProcessId, Status );
            break;
            }
        }

    return;
}

BOOL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    BOOL Highlight
    )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }

    if (!FillConsoleOutputAttribute( OutputHandle,
                                     (WORD)((Highlight && fHighlight) ? HighlightAttribute : NormalAttribute),
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }


    if (Text == NULL || (TextLength = strlen( Text )) == 0) {
        return TRUE;
        }
    else {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
        }
}


VOID
ShowHelpPopup( VOID )
{
    HANDLE PopupHandle;
    WORD n;

    PopupHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL
                                           );
    if (PopupHandle == NULL) {
        return;
        }

    SetConsoleActiveScreenBuffer( PopupHandle );
    n = 0;

    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "                HeapMon Help", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " columns:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Heap Name is the name or hex address of the heap", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Tag Name is a string given to the heap allocation", FALSE );
    WriteConsoleLine( PopupHandle, n++, "       For untagged allocations, the tag name is a function of the size", FALSE );
    WriteConsoleLine( PopupHandle, n++, "       Objects=  32 - objects of size 32 bytes", FALSE );
    WriteConsoleLine( PopupHandle, n++, "       Objects>1024 - objects larger than 1024 bytes are lumped under this tag", FALSE );
    WriteConsoleLine( PopupHandle, n++, "       VirtualAlloc - objects larger than 1MB bytes are lumped under this tag", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Allocations is count of all alloctions", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) is difference in Allocations column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Frees is count of all frees", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Frees column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Diff is (Allocations - Frees)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Bytes Used is the total bytes consumed in heap", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Bytes column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " switches:                                                                     ", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ? or h - gives this help", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   q - quits", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   e - toggles totals lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " sorting switches:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   t - tag    a - allocations", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   f - frees  d - difference", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   b - bytes  (u is the same as b)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ) - toggles sort between primary value and value in (  )", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " command line switches", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -eltafdbu) - as listed above", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );

    while (TRUE) {
        if (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0 &&
            ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown &&
            InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
           ) {
            break;
        }
    }

    SetConsoleActiveScreenBuffer( OutputHandle );
    CloseHandle( PopupHandle );
    return;
}

VOID
UpdateDisplay( VOID )
{
    ULONG HeapLines, DetailLines, SummaryLines;
    WORD DisplayLine;
    PHEAP_ENTRY pHeap;
    PTAG_ENTRY p, *pp;
    CHAR Buffer[ 512 ];

    HeapLines = HeapListLength;
    if (fDisplayTotals) {
        SummaryLines = 2;
        RtlZeroMemory( &TagTotals, sizeof( TagTotals ) );
        }
    else {
        SummaryLines = 0;
        }
    DetailLines = NumberOfRows - HeapLines - SummaryLines - 3;
    NumberOfDetailLines = DetailLines;
    if (DetailLines > (TagListLength - FirstDetailLine)) {
        DetailLines = TagListLength - FirstDetailLine;
        }

    DisplayLine = 0;
    WriteConsoleLine( OutputHandle,
                      DisplayLine++,
                      "Heap Name                Address  Allocated      Committed        Free",
                      FALSE
                    );

    pHeap = HeapListHead;
    while (pHeap != NULL && HeapLines--) {
        sprintf( Buffer,
                 "%-20.20s     %p %8u        %8u      %8u",
                 pHeap->HeapName,
                 pHeap->HeapBase,
                 pHeap->BytesAllocated,
                 pHeap->BytesCommitted,
                 pHeap->BytesCommitted - pHeap->BytesAllocated
               );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          Buffer,
                          pHeap->Changed
                        );

        pHeap->Changed = FALSE;

        pHeap = pHeap->Next;
        }

    pp = &TagArray[ FirstDetailLine ];
    WriteConsoleLine( OutputHandle,
                      DisplayLine++,
                      "Heap Name            Tag Name             Allocations           Frees     Diff      Bytes Used",
                      FALSE
                    );
    while (DetailLines--) {
        p = *pp++;
        sprintf( Buffer,
                 "%-20.20s %-14.14s %8u (%6u) %8u (%6u) %6u %8u (%6u)",
                 p->HeapName,
                 p->TagName,
                 p->Counts.Allocs,
                 p->Differences.Allocs,
                 p->Counts.Frees,
                 p->Differences.Frees,
                 p->Counts.Allocs_Frees,
                 p->Counts.Used,
                 p->Differences.Used
               );
        if (fDisplayTotals) {
            TagTotals.Counts.Allocs += p->Counts.Allocs;
            TagTotals.Differences.Allocs += p->Differences.Allocs;
            TagTotals.Counts.Frees += p->Counts.Frees;
            TagTotals.Differences.Frees += p->Differences.Frees;
            TagTotals.Counts.Allocs_Frees += p->Counts.Allocs_Frees;
            TagTotals.Differences.Allocs_Frees += p->Counts.Used;
            TagTotals.Differences.Used += p->Differences.Used;
            TagTotals.Changed |= p->Changed;
            }

        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          Buffer,
                          p->Changed
                        );

        p->Changed = FALSE;
        }

    while (SummaryLines--) {
        if (SummaryLines) {
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              NULL,
                              FALSE
                            );
            }
        else {
            sprintf( Buffer,
                     "%-20.20s %-14.14s %8u (%6u) %8u (%6u) %6u %8u (%6u)",
                     "Totals",
                     "",
                     TagTotals.Counts.Allocs,
                     TagTotals.Differences.Allocs,
                     TagTotals.Counts.Frees,
                     TagTotals.Differences.Frees,
                     TagTotals.Counts.Allocs_Frees,
                     TagTotals.Differences.Allocs_Frees,
                     TagTotals.Differences.Used
                   );
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              Buffer,
                              TagTotals.Changed
                            );
            }
        }

    while (DisplayLine < NumberOfRows) {
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          NULL,
                          FALSE
                        );
        }

    return;
}

VOID
DumpTagDataBase( VOID )
{
    ULONG i;
    PTAG_ENTRY p;

    for (i=0; i<TagListLength; i++) {
        p = TagArray[ i ];
        if (p->Changed && (p->Counts.Used != 0)) {
            printf( "%-14.14s%-20.20s %8u (%6u) %8u (%6u) %6u %8u (%6u)\n",
                    p->HeapName,
                    p->TagName,
                    p->Counts.Allocs,
                    p->Differences.Allocs,
                    p->Counts.Frees,
                    p->Differences.Frees,
                    p->Counts.Allocs_Frees,
                    p->Counts.Used,
                    p->Differences.Used
                  );
            p->Changed = FALSE;
            }
        }

    return;
}

__inline int DiffSizeT(SIZE_T s1, SIZE_T s2)
{
    if (s1 == s2)
        return 0;

    if (s1 > s2)
        return -1;
    else
        return 1;
}

int
__cdecl
CompareTagFunction(
    const void *e1,
    const void *e2
    )
{
    int Result;
    PTAG_ENTRY p1, p2;
    SIZE_T s1, s2;

    p1 = *(PTAG_ENTRY *)e1;
    p2 = *(PTAG_ENTRY *)e2;

    switch (SortBy) {
        case TAG:
            Result = _stricmp( p1->HeapName, p2->HeapName );
            if (!Result) {
                Result = _stricmp( p1->TagName, p2->TagName );
                }
            return Result;

        case ALLOC:
            if (fParen) {
                return DiffSizeT(p2->Differences.Allocs, p1->Differences.Allocs);
                }
            else {
                return DiffSizeT(p2->Counts.Allocs, p1->Counts.Allocs);
                }

        case FREE:
            if (fParen) {
                return DiffSizeT(p2->Differences.Frees, p1->Differences.Frees);
                }
            else {
                return DiffSizeT(p2->Counts.Frees, p1->Counts.Frees);
                }

        case BYTES:
            if (fParen) {
                return DiffSizeT(p2->Differences.Used, p1->Differences.Used);
                }
            else {
                return DiffSizeT(p2->Counts.Used, p1->Counts.Used);
                }

        case DIFF:
            return DiffSizeT(p2->Counts.Allocs_Frees, p1->Counts.Allocs_Frees);
    }

    return(0);
}


BOOLEAN
UpdateTagDataBase(
    PRTL_DEBUG_INFORMATION DebugInfo
    )
{
    PTAG_ENTRY p, p1, *pp;
    PLIST_ENTRY Next, Head;
    ULONG HeapNumber;
    PRTL_PROCESS_HEAPS Heaps;
    PRTL_HEAP_INFORMATION HeapInfo;
    PRTL_HEAP_TAG HeapTagEntry;
    PVOID HeapNameBase;
    PCHAR HeapName;
    ULONG TagIndex;
    UCHAR Buffer[ MAX_PATH ];
    BOOL CalcDifferences;

    if (!UpdateHeapDataBase( DebugInfo )) {
        return FALSE;
        }

    HeapNameBase = INVALID_HANDLE_VALUE;

    pp = &TagListHead;
    Heaps = DebugInfo->Heaps;
    HeapInfo = &Heaps->Heaps[ 0 ];
    for (HeapNumber = 0; HeapNumber < Heaps->NumberOfHeaps; HeapNumber++) {
        if (HeapInfo->Tags != NULL && HeapInfo->NumberOfTags > 0) {
            HeapTagEntry = HeapInfo->Tags;
            for (TagIndex=0; TagIndex<HeapInfo->NumberOfTags; TagIndex++) {
                p = *pp;
                if (p == NULL ||
                    p->HeapBase != HeapInfo->BaseAddress ||
                    p->TagIndex != HeapTagEntry->TagIndex
                   ) {
                    if (HeapTagEntry->NumberOfAllocations != 0 ||
                        HeapTagEntry->NumberOfFrees != 0 ||
                        HeapTagEntry->BytesAllocated != 0
                       ) {
                        *pp = RtlAllocateHeap( RtlProcessHeap(),
                                               HEAP_ZERO_MEMORY,
                                               sizeof( *p )
                                             );
                        if (*pp == NULL) {
                            return FALSE;
                            }

                        (*pp)->Next = p;
                        p = *pp;
                        if (p->Next == NULL) {
                            pp = &p->Next;
                            }

                        p->HeapBase = HeapInfo->BaseAddress;
                        if (p->HeapBase != HeapNameBase) {
                            HeapName = GetNameForHeapBase( HeapNameBase = p->HeapBase );
                            }
                        p->HeapName = HeapName;

                        p->TagIndex = HeapTagEntry->TagIndex;
                        sprintf( Buffer, "%ws", HeapTagEntry->TagName );
                        p->TagName = AddNameToNameTable( NameTable, Buffer );
                        p->Changed = !fFirstTimeThrough;
                        TagListLength += 1;
                        CalcDifferences = FALSE;
                        }
                    else {
                        p = NULL;
                        }
                    }
                else {
                    pp = &p->Next;
                    p->PrevCounts = p->Counts;
                    CalcDifferences = TRUE;
                    p->Changed = FALSE;
                    }

                if (p != NULL) {
                    p->Counts.Allocs = HeapTagEntry->NumberOfAllocations;
                    p->Counts.Frees = HeapTagEntry->NumberOfFrees;
                    p->Counts.Used = HeapTagEntry->BytesAllocated;
                    p->Counts.Allocs_Frees = p->Counts.Allocs - p->Counts.Frees;
                    if (CalcDifferences) {
                        p->Differences.Allocs = p->Counts.Allocs - p->PrevCounts.Allocs;
                        p->Differences.Frees = p->Counts.Frees - p->PrevCounts.Frees;
                        p->Differences.Used = p->Counts.Used - p->PrevCounts.Used;
                        p->Differences.Allocs_Frees = p->Counts.Allocs_Frees - p->PrevCounts.Allocs_Frees;
                        if (p->Differences.Allocs != 0 ||
                            p->Differences.Frees != 0 ||
                            p->Differences.Used != 0 ||
                            p->Differences.Allocs_Frees != 0
                           ) {
                            p->Changed = TRUE;
                            }
                        }
                    }

                HeapTagEntry += 1;
                }
            }

        HeapInfo += 1;
        }


    if (TagArray != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, TagArray );
        }
    TagArray = RtlAllocateHeap( RtlProcessHeap(), 0, TagListLength * sizeof( *TagArray ) );
    if (TagArray == NULL) {
        return FALSE;
        }

    p = TagListHead;
    pp = TagArray;
    while (p != NULL) {
        *pp++ = p;
        p = p->Next;
        }

    qsort( (void *)TagArray,
           (size_t)TagListLength,
           (size_t)sizeof( *TagArray ),
           CompareTagFunction
         );

    return TRUE;
}


BOOLEAN
UpdateHeapDataBase(
    PRTL_DEBUG_INFORMATION DebugInfo
    )
{
    PHEAP_ENTRY p, *pp;
    PRTL_PROCESS_HEAPS Heaps;
    PRTL_HEAP_INFORMATION HeapInfo;
    PRTL_HEAP_TAG HeapTagEntry;
    ULONG i;
    UCHAR Buffer[ MAX_PATH ];
    PCHAR s;

    pp = &HeapListHead;
    Heaps = DebugInfo->Heaps;
    HeapInfo = Heaps->Heaps;
    for (i=0; i<Heaps->NumberOfHeaps; i++) {
        p = *pp;
        if (p == NULL ||
            p->HeapBase != HeapInfo->BaseAddress
           ) {
            *pp = RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *p ) );
            if (*pp == NULL) {
                return FALSE;
                }
            (*pp)->Next = p;
            p = *pp;
            if (p->Next == NULL) {
                pp = &p->Next;
                }

            p->HeapBase = HeapInfo->BaseAddress;
            HeapTagEntry = HeapInfo->Tags + HeapInfo->NumberOfPseudoTags;
            if (HeapInfo->NumberOfTags > HeapInfo->NumberOfPseudoTags &&
                HeapTagEntry->TagName[ 0 ] != UNICODE_NULL
               ) {
                sprintf( Buffer, "%ws", HeapTagEntry->TagName );
                }
            else {
                sprintf( Buffer, "%p", p->HeapBase );
                }
            p->HeapName = AddNameToNameTable( NameTable, Buffer );
            p->BytesAllocated = HeapInfo->BytesAllocated;
            p->BytesCommitted = HeapInfo->BytesCommitted;
            p->Changed = !fFirstTimeThrough;
            HeapListLength += 1;
            }
        else {
            p->Changed = FALSE;
            if (HeapInfo->BytesAllocated != p->BytesAllocated) {
                p->Changed = TRUE;
                p->BytesAllocated = HeapInfo->BytesAllocated;
                }

            if (HeapInfo->BytesCommitted != p->BytesCommitted) {
                p->Changed = TRUE;
                p->BytesCommitted = HeapInfo->BytesCommitted;
                }

            pp = &p->Next;
            }

        HeapInfo += 1;
        }

    return TRUE;
}

PCHAR
GetNameForHeapBase(
    PVOID HeapBase
    )
{
    PHEAP_ENTRY p;

    p = HeapListHead;
    while (p != NULL) {
        if (p->HeapBase == HeapBase) {
            return p->HeapName;
            }
        else {
            p = p->Next;
            }
        }
    return NULL;
}

typedef struct _NAME_TABLE_ENTRY {
    struct _NAME_TABLE_ENTRY *HashLink;
    UCHAR Name[ 1 ];
} NAME_TABLE_ENTRY, *PNAME_TABLE_ENTRY;

typedef struct _NAME_TABLE {
    ULONG NumberOfBuckets;
    PNAME_TABLE_ENTRY Buckets[1];
} NAME_TABLE, *PNAME_TABLE;


PVOID
CreateNameTable(
    IN ULONG NumberOfBuckets
    )
{
    PNAME_TABLE p;
    ULONG Size;

    Size = FIELD_OFFSET( NAME_TABLE, Buckets ) +
           (sizeof( PNAME_TABLE_ENTRY ) * NumberOfBuckets);

    p = (PNAME_TABLE)RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, Size );
    if (p != NULL) {
        p->NumberOfBuckets = NumberOfBuckets;
        }

    return p;
}


PCHAR
AddNameToNameTable(
    IN PVOID pNameTable,
    IN PCHAR Name
    )
{
    PNAME_TABLE NameTable = pNameTable;
    PNAME_TABLE_ENTRY p, *pp;
    ULONG Value;
    ULONG n, Hash;
    UCHAR c;
    PCHAR s;
    PNAME_TABLE_ENTRY *pa, a;

    s = Name;
    Hash = 0;
    while (c = *s++) {
        c = (UCHAR)toupper( c );
        Hash = Hash + (c << 1) + (c >> 1) + c;
        }
    n = (ULONG)((PCHAR)s - (PCHAR)Name);

    pp = &NameTable->Buckets[ Hash % NameTable->NumberOfBuckets ];
    while (p = *pp) {
        if (!_stricmp( p->Name, Name )) {
            break;
            }
        else {
            pp = &p->HashLink;
            }
        }

    if (p == NULL) {
        p = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( *p ) + n );
        if (p == NULL) {
            return NULL;
            }
        p->HashLink = NULL;
        strcpy( p->Name, Name );
        *pp = p;
        }

    return p->Name;
}


BOOL
ProcessOptionCharacter(
    IN CHAR c
    )
{
    switch (toupper( c )) {
        case 'T':
            SortBy = TAG;
            return TRUE;

        case 'A':
            SortBy = ALLOC;
            return TRUE;

        case 'U':
        case 'B':
            SortBy = BYTES;
            return TRUE;

        case 'F':
            SortBy = FREE;
            return TRUE;

        case 'D':
            SortBy = DIFF;
            return TRUE;

        case '(':
        case ')':
            fParen = !fParen;
            return TRUE;

        case 'E':
            fDisplayTotals = !fDisplayTotals;
            return TRUE;

        case 'L':
            fHighlight = !fHighlight;
            break;

        case 'H':
        case '?':
            fHelp = TRUE;
            return TRUE;
        }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\heapwalk.c ===
#include<windows.h>
#include<stdio.h>
#include<stdlib.h>
#include<malloc.h>

DWORD NumberOfHeaps;
HANDLE ProcessHeaps[ 64 ];

char MyBuffer[ 256 ];

int
_cdecl
main()
{
    struct _heapinfo info;
    PROCESS_HEAP_ENTRY Entry;
    size_t i;
    LPBYTE s;

    info._pentry = NULL;
    setvbuf( stdout, MyBuffer, _IOFBF, sizeof( MyBuffer ) );
    _heapset( 0xAE );
    while (_heapwalk( &info ) == _HEAPOK) {
        printf( "%08x: %05x - %s", info._pentry, info._size, info._useflag ? "busy" : "free" );
        if (info._useflag == _FREEENTRY) {
            s = (LPBYTE)info._pentry;
            for (i=0; i<info._size; i++) {
                if (s[i] != 0xAE) {
                    printf( " *** free block invalid at offset %x [%x]", i, s[i] );
                    break;
                    }
                }
            }

        printf( "\n" );
        fflush( stdout );
        }
    printf( "*** end of heap ***\n\n" );
    fflush( stdout );

    NumberOfHeaps = GetProcessHeaps( 64, ProcessHeaps );
    Entry.lpData = NULL;
    for (i=0; i<NumberOfHeaps; i++) {
        printf( "Heap[ %u ]: %x  HeapCompact result: %lx\n",
                i,
                ProcessHeaps[ i ],
                HeapCompact( ProcessHeaps[ i ], 0 )
              );
        while (HeapWalk( ProcessHeaps[ i ], &Entry )) {
            if (Entry.wFlags & PROCESS_HEAP_REGION) {
                printf( "    %08x: %08x - Region(First: %08x  Last: %08x  Committed: %x  Uncommitted: %08x)\n",
                        Entry.lpData, Entry.cbData,
                        Entry.Region.lpFirstBlock,
                        Entry.Region.lpLastBlock,
                        Entry.Region.dwCommittedSize,
                        Entry.Region.dwUnCommittedSize
                      );
                }
            else
            if (Entry.wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
                printf( "    %08x: %08x - Uncommitted\n",
                        Entry.lpData, Entry.cbData
                      );
                }
            else
            if (Entry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
                printf( "    %08x: %08x - Busy", Entry.lpData, Entry.cbData );
                if (Entry.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE) {
                    printf( "  hMem: %08x", Entry.Block.hMem );
                    }

                if (Entry.wFlags & PROCESS_HEAP_ENTRY_DDESHARE) {
                    printf( "  DDE" );
                    }

                printf( "\n" );
                }
            else {
                printf( "    %08x: %08x - Free\n", Entry.lpData, Entry.cbData );
                }

            fflush( stdout );
            }

        printf( "*** end of heap ***\n\n" );
        fflush( stdout );
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\htmprint.c ===
// htmprint.c
//
// Routines to print to either console or HTML formated console.
//
// controled by 'bHtmlStyle'.  If TRUE, we will output HTML.
//

BOOL bHtmlStyle= FALSE;


VOID TableHeader(VOID)
{

    if( bHtmlStyle )
    {
        printf( "<TABLE BORDER CELLPADDING=\"0\">\n" );
    }
}

VOID TableTrailer(VOID)
{

    if( bHtmlStyle )
    {
        printf( "</TABLE>\n" );
    }
}


VOID TableStart(VOID)
{
    if( bHtmlStyle )
    {
        printf( "<TR>\n");
    }
}

VOID TableField( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    printf(pszFormat,pszDatum);

    if( bHtmlStyle )
    {
        printf("&nbsp</TD>\n");
    }
}

VOID TableNum( CHAR* pszFormat, INT Datum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    printf(pszFormat,Datum);

    if( bHtmlStyle )
    {
        printf("&nbsp</TD>\n");
    }
}


// Print string making sure the string won't break (nbsp)

VOID TableSS( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    if( bHtmlStyle )
    {
        INT i;

        for( i=0; (i<lstrlen(pszDatum)); i++ )
        {
            if( pszDatum[i] != ' ' )
            {
                printf("%c",pszDatum[i]);
            }
            else
            {
                printf("&nbsp");
            }
        }
        printf("&nbsp");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

    if( bHtmlStyle )
    {
        printf("</TD>\n");
    }

}

VOID TableEmail( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
        printf("<A href=\"mailto:%s\"> %s </a>",pszDatum, pszDatum );
        printf("&nbsp</TD>\n");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

}

VOID TableBugID( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
        printf("<A href=\"http://nitest/ntraid/raid_det.asp?BugID=%p\"> %p </a>",pszDatum, pszDatum );
        printf("&nbsp</TD>\n");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

}

VOID TableEnd(VOID)
{
    if( bHtmlStyle )
    {
        printf( "</TR>\n");
    }
    printf("\n");
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\mapstringint.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mapstringtoint.h

Abstract:

    This module defines the MAPSTRINGTOINT class and the STRINGTOINTASSOCIATION type.

Author:

    Matt Bandy (t-mattba) 24-Jul-1998

Revision History:

    24-Jul-1998     t-mattba
        
        Modified module to conform to coding standards.
        
--*/

#ifndef _MAPSTRINGTOINT_
#define _MAPSTRINGTOINT_

typedef struct _STRINGTOINTASSOCIATION {
    
    LPTSTR Key;
    LONG Value;
    struct _STRINGTOINTASSOCIATION *Next;
    
} STRINGTOINTASSOCIATION, *PSTRINGTOINTASSOCIATION;

class MAPSTRINGTOINT
{
    
private:

    PSTRINGTOINTASSOCIATION Associations;
    
public:

    MAPSTRINGTOINT(
        );
    ~MAPSTRINGTOINT(
        );
    LONG & 
    operator [] (
        IN LPTSTR Key
        );
    BOOLEAN
    Lookup(
        IN LPTSTR Key,
        OUT LONG & Value
        );
    PSTRINGTOINTASSOCIATION
    GetStartPosition(
        );
    VOID
    GetNextAssociation(
        IN OUT PSTRINGTOINTASSOCIATION & Position,
        OUT LPTSTR & Key, 
        OUT LONG & Value
        );
        
};

typedef MAPSTRINGTOINT * PMAPSTRINGTOINT;

#endif // _MAPSTRINGTOINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\resource.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This module defines resource identifiers for OHCMP.

Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba
    
        Modified module to conform to coding standards.

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#define IDS_HELLO                       1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\oh.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

   oh.cxx

Abstract:

    Prints out kernel handle information for a given process or systemwide
    and compares logs with handle information for possible leaks.

Author:

    SteveWo (probably)
    ChrisW - tweaks, GC style leak checking
    SilviuC - support for stack traces
    SilviuC - added log compare functionality (a la ohcmp)

Futures:

    get -h to work without -p (ie stack traces for all processes)
    for the -u feature, look for unaligned values

--*/

//
// OH version. 
//
// Please update this for important changes
// so that people can understand what version of the tool
// created a log.
//

#define LARGE_HITCOUNT 1234

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <memory.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <common.ver>
#include <dbghelp.h>

#include "MAPSTRINGINT.h"

LPTSTR OhHelpText =

    TEXT("oh - Object handles dump --") BUILD_MACHINE_TAG TEXT("\n")
    VER_LEGALCOPYRIGHT_STR TEXT("\n") 
    TEXT("                                                                        \n")
    TEXT("OH [DUMP_OPTIONS ...]                                                   \n")
    TEXT("OH [FLAGS_OPTIONS ...]                                                  \n")
    TEXT("OH -c [COMPARE_OPTIONS ...] BEFORE_LOG AFTER_LOG                        \n")
    TEXT("                                                                        \n")
    TEXT("DUMP_OPTIONS are:                                                       \n")
    TEXT("                                                                        \n")
    TEXT("    -p N - displays only open handles for process with ID of n. If not  \n")
    TEXT("           specified perform a system wide dump.                        \n")
    TEXT("    -t TYPENAME - displays only open object names of specified type.    \n")
    TEXT("    -o FILENAME - specifies the name of the file to write the output to.\n")
    TEXT("    -a includes objects with no name.                                   \n")
    TEXT("    -s display summary information                                      \n")
    TEXT("    -h display stack traces for handles (a process ID must be specified)\n")
    TEXT("    -u display only handles with no references in process memory        \n")
    TEXT("    -v verbose mode (used for debugging oh)                             \n")
    TEXT("    NAME - displays only handles that contain the specified name.       \n")
    TEXT("                                                                        \n")
    TEXT("FLAGS_OPTIONS are:                                                      \n")
    TEXT("                                                                        \n")
    TEXT("    [+kst|-kst] - enable or disable kst flag (kernel mode stack traces).\n")
    TEXT("    [+otl|-otl] - enable or disable otl flag (object lists).            \n")
    TEXT("                                                                        \n")
    TEXT("The `OH [+otl] [+kst]' command can be used to set the global flags      \n")
    TEXT("needed by OH. `+otl' is needed for all OH options and `+kst' is needed  \n")
    TEXT("by the `-h' option. The changes will take effect only after reboot.     \n")
    TEXT("The flags can be disabled by using `-otl' or `-kst' respectively.       \n")
    TEXT("                                                                        \n")
    TEXT("COMPARE_OPTIONS are:                                                    \n")
    TEXT("                                                                       \n")
    TEXT("    -l     Print most interesting increases in a separate initial section. \n")
    TEXT("    -t     Do not add TRACE id to the names if files contain traces.       \n")
    TEXT("    -all   Report decreases as well as increases.                          \n")
    TEXT("                                                                       \n")
    TEXT("If the OH files have been created with -h option (they contain traces) \n")
    TEXT("then handle names will be printed using this syntax: (TRACEID) NAME.        \n")
    TEXT("In case of a potential leak just search for the TRACEID in the original\n")
    TEXT("OH file to find the stack trace.                                       \n")
    TEXT("                                                                       \n");




typedef DWORD PID;

PID ProcessId;
WCHAR TypeName[ 128 ];
WCHAR SearchName[ 512 ];


typedef struct _HANDLE_AUX_INFO {
    ULONG_PTR                          HandleValue;  // value of handle for a process
    PID                                Pid;          // Process ID for this handle
    DWORD                              HitCount;     // number of references
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;  // points to main table entry
} HANDLE_AUX_INFO, *PHANDLE_AUX_INFO;


//
// Globals
//

struct {

    FILE*                   Output;             // output file
    PRTL_PROCESS_BACKTRACES TraceDatabase;      // stack traces 
    HANDLE                  TargetProcess;      // process handle to get symtab info from

    BOOL                    DumpTraces;         // True if we are to dump stack traces

    HANDLE_AUX_INFO*        AuxInfo;            // additional data for every handle
    DWORD                   AuxSize;            // number of entries in AuxInfo

    BOOL                    fOnlyShowNoRefs;    // Only show handles with NO references
    BOOL                    fVerbose;           // display debugging text

} Globals;

//
// Log comparing main function (ohcmp).
//

VOID
OhCmpCompareLogs (
    IN LONG argc,
    IN LPTSTR argv[]
    );

//
// Global flags handling
//

DWORD
OhGetCurrentGlobalFlags (
    );

VOID
OhSetRequiredGlobalFlag (
    DWORD Flags
    );

VOID
OhResetRequiredGlobalFlag (
    DWORD Flags
    );

//
// Memory management
//

PVOID
OhAlloc (
    SIZE_T Size
    );

VOID
OhFree (
    PVOID P
    );

PVOID
OhZoneAlloc(
    IN OUT SIZE_T *Length
    );

VOID
OhZoneFree(
    IN PVOID Buffer
    );

PVOID
OhZoneAllocEx(
    SIZE_T Size
    );

//
// Others
//

VOID
OhError (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

VOID
OhDumpHandles (
    BOOLEAN DumpAnonymousHandles
    );

VOID
OhInitializeHandleStackTraces (
    PID Pid
    );

VOID
OhDumpStackTrace (
    PRTL_PROCESS_BACKTRACES TraceDatabase,
    USHORT Index
    );

BOOL
OhSetSymbolsPath (
    );

VOID
OhStampLog (
    VOID
    );

VOID
Info (
    PCHAR Format,
    ...
    );

VOID
OhComment (
    PCHAR Format,
    ...
    );

VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );


PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    );

VOID
DoSummary( VOID );

BOOLEAN
AnsiToUnicode(
    LPCSTR Source,
    PWSTR Destination,
    ULONG NumberOfChars
    )
{
    if (NumberOfChars == 0) {
        NumberOfChars = strlen( Source );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             Source,
                             NumberOfChars,
                             Destination,
                             NumberOfChars
                           ) != (LONG)NumberOfChars
       ) {
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
        return FALSE;
        }
    else {
        Destination[ NumberOfChars ] = UNICODE_NULL;
        return TRUE;
        }
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////// main(), command line processing
/////////////////////////////////////////////////////////////////////

VOID 
Help (
    VOID
    )
/*++

Routine Description:

This routine prints out a message describing the proper usage of OH.

Arguments:

    None.

Return value:

    None.
    
--*/
{
    fputs (OhHelpText, stderr);
    exit (1);
}


int __cdecl
main (
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOLEAN fAnonymousToo;
    BOOLEAN fDoSummary;
    char *s;
    NTSTATUS Status;
    PRTL_DEBUG_INFORMATION p;
    CHAR OutputFileName [MAX_PATH];
    DWORD GlobalFlags;
    int Index;
    BOOL FlagsSetRequested = FALSE;
    BOOLEAN bJunk;

    _try {

        //
        // Print to stdout for now.
        //

        Globals.Output = stdout;

        //
        // Check for help first.
        //

        if (argc >= 2 && strstr (argv[1], "?") != NULL) {
            Help ();
        }

        //
        // Get current global flags.
        //

        GlobalFlags = OhGetCurrentGlobalFlags ();

        OutputFileName[0]='\0';

        ProcessId = 0;

        fAnonymousToo = FALSE;
        fDoSummary = FALSE ;

        //
        // Before any other command line parsing check for `+otl' or `+kst' options.
        //

        for (Index = 1; Index < argc; Index += 1) {

            if (_stricmp (argv[Index], "+otl") == 0) {

                OhSetRequiredGlobalFlag (FLG_MAINTAIN_OBJECT_TYPELIST);
                FlagsSetRequested = TRUE;
            }
            else if (_stricmp (argv[Index], "+kst") == 0) {

                OhSetRequiredGlobalFlag (FLG_KERNEL_STACK_TRACE_DB);
                FlagsSetRequested = TRUE;
            }
            else if (_stricmp (argv[Index], "-otl") == 0) {

                OhResetRequiredGlobalFlag (FLG_MAINTAIN_OBJECT_TYPELIST);
                FlagsSetRequested = TRUE;
            }
            else if (_stricmp (argv[Index], "-kst") == 0) {

                OhResetRequiredGlobalFlag (FLG_KERNEL_STACK_TRACE_DB);
                FlagsSetRequested = TRUE;
            }
        }

        if (FlagsSetRequested == TRUE) {
            exit (0);
        }

        //
        // Now check if we want log comparing functionality (a la ohcmp).
        //

        if (argc > 2 && _stricmp (argv[1], "-c") == 0) {

            OhCmpCompareLogs (argc - 1, &(argv[1]));
            exit (0);
        }

        //
        // Figure out if we have the +otl global flag. We need to do this
        // before getting into real oh functionality.
        //

        if ((GlobalFlags & FLG_MAINTAIN_OBJECT_TYPELIST) == 0) {

            Info ("The system global flag `maintain object type lists' is not enabled  \n"
                  "for this system. Please use `oh +otl' to enable it and then reboot. \n");

            exit (1);
        }

        //
        // Finally parse the `oh' command line.
        //

        while (--argc) {
            s = *++argv;
            if (*s == '/' || *s == '-') {
                while (*++s) {
                    switch (tolower(*s)) {
                        case 'a':
                        case 'A':
                            fAnonymousToo = TRUE;
                            break;

                        case 'p':
                        case 'P':
                            if (--argc) {
                                ProcessId = (PID)atol( *++argv );
                            }
                            else {
                                Help();
                            }
                            break;

                        case 'h':
                        case 'H':
                            Globals.DumpTraces = TRUE;
                            break;

                        case 'o':
                        case 'O':
                            if (--argc) {
                                strncpy( OutputFileName, *++argv, sizeof(OutputFileName)-1 );
                                OutputFileName[sizeof(OutputFileName)-1]= 0;
                            }
                            else {
                                Help();
                            }
                            break;

                        case 't':
                        case 'T':
                            if (--argc) {
                                AnsiToUnicode( *++argv, TypeName, 0 );
                            }
                            else {
                                Help();
                            }
                            break;

                        case 's':
                        case 'S':
                            fDoSummary = TRUE;
                            break;

                        case 'u':
                        case 'U':
                            Globals.fOnlyShowNoRefs= TRUE;
                            break;

                        case 'v':
                        case 'V':
                            Globals.fVerbose= TRUE;
                            break;

                        default:
                            Help();
                    }
                }
            }
            else
            if (*SearchName) {
                Help();
            }
            else {
                AnsiToUnicode( s, SearchName, 0 );
            }
        }

        if (OutputFileName[0] == '\0') {
            Globals.Output = stdout;
        }
        else {
            Globals.Output = fopen (OutputFileName, "w");
        }

        if (Globals.Output == NULL) {

            OhError (NULL, 0,
                       "cannot open output file `%s' (error %u) \n", 
                       OutputFileName,
                       GetLastError ());
        }

        //
        // Get debug privilege.  This will be useful for opening processes.
        //

        Status= RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &bJunk);

        if( !NT_SUCCESS(Status) ) {

            Info ( "RtlAdjustPrivilege(SE_DEBUG) failed with status = %X. -u may not work.",
                       Status);
        }


        //
        // Stamp the log with OS version, time, machine name, etc.
        //

        OhStampLog ();

        if (Globals.DumpTraces) {

            if (ProcessId == 0) {

                OhError (NULL, 
                         0,
                         "`-h' option can be used only if a process ID is specified with `-p PID'");
            }

            if ((GlobalFlags & FLG_KERNEL_STACK_TRACE_DB) == 0) {

                Info ("The system global flag `get kernel mode stack traces' is not enabled \n"
                      "for this system. Please use `oh +kst' to enable it and then reboot.  \n");

                exit (1);
            }

            OhInitializeHandleStackTraces ( ProcessId );
        }

        p = RtlQuerySystemDebugInformation( 0 );
        if (p == NULL) {
            fprintf( stderr, "OH1: Unable to query kernel mode information.\n" );
            exit( 1 );
        }

        OhDumpHandles (fAnonymousToo);

        if ( fDoSummary ) {
            DoSummary();
        }

        if (Globals.Output != stdout) {
            fclose (Globals.Output);
        }

        RtlDestroyQueryDebugBuffer( p );
        return 0;
    }
    _except (EXCEPTION_EXECUTE_HANDLER) {

        OhComment ("Exception %X raised within OH process. Aborting ... \n",
                   _exception_code());
    }

    return 0;
}


typedef struct _PROCESS_INFO {
    LIST_ENTRY                   Entry;
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    PSYSTEM_THREAD_INFORMATION   ThreadInfo[ 1 ];
} PROCESS_INFO, *PPROCESS_INFO;

LIST_ENTRY ProcessListHead;

PSYSTEM_OBJECTTYPE_INFORMATION  ObjectInformation;
PSYSTEM_HANDLE_INFORMATION_EX   HandleInformation;
PSYSTEM_PROCESS_INFORMATION     ProcessInformation;

typedef struct _TYPE_COUNT {
    UNICODE_STRING  TypeName ;
    ULONG           HandleCount ;
} TYPE_COUNT, * PTYPE_COUNT ;

#define MAX_TYPE_NAMES 128

TYPE_COUNT TypeCounts[ MAX_TYPE_NAMES + 1 ] ;

UNICODE_STRING UnknownTypeIndex;

#define RTL_NEW( p ) RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *p ) )

BOOLEAN
OhLoadSystemModules(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
OhLoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
OhLoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
OhLoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    );

PSYSTEM_PROCESS_INFORMATION
OhFindProcessInfoForCid(
    IN PID UniqueProcessId
    );

PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PRTL_DEBUG_INFORMATION Buffer;

    Buffer = (PRTL_DEBUG_INFORMATION)RTL_NEW( Buffer );
    if (Buffer == NULL) {
        return NULL;
    }

    if (!OhLoadSystemObjects( Buffer )) {
        fprintf( stderr, "OH2: Unable to query system object information.\n" );
        exit (1);
     }

    if (!OhLoadSystemHandles( Buffer )) {
        fprintf( stderr, "OH3: Unable to query system handle information.\n" );
        exit (1);
    }

    if (!OhLoadSystemProcesses( Buffer )) {
        fprintf( stderr, "OH4: Unable to query system process information.\n" );
        exit (1);
    }

    return Buffer;
}


BOOLEAN
OhLoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    NTSTATUS Status;
    SYSTEM_OBJECTTYPE_INFORMATION ObjectInfoBuffer;
    SIZE_T RequiredLength, NewLength=0;
    ULONG i;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;

    ObjectInformation = &ObjectInfoBuffer;
    RequiredLength = sizeof( *ObjectInformation );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemObjectInformation,
                                           ObjectInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH && NewLength > RequiredLength) {
            if (ObjectInformation != &ObjectInfoBuffer) {
                OhZoneFree (ObjectInformation);
            }
            RequiredLength = NewLength + 4096;
            ObjectInformation = (PSYSTEM_OBJECTTYPE_INFORMATION)OhZoneAlloc (&RequiredLength);
            if( ObjectInformation == NULL ) {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status )) {
            if( ObjectInformation != &ObjectInfoBuffer ) {
                OhZoneFree (ObjectInformation);
            }
            return FALSE;
        }
        else {
            break;
        }
    }

    TypeInfo = ObjectInformation;

    while (TRUE) {

        if (TypeInfo->TypeIndex < MAX_TYPE_NAMES) {
            TypeCounts[ TypeInfo->TypeIndex ].TypeName = TypeInfo->TypeName;
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }


        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    RtlInitUnicodeString( &UnknownTypeIndex, L"UnknownTypeIdx" );
    for (i=0; i<=MAX_TYPE_NAMES; i++) {
        if (TypeCounts[ i ].TypeName.Length == 0 ) {
            TypeCounts[ i ].TypeName = UnknownTypeIndex;
        }
    }

    return TRUE;
}


BOOLEAN
OhLoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine description:

    This routine ...
    
Parameters:

    Information buffer to fill.
    
Return value:

    True if all information was obtained from kernel side.        

--*/
{
    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION_EX HandleInfoBuffer;
    SIZE_T RequiredLength;
    SIZE_T NewLength = 0;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;

    HandleInformation = &HandleInfoBuffer;
    RequiredLength = sizeof( *HandleInformation );

    while (TRUE) {

        Status = NtQuerySystemInformation( SystemExtendedHandleInformation,
                                           HandleInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH && NewLength > RequiredLength) {
            if (HandleInformation != &HandleInfoBuffer) {
                OhZoneFree (HandleInformation);
            }

            RequiredLength = NewLength + 4096; // slop, since we may trigger more handle creations.
            HandleInformation = (PSYSTEM_HANDLE_INFORMATION_EX)OhZoneAlloc( &RequiredLength );
            if (HandleInformation == NULL) {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status )) {
            if (HandleInformation != &HandleInfoBuffer) {
                OhZoneFree (HandleInformation);
            }

            OhError (__FILE__, __LINE__,
                       "query (SystemExtendedHandleInformation) failed with status %08X \n",
                       Status);

            return FALSE;
        }
        else {
            break;
        }
    }

    TypeInfo = ObjectInformation;
    while (TRUE) {
        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                     ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (TRUE) {
            if (ObjectInfo->HandleCount != 0) {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
                ULONG HandleNumber;

                HandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles) {
                    if (!(HandleEntry->HandleAttributes & 0x80) &&
                        HandleEntry->Object == ObjectInfo->Object
                       ) {
                        HandleEntry->Object = ObjectInfo;
                        HandleEntry->HandleAttributes |= 0x80;
                    }

                    HandleEntry++;
                }
            }

            if (ObjectInfo->NextEntryOffset == 0) {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                         ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
                   ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    return TRUE;
}


BOOLEAN
OhLoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    ULONG i, TotalOffset;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer[ MAX_PATH ];
    ANSI_STRING AnsiString;
    const SIZE_T SIZE_64_KB = 0x10000;

    //
    //  Always initialize the list head, so that a failed
    //  NtQuerySystemInformation call won't cause an AV later on.
    //
    
    InitializeListHead (&ProcessListHead);

    RequiredLength = SIZE_64_KB;
    ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)OhZoneAllocEx (RequiredLength);

    while (TRUE) {
        
        Status = NtQuerySystemInformation (SystemProcessInformation,
                                           ProcessInformation,
                                           (ULONG)RequiredLength,
                                           NULL);

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            OhZoneFree (ProcessInformation);

            //
            //  Check for number overflow.
            //

            if (RequiredLength * 2 < RequiredLength) {
                return FALSE;
            }

            RequiredLength *= 2;
            ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)OhZoneAllocEx (RequiredLength);
        }
        else if (! NT_SUCCESS(Status)) {

            OhError (__FILE__, __LINE__,
                       "query (SystemProcessInformation) failed with status %08X \n",
                       Status);
        }
        else {
            
            //
            // We managed to read the process information.
            //

            break;
        }
    }

    ProcessInfo = ProcessInformation;
    TotalOffset = 0;

    while (TRUE) {

        SIZE_T ProcessEntrySize;

        if (ProcessInfo->ImageName.Buffer == NULL) {

            sprintf ((PCHAR)NameBuffer, 
                     "System Process (%p)", 
                     ProcessInfo->UniqueProcessId );
        }
        else {

            sprintf ((PCHAR)NameBuffer, 
                     "%wZ", 
                     &ProcessInfo->ImageName );
        }

        RtlInitAnsiString( &AnsiString, (PCSZ)NameBuffer );
        RtlAnsiStringToUnicodeString( &ProcessInfo->ImageName, &AnsiString, TRUE );

        ProcessEntrySize = sizeof (*ProcessEntry) + sizeof (ThreadInfo) * ProcessInfo->NumberOfThreads;
        ProcessEntry = (PPROCESS_INFO)OhAlloc (ProcessEntrySize);
        
        InitializeListHead( &ProcessEntry->Entry );
        ProcessEntry->ProcessInfo = ProcessInfo;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        
        for (i = 0; i < ProcessInfo->NumberOfThreads; i += 1) {
            ProcessEntry->ThreadInfo[i] = ThreadInfo;
            ThreadInfo += 1;
        }

        InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) ((PCHAR)ProcessInformation + TotalOffset);
    }

    return TRUE;
}


PSYSTEM_PROCESS_INFORMATION
OhFindProcessInfoForCid(
    IN PID UniqueProcessId
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PLIST_ENTRY Next, Head;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer [64];
    ANSI_STRING AnsiString;

    Head = &ProcessListHead;
    Next = Head->Flink;
    
    while (Next != Head) {

        ProcessEntry = CONTAINING_RECORD (Next,
                                          PROCESS_INFO,
                                          Entry);

        ProcessInfo = ProcessEntry->ProcessInfo;
        if(  ProcessInfo->UniqueProcessId == UlongToHandle(UniqueProcessId) ) {
            return ProcessInfo;
        }

        Next = Next->Flink;
        }

    ProcessEntry = (PPROCESS_INFO)RtlAllocateHeap (RtlProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   sizeof( *ProcessEntry ) + sizeof( *ProcessInfo ));
    
    if (ProcessEntry == NULL) {
        printf ("Failed to allocate memory for process\n");
        ExitProcess (0);
    }
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessEntry+1);

    ProcessEntry->ProcessInfo = ProcessInfo;
    
    sprintf ((PCHAR)NameBuffer, "Unknown Process" );
    RtlInitAnsiString( &AnsiString, (PCSZ)NameBuffer );
    RtlAnsiStringToUnicodeString( (PUNICODE_STRING)&ProcessInfo->ImageName, &AnsiString, TRUE );
    ProcessInfo->UniqueProcessId = UlongToHandle(UniqueProcessId);

    InitializeListHead( &ProcessEntry->Entry );
    InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

    return ProcessInfo;
}


//
// comparison routine used by qsort and bsearch routines
// key: (Pid, HandleValue)
//

int _cdecl AuxInfoCompare( const void* Arg1, const void* Arg2 )
{
    HANDLE_AUX_INFO* Ele1= (HANDLE_AUX_INFO*) Arg1;
    HANDLE_AUX_INFO* Ele2= (HANDLE_AUX_INFO*) Arg2;

    if( Ele1->Pid < Ele2->Pid ) {
        return -1;
    }
    if( Ele1->Pid > Ele2->Pid ) {
       return 1;
    }

    if( Ele1->HandleValue < Ele2->HandleValue ) {
        return -1;
    }
    if( Ele1->HandleValue > Ele2->HandleValue ) {
       return 1;
    }
    return 0;
}

// OhGatherData
//
// Search through a region of process space for anything that looks
// like it could the value of a handle that is opened by that process.
// If we find a reference, increment the AuxInfo.Hitcount field for that handle.
//
// returns: FALSE if it couldn't scan the region

BOOL
OhGatherData( 
    IN HANDLE ProcHan, 
    IN PID    PidToExamine, 
    IN PVOID  VAddr, 
    IN SIZE_T RegionSize
)
{
    PDWORD Buf;
    SIZE_T BytesRead;
    BOOL bStatus;
    SIZE_T i;
    HANDLE_AUX_INFO AuxToCompare;
    HANDLE_AUX_INFO* AuxInfo;


    Buf= (PDWORD)LocalAlloc( LPTR, RegionSize );
    if( Buf == NULL ) {
        OhComment("Failed to alloc mem  size= %d\n",RegionSize);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    bStatus= ReadProcessMemory( ProcHan, VAddr, Buf, RegionSize, &BytesRead );
    if( !bStatus ) {
       OhComment ( "Failed to ReadProcessMemory\n");
       if( Buf ) {
          LocalFree( Buf );
       }
       return FALSE;
    }

    // feature: this only looks for aligned dword refs.  may want unaligned too.

    for( i=0; i < BytesRead/sizeof(DWORD); i++ ) {
        AuxToCompare.HandleValue= Buf[ i ] & (~3);  // kernel ignores 2 lsb
        AuxToCompare.Pid= PidToExamine;

        AuxInfo= (HANDLE_AUX_INFO*) bsearch( &AuxToCompare,
                                             Globals.AuxInfo,
                                             Globals.AuxSize,
                                             sizeof( HANDLE_AUX_INFO ),
                                             &AuxInfoCompare );
        if( AuxInfo ) {
            AuxInfo->HitCount++;
        }
    }

    LocalFree( Buf );
    return TRUE;
}


VOID OhSearchForReferencedHandles( PID PidToExamine )
{
    HANDLE_AUX_INFO AuxToCompare;
    DWORD HandleNumber;
    HANDLE ProcHan= NULL;           // process to examine
    PVOID VAddr;                    // pointer into process virtual memory
    MEMORY_BASIC_INFORMATION MemoryInfo;
    DWORD CurrentProtect;
    SIZE_T Size;

    // ignore process IDs= 0 or 4 because they are the system process

    if( ( PidToExamine == (PID)0 ) || ( PidToExamine == (PID)4 ) ) {
        return;
    }


    AuxToCompare.Pid= PidToExamine;


    ProcHan= OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                          FALSE,
                          (PID) PidToExamine );
    if( NULL == ProcHan ) {
        OhComment ( "Could not open process %d\n",PidToExamine );
        goto errorexit;
    }

    // zero the hit counts for this process number
    // if we can't read the memory, we will re-fill the HitCount fields with non-zero 

    for( HandleNumber=0; HandleNumber < Globals.AuxSize;  HandleNumber++ ) {
        if( Globals.AuxInfo[ HandleNumber ].Pid == PidToExamine ) {
            Globals.AuxInfo[ HandleNumber ].HitCount= 0;
        }
    }

    // read thru all interesting process memory
    // if we get a value that the process could have written, then see if
    // it matches one of our handle values.  Keep track of the number of matches.
    // if any HitCount field is zero when we are done, there is no way to reference it.
    // modulo (encrypted it in memory (xor), truncated into a short, or hidden it 
    // in a file, memory section not mapped, registry.)


    for( VAddr= 0;
         VAddr < (PVOID) (0x80000000-0x10000);
         VAddr= (PVOID) ((PCHAR) VAddr+ MemoryInfo.RegionSize) )
    {

        MemoryInfo.RegionSize=0x1000;
        Size= VirtualQueryEx( ProcHan,
                              VAddr,
                              &MemoryInfo,
                              sizeof( MemoryInfo ) );
        if( Size != sizeof(MemoryInfo) ) {
           fprintf(stderr,"VirtualQueryEx failed at %p  LastError %d\n",VAddr,GetLastError() );
        }
        else {
            CurrentProtect= MemoryInfo.Protect;

            if( MemoryInfo.State == MEM_COMMIT ) {
               if( (CurrentProtect & (PAGE_READWRITE|PAGE_READWRITE) ) &&
                 ( (CurrentProtect&PAGE_GUARD)==0 )
               ) {
                   BOOL bSta;

                   bSta= OhGatherData( ProcHan, PidToExamine, VAddr, MemoryInfo.RegionSize );
                   if( !bSta ) {
                      goto errorexit;
                   }
               }
            }
        }
    }

    CloseHandle( ProcHan ); ProcHan= NULL;

    return;

    // If we have an error, just mark all the HitCount values so it looks like they
    // have been referenced.
errorexit:

    for( HandleNumber=0; HandleNumber < Globals.AuxSize; HandleNumber++ ) {
        if( Globals.AuxInfo[ HandleNumber ].Pid == PidToExamine ) {
            Globals.AuxInfo[ HandleNumber].HitCount= LARGE_HITCOUNT;
        }
    }
    CloseHandle( ProcHan ); ProcHan= NULL;
    return;
}



VOID
OhBuildAuxTables( PID PidToExamine )
/*++

Routine description:

Creates auxillary table keyed with (HandleValue,Pid) containing HitCount

Parameters:
The Process ID to examine

Return value:

--*/
{
    PID PreviousUniqueProcessId;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
    ULONG HandleNumber;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    DWORD TotalHandles;
    PID LastPid;

    HANDLE_AUX_INFO* AuxInfo;

    Globals.AuxInfo= NULL;
    Globals.AuxSize= 0;

    TotalHandles=(DWORD) HandleInformation->NumberOfHandles;

    // Allocate AuxInfo table

    AuxInfo= (HANDLE_AUX_INFO*) LocalAlloc( LPTR, TotalHandles*sizeof(HANDLE_AUX_INFO) );
    if( NULL == AuxInfo ) {
        return;
    } 
    Globals.AuxInfo= AuxInfo;
    Globals.AuxSize= TotalHandles;

    // populate the table with key information

    HandleEntry = &HandleInformation->Handles[ 0 ];
    PreviousUniqueProcessId = (PID) -1;

    for (HandleNumber = 0; HandleNumber < TotalHandles; HandleNumber++ ) {

        if (PreviousUniqueProcessId != (PID)HandleEntry->UniqueProcessId) {
            PreviousUniqueProcessId = (PID)HandleEntry->UniqueProcessId;
            ProcessInfo= OhFindProcessInfoForCid( PreviousUniqueProcessId );
        }

        AuxInfo[ HandleNumber ].HandleValue= HandleEntry->HandleValue;
        AuxInfo[ HandleNumber ].Pid=         HandleToUlong(ProcessInfo->UniqueProcessId);
        AuxInfo[ HandleNumber ].HitCount=    LARGE_HITCOUNT;
        AuxInfo[ HandleNumber ].HandleEntry= HandleEntry;

        HandleEntry++;

    }

    // Sort the table so bsearch works later

    qsort( AuxInfo, 
           TotalHandles,
           sizeof( HANDLE_AUX_INFO ),
           AuxInfoCompare );

    //
    // Search the process or processes for references and keep count
    //

    if( PidToExamine ) {
        OhSearchForReferencedHandles( PidToExamine );
        return;
    }

    //
    // No Pid then do all the Pids on the system
    // (actually only search Pids that have kernel handles)
    // 

    LastPid= (PID) -1;
    for( HandleNumber=0; HandleNumber < TotalHandles; HandleNumber++ ) {
        PID ThisPid= Globals.AuxInfo[ HandleNumber ].Pid;
        if( LastPid != ThisPid ) {
            OhSearchForReferencedHandles( ThisPid );
            LastPid= ThisPid;
        }
    }

}


VOID
OhDumpHandles (
    BOOLEAN DumpAnonymousHandles
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PID PreviousUniqueProcessId;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
    ULONG HandleNumber;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    PUNICODE_STRING ObjectTypeName;
    WCHAR ObjectName[ 1024 ];
    PVOID Object;
    CHAR OutputLine[ 512 ];
    PWSTR s;
    ULONG n;
    DWORD d = 0;
    BOOL AnyRefs;


    OhBuildAuxTables( ProcessId );


    HandleEntry = &HandleInformation->Handles[ 0 ];
    HandleNumber = 0;
    PreviousUniqueProcessId = (PID) -1;
    for (HandleNumber = 0;
         HandleNumber < HandleInformation->NumberOfHandles;
         HandleNumber++, HandleEntry++
        )
    {
        if (PreviousUniqueProcessId != (PID)HandleEntry->UniqueProcessId) {
            PreviousUniqueProcessId = (PID)HandleEntry->UniqueProcessId;
            ProcessInfo = OhFindProcessInfoForCid( PreviousUniqueProcessId );
        }

        ObjectName[ 0 ] = UNICODE_NULL;
        if (HandleEntry->HandleAttributes & 0x80) {
            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)(HandleEntry->Object);
            Object = ObjectInfo->Object;
            _try {
                if (ObjectInfo->NameInfo.Name.Length != 0 &&
                    *(ObjectInfo->NameInfo.Name.Buffer) == UNICODE_NULL
                   ) {
                    ObjectInfo->NameInfo.Name.Length = 0;
                 }

                n = ObjectInfo->NameInfo.Name.Length / sizeof( WCHAR );
                wcsncpy( ObjectName,
                         ObjectInfo->NameInfo.Name.Buffer,
                         n
                       );
                ObjectName[ n ] = UNICODE_NULL;
            }
            _except( EXCEPTION_EXECUTE_HANDLER ) {
                _snwprintf( ObjectName, 1024, L"[%04x, %04x, %08x]",
                            ObjectInfo->NameInfo.Name.MaximumLength,
                            ObjectInfo->NameInfo.Name.Length,
                            ObjectInfo->NameInfo.Name.Buffer
                          );
            }
        }
        else {
            ObjectInfo = NULL;
            Object = HandleEntry->Object;
        }

        if( ProcessId != 0 && ProcessInfo->UniqueProcessId != UlongToHandle(ProcessId) ) {
            continue;
        }

        ObjectTypeName = &TypeCounts[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
                                            HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].TypeName ;

        TypeCounts[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
                        HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].HandleCount++ ;

        if (TypeName[0]) {
            if (_wcsicmp( TypeName, ObjectTypeName->Buffer )) {
                continue;
            }
        }

        if (!*ObjectName) {
            if (! DumpAnonymousHandles) {
                continue;
            }
        }
        else
        if (SearchName[0]) {
            if (!wcsstr( ObjectName, SearchName )) {
                s = ObjectName;
                n = wcslen( SearchName );
                while (*s) {
                    if (!_wcsnicmp( s, SearchName, n )) {
                        break;
                        }
                    s += 1;
                }

                if (!*s) {
                    continue;
                }
            }
        }

        // See if there were any references to this handle in the process memory space

        AnyRefs= TRUE;
        { 
            HANDLE_AUX_INFO* AuxInfo;
            HANDLE_AUX_INFO AuxToCompare;

            AuxToCompare.Pid=         HandleToUlong( ProcessInfo->UniqueProcessId );
            AuxToCompare.HandleValue= HandleEntry->HandleValue;

            AuxInfo= (HANDLE_AUX_INFO*) bsearch( &AuxToCompare,
                                                 Globals.AuxInfo,
                                                 Globals.AuxSize,
                                                 sizeof( HANDLE_AUX_INFO ),
                                                 &AuxInfoCompare );
            if( AuxInfo ) {
                if( AuxInfo->HitCount == 0 ) {
                   AnyRefs=FALSE;
                }
            }

        }

        if( (!Globals.fOnlyShowNoRefs) || (Globals.fOnlyShowNoRefs && (AnyRefs==FALSE) ) ) {


            if( Globals.fOnlyShowNoRefs) {
               Info ( "noref_" );
            }

            if (Globals.DumpTraces) {
                
                Info ("%p %-14wZ %-14wZ %04x (%04x) %ws\n",
                      ProcessInfo->UniqueProcessId,
                      &ProcessInfo->ImageName,
                      ObjectTypeName,
                      HandleEntry->HandleValue,
                      HandleEntry->CreatorBackTraceIndex,
                      *ObjectName ? ObjectName : L"");
            }
            else {
    
                Info ("%p %-14wZ %-14wZ %04x %ws\n",
                      ProcessInfo->UniqueProcessId,
                      &ProcessInfo->ImageName,
                      ObjectTypeName,
                      HandleEntry->HandleValue,
                      *ObjectName ? ObjectName : L"");
            }

            if (HandleEntry->CreatorBackTraceIndex && Globals.TraceDatabase) {

                OhDumpStackTrace (Globals.TraceDatabase,
                                    HandleEntry->CreatorBackTraceIndex);
            }
        }
    }

    return;
}

VOID
DoSummary( VOID )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    ULONG i ;
    ULONG ignored ;

    Info ("Summary: \n");
    
    for ( i = 0 ; i < MAX_TYPE_NAMES ; i++ )
    {
        if ( TypeCounts[ i ].HandleCount )
        {
            Info ("  %-20ws\t%d\n",
                  TypeCounts[ i ].TypeName.Buffer,
                  TypeCounts[ i ].HandleCount );
        }
    }
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Handle stack traces
/////////////////////////////////////////////////////////////////////

VOID
OhError (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

PCHAR
OhNameForAddress(
    IN HANDLE UniqueProcess,
    IN PVOID Address
    );

PRTL_PROCESS_BACKTRACES
OhLoadSystemTraceDatabase (
    )
{
    const SIZE_T OneMb = 0x100000;
    NTSTATUS Status;
    PRTL_PROCESS_BACKTRACES TraceDatabase;
    SIZE_T RequiredLength;
    SIZE_T CurrentLength;
    
    CurrentLength = OneMb;
    RequiredLength = 0;

    TraceDatabase = (PRTL_PROCESS_BACKTRACES)VirtualAlloc (NULL, 
                                                           CurrentLength, 
                                                           MEM_COMMIT, 
                                                           PAGE_READWRITE);

    if (TraceDatabase == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %p bytes", CurrentLength);
    }

    while (TRUE) {

        Status = NtQuerySystemInformation (SystemStackTraceInformation,
                                           TraceDatabase,
                                           (ULONG)CurrentLength,
                                           (ULONG *)&RequiredLength);

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            CurrentLength = RequiredLength + OneMb;

            VirtualFree (TraceDatabase,
                         0,
                         MEM_RELEASE);

            TraceDatabase = (PRTL_PROCESS_BACKTRACES)VirtualAlloc (NULL, 
                                                                   CurrentLength, 
                                                                   MEM_COMMIT, 
                                                                   PAGE_READWRITE);

            
            if (TraceDatabase == NULL) {
                OhError (__FILE__, __LINE__,
                           "failed to allocate %p bytes", CurrentLength);
            }
        }
        else if (! NT_SUCCESS(Status)) {

            OhError (__FILE__, __LINE__,
                       "QuerySystemInformation failed with status %08x",Status);
        }
        else {

            //
            // We managed to read the stack trace database.
            //

            break;
        }
    }

    return TraceDatabase;
}


VOID
OhDumpStackTrace (
    PRTL_PROCESS_BACKTRACES TraceDatabase,
    USHORT Index
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION Trace;
    USHORT I;
    PCHAR Name;
    
    if (Index >= TraceDatabase->NumberOfBackTraces) {
        return;
    }

    Trace = &(TraceDatabase->BackTraces[Index - 1]);

    if (Trace->Depth > 0) {
        Info ("\n");
    }

    for (I = 0; I < Trace->Depth; I += 1) {

        if ((ULONG_PTR)(Trace->BackTrace[I]) < 0x80000000) {

            if (Trace->BackTrace[I] == NULL) {
                break;
            }

            Name = OhNameForAddress (Globals.TargetProcess,
                                       Trace->BackTrace[I]);
            
            Info ("\t%p %s\n", 
                  Trace->BackTrace[I],
                  (Name ? Name : "<unknown>"));
        }
        else {

            Info ("\t%p <kernel address>\n", 
                  Trace->BackTrace[I]);
        }
    }

    Info ("\n");
}


BOOL
OhEnumerateModules(
    IN LPSTR ModuleName,
    IN ULONG_PTR BaseOfDll,
    IN PVOID UserContext
    )
/*++
 UmdhEnumerateModules

 Module enumeration 'proc' for imagehlp.  Call SymLoadModule on the
 specified module and if that succeeds cache the module name.

 ModuleName is an LPSTR indicating the name of the module imagehlp is
      enumerating for us;
      
 BaseOfDll is the load address of the DLL, which we don't care about, but
      SymLoadModule does;
      
 UserContext is a pointer to the relevant SYMINFO, which identifies
      our connection.
--*/
{
    DWORD64 Result;

    Result = SymLoadModule(Globals.TargetProcess,
                           NULL,             // hFile not used
                           NULL,             // use symbol search path
                           ModuleName,       // ModuleName from Enum
                           BaseOfDll,        // LoadAddress from Enum
                           0);               // Let ImageHlp figure out DLL size

    // SilviuC: need to understand exactly what does this function return

    if (Result) {

        Warning (NULL, 0,
               "SymLoadModule (%s, %p) failed with error %X (%u)",
               ModuleName, BaseOfDll,
               GetLastError(), GetLastError());

        return FALSE;
    }

    OhComment ("    %s (%p) ...", ModuleName, BaseOfDll);

    return TRUE;
}


VOID
Info (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    vfprintf (Globals.Output, Format, Params);
}


VOID
OhComment (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    fprintf (Globals.Output, "// ");
    vfprintf (Globals.Output, Format, Params);
    fprintf (Globals.Output, "\n");
}


VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (stderr, "Warning: %s: %u: ", File, Line);
    } 
    else {
        fprintf (stderr, "Warning: ");
    }

    vfprintf (stderr, Format, Params);
    fprintf (stderr, "\n");
}

VOID
OhError (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (stderr, "Error: %s: %u: ", File, Line);
    } 
    else {
        fprintf (stderr, "Error: ");
    }

    vfprintf (stderr, Format, Params);
    fprintf (stderr, "\n");

    exit (1);
}


VOID
OhStampLog (
    VOID
    )
/*++

Routine description:
    
    This routines writes an initial stamp in the log.
        
Parameters:
    
    None.
        
Return value:
    
    None.            
--*/
{
    CHAR CompName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD CompNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    SYSTEMTIME st;
    OSVERSIONINFOEX OsInfo;

    //
    // Stamp the log
    //

    ZeroMemory (&OsInfo, sizeof OsInfo);
    OsInfo.dwOSVersionInfoSize = sizeof OsInfo;

    GetVersionEx ((POSVERSIONINFO)(&OsInfo));

    GetLocalTime(&st);
    GetComputerName(CompName, &CompNameLength);

    OhComment ("");
    OhComment ("TIME: %4u-%02u-%02u %02u:%02u", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute);
    OhComment ("MACHINE: %s", CompName);
    OhComment ("BUILD: %u", OsInfo.dwBuildNumber);
    OhComment ("OH version: %s", BUILD_MACHINE_TAG);
    OhComment ("");
    OhComment ("");
}


VOID
OhInitializeHandleStackTraces (
    PID Pid
    )
/*++

    Routine description:
    
        This routine initializes all interal structures required to
        read handle stack traces. It will adjust priviles (in order
        for this to work on lsass, winlogon, etc.), open the process,
        read from kernel the trace database.
        
    Parameters:
    
        Pid - process ID for the process for which we will get traces.
        
    Return value:
    
        None.            
--*/
{
    BOOL Result;
    NTSTATUS Status;

    //
    // Check if we have a symbols path defined and define a default one
    // if not.
    //

    OhSetSymbolsPath ();

    //
    // Imagehlp library needs the query privilege for the process
    // handle and of course we need also read privilege because
    // we will read all sorts of things from the process.
    //

    Globals.TargetProcess = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                         FALSE,
                                         Pid);

    if (Globals.TargetProcess == NULL) {

        OhError (__FILE__, __LINE__,
               "OpenProcess(%u) failed with error %u", Pid, GetLastError());
    }

    OhComment ("Process %u opened.", Pid);

    //
    // Attach ImageHlp and enumerate the modules.
    //

    Result = SymInitialize(Globals.TargetProcess, // target process
                           NULL,                  // standard symbols search path
                           TRUE);                 // invade process space with symbols

    if (Result == FALSE) {

        ULONG ErrorCode = GetLastError();

        if (ErrorCode >= 0x80000000) {
            
            OhError (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %X", ErrorCode);
        }
        else {

            OhError (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %u", ErrorCode);
        }
    }

    OhComment ("Dbghelp initialized.");

    SymSetOptions(SYMOPT_CASE_INSENSITIVE | 
                  SYMOPT_DEFERRED_LOADS |
                  SYMOPT_LOAD_LINES |
                  SYMOPT_UNDNAME);

    OhComment ("Enumerating modules ...");
    OhComment ("");

    Result = SymEnumerateModules (Globals.TargetProcess,
                                  OhEnumerateModules,
                                  Globals.TargetProcess);
    if (Result == FALSE) {

        OhError (__FILE__, __LINE__,
               "SymEnumerateModules() failed with error %u", GetLastError());
    }

    OhComment ("");
    OhComment ("Finished module enumeration.");

    //
    // Initialize local trace database. Note that order is important.
    // Initialize() assumes the process handle to the target process
    // already exists and the symbol management package was initialized.
    //

    OhComment ("Loading stack trace database ...");

    Globals.TraceDatabase = OhLoadSystemTraceDatabase ();

    OhComment ("Initialization finished.");
    OhComment ("");

    OhComment ("\n");
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Symbol lookup
/////////////////////////////////////////////////////////////////////

#define HNDL_SYMBOL_MAP_BUCKETS 4096

typedef struct _HNDL_SYMBOL_ENTRY
{
    PVOID Address;
    PCHAR Symbol;
    struct _HNDL_SYMBOL_ENTRY * Next;

} HNDL_SYMBOL_ENTRY, * PHNDL_SYMBOL_ENTRY;

PHNDL_SYMBOL_ENTRY OhSymbolsMap [HNDL_SYMBOL_MAP_BUCKETS];


PCHAR 
OhFindSymbol (
    PVOID Address 
    )
{
    ULONG_PTR Bucket = ((ULONG_PTR)Address >> 2) % HNDL_SYMBOL_MAP_BUCKETS;
    PHNDL_SYMBOL_ENTRY Node = OhSymbolsMap[Bucket];

    while (Node != NULL ) {

        if (Node->Address == Address) {
            return Node->Symbol;
        }

        Node = Node->Next;
    }

    return NULL;
}

VOID 
OhInsertSymbol (
    PCHAR Symbol, 
    PVOID Address 
    )
{
    ULONG_PTR Bucket = ((ULONG_PTR)Address >> 2) % HNDL_SYMBOL_MAP_BUCKETS;

    PHNDL_SYMBOL_ENTRY New;
     
    New = (PHNDL_SYMBOL_ENTRY) OhAlloc (sizeof (HNDL_SYMBOL_ENTRY));
    
    New->Symbol = Symbol;
    New->Address = Address;
    New->Next = OhSymbolsMap[Bucket];

    OhSymbolsMap[Bucket] = New;
}


PCHAR
OhNameForAddress(
    IN HANDLE UniqueProcess,
    IN PVOID Address
    )
{
    IMAGEHLP_MODULE ModuleInfo;
    CHAR SymbolBuffer[512];
    PIMAGEHLP_SYMBOL Symbol;
    ULONG_PTR Offset;
    CHAR Name [512 + 100];
    SIZE_T TotalSize;
    BOOL Result;
    PVOID Duplicate;
    PCHAR SymbolName;

    //
    // Lookup in map first ..
    //

    SymbolName = OhFindSymbol (Address);

    if (SymbolName != NULL) {
        return SymbolName;
    }
    
    TotalSize = 0;
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (SymGetModuleInfo (UniqueProcess, (ULONG_PTR)Address, &ModuleInfo)) {

        TotalSize += strlen( ModuleInfo.ModuleName );
    }
    else {

        Warning (NULL, 0,
               "Symbols: cannot identify module for address %p", 
               Address);
        
        return NULL;
    }

    Symbol = (PIMAGEHLP_SYMBOL)SymbolBuffer;
    Symbol->MaxNameLength = 512 - sizeof(IMAGEHLP_SYMBOL) - 1;

    if (SymGetSymFromAddr (UniqueProcess, (ULONG_PTR)Address, &Offset, Symbol)) {

        TotalSize += strlen (Symbol->Name) + 16 + 3;

        sprintf (Name, "%s!%s+%08X", ModuleInfo.ModuleName, Symbol->Name, Offset);

        Duplicate = _strdup(Name);
        OhInsertSymbol ((PCHAR)Duplicate, Address);
        return (PCHAR)Duplicate;
    }
    else {

        Warning (NULL, 0,
               "Symbols: incorrect symbols for module %s (address %p)", 
               ModuleInfo.ModuleName,
               Address);

        TotalSize += strlen ("???") + 16 + 5;

        sprintf (Name, "%s!%s @ %p", ModuleInfo.ModuleName, "???", Address);

        Duplicate = _strdup(Name);
        OhInsertSymbol ((PCHAR)Duplicate, Address);
        return (PCHAR)Duplicate;
    }
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Registry handling
/////////////////////////////////////////////////////////////////////

//
// Registry key name to read/write system global flags
//

#define KEYNAME_SESSION_MANAGER "SYSTEM\\CurrentControlSet\\Control\\Session Manager"

DWORD
OhGetCurrentGlobalFlags (
    )
{
    SYSTEM_FLAGS_INFORMATION Information;
    NTSTATUS Status;

    Status = NtQuerySystemInformation (SystemFlagsInformation,
                                       &Information,
                                       sizeof Information,
                                       NULL);

    if (! NT_SUCCESS(Status)) {

        OhError (NULL, 0,
                   "cannot get current global flags settings (error %08X) \n",
                   Status);
    }

    return Information.Flags;
}

DWORD
OhGetSystemRegistryFlags ( 
    )
{
    DWORD cbKey;
    DWORD GFlags;
    DWORD type;
    HKEY hKey;
    LONG Result;

    Result = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           KEYNAME_SESSION_MANAGER,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hKey);

    if (Result != ERROR_SUCCESS) {

        OhError (NULL, 0,
                   "cannot open registry key `%s' \n", 
                   KEYNAME_SESSION_MANAGER);
    }

    cbKey = sizeof (GFlags);

    Result = RegQueryValueEx (hKey,
                              "GlobalFlag",
                              0,
                              &type,
                              (LPBYTE)&GFlags,
                              &cbKey);
    
    if (Result != ERROR_SUCCESS || type != REG_DWORD) {

        OhError (NULL, 0,
                   "cannot read registry value '%s'\n", 
                   KEYNAME_SESSION_MANAGER "\\GlobalFlag");
    }

    RegCloseKey (hKey); 
    hKey = NULL;

    return GFlags;
}


VOID
OhSetSystemRegistryFlags(
    DWORD GFlags
    )
{
    HKEY hKey;
    LONG Result;

    Result = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           KEYNAME_SESSION_MANAGER,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hKey);

    if (Result != ERROR_SUCCESS) {
        OhError (NULL, 0,
                   "cannot open registry key '%s'\n", 
                   KEYNAME_SESSION_MANAGER );
    }

    Result = RegSetValueEx (hKey,
                            "GlobalFlag",
                            0,
                            REG_DWORD,
                            (LPBYTE)&GFlags,
                            sizeof( GFlags ));

    if (Result != ERROR_SUCCESS) {
        OhError (NULL, 0, 
                   "cannot write registry value '%s'\n",  
                   KEYNAME_SESSION_MANAGER "\\GlobalFlag" );
    }

    RegCloseKey (hKey); 
    hKey = NULL;
}


VOID
OhSetRequiredGlobalFlag (
    DWORD Flags
    )
{
    DWORD RegistryFlags;

    if ((Flags & FLG_KERNEL_STACK_TRACE_DB)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();

        OhSetSystemRegistryFlags (RegistryFlags | FLG_KERNEL_STACK_TRACE_DB);

        Info ("Enabled `kernel mode stack traces' flag needed for handle traces. \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
    else if ((Flags & FLG_MAINTAIN_OBJECT_TYPELIST)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();

        OhSetSystemRegistryFlags (RegistryFlags | FLG_MAINTAIN_OBJECT_TYPELIST);

        Info ("Enabled `object type list' flag needed by the OH utility.         \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
}


VOID
OhResetRequiredGlobalFlag (
    DWORD Flags
    )
{
    DWORD RegistryFlags;

    if ((Flags & FLG_KERNEL_STACK_TRACE_DB)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();
        RegistryFlags &= ~FLG_KERNEL_STACK_TRACE_DB;

        OhSetSystemRegistryFlags (RegistryFlags);

        Info ("Disabled `kernel mode stack traces' flag needed for handle traces. \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
    else if ((Flags & FLG_MAINTAIN_OBJECT_TYPELIST)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();
        RegistryFlags &= ~FLG_MAINTAIN_OBJECT_TYPELIST;

        OhSetSystemRegistryFlags (RegistryFlags);

        Info ("Disabled `object type list' flag needed by the OH utility.         \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Memory management routines
/////////////////////////////////////////////////////////////////////


PVOID
OhAlloc (
    SIZE_T Size
    )
{
    PVOID P;

    P = RtlAllocateHeap (RtlProcessHeap(), HEAP_ZERO_MEMORY, Size);

    if (P == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %u bytes",
                   Size);
    }

    return P;
}

VOID
OhFree (
    PVOID P
    )
{
    RtlFreeHeap (RtlProcessHeap(), 0, P);
}


PVOID
OhZoneAlloc(
    IN OUT SIZE_T *Length
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PVOID Buffer;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    Buffer = VirtualAlloc (NULL,
                           *Length,
                           MEM_COMMIT | MEM_RESERVE,
                           PAGE_READWRITE);

    if (Buffer == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %u bytes",
                   *Length);
    }
    else if (Buffer != NULL &&
        VirtualQuery (Buffer, &MemoryInformation, sizeof (MemoryInformation))) {

        *Length = MemoryInformation.RegionSize;
    }

    return Buffer;
}

PVOID
OhZoneAllocEx(
    SIZE_T Size
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PVOID Buffer;

    Buffer = VirtualAlloc (NULL,
                           Size,
                           MEM_COMMIT | MEM_RESERVE,
                           PAGE_READWRITE);

    if (Buffer == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %u bytes",
                   Size);
    }

    return Buffer;
}


VOID
OhZoneFree(
    IN PVOID Buffer
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    if (!VirtualFree (Buffer,
                      0,
                      MEM_DECOMMIT)) {
        fprintf( stderr, "Unable to free buffer memory %p, error == %u\n", Buffer, GetLastError() );
        exit( 1 );
    }
}


BOOL
OhSetSymbolsPath (
    )
/*++

Routine Description:

    OhSetSymbolsPath tries to set automatically the symbol path if
    _NT_SYMBOL_PATH environment variable is not already defined. 

Arguments:

    None.

Return Value:

    Returns TRUE if the symbols path seems to be ok, that is
    _NT_SYMBOL_PATH was defined or we managed to define it to
    a meaningful value.
    
--*/
{
    TCHAR Buffer [MAX_PATH];
    DWORD Length;
    BOOL Result;

    Length = GetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                     Buffer,
                                     MAX_PATH);

    if (Length == 0) {
        
        Warning (NULL, 0, 
               "_NT_SYMBOL_PATH variable is not defined. Will be set to %%windir%%\\symbols.");

        Length = GetEnvironmentVariable (TEXT("windir"),
                                         Buffer,
                                         MAX_PATH);

        if (Length == 0) {
            OhError (NULL, 0,
                   "Cannot get value of WINDIR environment variable.");
            return FALSE;
        }

        strcat (Buffer, TEXT("\\symbols"));

        Result = SetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                         Buffer);

        if (Result == FALSE) {

            OhError (NULL, 0,
                   "Failed to set _NT_SYMBOL_PATH to `%s'", Buffer);

            return FALSE;
        }

        OhComment ("_NT_SYMBOL_PATH set by default to %s", Buffer);
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////// Log compare
/////////////////////////////////////////////////////////////////////

LPTSTR
OhCmpSearchStackTrace (
    LPTSTR FileName,
    LPTSTR TraceId
    );

PSTRINGTOINTASSOCIATION
MAPSTRINGTOINT::GetStartPosition(
    VOID
    )
/*++

Routine Description:

    This routine retrieves the first association in the list for iteration with the
    MAPSTRINGTOINT::GetNextAssociation function.
    
Arguments:

    None.

Return value:

    The first association in the list, or NULL if the map is empty.

--*/

{
    return Associations;
}


VOID
MAPSTRINGTOINT::GetNextAssociation(
    IN OUT PSTRINGTOINTASSOCIATION & Position,
    OUT LPTSTR & Key,
    OUT LONG & Value)
/*++

Routine Description:

    This routine retrieves the data for the current association and sets Position to
    point to the next association (or NULL if this is the last association.)
    
Arguments:

    Position - Supplies the current association and returns the next association.
    
    Key - Returns the key for the current association.

    Value - Returns the value for the current association.

Return value:

    None.

--*/

{
    Key = Position->Key;
    Value = Position->Value;
    Position = Position->Next;
}


MAPSTRINGTOINT::MAPSTRINGTOINT(
    )
/*++

Routine Description:

    This routine initializes a MAPSTRINGTOINT to be empty.
    
Arguments:

    None.

Return value:

    None.

--*/

{
    Associations = NULL;
}


MAPSTRINGTOINT::~MAPSTRINGTOINT(
    )
/*++

Routine Description:

    This routine cleans up memory used by a MAPSTRINGTOINT.
    
Arguments:

    None.
    
Return value:

    None.

--*/

{
    PSTRINGTOINTASSOCIATION Deleting;
    
    // clean up associations
    
    while (Associations != NULL) {
        
        // save pointer to first association
        
        Deleting = Associations;
        
        // remove first association from list
        
        Associations = Deleting->Next;
        
        // free removed association
        
        free (Deleting->Key);
        delete Deleting;
    }
}


LONG & 
MAPSTRINGTOINT::operator [] (
    IN LPTSTR Key
    )
/*++

Routine Description:

    This routine retrieves an l-value for the value associated with a given key.
    
Arguments:

    Key - The key for which the value is to be retrieved.

Return value:

    A reference to the value associated with the provided key.

--*/

{
    PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;

    // search for key
    while(CurrentAssociation != NULL) {
        
        if(!_tcscmp(CurrentAssociation->Key, Key)) {
            
            // found key, return value
            
            return CurrentAssociation->Value;
            
        }
            
        CurrentAssociation = CurrentAssociation->Next;
        
    }
    
    // not found, create new association    
    
    CurrentAssociation = new STRINGTOINTASSOCIATION;
    
    if (CurrentAssociation == NULL) {
        
        _tprintf(_T("Memory allocation failure\n"));
        exit (0);
    }

    if (Key == NULL) {
        _tprintf(_T("Null object name\n"));
        exit (0);
    }
    else if (_tcscmp (Key, "") == 0) {
        _tprintf(_T("Invalid object name `%s'\n"), Key);
        exit (0);
    }

    CurrentAssociation->Key = _tcsdup(Key);
    
    if (CurrentAssociation->Key == NULL) {
        
        _tprintf(_T("Memory string allocation failure\n"));
        exit (0);
    }

    // add association to front of list
    
    CurrentAssociation->Next = Associations;
    Associations = CurrentAssociation;
    
    // return value for new association
    
    return CurrentAssociation->Value;
}


BOOLEAN
MAPSTRINGTOINT::Lookup(
    IN LPTSTR Key,
    OUT LONG & Value
    )
    
/*++

Routine Description:

    This routine retrieves an r-value for the value association with a given key.
    
Arguments:

    Key - The key for which the associated value is to be retrieved.

    Value - Returns the value associated with Key if Key is present in the map.

Return value:

    TRUE if the key is present in the map, FALSE otherwise.

--*/

{
    
    PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;
    
    // search for key
    
    while (CurrentAssociation != NULL) {
        
        if(!_tcscmp(CurrentAssociation->Key , Key)) {

            // found key, return it
            
            Value = CurrentAssociation->Value;
            
            return TRUE;
            
        }
        
        CurrentAssociation = CurrentAssociation->Next;
        
    }
    
    // didn't find it
    return FALSE;
}


BOOLEAN
OhCmpPopulateMapsFromFile(
    IN LPTSTR FileName,
    OUT MAPSTRINGTOINT & TypeMap,
    OUT MAPSTRINGTOINT & NameMap,
    BOOLEAN FileWithTraces
    )
/*++

Routine Description:

This routine parses an OH output file and fills two maps with the number of handles of
each type and the number of handles to each named object.

Arguments:

    FileName - OH output file to parse.

    TypeMap - Map to fill with handle type information.

    NameMap - Map to fill with named object information.

Return value:

    TRUE if the file was successfully parsed, FALSE otherwise.
    
--*/

{
    LONG HowMany;
    LPTSTR Name, Type, Process, Pid;
    LPTSTR NewLine;
    TCHAR LineBuffer[512];
    TCHAR ObjectName[512];
    TCHAR TypeName[512];
    FILE *InputFile;
    ULONG LineNumber;

    BOOLEAN rc;

    LineNumber = 0;

    // open file
    
    InputFile = _tfopen(FileName, _T("rt"));

    if (InputFile == NULL) {
        
        _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
        return FALSE;
        
    }

    rc = TRUE;
    
    // loop through lines in oh output
    
    while (_fgetts(LineBuffer, sizeof(LineBuffer), InputFile)
        && !( feof(InputFile) || ferror(InputFile) ) ) {
        
        LineNumber += 1;

        // trim off newline
        
        if((NewLine = _tcschr(LineBuffer, _T('\n'))) != NULL) {
            *NewLine = _T('\0');
        }

        // ignore lines that start with white space or are empty.
        if (LineBuffer[0] == _T('\0') ||
            LineBuffer[0] == _T('\t') || 
            LineBuffer[0] == _T(' ')) {
           continue;
        }

        // ignore lines that start with a comment
        if( LineBuffer[0] == _T('/') && LineBuffer[1] == _T('/') ) {
           continue;
        }

        // skip pid
        
        if((Pid = _tcstok(LineBuffer, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // skip process name
        
        if((Process = _tcstok(NULL, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // Type points to the type of handle
        
        if ((Type = _tcstok(NULL, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // HowMany = number of previous handles with this type
        
        _stprintf (TypeName, 
                   TEXT("<%s/%s/%s>"),
                   Process,
                   Pid,
                   Type);

        if (TypeMap.Lookup(TypeName, HowMany) == FALSE) {
            HowMany = 0;
        }

        // add another handle of this type
        TypeMap[TypeName] = (HowMany + 1);
        
        //
        // Name points to the name. These are magic numbers based on the way
        // OH formats output. The output is a little bit different if the
        // `-h' option of OH was used (this dumps stack traces too).
        //

        Name = LineBuffer + 39 + 5;

        if (FileWithTraces) {
            Name += 7;
        }

        if (_tcscmp (Name, "") == 0) {

            _stprintf (ObjectName, 
                       TEXT("<%s/%s/%s>::<<noname>>"),
                       Process,
                       Pid,
                       Type);
        }
        else {

            _stprintf (ObjectName, 
                       TEXT("<%s/%s/%s>::%s"),
                       Process,
                       Pid,
                       Type,
                       Name);
        }

        // HowMany = number of previous handles with this name
        
        // printf("name --> `%s' \n", ObjectName);

        if (NameMap.Lookup(ObjectName, HowMany) == FALSE) {
            HowMany = 0;
        }

        // add another handle with this name and read the next line
        // note -- NameMap[] is a class operator, not an array.

        NameMap[ObjectName] = (HowMany + 1);
    }

    // done, close file
    
    fclose(InputFile);

    return rc;
}


int
__cdecl
OhCmpKeyCompareAssociation (
    const void * Left,
    const void * Right
    )
{
    PSTRINGTOINTASSOCIATION X;
    PSTRINGTOINTASSOCIATION Y;

    X = (PSTRINGTOINTASSOCIATION)Left;
    Y = (PSTRINGTOINTASSOCIATION)Right;

    return _tcscmp (X->Key, Y->Key);
}


int
__cdecl
OhCmpValueCompareAssociation (
    const void * Left,
    const void * Right
    )
{
    PSTRINGTOINTASSOCIATION X;
    PSTRINGTOINTASSOCIATION Y;

    X = (PSTRINGTOINTASSOCIATION)Left;
    Y = (PSTRINGTOINTASSOCIATION)Right;

    return Y->Value - X->Value;
}


VOID 
OhCmpPrintIncreases(
    IN MAPSTRINGTOINT & BeforeMap,
    IN MAPSTRINGTOINT & AfterMap,
    IN BOOLEAN ReportIncreasesOnly,
    IN BOOLEAN PrintHighlights,
    IN LPTSTR AfterLogName
    )
/*++

Routine Description:

This routine compares two maps and prints out the differences between them.

Arguments:

    BeforeMap - First map to compare.

    AfterMap - Second map to compare.

    ReportIncreasesOnly - TRUE for report only increases from BeforeMap to AfterMap, 
                          FALSE for report all differences.

Return value:

    None.
    
--*/

{
    PSTRINGTOINTASSOCIATION Association = NULL;
    LONG HowManyBefore = 0;
    LONG HowManyAfter = 0;
    LPTSTR Key = NULL;
    PSTRINGTOINTASSOCIATION SortBuffer;
    ULONG SortBufferSize;
    ULONG SortBufferIndex;
    
    //
    // Loop through associations in map and figure out how many output lines
    // we will have.
    //
    
    SortBufferSize = 0;

    for (Association = AfterMap.GetStartPosition(),
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
         Association != NULL;
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {
            
        // look up value for this key in BeforeMap
        if(BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {
            
            HowManyBefore = 0;
            
        }

        // should we report this?
        if((HowManyAfter > HowManyBefore) || 
            ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {
                
            SortBufferSize += 1;
            
        }
    }
    
    //
    // Loop through associations in map again this time filling the output buffer.
    //
    
    SortBufferIndex = 0;

    SortBuffer = new STRINGTOINTASSOCIATION[SortBufferSize];

    if (SortBuffer == NULL) {
        _ftprintf(stderr, _T("Failed to allocate internal buffer of %u bytes.\n"), 
                  SortBufferSize);
        return;
    }

    for (Association = AfterMap.GetStartPosition(),
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
         Association != NULL;
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {
            
        // look up value for this key in BeforeMap
        if(BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {
            
            HowManyBefore = 0;
        }

        // should we report this?
        if((HowManyAfter > HowManyBefore) || 
            ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {
                
            ZeroMemory (&(SortBuffer[SortBufferIndex]), 
                        sizeof (STRINGTOINTASSOCIATION));

            SortBuffer[SortBufferIndex].Key = Key;
            SortBuffer[SortBufferIndex].Value = HowManyAfter - HowManyBefore;
            SortBufferIndex += 1;
        }
    }

    //
    // Sort the output buffer using the Key.
    //

    if (PrintHighlights) {

        qsort (SortBuffer,
               SortBufferSize,
               sizeof (STRINGTOINTASSOCIATION),
               OhCmpValueCompareAssociation);
    }
    else {

        qsort (SortBuffer,
               SortBufferSize,
               sizeof (STRINGTOINTASSOCIATION),
               OhCmpKeyCompareAssociation);
    }

    //
    // Dump the buffer.
    //

    for (SortBufferIndex = 0; SortBufferIndex < SortBufferSize; SortBufferIndex += 1) {
        
        if (PrintHighlights) {

            if (SortBuffer[SortBufferIndex].Value >= 1) {

                TCHAR TraceId[7];
                LPTSTR Start;

                _tprintf(_T("%d\t%s\n"), 
                         SortBuffer[SortBufferIndex].Value,
                         SortBuffer[SortBufferIndex].Key);

                Start = _tcsstr (SortBuffer[SortBufferIndex].Key, "(");

                if (Start == NULL) {
                    
                    TraceId[0] = 0;
                }
                else {

                    _tcsncpy (TraceId,
                              Start,
                              6);

                    TraceId[6] = 0;
                }

                _tprintf (_T("%s"), OhCmpSearchStackTrace (AfterLogName, TraceId));
            }
        }
        else {

            _tprintf(_T("%d\t%s\n"), 
                     SortBuffer[SortBufferIndex].Value,
                     SortBuffer[SortBufferIndex].Key);
        }
    }

    //
    // Clean up memory.
    //

    if (SortBuffer) {
        delete[] SortBuffer;
    }
}


VOID
OhCmpCompareLogs (
    IN LONG argc,
    IN LPTSTR argv[]
    )
/*++

Routine Description:

This routine parses program arguments, reads the two input files, and prints out the
differences.

Arguments:

    argc - Number of command-line arguments.

    argv - Command-line arguments.

Return value:

    None.
    
--*/
{
    MAPSTRINGTOINT TypeMapBefore, TypeMapAfter;
    MAPSTRINGTOINT NameMapBefore, NameMapAfter;
    LPTSTR BeforeFileName=NULL;
    LPTSTR AfterFileName=NULL;
    BOOLEAN ReportIncreasesOnly = TRUE;
    BOOLEAN Interpreted = FALSE;
    BOOLEAN Result;
    BOOLEAN FileWithTraces;
    BOOLEAN PrintHighlights;

    // parse arguments

    FileWithTraces = FALSE;
    PrintHighlights = FALSE;

    for (LONG n = 1; n < argc; n++) {

        Interpreted = FALSE;

        switch(argv[n][0]) {

        case _T('-'):
        case _T('/'):

            // the argument is a switch

            if(_tcsicmp(argv[n]+1, _T("all")) == 0) {

                ReportIncreasesOnly = FALSE;
                Interpreted = TRUE;

            }
            else if (_tcsicmp(argv[n]+1, _T("t")) == 0) {

                FileWithTraces = TRUE;
                Interpreted = TRUE;
            }
            else if (_tcsicmp(argv[n]+1, _T("l")) == 0) {

                PrintHighlights = TRUE;
                Interpreted = TRUE;
            }

            break;

        default:

            // the argument is a file name

            if(BeforeFileName == NULL) {

                BeforeFileName = argv[n];
                Interpreted = TRUE;

            } else {

                if(AfterFileName == NULL) {

                    AfterFileName = argv[n];
                    Interpreted = TRUE;

                } else {
                    Help();
                }

            }

            break;
        }

        if(!Interpreted) {
            Help();
        }
    }

    // did user specify required arguments?

    if((BeforeFileName == NULL) || (AfterFileName == NULL)) {
        Help();
    }

    // read oh1 file

    Result = OhCmpPopulateMapsFromFile (BeforeFileName, 
                                   TypeMapBefore, 
                                   NameMapBefore,
                                   FileWithTraces);

    if(Result == FALSE) {

        _ftprintf(stderr, _T("Failed to read first OH output file.\n"));
        return;
    }

    // read oh2 file

    Result = OhCmpPopulateMapsFromFile (AfterFileName, 
                                   TypeMapAfter, 
                                   NameMapAfter,
                                   FileWithTraces);

    if(Result == FALSE) {

        _ftprintf(stderr, _T("Failed to read second OH output file.\n"));
        return;
    }

    // print out increases by handle name

    if (PrintHighlights) {

        _putts (TEXT ("\n")
                TEXT("//                                              \n")
                TEXT("// Possible leaks (DELTA <PROCESS/PID/TYPE>::NAME):  \n")
                TEXT("//                                              \n")
                TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output \n")
                TEXT("// is generated by comparing OH files containing traces. In this case  \n")
                TEXT("// just search in the `AFTER' OH log file for the trace id to \n")
                TEXT("// find the stack trace creating the handle possibly leaked. \n")
                TEXT("//                                              \n\n"));

        OhCmpPrintIncreases (NameMapBefore, 
                        NameMapAfter, 
                        ReportIncreasesOnly,
                        TRUE,
                        AfterFileName);
    }

    // print out increases by handle type

    _putts (TEXT ("\n")
            TEXT("//                                              \n")
            TEXT("// Handle types (DELTA <PROCESS/PID/TYPE>):     \n")
            TEXT("//                                              \n")
            TEXT("// DELTA is the additional number of handles found in the `AFTER' log. \n")
            TEXT("// PROCESS is the process name having a handle increase.        \n")
            TEXT("// PID is the process PID having a handle increase.   \n")
            TEXT("// TYPE is the type of the handle               \n")
            TEXT("//                                              \n\n"));

    OhCmpPrintIncreases (TypeMapBefore, 
                    TypeMapAfter, 
                    ReportIncreasesOnly, 
                    FALSE,
                    NULL);

    // print out increases by handle name

    _putts (TEXT ("\n")
            TEXT("//                                              \n")
            TEXT("// Objects (named and anonymous) (DELTA <PROCESS/PID/TYPE>::NAME):  \n")
            TEXT("//                                              \n")
            TEXT("// DELTA is the additional number of handles found in the `AFTER' log. \n")
            TEXT("// PROCESS is the process name having a handle increase.        \n")
            TEXT("// PID is the process PID having a handle increase.   \n")
            TEXT("// TYPE is the type of the handle               \n")
            TEXT("// NAME is the name of the handle. Anonymous handles appear with name <<noname>>.\n")
            TEXT("//                                              \n")
            TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output \n")
            TEXT("// is generated by comparing OH files containing traces. In this case  \n")
            TEXT("// just search in the `AFTER' OH log file for the trace id to \n")
            TEXT("// find the stack trace creating the handle possibly leaked. \n")
            TEXT("//                                              \n\n"));

    OhCmpPrintIncreases (NameMapBefore, 
                    NameMapAfter, 
                    ReportIncreasesOnly,
                    FALSE,
                    NULL);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

TCHAR OhCmpStackTraceBuffer [0x10000];

LPTSTR
OhCmpSearchStackTrace (
    LPTSTR FileName,
    LPTSTR TraceId
    )
{
    TCHAR LineBuffer[512];
    FILE *InputFile;

    OhCmpStackTraceBuffer[0] = 0;

    //
    // Open file.
    //
    
    InputFile = _tfopen(FileName, _T("rt"));

    if (InputFile == NULL) {
        
        _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
        return NULL;
    }
    
    //
    // Loop through lines in oh output.
    //
    
    while (_fgetts(LineBuffer, sizeof(LineBuffer), InputFile)
        && !( feof(InputFile) || ferror(InputFile) ) ) {
        
        //
        // Skip line if it does not contain trace ID.
        //

        if (_tcsstr (LineBuffer, TraceId) == NULL) {
            continue;
        }

        //
        // We have got a trace ID. We need now to copy everything
        // to a trace buffer until we get a line containing a character
        // in column zero.
        //

        while (_fgetts(LineBuffer, sizeof(LineBuffer), InputFile)
               && !( feof(InputFile) || ferror(InputFile) ) ) {

            if (LineBuffer[0] == _T(' ') ||
                LineBuffer[0] == _T('\0') ||
                LineBuffer[0] == _T('\n') ||
                LineBuffer[0] == _T('\t')) {

                _tcscat (OhCmpStackTraceBuffer, LineBuffer);
            }
            else {

                break;
            }
        }

        break;
    }

    //
    // Close file.
    
    fclose(InputFile);

    return OhCmpStackTraceBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\ohcmp.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ohcmp.cpp

Abstract:

    This module reports the differences between two oh output files.

Author:

    Matt Bandy (t-mattba) 23-Jul-1998

Revision History:

    24-Jul-1998     t-mattba
        
        Modified module to conform to coding standards.
        
    11-Jun-2001     silviuc
    
        Deal with handles that are recreated with a different value
        and other simple output improvements (sorted output etc.).    
    
--*/

#include <windows.h>
#include <common.ver>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <tchar.h>
#include "MAPSTRINGINT.h"

LPTSTR HelpText =
    TEXT("ohcmp - Display difference between two OH output files --") BUILD_MACHINE_TAG TEXT("\n")
    VER_LEGALCOPYRIGHT_STR TEXT("\n") 
    TEXT("                                                                       \n")
    TEXT("ohcmp [OPTION ...] BEFORE_OH_FILE AFTER_OH_FILE                        \n")
    TEXT("                                                                       \n")
    TEXT("/h     Print most interesting increases in a separate initial section. \n")
    TEXT("/t     Do not add TRACE id to the names if files contain traces.       \n")
    TEXT("/all   Report decreases as well as increases.                          \n")
    TEXT("                                                                       \n")
    TEXT("If the OH files have been created with -h option (they contain traces) \n")
    TEXT("then ohcmp will print Names having this syntax: (TRACEID) NAME.        \n")
    TEXT("In case of a potential leak just search for the TRACEID in the original\n")
    TEXT("OH file to find the stack trace.                                       \n")
    TEXT("                                                                       \n");

LPTSTR
SearchStackTrace (
    LPTSTR FileName,
    LPTSTR TraceId
    );

PSTRINGTOINTASSOCIATION
MAPSTRINGTOINT::GetStartPosition(
    VOID
    )
/*++

Routine Description:

    This routine retrieves the first association in the list for iteration with the
    MAPSTRINGTOINT::GetNextAssociation function.
    
Arguments:

    None.

Return value:

    The first association in the list, or NULL if the map is empty.

--*/

{
    return Associations;
}


VOID
MAPSTRINGTOINT::GetNextAssociation(
    IN OUT PSTRINGTOINTASSOCIATION & Position,
    OUT LPTSTR & Key,
    OUT LONG & Value)
/*++

Routine Description:

    This routine retrieves the data for the current association and sets Position to
    point to the next association (or NULL if this is the last association.)
    
Arguments:

    Position - Supplies the current association and returns the next association.
    
    Key - Returns the key for the current association.

    Value - Returns the value for the current association.

Return value:

    None.

--*/

{
    Key = Position->Key;
    Value = Position->Value;
    Position = Position->Next;
}


MAPSTRINGTOINT::MAPSTRINGTOINT(
    )
/*++

Routine Description:

    This routine initializes a MAPSTRINGTOINT to be empty.
    
Arguments:

    None.

Return value:

    None.

--*/

{
    Associations = NULL;
}


MAPSTRINGTOINT::~MAPSTRINGTOINT(
    )
/*++

Routine Description:

    This routine cleans up memory used by a MAPSTRINGTOINT.
    
Arguments:

    None.
    
Return value:

    None.

--*/

{
    PSTRINGTOINTASSOCIATION Deleting;
    
    // clean up associations
    
    while (Associations != NULL) {
        
        // save pointer to first association
        
        Deleting = Associations;
        
        // remove first association from list
        
        Associations = Deleting->Next;
        
        // free removed association
        
        free (Deleting->Key);
        delete Deleting;
    }
}


LONG & 
MAPSTRINGTOINT::operator [] (
    IN LPTSTR Key
    )
/*++

Routine Description:

    This routine retrieves an l-value for the value associated with a given key.
    
Arguments:

    Key - The key for which the value is to be retrieved.

Return value:

    A reference to the value associated with the provided key.

--*/

{
    PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;

    // search for key
    while(CurrentAssociation != NULL) {
        
        if(!_tcscmp(CurrentAssociation->Key, Key)) {
            
            // found key, return value
            
            return CurrentAssociation->Value;
            
        }
            
        CurrentAssociation = CurrentAssociation->Next;
        
    }
    
    // not found, create new association    
    
    CurrentAssociation = new STRINGTOINTASSOCIATION;
    
    if (CurrentAssociation == NULL) {
        
        _tprintf(_T("Memory allocation failure\n"));
        exit (0);
    }

    if (Key == NULL) {
        _tprintf(_T("Null object name\n"));
        exit (0);
    }
    else if (_tcscmp (Key, "") == 0) {
        _tprintf(_T("Invalid object name `%s'\n"), Key);
        exit (0);
    }

    CurrentAssociation->Key = _tcsdup(Key);
    
    if (CurrentAssociation->Key == NULL) {
        
        _tprintf(_T("Memory string allocation failure\n"));
        exit (0);
    }

    // add association to front of list
    
    CurrentAssociation->Next = Associations;
    Associations = CurrentAssociation;
    
    // return value for new association
    
    return CurrentAssociation->Value;
}


BOOLEAN
MAPSTRINGTOINT::Lookup(
    IN LPTSTR Key,
    OUT LONG & Value
    )
    
/*++

Routine Description:

    This routine retrieves an r-value for the value association with a given key.
    
Arguments:

    Key - The key for which the associated value is to be retrieved.

    Value - Returns the value associated with Key if Key is present in the map.

Return value:

    TRUE if the key is present in the map, FALSE otherwise.

--*/

{
    
    PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;
    
    // search for key
    
    while (CurrentAssociation != NULL) {
        
        if(!_tcscmp(CurrentAssociation->Key , Key)) {

            // found key, return it
            
            Value = CurrentAssociation->Value;
            
            return TRUE;
            
        }
        
        CurrentAssociation = CurrentAssociation->Next;
        
    }
    
    // didn't find it
    return FALSE;
}


BOOLEAN
PopulateMapsFromFile(
    IN LPTSTR FileName,
    OUT MAPSTRINGTOINT & TypeMap,
    OUT MAPSTRINGTOINT & NameMap,
    BOOLEAN FileWithTraces
    )
/*++

Routine Description:

This routine parses an OH output file and fills two maps with the number of handles of
each type and the number of handles to each named object.

Arguments:

    FileName - OH output file to parse.

    TypeMap - Map to fill with handle type information.

    NameMap - Map to fill with named object information.

Return value:

    TRUE if the file was successfully parsed, FALSE otherwise.
    
--*/

{
    LONG HowMany;
    LPTSTR Name, Type, Process, Pid;
    LPTSTR NewLine;
    TCHAR LineBuffer[512];
    TCHAR ObjectName[512];
    TCHAR TypeName[512];
    FILE *InputFile;
    ULONG LineNumber;

    BOOLEAN rc;

    LineNumber = 0;

    // open file
    
    InputFile = _tfopen(FileName, _T("rt"));

    if (InputFile == NULL) {
        
        _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
        return FALSE;
        
    }

    rc = TRUE;
    
    // loop through lines in oh output
    
    while (_fgetts(LineBuffer, sizeof(LineBuffer), InputFile)
        && !( feof(InputFile) || ferror(InputFile) ) ) {
        
        LineNumber += 1;

        // trim off newline
        
        if((NewLine = _tcschr(LineBuffer, _T('\n'))) != NULL) {
            *NewLine = _T('\0');
        }

        // ignore lines that start with white space or are empty.
        if (LineBuffer[0] == _T('\0') ||
            LineBuffer[0] == _T('\t') || 
            LineBuffer[0] == _T(' ')) {
           continue;
        }

        // ignore lines that start with a comment
        if( LineBuffer[0] == _T('/') && LineBuffer[1] == _T('/') ) {
           continue;
        }

        // skip pid
        
        if((Pid = _tcstok(LineBuffer, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // skip process name
        
        if((Process = _tcstok(NULL, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // Type points to the type of handle
        
        if ((Type = _tcstok(NULL, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // HowMany = number of previous handles with this type
        
        _stprintf (TypeName, 
                   TEXT("<%s/%s/%s>"),
                   Process,
                   Pid,
                   Type);

        if (TypeMap.Lookup(TypeName, HowMany) == FALSE) {
            HowMany = 0;
        }

        // add another handle of this type
        TypeMap[TypeName] = (HowMany + 1);
        
        //
        // Name points to the name. These are magic numbers based on the way
        // OH formats output. The output is a little bit different if the
        // `-h' option of OH was used (this dumps stack traces too).
        //

        Name = LineBuffer + 39 + 5;

        if (FileWithTraces) {
            Name += 7;
        }

        if (_tcscmp (Name, "") == 0) {

            _stprintf (ObjectName, 
                       TEXT("<%s/%s/%s>::<<noname>>"),
                       Process,
                       Pid,
                       Type);
        }
        else {

            _stprintf (ObjectName, 
                       TEXT("<%s/%s/%s>::%s"),
                       Process,
                       Pid,
                       Type,
                       Name);
        }

        // HowMany = number of previous handles with this name
        
        // printf("name --> `%s' \n", ObjectName);

        if (NameMap.Lookup(ObjectName, HowMany) == FALSE) {
            HowMany = 0;
        }

        // add another handle with this name and read the next line
        // note -- NameMap[] is a class operator, not an array.

        NameMap[ObjectName] = (HowMany + 1);
    }

    // done, close file
    
    fclose(InputFile);

    return rc;
}


int
__cdecl
KeyCompareAssociation (
    const void * Left,
    const void * Right
    )
{
    PSTRINGTOINTASSOCIATION X;
    PSTRINGTOINTASSOCIATION Y;

    X = (PSTRINGTOINTASSOCIATION)Left;
    Y = (PSTRINGTOINTASSOCIATION)Right;

    return _tcscmp (X->Key, Y->Key);
}


int
__cdecl
ValueCompareAssociation (
    const void * Left,
    const void * Right
    )
{
    PSTRINGTOINTASSOCIATION X;
    PSTRINGTOINTASSOCIATION Y;

    X = (PSTRINGTOINTASSOCIATION)Left;
    Y = (PSTRINGTOINTASSOCIATION)Right;

    return Y->Value - X->Value;
}


VOID 
PrintIncreases(
    IN MAPSTRINGTOINT & BeforeMap,
    IN MAPSTRINGTOINT & AfterMap,
    IN BOOLEAN ReportIncreasesOnly,
    IN BOOLEAN PrintHighlights,
    IN LPTSTR AfterLogName
    )
/*++

Routine Description:

This routine compares two maps and prints out the differences between them.

Arguments:

    BeforeMap - First map to compare.

    AfterMap - Second map to compare.

    ReportIncreasesOnly - TRUE for report only increases from BeforeMap to AfterMap, 
                          FALSE for report all differences.

Return value:

    None.
    
--*/

{
    PSTRINGTOINTASSOCIATION Association = NULL;
    LONG HowManyBefore = 0;
    LONG HowManyAfter = 0;
    LPTSTR Key = NULL;
    PSTRINGTOINTASSOCIATION SortBuffer;
    ULONG SortBufferSize;
    ULONG SortBufferIndex;
    
    //
    // Loop through associations in map and figure out how many output lines
    // we will have.
    //
    
    SortBufferSize = 0;

    for (Association = AfterMap.GetStartPosition(),
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
         Association != NULL;
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {
            
        // look up value for this key in BeforeMap
        if(BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {
            
            HowManyBefore = 0;
            
        }

        // should we report this?
        if((HowManyAfter > HowManyBefore) || 
            ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {
                
            SortBufferSize += 1;
            
        }
    }
    
    //
    // Loop through associations in map again this time filling the output buffer.
    //
    
    SortBufferIndex = 0;

    SortBuffer = new STRINGTOINTASSOCIATION[SortBufferSize];

    if (SortBuffer == NULL) {
        _ftprintf(stderr, _T("Failed to allocate internal buffer of %u bytes.\n"), 
                  SortBufferSize);
        return;
    }

    for (Association = AfterMap.GetStartPosition(),
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
         Association != NULL;
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {
            
        // look up value for this key in BeforeMap
        if(BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {
            
            HowManyBefore = 0;
        }

        // should we report this?
        if((HowManyAfter > HowManyBefore) || 
            ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {
                
            ZeroMemory (&(SortBuffer[SortBufferIndex]), 
                        sizeof (STRINGTOINTASSOCIATION));

            SortBuffer[SortBufferIndex].Key = Key;
            SortBuffer[SortBufferIndex].Value = HowManyAfter - HowManyBefore;
            SortBufferIndex += 1;
        }
    }

    //
    // Sort the output buffer using the Key.
    //

    if (PrintHighlights) {

        qsort (SortBuffer,
               SortBufferSize,
               sizeof (STRINGTOINTASSOCIATION),
               ValueCompareAssociation);
    }
    else {

        qsort (SortBuffer,
               SortBufferSize,
               sizeof (STRINGTOINTASSOCIATION),
               KeyCompareAssociation);
    }

    //
    // Dump the buffer.
    //

    for (SortBufferIndex = 0; SortBufferIndex < SortBufferSize; SortBufferIndex += 1) {
        
        if (PrintHighlights) {

            if (SortBuffer[SortBufferIndex].Value >= 1) {

                TCHAR TraceId[7];
                LPTSTR Start;

                _tprintf(_T("%d\t%s\n"), 
                         SortBuffer[SortBufferIndex].Value,
                         SortBuffer[SortBufferIndex].Key);

                Start = _tcsstr (SortBuffer[SortBufferIndex].Key, "(");

                if (Start == NULL) {
                    
                    TraceId[0] = 0;
                }
                else {

                    _tcsncpy (TraceId,
                              Start,
                              6);

                    TraceId[6] = 0;
                }

                _tprintf (_T("%s"), SearchStackTrace (AfterLogName, TraceId));
            }
        }
        else {

            _tprintf(_T("%d\t%s\n"), 
                     SortBuffer[SortBufferIndex].Value,
                     SortBuffer[SortBufferIndex].Key);
        }
    }

    //
    // Clean up memory.
    //

    if (SortBuffer) {
        delete[] SortBuffer;
    }
}


VOID 
PrintUsage(
    VOID
    )
/*++

Routine Description:

This routine prints out a message describing the proper usage of OHCMP.

Arguments:

    None.

Return value:

    None.
    
--*/
{
    _ftprintf (stderr, HelpText);
}


LONG _cdecl
_tmain(
    IN LONG argc,
    IN LPTSTR argv[]
    )
    
/*++

Routine Description:

This routine parses program arguments, reads the two input files, and prints out the
differences.

Arguments:

    argc - Number of command-line arguments.

    argv - Command-line arguments.

Return value:

    0 if comparison is successful, 1 otherwise.
    
--*/

{
    
    try {
    
        MAPSTRINGTOINT TypeMapBefore, TypeMapAfter;
        MAPSTRINGTOINT NameMapBefore, NameMapAfter;
        LPTSTR BeforeFileName=NULL;
        LPTSTR AfterFileName=NULL;
        BOOLEAN ReportIncreasesOnly = TRUE;
        BOOLEAN Interpreted = FALSE;
        BOOLEAN Result;
        BOOLEAN FileWithTraces;
        BOOLEAN PrintHighlights;

        // parse arguments

        FileWithTraces = FALSE;
        PrintHighlights = FALSE;

        for (LONG n = 1; n < argc; n++) {

            Interpreted = FALSE;

            switch(argv[n][0]) {

            case _T('-'):
            case _T('/'):

                // the argument is a switch

                if(_tcsicmp(argv[n]+1, _T("all")) == 0) {

                    ReportIncreasesOnly = FALSE;
                    Interpreted = TRUE;

                }
                else if (_tcsicmp(argv[n]+1, _T("t")) == 0) {

                    FileWithTraces = TRUE;
                    Interpreted = TRUE;
                }
                else if (_tcsicmp(argv[n]+1, _T("h")) == 0) {

                    PrintHighlights = TRUE;
                    Interpreted = TRUE;
                }

                break;

            default:

                // the argument is a file name

                if(BeforeFileName == NULL) {

                    BeforeFileName = argv[n];
                    Interpreted = TRUE;

                } else {

                    if(AfterFileName == NULL) {

                        AfterFileName = argv[n];
                        Interpreted = TRUE;

                    } else {

                        // too many file arguments
                        PrintUsage();
                        return 1;

                    }

                }

                break;
            }

            if(!Interpreted) {

                // user specified a bad argument
                PrintUsage();
                return 1;

            }
        }

        // did user specify required arguments?

        if((BeforeFileName == NULL) || (AfterFileName == NULL))
        {

            PrintUsage();
            return 1;

        }

        // read oh1 file

        Result = PopulateMapsFromFile (BeforeFileName, 
                                       TypeMapBefore, 
                                       NameMapBefore,
                                       FileWithTraces);

        if(Result == FALSE) {

            _ftprintf(stderr, _T("Failed to read first OH output file.\n"));
            return 1;
        }

        // read oh2 file

        Result = PopulateMapsFromFile (AfterFileName, 
                                       TypeMapAfter, 
                                       NameMapAfter,
                                       FileWithTraces);

        if(Result == FALSE) {

            _ftprintf(stderr, _T("Failed to read second OH output file.\n"));
            return 1;

        }

        // print out increases by handle name

        if (PrintHighlights) {

            _putts (TEXT ("\n")
                    TEXT("//                                              \n")
                    TEXT("// Possible leaks (DELTA <PROCESS/PID/TYPE>::NAME):  \n")
                    TEXT("//                                              \n")
                    TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output \n")
                    TEXT("// is generated by comparing OH files containing traces. In this case  \n")
                    TEXT("// just search in the `AFTER' OH log file for the trace id to \n")
                    TEXT("// find the stack trace creating the handle possibly leaked. \n")
                    TEXT("//                                              \n\n"));

            PrintIncreases (NameMapBefore, 
                            NameMapAfter, 
                            ReportIncreasesOnly,
                            TRUE,
                            AfterFileName);
        }

        // print out increases by handle type

        _putts (TEXT ("\n")
                TEXT("//                                              \n")
                TEXT("// Handle types (DELTA <PROCESS/PID/TYPE>):     \n")
                TEXT("//                                              \n")
                TEXT("// DELTA is the additional number of handles found in the `AFTER' log. \n")
                TEXT("// PROCESS is the process name having a handle increase.        \n")
                TEXT("// PID is the process PID having a handle increase.   \n")
                TEXT("// TYPE is the type of the handle               \n")
                TEXT("//                                              \n\n"));
        
        PrintIncreases (TypeMapBefore, 
                        TypeMapAfter, 
                        ReportIncreasesOnly, 
                        FALSE,
                        NULL);

        // print out increases by handle name

        _putts (TEXT ("\n")
                TEXT("//                                              \n")
                TEXT("// Objects (named and anonymous) (DELTA <PROCESS/PID/TYPE>::NAME):  \n")
                TEXT("//                                              \n")
                TEXT("// DELTA is the additional number of handles found in the `AFTER' log. \n")
                TEXT("// PROCESS is the process name having a handle increase.        \n")
                TEXT("// PID is the process PID having a handle increase.   \n")
                TEXT("// TYPE is the type of the handle               \n")
                TEXT("// NAME is the name of the handle. Anonymous handles appear with name <<noname>>.\n")
                TEXT("//                                              \n")
                TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output \n")
                TEXT("// is generated by comparing OH files containing traces. In this case  \n")
                TEXT("// just search in the `AFTER' OH log file for the trace id to \n")
                TEXT("// find the stack trace creating the handle possibly leaked. \n")
                TEXT("//                                              \n\n"));
        
        PrintIncreases (NameMapBefore, 
                        NameMapAfter, 
                        ReportIncreasesOnly,
                        FALSE,
                        NULL);

        return 0;
        
    } catch (...) {

        // this is mostly intended to catch out of memory conditions
        
        _tprintf(_T("\nAn exception has been detected.  OHCMP aborted.\n"));
        return 1;
        
    }
    
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

TCHAR StackTraceBuffer [0x10000];

LPTSTR
SearchStackTrace (
    LPTSTR FileName,
    LPTSTR TraceId
    )
{
    TCHAR LineBuffer[512];
    FILE *InputFile;

    StackTraceBuffer[0] = 0;

    //
    // Open file.
    //
    
    InputFile = _tfopen(FileName, _T("rt"));

    if (InputFile == NULL) {
        
        _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
        return NULL;
    }
    
    //
    // Loop through lines in oh output.
    //
    
    while (_fgetts(LineBuffer, sizeof(LineBuffer), InputFile)
        && !( feof(InputFile) || ferror(InputFile) ) ) {
        
        //
        // Skip line if it does not contain trace ID.
        //

        if (_tcsstr (LineBuffer, TraceId) == NULL) {
            continue;
        }

        //
        // We have got a trace ID. We need now to copy everything
        // to a trace buffer until we get a line containing a character
        // in column zero.
        //

        while (_fgetts(LineBuffer, sizeof(LineBuffer), InputFile)
               && !( feof(InputFile) || ferror(InputFile) ) ) {

            if (LineBuffer[0] == _T(' ') ||
                LineBuffer[0] == _T('\0') ||
                LineBuffer[0] == _T('\n') ||
                LineBuffer[0] == _T('\t')) {

                _tcscat (StackTraceBuffer, LineBuffer);
            }
            else {

                break;
            }
        }

        break;
    }

    //
    // Close file.
    
    fclose(InputFile);

    return StackTraceBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\objmon.c ===
#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <ntstatus.dbg>
#include <winerror.dbg>
#include <netevent.h>
#include <netevent.dbg>

#define MAX_TYPE_NAMES 32

ULONG NumberOfTypeNames;
UNICODE_STRING TypeNames[ MAX_TYPE_NAMES ];

PCHAR LargeBuffer1[ 8192 ];

ULONG CompareField;

#define SORT_BY_TYPE_NAME       0
#define SORT_BY_OBJECT_COUNT    1
#define SORT_BY_HANDLE_COUNT    2
#define SORT_BY_PAGED_POOL      3
#define SORT_BY_NONPAGED_POOL   4
#define SORT_BY_NAME_USAGE      5

int __cdecl
CompareTypeInfo(
    const void *e1,
    const void *e2
    );

int __cdecl
CompareTypeInfo(
    const void *e1,
    const void *e2
    )
{
    POBJECT_TYPE_INFORMATION p1, p2;

    p1 = (POBJECT_TYPE_INFORMATION)e1;
    p2 = (POBJECT_TYPE_INFORMATION)e2;

    switch (CompareField) {
    case SORT_BY_TYPE_NAME:
        return RtlCompareUnicodeString( &p1->TypeName, &p2->TypeName, TRUE );

    case SORT_BY_OBJECT_COUNT:
        return p2->TotalNumberOfObjects - p1->TotalNumberOfObjects;

    case SORT_BY_HANDLE_COUNT:
        return p2->TotalNumberOfHandles - p1->TotalNumberOfHandles;

    case SORT_BY_PAGED_POOL:
        return p2->TotalPagedPoolUsage - p1->TotalPagedPoolUsage;

    case SORT_BY_NONPAGED_POOL:
        return p2->TotalNonPagedPoolUsage - p1->TotalNonPagedPoolUsage;

    case SORT_BY_NAME_USAGE:
        return p2->TotalNamePoolUsage - p1->TotalNamePoolUsage;

    default:
        return 0;
    }
}


int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    BOOL fShowUsage;
    ANSI_STRING AnsiString;
    PCHAR s;
    NTSTATUS Status;
    POBJECT_TYPES_INFORMATION TypesInfo;
    POBJECT_TYPE_INFORMATION TypeInfo;
    POBJECT_TYPE_INFORMATION TypeInfo1;
    ULONG Size, i, j;
    ULONG Totals[ 8 ];

    fShowUsage = FALSE;
    CompareField = SORT_BY_TYPE_NAME;
    NumberOfTypeNames = 0;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( toupper( *s ) ) {
                    case 'C':
                        CompareField = SORT_BY_OBJECT_COUNT;
                        break;

                    case 'H':
                        CompareField = SORT_BY_HANDLE_COUNT;
                        break;

                    case 'P':
                        CompareField = SORT_BY_PAGED_POOL;
                        break;

                    case 'N':
                        CompareField = SORT_BY_NONPAGED_POOL;
                        break;

                    case 'M':
                        CompareField = SORT_BY_NAME_USAGE;
                        break;

                    default:
                        fprintf( stderr, "OBJMON: Invalid flag - '%c'\n", *s );

                    case '?':
                        fShowUsage = TRUE;
                        break;
                    }
                }
            }
        else
        if (fShowUsage) {
            break;
            }
        else {
            if (NumberOfTypeNames >= MAX_TYPE_NAMES) {
                fprintf( stderr, "OBJMON: Too many type names specified.\n" );
                fShowUsage = TRUE;
                break;
                }

            RtlInitAnsiString( &AnsiString, s );
            RtlAnsiStringToUnicodeString( &TypeNames[ NumberOfTypeNames++ ],
                                          &AnsiString,
                                          TRUE
                                        );
            }
        }

    if (fShowUsage) {
        fprintf( stderr, "usage: OBJMON [-h] [Type Names to display]\n" );
        fprintf( stderr, "where: -? - displays this help message.\n" );
        fprintf( stderr, "       -c - sort by number of objects.\n" );
        fprintf( stderr, "       -h - sort by number of handles.\n" );
        fprintf( stderr, "       -p - sort by paged pool usage.\n" );
        fprintf( stderr, "       -n - sort by nonpaged pool usage.\n" );
        fprintf( stderr, "       -m - sort by object name usage.\n" );
        return 1;
        }

    TypesInfo = (POBJECT_TYPES_INFORMATION)LargeBuffer1;

    Size = sizeof( LargeBuffer1 );
    Status = NtQueryObject( NULL,
                            ObjectTypesInformation,
                            TypesInfo,
                            Size,
                            &Size
                          );
    
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "OBJMON: Unable to query type information - %x\n", Status );
        return 1;
        }

    TypeInfo = (POBJECT_TYPE_INFORMATION)malloc( TypesInfo->NumberOfTypes * sizeof( *TypeInfo ) );
    TypeInfo1 = (POBJECT_TYPE_INFORMATION)(((PUCHAR)TypesInfo) + ALIGN_UP( sizeof(*TypesInfo), ULONG_PTR ));
    for (i=0; i<TypesInfo->NumberOfTypes; i++) {
        TypeInfo[ i ] = *TypeInfo1;
        TypeInfo1 = (POBJECT_TYPE_INFORMATION)
            ((PCHAR)TypeInfo1 + sizeof( *TypeInfo1 ) + ALIGN_UP( TypeInfo1->TypeName.MaximumLength, ULONG_PTR ));
        }

    qsort( (void *)TypeInfo, TypesInfo->NumberOfTypes, sizeof( *TypeInfo ), CompareTypeInfo );

    memset( Totals, 0, sizeof( Totals ) );
    printf( "Object Type    Count Handles\n" );
    for (i=0; i<TypesInfo->NumberOfTypes; i++) {
        for (j=0; j<NumberOfTypeNames; j++) {
            if (RtlEqualUnicodeString( &TypeInfo[ i ].TypeName,
                                       &TypeNames[ j ],
                                       TRUE
                                     )
               ) {
                break;
                }
            }

        if (NumberOfTypeNames == 0 || j < NumberOfTypeNames) {
            printf( "%-14wZ %5u %7u\n",
                    &TypeInfo[ i ].TypeName,
                    TypeInfo[ i ].TotalNumberOfObjects,
                    TypeInfo[ i ].TotalNumberOfHandles
                  );

            Totals[ 0 ] += TypeInfo[ i ].TotalNumberOfObjects;
            Totals[ 1 ] += TypeInfo[ i ].TotalNumberOfHandles;
            }

        }

    printf( "%-14s %5u %7u\n",
            "Totals",
            Totals[ 0 ],
            Totals[ 1 ]
          );

    memset( Totals, 0, sizeof( Totals ) );
    printf( "\n\nHigh Water marks for above totals.\n" );
    printf( "Object Type    Count Handles\n" );
    for (i=0; i<TypesInfo->NumberOfTypes; i++) {
        for (j=0; j<NumberOfTypeNames; j++) {
            if (RtlEqualUnicodeString( &TypeInfo[ i ].TypeName,
                                       &TypeNames[ j ],
                                       TRUE
                                     )
               ) {
                break;
                }
            }

        if (NumberOfTypeNames == 0 || j < NumberOfTypeNames) {
            printf( "%-14wZ %5u %7u\n",
                    &TypeInfo[ i ].TypeName,
                    TypeInfo[ i ].HighWaterNumberOfObjects,
                    TypeInfo[ i ].HighWaterNumberOfHandles
                  );

            Totals[ 0 ] += TypeInfo[ i ].HighWaterNumberOfObjects;
            Totals[ 1 ] += TypeInfo[ i ].HighWaterNumberOfHandles;
            }
        }

    printf( "%-14s %5u %7u\n",
            "Totals",
            Totals[ 0 ],
            Totals[ 1 ]
          );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\resmon\target.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

PRTL_EVENT_ID_INFO IopCreateFileEventId;

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    char Buffer[ 80 ];
    PWSTR Pwstr = L"This is a PWSTR";
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;


    RtlInitUnicodeString( &UnicodeString, L"This is a UNICODE_STRING" );
    printf( "Waiting for <Enter> to proceed..." );
    fflush( stdout );
    gets( Buffer );

    IopCreateFileEventId = RtlCreateEventId( NULL,
                                             0,
                                             "CreateFile",
                                             RTL_EVENT_CLASS_IO,
                                             9,
                                             RTL_EVENT_PUNICODE_STRING_PARAM, "FileName", 0,
                                             RTL_EVENT_FLAGS_PARAM, "", 13,
                                                GENERIC_READ, "GenericRead",
                                                GENERIC_WRITE, "GenericWrite",
                                                GENERIC_EXECUTE, "GenericExecute",
                                                GENERIC_ALL, "GenericAll",
                                                FILE_READ_DATA, "Read",
                                                FILE_WRITE_DATA, "Write",
                                                FILE_APPEND_DATA, "Append",
                                                FILE_EXECUTE, "Execute",
                                                FILE_READ_EA, "ReadEa",
                                                FILE_WRITE_EA, "WriteEa",
                                                FILE_DELETE_CHILD, "DeleteChild",
                                                FILE_READ_ATTRIBUTES, "ReadAttributes",
                                                FILE_WRITE_ATTRIBUTES, "WriteAttributes",
                                             RTL_EVENT_FLAGS_PARAM, "", 3,
                                                FILE_SHARE_READ, "ShareRead",
                                                FILE_SHARE_WRITE, "ShareWrite",
                                                FILE_SHARE_DELETE, "ShareDelete",
                                             RTL_EVENT_ENUM_PARAM, "", 5,
                                                FILE_SUPERSEDE, "Supersede",
                                                FILE_OPEN, "Open",
                                                FILE_CREATE, "Create",
                                                FILE_OPEN_IF, "OpenIf",
                                                FILE_OVERWRITE, "Overwrite",
                                             RTL_EVENT_FLAGS_PARAM, "", 15,
                                                FILE_DIRECTORY_FILE, "OpenDirectory",
                                                FILE_WRITE_THROUGH, "WriteThrough",
                                                FILE_SEQUENTIAL_ONLY, "Sequential",
                                                FILE_NO_INTERMEDIATE_BUFFERING, "NoBuffering",
                                                FILE_SYNCHRONOUS_IO_ALERT, "Synchronous",
                                                FILE_SYNCHRONOUS_IO_NONALERT, "SynchronousNoAlert",
                                                FILE_NON_DIRECTORY_FILE, "OpenNonDirectory",
                                                FILE_CREATE_TREE_CONNECTION, "CreateTreeConnect",
                                                FILE_COMPLETE_IF_OPLOCKED, "CompleteIfOpLocked",
                                                FILE_NO_EA_KNOWLEDGE, "NoEas",
                                                FILE_EIGHT_DOT_THREE_ONLY, "EightDot3",
                                                FILE_RANDOM_ACCESS, "Random",
                                                FILE_DELETE_ON_CLOSE, "DeleteOnClose",
                                                FILE_OPEN_BY_FILE_ID, "OpenById",
                                                FILE_OPEN_FOR_BACKUP_INTENT, "BackupIntent",
                                             RTL_EVENT_ENUM_PARAM, "", 2,
                                                1, "NamedPiped",
                                                2,  "MailSlot",
                                             RTL_EVENT_ULONG_PARAM, "Handle", 0,
                                             RTL_EVENT_STATUS_PARAM, "", 0,
                                             RTL_EVENT_ENUM_PARAM, "", 6,
                                                FILE_SUPERSEDED, "Superseded",
                                                FILE_OPENED, "Opened",
                                                FILE_CREATED, "Created",
                                                FILE_OVERWRITTEN, "Truncated",
                                                FILE_EXISTS, "Exists",
                                                FILE_DOES_NOT_EXIST, "DoesNotExist"
                                           );

    RtlLogEvent( IopCreateFileEventId,
                 &UnicodeString,
                 GENERIC_READ | DELETE,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,
                 FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
                 0,
                 0x24,
                 STATUS_SUCCESS,
                 FILE_CREATED
               );

    ExitProcess( 0x22 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\setupext\setupext.c ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    setupext.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

--*/

#define KDEXT_64BIT

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <ntverp.h>

//
// BUGBUG - need to find better way to get these values
//

#define HASH_BUCKET_COUNT 509
#define WizPagesTypeMax 7
#define LOADED_INF_SIG   0x24666e49
#define INF_STYLE_NONE           0x00000000       // unrecognized or non-existent
#define INF_STYLE_OLDNT          0x00000001       // winnt 3.x
#define INF_STYLE_WIN4           0x00000002       // Win95
#define SPOST_NONE  0
#define SPOST_PATH  1
#define SPOST_URL   2
#define SPOST_MAX   3
#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002
#define SP_FILE_QUEUE_SIG   0xc78e1098
#define FILEOP_COPY                     0
#define FILEOP_RENAME                   1
#define FILEOP_DELETE                   2
#define FILEOP_ABORT                    0
#define FILEOP_DOIT                     1
#define FILEOP_SKIP                     2
#define FILEOP_RETRY                    FILEOP_DOIT
#define FILEOP_NEWPATH                  4

//
// Local function prototypes
//

VOID
UtilGetWStringField (
    ULONG64 Address,
    PUCHAR Structure,
    PUCHAR Field,
    PWCHAR Buffer,
    ULONG Size
    );

VOID
UtilReadWString (
    ULONG64 Address,
    PWCHAR Buffer,
    ULONG64 Size
    );

VOID
UtilDumpHex (
    PUCHAR Buffer,
    ULONG Size
    );

VOID
DumpUnwindList(
    ULONG64 pun,
    BOOL recursive
    );

VOID
DumpTargetEnt(
    ULONG64 pte
    );

VOID
DumpDelayMoveList(
    ULONG64 pdn,
    BOOL recursive
    );

VOID
DumpFileQueueNodeList(
    ULONG64 pfqn,
    ULONG64 mask,
    BOOL recursive
    );

VOID
DumpSourceMediaInfoList(
    ULONG64 smi,
    ULONG64 mask,
    BOOL recursive
    );

VOID
DumpCatalogInfoList(
    ULONG64 ci,
    ULONG64 mask,
    BOOL recursive
    );

VOID
DumpAltPlatformInfo(
    ULONG64 api
    );

VOID
DumpXFile(
    ULONG64 pxf,
    ULONG64 mask
    );

VOID
DumpXDirectory(
    ULONG64 pxdir,
    ULONG64 mask
    );

VOID
DumpXDrive(
    ULONG64 pxd,
    ULONG64 mask
    );

VOID
DumpInfVersionNode(
    ULONG64 ver
    );

VOID
DumpInfLine(
    ULONG64 line,
    ULONG64 valuedata
    );

VOID
DumpStringTableHeader(
    ULONG64 st
    );

VOID
DumpInfSection(
    ULONG64 section,
    ULONG64 linedata,
    ULONG64 valuedata
    );

ULONG64
GetStringTableData(
    ULONG64 st
    );

ULONG64
GetFirstNode(
    ULONG64 stdata,
    ULONG64 offset,
    PULONG64 poffset
    );

ULONG64
GetNextNode(
    ULONG64 stdata,
    ULONG64 node,
    PULONG64 offset
    );

BOOL
CheckInterupted(
    VOID
    );

LPCSTR
GetWizPage(
    DWORD i
    );

VOID
DumpOcComponent(
    ULONG64 offset,
    ULONG64 node,
    ULONG64 pcomp
    );


//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

ULONG64 EXPRLastDump = 0;


//
// this string is for supporting both the old and the new way of getting
// data from the kernel.  Maybe it will go away soon.
//
char ___SillyString[200];



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis, // 64Bit Change
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
    return;
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

VOID
UtilGetWStringField (
    ULONG64 Address,
    PUCHAR Structure,
    PUCHAR Field,
    PWCHAR Buffer,
    ULONG Size
    )
{
    ULONG offset = 0;
    GetFieldOffset (Structure, Field, &offset);
    UtilReadWString (offset + Address, Buffer, Size);
}


VOID
UtilReadWString (
    ULONG64 Address,
    PWCHAR Buffer,
    ULONG64 Size
    )
{
    ULONG64 count = 0;

    ZeroMemory (Buffer, (ULONG) Size);
    
    while (1)
    {
        
        if (count == (Size-1)) {
            break;
        }
        
        ReadMemory (Address + (count * sizeof (WCHAR)),
                    Buffer + count,
                    sizeof (WCHAR),
                    NULL);

        if (!Buffer[count]) {
            break;
        }
        
        count ++;
    }
}
      

ULONG64
UtilStringToUlong64 (
    UCHAR *String
    )
{
    ULONG64 ReturnValue = 0;
    sscanf (String, "%I64x", &ReturnValue);

    return ReturnValue;
}



VOID
UtilDumpHex (
    PUCHAR Buffer,
    ULONG Size
    )
{
    ULONG count = 0, count2 = 0;
    
    dprintf ("\n%08lx:", Buffer);
    
    while (count < Size) {

        if (! (count%16) && count) {
            dprintf ("|");
            for (count2 = 16; count2; count2--) {
                
                if (Buffer[count - count2] >= 0x30) {
                    dprintf ("%c", (UCHAR) Buffer[count - count2]);
                } else {
                    dprintf (".");
                }
            }
            dprintf ("\n%08lx:", Buffer + count);
        }
        dprintf ("%02x ", (UCHAR) Buffer[count]);
        count ++;
    }
}

VOID
DumpUnwindList(
    ULONG64 pun,
    BOOL recursive
    )
{
    InitTypeRead (pun, SETUPAPI!SP_UNWIND_NODE);

    dprintf( "\t\t***SP_UNWIND_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%I64x\n", ReadField (NextNode));
    dprintf( "\t\t TargetID : 0x%I64x\n", ReadField (TargetID));
    dprintf( "\t\t SecurityDesc : 0x%I64x\n", ReadField (SecurityDesc));
    dprintf( "\t\t CreateTime : 0x%I64x 0x%I64x\n",
             ReadField (CreateTime.dwLowDateTime),
             ReadField (CreateTime.dwHighDateTime));

    dprintf( "\t\t AccessTime : 0x%I64x 0x%I64x\n",
             ReadField (AccessTime.dwLowDateTime),
             ReadField (AccessTime.dwHighDateTime));

    dprintf( "\t\t WriteTime : 0x%I64x 0x%I64x\n",
             ReadField (WriteTime.dwLowDateTime),
             ReadField (WriteTime.dwHighDateTime));

    if (ReadField (NextNode) && recursive) {
        
        if (CheckInterupted()) {
            return;
        }
        
        DumpUnwindList(ReadField (NextNode), TRUE );
    }

}


VOID
DumpTargetEnt(
    ULONG64 pte
    )
{
    InitTypeRead (pte, SETUPAPI!SP_TARGET_ENT);
    
    dprintf( "\t\t***SP_TARGET_ENT structure***\n" );
    dprintf( "\t\t TargetRoot : 0x%I64x\n", ReadField (TargetRoot));
    dprintf( "\t\t TargetSubDir : 0x%I64x\n", ReadField (TargetSubDir));
    dprintf( "\t\t TargetFilename : 0x%I64\n", ReadField (TargetFilename));
    dprintf( "\t\t BackupRoot : 0x%I64x\n", ReadField (BackupRoot));
    dprintf( "\t\t BackupSubDir : 0x%I64x\n", ReadField (BackupSubDir));
    dprintf( "\t\t BackupFilename : 0x%I64x\n", ReadField (BackupFilename));
    dprintf( "\t\t NewTargetFilename : 0x%I64x\n", ReadField (NewTargetFilename));
    dprintf( "\t\t InternalFlags : 0x%I64x\n", ReadField (InternalFlags));
}

VOID
DumpDelayMoveList(
    ULONG64 pdn,
    BOOL recursive
    )
{
    InitTypeRead (pdn, SETUPAPI!SP_DELAYMOVE_NODE);

    dprintf( "\t\t***SP_DELAYMOVE_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%I64x\n", ReadField (NextNode));
    dprintf( "\t\t SourceFilename : 0x%I64x\n", ReadField (SourceFilename));
    dprintf( "\t\t TargetFilename : 0x%I64x\n", ReadField (TargetFilename));
    dprintf( "\t\t SecurityDesc (stringtable index) : 0x%I64x\n", ReadField (SecurityDesc));

    if (ReadField (NextNode) && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpDelayMoveList( ReadField (Next), TRUE );
    }

}

VOID
DumpFileQueueNodeList(
    ULONG64 pfqn,
    ULONG64 mask,
    BOOL recursive
    )

{
    InitTypeRead (pfqn, SP_FILE_QUEUE_NODE);
    
    dprintf( "\t\t***SP_FILE_QUEUE_NODE structure***\n" );
    dprintf( "\t\t Next : 0x%I64x\n", ReadField (Next));
    dprintf( "\t\t Operation : 0x%I64x ( %s )\n", ReadField (Operation),
             (ReadField (Operation) == FILEOP_DELETE) ? "DELETE" :
             (ReadField (Operation) == FILEOP_RENAME) ? "RENAME" :
             "COPY" );


    dprintf( "\t\t SourceRootPath : 0x%I64x\n", ReadField (SourceRootPath));
    dprintf( "\t\t SourcePath : 0x%I64x\n", ReadField (SourcePath));
    dprintf( "\t\t SourceFilename : 0x%I64x\n", ReadField (SourceFilename));
    dprintf( "\t\t TargetDirectory : 0x%I64x\n", ReadField (TargetDirectory));
    dprintf( "\t\t SecurityDesc : 0x%I64x\n", ReadField (SecurityDesc));

    dprintf( "\t\t SourceMediaInfo : 0x%I64x\n", ReadField (SourceMediaInfo));
    if (ReadField (SourceMediaInfo)  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpSourceMediaInfoList( ReadField (SourceMediaInfo), mask, FALSE );
        InitTypeRead (pfqn, SP_FILE_QUEUE_NODE);
    }
    
    dprintf( "\t\t StyleFlags : 0x%I64x\n", ReadField (StyleFlags));
    dprintf( "\t\t InternalFlags : 0x%I64x\n", ReadField (InternalFlags));

    dprintf( "\t\t CatalogInfo : 0x%I64x\n", ReadField (CatalogInfo));
    
    if (ReadField (CatalogInfo)  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpCatalogInfoList( ReadField (CatalogInfo), mask, FALSE  );
        InitTypeRead (pfqn, SP_FILE_QUEUE_NODE);
    }

    if (ReadField (Next) && recursive) {

        DumpFileQueueNodeList( ReadField (Next), mask, TRUE );
    }

}


VOID
DumpSourceMediaInfoList(
    ULONG64 smi,
    ULONG64 mask,
    BOOL recursive
    )
{
    InitTypeRead (smi, SETUPAPI!SOURCE_MEDIA_INFO);

    dprintf( "\t\t***SOURCE_MEDIA_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%I64x\n", ReadField (Next));
    dprintf( "\t\t Description : 0x%I64x\n", ReadField (Description));
    dprintf( "\t\t DescriptionDisplayName : 0x%I64x\n", ReadField (DescriptionDisplayName));
    dprintf( "\t\t Tagfile : 0x%I64x\n", ReadField (Tagfile));
    dprintf( "\t\t SourceRootPath : 0x%I64x\n", ReadField (SourceRootPath));
    dprintf( "\t\t CopyQueue : 0x%I64x\n", ReadField (CopyQueue));

    if (ReadField (CopyQueue) && (mask & 8)  && recursive) {
        
        if (CheckInterupted()) {
            return;
        }
        
        DumpFileQueueNodeList( ReadField (CopyQueue), mask, FALSE );
        InitTypeRead (smi, SETUPAPI!SOURCE_MEDIA_INFO);
    }

    dprintf( "\t\t CopyNodeCount : 0x%I64x\n", ReadField (CopyNodeCount));
    dprintf( "\t\t Flags : 0x%I64x\n", ReadField (Flags));

    if (ReadField (Next) && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpSourceMediaInfoList( ReadField (next), mask, TRUE );
    }

}

VOID
DumpCatalogInfoList(
    ULONG64 ci,
    ULONG64 mask,
    BOOL recursive
    )
{
    WCHAR Buffer[200];

    InitTypeRead (ci, SETUPAPI!SPQ_CATALOG_INFO);
    
    dprintf( "\t\t***SPQ_CATALOG_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%I64x\n", ReadField (Next));
    dprintf( "\t\t CatalogFileFromInf : 0x%I64x\n", ReadField (CatalogFileFromInf));
    dprintf( "\t\t AltCatalogFileFromInf : 0x%I64x\n", ReadField (AltCatalogFileFromInf));
    dprintf( "\t\t AltCatalogFileFromInfPending : 0x%I64x\n", ReadField (AltCatalogFileFromInfPending));
    dprintf( "\t\t InfFullPath : 0x%I64x\n", ReadField (InfFullPath));
    dprintf( "\t\t InfOriginalName : 0x%I64x\n", ReadField (InfOriginalName));
    dprintf( "\t\t InfFinalPath : 0x%I64x\n", ReadField (InfFinalPath));
    dprintf( "\t\t VerificationFailureError : 0x%I64x\n", ReadField (VerificationFailureError));
    dprintf( "\t\t Flags : 0x%I64x\n", ReadField (Flags));
    
    UtilGetWStringField (ci, "SETUPAPI!SPQ_CATALOG_INFO", "CatalogFilenameOnSystem", Buffer, sizeof (Buffer));
    dprintf( "\t\t CatalogFilenameOnSystem : %ws\n", Buffer);

    if (ReadField (Next) && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpCatalogInfoList(ReadField (Next), mask, TRUE ) ;
    }

}

VOID
DumpAltPlatformInfo(
    ULONG64 api
    )
{
    InitTypeRead (api, SETUPAPI!SP_ALTPLATFORM_INFO);

    dprintf( "\t\t***SP_ALT_PLATFORM_INFO structure***\n" );
    dprintf( "\t\t cbSize : 0x%I64x\n", ReadField (cbSize));
    dprintf( "\t\t Platform : 0x%I64x\n", ReadField (Platform));
    dprintf( "\t\t MajorVersion : 0x%I64x\n", ReadField (MajorVersion));
    dprintf( "\t\t MinorVersion : 0x%I64x\n", ReadField (MinorVersion));
    dprintf( "\t\t ProcessorArchitecture : 0x%I64x\n", ReadField (ProcessorArchitecture));
    dprintf( "\t\t Reserved : 0x%I64x\n", ReadField (Reserved));

}


VOID
DumpXFile(
    ULONG64 pxf,
    ULONG64 mask
    )
{
    if ((mask & 4) == 0 ) {
        return;
    }

    InitTypeRead (pxf, SETUPAPI!XFILE);
    
    dprintf( "\t\t     ***XFILE structure***\n" );
    dprintf( "\t\t      CurrentSize : 0x%I64x", ReadField (CurrentSize));
    if (ReadField (CurrentSize) == -1) {
        dprintf( " (doesn't