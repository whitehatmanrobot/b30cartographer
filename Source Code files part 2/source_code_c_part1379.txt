ethod:     CCommitEngine::ParseUnknown
//
//  Synopsis:   Tests for support of IPicture/IFont.
//
//--------------------------------------------------------------------------

HRESULT
CCommitEngine::ParseUnknown(ITypeInfo *pTypeInfo, DPD * pDPD)
{
    ITypeLib *pTypeLib = NULL;
    ITypeInfo *pInterfaceInfo = NULL;
    HRESULT hr = S_OK;
    USHORT uFound = 1; // Find the first matching name
    MEMBERID memID; // Not used
    TYPEATTR *pTypeAttr = NULL;
    UINT nTypeInfoIndex;

    switch (pDPD->dispid)
    {
    case DISPID_FONT:
        pDPD->fSpecialCaseFont = TRUE;
        break;

    case DISPID_MOUSEICON:
        pDPD->fSpecialCaseMouseIcon = TRUE;
        // Intentional fallthrough.
    case DISPID_PICTURE:
        pDPD->fSpecialCasePicture = TRUE;
        break;

    default:
        // The pDPD->bstrType contains the arg name for the property
        // go to the typelibrary, find the interface type info corresponding
        // to this name, and see if its IID is the unit measurement subobject
        for (int i = 0; i < 1; i++)
        {
            hr = pTypeInfo->GetContainingTypeLib ( &pTypeLib, &nTypeInfoIndex );
            if ( hr || !pTypeLib )
                break;

            hr = pTypeLib->FindName ( pDPD->bstrType, 0, 
                &pInterfaceInfo, &memID, &uFound );
            if ( hr || !pInterfaceInfo )
                break;

            hr = pInterfaceInfo->GetTypeAttr ( &pTypeAttr );
        }

        if ( !hr )
            hr = S_FALSE;
        break;
    }

// Cleanup:
    if ( pInterfaceInfo && pTypeAttr )
        pInterfaceInfo->ReleaseTypeAttr ( pTypeAttr );
    ReleaseInterface ( pInterfaceInfo ); 
    ReleaseInterface ( pTypeLib ); 
    RRETURN1 ( hr, S_FALSE );
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::FindReadPropFuncDesc
//
//  Synopsis:   Find FUNCDESC for get property with specified DISPID
//              This is helper function for ExamineObjects().
//
//-------------------------------------------------------------------------
HRESULT
CCommitEngine::FindReadPropFuncDesc(
        ITypeInfo * pTI,
        DISPID      dispid,
        int         iStart,         // Start search point for optimis
        int         iCount,         // Total number of functions in TypeInfo
        FUNCDESC **  ppFD)
{
    HRESULT     hr = E_FAIL;
    int         i;

    //
    // Start at the current location and move forward to the end,
    // If not found, start at the beginning of the FUNCDESCs and search to
    // the current location
    //

    for (i = iStart; i < iCount; i++)
    {
        hr = THR(pTI->GetFuncDesc(i, ppFD));
        if (hr)
            goto Cleanup;

        if ((*ppFD)->invkind == INVOKE_PROPERTYGET &&
                (*ppFD)->memid == dispid)

        {
            // Find the funcion desc for the read property
            return S_OK;
        }
        pTI->ReleaseFuncDesc(*ppFD);
        *ppFD = NULL;
    }

    for (i = 0; i < iStart; i++)
    {
        hr = THR(pTI->GetFuncDesc(i, ppFD));
        if (hr)
            goto Cleanup;

        if ((*ppFD)->invkind == INVOKE_PROPERTYGET &&
                (*ppFD)->memid == dispid)

        {
            // Find the funcion desc for the read property
            return S_OK;
        }
        pTI->ReleaseFuncDesc(*ppFD);
        *ppFD = NULL;
    }

Cleanup:
    pTI->ReleaseFuncDesc(*ppFD);
    *ppFD = NULL;
    RRETURN_NOTRACE(E_FAIL);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::ReleasePropertyDescriptor
//
//  Synopsis:   Release the created property descriptor list
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::ReleasePropertyDescriptor()
{
    long    i;
    DPD *   pDPD;

    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        pDPD->Free();
    }
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::UpdateValues
//
//  Synopsis:   Fill in values into _aryDPD
//
//-------------------------------------------------------------------------

void
CCommitEngine::UpdateValues()
{
    HRESULT     hr;
    int         i;
    DPD *       pDPD;
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD;
         i > 0;
         i--, pDPD++)
    {
        Assert(pDPD->var.vt == VT_EMPTY);

        // Clear down the current value
        VariantClear(&pDPD->var);

        hr = THR_NOTRACE(GetCommonPropertyValue(
                pDPD->dispid,
                _aryObjs.Size(),
                _aryObjs,
                &pDPD->var));

        if (hr == S_FALSE)
        {
            pDPD->fNoMatch = TRUE;
            pDPD->fMemberNotFound = FALSE;
        }
        else
        {
            pDPD->fNoMatch = FALSE;
            pDPD->fMemberNotFound = (BOOL) hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accbhave.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBhave.Cxx
//
//  Contents:   Accessible implementation for binary behaviors
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBHAVE_HXX_
#define X_ACCBHAVE_HXX_
#include "accbhave.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_ACCWINDOW_HXX_
#define X_ACCWINDOW_HXX_
#include "accwind.hxx"
#endif

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccBehavior::CAccBehavior
//----------------------------------------------------------------------------
CAccBehavior::CAccBehavior( CElement * pElementParent, BOOL fDelegate )
: CAccElement(pElementParent)
{
    if (fDelegate)
    {
        // As the default role, we give the behavior the role that we would
        // give for an ActiveX control. However, the behavior has the right to 
        // change that, since we delegate the get_accRole call. 
        // (See get_accRole implementation for details )
        SetRole(ROLE_SYSTEM_CLIENT);
    }
    else
    {
        SetRole(ROLE_SYSTEM_GROUPING);
    }

    _fDelegate = fDelegate;
    _pSubElement = NULL;
}

//----------------------------------------------------------------------------
//  CAccBehavior::~CAccBehavior
//----------------------------------------------------------------------------
CAccBehavior::~CAccBehavior()
{
    if (_pSubElement)
        _pSubElement->SubRelease();
}

//----------------------------------------------------------------------------
//  EnsureSubElement
//  
//  Ensures that the CAccBehavior::_pSubElement is set properly.
//----------------------------------------------------------------------------
HRESULT
CAccBehavior::EnsureSubElement()
{

    if (_pSubElement)
        return S_OK;

    // get the sub element
    Assert(_pElement->HasSlavePtr());

    CElement * pSubElement = _pElement->GetSlavePtr();
    CMarkup * pMarkup = pSubElement->GetMarkupPtr();

    Assert(pSubElement);
    Assert(pSubElement->Tag() == ETAG_ROOT);

    // Find out if the slave markup has been created by DOM or has 
    // been parsed in from a URL.
    // if the markup has a rootparse context or has the loaded flag
    // set, then it has been parsed. In that case, the slave element
    // is not the root but the BODY tag of the document fragment.
    if (pMarkup->GetRootParseCtx() || pMarkup->GetLoaded())
    {
        pSubElement = pMarkup->GetElementClient();
    }

    Assert((pSubElement->Tag() == ETAG_ROOT) || 
            (pSubElement->Tag() == ETAG_BODY));

    _pSubElement = pSubElement;

    _pSubElement->SubAddRef();

    return S_OK;
}

#define IMPLEMENT_DELEGATE_TO_BEHAVIOR(meth)                                    \
    IAccessible * pAccPtr;                                                      \
                                                                                \
    Assert(_pElement->HasPeerHolder());                                         \
                                                                                \
    hr = THR(_pElement->GetPeerHolder()->QueryPeerInterfaceMulti                \
                            (IID_IAccessible,                                   \
                             (void **)&pAccPtr,                                 \
                             FALSE));                                           \
                                                                                \
    if (S_OK == hr)                                                             \
    {                                                                           \
        Assert(pAccPtr);                                                        \
        hr = THR(pAccPtr->meth);                                                \
        pAccPtr->Release();                                                     \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        hr = E_NOTIMPL;                                                         \
    }                                                                       


//----------------------------------------------------------------------------
//  get_accParent
//
//  Delegate to the behavior first to see if it wants to expose its own tree 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT     hr = E_FAIL;

    if (!ppdispParent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    // delegate to the behavior
    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accParent(ppdispParent))

        // if we get an error that indicates that the behavior does not support the 
        // call, we execute our own version.
    }

    // GetAccParent handles the no markup scenario.
    if (hr)
    {
        CAccBase  * pBase = NULL;

        //
        // We are using the _pElement instead of the _pSubElement here since we want to 
        // walk on the parent tree.
        hr = GetAccParent( _pElement, &pBase);
        if (hr)
            goto Cleanup;

        hr = THR(pBase->QueryInterface(IID_IDispatch, (void**)ppdispParent));
    }
  
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accChildCount
//
//  DESCRIPTION:
//      if the behavior that is being represented here supports IAccessible,
//      we delegate the call to that behavior. Otherwise we return 0.
//
//  PARAMETERS:
//      pChildCount :   address of the parameter to receive the child count
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accChildCount(long* pChildCount)
{
    HRESULT hr = S_OK;

    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accChildCount(pChildCount))

        // if we get an error that indicates that the behavior does not support the 
        // IAccessible or the method has a problem running, we return S_OK and a child
        // count of zero.
        if (hr)
        {
            *pChildCount = 0;   //there are no children    
            hr = S_OK;
        }  
    }
    else
    {
        // cache check.
        // since the IsCacheValid checks for the Doc() too, we don't have to
        // check for Doc being there here... 
        // Also, if there is a last child and the child count is zero, then it
        // means that we made a partial walk before and we should count the
        // children now
        if ( !IsCacheValid() || ((_lLastChild != 0) && (_lChildCount == 0)))
        {
            CWindow * pAccWind = GetAccWnd();

            if (!pAccWind)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            CMarkupPointer *    pBegin = &( pAccWind->_pAccWindow->_elemBegin );
            CMarkupPointer *    pEnd = &( pAccWind->_pAccWindow->_elemEnd );
        
            // get markup limits for this element
            hr = THR(GetSubMarkupLimits( _pSubElement, pBegin, pEnd));
            if ( hr )
                goto Cleanup;
        
            // count the children within the limits provided
            hr = THR( GetChildCount( pBegin, pEnd, &_lChildCount));
        }

        *pChildCount = _lChildCount;
    }

    TraceTag((tagAcc, "CAccBehavior::get_accChildCount, childcnt=%d hr=%d", 
                *pChildCount, hr));

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  get_accChild()
//
//  DESCRIPTION:
//      if the behavior that is being represented here supports IAccessible,
//      we delegate the call to that behavior. Otherwise we return an error, since
//      this tag type can not have any children.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT      hr;

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppdispChild = NULL;        //reset the return value.

    hr = ValidateChildID(&varChild);
    if (hr)
        goto Cleanup;

    if (_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accChild(varChild, ppdispChild))

        // If the behavior does not implement this method, behave like 
        // there are no children. 
        if (E_NOTIMPL == hr)
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = super::get_accChild(varChild, ppdispChild);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accChild, childid=%d requested, hr=0x%x", 
                        V_I4(&varChild),
                        hr));  

    //S_FALSE is valid when there are no children
    //E_NOINTERFACE is valid for text children
    RRETURN2( hr, S_FALSE, E_NOINTERFACE);    
}


//----------------------------------------------------------------------------
//  accLocation()
//  
//  DESCRIPTION:
//      Returns the coordinates of the element relative to the top left corner 
//      of the client window.
//      To do that, we are getting the CLayout pointer from the element
//      and calling the GetRect() method on that class, using the global coordinate
//      system. This returns the coordinates relative to the top left corner of
//      the screen. 
//      We then convert these screen coordinates to client window coordinates.
//      
//      If the childid is not CHILDID_SELF, then tries to delegate the call to the 
//      behavior, and returns E_NOINTERFACE if the behavior does not support 
//      IAccessible.
//  
//  PARAMETERS:
//        pxLeft    :   Pointers to long integers to receive coordinates of
//        pyTop     :   the rectangle.
//        pcxWidth  :
//        pcyHeight :
//        varChild  :   VARIANT containing child information. 
//
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accLocation(  long* pxLeft, long* pyTop, 
                            long* pcxWidth, long* pcyHeight, 
                            VARIANT varChild)
{
    HRESULT     hr;
    CRect       rectElement;
   
    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;

    if (_fDelegate)
    {
        if ( V_I4(&varChild) == CHILDID_SELF )
        {
            // call super's implementation here..... 
            hr = super::accLocation( pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        }
        else 
        {
            // we pass the error that is actually coming from the behavior, since this location is
            // only hit when the behavior actually reported that it had children.
            IMPLEMENT_DELEGATE_TO_BEHAVIOR(accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild))
        }
    }
    else
    {
        // delegate to the element to handle
        hr = super::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
    }

Cleanup:

    TraceTag((tagAcc, "CAccBehavior::accLocation, childid=%d hr=0x%x", 
                V_I4(&varChild),
                hr));  

    RRETURN1( hr, S_FALSE ); 
}

//----------------------------------------------------------------------------
//  accNavigate
//  
//  DESCRIPTION:
//      Delegate to the behavior if it implements the IAccessible. Otherwise
//      not implemented.
//      
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT hr = E_NOTIMPL;

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    V_VT( pvarEndUpAt ) = VT_EMPTY;

    // if we are not delegating to a behavior, handle all navigation in 
    // the super
    if (_fDelegate)
    {
        // if we are delegating, we still handle the next/previous for the element
        // itself on the super. Other methods are delegated to the behavior.
        if ((V_VT(&varStart) == VT_I4) && 
            (V_I4(&varStart) == CHILDID_SELF) && 
            ((navDir == NAVDIR_NEXT) || (navDir == NAVDIR_PREVIOUS)))
        {
            hr = THR(super::accNavigate(navDir, varStart, pvarEndUpAt));
        }
        else
        {
            // for any of the children, and for first and last child navigation calls
            // delegate to the behavior object's implementation of IAccessible.
            IMPLEMENT_DELEGATE_TO_BEHAVIOR(accNavigate(navDir, varStart, pvarEndUpAt))        
        }
    }
    else
    {
        hr = THR(super::accNavigate(navDir, varStart, pvarEndUpAt));
    }
        
Cleanup:
    TraceTag((tagAcc, "CAccBehavior::accNavigate, start=%d, direction=%d", 
                V_I4(&varStart),
                navDir));  

    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  accHitTest()
//  
//  DESCRIPTION :   Since the window already have checked the coordinates
//                  and decided that the document contains the point, this
//                  function does not do any point checking. 
//                  If the behavior implements IAccessible, then the call is 
//                  delegated to the behavior. Otherwise CHILDID_SELF is 
//                  returned.
//                  
//  PARAMETERS  :
//      xLeft, yTop         :   (x,y) coordinates 
//      pvarChildAtPoint    :   VARIANT pointer to receive the acc. obj.
//
//  RETURNS:    
//      S_OK | E_INVALIDARG | 
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    HRESULT     hr;

    if (!pvarChildAtPoint)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(pvarChildAtPoint);

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(accHitTest(xLeft,yTop,pvarChildAtPoint))

        // if the behavior does not want to implement this method, act like this 
        // is a single block.
        if (E_NOTIMPL == hr)
        {
            V_VT( pvarChildAtPoint ) = VT_I4;
            V_I4( pvarChildAtPoint ) = CHILDID_SELF;
        
            hr = S_OK;
        }
    }
    else
    {
        hr = CAccElement::accHitTest( xLeft, yTop, pvarChildAtPoint);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::accHitTest, point(%d,%d), hr=0x%x", 
                xLeft, yTop, hr));  

    RRETURN(hr);
}    

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accDoDefaultAction(VARIANT varChild)
{   
    HRESULT     hr = S_OK;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(accDoDefaultAction(varChild))
    }

    // If the behavior does not implement this, we scroll the element into focus
    // if the childID was CHILDID_SELF.
    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = THR(ScrollIn_Focus(_pElement));
        }
        else if (!_fDelegate)
        {
            hr = super::accDoDefaultAction(varChild);
        }
    }

    TraceTag((tagAcc, "CAccBehavior::accDoDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accName
//  
//  DESCRIPTION:
//      If the behavior implements IAccessible, then call that implementation
//      otherwise return the title, if there is one.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accName(VARIANT varChild,  BSTR* pbstrName )
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accName(varChild, pbstrName))
    }

    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        // Try to return the title of the element 
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = S_OK;

            //get the title 
            pchString = (LPTSTR) _pElement->GetAAtitle();
    
            if ( pchString )
            {
                *pbstrName = SysAllocString( pchString );
        
                if ( !(*pbstrName) )
                    hr = E_OUTOFMEMORY;
            }
        }
        else if (!_fDelegate)
        {
            hr = super::get_accName( varChild, pbstrName);
        }
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accName, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accValue
//  
//  DESCRIPTION:
//      Delegates to the behavior. If there is no implementation on the 
//      behavior then E_NOINTERFACE
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accValue(VARIANT varChild,  BSTR* pbstrValue )
{
    HRESULT hr = E_NOTIMPL;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrValue = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accValue(varChild, pbstrValue))
    }
    else
    {
        hr = super::get_accValue(varChild, pbstrValue);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accValue, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}

//----------------------------------------------------------------------------
//  get_accDefaultAction
//  
//  DESCRIPTION:
//  If the behavior supports the IAccessible, the behavior is called. 
//  Otherwise the default action for OBJECT tags, which is "select" is returned.
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accDefaultAction(VARIANT varChild,  BSTR* pbstrDefaultAction )
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accDefaultAction(varChild, pbstrDefaultAction ))
    }

    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        // if the behavior returns an error, return "Select" as the default action...
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = S_OK;

            // TODO :  resource string
            *pbstrDefaultAction = SysAllocString( _T("Select") );

            if ( !(*pbstrDefaultAction) )
                hr = E_OUTOFMEMORY;
        }
        else if (!_fDelegate)
        {
            hr = super::get_accDefaultAction( varChild, pbstrDefaultAction);
        }
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

   RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accState
//  
//  DESCRIPTION:
//      
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccBehavior::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accState( varChild, pvarState))
    }

    // Do the best we can, if the behavior does not support this.
    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = S_OK;

            CDoc *  pDoc = _pElement->Doc();

            V_I4( pvarState ) = 0;

            if ( _pElement->GetReadyState() != READYSTATE_COMPLETE )
                V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    
            if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
                V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
            if ( !_pElement->IsVisible(FALSE) )
                V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
        }
        else if (!_fDelegate)
        {
            hr = super::get_accState(varChild, pvarState);
        }
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accState, childid=%d, state=0x%x, hr=0x%x", 
                V_I4(&varChild), V_I4( pvarState ), hr));  

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accDescription(VARIANT varChild, BSTR * pbstrDescription )
{
    HRESULT hr;

    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accDescription(varChild, pbstrDescription))
    }
    else
    {
        hr = super::get_accDescription(varChild, pbstrDescription);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accDescription, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accKeyboardShortcut( VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT hr;

    if (!pbstrKeyboardShortcut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrKeyboardShortcut = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut))
    }
    else
    {
        hr = THR(GetAccKeyboardShortcut(pbstrKeyboardShortcut));
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT hr;

    if (!pvarFocusChild)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(pvarFocusChild);

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accFocus(pvarFocusChild))
    }
    else
    {
        CDoc * pDoc = GetElement()->Doc();

        // Is the active element the view master or the primary 
        // element client of the viewlinked markup ?
        if ((_pElement == pDoc->_pElemCurrent) ||
            (GetElement() == pDoc->_pElemCurrent))
        {
            V_VT( pvarFocusChild ) = VT_I4;
            V_I4( pvarFocusChild ) = CHILDID_SELF;
            hr = S_OK;
        }
        else
        {
            hr = super::get_accFocus(pvarFocusChild);
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT hr = E_NOTIMPL;

    // clean the return value 
    if (!pvarSelectedChildren)
    {   
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(pvarSelectedChildren);

    if(_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accSelection(pvarSelectedChildren))
    }
    else
    {
        super::get_accSelection(pvarSelectedChildren);
    }

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT hr = E_NOTIMPL;

    // if the element itself is being asked to take focus, 
    // then no need to delegate.
    if ((V_I4(&varChild) == CHILDID_SELF) && 
        (V_VT(&varChild) == VT_I4))
    {
        if (flagsSel & SELFLAG_TAKEFOCUS)
            hr = THR(ScrollIn_Focus(_pElement));
    }
    else
    {
        if (_fDelegate)
        {
            IMPLEMENT_DELEGATE_TO_BEHAVIOR( accSelect( flagsSel, varChild))
        }
        else
        {
            hr = super::accSelect( flagsSel, varChild);
        }
    }

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT hr=S_OK;

    TraceTag((tagAcc, "CAccBehavior::get_accRole, childid=%d", 
                V_I4(&varChild)));  

    if (!pvarRole)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // clear the out parameter
    V_VT( pvarRole ) = VT_EMPTY;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accRole(varChild, pvarRole))
    }

    //
    // If the behavior is not capable of reporting a role, 
    // or we are not hooked to a binary behavior,
    // then return the default role that was set in the constructor.
    //
    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            // pack role into out parameter
            V_VT( pvarRole ) = VT_I4;
            V_I4( pvarRole ) = GetRole();
            hr = S_OK;
        }
        else if (!_fDelegate)
        {
            hr = super::get_accRole(varChild, pvarRole);
        }
    }

Cleanup:
    RRETURN2(hr, S_FALSE, E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::put_accValue( VARIANT varChild, BSTR bstrValue )
{
    HRESULT hr = E_NOTIMPL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(put_accValue(varChild, bstrValue))
    }

    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::put_accName( VARIANT varChild, BSTR bstrName )
{
    HRESULT hr = E_NOTIMPL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(put_accName(varChild, bstrName))
    }

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accarea.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccArea.Cxx
//
//  Contents:   Accessible Area object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCAREA_HXX_
#define X_ACCAREA_HXX_
#include "accarea.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccArea
//  
//  DESCRIPTION:    
//      The area accessible object constructor
//
//  PARAMETERS:
//      Pointer to the area element 
//----------------------------------------------------------------------------
CAccArea::CAccArea( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_LINK );
}

//----------------------------------------------------------------------------
//  get_accParent
//  
//  DESCRIPTION:
//      Area elements have map elements as their parents in the tree. The map
//  elements have the body as their parent. In the accessibility code, the parent
//  for an area must be the image that contains that area, since the map element
//  is not supported and the area is really associated with the image and not the
//  body.
//  
//  Since there is no way for us to learn which area is associated with which 
//
//----------------------------------------------------------------------------
STDMETHODIMP    
CAccArea::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT             hr;
    CTreeNode *         pNode = NULL;
    CTreeNode *         pParentNode = NULL;
    CCollectionCache *  pCollectionCache;
    long                lSize, l;
    CAccBase *          pAccParent = NULL;
    CMarkup *           pMarkup = NULL;


    TraceTag((tagAcc, "CAccArea::get_accParent"));      

    if ( !ppdispParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    //
    // get to the element's node
    //
    pNode = _pElement->GetFirstBranch();

    // We have to have a tree node that is in the tree when we reach here
    if ( !pNode || pNode->IsDead())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get the parent node.
    pParentNode = pNode->Parent();

    AssertSz( ( pParentNode->Tag()== ETAG_MAP ), 
                    "How can we not have a MAP Parent for an AREA?? !?!" );

    pMarkup = _pElement->GetMarkupPtr();

    // there has to be a MAP parent for an area.
    if ( !pParentNode || 
        ( pParentNode->Tag()!= ETAG_MAP ) || 
        !pMarkup)       // we can not count on the fact that we are in a markup at anytime.
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // We have the MAP element that contains the area, now find an image that 
    // is associated with this map.
    hr = THR( pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION) );
    if ( hr )
        goto Cleanup;
        
    pCollectionCache = pMarkup->CollectionCache();

    // Get the size of the doc's elements collection (0).
    lSize = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    for ( l=0; l< lSize; l++ )
    {
        CElement * pElemCandidate;

        WHEN_DBG( pElemCandidate = NULL; )

        hr = THR( pCollectionCache->GetIntoAry( CMarkup::ELEMENT_COLLECTION, l, &pElemCandidate ));
        if (hr)
            goto Cleanup;

        Assert( pElemCandidate );
        
        // if this element is an image and 
        // the image is associated with the map that is this area's parent, then we return
        // the element as the parent.
        if ( pElemCandidate->Tag() == ETAG_IMAGE) 
        {
            CMapElement * pMap;

            DYNCAST( CImgElement, pElemCandidate)->EnsureMap();

            pMap = DYNCAST( CImgElement, pElemCandidate)->GetMap();

            if ( (CElement *)pMap == pParentNode->Element() )
            {
                // get the accessible object of the image element 
                pAccParent = GetAccObjOfElement( pElemCandidate );

                if ( pAccParent )
                {
                    hr = THR(pAccParent->QueryInterface(IID_IDispatch, (void**)ppdispParent));
                }
                else
                    hr = E_OUTOFMEMORY;

                // return with the success code and the value for the parent
                goto Cleanup;
            }
        }
    }

    // if we did not return from the loop, it means that we could not find 
    // an image that contains this area. Return S_FALSE and NULL pointer for 
    // the parent value.
    hr = S_FALSE;

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the title
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccArea::GetAccName( BSTR* pbstrName)
{
    HRESULT hr = S_OK;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;
    
    //get the title or the label for the area.
    hr = GetTitleorLabel(pbstrName);

    // if there is no title or label may be we can use the alt text
    // if there is alt text on the area tag.
    if (!*pbstrName || hr)
    {
        TCHAR * pchString;

        pchString = (LPTSTR) (DYNCAST(CAreaElement, _pElement))->GetAAalt();

        if (pchString)
        {
            hr = FormsAllocString( pchString, pbstrName);
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the href of the area, which is stored in the CHyperLink
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccArea::GetAccValue( BSTR* pbstrValue)
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    hr = THR( (DYNCAST(CAreaElement,_pElement))->get_href( pbstrValue ) );

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the area has a shape, then appends the shape string to the string:
//      "link region type:"
//      The shape string can be "RECT", "CIRCLE" or "POLY"
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccArea::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr;
    CStr    strShape;
    CStr    strBase;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = NULL;

    //get the shape string
    hr = THR( ((CAreaElement *)_pElement)->GetshapeHelper(&strShape));
    if ( hr )
        goto Cleanup;

    //if there was a shape string, then prepare the return string
    if ( strShape.Length() > 0 )
    {
        hr = THR( strBase.Set(_T("link region type: ")));
        if ( hr )
            goto Cleanup;

        hr = THR (strBase.Append( strShape ) );
        if ( hr )
            goto Cleanup;

        hr = THR(strBase.AllocBSTR(pbstrDescription));
    }

Cleanup:
    RRETURN( hr );

}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_LINKED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccArea::GetAccState( VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = STATE_SYSTEM_LINKED;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus())
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action for  an area element, in a string. The default
//  action string is "jump"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccArea::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Jump") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}


//+------------------------------------------------------------------
//
//  Member : accLocation
//
//  Synopsis : virtual override. this method deals wit hteh specific 
//      positioning informatio nof areas. beause they are not in the 
//      tree/runs the same way as other elements all we really need to 
//      do here is get the offset properties and return that.  In addition
//      this is all the proxy did, so we will be consistent.
//-------------------------------------------------------------------
STDMETHODIMP 
CAccArea::accLocation(  long* pxLeft, long* pyTop, 
                        long* pcxWidth, long* pcyHeight, 
                        VARIANT varChild)
{
    HRESULT         hr;
    RECT            rectBound;
    CDoc *          pDoc = _pElement->Doc();
    IAccessible *   pAccImg = NULL;
   
    TraceTag((tagAcc, "CAccArea::accLocation, childid=%d", V_I4(&varChild)));  
    WHEN_DBG(rectBound.left = rectBound.top = rectBound.bottom = rectBound.right = 0);

    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;
    
    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) != CHILDID_SELF )
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    // we need to be in the active tree.
    if ( _pElement->IsInMarkup() && pDoc && pDoc->GetView()->IsActive() )
    {
        RECT rectImg = g_Zero.rc;       // left, top, bottom, right will map to
                                        // left, top, width, height for location of image

        // get the location relative to the top of the image the area is associated with
        DYNCAST(CAreaElement, _pElement)->GetBoundingRect(&rectBound);

        // get the image's coordinates to calculate the screen location.
        hr = THR(get_accParent((IDispatch **)&pAccImg));
        if (hr)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        Assert( pAccImg );

        // varChild has to contain CHILDID_SELF, otherwise we would not be here.
        hr = THR(pAccImg->accLocation( &rectImg.left, &rectImg.top, 
                                       &rectImg.bottom, &rectImg.right, varChild));
        if (hr)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // add the image coordinates to the area coordinates to get the screen coordinates
        *pyTop = rectBound.top + rectImg.top;
        *pxLeft = rectBound.left + rectImg.left;
        *pcxWidth = rectBound.right - rectBound.left;
        *pcyHeight = rectBound.bottom - rectBound.top;
    }

Cleanup:
    TraceTag((tagAcc, "CAccArea::accLocation, Location reported as left=%d top=%d width=%d height=%d, hr=%d", 
                rectBound.left,
                rectBound.top,
                rectBound.right - rectBound.left,
                rectBound.bottom - rectBound.top,
                hr));
    ReleaseInterface(pAccImg);
    RRETURN( hr ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accbody.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBody.Cxx
//
//  Contents:   Accessible object for the Body Element 
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ACCBODY_HXX_
#define X_ACCBODY_HXX_
#include "accbody.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

ExternTag(tagAcc);

extern HRESULT EnsureAccWindow(CWindow * pWindow);

//-----------------------------------------------------------------------
//  CAccBody::CAccBody()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  :   Address of the CElement that hosts this 
//                          object.
//----------------------------------------------------------------------
CAccBody::CAccBody( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );

    //initialize the instance variables
    SetRole(ROLE_SYSTEM_PANE);
}

//-----------------------------------------------------------------------
//  get_accParent
//
//  DESCRIPTION    :
//          Return the window object related to the document that contains
//          the body tag.
//          The implementation of this method is fairly simple and different
//          from the CAccBase::get_accParent implementation. The reason is 
//          that we know for a that the body can be only parented by the
//          document itself.
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBody::get_accParent( IDispatch ** ppdispParent )
{
    HRESULT hr = S_OK;

    if ( !ppdispParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    // If the document has not been questioned for its accessible object
    // yet. This could happen if the hit test started at a windowed child.

    //
    // !! <<<< READTHIS BEFORE MAKING CHANGES HERE >>>> 
    // The accbody is created for both FRAMESET and BODY tags that are the primary
    // client of the window. The frameset elements that are not at the top level are
    // ignored. This is IE4 and IE5 compat requirement for MSAA1.x. DO NOT CHANGE! 
    // (FerhanE)

    CWindow * pWindow;

    pWindow = _pElement->GetCWindowPtr();
    hr = EnsureAccWindow(pWindow);
    if (hr)
        goto Cleanup;

    Assert(pWindow->_pAccWindow);

    hr = THR( pWindow->_pAccWindow->QueryInterface(IID_IDispatch, (void**)ppdispParent));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  get_accSelection
//  
//  DESCRIPTION:
//      The CAccBody is a special case for this method, since it also can
//      represent a frameset. 
//      If the object represents a frameset, then the call is delegated to the 
//      frame that has the focus.
//      Otherwise, the call is delegated to the CAccElement implementation of this
//      method, since CAccElement is the base class for the CAccBOdy, and the body
//      element is treated as any other.
//      
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBody::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT     hr = S_OK;
    CElement *  pClient = NULL;
    CAccBase *  pAccChild = NULL;
    CDoc *      pDoc = _pElement->Doc();

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( _pElement->Tag() == ETAG_BODY )
    {
        hr = THR( CAccElement::get_accSelection( pvarSelectedChildren ) );
        goto Cleanup;
    }

    // the element is a frameset.

    // get the active frame and delegate the call. This function handles
    // recursive frames too.
    if ( pDoc )
    {
        CFrameElement *  pFrameActive;

        // Get the active frame element in this frameset tag's markup.
        hr = THR(pDoc->GetActiveFrame(&pFrameActive, _pElement->GetMarkupPtr()));
        if (hr)
            goto Cleanup;

        if (pFrameActive)
        {
            // We have a frame element that is active, and a child of this frameset.
            // Delegate the call to the active frame's document's element client.
            Assert(pFrameActive->_pWindow->Markup());
            pClient = pFrameActive->_pWindow->Markup()->GetElementClient();
        
            Assert( pClient );
    
            pAccChild = GetAccObjOfElement( pClient );
            if ( !pAccChild )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = THR( pAccChild->get_accSelection( pvarSelectedChildren ) );
        }
        else
        {
            // return no selection
            VariantClear(pvarSelectedChildren);
        }
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  DESCRIPTION:
//      Returns the document title
//      
//
//  PARAMETERS:
//      pbstrName   :   address of the pointer to receive the URL BSTR
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBody::GetAccName( BSTR* pbstrName)
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;
    
    pMarkup = _pElement->GetMarkupPtr();
    if (!pMarkup)
        goto Cleanup;

    TraceTag((tagAcc, "CAccBody::GetAccName, %s", (CMarkup::GetUrl(pMarkup))));

    hr = THR(pMarkup->Document()->get_title(pbstrName));

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------
//  DESCRIPTION :   
//      Return the value for the document object, this is the URL of the 
//      document if the child id is CHILDID_SELF. 
//
//  PARAMETERS:
//      pbstrValue  :   pointer to the BSTR to receive the value.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBody::GetAccValue( BSTR* pbstrValue )
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pbstrValue = NULL;

    pMarkup = _pElement->GetMarkupPtr();
    if (!pMarkup)
        goto Cleanup;

    TraceTag((tagAcc, "CAccBody::GetAccName, %s", (CMarkup::GetUrl(pMarkup))));

    hr = THR(pMarkup->Document()->get_URL(pbstrValue));

Cleanup:
    RRETURN( hr );
}


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBody::GetAccState( VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }
     
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( _pElement->GetReadyState() != READYSTATE_COMPLETE )
        V_I4( pvarState ) = STATE_SYSTEM_UNAVAILABLE;
    else 
        V_I4( pvarState ) = STATE_SYSTEM_READONLY;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;

    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;    

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accanch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccAnch.Cxx
//
//  Contents:   Accessible Anchor object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCANCH_HXX_
#define X_ACCANCH_HXX_
#include "accanch.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccAnchor
//  
//  DESCRIPTION:    
//      The anchor accessible object constructor
//
//  PARAMETERS:
//      Pointer to the anchor element 
//----------------------------------------------------------------------------
CAccAnchor::CAccAnchor( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_LINK );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns the inner text of the anchor, which is the name seen for the 
//      anchor. 
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccAnchor::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    //get the title or the label for the anchor.
    hr = GetTitleorLabel(pbstrName);

    if (hr || !*pbstrName)
    {
        hr = THR( _pElement->get_innerText( pbstrName ) );
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the href of the anchor, which is stored in the CHyperLink
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccAnchor::GetAccValue( BSTR* pbstrValue )
{
    HRESULT hr;

    // validate out parameter
     if ( !pbstrValue )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrValue = NULL;

    hr = THR( (DYNCAST(CAnchorElement,_pElement))->get_href( pbstrValue ) );

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the inner text of the anchor, which is the name seen for the 
//      anchor. Actually, this is the same function with the GetAccName for the
//      anchor element, so it calls GetAccName()
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccAnchor::GetAccDescription( BSTR* pbstrDescription )
{
    RRETURN( GetAccName(pbstrDescription) );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_LINKED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccAnchor::GetAccState( VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();
    
    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;       
        goto Cleanup;
    }
    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = STATE_SYSTEM_LINKED;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if (!_pElement->IsVisible(FALSE))
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

    if ( (DYNCAST( CAnchorElement, _pElement))->IsVisited() )
        V_I4( pvarState ) |= STATE_SYSTEM_TRAVERSED;
        
Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action for  an anchor element, in a string. The default
//  action string is "jump"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccAnchor::GetAccDefaultAction( BSTR* pbstrDefaultAction )
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Jump") );

    if ( !(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBase.Cxx
//
//  Contents:   Accessible base object implementation
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBASE_HXX_
#define X_ACCBASE_HXX_
#include "accbase.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CAccBase, ObjectModel, "CAccBase")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//  Synopsis : CBase Class Descriptor Structure
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAccBase::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IAccessible,               // _piidDispinterface
    NULL,                           // _apHdlDesc
};


//----------------------------------------------------------------------------
//  IUnknown Interface Implementation
//----------------------------------------------------------------------------

//-----------------------------------------------------------------------
//  CAccBase::QueryInterface()
//
//  DESCRIPTION:
//
//      Standard QI implementation : the CAccBase object implements
//      IDispatch and IAccessible.
//
//  PARAMETERS:
//
//      riid        REFIID of requested interface.
//      ppv         pointer to interface in.
//
//  RETURNS:
//
//      E_NOINTERFACE | NOERROR.
//
//  TODO    : Add IEnumVariant.
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccBase::PrivateQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    
    if ( !ppv )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
  
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *)((IPrivateUnknown *)this);
    }
    else if (riid == IID_IDispatch) 
    {
        *ppv = (IDispatch *)((IAccessible *)this);
    }
    else if ( riid == IID_IAccessible )
    {
        *ppv = (IAccessible *)this;
    }
    /*
    else if ( riid == IID_IEnumVARIANT )
    {
        // Get the enumerator for this instance. We don't
        // keep a reference for the enumerator, so we
        // don't have to AddRef it below.

        // BOLLOCKS - Breaks COM Rules
        hr = THR( GetEnumerator( (IEnumVARIANT **)ppv ) );
    }
    */
    else if ( riid == IID_IServiceProvider )
    {
        *ppv = (IServiceProvider *)this;
    }
    else
    {
        //Delegate the call to the super;
        hr = THR( super::PrivateQueryInterface( riid, ppv));
        goto Cleanup;
    }

    //AddRef if the pointer is being returned.
    if ( *ppv /*&& (riid != IID_IEnumVARIANT)*/)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}

//+---------------------------------------------------------------------------
//  GetTypeInfoCount
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::GetTypeInfoCount( UINT *pctInfo )
{
    // check the out parameter
    if ( !pctInfo )
    {
        RRETURN( E_POINTER );
    }
    
    //set the type information count
    *pctInfo = 1;

    RRETURN( S_OK );
}


//+---------------------------------------------------------------------------
//  GetTypeInfoCount
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::GetTypeInfo(  unsigned int iTInfo,
                        LCID ,
                        ITypeInfo FAR* FAR* ppTInfo)
{   
    HRESULT     hr = S_OK;

    if ( iTInfo )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if ( !ppTInfo )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    hr = THR( EnsureAccTypeInfo( ppTInfo ) );
    
Cleanup:    
    RRETURN( hr ); 
}

//+---------------------------------------------------------------------------
//  GetIDsOfNames
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::GetIDsOfNames(    REFIID riid,
                            OLECHAR FAR* FAR* rgszNames,
                            unsigned int cNames,
                            LCID,
                            DISPID FAR* rgDispId)
{
    HRESULT     hr;
    ITypeInfo * pAccTypeInfo = NULL;
    
    hr = THR( EnsureAccTypeInfo( &pAccTypeInfo ) );
    if ( hr )
        RRETURN( hr );

    Assert( pAccTypeInfo );
    
    RRETURN( DispGetIDsOfNames( pAccTypeInfo, 
                                rgszNames, 
                                cNames, 
                                rgDispId));
}

//+---------------------------------------------------------------------------
//  Invoke
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::Invoke(   DISPID dispIdMember,
                    REFIID riid,
                    LCID,
                    WORD wFlags,
                    DISPPARAMS FAR* pDispParams,
                    VARIANT FAR* pVarResult,
                    EXCEPINFO FAR* pExcepInfo,
                    unsigned int FAR* puArgErr)
{
    HRESULT     hr;
    ITypeInfo * pAccTypeInfo = NULL;

    hr = THR( EnsureAccTypeInfo( &pAccTypeInfo ) );
    if ( hr )
        RRETURN( hr );

    Assert( pAccTypeInfo );

    RRETURN( DispInvoke(    DYNCAST( IAccessible, this),           
                            pAccTypeInfo,   
                            dispIdMember,   
                            wFlags,         
                            pDispParams,    
                            pVarResult,     
                            pExcepInfo,     
                            puArgErr) );
}


//----------------------------------------------------------------------------
//  DESCRIPTION :   
//          Not supported
//
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      pbstrHelp    :   pointer to the BSTR to receive data.
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::get_accHelp(VARIANT varChild, BSTR* pbstrHelp)
{
    if ( pbstrHelp )
        *pbstrHelp = NULL;
        
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  DESCRIPTION :   
//          Not supported
//
//  PARAMETERS:
//      pbstrHelpFile   :   Path for the help file.
//      varChild        :   VARIANT containing the child ID
//      pidTopic        :   address of the long to receive data
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic)
{
    if ( pidTopic )
        *pidTopic = NULL;
        
    return E_NOTIMPL;
}


//----------------------------------------------------------------------------
//  DESCRIPTION :   
//          NYI
//
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      pbstrValue   :   value bstr
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::put_accName(VARIANT varChild, BSTR bstrName)
{   
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  IOleWindow implementation
//
//----------------------------------------------------------------------------
STDMETHODIMP    
CAccBase::GetWindow( HWND* phwnd )
{
    HRESULT hr = S_OK;
    
    if ( !phwnd )
    {
        hr = E_POINTER;
    }
    else
    { 
        Assert( GetAccWnd()->Doc()->State() >= OS_INPLACE );
        
        //get the window handle from the document.
        *phwnd = GetAccWnd()->Doc()->GetHWND();
        if ( !(*phwnd) )
            hr = E_FAIL;
    }

    RRETURN( hr );
}


STDMETHODIMP
CAccBase::ContextSensitiveHelp( BOOL fEnterMode )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//
//      HELPER FUNCTIONS 
//
//----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//  ValidateChildID()
//
//  DESCRIPTION:
//      Validates the child id that is passed in in a variant variable. This is 
//      used only on in-parameters so that is it a safe operation to change it
//      and dereference in place.
//----------------------------------------------------------------------------
HRESULT 
CAccBase::ValidateChildID( VARIANT *pVar )
{
    HRESULT hr = S_OK;
    
    Assert(pVar);

    switch ( V_VT( pVar ) )
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy( pVar, pVar->pvarVal );
            hr = ValidateChildID( pVar );
            break;

        case VT_ERROR:
            if ( pVar->scode != DISP_E_PARAMNOTFOUND )
            {
                hr = E_INVALIDARG;
                break;
            }
          // Treat this as a VT_EMPTY

        case VT_EMPTY:
            V_VT(pVar ) = VT_I4;
            V_I4( pVar ) = CHILDID_SELF;
            break;

        case VT_I4:
            if ( V_I4( pVar ) < 0 )
                hr = E_INVALIDARG;
            break;

        default:
            hr = E_INVALIDARG;
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetAccParent
//  
//  DESCRIPTION:
//      Non-virtual helper that returns the accessible parent object for a 
//      CElement.
//      Although this function works with elements, it is still placed in the
//      base class, since the frames also have element parents, although they
//      are themselves accessible window objects.
//  
//  PARAMETERS:
//      pElem       :   CElement which we want the accessible parent of.
//      pAccParent  :   Pointer to the accessible parent object to be returned.
//  
//  RETURNS:
//      S_OK | E_POINTER | E_OUTOFMEMORY | E_FAIL
//----------------------------------------------------------------------------
HRESULT
CAccBase::GetAccParent( CElement * pElem,  CAccBase ** ppAccParent)
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode = NULL;
    CTreeNode * pParentNode = NULL;
    
    if ( !ppAccParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppAccParent = NULL;

    //
    // get to the element's node
    //
    pNode = pElem->GetFirstBranch();

    // We have to have a tree node that is in the tree when we reach here
    if ( !pNode || pNode->IsDead())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // initialize for the loop
    pParentNode = pNode;

    //
    // loop until we find a parent node, that is connected to an 
    // HTML element that is a supported in the accessibility world.
    //
    // use do/while since the element passed with pElem may not be supported.
    do 
    {
        pParentNode = pParentNode->Parent();
    }
    while ( pParentNode && 
            (pParentNode->Tag() != ETAG_ROOT) && 
            !IsSupportedElement( pParentNode->Element()));

    if ( !pParentNode )
    {
        hr = S_FALSE;   // according to the spec, this is what we should return
        goto Cleanup;
    }
    else
    {
        // We have hit a valid element, but if it is a BODY tag, then we 
        // may be in a viewlink that is not a frame/iframe
        // 
        // In that case, the parent is the master element.
        //

        // If we hit a BODY tag and the master is a GENERIC tag, then use that tag
        // as the parent.
        CRootElement * pRoot = pParentNode->GetMarkup()->Root();

        if ((pParentNode->Tag() == ETAG_BODY) && 
            (pRoot->HasMasterPtr()) && 
            (pRoot->GetMasterPtr()->Tag() == ETAG_GENERIC))
        {
            pParentNode = pRoot->GetMasterPtr()->GetFirstBranch();
        }
        else if (pParentNode->Tag() == ETAG_ROOT)
        {
            // If we hit the root and that kicked us out of the loop, then use its
            // master if it has one.
            // Otherwise, we have reached the top without finding anything.
            //
            if (pParentNode->Element()->HasMasterPtr())
            {
                pParentNode = pParentNode->Element()->GetMasterPtr()->GetFirstBranch();
            }
            else
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }
        
        Assert(IsSupportedElement(pParentNode->Element()));
    }

    //
    // Since we have found the node for the supported element parent,
    // we can now create the accessible object for that element.
    //
    *ppAccParent = GetAccObjOfElement( pParentNode->Element() );

    if ( !(*ppAccParent)) 
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
HRESULT 
CAccBase::EnsureAccTypeInfo( ITypeInfo ** ppTI )
{
    HRESULT     hr = S_OK;
    CDoc *      pRootDoc = NULL;
    ITypeLib *  pTLib = NULL;
    
    // only called by internal methods
    Assert( ppTI );

    pRootDoc = GetAccWnd()->Doc();
    
    // if the root document already has a cached ITypeInfo for IAccessible
    if ( pRootDoc && pRootDoc->_pAccTypeInfo )
    {
        *ppTI = pRootDoc->_pAccTypeInfo;
    }
    else
    {
        OLECHAR     szFile[] = _T("OLEACC.DLL");
        
        // get the type information pointer from OLEACC
        hr = THR(LoadTypeLib( szFile, &pTLib));
        if ( hr )
            goto Cleanup;

        Assert( pTLib );

        // get the type information for the IID_IAccessible 
        hr = THR( pTLib->GetTypeInfoOfGuid( IID_IAccessible, ppTI));
        if ( hr )
            goto Cleanup;

        // it is implied with the 'if' above that we will have a valid *ppTI
        Assert( *ppTI );
        
        // cache the pointer if the call was successfull
        if ( pRootDoc )
            pRootDoc->_pAccTypeInfo = *ppTI;
    }
    
Cleanup:
    // we can release the pTLib, since we are holding on to the type
    // information from the same type library
    ReleaseInterface( pTLib );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accbtn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBtn.Cxx
//
//  Contents:   Accessible object for the INPUT buttons( BUTTON, RESET, SUBMIT)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBTN_HXX_
#define X_ACCBTN_HXX_
#include "accbtn.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif


//-----------------------------------------------------------------------
//  CAccBtn::CAccBtn()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  :   Address of the CElement that hosts this 
//                          object.
//----------------------------------------------------------------------
CAccButton::CAccButton( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );

    //initialize the instance variables
    SetRole( ROLE_SYSTEM_PUSHBUTTON );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty return it. Otherwise return the object.value 
//      for tag==INPUT and object.innertext for tag==BUTTON
//      
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccButton::GetAccName( BSTR* pbstrName)
{
    HRESULT hr = S_OK;
    CStr    strValue;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    if ( _pElement->Tag() == ETAG_INPUT )
    {
        hr = THR( DYNCAST(CInput, _pElement)->GetValueHelper( &strValue ) );
        if ( hr )
            goto Cleanup;

        hr = THR( strValue.AllocBSTR( pbstrName ) );
    }
    else
    {
        hr = THR( _pElement->get_innerText( pbstrName ) );
    }

    //get the title 
    if ( !( *pbstrName ) )
        hr = GetTitleorLabel(pbstrName);


Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty return it. Otherwise return the object.value 
//      for tag==INPUT and object.innertext for tag==BUTTON
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccButton::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    CStr    strValue;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    // the description is the Title if there is a value for:
    //     NAME:{if <input type=button > return Value or "" .
    //           for <BUTTON> tag return the inner text }
    // otherwise, it is ""
    if ( _pElement->Tag() == ETAG_INPUT )
    {
        hr = THR( DYNCAST(CInput, _pElement)->GetValueHelper( &strValue ) );
    }
    else
    {
        hr = THR( _pElement->get_innerText( pbstrDescription ) );
    }

    // we'll have one or the other, but never both
    if ( *pbstrDescription)
    {
        SysFreeString(*pbstrDescription);
        *pbstrDescription = NULL;
        hr = GetTitle( pbstrDescription );
    }
    else if (!strValue.IsNull())
    {
        hr = GetTitle( pbstrDescription );
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_LINKED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccButton::GetAccState(  VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;

        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
        if (( _pElement->Tag()==ETAG_INPUT ) && 
            ( (DYNCAST(CInput, _pElement))->GetAAtype() == htmlInputSubmit) )
        {
            V_I4( pvarState ) |= STATE_SYSTEM_DEFAULT;
        }
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action, which is "Press"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccButton::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Press") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\acccheck.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccCheck.Cxx
//
//  Contents:   Accessible Checkbox object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCCHECK_HXX_
#define X_ACCCHECK_HXX_
#include "acccheck.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

//----------------------------------------------------------------------------
//  CAccCheckbox
//  
//  DESCRIPTION:    
//      The checkbox accessible object constructor
//
//  PARAMETERS:
//      Pointer to the checkbox element 
//----------------------------------------------------------------------------
CAccCheckbox::CAccCheckbox( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_CHECKBUTTON );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the label, if not the title.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCheckbox::GetAccName( BSTR* pbstrName)
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrName = NULL;

    hr = THR( GetLabelorTitle(pbstrName) );

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the label, if not, the title
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCheckbox::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr=S_OK;

    // validate out parameter
    if ( !pbstrDescription )
    {   
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if (HasLabel())
        hr = THR( GetTitle( pbstrDescription ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//      if checked then STATE_SYSTEM_CHECKED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccCheckbox::GetAccState( VARIANT *pvarState)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bChecked = FALSE;
    CDoc *          pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;

        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
        hr = THR( (DYNCAST( CInput, _pElement))->GetChecked(&bChecked) ) ;
        if ( hr )
            goto Cleanup;
    
        //check explicitly for FALSE since this is a VARIANT_BOOL.
        if ( bChecked != VB_FALSE )
            V_I4( pvarState ) |= STATE_SYSTEM_CHECKED;
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//      Returns the default action for a checkbox. The default action is either
//      "check" or "uncheck", depending on the state of the checkbox
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccCheckbox::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT         hr;
    VARIANT_BOOL    bChecked = FALSE;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = NULL;

    hr = THR( (DYNCAST( CInput, _pElement))->GetChecked(&bChecked) ) ;
    if ( hr )
        goto Cleanup;

    //check explicitly for FALSE since this is a VARIANT_BOOL.
    if ( bChecked != VB_FALSE )
    {
        *pbstrDefaultAction = SysAllocString( _T("Uncheck") );
    }
    else
    {
        *pbstrDefaultAction = SysAllocString( _T("Check") );
    }

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accedit.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccEdit.Cxx
//
//  Contents:   Accessible editbox object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCEDIT_HXX_
#define X_ACCEDIT_HXX_
#include "accedit.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

//----------------------------------------------------------------------------
//  CAccEdit
//  
//  DESCRIPTION:    
//      The editbox accessible object constructor
//
//  PARAMETERS:
//      Pointer to the editbox element 
//----------------------------------------------------------------------------
CAccEdit::CAccEdit( CElement* pElementParent, BOOL bIsPassword )
:CAccElement( pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_TEXT );

    // is this edit control of type input password.
    _bIsPassword = bIsPassword;
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the label text or the title
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    hr = THR( GetLabelorTitle(pbstrName) );    

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the value of the edit box.
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::GetAccValue( BSTR* pbstrValue)
{
    HRESULT hr = S_OK;
    CStr    str;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    // if not a password element, then return the information
    if ( !_bIsPassword )
    {
        if (_pElement->Tag() != ETAG_TEXTAREA)
        {
            hr = THR( (DYNCAST( CInput, _pElement))->GetValueHelper( &str ) );
        }
        else
        {
            hr = THR((DYNCAST(CTextArea, _pElement))->GetValueHelper( &str ));
        }
        
        if ( hr ) 
            goto Cleanup;

        //even if the value that is returned is NULL, we want to return it..
        hr = str.AllocBSTR(pbstrValue);
    }
    else
        hr = E_ACCESSDENIED;    // password's can not be read by outsiders.
    
Cleanup:
    RRETURN( hr );
}



//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the title if there is no label, otherwise ""
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr=S_OK;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = NULL;

    if (HasLabel())
        hr = THR( GetTitle( pbstrDescription ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccEdit::GetAccState( VARIANT *pvarState)
{
    HRESULT hr =S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {  
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;

        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    }

    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

    if ( _bIsPassword )
        V_I4( pvarState ) |= STATE_SYSTEM_PROTECTED;

Cleanup:
    RRETURN( hr );
}


HRESULT
CallInvoke(CElement * pElement, OLECHAR* pszMethod, BSTR bstrValue)
{
    HRESULT             hr;
    IDispatch          *pDispatch = NULL;
    DISPID              dispid;
    DISPPARAMS          params;
    VARIANTARG          var;

    hr = pElement->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    if ( hr )
    {
        goto Cleanup;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pszMethod, 1, LCID_SCRIPTING, &dispid);
    if ( hr )
    {
        goto Cleanup;
    }

    V_BSTR(&var) = bstrValue;
    V_VT(&var) = VT_BSTR;

    params.rgdispidNamedArgs = NULL;
    params.cNamedArgs = 0;
    params.rgvarg = &var;
    params.cArgs = 1;
    
    hr = pDispatch->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_PROPERTYPUT, 
                            &params, NULL, NULL, NULL);
    if ( hr )
    {
        goto Cleanup;
    }

    hr = S_OK;
Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::PutAccValue( BSTR bstrValue )
{
    HRESULT hr = S_OK;

    // move the element into focus.
    hr = THR( ScrollIn_Focus( _pElement ) );
    if ( hr )
        goto Cleanup;

    hr = THR( CallInvoke(_pElement, _T("value"), bstrValue) );

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accfile.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-2000
//
//  File:       AccFile.Cxx
//
//  Contents:   Accessible <input type=file> object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCFILE_HXX_
#define X_ACCFILE_HXX_
#include "accfile.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccInputFile
//  
//  DESCRIPTION:    
//      The input type=file accessible object constructor
//
//  PARAMETERS:
//      Pointer to the input element 
//----------------------------------------------------------------------------
CAccInputFile::CAccInputFile(CElement* pElementParent)
:CAccEdit(pElementParent, FALSE)
{
    Assert(pElementParent);
    
    //initialize the instance variables
    SetRole(ROLE_SYSTEM_TEXT);
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action, which is "Browse for file to upload"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccInputFile::GetAccDefaultAction(BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if (!pbstrDefaultAction)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Browse for file to upload") );

    if (!(*pbstrDefaultAction))
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN(hr);
}


//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the value of the input type=file box.
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputFile::GetAccValue(BSTR* pbstrValue)
{
    HRESULT hr = S_OK;
    CStr    str;

    // validate out parameter
    if (!pbstrValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

	// get value from InputFile    
    hr = THR((DYNCAST(CInput, _pElement))->GetValueHelper(&str));
    if (hr) 
        goto Cleanup;

    //even if the value that is returned is NULL, we want to return it..
    hr = str.AllocBSTR(pbstrValue);
    
Cleanup:
    RRETURN(hr);
}



//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns "browse for file to upload"
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputFile::GetAccDescription(BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if (!pbstrDescription)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = SysAllocString(_T("Browse for file to upload"));
	
Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccElem.Cxx
//
//  Contents:   Accessible element implementation
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CAccElementaccLocation_aryRects_pv, Locals, "CAccElement::accLocation aryRects::_pv")
MtDefine(CAccElementget_accSelection_aryVariants_pv, Locals, "CAccElement::get_accSelection aryVariants::_pv")
DeclareTag(tagAcc, "Accessibility", "IAccessible Methods");

//
//we have some test code in the accLocation that needs this.
//
#if DBG==1
#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif
MtExtern(CFlowLayoutGetChildElementTopLeft_aryRects_pv);
#endif

extern HRESULT EnsureAccWindow( CWindow * pWindow );

//-----------------------------------------------------------------------
//  CAccElement::GetAccWnd()
//
//  Returns the window object that has the accessible window attached to it.
//  In the process, it also ensures that there will be an accessible window
//  object. In case there is not one, returns NULL.
//
//-----------------------------------------------------------------------
CWindow * 
CAccElement::GetAccWnd()
{
    CWindow *pWindow = _pElement->GetCWindowPtr();
    if (EnsureAccWindow(pWindow))
    {
        return NULL;
    }
    return pWindow;
}



//-----------------------------------------------------------------------
//  CAccElem::CAccElem()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  CElement pointer to the element which this
//                      accessible class hangs from. 
//                      If this parameter is NOT provided.
// ----------------------------------------------------------------------
CAccElement::CAccElement( CElement* pElementParent ) 
: CAccBase(), _lastChild( pElementParent->Doc() )
{
    Assert( pElementParent );
    
    _pElement = pElementParent;         //cache the pointer

    //only if the element pointer is valid
    if ( _pElement )
    {
        //if this element already has an accessibility object.
        if ( _pElement->HasAccObjPtr() )
        {
            //this should never happen.
            AssertSz( FALSE, 
                      "The newly created acc obj was already listed in lookaside list" );
        
            _pElement->DelAccObjPtr();
        }

        _pElement->SetAccObjPtr(this);
    }
}

//----------------------------------------------------------------------------
//  CAccElement::~CAccElement()
//  
//  DESCRIPTION:
//      Destructor
//----------------------------------------------------------------------------
CAccElement::~CAccElement()
{
    //Since this destructor only gets called after the element deletes the 
    //lookaside pointer, we don't have to delete the lookaside pointer here.
    _pElement = NULL;    
}

//+---------------------------------------------------------------------------
//  PrivateAddRef
//  
//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the element that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccElement::PrivateAddRef()
{
    Assert( _pElement );
    return _pElement->AddRef();
}

//+---------------------------------------------------------------------------
//  PrivateRelease

//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the element that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccElement::PrivateRelease()
{
    Assert( _pElement );
    return _pElement->Release();
}


//----------------------------------------------------------------------------
//
//  IAccessible Interface Implementation.
//
//----------------------------------------------------------------------------

//-----------------------------------------------------------------------
//  get_accParent()
//
//  DESCRIPTION:
//
//      Element implementation of the IAccessible::get_accParent method.
//      If the accessible object already has an accessible parent, that 
//      parent is returned. Otherwise the accessible element tree is 
//      walked and the parent is found.
//
//  PARAMETERS:
//
//      ppdispParent    :   address of the variable that will receive the
//                          parent pointer.
//
//  RETURNS:
//
//      E_POINTER | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT     hr;
    CAccBase  * pBase = NULL;

    // GetAccParent handles the no markup scenario.

    hr = GetAccParent( _pElement, &pBase);
    if (hr)
        goto Cleanup;

    hr = THR(pBase->QueryInterface(IID_IDispatch, (void**)ppdispParent));
  
Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  CAccElement::get_accChildCount()
//
//  DESCRIPTION:
//          Returns the number of accessible children that the object has.
//
//  PARAMETERS:
//
//      pChildCount :   Address of the variable to receive the child count
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accChildCount(long* pChildCount)
{
    HRESULT             hr = S_OK;
    
    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pChildCount = 0;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( CanHaveChildren() )
    {
        // cache check.
        // since the IsCacheValid checks for the Doc() too, we don't have to
        // check for Doc being there here... 
        // Also, if there is a last child and the child count is zero, then it
        // means that we made a partial walk before and we should count the
        // children now
        if ( !IsCacheValid() || ((_lLastChild != 0) && (_lChildCount == 0)))
        {
            CWindow * pAccWind = GetAccWnd();
            
            _lChildCount = 0;       // reset cached value

            if (!pAccWind)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            CMarkupPointer *    pBegin = &( pAccWind->_pAccWindow->_elemBegin );
            CMarkupPointer *    pEnd = &( pAccWind->_pAccWindow->_elemEnd );

            // get markup limits for this element
            hr = THR( GetMarkupLimits( _pElement, pBegin, pEnd) );
            if ( hr )
                goto Cleanup;
            
            hr = THR( GetChildCount( pBegin, pEnd, &_lChildCount));
        }

        *pChildCount = _lChildCount;
    } 

    TraceTag((tagAcc, "CAccElement::get_accChildCount, role=%d, childcnt=%d hr=%d", GetRole(), _lChildCount, hr));

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  CAccElement::get_accChild()
//
//  DESCRIPTION:
//          Returns the number of accessible children that the object has.
//          The implementation here is called by all derived implementations
//          since it checks the parameters and performs initial work.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT          hr;
    CAccBase *       pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accChild, role=%d, childid=%d requested", 
                        GetRole(), 
                        V_I4(&varChild)));  

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppdispChild = NULL;        //reset the return value.

    // markup existence check is done in GetChildFromID which is called below.

    // unpack varChild, and validate the child id 
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //the object itself is not its own child
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else 
    {
        //if there are no children, this function returns S_FALSE.
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the child is text, then the client has to talk to 
            //the parent object to get to that child. So we have to
            //return an invalid return value to tell the client
            //that this acc obj. is the object to talk to for this 
            //child.
            hr = E_NOINTERFACE;

            TraceTag((tagAcc, 
                        "CAccElement::get_accChild, role=%d, childid=%d, text child indication returned", 
                        GetRole(), 
                        V_I4(&varChild)));  
        }
        else 
        {
            //assign return value.
            *ppdispChild = (IDispatch *)pAccChild;            

            //AddRef since this is going outside 
            pAccChild->AddRef();

            TraceTag((tagAcc, 
                        "CAccElement::get_accChild, role=%d, childid=%d, accChild=0x%x", 
                        GetRole(), 
                        V_I4(&varChild),
                        pAccChild));
        }
    }

Cleanup:
    //S_FALSE is valid when there is no children
    //E_NOINTERFACE is valid for text children
    RRETURN2( hr, S_FALSE, E_NOINTERFACE);
}

//----------------------------------------------------------------------------
//  get_accName()
//
//  DESCRIPTION:
//  CAccElement class implementation of the get_accName. 
//  This method is not implemented in any of the derived classes. 
//  The derived classes implement the GetAccName() instead, to make 
//  the code simpler.
//  This implementation handles all child related checks, to let the 
//  GetAccName to only worry about the value to be returned, for the 
//  object that it is implemented on.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pbstrName   :   pointer to the bstr to receive the name
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP
CAccElement::get_accName(VARIANT varChild, BSTR* pbstrName)
{
    HRESULT                 hr;
    CAccBase *              pAccChild = NULL;
    CMarkupPointer *        pMarkupText = NULL;
    MARKUP_CONTEXT_TYPE     context;
    long                    lchCnt =-1;

    TraceTag((tagAcc, "CAccElement::get_accName, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrName )
     {
        hr= E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's GetAccName implementation
        hr = THR( GetAccName(pbstrName) );
    }
    else
    {
        CWindow * pWindow = GetAccWnd();

        if (!pWindow)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        pMarkupText = &( pWindow->_pAccWindow->_elemBegin );

        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, pMarkupText) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            // the markup pointer is actually pointing after the text now. 
            // get the number of characters available for reading.
            hr = THR( pMarkupText->Left( TRUE, &context, NULL, &lchCnt, NULL, NULL) );
            if ( hr )
                goto Cleanup;

            Assert( context == CONTEXT_TYPE_Text );   //just checking.. !

            //allocate buffer
            hr = FormsAllocStringLen ( NULL, lchCnt, pbstrName );
            if ( hr )
                goto Cleanup;

            //read text
            hr = THR( pMarkupText->Right( TRUE, &context, NULL, &lchCnt, *pbstrName, NULL));
            if ( hr )
            {
                // release the BSTR and reset the pointer if we have failed to get
                // the text from tree services.
                FormsFreeString( *pbstrName );
                *pbstrName = NULL;
            }    
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;
            
            //call child's get_accName implementation
            hr = THR( pAccChild->get_accName( varChild, pbstrName) );
        }
    }

Cleanup:

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  DESCRIPTION:
//  CAccElement class implementation of the get_accValue. This method is not 
//  implemented in any of the derived classes. The derived classes implement
//  the GetAccValue() instead, to make the code simpler.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pbstrValue  :   pointer to the bstr to receive the value
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accValue, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrValue )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrValue = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's implementation
        hr = THR( GetAccValue(pbstrValue) );
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the parent is anchor, then anchor's value, otherwise
            //not implemented
            if ( GetElement()->Tag() == ETAG_A )
            {
                //call instance's implementation
                hr = THR( GetAccValue(pbstrValue) );
            }
            else
            {
                hr = E_NOTIMPL;
            }
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;
            
            //call child's GetAccName implementation
            hr = THR( pAccChild->get_accValue( varChild, pbstrValue) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  DESCRIPTION:
//  CAccElement class implementation of the get_accDescription. This method is not 
//  implemented in any of the derived classes. The derived classes implement
//  the GetAccDescription() instead, to make the code simpler.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pbstrDescription  :   pointer to the bstr to receive the description
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accDescription(VARIANT varChild, BSTR* pbstrDescription)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accDescription, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDescription = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's implementation
        hr = THR( GetAccDescription(pbstrDescription) );
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            // child is text.
            hr = E_NOTIMPL;
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;

            //call child's implementation
            hr = THR( pAccChild->get_accDescription( varChild, pbstrDescription) );
        }
    }

Cleanup:
    RRETURN2( hr, S_FALSE, E_NOTIMPL);
}

//-----------------------------------------------------------------------
//  CAccElement::get_accRole()
//
//  DESCRIPTION:
//          Returns the accessibility role of the object.
//
//  PARAMETERS:
//
//      varChild    :   Variant that contains the child information
//      pvarRole    :   Address of the variant to receive the role information
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT         hr ;      
    long            lRetRole = 0;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accRole, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate the out parameter
    if ( !pvarRole )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // clear the out parameter
    V_VT( pvarRole ) = VT_EMPTY;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        lRetRole = GetRole();   //this acc. objects role
    }
    else 
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            lRetRole = ROLE_SYSTEM_TEXT;
        }
        else 
        {
            //call child's implementation
            lRetRole = pAccChild->GetRole();
        }
    }
       
    if ( hr == S_OK )
    {
        // pack role into out parameter
        V_VT( pvarRole ) = VT_I4;
        V_I4( pvarRole ) = lRetRole;
    }
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accState()
//
//  DESCRIPTION:
//  CAccElement class implementation of the get_accState. This method is not 
//  implemented in any of the derived classes. The derived classes implement
//  the GetAccState() instead, to make the code simpler.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pvarState   :   pointer to the VARIANT to receive the state information
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT             hr;
    CAccBase *          pAccChild = NULL;
    CMarkupPointer *    pTextBegin = NULL;
    CMarkupPointer *    pTextEnd = NULL;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    htmlSelection       selectionType;
    IDispatch *         pDispRange = NULL;

    CMarkup * pMarkup = _pElement->GetMarkupPtr();

    if (pMarkup == NULL || pMarkup->Document() == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        CSelectionObject selectionObject(pMarkup->Document());


        TraceTag((tagAcc, "CAccElement::get_accState, role=%d, childid=%d", 
                 GetRole(), 
                 V_I4(&varChild)));  

        // validate out parameter
        if ( !pvarState )
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        // reset the out parameter
        V_VT( pvarState ) = VT_EMPTY;
    
        // unpack varChild 
        hr = THR( ValidateChildID(&varChild) );
        if ( hr )
            goto Cleanup;

        if ( V_I4(&varChild) == CHILDID_SELF )
        {   

            hr = THR( GetAccState(pvarState) );

            // a pane is always visible.
            if (ROLE_SYSTEM_PANE != GetRole())
            {
                CLayout *           pLayout;
                CStackDataAry <RECT,4>     aryRects( Mt(CAccElementaccLocation_aryRects_pv) );
                CRect               rectElement;
                CDoc *              pDoc = GetElement()->Doc();

                // bodies and framesets should be treated like any other element
                // get the closest layout.
                pLayout = GetElement()->GetUpdatedNearestLayout();
                if ( !pLayout )
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                // get the region 
                if (ETAG_AREA != GetElement()->Tag())
                {
                    pLayout->RegionFromElement( GetElement(), &aryRects, &rectElement, RFE_SCREENCOORD);

                    //rectElem needs to be adjusted if we are in a frame
                    if (   !rectElement.IsEmpty()
                        && _pElement->GetWindowedMarkupContext())
                    {
                        POINT ptOrg;
                        CMarkup  *pwmc = _pElement->GetWindowedMarkupContext();

                        pwmc->GetElementClient()->GetClientOrigin(&ptOrg);

                        rectElement.OffsetRect(-ptOrg.x, -ptOrg.y);
                    }
                }
                else if (GetElement()->IsInMarkup() && pDoc && pDoc->GetView()->IsActive())
                {
                    DYNCAST(CAreaElement, GetElement())->GetBoundingRect(&rectElement);
                }
                else
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                // if the element is out of the client area, it is not visible.
                if (!IsVisibleRect(&rectElement))
                {                    
                    V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE; 

                    if (GetElement() && GetElement()->IsVisible(FALSE))
                    {
                        V_I4( pvarState ) |= STATE_SYSTEM_OFFSCREEN;
                    }
                }
            }
        }
        else
        {
            CWindow * pWindow = GetAccWnd();
            
            if (!pWindow)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            //
            // get the child CElement/CMarkupPointer. If the child id 
            // is invalid, the GetChildFromID will return with an err.
            //
            pTextBegin = &(pWindow->_pAccWindow->_elemBegin);

            hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, pTextBegin) );
            if ( hr ) 
               goto Cleanup;

            if ( !pAccChild )
            {
                CAccBase *  pParentA = (GetElement()->Tag() == ETAG_A) ? this : GetParentAnchor();

                //if we are an anchor, assume its state
                if (pParentA)
                {
                    hr = THR( DYNCAST(CAccElement, pParentA)->GetAccState( pvarState ) );
                    if ( hr )
                        goto Cleanup;
                }
                else 
                {
                    V_VT( pvarState ) = VT_I4;
                    V_I4( pvarState ) = 0;
                }
            
                if ( fBrowserWindowHasFocus() )
                    V_I4( pvarState ) |= STATE_SYSTEM_SELECTABLE;

                CTreeNode * pParentNode = NULL;
                if (_pElement->IsNoScope())
                {
                    CTreeNode * pNode = _pElement->GetFirstBranch();
                    if (pNode)
                    {
                        pParentNode = pNode->Parent();
                    }
                }
                else
                {
                    pParentNode = pTextBegin->CurrentScope();
                }

                if (!pParentNode)
                {
                    Assert(FALSE);
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                //READONLY only if not editable
                BOOL fEditable = pParentNode->Element()->IsEditable(/*fCheckContainerOnly*/FALSE);
                
                if (!fEditable)
                    V_I4( pvarState ) |= STATE_SYSTEM_READONLY;
                
                if (!pParentNode->Element()->IsVisible(FALSE))
                    V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

                // pTextBegin is already pointing to the end of the text. 
                pTextEnd = &(pWindow->_pAccWindow->_elemEnd);

                hr = THR( pTextEnd->MoveToPointer( pTextBegin ) );
                if ( hr )
                    goto Cleanup;

                //move the pointer to mark the beginning of the child.
                hr = THR( pTextBegin->Left( TRUE, &context, NULL, NULL, NULL, NULL) );
                if ( hr )
                    goto Cleanup;

                // Is text selected ? If any text that is inside this text child is selected, then
                // we consider this text child as selected.
                hr = THR( selectionObject.GetType( &selectionType ) );

                if ( (selectionType != htmlSelectionNone) && GetElement()->Doc() ) 
                {
                    CMarkupPointer      selBegin( GetElement()->Doc() );
                    CMarkupPointer      selEnd( GetElement()->Doc() );
                    CAutoRange *        pRange = NULL;

                    // Get the range that is selected from the selection object
                    hr = THR( selectionObject.createRange(&pDispRange) );
                    if ( hr )
                        goto Cleanup;

                    // The selection range is always there, even if there is no selection
                    Assert( pDispRange );

                    hr = THR( pDispRange->QueryInterface( CLSID_CRange, (void **)&pRange ) );
                    if ( hr )
                        goto Cleanup;

                    Assert( pRange );

                    // place the left and right markups to the txtrange left and right
                    hr  = THR( pRange->GetLeftAndRight( &selBegin, &selEnd ) );
                    if ( hr )
                        goto Cleanup;

                    Assert( context == CONTEXT_TYPE_Text );

                    // if the selection is NOT totally out of this element, then the state
                    // has to be STATE_SYSTEM_SELECTED.
       
                    // if there is a selection, it should somehow be inside or overlapping with the
                    // text area. 
                    // 
                    if ( selEnd.IsRightOf( pTextBegin ) && selBegin.IsLeftOf( pTextEnd ) )
                        V_I4( pvarState ) |= STATE_SYSTEM_SELECTED; //hr is S_OK here.
                }

                //visibility of the text depends on the following two things to be TRUE
                // Is the closest element parent of the text visible?
                // Is the text within the client window coordinates ?
                //
                if (!IsTextVisible(pTextBegin, pTextEnd))
                {
                    V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE; 
                    if (pParentNode->Element()->IsVisible(FALSE))
                        V_I4( pvarState ) |= STATE_SYSTEM_OFFSCREEN; 
                }
            }
            else 
            {
                V_I4( &varChild ) = CHILDID_SELF;

                //call child's implementation
                hr = THR( pAccChild->get_accState(varChild, pvarState) );
            }
        }
}
Cleanup:
    ReleaseInterface( pDispRange );

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accKeyboardShortCut
//  
//  DESCRIPTION :   
//          Returns the keyboard shortcut if there is one.
//
//  PARAMETERS:
//      varChild                :   VARIANT containing the child ID
//      pbstrKeyboardShortcut   :   address of the bstr to receive data
//
//  RETURNS:
//      E_POINTER | S_OK | E_NOTIMPL | E_OUTOFMEMORY
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accKeyboardShortcut, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrKeyboardShortcut )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrKeyboardShortcut = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        switch (GetElement()->Tag())
        {
            case ETAG_INPUT:
            case ETAG_BUTTON:
            case ETAG_A:
            case ETAG_SELECT:
                hr = THR(GetAccKeyboardShortcut(pbstrKeyboardShortcut));
                if (hr)
                    goto Cleanup;
                break;
                
            default:
                hr = S_OK;
                break;
        }
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //no keyboard shortcuts for plain text, unless we (or a parent is an
            // anchor)
            CAccBase * pParentA = (GetElement()->Tag() == ETAG_A) ? this : GetParentAnchor();
            CVariant   varChildSelf;

            V_VT(&varChildSelf) = VT_I4;
            V_I4(&varChildSelf) = CHILDID_SELF;

            //if we are an anchor, assume its state
            hr = (!pParentA) ? S_OK :
                THR( pParentA->get_accKeyboardShortcut(varChildSelf, pbstrKeyboardShortcut) );
        }
        else 
        {
            // call child's implementation of this method. We don't have a helper here,
            // since the CHILDID_SELF case above has all the smarts and code.
            // varChild already is of type VT_I4, so only set the value.
            V_I4( &varChild ) = CHILDID_SELF;
            hr = THR( pAccChild->get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accFocus
//
//  DESCRIPTION :   Gets the active element on the current document and 
//                  checks if this acc object's element is the same one.
//
//  PARAMETERS:
//      pvarFocusChild  :   address of VARIANT to receive the focused child info
//
//  RETURNS:
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT         hr = S_OK;
    CElement *      pElemFocus = NULL;
    CAccBase *      pAccFocus = NULL;
    IDispatch *     pAccParent = NULL;
   
    TraceTag((tagAcc, "CAccElement::get_accFocus, role=%d, childid=%d", GetRole()));  

    if ( !pvarFocusChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarFocusChild ) = VT_EMPTY;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //using GetAccDoc saves us from reimplementing this on window.
    pElemFocus = GetElement()->Doc()->_pElemCurrent;

    //is the active element this one?
    if ( GetElement() == pElemFocus )
    {
        V_VT( pvarFocusChild ) = VT_I4;
        V_I4( pvarFocusChild ) = CHILDID_SELF;
        goto Cleanup;
    }
    else
    {
        // if this object is the accessible parent of the element that
        // has the focus, then return the acc object for that element
        
// ???? - look into area's & images when the area has the focus
        pAccFocus = GetAccObjOfElement(pElemFocus);
        if ( !pAccFocus )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // Get the parent accessible object for the element that has the 
        // focus. We have to call through interface, since the pAccFocus element
        // can be a body or a frame set.
        hr = THR( pAccFocus->get_accParent( &pAccParent ) );
        if ( hr )
            goto Cleanup;

        Assert( pAccParent );

        // if these two objects are the same, then this acc object instance
        // is the parent for the acc object that is attached to the element
        // that currently has the focus. We return the acc object for the 
        // element that has the focus
        if ( pAccParent == DYNCAST( IAccessible, this) )  
        {
            V_VT( pvarFocusChild ) = VT_DISPATCH;
            V_DISPATCH( pvarFocusChild ) = pAccFocus;
            pAccFocus->AddRef();
        }
        else
        {
            V_VT(pvarFocusChild) = VT_EMPTY;
        }
    }
    
Cleanup:    
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//  get_accSelection
//  
//  DESCRIPTION:
//      This is the method implementation for all HTML elements except for the
//      body/frameset tags. The body/frameset implementation delegates the call
//      to the frame that has the focus.
//      This method returns an acc object, or a pointer to the IEnumVariant
//      that represents an array of acc. objects, that is/are intersecting with
//      the selection on the page.
//      
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT             hr;

    CMarkup * pMarkup = _pElement->GetMarkupPtr();
    htmlSelection       selectionType;
    IDispatch *         pDispRange = NULL;  

    if (pMarkup == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        CSelectionObject    selectionObject(pMarkup->Document());

        TraceTag((tagAcc, "CAccElement::get_accSelection, role=%d, childid=%d", GetRole()));  

        if ( !pvarSelectedChildren )
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        // default the return value to no selection.
        V_VT(pvarSelectedChildren) = VT_EMPTY;  

        // we can not return selected children , if there are no children.
        if ( !CanHaveChildren() )
        {
            hr = S_OK;
            goto Cleanup;
        }

        // Is text selected ? If any text that is inside this text child is selected, then
        // we consider this text child as selected.
        hr = THR( selectionObject.GetType( &selectionType ) );
    
        if (hr)
            goto Cleanup;

        if ( (selectionType != htmlSelectionNone) && GetElement()->Doc() ) 
        {
            CAutoRange *        pRange = NULL;
            MARKUP_CONTEXT_TYPE context;
            CMarkupPointer      selStart( GetElement()->Doc() );
            CMarkupPointer      selEnd( GetElement()->Doc() );
            CMarkupPointer      elemStart( GetElement()->Doc() );
            CMarkupPointer      elemEnd( GetElement()->Doc() );
            long                cChildBase = 0;              

//Note: [FerhanE]
//          Using the range object is very expensive for us, since it 
//          is created using markups and we have to ask for them again.
//          However, since the editing and selection live out of the native code base, 
//          we have to use interface calls.
        
            // Get the range that is selected from the selection object
            hr = THR( selectionObject.createRange(&pDispRange) );
            if ( hr )
                goto Cleanup;

            // if there is no selection, there is nothing to do, we have already 
            // set the return value to VT_EMPTY by clearing the out parameter.
            if ( !pDispRange )
                goto Cleanup;
   
            hr = THR( pDispRange->QueryInterface( CLSID_CRange, (void **)&pRange ) );
            if ( hr )
                goto Cleanup;

            Assert( pRange );

            // place the left and right markups to the txtrange left and right
            hr  = THR( pRange->GetLeftAndRight( &selStart, &selEnd ) );
            if ( hr )
                goto Cleanup;

            // move the pSelStart pointer to the closest tag to its left, 
            // to ease our lives for child counting. Any child that is partially
            // selected is assumed to be selected.
            hr = THR( selStart.Left( FALSE, &context, NULL, NULL, NULL, NULL ));
            if (hr) 
                goto Cleanup;

            if ( context == CONTEXT_TYPE_Text )
            {   
                hr = THR( selStart.Left( TRUE, &context, NULL, NULL, NULL, NULL ) );
                if ( hr ) 
                    goto Cleanup;
            }
    
            // place markups to beginning and end of the element too.
            hr = THR( GetMarkupLimits(GetElement(), &elemStart, &elemEnd) );
            if ( hr ) 
                goto Cleanup;

            // Check if the selection is completely out of this element's scope.
            if ( selStart.IsRightOf( &elemEnd ) || selEnd.IsLeftOf( &elemStart ) )
                goto Cleanup;       //hr is S_OK here.
        
            // If the selection starts before the element, we should make it start
            // with the element, to ease our calculations later.
            if ( selStart.IsLeftOf( &elemStart ) )
            {
                // Move the selection pointer to the start of element
                hr = THR( selStart.MoveToPointer( &elemStart ) );
                if ( hr )
                    goto Cleanup;
            }

            // If the selection ends after the element, make it end with the element
            // to ease calculations.
            if ( elemEnd.IsLeftOf( &selEnd ) )
            {
                // Move the selection pointer to the end of element
                hr = THR( selEnd.MoveToPointer( &elemEnd ) );
                if ( hr )
                    goto Cleanup;
            }

            // Count the number of children from the beginning of the element's scope,
            // until the selection starts.
            hr = THR( GetChildCount( &elemStart, &selStart, &cChildBase) );
            if ( hr ) 
                goto Cleanup;

            // GetChildCount moves the pElemStart in the markup stream as it counts children.
            // If the pElemStart is further than the selStart in the markup stream, then it means
            // that the selection starts in a supported element. We should move the selection begin
            // point to the beginning of that element and decrement the child count.
            if ( selStart.IsLeftOf( &elemStart)  )
            {   
                CTreeNode * pNode = NULL;

                pNode = selStart.CurrentScope();

                while ( !IsSupportedElement(pNode->Element()) 
    #if DBG ==1 
                        && ( GetElement() != pNode->Element() )   //security check
    #endif                
                      )
                {
                    pNode = pNode->Parent();
                }
        
                //security check continues
                Assert( GetElement() != pNode->Element() );

                // move the selection start to the beginning of the supported element
                hr = THR( selStart.MoveAdjacentToElement( pNode->Element(), ELEM_ADJ_BeforeBegin));
                if ( hr )
                    goto Cleanup;
        
                //decrement the child base, since we took a step backwards.
                cChildBase--;
            }

            // count and retrieve the children starting from the selStart position, 
            // upto and incuding the element that contains the selEnd position
            hr = THR( GetSelectedChildren( cChildBase, 
                                            &selStart, &selEnd, 
                                            pvarSelectedChildren ));
        }
    }

Cleanup:
    ReleaseInterface( pDispRange );
    
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  get_accDefaultAction
//
//  DESCRIPTION:
//      CAccElement implementation for the get_accDefaultAction method. Each
//      object that is derived from this class overwrites this method's helper
//      function GetAccDefaultAction. This implementation is only responsible for
//      manipulating the child id and processing the call in case the child
//      id that is passed refers to text.
//      
//  PARAMETERS:
//      varChild            :   VARIANT that contains the child information
//      pbstrDefaultAction  :   Address of the BSTR to receive the default 
//                              action string.
//      
//  RETURNS:
//          S_OK | E_INVALIDARG | E_POINTER    
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accDefaultAction, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrDefaultAction )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDefaultAction = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's GetAccDefaultAction implementation
        hr = THR( GetAccDefaultAction(pbstrDefaultAction) );
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the text is inside an anchor, then it reflects
            //anchors default action
            if ( GetElement()->Tag() ==ETAG_A )
            {
                hr = THR( GetAccDefaultAction(pbstrDefaultAction) );
            }
            else
            {
                //there is no default action for text.
                hr = E_NOTIMPL;
            }
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;

            //call child's GetAccDefaultAction implementation
            hr = THR( pAccChild->get_accDefaultAction( varChild, pbstrDefaultAction) );
        }
    }

Cleanup:
    RRETURN( hr );

}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT             hr;
    CAccBase *          pAccChild = NULL;
    CAccBase *          pAccParent = NULL;
    CElement *          pElemFocus = GetElement();

    TraceTag((tagAcc, "CAccElement::accSelect, role=%d, childid=%d, flagsSel=0x%x", 
                GetRole(), 
                V_I4(&varChild),
                flagsSel));  

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // validate the child,
    hr = THR( ValidateChildID( &varChild ));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {   
        // if the element is an IMG 
        if ( GetElement()->Tag() == ETAG_IMG )
        {
            // we can call the helper, since we know that the 
            // element is not a body/frameset
            hr = GetAccParent( GetElement(), &pAccParent);
            if ( hr )
                goto Cleanup;

            Assert( pAccParent );

            //  If the parent acc. obj is an anchor, call
            //  the standard implementation. otherwise E_NOTIMPL
            if ( pAccParent->GetElement()->Tag() != ETAG_A )
            {
                hr =E_NOTIMPL;
                goto Cleanup;
            }

            pElemFocus = pAccParent->GetElement();
            
            //fall through if the parent is anchor.
        }

        // For all elements, including the body/frameset, the behavior is to
        // set the focus to itself
        if ( flagsSel & SELFLAG_TAKEFOCUS )
        {
            hr = ScrollIn_Focus( pElemFocus );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        CWindow * pWindow = GetAccWnd();

        if (!pWindow)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        CMarkupPointer *    ptrBegin = &( pWindow->_pAccWindow->_elemBegin );

        // Find the child indicated with the ID.
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, ptrBegin) );
        if ( hr ) 
            goto Cleanup;

        if ( pAccChild )
        {
            // Go through the interface method, to support frames
            V_I4( &varChild ) = CHILDID_SELF;
            
            hr = pAccChild->accSelect(flagsSel, varChild);
        }
        else
        {
            //text 
            
            // the child is a text block.
            switch ( flagsSel )
            {
                // set focus to the parent element.
                case SELFLAG_TAKEFOCUS:
                    hr = ScrollIn_Focus(GetElement());
                    break;

                case SELFLAG_TAKESELECTION:
                    IMarkupPointer  * pIMarkup;
                    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;

                    hr = THR(ptrBegin->Left(TRUE, &context, NULL, NULL, NULL, NULL));
                    if (hr)
                        goto Cleanup;

                    hr = THR( ptrBegin->QueryInterface( IID_IMarkupPointer, 
                                                                (void**)&pIMarkup ));
                    if ( hr )
                        goto Cleanup;
                        
                    hr = THR( SelectText( GetElement(), pIMarkup ) );

                    // Release the instance we got from the QI call.
                    ReleaseInterface( pIMarkup );
                    
                    break;
            }
        }
    }
    
Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  accLocation()
//  
//  DESCRIPTION:
//      Returns the coordinates of the element relative to the top left corner 
//      of the client window.
//      To do that, we are getting the CLayout pointer from the element
//      and calling the GetRect() method on that class, using the global coordinate
//      system. This returns the coordinates relative to the top left corner of
//      the screen. 
//      We then convert these screen coordinates to client window coordinates.
//  
//  PARAMETERS:
//        pxLeft    :   Pointers to long integers to receive coordinates of
//        pyTop     :   the rectangle.
//        pcxWidth  :
//        pcyHeight :
//        varChild  :   VARIANT containing child information. 
//
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accLocation(   long* pxLeft, long* pyTop, 
                            long* pcxWidth, long* pcyHeight, 
                            VARIANT varChild)
{
    HRESULT             hr;
    CLayout *           pLayout = NULL;
    CRect               rectElement;
    CRect               rectWnd;
    HWND                hWnd;
    CAccBase *          pAccChild = NULL;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CMarkupPointer *    pBegin = NULL;
    CMarkupPointer *    pEnd = NULL;
    CStackDataAry <RECT, 4>     aryRects( Mt(CAccElementaccLocation_aryRects_pv) );


    TraceTag((tagAcc, "CAccElement::accLocation, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // unpack varChild, and validate the child id 
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // bodies and framesets should be treated like any other element
        // get the closest layout.
        pLayout = _pElement->GetUpdatedNearestLayout();
        if ( !pLayout )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // get the region 
        pLayout->RegionFromElement( _pElement, &aryRects, &rectElement, RFE_SCREENCOORD);

        // we fall into the offset calculation code placed after the 'if'.
    }
    else 
    {
        CWindow * pWindow = GetAccWnd();

        if (!pWindow)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        pBegin = &(pWindow->_pAccWindow->_elemBegin );

        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, pBegin) );
        if ( hr ) 
            goto Cleanup;

        // If there is an accessible child, delegate the call, otherwise get the 
        // location for the text child.
        if ( pAccChild )
        {
            // call child's implementation of this method. We don't have a helper here,
            // since the CHILDID_SELF case above has all the smarts and code.
            V_I4( &varChild ) = CHILDID_SELF;

            // Delegate to the accessible child.
            hr = THR( pAccChild->accLocation( pxLeft, pyTop, 
                                              pcxWidth, pcyHeight, 
                                              varChild ) );

            // We are done here, skipping over the offset calculation
            goto Cleanup;
        }
        else        
        {
            pEnd = &(pWindow->_pAccWindow->_elemEnd );

            hr = THR( pEnd->MoveToPointer( pBegin ) );
            if ( hr ) 
                goto Cleanup;

            // move the begin pointer to where it should be
            hr = THR( pBegin->Left( TRUE, &context, (CTreeNode **) NULL, NULL, NULL, NULL ) );
            if ( hr )
                goto Cleanup;

            Assert( context == CONTEXT_TYPE_Text );

            hr = THR( _pElement->Doc()->RegionFromMarkupPointers(pBegin, 
                                                                    pEnd,
                                                                    &aryRects, 
                                                                    &rectElement,
                                                                    TRUE));
            if ( hr ) 
                goto Cleanup;
        }
    }

    // Offset calculation...

    // the window handle may come back NULL, if the window is not in place activated

    hWnd = _pElement->Doc()->GetHWND();

    if ( !hWnd )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( !GetWindowRect( hWnd, &rectWnd) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pxLeft = rectElement.left + rectWnd.left;
    *pyTop = rectElement.top + rectWnd.top;
    *pcxWidth = rectElement.right - rectElement.left;
    *pcyHeight = rectElement.bottom - rectElement.top;

    TraceTag((tagAcc, "CAccElement::accLocation, Location reported as left=%d top=%d width=%d height=%d", 
                rectElement.left + rectWnd.left,
                rectElement.top + rectWnd.top,
                rectElement.right - rectElement.left,
                rectElement.bottom - rectElement.top));

Cleanup:
    RRETURN( hr );    
}


//----------------------------------------------------------------------------
//  accNavigate
//
//  DESCRIPTION:
//      Provides navigation for the accessible children of the accessible object
//      it is called on.
//      The navigation is provided according to the schema below:
//      
//                          start=self      start = id
//      NAVDIR_NEXT     :   err                 OK
//      NAVDIR_PREV     :   err                 OK
//      NAVDIR_FIRST    :   OK                  err
//      NAVDIR_LAST     :   OK                  err
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT                 hr;
    CAccBase *              pAccChild = NULL;
    long                    lIndex = 0;
    long                    lChildIdx = 0;
    CAccElement *           pAccObj = this;


    TraceTag((tagAcc, "CAccElement::accNavigate, role=%d, start=%d, direction=%d", 
                GetRole(), 
                V_I4(&varStart),
                navDir));  

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varStart));
    if ( hr )
        goto Error;

    switch ( navDir )
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            // An acc object can only return its own first and last children.
            if ( V_I4(&varStart) != CHILDID_SELF )
            {
                hr = E_INVALIDARG;
                goto Error;
            }

            if ( navDir == NAVDIR_FIRSTCHILD )
                lIndex = 1;                 //get the first child
            else        
                lIndex = -1;                //get the last child
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_NEXT:
            // check the varStart. 
            // If the varStart is pointing to the self, then we have to delegate
            // the call to this element's accessible parent.
            // Otherwise, we have to return the child that is being asked from us.
            if ( V_I4(&varStart) == CHILDID_SELF )
            {
                 // If we are in a pane, since a window can have only one pane child
                // the navigation should fail, regardless of the direction.
                if (ROLE_SYSTEM_PANE == GetRole())
                {
                    Assert( (ETAG_BODY == _pElement->Tag())||
                            (ETAG_FRAMESET == _pElement->Tag()) );

                    hr = S_FALSE;       // no error, just no more children
                    goto Error;
                }

                // get the accessible parent element, we know for sure that the parent
                // is an element here, since we are not a pane. So casting is OK.
                hr = THR(GetAccParent(_pElement, (CAccBase **)&pAccObj));
                if (hr)
                     goto Error;

                // get the index of the element.
                hr = THR(pAccObj->GetNavChildId(navDir, _pElement, &lIndex));
                if (hr)
                    goto Error;
            }
            else
            {
                // the upper limit checks for the validity of indexes for these navdirs
                // are left to the GetChildFromID call below.
                if ( navDir == NAVDIR_PREVIOUS )
                {
                    //we can not go left from the first child
                    if ( V_I4(&varStart) == 1 )
                    {   
                        hr = S_FALSE;
                        goto Error;
                    }

                    // Get the index of the previous child
                    lIndex = V_I4(&varStart) - 1;
                }
                else    //NAVDIR_NEXT
                {
                    lIndex = V_I4(&varStart) + 1;
                }
            }
            break;

        // we don't support any other navigation commands
        default:
            hr = E_INVALIDARG;
            goto Error;
    }

    // get the child
    hr = THR( pAccObj->GetChildFromID( lIndex, &pAccChild, NULL, &lChildIdx) );
    if ( hr )
    {
        // FIRST and LAST can only return S_FALSE, if there are no children.
        // NEXT and PREVIOUS can return E_INVALIDARG, which indicates that the
        // index we passed to the function was out of limits. In that case, 
        // spec asks us to return S_FALSE, and an empty variant.
        if ( hr == E_INVALIDARG )
            hr = S_FALSE;       
            
        goto Error;
    }

    // Prepare the return value according to the type of the data received
    // Either a child id or a pointer to the accessible child to be returned.
    if ( pAccChild )
    {
        IDispatch * pDispChild;

        //the child did have an accessible object
        hr = pAccChild->QueryInterface( IID_IDispatch, (void **)&pDispChild);
        if (hr) 
            goto Cleanup;

        V_VT( pvarEndUpAt ) = VT_DISPATCH;
        V_DISPATCH( pvarEndUpAt ) = pDispChild;
    }
    else
    {
        Assert ((lIndex == -1) || (lIndex == lChildIdx));

        //return the child id
        V_VT( pvarEndUpAt ) = VT_I4;
        V_I4( pvarEndUpAt ) = lChildIdx;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
Error:
    V_VT( pvarEndUpAt ) = VT_EMPTY;
    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  accHitTest()
//  
//  DESCRIPTION :   Since the window already have checked the coordinates
//                  and decided that the document contains the point, this
//                  function does not do any point checking. 
//                  
//  PARAMETERS  :
//      xLeft, yTop         :   (x,y) coordinates 
//      pvarChildAtPoint    :   VARIANT pointer to receive the acc. obj.
//
//  RETURNS:    
//      S_OK | E_INVALIDARG | 
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    HRESULT         hr = E_FAIL;
    CTreeNode *     pElemNode = NULL;
    CTreeNode *     pHitNode = NULL;
    CTreeNode *     pTreeWalker = NULL;
    CTreeNode *     pLastSupported = NULL;
    CAccBase  *     pAccObj = NULL;
    ELEMENT_TAG     elementTag;

    POINT       pt = {xLeft, yTop};
    HTC         htc;
    CMessage    msg;

    TraceTag((tagAcc, "CAccElement::accHitTest, role=%d", GetRole()));  

    if ( !pvarChildAtPoint )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    V_VT( pvarChildAtPoint ) = VT_EMPTY;
    V_I4( pvarChildAtPoint ) = 0;
    
    //get this element's node
    pElemNode = GetElement()->GetFirstBranch();
    if ( !pElemNode )
        goto Cleanup;       //the node was not in the tree.

    // make sure that the window that contains the document is in-place
    // activated.
    if ( !GetElement()->Doc()->GetHWND() )
        goto Cleanup;   //the document is not inplace activated

    //convert the (x,y) coordinates that we receive to client coordinates
    if ( !ScreenToClient( GetElement()->Doc()->GetHWND(), &pt) )
        goto Cleanup;
    
    msg.pt = pt;

    // Get the node that got the hit
    htc = GetElement()->Doc()->HitTestPoint( &msg, &pHitNode, HT_VIRTUALHITTEST);

    // if the hit node is in a slave tree, we have to get to the master tree
    // and the master tree element,
    // the view links are to be handled differently.
    if (pHitNode->Element()->HasMasterPtr())
    {
        CElement * pElemMaster = pHitNode->Element()->GetMasterPtr();

        // For Trident V3, only identity behaviors can have view links,
        // and identity behaviors can only be attached to custom tags.
        // If the master does not have an identity peer holder, it can
        // not be a view link, so it has to be an intrinsics control.
        // Otherwise, it is a view link we are dealing with.
        if (!pElemMaster->HasIdentityPeerHolder())
        {
            pHitNode = pElemMaster->GetFirstBranch();
        }
        else
        {
            // we some how hit the top level node on a viewlink markup
            // what do we return now?
            Assert(0);
        }
    }

    // Is there a tree built and ready?
    if ( pHitNode->Tag() == ETAG_ROOT )
        goto Cleanup;

    if (GetElement()->Tag() ==ETAG_IMG )
    {
        pHitNode->Element()->SubDivisionFromPt(msg.ptContent, 
                                               &msg.lSubDivision);

        // We are an area was hit so just return it.  if there is an error
        // bail and fall through to return the img
        hr = HitTestArea(&msg, pHitNode, pvarChildAtPoint);
        if (SUCCEEDED( hr ))
            goto Cleanup;
    }

    hr = S_OK;                              //Reset the return value

    // If the point was not inside of this document, return VT_EMPTY
    if ( htc == HTC_NO )
    {
        V_VT( pvarChildAtPoint ) = VT_EMPTY;       
        goto Cleanup;
    }
   
    // if we have already on the node that this object's element is connected, then
    // move on to child calculation part
    //
    // Compare elements instaad of nodes, to avoid problems with overlapping
    //
    // stert from the node that got hit, move up until you find a supported element
    // that is an immediage acc. child of this acc. object.
    pTreeWalker = pHitNode;

    if ( pHitNode->Element() != GetElement())
    {
        CMarkup *   pMarkupElement = _pElement->GetMarkupPtr();

        if (pMarkupElement == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        long        lElementIndex = _pElement->GetSourceIndex();
        long        lWalkerIndex = 0;

        do
        {
            // if the parent node is a suported element's node, move the 
            // hit node to that node. 
            // In the case that we are hittesting an element behavior, if there
            // is already a last supported element, then we may need to return that. 
            // However, if we change the last supported to the element client of the 
            // behavior's slave markup, we lose that information. So, we only update 
            // the last supported node information if there was not already a supported
            // element found in the hit test route within the slave markup.
            if ( IsSupportedElement( pTreeWalker->Element()) )
            {
                // If this is not an element behavior, just update.
                // If it is an element behavior, only update if we don't have 
                // a last supported element.
                if (!_pElement->HasIdentityPeerHolder() || !pLastSupported)
                {
                    pLastSupported = pTreeWalker;
                }
            }

            // Walk up the tree
            pTreeWalker = pTreeWalker->Parent();

            // if we hit the root, then climb up to the next markup that contains us.
            if (pTreeWalker->Tag() == ETAG_ROOT)
            {
                if (pTreeWalker->Element()->HasMasterPtr())
                {
                    pTreeWalker = pTreeWalker->Element()->GetMasterPtr()->GetFirstBranch();
                }
                else
                    break;      // we have hit the root on a non-viewlink markup, hit should be out of scope
            }
           
            lWalkerIndex = pTreeWalker->Element()->GetSourceIndex();
        }
        while ( (pTreeWalker->Element() != _pElement) &&                // hit is on us
                ((pMarkupElement != pTreeWalker->GetMarkup()) ||        // If we are in the same markup, then we should
                 (lWalkerIndex >= lElementIndex)));                     // be checking an element that has a larger source index...
    }
    // else they are equal, drop to the last else case below

    if ( pTreeWalker->Tag() == ETAG_ROOT ||
                ((pTreeWalker->GetMarkup() ==  _pElement->GetMarkup()) && 
                 (pTreeWalker->Element()->GetSourceIndex() < _pElement->GetSourceIndex()))) 
    {
        // this case means the hit was OUTSIDE of our scope 
        V_VT( pvarChildAtPoint ) = VT_EMPTY;       
        goto Cleanup;
    }
    else if (pLastSupported && (pLastSupported->Element() != GetElement()) )
    {
        // hit in our scope, and the hit is on a supported child
        // return this child 

        pAccObj = GetAccObjOfElement( pLastSupported->Element() );
        if ( !pAccObj )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        V_VT( pvarChildAtPoint )  = VT_DISPATCH;
        V_DISPATCH( pvarChildAtPoint ) = pAccObj;

        pAccObj->AddRef();

    }
    
    if (!pAccObj)
    {
        // hit in our scope, and the hit is on a text node
        // or the hit was on us directly
        //
        // If there were no supported elements below us, we have to find the child id
        // from the current element
        if ( !pLastSupported )
            pLastSupported = pElemNode;

        // We have to return ourselves as the acc object if we are
        // connected to a noscope tag, since it can not have any
        // text content.
        // buttons need to be handled here, even though they can contain
        //   html.  This is primarily due to proxy compat.
        // Also if the hit was not on any content, the cp comes back -1
        // and that requires us to return CHILDID_SELF for the acc object.
        elementTag = pLastSupported->Tag();
    
        if ( !CanHaveChildren()              ||  // can not have children
            (msg.resultsHitTest._cpHit < 0 ) ||  // 
            msg.resultsHitTest._fWantArrow   )   // arrow means we are not on text
        {
            V_VT( pvarChildAtPoint )  = VT_I4;
            V_I4 ( pvarChildAtPoint ) = CHILDID_SELF;
            goto Cleanup;
        }

        // We know for a fact now, that the element that is represented
        // by this acc object was hit, and the hit was on content.
        // We should now find the child that was hit.

        // since this element can have children, we have to find out
        // which one of its children the pointer was on.
        // we can return with the information we get from this 
        // function, since it will fill the VARIANT for us.
        //
        hr = THR( GetHitChildID( GetElement(), &msg, pvarChildAtPoint) );
    }


Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//  Does different things per tag:
//      The implementation for the tags OBJECT/EMBED and PLUGIN is in the 
//      AccObject class implementation.
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accDoDefaultAction(VARIANT varChild)
{   
    HRESULT     hr;
    CAccBase *  pParent = NULL;
    CAccBase *  pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::accDoDefaultAction, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        switch ( GetElement()->Tag() )
        {
            case ETAG_INPUT:
                switch( DYNCAST(CInput, GetElement())->GetAAtype())
                {
                    case htmlInputButton:
                    case htmlInputReset:
                    case htmlInputCheckbox:
                    case htmlInputImage:
                    case htmlInputRadio:
                    case htmlInputSubmit:
                    case htmlInputFile:
                        hr = THR( ScrollIn_Focus_Click( GetElement() ) );
                        break;

                    case htmlInputPassword: //E_NOTIMPL.
                    case htmlInputText:
                    case htmlInputTextarea:
                        hr = E_NOTIMPL;
                        break;
                }
                break;

            case ETAG_SELECT:
            case ETAG_BUTTON:
            case ETAG_A:
            case ETAG_AREA:
                hr = THR( ScrollIn_Focus_Click( GetElement() ) );
                break;
          
            case ETAG_FRAMESET:
            case ETAG_BODY:
            case ETAG_MARQUEE:
            case ETAG_TABLE:
            case ETAG_TD:
            case ETAG_TH:
                hr = E_NOTIMPL;
                break;

            case ETAG_IMG:  //if your acc.parent is anchor, ask your parent
            default:        //text nodes and IMG are the same
//
// TODO: - what if anchor around table around image???  is sniffing 1 level enough (ferhane)
//
                hr = THR( GetAccParent( GetElement(), &pParent ));
                if ( hr )
                    break;

                Assert( pParent );

                //there is no need to change varChild, since it
                //contains the CHILDID_SELF anyway...
                hr = THR( pParent->accDoDefaultAction(varChild) );
                break;
        }
    }
    else 
    {
        // find that object and call its API implementation, passing 
        // CHILDID_SELF as the child information.
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the text is inside an anchor, then the 
            //anchor behavior is used.
            if ( GetElement()->Tag() == ETAG_A )
            {
                hr = THR( ScrollIn_Focus_Click( GetElement() ) );
            }
            else
            {
                //no default action for plain text.
                hr = E_NOTIMPL;
            }
        }
        else 
        {
            // call child's implementation of this method. We don't have a helper for this
            // method, since the CHILDID_SELF case above has all the smarts and code.
            V_VT( &varChild ) = VT_I4;
            V_I4( &varChild ) = CHILDID_SELF;

            hr = THR( pAccChild->accDoDefaultAction( varChild ) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  put_accValue
//  
//  DESCRIPTION :   
//          Sets the value property of the accessible object. Only the edit box
//          and password accessible objects support this method, all others 
//          return an error.
//          
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      pbstrValue   :   value bstr
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    // validate parameter
    if ( !bstrValue )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's implementation
        hr = THR( PutAccValue(bstrValue) );
    }
    else
    {
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( pAccChild )
        {
            V_I4( &varChild ) = CHILDID_SELF;
            
            //call child's implementation
            hr = THR( pAccChild->put_accValue( varChild, bstrValue) );
        }
        else 
            hr = E_NOTIMPL;
    }

Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//  GetChildFromID()
//
//  DESCRIPTION:
//      Return the child object that is indicated with the child id that is 
//      passed.
//      The object returned is either a CElement pointer or a CMarkupPointer 
//      pointer.
//      If the child refers to a text block, a CMarkupPointer * is placed
//      after the text block and returned.
//      If the child refers to a tag that is supported ( determined by calling
//      the IsSupportedElement() helper from inside AccStepRight() ) then a
//      pointer to the CElement is returned. 
//      The accessible object decides how to use the information.
//      
//  
//  PARAMETERS:
//      lChildId    :   ID of the child that is being asked for. If this parameter
//                      is (-1) then the last accessible child of this element is 
//                      returned.
//      plType      :   Address of the long to receive the child type.
//                      Valid child types are the members of the childType
//                      enumeration in the CAccElement class
//      ppAccChild  :   Address of the pointer to receive the accessible child
//                      object. The parameter can be NULL, indicating that the caller
//                      does not want it.
//      ppMarkupPtr :   Address (CMarkupPointer *) variable. The parameter
//                      can be NULL, indicating that the caller does not want it
//      plChildCnt  :   The address of the variable to receive the ID of this child.
//                      Using this parameter, the caller can both determine the total
//                      number of children and get the last one at the same time. The
//                      parameter is optional and defaults to NULL.
//----------------------------------------------------------------------------
HRESULT
CAccElement::GetChildFromID(    long                lChildId, 
                                CAccBase **         ppAccChild, 
                                CMarkupPointer *    pMarkupPtrBegin,
                                long *              plChildCnt /*= NULL */)
{
    HRESULT             hr= S_OK;
    CMarkupPointer *    pelemBegin = NULL;
    CMarkupPointer *    pelemEnd = NULL;
    CTreeNode *         pElemNode = NULL;
    long                lChildCnt =0;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CWindow *           pWindow = GetAccWnd();

    //if the lChildId is <0 then go till the end of the scope
    BOOL                bGotoTheEnd = (lChildId < 0) ? TRUE : FALSE; 

    // we should never pass in CHILDID_SELF to this method.
    Assert( lChildId != 0 );

    if ( ppAccChild )
        *ppAccChild = NULL;

    // if the element is not in a markup, we are hosed.
    if (!GetElement()->HasMarkupPtr())
    {
        hr = E_FAIL;
        
        if (plChildCnt)
            *plChildCnt = NULL;

        goto Cleanup;
    }

    if (!pWindow)       // could not get an accwnd.
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // CAUTION CAUTION CAUTION ! ! !
    //          This function uses the markup pointer that is passed in as a parameter
    //          to walk on the HTML stream using the tree services core functions.
    //          There are two cached CMarkupPointer instances on the CAccWindow to 
    //          avoid the constant create/destroy of these pointers. This function uses
    //          the _elemEnd to mark the end of the element, so it can determine when
    //          to stop. 
    //          The pointer that is passed in MUST NOT BE the end pointer, since that
    //          would cause immediate satisfaction of condition in the <while> below
    //          and return the wrong child.
    //          Hence the assert. (ferhane)
    AssertSz( pWindow->_pAccWindow && pMarkupPtrBegin != &( pWindow->_pAccWindow->_elemEnd ), 
                            "The markup pointer this function relies on being static is passed in as volatile. BUG!");

    if (GetElement()->Tag() == ETAG_IMAGE)
    {
        CImgElement *pImg = DYNCAST(CImgElement, GetElement());

        // handle areas under an image. in this case the childID is the 
        // subdivision of the image as a 1 based index.
        if (pImg && pImg->EnsureAndGetMap())
        {
            CAreaElement *  pArea = NULL;

            IGNORE_HR(pImg->GetMap()->GetAreaContaining(lChildId-1, 
                                                        &pArea));
            if (pArea)
            {
                *ppAccChild = GetAccObjOfElement( pArea );
                lChildCnt = lChildId;
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

    if ( !CanHaveChildren() )
        return S_FALSE;             // No Children

    // Either use my local markup pointer, or the one I'm handed.
    // This is the pointer to be moved around in the markup stream
    if ( pMarkupPtrBegin )
    {
        pelemBegin = pMarkupPtrBegin;
    }
    else
    {
        pelemBegin = &( pWindow->_pAccWindow->_elemBegin );
    }

    // did we have a cached child, and is the cache still valid? 
    if ( IsCacheValid() && ( lChildId >= _lLastChild ) )
    {
        // move the beginning pointer to where the cached pointer is
        pelemBegin->MoveToPointer( &_lastChild );

        // set the current child count to the current index
        lChildCnt = _lLastChild;

        // if we are accessing the same child, just get the context information
        // and return.
        if ( lChildId == _lLastChild )
        {
            // Check left to see what the last child was
            hr = THR( pelemBegin->Left( FALSE, &context, &pElemNode, NULL, NULL, NULL) );
            if ( hr ) 
                goto Cleanup;

            // we have the context and pElemNode values, go to return routine...
            goto Return;
        }
    }
    else
    {
        // the cache was not valid, reset variables.

        _lLastChild = 0;   // invalidate the cache.
        _lTreeVersion = 0;
    }

    // if the last child is zero, either we reset it above, or there was no cache.
    // either way, we have to start from the very beginning.
    if ( _lLastChild == 0 )
    {
        // mark the beginning of the element
        hr = THR( pelemBegin->MoveAdjacentToElement( GetElement(), ELEM_ADJ_AfterBegin));
        if (hr)
            goto Cleanup;
    }

    // set the end markup pointer to the end of the element, so
    // that we can stop.
    pelemEnd = &(pWindow->_pAccWindow->_elemEnd);

    hr = THR( pelemEnd->MoveAdjacentToElement( GetElement(), ELEM_ADJ_BeforeEnd));
    if ( hr )
        goto Cleanup;

    //now, start walking to the right, until you hit child that is being 
    //asked, or the end of the scope for this element
    while ( bGotoTheEnd || ( lChildCnt < lChildId ) )
    {
        // we have reached the end of the scope of this element. If we have
        // the bGotoTheEnd set to TRUE, then we actually want the last child
        // which we just jumped over. 
        // Otherwise we have reached here without finding the child id that 
        // was passed and the child id is invalid
        if ( pelemBegin->IsEqualTo( pelemEnd ) )
        {
            // If the last child was being asked, there is nothing wrong,
            // break out and continue.
            if ( bGotoTheEnd )
                break;
            else
            {
                //[FerhanE]
                // Different from the proxy, we return E_INVALIDARG for all child
                // needing calls if we don't have a child. That is the same return
                // code we return if we have an invalid child id.
                if (lChildCnt)
                {
                    // there were children counted, so a bad value must have been passed in
                    hr = E_INVALIDARG;
                }
                else
                {
                    // return ourselves. since no children were counted, and we left
                    // our scope. This can happen hittesting and Iframe.
                    *ppAccChild= this;
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }

        //Take us out if the index was invalid or there were no children.
        if ( hr )               
            goto Cleanup;


        //get what is to our right
        hr = THR( pelemBegin->Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));
        if ( hr )
            goto Cleanup;

        switch ( context )
        {
#if DBG==1            
            case CONTEXT_TYPE_None:     
                //if there was nothing on this side at all,
                AssertSz(FALSE, "We have hit the root..");
                break;

            case CONTEXT_TYPE_ExitScope://don't care ...
                break;
#endif

            case CONTEXT_TYPE_EnterScope:
                //check the element to see if it is a supported element
                if ( IsSupportedElement( pElemNode->Element() ) )
                {
                    //go to the end of this element, since we will handle it as a container
                    hr = THR( pelemBegin->MoveAdjacentToElement( pElemNode->Element(), ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    lChildCnt++;      
                }
                //don't do anything if it is not a supported element.
                break;  
            
            //we jumped over text or noscope
            case CONTEXT_TYPE_NoScope:
                if ( !IsSupportedElement( pElemNode->Element() ))
                    break;
            
            case CONTEXT_TYPE_Text:
                lChildCnt++;
                break;
        }
    }

    // if we don't have any children
    // we better leave before reaching here, 
    Assert( lChildCnt );

    // place the cache pointer to where the walker is
    hr = THR( _lastChild.MoveToPointer( pelemBegin ) );
    if ( hr )
        goto Cleanup;                

Return:
    //if the block was a text block, we return the markup pointer
    //otherwise return the acc object for the element that we passed over.
    if ((( context == CONTEXT_TYPE_EnterScope ) || 
              ( context == CONTEXT_TYPE_NoScope    ) ||
              ( context == CONTEXT_TYPE_ExitScope )) && 
             ( ppAccChild ))
    {
        
        // if the element is a supported element, return the element,
        // however, if the call was for a last child, the last tag
        // may belong to a non-supported element.
        if (bGotoTheEnd && !IsSupportedElement(pElemNode->Element()))
        {
            context = CONTEXT_TYPE_None;

            // until we find an element 
            while ((context != CONTEXT_TYPE_Text) && 
                    !IsSupportedElement(pElemNode->Element()))
            {
                // we use the _lastChild, since we also want to be able to preserve the
                // location in case we return text.
                hr = THR( _lastChild.Left( TRUE, &context, &pElemNode, NULL, NULL, NULL));
                if (hr)
                    goto Cleanup;
            }

            // reverse the last move, so that we are pointing to the end of the last child
            hr = THR( _lastChild.Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));
            if (hr)
                goto Cleanup;

            if (context == CONTEXT_TYPE_Text)
                goto Cleanup;
        }
 
        //get the accessible object for that element.
        *ppAccChild = GetAccObjOfElement( pElemNode->Element() );
        if ( !(*ppAccChild))
            hr = E_OUTOFMEMORY;
    }
    
Cleanup:
    //set the return child count.
    if ( plChildCnt && !hr )
        *plChildCnt = lChildCnt;

    // invalidate the cache if there was an error.
    if ( hr )
    {
        _lLastChild = 0;
        _lTreeVersion = 0;
    }
    else
    {
        _lTreeVersion = GetElement()->GetMarkupPtr()->GetMarkupTreeVersion();
        _lLastChild = lChildCnt;                       // last child we accessed.
    }
   
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  GetLabelText
//-----------------------------------------------------------------------
HRESULT
CAccElement::GetLabelText( BSTR * pbstrOutput)
{
    HRESULT hr = S_OK;

    //get the associated label element if there is one
    CLabelElement * pLabel = GetLabelElement();

    if( pLabel)
    {
        hr = THR( pLabel->get_innerText( pbstrOutput ) );

        // If the user explicitly wanted to have a label with no text then
        // we should honor it. 
        // But for backward (IE4.01) compatability we need to test the length
        if (!SysStringLen(*pbstrOutput))
        {
            SysFreeString(*pbstrOutput);
            *pbstrOutput = NULL;
        }
    }

    RRETURN(hr);
}

//-----------------------------------------------------------------------
//  GetLabelOrTitle
//-----------------------------------------------------------------------
HRESULT 
CAccElement::GetLabelorTitle( BSTR* pbstrOutput )
{
    HRESULT         hr=S_OK;

    if (!pbstrOutput)
        return S_FALSE;

    *pbstrOutput = NULL;

    hr = GetLabelText(pbstrOutput);
    if (hr)
        goto Cleanup;

    if (!*pbstrOutput)
    {
        //get the title for the checkbox
        hr = GetTitle(pbstrOutput);
        if (FAILED(hr) || !*pbstrOutput)
            hr = E_NOTIMPL;
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//-----------------------------------------------------------------------
//  GetTitleorLabel
//-----------------------------------------------------------------------
HRESULT 
CAccElement::GetTitleorLabel( BSTR* pbstrOutput )
{
    HRESULT         hr=S_OK;

    Assert(pbstrOutput);

    //get the title for the checkbox
    hr = GetTitle(pbstrOutput);
    if (hr || !*pbstrOutput)
    {
        hr = GetLabelText(pbstrOutput);
    }

    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  GetTitle
//-----------------------------------------------------------------------
HRESULT
CAccElement::GetTitle( BSTR* pbstrOutput )
{
    HRESULT hr = S_OK;
    TCHAR* pchString=NULL;

    Assert(pbstrOutput);
    Assert(!*pbstrOutput);

    //get the title 
    pchString = (LPTSTR) GetElement()->GetAAtitle();
    if ( pchString )
    {
        *pbstrOutput = SysAllocString( pchString );
        if ( !(*pbstrOutput) )
            hr = E_OUTOFMEMORY;
    }
    else
        hr = S_FALSE;

    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  HasLabel - this helper function is necessaryt to support the accDescription
//      methods.  The way that description works is that it returns what
//      the name doesn't.  So if there is a label, accName returns it and 
//      accDesc shoule return the title.  If there is no label, then accName 
//      returns the title and accDescription is left returning nothing.
//          the wrinkle in this is that there not only has to be a label but
//      the label needs to actually have text . i.e. <label for=idFoo></label>
//      doesn't count.
//-----------------------------------------------------------------------
BOOL
CAccElement::HasLabel()
{
    BSTR            bstrOutput = NULL;
    CLabelElement * pLabel;
    BOOL            fRet = FALSE;

    pLabel = GetLabelElement();

    if (!pLabel)
        goto Cleanup;

    if (FAILED( pLabel->get_innerText( &bstrOutput ) ))
        goto Cleanup;

    if (bstrOutput)
    {
        fRet = !!SysStringLen(bstrOutput);

        SysFreeString(bstrOutput);
    }

Cleanup:
    return fRet;
}

//+-------------------------------------------------------------------------
//
// HitTestArea - helper function for accHitTest.  This is called when an
//  image with a map is hittested over an area (subdivision).  its job is 
//  to return the accElemetn of hte area that was hit.
//
//---------------------------------------------------------------------------
HRESULT
CAccElement::HitTestArea(CMessage *pMsg,    
                         CTreeNode *pHitNode,
                         VARIANT * pvarChildAtPoint)
{
    HRESULT      hr = E_FAIL;
    CImgElement *pImg = DYNCAST(CImgElement, pHitNode->Element());

    Assert(pvarChildAtPoint && V_VT(pvarChildAtPoint)==VT_EMPTY);

    if (pImg && pImg->GetMap())
    {
        CAreaElement *  pArea = NULL;

        IGNORE_HR(pImg->GetMap()->GetAreaContaining(pMsg->lSubDivision, 
                                                    &pArea));
        if (pArea)
        {
            CAccBase  *pAccObj = GetAccObjOfElement( pArea );
            if ( pAccObj )
            {
                V_VT( pvarChildAtPoint )  = VT_DISPATCH;
                V_DISPATCH( pvarChildAtPoint ) = pAccObj;
    
                pAccObj->AddRef();
    
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//+----------------------------------------------------
//
//  GetAnchorParent() - helper function that walks up the 
//      accesssible parent chain looking to see if there is
//      an anchor in scope above us.  If there is return it
//      so that it's properties can be used.  If there isn't
//      return NULL
//
//-----------------------------------------------------
CAccBase *
CAccElement::GetParentAnchor()
{
    CAccBase * pParent = NULL;
    CAccBase * pCurrent = this;
    BOOL       fDone = FALSE;

    while (!fDone && pCurrent)
    {
        if (S_OK != GetAccParent( pCurrent->GetElement(), &pParent ) )
        {
            fDone = TRUE;
            pParent = NULL;
        }
        else 
        {
            Assert( pParent);

            if (pParent->GetElement())
            {
                switch ( pParent->GetElement()->Tag())
                {
                case ETAG_A:
                    // bingo, retun this puppy
                    fDone = TRUE;
                    break;

                case ETAG_TABLE:
                case ETAG_TD:
                case ETAG_TH:
                case ETAG_BODY:
                    // anchors don't propogate through tables.
                    // ..and other good stopping criteria
                    pParent = NULL;
                    fDone = TRUE;
                    break;

                }
                pCurrent = pParent;
            }
            else
            {
                // we have hit a frame or a viewlink boundary...
                pParent = NULL;
                fDone = TRUE;
            }
        }
    }

    return pParent;
}



//+------------------------------------------------------
//
//   BOOL fBrowserWindowHasFocus() - 
//  Another helper function for determining when we can
//  specify the STATE_SYSTEM_SELECTABLE for text.  For
//  proxy compatablity this is when the forground focus
//  window is ours.
//-------------------------------------------------------
BOOL
CAccElement::fBrowserWindowHasFocus()
{
    HWND hwndCurrent = GetElement()->Doc()->GetHWND();
    HWND hwndTarget = GetForegroundWindow();

    while(hwndCurrent)
    {
        if(hwndTarget == hwndCurrent)
            break;
    
        hwndCurrent = ::GetParent(hwndCurrent);
    }

    //--------------------------------------------------
    // no focused window means that neither this 
    // window or any of its parent chain has the focus.
    // **NOTE** this handles uninitialized frames also.
    //--------------------------------------------------
    return !! hwndCurrent;
}

//+---------------------------------------------------------------------------
//  GetSelectedChildren
//  
//  DESCRIPTION: Returns accessible children that reside between two markup 
//          pointers. 
//          bForceEnumerator flag is used to force creation of an IEnumVariant 
//          implementation. If the flag is FALSE, and there is only one child
//          then the only child is returned in the return variant. Otherwise
//          the return variant contains the IEnumVariant pointer.
//          cChildBase contains the offset child id, for the child that starts
//          at the location marked with pStart. This is needed for text children.
//  
//  PARAMETERS:
//      cChildBase          :   Child id offset
//      pStart              :   Starting point within the markup
//      pEnd                :   Ending point within the markup
//      pvarSelectedChildren:   Return variant that receives a child or enumeration
//      bForceEnumerator    :   If TRUE, an enumerator is created even if there 
//                              is only one child in the markup region.
//
//----------------------------------------------------------------------------
HRESULT
CAccElement::GetSelectedChildren(   long cChildBase, 
                                    CMarkupPointer *pStart, 
                                    CMarkupPointer * pEnd, 
                                    VARIANT * pvarSelectedChildren,
                                    BOOL    bForceEnumerator )
{
    HRESULT                     hr = S_OK;
    long                        lCounter = 0;
    long                        lOldCounter = 0;
    CTreeNode *                 pElemNode = NULL;
    VARIANT                     varCurrent;
    MARKUP_CONTEXT_TYPE         context;
    CAccBase *                  pAccChild = NULL;
    CDataAry <VARIANT> *        pary = NULL;

    Assert( pStart );
    Assert( pEnd );
    Assert( pvarSelectedChildren );
    
    varCurrent.vt = VT_EMPTY;
    varCurrent.lVal = 0;

    pary = new(Mt(CAccElementget_accSelection_aryVariants_pv)) 
                        CDataAry<VARIANT>(Mt(CAccElementget_accSelection_aryVariants_pv));
    if ( !pary )
        RRETURN( E_OUTOFMEMORY );

    // Until the start pointer reaches or passes the end location
    while ( pStart->IsLeftOf( pEnd )  )
    {
        hr = THR( pStart->Right( TRUE, &context, &pElemNode, 
                                            NULL, NULL, NULL));
        if ( hr )
            goto Cleanup;

        switch ( context )
        {
#if DBG==1            
            case CONTEXT_TYPE_None:     
                //if there was nothing on this side at all,
                AssertSz(FALSE, "We have hit the root..");
                break;
            case CONTEXT_TYPE_ExitScope://don't care ...
                break;
#endif
            case CONTEXT_TYPE_EnterScope:
                Assert( pElemNode );
                
                // check the element to see if it is a supported element
                if ( IsSupportedElement( pElemNode->Element() ) )
                {
                    // go to the end of this element, 
                    // since we will handle it as a container
                    hr = THR( pStart->MoveAdjacentToElement( pElemNode->Element(), 
                                                                ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    lCounter++;
                }
                //don't do anything if it is not a supported element.
                break;  
                
            //we jumped over text or noscope
            case CONTEXT_TYPE_NoScope:
                Assert( pElemNode );
                if ( !IsSupportedElement( pElemNode->Element() ))
                    break;
                //else 
                //  fall through to increment the counter.
                
            case CONTEXT_TYPE_Text:
                lCounter++;      
                break;
        }

        // if we passed a valid accessible child, then the counter must have been incremented
        if ( lOldCounter != lCounter )
        {
            VariantInit( &varCurrent );
            
            if ( context == CONTEXT_TYPE_Text )
            {   
                V_VT( &varCurrent ) = VT_I4;
                V_I4( &varCurrent ) = lCounter + cChildBase;
            }
            else
            {
                IDispatch * pDispTmp;

                V_VT( &varCurrent ) = VT_DISPATCH;

                pAccChild = GetAccObjOfElement( pElemNode->Element() );
                if ( !pAccChild )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                // increment the ref count and do the casting at the same time.
                hr = THR( pAccChild->QueryInterface( IID_IDispatch, (void**)&pDispTmp));
                if ( hr )
                    goto Cleanup;
                    
                Assert( pDispTmp );

                V_DISPATCH( &varCurrent ) = pDispTmp;
            }

            //append the record to the list, and reset the variant
            hr = THR(pary->EnsureSize(lCounter));
            if (hr)
                goto Cleanup;

            // no need to addref the variant's IDispatch content, since we will dispose 
            // of the varCurrent's contents. AddRef is done above with the QI call.
            hr = THR( pary->AppendIndirect( &varCurrent, NULL ) );
            if ( hr )
                goto Cleanup;

            // reset the check condition.
            lOldCounter = lCounter;
        }
    }
    if ( bForceEnumerator  || (lCounter > 1 ) )   
    {
        // create the enumerator using the CDataAry contents and return the 
        // IEnumVariant * in the return VARIANT.
        hr = THR(pary->EnumVARIANT(VT_VARIANT, 
                                    (IEnumVARIANT **) &V_DISPATCH(pvarSelectedChildren), 
                                    FALSE,  // don't copy the array being enumerated use the one we gave
                                    TRUE)); // delete enumeration when no one is left to use .
        if (hr)
            goto Cleanup;

        V_VT( pvarSelectedChildren ) = VT_DISPATCH;
        
        //we don't delete the pary, since its contents are being used by the enumerator...!
        pary = NULL;
    }
    else if ( lCounter == 1 )
    {
        // we copy ourselves, and not use VariantCopy, since the value is already
        // addref ed if it is a dispatch ptr.
        memcpy( pvarSelectedChildren, &varCurrent, sizeof(VARIANT));
    }
    else    //no children, and bForceEnumerator is FALSE, return VT_EMPTY.
    {
        V_VT( pvarSelectedChildren ) = VT_EMPTY;
    }

Cleanup:
    delete  pary;
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetEnumerator
//
//  DESCRIPTION:
//      Create and return a pointer to the enumerator object for this 
//----------------------------------------------------------------------------
HRESULT 
CAccElement::GetEnumerator( IEnumVARIANT ** ppEnum)
{
    HRESULT             hr;
    CMarkupPointer      markupStart( GetElement()->Doc() );
    CMarkupPointer      markupEnd( GetElement()->Doc() );
    VARIANT             varResult;

    // only called internally.
    Assert( ppEnum );

    *ppEnum = NULL;

    // get the limits for the element 
    hr = THR( GetMarkupLimits( GetElement(), &markupStart, &markupEnd ) );
    if ( hr )
        goto Cleanup;    

    // get an array of children of this element.
    // Even if there are no children, varResult contains the enumerator, 
    // since we pass TRUE for the last parameter( bForceEnumerator )
    hr = THR( GetSelectedChildren( 0, &markupStart, &markupEnd, &varResult, TRUE ) );
    if ( hr )
        goto Cleanup;

    // We've got to receive an enumerator here.
    Assert( V_VT(&varResult) == VT_DISPATCH );

    // return the enumerator object.
    *ppEnum = (IEnumVARIANT *)V_DISPATCH( &varResult );
    
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetLabelParent
//  
//  DESCRIPTION:
//      REturns the CLabelElement parent for the element this accessible object
//      is associated with. 
//
//      Return value can be NULL.
//----------------------------------------------------------------------------
CLabelElement *
CAccElement::GetLabelElement()
{
    CTreeNode * pNode;
    CLabelElement * pLabel = GetElement()->GetLabel();

    // does this element have a label associated with it.
    // if so, return it.
    if (pLabel)
        goto Cleanup;

    // may be the element does not have a label associated
    // but is wrapped with one.
    pNode = GetElement()->GetFirstBranch();

    if ( !pNode || pNode->IsDead() )
        goto Cleanup;

    pNode = pNode->Parent();

    // if we have a parent, then check if it is actually 
    // a label element,
    if (pNode && (pNode->Tag() == ETAG_LABEL) )
        pLabel = DYNCAST( CLabelElement, pNode->Element());

Cleanup:
    return pLabel;
}


BOOL 
CAccElement::IsVisibleRect( CRect * pRectRegion )
{
    HRESULT     hr;
    CElement *  pElemClient;
    long        clientWidth;
    long        clientHeight;

    Assert(GetElement()->HasMarkupPtr());

    // get the document's primary element client and ask it where its scroll
    // positions are.
    pElemClient = CMarkup::GetElementClientHelper(GetElement()->GetMarkupPtr());

    // if there is no primary element client, NOT VISIBLE
    if (!pElemClient)
        goto Invisible;

    hr = THR(pElemClient->get_clientWidth(&clientWidth));
    if (hr)
        goto Visible;

    hr = THR(pElemClient->get_clientHeight(&clientHeight));
    if (hr)
        goto Visible;

    // if the bounding rectangle of the text is containing the scroll area, 
    // or it has one of its corners inside it, the text is visible.
    // it is easier to check the invisible condition
    if ((pRectRegion->left > clientWidth) || 
        (pRectRegion->top > clientHeight) ||
        (pRectRegion->bottom < 0) ||
        (pRectRegion->right < 0) )
        goto Invisible;

Visible:
    return TRUE;
Invisible:
    return FALSE;
}

//+---------------------------------------------------------------------------
//  IsTextVisible
//
//----------------------------------------------------------------------------
BOOL
CAccElement::IsTextVisible(CMarkupPointer * pTextBegin, CMarkupPointer * pTextEnd)
{
    HRESULT             hr;
    CTreeNode *         pParentNode;
    CStackDataAry <RECT,4>     aryRects( Mt(CAccElementaccLocation_aryRects_pv) );
    CRect               rectRegion;
    CDoc *              pDoc = GetElement()->Doc();

    //get the closest HTML element parent 
    pParentNode = pTextEnd->CurrentScope(MPTR_SHOWSLAVE);

    if (pParentNode)
    {
        // if the parent element is not visible, then it does not matter if we 
        // are in the view or not.
        if (!pParentNode->Element()->IsVisible(TRUE))
            goto Cleanup;

        // is the text inside the client window coordinates
        hr = THR( pDoc->RegionFromMarkupPointers( pTextBegin, 
                                                    pTextEnd,
                                                    &aryRects, 
                                                    &rectRegion ));

        if ( hr || IsVisibleRect(&rectRegion))
            return TRUE;
    }

Cleanup:
    return FALSE;
}

//----------------------------------------------------------------------------
//  Function    :   GetNavChildId
//  Description :   Given a child element of this element, returns the index
//                  of its sibling in the direction indicated by the navigation
//                  direction parameter.
//----------------------------------------------------------------------------
HRESULT
CAccElement::GetNavChildId( long navDir, CElement * pChildElement, long * pChildId)
{
    HRESULT             hr;
    CMarkupPointer *    pBegin;
    CMarkupPointer *    pEnd;
    long                lChildId = 0;
    long                lCachedChildId = 0;
    long                lIndex = 0;

    CWindow * pWindow = GetAccWnd();
    
    if (!pWindow)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pBegin = &( pWindow->_pAccWindow->_elemBegin );
    pEnd = &( pWindow->_pAccWindow->_elemEnd );
    
    // place a markup pointer before the beginning of the child element
    hr = THR( pEnd->MoveAdjacentToElement(pChildElement, ELEM_ADJ_BeforeBegin) );
    if (hr)
        goto Cleanup;
 
    // if there is a cached location pointer and 
    // if this element is on the right or on top of the cached location
    if ( IsCacheValid() && 
            !pEnd->IsLeftOf(&_lastChild))
    {
        // move the beginning pointer to where the cached pointer is
        pBegin->MoveToPointer( &_lastChild );

        // The cached child id will change on the parent side when we walk to 
        // find this element in the stream. We must backup.
        lCachedChildId = _lLastChild;
    }
    else
    {
        //place a pointer to the beginning of this element
        hr = THR( pBegin->MoveAdjacentToElement( GetElement(),ELEM_ADJ_AfterBegin ) );
        if (hr) 
            goto Cleanup;

        // invalidate the cache of the parent, 
        // we will have to walk from the start anyway.
        _lLastChild = 0;
        _lTreeVersion = 0;
    }
    
    // find child element's child id
    hr = GetChildCount( pBegin, pEnd, &lChildId);
    if(hr)
        goto Cleanup;

    // since we have counted the children up to the child element, it is +1
    // to the total number of children that are before it.
    lChildId = lCachedChildId + lChildId + 1;
    
    // If we need to go to the next element, we could actually benefit from the 
    // cache on the parent element
    if ( navDir == NAVDIR_NEXT )
    {
        CMarkup * pMarkup;

        // place the cached markup pointer to the end of this child.
        hr = THR( _lastChild.MoveAdjacentToElement( pChildElement, ELEM_ADJ_AfterEnd ));
        if (hr)
            goto Cleanup;

        _lLastChild = lChildId;

        pMarkup = GetElement()->GetMarkupPtr();

        if (pMarkup)
        {
            _lTreeVersion = pMarkup->GetMarkupTreeVersion();
        }
        else
        {
            _lTreeVersion = 0;
        }

        // the child id we will ask for from the parent
        lIndex = lChildId + 1;
    }
    else if (lChildId == 1)
    {
        // if NAVDIR_PREVIOUS, then we MUST be at least the second child.
        hr = S_FALSE;
    }
    else
    {
        // the child id we will ask for from the parent
        lIndex = lChildId - 1;
    }

Cleanup:
    *pChildId = lIndex;

    // convert all other error codes to S_FALSE too.
    if (hr)
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//----------------------------------------------------------------------------
//  Helper to get the access key for an element.
//
//----------------------------------------------------------------------------
HRESULT 
CAccElement::GetAccKeyboardShortcut(BSTR * pbstrKeyboardShortcut)
{
    CStr    accessString;
    CStr    sString;    
    HRESULT hr;

    // get the actual key combination value
    hr = THR (accessString.Set(GetElement()->GetAAaccessKey()));
    if (hr)
        goto Cleanup;

    // if there is an access key string
    if (accessString.Length() > 0)
    {
        // we want all keyboard shortcut values to contain 'Alt+' 
        hr = THR(sString.Set( _T("Alt+")));
        if ( hr )
            goto Cleanup;
        
        hr = THR(sString.Append(accessString));
        if (hr)
            goto Cleanup;
            
        hr = THR(sString.AllocBSTR( pbstrKeyboardShortcut ) );
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  Function    :   IServiceProvider::QueryService
//
//  Description :   Function that provides access to other objects that are 
//                  related to this accessible object, but do not have the
//                  same COM identity.
//
//                  Service requests that are supported are:
//                  IID_IHTMLElement
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::QueryService(  REFGUID guidService, REFIID riid, void ** ppvObject)
{
    HRESULT hr;

    if (!ppvObject)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsEqualGUID(guidService, IID_IHTMLElement))
    {
        hr = THR(_pElement->QueryInterface(riid, ppvObject));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccAnch.Cxx
//
//  Contents:   Accessible Anchor object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCOBJ_HXX_
#define X_ACCOBJ_HXX_
#include "accobj.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PLUGINST_HXX_
#define X_PLUGINST_HXX_
#include "pluginst.hxx"
#endif

#ifndef WIN16
extern DYNLIB g_dynlibOLEACC;
#endif // !WIN16


ExternTag(tagAcc);

CAccObject::CAccObject( CElement* pElementParent )
:CAccElement( pElementParent )
{
    //reset the _pAccObject pointer.
    _pAccObject = NULL;

    //initialize the instance variables
    SetRole( ROLE_SYSTEM_CLIENT );
}

CAccObject::~CAccObject()
{
    if ( _pAccObject )
        _pAccObject->Release();
}

//-----------------------------------------------------------------------
//  CAccObject::PrivateQueryInterface()
//
//  DESCRIPTION:
//
//      Standard QI implementation : the CAccBase object implements
//      IDispatch and IAccessible. CAccObject only delegates the IEnumVariant
//      request to the object that it represents.
//
//  PARAMETERS:
//
//      riid        REFIID of requested interface.
//      ppv         pointer to interface in.
//
//  RETURNS:
//
//      E_NOINTERFACE | NOERROR.
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccObject::PrivateQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    
    if ( !ppv )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
  
    if (riid == IID_IEnumVARIANT)
    {
//NOTE: (ferhane)
//          If the object does not support IEnumVariant, then we should
//          return E_NOINTERFACE, since our enumerator can not really know
//          what the object's implementation would be like.

        // if there is an object that is represented, then delegate
        if ( EnsureAccObject()) 
        {
            hr = THR( _pAccObject->QueryInterface( riid, ppv ) );
        }
        else
            hr = E_NOINTERFACE;
    }
    else if (riid == IID_IOleWindow)
    {
        *ppv = (IOleWindow *)this;
        ((LPUNKNOWN) *ppv)->AddRef();
    }
    else
    {
        //Delegate the call to the super;
        hr = THR( super::PrivateQueryInterface( riid, ppv));
        goto Cleanup;
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}


//----------------------------------------------------------------------------
//  get_accChildCount
//
//  DESCRIPTION:
//      if the object that is being represented here supports IAccessible,
//      we delegate the call to that object. Otherwise we return 0.
//
//  PARAMETERS:
//      pChildCount :   address of the parameter to receive the child count
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accChildCount(long* pChildCount)
{
    HRESULT hr = S_OK;
    
    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pChildCount = 0;   //there are no children

    // if the objec that is being represented here supports IAccessible,
    // we delegate the call to that object. Otherwise we return 0.
    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accChildCount( pChildCount ) );
    }

    TraceTag((tagAcc, "CAccObject::get_accChildCount, childcnt=%d hr=%d", 
                *pChildCount, hr));

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  get_accChild()
//
//  DESCRIPTION:
//      if the object that is being represented here supports IAccessible,
//      we delegate the call to that object. Otherwise we return an error, since
//      this tag type can not have any children.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT      hr = S_FALSE;

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispChild = NULL;        //reset the return value.

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accChild( varChild, ppdispChild) );
    }


Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accChild, childid=%d requested, hr=0x%x", 
                        V_I4(&varChild),
                        hr));  

    RRETURN1( hr, S_FALSE );    //S_FALSE is valid when there is no children
}

//----------------------------------------------------------------------------
//  accLocation()
//  
//  DESCRIPTION:
//      Returns the coordinates of the element relative to the top left corner 
//      of the client window.
//      To do that, we are getting the CLayout pointer from the element
//      and calling the GetRect() method on that class, using the global coordinate
//      system. This returns the coordinates relative to the top left corner of
//      the screen. 
//      We then convert these screen coordinates to client window coordinates.
//      
//      If the childid is not CHILDID_SELF, then tries to delegate the call to the 
//      object itself, and returns E_NOINTERFACE if the object does not support 
//      IAccessible
//  
//  PARAMETERS:
//        pxLeft    :   Pointers to long integers to receive coordinates of
//        pyTop     :   the rectangle.
//        pcxWidth  :
//        pcyHeight :
//        varChild  :   VARIANT containing child information. 
//
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accLocation(  long* pxLeft, long* pyTop, 
                          long* pcxWidth, long* pcyHeight, 
                          VARIANT varChild)
{
    HRESULT     hr;
    CRect       rectElement;
   
    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;
    
    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // call super's implementation here..... 
        hr = CAccElement::accLocation( pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
    }
    else 
    {
        if ( EnsureAccObject()) 
        {
            hr = THR( _pAccObject->accLocation( pxLeft, pyTop, pcxWidth, 
                                                pcyHeight, varChild) );
        }
        else
            hr = E_NOTIMPL;
    }

Cleanup:

    TraceTag((tagAcc, "CAccObject::accLocation, childid=%d hr=0x%x", 
                V_I4(&varChild),
                hr));  

    RRETURN1( hr, S_FALSE ); 
}


//----------------------------------------------------------------------------
//  accNavigate
//  
//  DESCRIPTION:
//      Delegate to the object if it implements the IAccessible. Otherwise
//      not implemented.
//      
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT hr = E_NOTIMPL;

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    V_VT( pvarEndUpAt ) = VT_EMPTY;
    
    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->accNavigate(navDir, varStart, pvarEndUpAt) );

Cleanup:
    TraceTag((tagAcc, "CAccObject::accNavigate, start=%d, direction=%d", 
                V_I4(&varStart),
                navDir));  
    RRETURN( hr );
}


//-----------------------------------------------------------------------
//  accHitTest()
//  
//  DESCRIPTION :   Since the window already have checked the coordinates
//                  and decided that the document contains the point, this
//                  function does not do any point checking. 
//                  If the object implements IAccessible, then the call is 
//                  delegated to the object. Otherwise CHILDID_SELF is 
//                  returned.
//                  
//  PARAMETERS  :
//      xLeft, yTop         :   (x,y) coordinates 
//      pvarChildAtPoint    :   VARIANT pointer to receive the acc. obj.
//
//  RETURNS:    
//      S_OK | E_INVALIDARG | 
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    HRESULT     hr;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->accHitTest( xLeft, yTop, pvarChildAtPoint));
    }
    else
    {
        if ( !pvarChildAtPoint )
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        V_VT( pvarChildAtPoint ) = VT_I4;
        V_I4( pvarChildAtPoint ) = CHILDID_SELF;
        
        hr = S_OK;
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::accHitTest, point(%d,%d), hr=0x%x", 
                xLeft, yTop, hr));  

    RRETURN1( hr, S_FALSE );
}    

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accDoDefaultAction(VARIANT varChild)
{   
    HRESULT     hr;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( EnsureAccObject()) 
    {
        hr = THR(_pAccObject->accDoDefaultAction(varChild));
    }
    else
    {
        if ( V_I4(&varChild) == CHILDID_SELF )
        {
            hr = THR( ScrollIn_Focus( _pElement ) );                
        }
        else
            hr = E_NOTIMPL;
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::accDoDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accName
//  
//  DESCRIPTION:
//      If the object implements IAccessible, then calls that implementation
//      otherwise returns the title
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accName(VARIANT varChild,  BSTR* pbstrName )
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accName( varChild, pbstrName) ); 
    }

    //
    // The delegation could not answer the query try to find substitution.
    //
    if (hr || !*pbstrName)
    {
        //
        // Try to get the label or the title for this element.
        //
        hr = THR( GetLabelorTitle(pbstrName) );        
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accName, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accValue
//  
//  DESCRIPTION:
//      Returns the src if the element is an EMBED. Otherwise delegates to the
//      object. If there is no implementation on the object then E_NOINTERFACE
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accValue(VARIANT varChild,  BSTR* pbstrValue )
{
    HRESULT hr = E_NOTIMPL;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrValue = NULL;

    if ( _pElement->Tag() == ETAG_EMBED )
    {
        pchString = (TCHAR *)(DYNCAST( CPluginSite, _pElement ))->GetAAsrc();

        if ( pchString )
        {
            *pbstrValue = SysAllocString( pchString );
            
            if ( !(*pbstrValue) )
                hr = E_OUTOFMEMORY;

            hr = S_OK;
        }
    }
    else 
    {
        if ( EnsureAccObject()) 
            hr = THR( _pAccObject->get_accValue( varChild, pbstrValue) );            
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accValue, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  get_accDefaultAction
//  
//  DESCRIPTION:
//  If the object supports the IAccessible, the object is called. Otherwise, 
//  teturns the default action for  an object, which is 
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accDefaultAction(VARIANT varChild,  BSTR* pbstrDefaultAction )
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accDefaultAction( varChild, pbstrDefaultAction) );
    }
    else
    {
        // Todo: resource string
        *pbstrDefaultAction = SysAllocString( _T("Select") );

        if ( !(*pbstrDefaultAction) )
            hr = E_OUTOFMEMORY;
    }
   
Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

   RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accState
//  
//  DESCRIPTION:
//      
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccObject::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accState(varChild, pvarState));
    }
    else
    {
       
        V_I4( pvarState ) = 0;

        if ( _pElement->GetReadyState() != READYSTATE_COMPLETE )
            V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
        
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
        
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
        
        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accState, childid=%d, state=0x%x, hr=0x%x", 
                V_I4(&varChild), V_I4( pvarState ), hr));  
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accDescription(VARIANT varChild, BSTR * pbstrDescription )
{
    HRESULT hr;

    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accDescription( varChild, pbstrDescription));
    }
    else
    {
        hr = S_OK;
        
        if ( _pElement->Tag() == ETAG_OBJECT )
        {
            *pbstrDescription = SysAllocString( _T("PLUGIN: type=Object") );
        }
        else
        {
            *pbstrDescription = SysAllocString( _T("PLUGIN: type=Embed") );
            
            if ( !(*pbstrDescription) )
                hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accDescription, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accKeyboardShortcut( VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT hr  = E_NOTIMPL;

    // If the call is for the tag itself, we handle it. If the call is 
    // for a child, then the control handles it.
    if ((V_VT(&varChild) == VT_I4) && 
        (V_I4(&varChild) == CHILDID_SELF))
    {
        hr = THR(CAccElement::get_accKeyboardShortcut( varChild, pbstrKeyboardShortcut));
    }
    else if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut) );
    }

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->get_accFocus(pvarFocusChild) );

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->get_accSelection(pvarSelectedChildren) );

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT hr  = E_NOTIMPL;

    // If the call is for the tag itself, we handle it. If the call is 
    // for a child, then the control handles it.
    if ((V_VT(&varChild) == VT_I4) && 
        (V_I4(&varChild) == CHILDID_SELF))
    {
        hr = THR(CAccElement::accSelect(flagsSel, varChild));
    }
    else if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->accSelect( flagsSel, varChild) );
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::put_accName( VARIANT varChild, BSTR bstrName )
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->put_accName(varChild, bstrName));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::put_accValue( VARIANT varChild, BSTR bstrValue )
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->put_accValue(varChild, bstrValue));

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL  
CAccObject::EnsureAccObject( )
{
    HWND        hwndControl = NULL;
    HRESULT     hr;
    
    if (_pAccObject)
        return TRUE;
        
    // If the tag was an embed tag, there is no way that it
    // can support IAccessible


    // RJG -- I believe this is not True

    if ( _pElement->Tag() != ETAG_EMBED )
    {
        IDispatch * pDisp = NULL;

        //HACKHACK: FerhanE: It is common for sites to contain APPLET tags that don't have 
        //                   a codebase at all. When we try to talk to these controls, the
        //                   trust dialogs are shown and this bothers the screen readers.
        //                   We check for an applet tag having a codebase attribute and if
        //                   it does not have one, we don't try to delegate to the control
        //                   or to the OLEACC at all. IEBug:36140
        //
        if ((_pElement->Tag() == ETAG_APPLET) && 
            !(DYNCAST( CObjectElement, _pElement))->GetAAcodeBase() && 
            !(DYNCAST( CObjectElement, _pElement))->GetAAcode())
        {
            return FALSE;
        }

        // get the IDispatch pointer to the COM object that is
        // inside the OBJECT/PLUGIN tag
        (DYNCAST( CObjectElement, _pElement))->get_object( &pDisp );

        if (pDisp)
        {
            hr = THR_NOTRACE(pDisp->QueryInterface( IID_IAccessible, (void **)&_pAccObject));

            // WebView control in the active desktop returns a value in the _pAccobject, although
            // it returns an error code.
            if (hr)
                _pAccObject = NULL;

            // Release the pDisp, so that we have a single reference on the
            // object if we have the _pAccObject. 
            // In case, we don't get a valid _pAccObject, this call serves
            // as a cleanup call...
            pDisp->Release();
        }
    }
    
    // if we don't have an IAccessible after checking with the component, 
    // try to delegate to the OLEACC for windowed controls. There is nothing we can do
    // for windowless controls.
    hwndControl = _pElement->GetHwnd();

    if (!_pAccObject && hwndControl && IsWindow(hwndControl))
    {
        static DYNPROC  s_dynprocAccessibleObjectFromWindow = { NULL, &g_dynlibOLEACC, "AccessibleObjectFromWindow"};

        // Load up the LresultFromObject pointer.
        hr = THR(LoadProcedure(&s_dynprocAccessibleObjectFromWindow));
        
        if (S_OK == hr)
        {
            hr = THR((*(HRESULT (APIENTRY *)(HWND, DWORD, REFIID, void**))
                        s_dynprocAccessibleObjectFromWindow.pfn)(   hwndControl, 
                                                                    OBJID_WINDOW, 
                                                                    IID_IAccessible,
                                                                    (void **)&_pAccObject));
            if (S_OK != hr)
            {
                _pAccObject = NULL;  // double check for the correct return value.
            }
        }
    }
       
    return !!_pAccObject;
}

//----------------------------------------------------------------------------
//
//  IOleWindow implementation
//
//----------------------------------------------------------------------------
STDMETHODIMP    
CAccObject::GetWindow( HWND* phwnd )
{
    HRESULT hr = S_OK;
    
    if ( !phwnd )
    {
        hr = E_POINTER;
    }
    else
    {   
        // if there is a window handle for the control.
        *phwnd = _pElement->GetHwnd();

        // by design, for windowless objects.
        if (!(*phwnd))
            hr = E_FAIL;
    }

    RRETURN( hr );
}

STDMETHODIMP
CAccObject::ContextSensitiveHelp( BOOL fEnterMode )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  get_accRole
//  
//  DESCRIPTION:
//      If the object implements IAccessible, then calls that implementation
//      otherwise returns ROLE_SYSTEM_CLIENT
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pvarRole )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarRole ) = VT_EMPTY;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accRole( varChild, pvarRole) ); 
    }
    else
    {
        // return the role information we have for the element, since
        // this code is only hit when a select does not have a current selection
        V_VT(pvarRole) = VT_I4;
        V_I4(pvarRole) = GetRole();
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccSelect::get_accRole, childid=%d role=%d, hr=0x%x", 
                V_I4(&varChild), V_I4( pvarRole ),  hr));  
    
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accimg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccImg.Cxx
//
//  Contents:   Accessible Image object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCIMG_HXX_
#define X_ACCIMG_HXX_
#include "accimg.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_ELABEL_HXX
#define X_ELABEL_HXX
#include "elabel.hxx"
#endif

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccImage
//  
//  DESCRIPTION:    
//      The image accessible object constructor
//
//  PARAMETERS:
//      Pointer to the image element 
//----------------------------------------------------------------------------
CAccImage::CAccImage( CElement* pElementParent )
:CAccElement(pElementParent)
{
    long lRole;
    
    Assert( pElementParent );
    
    //initialize the instance variables    
    if ( (DYNCAST( CImgElement, _pElement))->GetAAdynsrc() )
    {
        lRole = ROLE_SYSTEM_ANIMATION;
    }
    else
        lRole  = ROLE_SYSTEM_GRAPHIC;

    SetRole( lRole );
}

//----------------------------------------------------------------------------
//  get_accChildCount
//  
//  An image's child count is the number of areas that are connected to this 
//  image, through map objects.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccImage::get_accChildCount(long* pChildCount)
{
    if ( !pChildCount )
        RRETURN( E_POINTER );

    TraceTag((tagAcc, "CAccImage::get_accChildCount"));  

    RRETURN( DYNCAST( CImgElement, _pElement)->GetSubDivisionCount ( pChildCount ) );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, if there is alt text returns the alt text . 
//      else, not implemented
//
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccImage::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    //get the title for the image
    pchString = (LPTSTR) _pElement->GetAAtitle();

    //if there is no title, get the alt. text
    if ( !pchString)
        pchString = (LPTSTR) (DYNCAST(CImgElement, _pElement))->GetAAalt();

    //if no title, and no alt. text.then walk up the accParent chain
    // and look for an anchor.  if there is one use its Name
    if ( !pchString )
    {
        CAccBase * pParent = GetParentAnchor();

        hr = (pParent) ? DYNCAST(CAccElement, pParent)->GetAccName(pbstrName) : E_NOTIMPL;
    }

    if ( !*pbstrName)
    {
        //if we have something in the pchString, use it.
        if (pchString)
        {
            *pbstrName = SysAllocString( pchString );
            if ( !(*pbstrName) )
                hr = E_OUTOFMEMORY;
        }
        else 
        {
            hr = THR(GetLabelText(pbstrName));
        }
    }
    
Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      If the parent is an anchor, delegate to the anchor. If not,
//      then if there is dynsrc return that, if not,
//      then if there is src return that.
//      Since the constructor checks for the dynsrc to determine the role, we
//      check the role here.
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccImage::GetAccValue( BSTR* pbstrValue)
{
    HRESULT     hr = S_OK;
    CAccBase *  pParent = NULL;
    TCHAR *     pchString = NULL;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchNewUrl = cBuf;
    CDoc *      pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    //get the parent and see if it is an anchor.
    pParent = GetParentAnchor();

    //if parent is an anchor, delegate the call.
    if (pParent )
    {
        hr = THR( DYNCAST(CAccElement, pParent)->GetAccValue( pbstrValue ));
    }
    else
    {
        //check if there is dynsrc.
        if ( _lRole == ROLE_SYSTEM_ANIMATION )
        {
            pchString = (LPTSTR) (DYNCAST( CImgElement, _pElement))->GetAAdynsrc();
        }
        else
        {
            pchString = (LPTSTR) (DYNCAST( CImgElement, _pElement))->GetAAsrc();
        }

        if (!pchString)
        {
            hr = E_NOTIMPL;
            goto Cleanup;
        }

        // Return fully expanded URL
        if ( pDoc )
            hr = THR(CMarkup::ExpandUrl(NULL, pchString, ARRAY_SIZE(cBuf), pchNewUrl, _pElement));
        if (hr || (pchNewUrl == NULL))
            goto Cleanup;

        //we have something in the pchString, use it.
        *pbstrValue = SysAllocString( pchNewUrl );
        if ( !(*pbstrValue) )
            hr = E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, if there is alt text returns the alt text . 
//      else, not implemented
//
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccImage::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDescription = NULL;


    // if there is a title then the alt goes into descption,
    // otherwise the desc is ""
    if (_pElement->GetAAtitle())
    {
        //get the alt. text
        pchString = (LPTSTR) (DYNCAST(CImgElement, _pElement))->GetAAalt();

        if ( pchString )
        {   
            *pbstrDescription = SysAllocString( pchString );
            if ( !(*pbstrDescription) )
                hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if object is not complete, then STATE_SYSTEM_UNAVAILABLE
//      adds the parents state to these, if the parent is an anchor.
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccImage::GetAccState( VARIANT *pvarState )
{
    HRESULT    hr=S_OK;
    CAccBase * pParent = NULL;
    VARIANT    varChild;

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
     
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;


    pParent = GetParentAnchor();
    
    //if parent is an anchor, get its values as well.
    if ( pParent )
    {
        V_I4(&varChild)=CHILDID_SELF; 
        V_VT(&varChild)=VT_I4;
        hr = THR( pParent->get_accState( varChild, pvarState ) );
        if ( hr )
            goto Cleanup;
    }
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
    if ( !(DYNCAST( CImgElement, _pElement))->GetAAcomplete() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action. If the parent is anchor, returns "jump"
//  otherwise, not implemented.
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccImage::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT    hr = S_OK;
    CAccBase * pParent = NULL;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pParent = GetParentAnchor();
    
    //if there is an ancestor anchor, then the default action is its default action
    // TODO - resourceString
    if ( pParent )
    {
        *pbstrDefaultAction = SysAllocString( _T("Jump") );

        if (!*pbstrDefaultAction )
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_NOTIMPL;
   
Cleanup:
   RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//  If the parent is anchor then calls the parent, otherwise returns E_NOTIMPL
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccImage::accDoDefaultAction(VARIANT varChild)
{
    HRESULT      hr;
    CAccBase * pParent = NULL;

    hr = THR( ValidateChildID( &varChild ) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) != CHILDID_SELF )
        goto Cleanup;

    pParent = GetParentAnchor();

    //if ancestor anchor, then the default action is its default action
    hr = (pParent) ? THR( pParent->accDoDefaultAction( varChild ) ) : 
                     E_NOTIMPL;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accframe.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccFrame.Cxx
//
//  Contents:   Accessible Frame object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCFRAME_HXX_
#define X_ACCFRAME_HXX_
#include "accframe.hxx"
#endif

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

ExternTag(tagAcc);

extern HRESULT EnsureAccWindow( CWindow * pWindow );
MtDefine(CAccFrameaccLocation_aryRects_pv, Locals, "CAccFrame::accLocation aryRects::_pv")


//+---------------------------------------------------------------------------
//
//  CAccFrame Constructor
//
//----------------------------------------------------------------------------
CAccFrame::CAccFrame( CWindow * pWndInner, CElement * pFrameElement)
: CAccWindow( pWndInner )
{
    _pFrameElement = pFrameElement;

    SetRole( ROLE_SYSTEM_CLIENT );
}

//----------------------------------------------------------------------------
//  accLocation
//
//  DESCRIPTION: Returns the coordinates of the frame relative to the 
//              root document coordinates
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccFrame::accLocation(   long* pxLeft, long* pyTop, 
                           long* pcxWidth, long* pcyHeight, 
                           VARIANT varChild)
{
    HRESULT hr;
    RECT    rectPos = {0};
    RECT    rectRoot = {0};
    CStackDataAry <RECT, 4> aryRects( Mt(CAccFrameaccLocation_aryRects_pv) );
    CLayout *       pLayout;
    CDoc    *       pDoc;

    Assert( pxLeft && pyTop && pcxWidth && pcyHeight );
    TraceTag((tagAcc, "CAccFrame::accLocation, childid=%d", V_I4(&varChild)));  

    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pxLeft = *pyTop = *pcxWidth = *pcyHeight = 0;

    // unpack varChild
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4( &varChild ) != CHILDID_SELF )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the root document coordinates
    pLayout = _pFrameElement->GetUpdatedNearestLayout();
    if ( !pLayout )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get the region 
    pLayout->RegionFromElement( _pFrameElement, &aryRects, &rectPos, RFE_SCREENCOORD);

    pDoc = _pWindow->Doc();

    // get the containing Win32 window's coordinates.
    if (!pDoc ||
        !pDoc->GetHWND( ) || 
        !::GetWindowRect( pDoc->GetHWND( ), &rectRoot ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pxLeft = rectPos.left + rectRoot.left;
    *pyTop =  rectPos.top + rectRoot.top;
    *pcxWidth = rectPos.right - rectPos.left;
    *pcyHeight = rectPos.bottom - rectPos.top;
    
Cleanup:    
    TraceTag((tagAcc, "CAccFrame::accLocation, Location reported as left=%d top=%d width=%d height=%d, hr=%d", 
                rectPos.left - rectRoot.left,
                rectPos.top - rectRoot.top,
                rectPos.right - rectPos.left - rectRoot.left,
                rectPos.bottom - rectPos.top - rectRoot.top,
                hr));
    RRETURN( hr );
}

STDMETHODIMP 
CAccFrame::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT         hr;
    CAccElement *   pAccParent;


    TraceTag((tagAcc, "CAccFrame::get_accParent"));  

    if (!ppdispParent)
        RRETURN(E_POINTER);

    hr = THR(GetParentOfFrame(&pAccParent));
    if (hr)
        goto Cleanup;

    // Reference count and cast at the same time.
    hr  = THR( pAccParent->QueryInterface( IID_IDispatch, (void **)ppdispParent ) );

Cleanup:
    RRETURN( hr );
}

STDMETHODIMP 
CAccFrame::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT         hr;

    TraceTag((tagAcc, "CAccFrame::accNavigate navdir=%d varStart=%d",
                navDir,
                V_I4(&varStart)));  

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarEndUpAt ) = VT_EMPTY;

    switch ( navDir )
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            // delegate to the super, since this is standard window operation
            RRETURN( super::accNavigate(navDir, varStart, pvarEndUpAt) );
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_NEXT:
            // if we are a frame/iframe document, then we should try to get to other 
            // elements that are possibly next to us. 

            if (CHILDID_SELF == V_I4(&varStart) && 
                (!_pWindow->_pMarkup->IsPrimaryMarkup()))
            {
                CAccElement *   pAccParent; // we know that we are a frame. the parent
                                            //  MUST be an element.
                CAccBase *      pAccChild = NULL;
                long            lIndex = 0;
                long            lChildIdx = 0;

                // get the parent document's body element accessible object.
                // We know that the parent is an element, since we are a frame.
                // Casting is OK.
                hr = THR(GetParentOfFrame(&pAccParent));
                if (hr)
                    goto Cleanup;

                hr = THR( pAccParent->GetNavChildId( navDir, _pFrameElement, &lIndex));
                if (hr) 
                    goto Cleanup;

                // now, ask the parent to return the child with that index, and return
                // that child as the sibling.
                hr = THR( pAccParent->GetChildFromID( lIndex, &pAccChild, NULL, &lChildIdx) );
                if ( hr )
                {
                    // NEXT and PREVIOUS can return E_INVALIDARG, which indicates that the
                    // index we passed to the function was out of limits. In that case, 
                    // spec asks us to return S_FALSE, and an empty variant.
                    if ( hr == E_INVALIDARG )
                        hr = S_FALSE;       
            
                    goto Cleanup;
                }

                // Prepare the return value according to the type of the data received
                // Either a child id or a pointer to the accessible child to be returned.
                if ( pAccChild )
                {
                    IDispatch * pDispChild;

                    //the child did have an accessible object

                    hr = pAccChild->QueryInterface( IID_IDispatch, (void **)&pDispChild);
                    if (hr) 
                        goto Cleanup;

                    V_VT( pvarEndUpAt ) = VT_DISPATCH;
                    V_DISPATCH( pvarEndUpAt ) = pDispChild;
                }
                else
                {
                    Assert((lIndex == -1) | (lIndex == lChildIdx));

                    //return the child id
                    V_VT( pvarEndUpAt ) = VT_I4;
                    V_I4( pvarEndUpAt ) = lChildIdx;
                }
            }
            else
                hr = S_FALSE;   // There is only one child for a frame, which is its pane
            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CAccFrame::GetParentOfFrame( CAccElement ** ppAccParent )
{
    HRESULT     hr = E_FAIL;

    Assert( ppAccParent );

    if (!_pFrameElement->HasMarkupPtr())
        goto Cleanup;

    // an IFRAME can have another element as its parent
    if ( _pFrameElement->Tag() == ETAG_IFRAME)
        hr = THR(GetAccParent(_pFrameElement, (CAccBase **)ppAccParent));
    else
    {
        Assert(_pFrameElement->Tag() == ETAG_FRAME);

        // for a FRAME tag, since there may be nested framesets and we don't want to expose them,
        // we should get the root document's primary element client and return the accessible 
        // object for that element.

        // get the parent doc.
        CWindow * pParentWindow;

        pParentWindow = _pFrameElement->GetMarkupPtr()->Window()->Window();

        Assert(pParentWindow);

        // if the parent window does not have an acc. obj, create one
        if (!pParentWindow->_pAccWindow)
        {
            // Since both hittesting and top-down traversal hits the top
            // level window object first, it is impossible to not have
            // a top level accessible object, unless this frame is moved
            // from one document to the other, and the new document was 
            // not hit by MSAA yet. Understand how we got here. (FerhanE)
            AssertSz( 0, "How did we get here ?");
            
            hr = EnsureAccWindow(pParentWindow);
            if (hr)
                goto Cleanup;
        }

        hr = THR(pParentWindow->_pAccWindow->GetClientAccObj( (CAccBase **)ppAccParent ));
    }

Cleanup: 
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accradio.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccRadio.Cxx
//
//  Contents:   Accessible radio button object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCRADIO_HXX_
#define X_ACCRADIO_HXX_
#include "accradio.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccRadio
//  
//  DESCRIPTION:    
//      The radio button accessible object constructor
//
//  PARAMETERS:
//      Pointer to the radio button element 
//----------------------------------------------------------------------------
CAccRadio::CAccRadio( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_RADIOBUTTON );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the label, if not the title.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccRadio::GetAccName( BSTR* pbstrName )
{
    HRESULT hr;
 
    // validate out parameter
    if ( !pbstrName )
    {
        hr= E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    hr = THR( GetLabelorTitle( pbstrName ) );

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the label, if not, the title
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccRadio::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr=S_OK;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if (HasLabel())
        hr = THR( GetTitle( pbstrDescription ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//      if checked then STATE_SYSTEM_CHECKED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccRadio::GetAccState( VARIANT *pvarState )
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bChecked = FALSE;
    CDoc *          pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {    
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
        hr = THR( (DYNCAST(CInput, _pElement))->GetChecked(&bChecked) ) ;
        if ( hr )
            goto Cleanup;
    
        if ( bChecked != VB_FALSE )
            V_I4( pvarState ) |= STATE_SYSTEM_CHECKED;
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//      Returns the default action for a radio button, "select"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccRadio::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Check") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accinimg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccInImg.Cxx
//
//  Contents:   Accessible INPUT TYPE=IMAGE object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCINIMG_HXX_
#define X_ACCINIMG_HXX_
#include "accinimg.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX
#define X_ELABEL_HXX
#include "elabel.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccInputImg
//  
//  DESCRIPTION:    
//      The input image accessible object constructor
//
//  PARAMETERS:
//      Pointer to the input image element 
//----------------------------------------------------------------------------
CAccInputImg::CAccInputImg( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_PUSHBUTTON );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns alt text if exists, otherwise
//      returns E_NOTIMPL
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputImg::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    //get the title for the input image 
    pchString = (LPTSTR) _pElement->GetAAtitle();        
    if ( !pchString )
    {
        //get the alt
        pchString = (LPTSTR) (DYNCAST( CInput, _pElement))->GetAAalt();
    }
    
    if ( pchString )
    { 
        *pbstrName = SysAllocString( pchString );
        if ( !(*pbstrName) )
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(GetLabelText(pbstrName));
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      if there is dynsrc return that, if not,
//      then return src
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputImg::GetAccValue( BSTR* pbstrValue)
{
    HRESULT     hr = S_OK;
    TCHAR *     pchString = NULL;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchNewUrl = cBuf;
    CDoc *      pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrValue = NULL;

    pchString = (LPTSTR) (DYNCAST(CInput, _pElement))->GetAAdynsrc();
    if ( !pchString )
    {
        pchString = (LPTSTR) (DYNCAST(CInput, _pElement))->GetAAsrc();
    }

    //did we get something in the pchString?
    if ( !pchString )
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    // Return fully expanded URL
    if ( pDoc )
        hr = THR(CMarkup::ExpandUrl(NULL, pchString, ARRAY_SIZE(cBuf), pchNewUrl, _pElement));

    if (hr || (pchNewUrl == NULL))
        goto Cleanup;

    *pbstrValue = SysAllocString( pchNewUrl );
    if ( !(*pbstrValue) )
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns alt text if exists, otherwise
//      returns E_NOTIMPL
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputImg::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    // if there is a title then the alt goes into descption,
    // otherwise the desc is ""
    if (_pElement->GetAAtitle())
    {
        //get the alt. text
        pchString = (LPTSTR) (DYNCAST( CInput, _pElement))->GetAAalt();

        if ( pchString )
        {   
            *pbstrDescription = SysAllocString( pchString );
            if ( !(*pbstrDescription) )
                hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not complete, then STATE_SYSTEM_UNAVAILABLE
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccInputImg::GetAccState( VARIANT *pvarState )
{
    HRESULT hr =S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
    if ( ! (DYNCAST(CInput, _pElement))->GetAAcomplete() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;


Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action, which is "Press"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccInputImg::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDefaultAction = SysAllocString( _T("Press") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accsel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccSel.Cxx
//
//  Contents:   Accessible Select object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCSEL_HXX_
#define X_ACCSEL_HXX_
#include "accsel.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

extern DYNLIB g_dynlibOLEACC;

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccSelect
//  
//  DESCRIPTION:    
//      The Select accessible object constructor
//
//  PARAMETERS:
//      Pointer to the select element 
//----------------------------------------------------------------------------
CAccSelect::CAccSelect( CElement* pElementParent )
:CAccObject(pElementParent)
{
    Assert( pElementParent );

    //Only lists can have more than one selection, and only lists can have a size
    //larger than one.
    if ( ( (DYNCAST(CSelectElement, pElementParent))->GetAAmultiple() == -1 ) ||
         ( (DYNCAST(CSelectElement, pElementParent))->GetAAsize() > 1 ))
    {
        SetRole( ROLE_SYSTEM_LIST );
    }
    else
    {
        SetRole( ROLE_SYSTEM_COMBOBOX );
    }
}

CAccSelect::~CAccSelect( )
{
    //if we used the select object's IAccessible interface,
    //release it.
    if ( _pAccObject )
        _pAccObject->Release();
}

//-----------------------------------------------------------------------
//  get_accChild()
//
//  DESCRIPTION:
//      If this is a listbox, we work around the OLEACC bug using a hack. Otherwise
//      we delegate to the object with the IAccessible implementation.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccSelect::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT hr;

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispChild = NULL;        //reset the return value.

    if ((ROLE_SYSTEM_LIST == GetRole()) && 
        (V_I4(&varChild) > 0))
    {
        V_VT(&varChild) = VT_I4;
        V_I4(&varChild) = -1 * V_I4(&varChild);
    }
        
    if ( EnsureAccObject())
    {
        hr = THR( _pAccObject->get_accChild( varChild, ppdispChild) );
    }
    else 
        hr = S_FALSE;
    
Cleanup:
    TraceTag((tagAcc, "CAccSelect::get_accChild, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );    //S_FALSE is valid when there is no children
}

//----------------------------------------------------------------------------
//  get_accDescription
//  
//  DESCRIPTION:
//      Returns the string "Select Element"
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccSelect::get_accDescription(VARIANT varChild, BSTR* pbstrDescription )
{
    HRESULT hr = S_OK;

    if ( !pbstrDescription )
        return E_POINTER;

    *pbstrDescription = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accDescription( varChild, pbstrDescription) );
    }
    else
    {
        //[FerhanE] The proxy returns "Uninitialized Select Element"
        //          I am not sure why, ask... ! ! !
        *pbstrDescription = SysAllocString( _T("Select Element") );
        
        if ( !(*pbstrDescription) )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    TraceTag((tagAcc, "CAccSelect::get_accDescription, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccSelect::get_accState(VARIANT varChild, VARIANT *pvarState )
{
    HRESULT hr;

    // validate out parameter
     if ( !pvarState )
        RRETURN (E_POINTER);
 
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ((V_VT(&varChild) == VT_I4) && 
        (V_I4(&varChild) == CHILDID_SELF))
    {
        hr = CAccElement::get_accState(varChild, pvarState);
    }
    else
    {
        if ( EnsureAccObject())
        {
            hr = THR( _pAccObject->get_accState( varChild, pvarState) );
        }
        else 
        {
            hr = S_FALSE;
        }
    }


    TraceTag((tagAcc, "CAccSelect::get_accState, childid=%d state=0x%x", 
                V_I4(&varChild), V_I4( pvarState )));  

    RRETURN1(hr, S_FALSE);
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL
CAccSelect::EnsureAccObject( )
{
    HWND    hwndCombo = NULL;
    long    lObjId;

    if ( _pAccObject )
        return TRUE;

    //does it have a window of its own?
    hwndCombo = (DYNCAST( CSelectElement, _pElement))->GetHwnd();
    
    // if the select does not have a window of its own, there is no point trying 
    // to get an accessible object from it, since it is not UI activated yet.
    if ( !hwndCombo )
        return FALSE;

    // there is a window for this object, get the
    // IAccessible from the window

    if ( GetRole() == ROLE_SYSTEM_LIST )
    {
        lObjId = OBJID_WINDOW;
    }
    else
    {
        lObjId = OBJID_CLIENT;
    }

    //this call may return S_FALSE
    if (S_OK != (THR( CreateStdAccObj( hwndCombo, 
                                       lObjId, 
                                       (void **)&_pAccObject ) )))
       return FALSE;

    // Without this line, we used to crash, TEST ! ! !
    _pAccObject->AddRef();

    return TRUE;
}

//+---------------------------------------------------------------------------
//  CreateStdAccObj
//  
//  DESCRIPTION:
//      Wrapper function for the OLEACC API CreateStdAccessibleObject
//
//----------------------------------------------------------------------------
HRESULT
CAccSelect::CreateStdAccObj( HWND hWnd, long lObjId, void ** ppAccObj )
{
    HRESULT hr;
    
    static DYNPROC s_dynprocCreateStdAccObj =
            { NULL, &g_dynlibOLEACC, "CreateStdAccessibleObject" };

    // Load up the CreateStdAccessibleObject pointer.
    hr = THR(LoadProcedure(&s_dynprocCreateStdAccObj));
    if (hr)
        goto Cleanup;

    hr = THR ((*(LRESULT (APIENTRY *)(HWND, DWORD, REFIID, void**))
                s_dynprocCreateStdAccObj.pfn)( hWnd, lObjId, 
                                               IID_IAccessible, ppAccObj) );
                                               
    // if the window is not UI active, the return value is E_FAIL.
    // if we still have a pointer, then we can return S_OK
    if ( (hr == E_FAIL) && (*ppAccObj) )
        hr = S_OK;

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
CAccSelect::GetAccState(VARIANT* pvarState )
{
    CDoc * pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
        return ( E_POINTER );
 
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accmarq.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccMarq.Cxx
//
//  Contents:   Accessible Marquee object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCMARQ_HXX_
#define X_ACCMARQ_HXX_
#include "accmarq.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccMarquee
//  
//  DESCRIPTION:    
//      The marquee accessible object constructor
//
//  PARAMETERS:
//      Pointer to the marquee element 
//----------------------------------------------------------------------------
CAccMarquee::CAccMarquee( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_ANIMATION );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title,
//      otherwise returns the innertext
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccMarquee::GetAccName( BSTR* pbstrName )
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrName = NULL;

    hr = THR( GetTitleorLabel( pbstrName ) );
    if ( FAILED(hr) )
        goto Cleanup;
    
    if ( !(*pbstrName))
        hr = THR( _pElement->get_innerText( pbstrName ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title,
//      otherwise returns the innertext
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccMarquee::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = NULL;

    
    // if there is a title, then then inner text is reported
    // as the description.  If there isn't a title, then the 
    // description is blank.
    hr = GetTitle( pbstrDescription );
    if (hr)
        goto Cleanup;  // includeing S_FALSE

    if ( *pbstrDescription)
    {
        SysFreeString(*pbstrDescription);
        *pbstrDescription = NULL;
        hr = THR( _pElement->get_innerText( pbstrDescription ) );
    }

    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_MARQUEED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccMarquee::GetAccState( VARIANT *pvarState )
{
    HRESULT         hr = S_OK;

    // validate out parameter
     if ( !pvarState )
     {
         hr = E_POINTER;
         goto Cleanup;
     }
        
    V_VT( pvarState ) = VT_I4;    
    V_I4( pvarState ) = STATE_SYSTEM_MARQUEED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\attr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       attr.cxx
//
//  Contents:   CAttrValue, CAttrArray
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(CAttrArray, Elements, "CAttrArray")
MtDefine(CAttrArray_pv, CAttrArray, "CAttrArray::_pv")
MtDefine(CAttrValue_pch, CAttrArray, "CAttrValue::_varValue::_pch")
MtDefine(CAttrValue_dbl, CAttrArray, "CAttrValue::_pdblVal")
MtDefine(CAttrValue_var, CAttrArray, "CAttrValue::_pvarVal")
MtDefine(CAttrArrayHeader, CAttrArray, "CAttrValue::_pAAHeader")

DeclareTag(tagPersistDefaultValues, "AttrArray", "Store default values in attr array")

//$WIN64: Win64 doesn't need to allocate for doubles since uVal is already 8 bytes wide

static const DWORD dwUnsetOther=0;
static const DWORD dwUnsetColor = VALUE_UNDEF;

#define DESTROY_DEFAULT 1

#if DESTROY_DEFAULT
static BOOL
IsDefaultValue ( const PROPERTYDESC *pPropertyDesc, VARIANT *pvt )
{
    DWORD dwValue;
    if ( V_VT(pvt)!=VT_I4)
    {
        return FALSE;
    }
    dwValue = (DWORD)pPropertyDesc->ulTagNotPresentDefault;
    return dwValue == (DWORD)V_I4(pvt) ? TRUE : FALSE;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Free
//
//  Synopsis:   Free's memory used by this AV
//
//-------------------------------------------------------------------------
void
CAttrValue::Free()
{
    switch (GetAVType())
    {
    case VT_LPWSTR:
        delete[] GetLPWSTR();
        break;

    case VT_BSTR:
        FormsFreeString(GetBSTR());
        break;

    case VT_ATTRARRAY:
        delete GetAA();
        break;

    case VT_R8:
        delete GetDoublePtr();
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        ReleaseInterface(GetpUnkVal());
        break;

    case VT_VARIANT:
        VariantClear(GetVariant());
        delete GetVariant();
        break;

    case VT_AAHEADER:
        delete GetAAHeader();
        break;
    }

    SetAVType(VT_EMPTY);
}

void CAttrValue::SetAAType(AATYPE aaType) 
{
    WORD extraBits = AA_Extra_Empty;

    if (aaType == AA_StyleAttribute)
    {
         extraBits |= AA_Extra_Style;
         aaType = AA_Attribute;
    }

    _wFlags._aaType = aaType;
    _wFlags._aaExtraBits = extraBits;
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::CompareWith
//
//  Synopsis:   Is this the attr value we want?
//
//				0 = exact match
//				1 = greater than
//			   -1 = less than
//
//-------------------------------------------------------------------------
int
CAttrValue::CompareWith ( DISPID dispID, AATYPE aaType )
{
    DISPID dispIdTmp = GetDISPID();

    if ( dispID < dispIdTmp )
        return -1;
    else if ( dispID > dispIdTmp )
        return 1;
    else
    {
        if ( aaType == AAType() )
            return 0;
        else if ( aaType < AAType() )
            return -1;
        else 
            return 1;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Copy
//
//  Synopsis:   Make this AV the same as input AV
//
//-------------------------------------------------------------------------
HRESULT
CAttrValue::Copy(const CAttrValue *pAV)
{
    HRESULT hr = S_OK;
    VARIANT varNew;
    Assert(pAV);

    // Tidy up existing
    Free();

    _pPropertyDesc = pAV->_pPropertyDesc;
    _dispid = pAV->_dispid;
    _wFlags = pAV->_wFlags;

    // Copy in new
    pAV->GetAsVariantNC(&varNew);
    hr = THR(InitVariant(&varNew, TRUE));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::CopyEmpty
//
//  Synopsis:   Copy everything about input AV except the value
//
//-------------------------------------------------------------------------
void
CAttrValue::CopyEmpty(const CAttrValue *pAV)
{
    Assert(pAV);

    // Tidy up existing
    Free();

    _pPropertyDesc = pAV->_pPropertyDesc;
    _dispid = pAV->_dispid;
    _wFlags = pAV->_wFlags;

    // Set as empty
    SetAVType(VT_EMPTY);
}

HRESULT
CAttrValue::InitVariant (const VARIANT *pvarNew, BOOL fIsCloning)
{
    LPTSTR lpNew;
    LPTSTR lpAlloc;
    BSTR bstrVal = NULL;
    HRESULT hr = S_OK;
    VARTYPE avType = V_VT(pvarNew);

    SetAVType(VT_EMPTY);
    switch (avType)
    {
    case VT_LPWSTR:
        {
            lpNew = (LPTSTR)(V_BYREF(pvarNew));
            if (lpNew)
            {
                lpAlloc = new(Mt(CAttrValue_pch)) TCHAR [ _tcslen ( lpNew ) + 1 ];
                if (!lpAlloc)
                    hr = E_OUTOFMEMORY;
                else
                {
                    SetLPWSTR(lpAlloc);
                    MemSetName((GetLPWSTR(), "CAttrValue string"));
                    _tcscpy (lpAlloc, lpNew);
                }
            }
            else
                SetLPWSTR(NULL);
        }
        break;

    case VT_ATTRARRAY:
        if (fIsCloning)
        {
            // Make a complete Copy
            CAttrArray *pCloneFromAttrArray = (CAttrArray *)V_BYREF(pvarNew);
            if (pCloneFromAttrArray)
            {
                CAttrArray *pNewAttrArray = NULL;
                hr = THR(pCloneFromAttrArray->Clone(&pNewAttrArray));
                if (!hr)
                    SetAA(pNewAttrArray);
            }
            else
                SetAA(NULL);
        }
        else
        {
            // Just initialising
            SetAA((CAttrArray *)V_BYREF(pvarNew));
        }
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        if (V_UNKNOWN(pvarNew))
            V_UNKNOWN(pvarNew)->AddRef();
        // fall through to VT_PTR

    case VT_INT_PTR:
    case VT_PTR:
        SetPointer(V_BYREF(pvarNew), avType);
        break;

    case VT_R4:
    case VT_I4:
        SetLong(V_I4(pvarNew), avType);
        break;

    case VT_INT:
        SetInt(V_INT(pvarNew), avType);
        break;

    case VT_I2:
    case VT_BOOL:
        SetShort(V_I2(pvarNew), avType);
        break;

    case VT_R8:
        hr = THR(SetDouble(V_R8(pvarNew)));
        break;

    case VT_BSTR:
        hr = THR(FormsAllocString(V_BSTR(pvarNew), &bstrVal));
        if (hr)
            goto Cleanup;

        SetBSTR(bstrVal);
        break;

    case VT_EMPTY:
    case VT_NULL:
        SetAVType(avType);
        break;

    default:
        hr = THR(SetVariant(pvarNew));
        break;
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
CAttrValue::SetDouble (double dblVal)
{
    HRESULT hr = S_OK;
    VARTYPE avType = VT_EMPTY;

    uVal._pdblVal = new(Mt(CAttrValue_dbl)) double;
    if (!uVal._pdblVal)
        hr = E_OUTOFMEMORY;
    else
    {
        *(uVal._pdblVal) = dblVal;
        avType = VT_R8;
    }

    SetAVType(avType);
    return hr;
}

HRESULT
CAttrValue::SetVariant (const VARIANT *pvar)
{
    HRESULT hr = S_OK;
    VARTYPE avType = VT_EMPTY;

    uVal._pvarVal = new(Mt(CAttrValue_var)) VARIANT;
    if (!uVal._pvarVal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    V_VT(uVal._pvarVal) = VT_EMPTY;
    hr = VariantCopy(uVal._pvarVal, (VARIANT *)pvar);
    if (hr)
        goto Cleanup;

    avType = VT_VARIANT;

Cleanup:
    if (hr && uVal._pvarVal)
        delete uVal._pvarVal;

    SetAVType(avType);
    return hr;
}

void
CAttrValue::GetAsVariantNC(VARIANT *pvar) const
{
  	VARTYPE avType = GetAVType();
    V_VT(pvar) = avType;
    switch(avType)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I2:
    case VT_BOOL:
        V_BOOL(pvar) = GetiVal();
        break;

    case VT_R4:
    case VT_I4:
        V_I4(pvar) = GetlVal();
        break;

    case VT_I8:
    case VT_R8:
        V_R8(pvar) = GetDouble();
        break;

    case VT_VARIANT:
        memcpy(pvar, GetVariant(), sizeof(VARIANT));
        break;

    default:
        V_BYREF(pvar) = GetPointerVal();
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::GetIntoVariant
//
//  Synopsis:   Initialize the variant and copy the attribute value into it
//
//-------------------------------------------------------------------------
HRESULT
CAttrValue::GetIntoVariant (VARIANT *pvar) const
{
    HRESULT hr = S_OK;

  	V_VT(pvar) = VT_EMPTY;
    switch (GetAVType())
    {
    case VT_LPWSTR:
    case VT_BSTR:
        hr = THR(FormsAllocString(GetString(), &V_BSTR(pvar)));
        if (hr)
            goto Cleanup;

        V_VT(pvar) = VT_BSTR;
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        if (GetpUnkVal())
            GetpUnkVal()->AddRef();
        
        V_UNKNOWN(pvar) = GetpUnkVal();
      	V_VT(pvar) = GetAVType();
        break;

    case VT_VARIANT:
        pvar->vt = VT_EMPTY;
        hr = VariantCopy(pvar, GetVariant());
        break;

    default:
        GetAsVariantNC(pvar);
        break;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::GetIntoString
//
//  Synopsis:   Massage the AttrValue into a string - if we need to alloc
//              a BSTR for this, so be it - the caller is responsible for
//              freeing it.
//
//-------------------------------------------------------------------------
HRESULT
CAttrValue::GetIntoString(BSTR *pbStr, LPCTSTR *ppStr) const
{
    HRESULT hr = S_OK;

    Assert(pbStr);

    *pbStr = NULL;

    switch (GetAVType())
    {
    case VT_LPWSTR:
        *ppStr = GetLPWSTR();
        break;

    case VT_BSTR:
        *ppStr = (LPTSTR)GetBSTR();
        break;

    default:
        {
            VARIANT varDest;
            VARIANT varSrc;
            varDest.vt = VT_EMPTY;
            GetAsVariantNC(&varSrc);
            hr = THR(VariantChangeTypeSpecial(&varDest, &varSrc, VT_BSTR));
            if (hr)
            {
                if (hr == DISP_E_TYPEMISMATCH)
                    hr = S_FALSE;
                goto Cleanup;
            }
            *ppStr = (LPTSTR)V_BSTR(&varDest);
            *pbStr = V_BSTR(&varDest);
        }
        break;
    }
Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Method: GetIntoDispatchableVariant
//
//  Synopsis: Stores the AttrValue into a representation suitable
//      for setting the property in IDispatch.  Stores it into a variant
//      because sometimes an VT_LPWSTR is appropriate (ie, enum), somtimes
//      a BSTR is appropriate (UnitValue/Color) and sometimes it's just a 
//      plain old number
//
//      [Variant *]         pVar        -   Variant to store into
//      [PROPERTYDESC *]    pPropDesc   -   PropDesc for AttrValue
//
//+----------------------------------------------------------------------------
void
CAttrValue::GetIntoDispatchableVariant( VARIANT * pVar, const PROPERTYDESC * pPropDesc )
{
    Assert( pVar && pPropDesc );

    BOOL fHasValue = GetAVType() != VT_NULL && GetAVType() != VT_EMPTY;

    V_VT(pVar) = VT_NULL;

    if( fHasValue)
    {
        if (pPropDesc->pfnHandleProperty == PROPERTYDESC::HandleEnumProperty )
        {
            ENUMDESC * pEnumDesc = pPropDesc->GetEnumDescriptor();

            Assert( pEnumDesc );

            pVar->vt = VT_LPWSTR;
            pVar->byref = (void *)( const_cast<TCHAR *>( pEnumDesc->StringPtrFromEnum( GetLong() ) ) );
        }
        else if (pPropDesc->pfnHandleProperty == PROPERTYDESC::HandleUnitValueProperty)
        {
            TCHAR ach[30];
            CUnitValue uv( GetLong() );

            uv.FormatBuffer( ach, ARRAY_SIZE(ach), pPropDesc );

            if( SUCCEEDED( FormsAllocString( ach, &V_BSTR(pVar) ) ) )
                pVar->vt = VT_BSTR;
        }
        else if(pPropDesc->pfnHandleProperty == PROPERTYDESC::HandleColorProperty)
        {
            TCHAR ach[64];
            CColorValue cv(GetLong());

            cv.FormatBuffer(ach, ARRAY_SIZE(ach), pPropDesc);

            if(SUCCEEDED(FormsAllocString(ach, &V_BSTR(pVar))))
                pVar->vt = VT_BSTR;
        }
    }
    else
    {
        GetIntoVariant( pVar );
    }
}
    


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Compare
//
//  Synopsis:   Compare 2 AttributeValues.  TRUE means they are the same
//              FALSE means they are different
//
//-------------------------------------------------------------------------
BOOL
CAttrValue::Compare(const CAttrValue *pAV) const
{
    Assert(pAV);

    if ( pAV -> GetDISPID() != GetDISPID() || pAV->AAType() != AAType() )
        return FALSE;

    switch ( GetAVType() )
    {
    case VT_DISPATCH:
    case VT_UNKNOWN:
        switch ( pAV->GetAVType() )
        {
            case VT_DISPATCH:
            case VT_UNKNOWN:
                {
                    LPUNKNOWN lpUnk1 = NULL;
                    LPUNKNOWN lpUnk2 = NULL;
                    HRESULT hr;
                    LPUNKNOWN lpUnk = (IUnknown *)pAV->GetpUnkVal();
                    hr  = lpUnk -> QueryInterface ( IID_IUnknown, (LPVOID *)&lpUnk1 );
                    if ( !hr )
                    {
                        lpUnk = (IUnknown *)GetpUnkVal();
                        hr  = lpUnk -> QueryInterface ( IID_IUnknown, (LPVOID *)&lpUnk2 );
                        if ( !hr )
                        {
                            if ( lpUnk1 == lpUnk2 )
                            {
                                ReleaseInterface ( lpUnk1 );
                                ReleaseInterface ( lpUnk2 );
                                return TRUE;
                            }
                        }
                    }
                    ReleaseInterface ( lpUnk1 );
                    ReleaseInterface ( lpUnk2 );
                }
                break;

            default:
                break;
        }
        break;

    case VT_BSTR:
        break;

    case VT_LPWSTR:
        switch ( pAV->GetAVType() )
        {
        case VT_LPWSTR:
            if ( GetLPWSTR() == NULL || pAV->GetLPWSTR() == NULL )
            {
                if ( GetLPWSTR() == NULL && pAV->GetLPWSTR() == NULL )
                {
                    return TRUE;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                // N.B. Need to confirm case sensitivity here.
                return StrCmpC( GetLPWSTR(), pAV->GetLPWSTR() ) == 0 ? TRUE : FALSE;
            }
            break;

        default:
            break;
        }
        break;

    case VT_ATTRARRAY:
        return GetAA()->Compare ( pAV->GetAA(), NULL );

    default:
        switch ( pAV->GetAVType() )
        {
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_DISPATCH:
        case VT_UNKNOWN:
            break;

        default:
            if ( pAV->GetAVType() != GetAVType() )
                return FALSE;
            switch ( pAV->GetAVType() )
            {
            case VT_I4:
                return pAV->GetLong() == GetLong();
            case VT_I2:
                return pAV->GetShort() == GetShort();
            case VT_R4:
                return pAV->GetFloat() == GetFloat();
            case VT_R8:
                return pAV->GetDouble() == GetDouble();
            case VT_PTR:
                return pAV->GetPointer() == GetPointer();
            default:
                break;
            }
            break;
        }
        break;
    }
    return FALSE;
}


//+------------------------------------------------------------------------
//
//  CAttrArray code follows:
//
//-------------------------------------------------------------------------

CAttrArray::CAttrArray() : CDataAry<CAttrValue>(Mt(CAttrArray_pv))
{
    _dwChecksum = 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Clone()
//
//  Synopsis:   Clone this CAttrArray
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::Clone(CAttrArray **ppAA) const
{
    HRESULT hr = S_OK;
    DISPID dispid;
    const PROPERTYDESC *pSrcDesc;
    BOOL fCopyNextInternal = FALSE;

    int z,nCount;
    CAttrValue *pAV, *pAV2;

    Assert(ppAA);

    *ppAA = new CAttrArray;
    if (!*ppAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    MemSetName((*ppAA, "cloned CAttrArray:%s", MemGetName((void *)this)));

    hr = THR( (*ppAA)->EnsureSize(Size()));
    if (hr)
        goto Cleanup;

    for (pAV2 = (CAttrValue*) *(*ppAA),
        pAV = (CAttrValue*) *(CAttrArray *)this,
        z=0, nCount = 0; z<Size(); ++z, ++pAV)
    {
        // Don't copy internals
        if ((pAV->AAType() != CAttrValue::AA_Internal) || fCopyNextInternal)
        {
            // don't copy uniqueID
            dispid = pAV->GetDISPID();
            if (DISPID_CElement_uniqueName == dispid)
                continue;

            pAV2->SetAVType(VT_EMPTY);
            hr = THR(pAV2->Copy(pAV));
            if (hr)
                goto Cleanup;
            ++pAV2; nCount++;

            // if onfoo event property the dispatch ptr to script code will be the next one in AA, copy it too
            pSrcDesc = pAV->GetPropDesc();
            fCopyNextInternal = pSrcDesc && (pSrcDesc->GetPPFlags() & PROPPARAM_SCRIPTLET);

            // Internals don't add to the checksum, so skip it if we are going to
            // copy the next internal.
            if (fCopyNextInternal)
            {
                if (    z + 1 < Size() 
                    &&  (pAV+1)->GetDISPID() == dispid 
                    &&  (pAV+1)->AAType() == CAttrValue::AA_Internal)
                   continue;
                else
                {
                   fCopyNextInternal = FALSE;
                }
            }
    
            (*ppAA)->_dwChecksum += ((DWORD)dispid)<<1;
        }

    }
    (*ppAA)->SetSize(nCount);

    pAV = (CAttrValue*) *(CAttrArray *)this;
    if (pAV && pAV->GetAVType() == CAttrValue::VT_AAHEADER)
    {
        CAttrArrayHeader *pSrcAAHeader = pAV->GetAAHeader();
        if (pSrcAAHeader != NULL)
        {
            InlineEvts *pEventsToHook = pAV->GetEventsToHook();
            pAV2 = (*ppAA)->EnsureHeader(TRUE);
            if (pAV2 != NULL && pEventsToHook != NULL)
            {
                InlineEvts *pEventsClone = new InlineEvts();
                if (! pEventsClone)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                *pEventsClone = *pEventsToHook;
                pAV2->SetEventsToHook(pEventsClone);
            }
        }
    }


Cleanup:
    if (hr)
    {
        delete *ppAA;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Merge()
//
//  Synopsis:   Merge this AttrArray in to the target.
//
//  Arguments:  ppAATarget      The target attr array to merge into
//              pTarget
//              pAAUndo         AttrArray to save old values
//              pAASync         AttrArray to store forward diff
//              fFromUndo       if TRUE, merge *everything*
//              fCopyID         merge the name/id also
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::Merge( CAttrArray **ppAATarget, 
                   CBase *pTarget, 
                   CAttrArray *pAAUndo, 
                   CAttrArray *pAASync /* = NULL */, 
                   BOOL fFromUndo /* = FALSE */, 
                   BOOL fCopyID /* = FALSE */) const
{
    HRESULT hr = S_OK;
    int z, nSizeTarget = 0, nCompare;
    BOOL fFind, fAlloced = FALSE, fCopyNextInternal = FALSE;
    CAttrValue *pAVSource, *pAVTarget, *pAVTargetBase;
    AAINDEX aaIndex;
    const PROPERTYDESC *pTargetDesc;
    const PROPERTYDESC *pSrcDesc;
    const TCHAR *pchName = NULL;
    DISPID dispid;

    Assert(ppAATarget);

    if ( !(*ppAATarget) )
    {
        *ppAATarget = new CAttrArray;
        if (!*ppAATarget)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        fAlloced = TRUE;
    }

    nSizeTarget = (*ppAATarget)->Size();

    // Only look for existing attr values if there are any!
    fFind = nSizeTarget > 0;

    MemSetName((*ppAATarget, "merged CAttrArray:%s", MemGetName((void *)this)));

    hr = THR((*ppAATarget)->EnsureSize(Size()+nSizeTarget));
    if (hr)
        goto Cleanup;

    pAVTarget = pAVTargetBase = (CAttrValue*) *(*ppAATarget);

    for (pAVSource = (CAttrValue*) *(CAttrArray *)this,
         z=0 ; z<Size(); ++z, ++pAVSource)
    {
        dispid = pAVSource->GetDISPID();

        // don't copy id or name or uniqueID
        if (    !fFromUndo
            &&  (   !fCopyID 
                &&  (   (DISPID_CElement_id == dispid) 
                    ||  (STDPROPID_XOBJ_NAME == dispid)) 
                ||  (DISPID_CElement_uniqueName == dispid)))
            continue;

        // Don't copy internals, nested AAs, attached events or expressions
        if (    fFromUndo
            ||  (   pAVSource->AAType() != CAttrValue::AA_Internal
                &&  pAVSource->AAType() != CAttrValue::AA_AttrArray
                &&  pAVSource->AAType() != CAttrValue::AA_AttachEvent
                &&  pAVSource->AAType() != CAttrValue::AA_Expression ) )
        {
            Assert(fFromUndo ||
                   pAVSource->AAType() == CAttrValue::AA_Attribute ||
                   pAVSource->AAType() == CAttrValue::AA_Expando ||
                   pAVSource->IsStyleAttribute() || 
                   pAVSource->AAType() == CAttrValue::AA_UnknownAttr ||
                   pAVSource->AAType() == CAttrValue::AA_DOMAttribute);

NEXT:
            // if at end of target AA, nothing left to compare, use common code path for nComape == -1
            fFind = fFind && ((pAVTarget - pAVTargetBase) < nSizeTarget);
            // if non-empty target, does src prop exist in target AA?
            nCompare = (fFind) ? pAVTarget->CompareWith(dispid, pAVSource->AAType()) : -1;
            switch (nCompare)  // yes
            {
            case  0: // yes, found one
            case -1: // no, src < target, or at end of target, time to insert appropriately into target
                    
                    pSrcDesc = pAVSource->GetPropDesc();

                    // if src and target elem are of same type OR src prop exists in target AA,
                    // just copy the new value, else ...
                    if (pTarget && nCompare && !fFromUndo)
                    {
                        // ... if not in common attribute range or not an expando\unknown, skip
                        if ((pAVSource->AAType() != CAttrValue::AA_Expando) &&
                            (pAVSource->AAType() != CAttrValue::AA_UnknownAttr) && 
                            (dispid >= 0))
                            break;

                        // ... does src prop have a propdesc ?
                        if (pSrcDesc)
                        {
                            // Yes, check to see if target supports prop name
                            pchName = pSrcDesc->pstrName;
                            pTargetDesc = pTarget->FindPropDescForName(pchName);
                    
                            // skip this src prop if only name is same in target, but not the whole property
                            if (!pTargetDesc ||
                                ((pSrcDesc != pTargetDesc) && 
                                 (pSrcDesc->GetDispid() != pTargetDesc->GetDispid())))
                                break;
                        }
                        // No, just copy (could be expando, unknwon attr or name\id)
                    }

COPYNEXTINTERNAL:                    
                    if( pAASync )
                    {
                        CAttrValue avTemp;

                        avTemp.SetAVType(VT_EMPTY);
                        if( SUCCEEDED( avTemp.Copy(pAVSource) ) &&
                            SUCCEEDED( pAASync->AppendIndirect( &avTemp ) ) )
                        {
                            // pAASync owns it now
                            avTemp.SetAVType(VT_EMPTY);
                        }
                    }

                    // destination element supports the property or it is an expando on the src,
                    // just insert new value if target is non-empty and src prop doesn't exist in it.
                    if (fFind && nCompare)
                    {
                        CAttrValue  tempAV;

                        // Setup CAttrValue to empty value so Copy won't free.
                        tempAV.SetAVType(VT_EMPTY);

                        // Need to allocate the value of the expando.
                        hr = THR(tempAV.Copy(pAVSource));

                        // get insertion point
                        aaIndex = pAVTarget - pAVTargetBase;
                        // if expando prop, it will already be in the doc's atom table, so don't bother adding again.
                        hr = THR((*ppAATarget)->InsertIndirect(aaIndex, &tempAV));

                        // Set back to empty, as owner is now ppAATarget, not tempAV.
                        tempAV.SetAVType(VT_EMPTY);
                    }
                    else
                    {
                        // empty target, or target at end of AA, or non-empty target with src prop value existing
                        // in it; just copy as src is already sorted 
                        
                        // if src has an expando, it will already be in the doc's atom table, so don't bother
                        // adding again.

                        // Need to set this here as pAVTarget always points to new, not necessarily zeroed out memory,
                        // so, need to protect from crashing in Free inside Copy.
                        if (nCompare)
                            pAVTarget->SetAVType(VT_EMPTY);

                        // For Undo, save the old value.
                        if (pAAUndo && !nCompare)
                        {
                            HRESULT     hrUndo;

                            hrUndo = THR( pAAUndo->AppendIndirect( pAVTarget ) );

                            // Undo AttrArray owns this now
                            pAVTarget->SetAVType(VT_EMPTY);
                        }

                        // The next CAV in target had better be the script dispatch code
                        Assert(nCompare ||
                               !fCopyNextInternal || 
                               ((pAVTarget->GetDISPID() == dispid) && (pAVTarget->AAType() == CAttrValue::AA_Internal)));

                        // If we are comming from undo and we have an exact match
                        // and our source has AVType == VT_EMPTY, remove the entry
                        // from the target array
                        if (fFromUndo && !nCompare && pAVSource->GetAVType() == VT_EMPTY)
                        {
                            // get insertion point
                            aaIndex = pAVTarget - pAVTargetBase;

                            // Fix up the checksum for the attr array
                            if (pAVTarget->AAType() != CAttrValue::AA_Internal)
                                (*ppAATarget)->_dwChecksum -= ((DWORD)pAVTarget->GetDISPID())<<1;

                            pAVTarget->Free();

                            // Delete will not realloc the array
                            (*ppAATarget)->Delete( aaIndex );

                            // The target array is one smaller
                            nSizeTarget--;

                            // Back off pAVTarget so we can move it forward below
                            pAVTarget--;
                        }
                        else
                        {
                            hr = THR(pAVTarget->Copy(pAVSource));
                        }
                    }

                    if (hr)
                        goto Cleanup;

                    if (nCompare)
                    {
                        if (pAVSource->AAType() != CAttrValue::AA_Internal)
                            (*ppAATarget)->_dwChecksum += ((DWORD)dispid)<<1;
                        nSizeTarget++;
                        (*ppAATarget)->SetSize(nSizeTarget);

                        // For Undo, store a VT_EMPTY to mark that we must
                        // remove this attr value
                        if (pAAUndo)
                        {
                            HRESULT     hrUndo;
                            CAttrValue *pAVUndo;

                            hrUndo = THR( pAAUndo->AppendIndirect( NULL, &pAVUndo ) );
                            if (!hrUndo)
                            {
                                pAVUndo->SetAVType( VT_EMPTY );
                                pAVUndo->CopyEmpty( pAVSource );
                            }
                        }
                    }
                    pAVTarget++;

                    // if onfoo event property the dispatch ptr to script code will be the next one in AA, copy it too
                    fCopyNextInternal = pSrcDesc && (pSrcDesc->GetPPFlags() & PROPPARAM_SCRIPTLET);
                    if (fCopyNextInternal)
                    {
                        pSrcDesc = NULL;
                        pAVSource++; z++;
                        if (    z < Size() 
                            &&  pAVSource->GetDISPID() == dispid 
                            &&  pAVSource->AAType() == CAttrValue::AA_Internal)
                           goto COPYNEXTINTERNAL;
                    }

                    break;

            case 1: // no, src > target, continue

                    pAVTarget++;
                    goto NEXT;
            }
        }
    }

Cleanup:

    if (hr && fAlloced)
    {
        delete *ppAATarget;
        *ppAATarget = NULL;
    }
    else if (*ppAATarget)
    {
        Assert((*ppAATarget)->Size() <= (nSizeTarget));
        hr = THR((*ppAATarget)->Grow(nSizeTarget));
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::CopyExpandos
//
//  Synopsis:   Add expandos of given attrarray to current attrarray
//
//-------------------------------------------------------------------------

HRESULT
CAttrArray::CopyExpandos(CAttrArray *pAA)
{
    HRESULT      hr = S_OK;
    CAttrValue * pAV2;

    Assert(pAA);

    pAV2 = (CAttrValue*) *pAA;

    for (int i = 0; i < pAA->Size(); i++, pAV2++)
    {
        // Copy all expandos
        if ( pAV2->AAType() == CAttrValue::AA_Expando)
        {
            VARIANT varVal;
            pAV2->GetAsVariantNC(&varVal);
            hr = THR(Set(pAV2->GetDISPID(), NULL, &varVal, CAttrValue::AA_Expando));
            if(hr)
                break;
        }
    }

    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Compare
//
//  Synopsis:   We are already sorted, and have cache cookies!
//              TRUE means same, FALSE means different
//
//-------------------------------------------------------------------------

BOOL
CAttrArray::Compare ( CAttrArray * pAAThat, DISPID * pdispIDOneDifferent ) const
{
    int nThisSize = this ? Size() : 0;
    int nThatSize = pAAThat ? pAAThat->Size() : 0;
    const CAttrValue * pAVThis, * pAVThat;
    BOOL fFoundOneAttrValueDifferent = FALSE;

    //
    // If both arrays are empty, or identical, then they are the same.
    //

    if ((nThatSize == 0 && nThisSize == 0) || (this == pAAThat))
        return TRUE;

    //
    // A quick check of the CRC's for each array will immediatly tell
    // us if thay are different (but no the same).  Note that if we also
    // want to know if one attr is differnt we can't do this quick check.
    //

    if (!pdispIDOneDifferent && (!pAAThat || (pAAThat->GetChecksum() != this->GetChecksum())))
        return FALSE;

    DISPID pdispIDDummy;
    DISPID & dispIDOneDifferent =
        pdispIDOneDifferent ? * pdispIDOneDifferent : pdispIDDummy;
    
    dispIDOneDifferent = DISPID_UNKNOWN;

    pAVThis = this    ? * (CAttrArray *)this    : (const CAttrValue *) NULL;
    pAVThat = pAAThat ? * pAAThat : (const CAttrValue *) NULL;

    for ( ; ; )
    {
        //
        // Skip all internal attrs
        //
        
        while (nThisSize && pAVThis->AAType() == CAttrValue::AA_Internal)
            nThisSize--, pAVThis++;

        while (nThatSize && pAVThat->AAType() == CAttrValue::AA_Internal)
            nThatSize--, pAVThat++;

        //
        // Have we reached the end of one of the arrays?
        //

        if (nThisSize == 0 || nThatSize == 0)
        {
            if (nThisSize != nThatSize)
                dispIDOneDifferent = DISPID_UNKNOWN;
            
            return nThisSize == nThatSize && !fFoundOneAttrValueDifferent;
        }

        //
        // We now have the next non-internal attr for each array, compare them
        //

        if (pAVThat->GetDISPID() != pAVThis->GetDISPID())
        {
            dispIDOneDifferent = DISPID_UNKNOWN;
            return FALSE;
        }

        //
        // See if the attr value is different
        //

        if (!pAVThis->Compare( pAVThat ))
        {
            if (fFoundOneAttrValueDifferent)
                dispIDOneDifferent = DISPID_UNKNOWN;
                
            if (!pdispIDOneDifferent || fFoundOneAttrValueDifferent)
                return FALSE;

            fFoundOneAttrValueDifferent = TRUE;
            dispIDOneDifferent = pAVThis->GetDISPID();
        }

        //
        // One to the next attr ...
        //

        pAVThis++, nThisSize--;
        pAVThat++, nThatSize--;
    }
}



//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::HasAnyAttribute
//
//  Synopsis:   Returns TRUE when the AttrArray contains an attribute
//              or an expando (if the flag is set)
//
//-------------------------------------------------------------------------

BOOL 
CAttrArray::HasAnyAttribute(BOOL fCountExpandosToo)
{
    CAttrValue * pAV;
    CAttrValue::AATYPE aaType;

    for(int i = 0; i < Size(); i++)
    {
        pAV = ((CAttrValue *)*this) + i;
        aaType = pAV->AAType();
        if(  aaType == CAttrValue::AA_Attribute ||
            (fCountExpandosToo && aaType == CAttrValue::AA_Expando) )
            return TRUE;
    }

    return FALSE;
}
//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::HasExpandos
//
//  Synopsis:   Returns TRUE when the AttrArray contains an attribute
//              or an expando (if the flag is set)
//
//-------------------------------------------------------------------------

BOOL 
CAttrArray::HasExpandos()
{
    CAttrValue * pAV;
    CAttrValue::AATYPE aaType;

    for(int i = 0; i < Size(); i++)
    {
        pAV = ((CAttrValue *)*this) + i;
        aaType = pAV->AAType();
        if( aaType == CAttrValue::AA_Expando )
            return TRUE;
    }

    return FALSE;
}


void
CAttrArray::Clear(CAttrArray * pAAUndo)
{
    long        i;
    CAttrValue *pAV;
    DISPID      dispid;
    HRESULT     hrUndo;

    _dwChecksum = _dwChecksum & 1;

    for (i = 0, pAV = (CAttrValue *)*this; i < Size(); pAV = ((CAttrValue *)*this) + i)
    {
        if (pAV->AAType() == CAttrValue::AA_Internal)
        {
            i++;
            continue;
        }

        // preserve identity.
        dispid = pAV->GetDISPID();
        if ((DISPID_CElement_id == dispid) ||
            (STDPROPID_XOBJ_NAME == dispid) ||
            (DISPID_CElement_uniqueName == dispid))
        {
            i++;
            _dwChecksum += ((DWORD)dispid)<<1;
            continue;
        }

        hrUndo = S_OK;

        if (pAAUndo)
            hrUndo = THR( pAAUndo->AppendIndirect( pAV ) );

        if (!pAAUndo || hrUndo)
            pAV->Free();

        Delete(i);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Free
//
//  Synopsis:   Frees all members
//
//-------------------------------------------------------------------------

void
CAttrArray::Free()
{
    long        i;
    CAttrValue *pAV;

    _dwChecksum = 0;

    for (i = Size(), pAV = (CAttrValue *)*this; i > 0; i--, pAV++)
    {
        pAV->Free();
    }
    DeleteAll();
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::FreeSpecial
//
//  Synopsis:   Frees all members except so-called members with special 
//              dispids.  This exclusive list consists of the dispids
//              we reserve for special purposes (like event sinks and
//              prop notify sinks).
//
//  Notes:      This type of Free is called when the doc unloads.
//
//-------------------------------------------------------------------------

void
CAttrArray::FreeSpecial()
{
    long            i;
    CAttrValue *    pAV;

    _dwChecksum = 0;
    SetGINCache(DISPID_UNKNOWN, NULL, FALSE);

    //
    // This complex loop is needed because we're deleting out of the
    // array while iterating over it.
    //
    
    for (i = 0, pAV = (CAttrValue *)*this; 
         i < Size(); 
         pAV = ((CAttrValue *)*this) + i)
    {
        if (pAV->GetDISPID() != DISPID_A_PROPNOTIFYSINK &&
            pAV->GetDISPID() != DISPID_A_EVENTSINK &&
            pAV->GetDISPID() != DISPID_AAHEADER &&
            pAV->GetDISPID() != DISPID_INTERNAL_INVOKECONTEXT )
        {
            pAV->Free();
            Delete(i);
        }
        else
        {
            i++;

            if (pAV->AAType() != CAttrValue::AA_Internal)
                _dwChecksum += (pAV->GetDISPID())<<1;
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Find
//
//  Synopsis:   Find CAttrValue given _dispID
//
//              The paaIdx is the index to start searching at if this value
//              is AA_IDX_UNKNOWN, then find first occurance.  If something
//              else then find the next occurance beyond AAINDEX which matches
//              thedispID.  The index of the CAttrValue returned is set in
//              paaIdx (this pointer can be NULL, if so then Find will always
//              return the first occurance of thedispID).
//
//-------------------------------------------------------------------------

CAttrValue*
CAttrArray::Find(
    DISPID              thedispID, 
    CAttrValue::AATYPE  aaType, 
    AAINDEX *           paaIdx,
    BOOL                fAllowMultiple)
{
    CAttrValue *    pAVBase;
    CAttrValue *    pAV;
    AAINDEX         aaIndx;
    
    if ( aaType == CAttrValue::AA_StyleAttribute )
    {
        aaType = CAttrValue::AA_Attribute;
    }

    if (paaIdx == NULL)
    {
        aaIndx = AA_IDX_UNKNOWN;
        paaIdx = &aaIndx;
    }

    // If thedispID is DISPID_UNKNOWN and *paaIdx is AA_IDX_UNKNOWN then
    // we're looking for the first occurance of the aaType.  Which we can
    // search linearly.

    // Yes, find first occurance.
    if (thedispID == DISPID_UNKNOWN)
    {
        int nCount;
        if ( !Size() )
            goto NotFound;

        // Linear search
        for ( nCount = *paaIdx + 1, pAV = ((CAttrValue*)*this) + nCount;
              nCount < Size();
              nCount++, pAV++ )
        {
            // We check with a bitwise & on the aatype so that the style and
            // attribute types are picked up
            if ( pAV->AAType() == aaType )
            {
                *paaIdx = nCount;
                thedispID = pAV->GetDISPID();
                goto UpdateCache;
            }
        }

NotFound:
        *paaIdx = AA_IDX_UNKNOWN;
    }
    else
    {
        int  nPos, nMin, nMax, nCompare;

        Assert(*paaIdx == AA_IDX_UNKNOWN);
        
        // Binary search
        pAVBase = (CAttrValue*)*this;

        //
        // Check cache first, but only if not accounting for multiple
        // entries of the same dispid.
        //
        
        for ( nPos = 0, nCompare = 0, nMin = 0, nMax = Size(); nMin < nMax ; )
        {
            nPos = (nMax + nMin) / 2;
            pAV = pAVBase + nPos;

            // Check sort order based on (DISPID,AATYPE) pair
            nCompare = pAV->CompareWith ( thedispID, aaType );

            if ( nCompare == 0 )
            {
                *paaIdx = pAV - pAVBase;
                goto UpdateCache;
            }
            else if ( nCompare < 0 )
            {
                nMax = nPos;
            }
            else
            {
                nMin = nPos + 1;
            }
        }
        // Calculate the insertion point for a new (DISPID,AATYPE)
        if ( nCompare == +1 )
        {
            *paaIdx = (AAINDEX)++nPos;        
        }
        else
        {
            *paaIdx = (AAINDEX)nPos;
        }
    }
    // Didn't find it
    return NULL;

UpdateCache:
    Assert(thedispID != DISPID_UNKNOWN && *paaIdx != AA_IDX_UNKNOWN);

    //
    // If multiple entries for the same dispid are allowed, then 
    // return the very first one.
    //
    
    if (fAllowMultiple)
    {

        ULONG   ulPos;
        
        for (ulPos = *paaIdx, pAV = ((CAttrValue*)*this) + ulPos;
             ;
             ulPos--, pAV--)
        {
            //
            // Catch the case when we're iterating down and we  
            // extend beyond the beginning or a change in dispid occurs  
            // AND we need to return the first instance of the dispid.
            //
            
            if (ulPos == AA_IDX_UNKNOWN || 
                pAV->GetDISPID() != thedispID ||
                pAV->AAType() != aaType ||
                ulPos >= (ULONG)Size())
            {
                ulPos++;
                pAV++;
                break;
            }
        }

        *paaIdx = (AAINDEX)ulPos;
    }
    
    return pAV;
}


BOOL
CAttrArray::FindString ( CAttrArray *pAA, const PROPERTYDESC *pPropertyDesc, LPCTSTR *ppStr )
{
    if ( pAA && pAA->FindString ( pPropertyDesc->GetDispid(), ppStr, CAttrValue::AA_Attribute ) )
        return TRUE;

    *ppStr = (LPTSTR)pPropertyDesc->ulTagNotPresentDefault;
    return FALSE;
}

BOOL
CAttrArray::FindString ( DISPID dispID, LPCTSTR *ppStr,
    CAttrValue::AATYPE aaType  ,
    const PROPERTYDESC **ppPropertyDesc )
{
    Assert(ppStr);

    CAttrValue *pAV = Find ( dispID, aaType );
    if ( pAV )
    {
        *ppStr = pAV->GetLPWSTR();
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
CAttrArray::FindSimple ( CAttrArray *pAA, const PROPERTYDESC *pPropertyDesc, DWORD *pdwValue )
{
    if ( pAA && pAA->FindSimple ( pPropertyDesc->GetDispid(), pdwValue, CAttrValue::AA_Attribute ) )
        return TRUE;

    *pdwValue = (DWORD)pPropertyDesc->ulTagNotPresentDefault;
    return FALSE;
}

BOOL
CAttrArray::FindSimple ( DISPID dispID, DWORD *pdwValue,
    CAttrValue::AATYPE aaType ,
    const PROPERTYDESC **ppPropertyDesc )
{
    Assert(pdwValue);

    CAttrValue *pAV = Find ( dispID, aaType );
    if ( pAV )
    {
        *pdwValue = (DWORD)pAV->GetLong();
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CAttrArray::FindSimpleInt4AndDelete( DISPID dispID, DWORD *pdwValue,
    CAttrValue::AATYPE aaType ,
    const PROPERTYDESC **ppPropertyDesc )
{
    AAINDEX aaIdx = AA_IDX_UNKNOWN;
    Assert(pdwValue);

    CAttrValue *pAV = Find ( dispID, aaType, &aaIdx );
    if ( pAV )
    {
        *pdwValue = (DWORD)pAV->GetLong();
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        Destroy( aaIdx );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CAttrArray::FindSimpleAndDelete( DISPID dispID,
    CAttrValue::AATYPE aaType ,
    const PROPERTYDESC **ppPropertyDesc )
{
    AAINDEX aaIdx = AA_IDX_UNKNOWN;

    CAttrValue *pAV = Find ( dispID, aaType, &aaIdx );
    if ( pAV )
    {
        Assert ( pAV->GetAVType() == VT_LPWSTR );
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        Destroy( aaIdx );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


HRESULT
CAttrArray::SetAt (AAINDEX aaIdx, VARIANT *pvarNew)
{
    CAttrValue *pAV = *this;
    HRESULT hr = E_FAIL;

    if (aaIdx != AA_IDX_UNKNOWN && aaIdx < ULONG(Size()))
    {
        // Change an existing one
        // CRC doesn't change cos we didn't add a new dispid
        (pAV + aaIdx)->Free();

        // Copy in new VARIANT
        hr = THR((pAV + aaIdx)->InitVariant ( pvarNew ));
    }

    RRETURN(hr);
}



HRESULT
CAttrArray::Set (
    DISPID dispID,
    const PROPERTYDESC *pProp,
    VARIANT *pvarNew,
    CAttrValue::AATYPE aaType,
    WORD wFlags,
    BOOL fAllowMultiple)
{
    // For changing non-unique values the SetAt function must be used. This Set
    // routine allows for adding both unique and non-unique and changing unique
    // only values.
    HRESULT hr = S_OK;
    CAttrValue avNew;
    CAttrValue *pAV;
    AAINDEX aaIdx = AA_IDX_UNKNOWN;

    Assert ( pvarNew );
    Assert ( dispID != DISPID_UNKNOWN );
    Assert ((pProp && (pProp->GetDispid() == dispID)) || !pProp);

    // If we don't find the attribute, aaIdx will be set to the insertion point
    pAV = Find(dispID, aaType, &aaIdx ) ;

    if ((aaType == CAttrValue::AA_UnknownAttr) &&
        (wFlags & CAttrValue::AA_Extra_DefaultValue) &&
        !pAV)
    {
        Assert(aaIdx != AA_IDX_UNKNOWN);
        CAttrValue *pAVPrev = FindAt(aaIdx-1);
        // NOTE (sramani): when (& if) DESTROY_DEFAULT is turned off these if
        // conditions can be turned into asserts.
        if (pAVPrev &&
            pAVPrev->GetDISPID() == dispID &&
            pAVPrev->AAType() == CAttrValue::AA_Attribute)
            pAVPrev->SetDefault(TRUE);
    }

    // Add a new one if not found or if we don't want a unique one.  If a multiple
    // one needs to be change then use the CBase helpers ChangeAt functions.
    if (!pAV || fAllowMultiple)
    {
#if DESTROY_DEFAULT // explicitly store default values
        // Need a new one
        if ( pProp && IsDefaultValue ( pProp, pvarNew ) && !(wFlags & CAttrValue::AA_Extra_RuntimeStyle) &&
            ( aaType == CAttrValue::AA_StyleAttribute || 
              !( TLS(fPersistDefaultValues) WHEN_DBG( || IsTagEnabled(tagPersistDefaultValues) ) ) ) )
        {
            // Don't bother
            goto Cleanup;
        }
#endif
        avNew.SetAAType ( aaType );

        // if the AAType warrants a propdesc, but pProp == NULL,
        // as might be the case when storing a CFuncPtr *, store in _dispid
        if (pProp)
            avNew.SetPropDesc(pProp);
        else
            avNew.SetDISPID(dispID);

        hr = THR ( avNew.InitVariant ( pvarNew ) );
        if ( hr )
            goto Cleanup;

        avNew.SetImportant( wFlags & CAttrValue::AA_Extra_Important );
        avNew.SetImplied( wFlags & CAttrValue::AA_Extra_Implied );
        avNew.SetTridentSink( wFlags & CAttrValue::AA_Extra_TridentEvent );
        avNew.SetOldEventStyle( wFlags & CAttrValue::AA_Extra_OldEventStyle );
        avNew.SetExpression( FALSE );

        hr = THR(InsertIndirect( aaIdx, &avNew ));
        if ( hr )
            goto Cleanup;

        if(aaType != CAttrValue::AA_Internal)
            _dwChecksum += ((DWORD)dispID)<<1;
        else if (dispID == DISPID_INTERNAL_CSTYLEPTRCACHE || dispID == DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE)
            SetStylePtrCachePossible();
    }
    else
    {
#if DESTROY_DEFAULT // explicitly store default values
        // Change an existing one
        if ( pProp && IsDefaultValue ( pProp, pvarNew ) && !(wFlags & CAttrValue::AA_Extra_RuntimeStyle) &&
            ( aaType == CAttrValue::AA_StyleAttribute ||
              !( TLS(fPersistDefaultValues) WHEN_DBG( || IsTagEnabled(tagPersistDefaultValues) ) ) ) )
        {
            // We're setting the attribute to its default value -
            // remove it from the attr array
            Destroy ( pAV-((CAttrValue*)*this) );
            goto Cleanup;
        }
#endif
        // Copy in new VARIANT
        pAV->Free();
        pAV->SetAAType ( aaType );
        pAV->SetImportant( wFlags & CAttrValue::AA_Extra_Important );
        pAV->SetImplied( wFlags & CAttrValue::AA_Extra_Implied );
        pAV->SetTridentSink( wFlags & CAttrValue::AA_Extra_TridentEvent );
        pAV->SetOldEventStyle( wFlags & CAttrValue::AA_Extra_OldEventStyle );
        pAV->SetExpression(FALSE);
        hr = THR(pAV->InitVariant ( pvarNew ));
    }

Cleanup:
    RRETURN(hr);
}


/* static */
HRESULT
CAttrArray::Set(
    CAttrArray **ppAA,
    DISPID dispID,
    VARIANT *pvarNew,
    const PROPERTYDESC *pProp /* = NULL */,
    CAttrValue::AATYPE aaType /* = CAttrValue::AA_Attribute */,
    WORD wFlags,
    BOOL fAllowMultiple)
{
    HRESULT hr = S_OK;

    Assert(ppAA);
    if (!*ppAA)
    {
        *ppAA = new CAttrArray;
        if (!*ppAA)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    hr = THR((*ppAA)->Set ( dispID, pProp, pvarNew, aaType, wFlags, fAllowMultiple));
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Destroy
//
//  Synopsis:   Destroys attribute referenced by supplied index
//
//-------------------------------------------------------------------------
void
CAttrArray::Destroy(int iIndex)
{
    CAttrValue *pAV;

    Assert(iIndex>=0);
    Assert(iIndex<Size());

    pAV = ((CAttrValue*) *this) + iIndex;

    // Remove DISPID from checksum
    if (pAV->AAType() != CAttrValue::AA_Internal)
        _dwChecksum -= ((DWORD)pAV->GetDISPID())<<1;

    pAV->Free();
    Delete(iIndex);
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::SetSimple
//
//  Synopsis:   Static function that lets you store a simple types into
//              an AttrArray.  This creates both the AttrArray and AttrValue
//              if needed.  The caller still needs to call consolidate, as
//              the insertion may have messed up the sort order.
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::SetSimple(CAttrArray **ppAA, const PROPERTYDESC *pPropertyDesc, DWORD dwSimple, WORD wFlags )
{
    VARIANT varNew;
    DWORD dwPPFlags = pPropertyDesc->GetPPFlags();
    CAttrValue::AATYPE aaType;

    varNew.vt = VT_I4;
    varNew.lVal = (long)dwSimple;

    if ( dwPPFlags & PROPPARAM_STYLISTIC_PROPERTY )
    {
        aaType = CAttrValue::AA_StyleAttribute;
    }
    else
    {
        aaType = CAttrValue::AA_Attribute;
    }

    RRETURN ( CAttrArray::Set (ppAA, pPropertyDesc->GetDispid(), &varNew, pPropertyDesc, aaType, wFlags ) );
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::SetString
//
//  Synopsis:   Static function that lets you store a TCHAR* into
//              an AttrArray.  This creates both the AttrArray and AttrValue
//              if needed.  The caller still needs to call consolidate, as
//              the insertion may have messed up the sort order and has
//              not converted the input to a cookie
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::SetString(CAttrArray **ppAA, const PROPERTYDESC *pPropertyDesc, LPCTSTR pch,
    BOOL fIsUnknown /* = FALSE */, WORD wFlags /*=0*/ )
{
    VARIANT varNew;
    DWORD dwPPFlags = pPropertyDesc->GetPPFlags();
    CAttrValue::AATYPE aaType;

    varNew.vt = VT_LPWSTR;
    varNew.byref = (LPVOID)pch;

    if ( fIsUnknown )
    {
        aaType = CAttrValue::AA_UnknownAttr;
    }
    else
    {
        if ( dwPPFlags & PROPPARAM_CUSTOMENUM )
        {
            aaType = CAttrValue::AA_CustomProperty;
        }
        else if ( dwPPFlags & PROPPARAM_STYLISTIC_PROPERTY )
        {
            aaType = CAttrValue::AA_StyleAttribute;
        }
        else
        {
            aaType = CAttrValue::AA_Attribute;
        }
    }
    RRETURN ( CAttrArray::Set (ppAA, pPropertyDesc->GetDispid(), &varNew, pPropertyDesc, aaType, wFlags ) );
}



HRESULT
CAttrArray::GetSimpleAt(AAINDEX aaIdx, DWORD *pdwValue)
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    const CAttrValue   *pAV;

    Assert(pdwValue);
    Assert(this);

    // Any attr array?
    pAV = FindAt(aaIdx);
    // Found AttrValue?
    if (pAV)
    {
        *pdwValue = (DWORD)pAV->GetLong();
        hr = S_OK;
    }

    RRETURN(hr);
}

AAINDEX
CAttrArray::FindAAIndex(
    DISPID              dispID, 
    CAttrValue::AATYPE  aaType, 
    AAINDEX             aaLastOne,
    BOOL                fAllowMultiple)
{
    return (Find(dispID, aaType, &aaLastOne, fAllowMultiple)) ? 
        aaLastOne : 
        AA_IDX_UNKNOWN;
}




CAttrValue *
CAttrArray::EnsureHeader(BOOL fCreate)
{
    CAttrValue *pAV = (CAttrValue*)*this;

    if (Size() && (pAV->GetAVType() == CAttrValue::VT_AAHEADER))
        return pAV;

    if (fCreate)
    {
        if (SetHeader())
            goto Cleanup;

        return (CAttrValue*)*this;
    }

Cleanup:
    return NULL;
}

HRESULT
CAttrArray::SetHeader()
{
    HRESULT hr = S_OK;
    CAttrValue avNew;
    CAttrArrayHeader *pAAHeader = new CAttrArrayHeader;
    if (!pAAHeader)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    avNew.SetDISPID(DISPID_AAHEADER);
#ifdef _MAC
    avNew.SetAAType(CAttrValue::AA_Internal);
#else
    avNew.SetAAType(CAttrValue::AATYPE::AA_Internal);
#endif
    avNew.SetAAHeader(pAAHeader);
    avNew.SetCachedDispid(DISPID_UNKNOWN);
    avNew.SetCachedVTblDesc(NULL);
    avNew.SetEventsToHook(NULL);

    hr = THR(InsertIndirect(0, &avNew));

Cleanup:
    if (hr && pAAHeader)
        delete pAAHeader;

    return hr;
}

DISPID CAttrArray::GetCachedDispidGIN()
{
    CAttrValue *pAV = EnsureHeader(FALSE);
    return pAV ? pAV->GetCachedDispid() : DISPID_UNKNOWN;
}

const VTABLEDESC *CAttrArray::GetCachedVTableDesc()
{
    CAttrValue *pAV = EnsureHeader(FALSE);
    return pAV ? pAV->GetCachedVTblDesc() : NULL;
}

void CAttrArray::SetGINCache(DISPID dispid, const VTABLEDESC *pVTblDesc, BOOL fCreate /*= TRUE*/)
{
    CAttrValue *pAV = EnsureHeader(fCreate);
    if (!pAV)
        return;

    Assert(pAV->GetAAHeader());
    pAV->SetCachedDispid(dispid);
    pAV->SetCachedVTblDesc(pVTblDesc);
}

const VTABLEDESC * CAttrArray::FindInGINCache(DISPID dispid)
{ 
    // First, look in the normal GIN cache
    if(dispid == GetCachedDispidGIN())
        return GetCachedVTableDesc();
    else if (dispid == DISPID_CWindow_document)
        return COmWindowProxy::s_COmWindowProxyDocument;
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\acctable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccTable.Cxx
//
//  Contents:   Accessible table and table cell object implementations
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCTABLE_HXX_
#define X_ACCTABLE_HXX_
#include "acctable.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE__HXX_
#include "table.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE__HXX_
#include "ltable.hxx"
#endif

#ifndef X_TCELL_HXX_
#define X_TCELL_HXX_
#include "tcell.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccTable
//  
//  DESCRIPTION:    
//      The table accessible object constructor
//
//  PARAMETERS:
//      Pointer to the element 
//----------------------------------------------------------------------------
CAccTable::CAccTable( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_TABLE );
}



//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns the innertext of the first caption tag that is contained
//      in this object. If there is no title and not caption, the method is
//      not implemented.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTable::GetAccName( BSTR* pbstrName )
{
    HRESULT           hr= S_OK;
    TCHAR           * pchString = NULL;
    CTableCaption   * pCaption = NULL;
    CTableLayout    * pTableLayout = NULL;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    //get the title 
    pchString = (LPTSTR) _pElement->GetAAtitle();
    if ( pchString )
    {
        *pbstrName = SysAllocString( pchString );
        if ( !(*pbstrName) )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        // check if the table has a caption. If it does, return 
        // inner text from the caption
        pTableLayout = (DYNCAST( CTable, _pElement))->TableLayoutCache();
        
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;

        pCaption = pTableLayout->GetFirstCaption();

        if (pCaption)
        {
            hr = THR( pCaption->get_innerText( pbstrName ) );
        }
        else
            hr = E_NOTIMPL;
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Same as the GetAccName
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTable::GetAccDescription( BSTR* pbstrDescription )
{
    HRESULT           hr;
    CTableCaption   * pCaption = NULL;
    CTableLayout    * pTableLayout = NULL;
    BSTR              bstrTemp = NULL;

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDescription = NULL;

    // check if the table has a caption. If it does, return 
    // inner text from the caption
    pTableLayout = (DYNCAST( CTable, _pElement))->TableLayoutCache();
    
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    // if there is a title then it went into name and the caption 
    // should be the description.  otherwise there is no description.
    //--------------------------------------------------------------
    hr = GetTitle(&bstrTemp);
    if (hr)
        goto Cleanup;
    else
    {
        SysFreeString(bstrTemp);
        hr = S_OK;
        pCaption = pTableLayout->GetFirstCaption();

        if (pCaption)
        {
            hr = THR( pCaption->get_innerText( pbstrDescription ) );
        }
        // else just return a blank string
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_NORMAL
//      if not visible, then STATE_SYSTEM_INVISIBLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTable::GetAccState( VARIANT *pvarState)
{
    // validate out parameter
    if ( !pvarState )
        return ( E_POINTER );       
    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    //check visibility
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) = STATE_SYSTEM_INVISIBLE;
        
    return S_OK;
}

//----------------------------------------------------------------------------
//  CAccTableCell
//  
//  DESCRIPTION:    
//      The table cell accessible object constructor
//
//  PARAMETERS:
//      Pointer to the element 
//----------------------------------------------------------------------------
CAccTableCell::CAccTableCell( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_CELL );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title. Otherwise method not 
//      implemented
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTableCell::GetAccName( BSTR* pbstrName )
{
    HRESULT           hr = S_OK;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    //get the title or label
    hr = GetTitleorLabel(pbstrName);

    if (!*pbstrName)
    {
        hr = E_NOTIMPL;
    }

Cleanup:
    RRETURN1( hr, E_NOTIMPL );
}



//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_NORMAL
//      if not visible, then STATE_SYSTEM_INVISIBLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTableCell::GetAccState( VARIANT *pvarState)
{
    // validate out parameter
    if ( !pvarState )
        return E_POINTER;
    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    //check visibility
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) = STATE_SYSTEM_INVISIBLE;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\acctab.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccTab.Cxx
//
//  Contents:   Accessible object for a (generic) element that has a tabstop, but
//              would otherwise be unsupported 
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCTAB_HXX_
#define X_ACCTAB_HXX_
#include "acctab.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif


//-----------------------------------------------------------------------
//  CAccTabStopped::CAccTabStopped()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  :   Address of the CElement that hosts this 
//                          object.
//----------------------------------------------------------------------
CAccTabStopped::CAccTabStopped( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );

    //initialize the instance variables, since this is sort of 
    // a generic element, we would like to set a role that aprximates
    // the role that this element is playing on the page. Note that 
    // none of the tags listed below are specified in the supported
    // element list.
    switch (pElementParent->Tag())
    {
    case ETAG_LI:
    case ETAG_OL:
    case ETAG_UL:
    case ETAG_DD:
    case ETAG_DL:
    case ETAG_DT:
        SetRole( ROLE_SYSTEM_LISTITEM );
        break;

    case ETAG_HR:
        SetRole( ROLE_SYSTEM_SEPARATOR );
        break;

    case ETAG_DIV:
    case ETAG_SPAN:
        SetRole( ROLE_SYSTEM_GROUPING );
        break;

    default:
        SetRole( ROLE_SYSTEM_TEXT );
        break;
    }
}

CAccLabel::CAccLabel( CElement* pElementParent )
:CAccTabStopped(pElementParent)
{
    SetRole( ROLE_SYSTEM_STATICTEXT );
}

//----------------------------------------------------------------------------
//  helper : GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty return it. Otherwise return the innerText value 
//  
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTabStopped::GetAccName( BSTR* pbstrName)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    hr = GetTitleorLabel(pbstrName);
    if (hr || !*pbstrName)
    {
        hr = THR( _pElement->get_innerText( pbstrName ) );
    }
    

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  helper : GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty return the innerText, else return nothing 
//  
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTabStopped::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    BOOL    fNeedText;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    // check for the title attribute, then toss the string
    hr = GetTitle( pbstrDescription );
    fNeedText = (hr == S_OK && *pbstrDescription);

    SysFreeString(*pbstrDescription);
    *pbstrDescription = NULL;
    hr = S_OK;

    // if we had a title, return the innerText, else nothing
    if (fNeedText)
    {
        hr = THR( _pElement->get_innerText( pbstrDescription ) );
    }


Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  member : GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_Focusable 
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTabStopped::GetAccState(VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CAccBase * pParentA =NULL;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

     // first, if we have an anchor parent set our state to its state
    pParentA = GetParentAnchor();

    //if we have  an anchor, assume its state
    if (pParentA)
    {
        hr = THR( DYNCAST(CAccElement, pParentA)->GetAccState( pvarState ) );
    }
    else 
    {
        V_VT( pvarState ) = VT_I4;
        V_I4( pvarState ) = 0;        
    
        if ( !_pElement->IsEnabled() )
            V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
        else
        {
            if ( IsFocusable(_pElement) )
                V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
            if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
                V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;

            if (!_pElement->IsVisible(FALSE))
                V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
        }
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  helper : GetAccValue
//  
//  DESCRIPTION:
//      If the parent is an anchor, delegate to the anchor. If not, Nothing.
//  
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTabStopped::GetAccValue( BSTR* pbstrValue)
{
    HRESULT     hr = S_OK;
    CAccBase *  pParentA = NULL;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    //get the parent and see if it is an anchor.
    pParentA = GetParentAnchor();

    //if parent is an anchor, delegate the call. otherwise return S_OK and
    // a NULL string
    if (pParentA )
    {
        hr = THR( DYNCAST(CAccElement, pParentA)->GetAccValue( pbstrValue ));
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  member : get_accKeyboardShortCut
//  
//  DESCRIPTION :   
//          Returns the keyboard shortcut if there is one.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccTabStopped::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;
    CStr            accessString;
    CStr            sString;    

    // validate out parameter
     if ( !pbstrKeyboardShortcut )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrKeyboardShortcut = NULL;
    
    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // get the actual key combination value
        hr = THR (accessString.Set( _pElement->GetAAaccessKey() ) );
        if ( hr )
            goto Cleanup;

        // if there is an access key string
        if ( accessString.Length() > 0 )
        {
            // we want all keyboard shortcut values to contain 'Alt+' 
            hr = THR( sString.Set( _T("Alt+") ) );
            if ( hr )
                goto Cleanup;
            
            hr = THR( sString.Append( accessString ) );
            if ( hr )
                goto Cleanup;
                
            hr = THR( sString.AllocBSTR( pbstrKeyboardShortcut ) );
        }                
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //no keyboard shortcuts for plain text, unless a parent is an anchor
            CAccBase * pParentA = GetParentAnchor();
            CVariant   varChildSelf;

            V_VT(&varChildSelf) = VT_I4;
            V_I4(&varChildSelf) = CHILDID_SELF;

            //delegate this call 
            hr = (!pParentA) ? S_OK :
                THR( pParentA->get_accKeyboardShortcut(varChildSelf, pbstrKeyboardShortcut) );
        }
        else 
        {
            // call child's implementation of this method. 
            V_I4( &varChild ) = CHILDID_SELF;
            hr = THR( pAccChild->get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut) );
        }
    }

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\bindhost.cxx ===
//+------------------------------------------------------------------------
//
//  File:       docurl.cxx
//
//  Contents:   url helpers, etc.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifdef WIN16

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_URLMKI_H_
#define X_URLMKI_H_
#include "urlmki.h"
#endif

#endif

BOOL IsUrlOnNet(const TCHAR *pchUrl);
BOOL IsSpecialUrl(LPCTSTR pszURL);

MtDefine(GetBaseTarget, Utilities, "CMarkup::GetBaseTarget")
MtDefine(GetFriendlyUrl, Utilities, "CMarkup::GetFriendlyUrl")
MtDefine(Url, CMarkup, "Urls");
MtDefine(SetUrl, Url, "CMarkup::SetUrl")
MtDefine(SetUrlOriginal, Url, "CMarkup::SetUrlOriginal")
MtDefine(ExpandUrlWithBaseUrl, Utilities, "ExpandUrlWithBaseUrl")

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetBaseTarget
//
//              Get the base URL for the document.
//
//              If supplied with an element, gets the base TARGET in effect
//              at that element, based on the position of <BASE> tags.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::GetBaseTarget(
    TCHAR **    ppchTarget, 
    CElement *  pElementContext)
{
    TCHAR       *pchTarget = NULL;
    TCHAR       *pchTargetTemp;
    HRESULT      hr = S_OK;
    CTreeNode   *pNode;

    if (pElementContext && pElementContext->GetFirstBranch())
    {
        //  Search the body upwards for first Base tag with target attribute
        for (pNode = pElementContext->GetFirstBranch()->Parent(); 
             pNode; 
             pNode=pNode->Parent())
        {
            if (pNode->Tag() == ETAG_BASE)
            {
                pchTargetTemp = (LPTSTR) DYNCAST(CBaseElement, pNode->Element())->GetAAtarget();
                if (pchTargetTemp && *pchTargetTemp)
                {
                    pchTarget = pchTargetTemp;
                    break;
                }
            }
        }
    }

    if (pchTarget == NULL && pElementContext && pElementContext->IsInMarkup())
    {
        CElement * pElementHead = pElementContext->GetMarkup()->GetHeadElement();
        if (pElementHead)
        {
            CChildIterator ci (pElementHead);
            CTreeNode * pNode;

            ci.SetAfterEnd();

            while ((pNode = ci.PreviousChild()) != NULL)
            {
                if (pNode->Tag() == ETAG_BASE)
                {
                    pchTargetTemp = LPTSTR(DYNCAST(CBaseElement, pNode->Element())->GetAAtarget());
                    
                                    
                    if (pchTargetTemp && *pchTargetTemp)
                    {
                        pchTarget = pchTargetTemp;
                        break;
                    }
                }
            }
        }
    }

    *ppchTarget = NULL;
    if (pchTarget)
    {
        hr = THR(MemAllocString(Mt(GetBaseTarget), pchTarget, ppchTarget));
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member  : CMarkup::GetUrl
//
//  Synopsis: Retrieve the default url for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrl(CMarkup * pMarkupThis)
{
    if (pMarkupThis && pMarkupThis->HasLocationContext())
    {
        CMarkupLocationContext * pmlc = pMarkupThis->GetLocationContext();

        if (pmlc->_pchUrl)
            return pmlc->_pchUrl;
    }

    return _T("about:blank");
}

//+---------------------------------------------------------------------------
//
//  Member  : CMarkup::SetUrl
//
//  Synopsis: Sets the default url for this markup.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrl(CMarkup * pMarkupThis, LPCTSTR pchUrl)
{
    HRESULT hr = E_FAIL;
    TCHAR * pchAlloc = NULL;
    CStr    cstrUrl;

    // check for %01 attacks
    cstrUrl.Set(pchUrl);
    hr = THR(UnescapeAndTruncateUrl(cstrUrl));
    if(hr)
        goto Cleanup;
    
    if (pMarkupThis)
    {
        if (pMarkupThis->Url() == pchUrl)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (pchUrl)
        {
            hr = THR(MemAllocString(Mt(SetUrl), pchUrl, &pchAlloc));
            if (hr)
                goto Cleanup;
        }

        MemFreeString(pMarkupThis->DelUrl());

        // Clear the URL location
        MemFreeString(pMarkupThis->DelUrlLocationPtr());

        if (pchAlloc)
        {
            hr = pMarkupThis->SetUrl(pchAlloc);
            if (hr)
                goto Cleanup;

            pchAlloc = NULL;
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlOriginal
//
//  Synopsis:   Retrieves the default original url for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrlOriginal(CMarkup * const pMarkupThis)
{
    if (pMarkupThis && pMarkupThis->HasLocationContext())
    {
        CMarkupLocationContext * pmlc = pMarkupThis->GetLocationContext();

        if (pmlc->_pchUrlOriginal)
            return pmlc->_pchUrlOriginal;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlOriginal
//
//  Synopsis:   Retrieves the default original url for this markup.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrlOriginal(CMarkup * pMarkupThis, const TCHAR * const pszUrlOriginal)
{
    HRESULT hr = E_FAIL;
    TCHAR * pchAlloc = NULL;

    Assert(pMarkupThis);

    if (pMarkupThis->UrlOriginal() == pszUrlOriginal)
    {
        hr = S_OK;
        goto Cleanup;
    }
    
    if (pszUrlOriginal)
    {
        hr = THR(MemAllocString(Mt(SetUrlOriginal), pszUrlOriginal, &pchAlloc));
        if (hr)
            goto Cleanup;
    }

    hr = pMarkupThis->SetUrlOriginal(pchAlloc);  // Passing NULL frees the string.
    if (hr)
        goto Cleanup;

    pchAlloc = NULL;

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlLocation
//
//  Synopsis:   Retrieve the default url location for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrlLocation(CMarkup * pMarkupThis)
{
    TCHAR * pchLocation=NULL;
    if (pMarkupThis)
    {
        pchLocation = pMarkupThis->UrlLocationPtr();
    }

    if (pchLocation)
        return pchLocation;

    return _T("");
}

HRESULT
CMarkup::SetUrlLocation(CMarkup * pMarkupThis, LPCTSTR pchUrlLocation)
{
    HRESULT hr       = E_FAIL;
    TCHAR * pchAlloc = NULL;
    
    if (pMarkupThis)
    {
        if (pMarkupThis->UrlLocationPtr() == pchUrlLocation)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (pchUrlLocation)
        {
            hr = THR(MemAllocString(Mt(SetUrl), pchUrlLocation, &pchAlloc));
            if (hr)
                goto Cleanup;
        }

        MemFreeString(pMarkupThis->DelUrlLocationPtr());

        if (pchAlloc)
        {
            hr = pMarkupThis->SetUrlLocationPtr(pchAlloc);
            if (hr)
                goto Cleanup;

            pchAlloc = NULL;
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlSearch
//
//  Synopsis:   Retrieve the default url search component for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrlSearch(CMarkup * pMarkupThis)
{
    TCHAR * pchSearch=NULL;
    if (pMarkupThis)
    {
        pchSearch = pMarkupThis->UrlSearchPtr();
    }

    if (pchSearch)
        return pchSearch;

    return _T("");
}


HRESULT
CMarkup::SetUrlSearch(CMarkup * pMarkupThis, LPCTSTR pchUrlSearch)
{
    HRESULT hr       = E_FAIL;
    TCHAR * pchAlloc = NULL;
    
    if (pMarkupThis)
    {
        if (pMarkupThis->UrlSearchPtr() == pchUrlSearch)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (pchUrlSearch)
        {
            hr = THR(MemAllocString(Mt(SetUrl), pchUrlSearch, &pchAlloc));
            if (hr)
                goto Cleanup;
        }

        MemFreeString(pMarkupThis->DelUrlSearchPtr());

        if (pchAlloc)
        {
            hr = pMarkupThis->SetUrlSearchPtr(pchAlloc);
            if (hr)
                goto Cleanup;

            pchAlloc = NULL;
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetBaseUrl
//
//              Get the base URL for the document.
//
//              If supplied with an element, gets the base URL in effect
//              at that element, based on the position of <BASE> tags.
//              Note that this is a pointer to an internal string, it can't
//              be modified. If you need to modify it, make a copy first.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::GetBaseUrl(
    CMarkup *  pMarkupThis,
    TCHAR * *  ppchHref,
    CElement * pElementContext,
    BOOL *     pfDefault,
    TCHAR *    pszAlternateDocUrl )
{
    Assert(pMarkupThis || pElementContext);
    
    TCHAR *     pchHref = NULL;
    TCHAR    *  pchHrefTemp;
    BOOL        fDefault;
    HRESULT     hr=S_OK;
    CTreeNode * pNode;
    CDoc *      pDoc;

    if (    !pMarkupThis
        &&  pElementContext
        &&  pElementContext != EXPANDIGNOREBASETAGS)
    {
        pMarkupThis = pElementContext->GetMarkup();

        if (!pMarkupThis)
        {
            pMarkupThis = pElementContext->Doc()->PrimaryMarkup();
        }
    }

    pDoc = (pElementContext && pElementContext != EXPANDIGNOREBASETAGS) ? 
                pElementContext->Doc() : 
                pMarkupThis ? pMarkupThis->Doc() : NULL;

    Assert(!!GetUrl(pMarkupThis));
    Assert(pDoc);

    if (pElementContext != EXPANDIGNOREBASETAGS && pDoc->_fHasBaseTag)
    {
        if (pElementContext)
        {
            CTreeNode * pNodeContext = pElementContext->GetFirstBranch();

            if (pNodeContext)
            {
                //  Search the body upwards for first Base tag with href attribute
                for ( pNode = pNodeContext->Parent() ; 
                      pNode ; 
                      pNode = pNode->Parent() )
                {
                    if (pNode->Tag() == ETAG_BASE)
                    {
                        pchHrefTemp = (LPTSTR) DYNCAST(CBaseElement, pNode->Element())->GetHref();

                        if (pchHrefTemp && *pchHrefTemp)
                        {
                            pchHref = pchHrefTemp;
                            break;
                        }
                    }
                }
            }
        }

        if (pchHref == NULL && pMarkupThis)
        {
            CHeadElement * pHead = pMarkupThis->GetHeadElement();
            if (pHead)
            {
                CChildIterator ci ( pHead, NULL, CHILDITERATOR_DEEP );
                CTreeNode * pNode;

                ci.SetAfterEnd();

                while ( (pNode = ci.PreviousChild()) != NULL )
                {
                    if (pNode->Tag() == ETAG_BASE)
                    {
                        pchHrefTemp = LPTSTR (DYNCAST( CBaseElement, pNode->Element() )->GetHref() );
                    
                        if (pchHrefTemp && *pchHrefTemp)
                        {
                            pchHref = pchHrefTemp;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (pchHref == NULL)
    {
        if (pszAlternateDocUrl)
        {
            *ppchHref = pszAlternateDocUrl; 
        }
        else if (IsSpecialUrl((TCHAR *)GetUrl(pMarkupThis)) && 
                    pMarkupThis->GetAAcreatorUrl())
        {
            *ppchHref = (TCHAR *)pMarkupThis->GetAAcreatorUrl();
        }
        else
        {
            *ppchHref = (TCHAR *)GetUrl(pMarkupThis);
        }

        fDefault = TRUE;
    }
    else
    {
        *ppchHref = pchHref;
        fDefault = FALSE;
    }

    if (pfDefault)
        *pfDefault = fDefault;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ExpandUrl
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ExpandUrl(CMarkup *  pMarkupThis,
                   LPCTSTR    pchRel, 
                   LONG       dwUrlSize,
                   TCHAR *    pchUrlOut,
                   CElement * pElementContext,
                   DWORD      dwFlags,           /* = 0xFFFFFFFF */
                   TCHAR *    pszAlternateDocUrl /* = NULL */
                  )
{
    HRESULT hr=S_OK;
    DWORD cchBuf;
    BOOL fDefault;
    BOOL fCombine;
    DWORD dwSize;
    TCHAR *pchBaseUrl = NULL;

    AssertSz(dwUrlSize == pdlUrlLen, "Wrong size URL buffer!!");

    if (dwFlags == 0xFFFFFFFF)
        dwFlags = URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE;

    if (pchRel == NULL) // note: NULL is different from "", which is more similar to "."
    {
        *pchUrlOut = _T('\0');
        goto Cleanup;
    }

    hr = GetBaseUrl(pMarkupThis, &pchBaseUrl, pElementContext,
                    &fDefault, pszAlternateDocUrl);
    if (hr)
        goto Cleanup;

    //
    // Expanding an outbind url in printing causes dll deadlock
    // when the outlib pluggable protocal is handling the CombineUrl call.
    //
    // since the only case this can happen is printing a mail message,
    // and there is no relative link into the mail message, we can
    // just return the url passed in.
    //
    // Lets try to make this test fast.
    //
    extern BOOL bCallCoInternetCombineUrl;
    
    if (!bCallCoInternetCombineUrl
        && !fDefault
        && !pszAlternateDocUrl
        && pchBaseUrl )
    {
        CDoc * pDoc = (pElementContext) ? pElementContext->Doc() 
             : ( pMarkupThis) ? pMarkupThis->Doc()
             : NULL;

        if (    pDoc
            &&  pDoc->IsPrintDialog()
            &&  _tcslen(pchBaseUrl) > 8
            && (   _tcsnicmp(_T("outbind:"), 8, pchBaseUrl, 8) == 0  //outlook2k
                || _tcsnicmp(_T("outday:"), 7, pchBaseUrl, 7) == 0) // outlook98
           )
        {
            // the base is an "outbind:" scheme
            // so all URLs are not relative
            _tcsncpy (pchUrlOut, pchRel, dwUrlSize);
            pchUrlOut[dwUrlSize-1] = _T('\0');    //If there wasn't room for the URL.
            goto Cleanup;
        }
    }

    hr = THR(CoInternetCombineUrl(pchBaseUrl, pchRel, dwFlags,
                                  pchUrlOut, pdlUrlLen, &cchBuf, 0));
    if (hr)
        goto Cleanup;

    if (!fDefault && (pMarkupThis || pszAlternateDocUrl))
    {
        LPCTSTR pchUrl;

        pchUrl = pszAlternateDocUrl ? pszAlternateDocUrl : GetUrl(pMarkupThis);

        if (S_OK == THR(CoInternetQueryInfo(
                        pchUrl,
                        QUERY_RECOMBINE, 0, &fCombine,
                        sizeof(BOOL), &dwSize, 0))
            &&  fCombine)
        {
            TCHAR achBuf2[pdlUrlLen];
            DWORD cchBuf2;

            hr = THR(CoInternetCombineUrl(
                pchUrl,
                pchUrlOut, dwFlags, achBuf2, pdlUrlLen, &cchBuf2, 0));
            
            if (hr)
                goto Cleanup;

            _tcsncpy (pchUrlOut, achBuf2, dwUrlSize);
            pchUrlOut[dwUrlSize-1] = _T('\0');    //If there wasn't room for the URL.
        }
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetRootSslState
//
//----------------------------------------------------------------------------
extern void PostManLock();
extern void PostManUnlock();


void
CDoc::EnterRootSslPrompt()
{
    _cInSslPrompt += 1;
    PostManLock();
}

BOOL
CDoc::InRootSslPrompt()
{
    return (!!_cInSslPrompt);
}

void
CDoc::LeaveRootSslPrompt()
{
    _cInSslPrompt -= 1;

    PostManUnlock();

    // Anything deferred because of InRootSslPrompt should be reexecuted now:
    if (_fNeedUrlImgCtxDeferredDownload)
    {
        _fNeedUrlImgCtxDeferredDownload = FALSE;
        OnUrlImgCtxDeferredDownload(NULL);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ValidateSecureUrl
//
//  Synopsis:   Given an absolute URL, returns TRUE if it is okay (in terms
//              of SSL security) to begin download of the URL.
//
//              May prompt the user (once per top-level frame).
//
//              If fReprompt is TRUE (default FALSE), the user is reprompted
//              even if s/he previously answered NO. The user is never
//              reprompted if s/he previously answered YES. (Once unsecure,
//              always unsecure.)
//
//----------------------------------------------------------------------------
BOOL
CMarkup::ValidateSecureUrl(BOOL fPendingRoot, LPCTSTR pchUrl, BOOL fReprompt, BOOL fSilent, BOOL fUnsecureSource)
{
    BOOL                bResult = TRUE;
    DWORD               error;
    SSL_SECURITY_STATE  sslSecurity;
    SSL_PROMPT_STATE    sslPrompt;
    CDoc              * pDoc = Doc();

    // grab the current security state
    pDoc->GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

    // if everything is allowed, don't even look at URL (perf win)
    if (sslPrompt == SSL_PROMPT_ALLOW)
        return TRUE;

    // If the URL is https then it needs no validation
    if (!fUnsecureSource && IsUrlSecure(pchUrl))
        return TRUE;

    // Otherwise, we may need to prompt
    if (sslPrompt == SSL_PROMPT_QUERY ||
        (sslPrompt == SSL_PROMPT_DENY && fReprompt))
    {
        if (fSilent || (pDoc->_dwLoadf & DLCTL_SILENT))
        {
            // in silent mode, act as if the user ignores the warnings
            pDoc->SetRootSslState(fPendingRoot, SSL_SECURITY_UNSECURE, SSL_PROMPT_ALLOW);
            sslPrompt = SSL_PROMPT_ALLOW;
        }
        else
        {
            BOOL    fAllow = FALSE;
            DWORD   dwPolicy = URLPOLICY_QUERY;

            // Grab the primary markup so we can recognize if a switch happened
            CMarkup * pMarkupPrimary = pDoc->PrimaryMarkup();

            // Check if the security manager ( URLMON or Host ) needs to have the zone crossing
            // confirmed for mixed content. 

            IGNORE_HR(ProcessURLAction(URLACTION_HTML_MIXED_CONTENT, 
                                            &fAllow,
                                            PUAF_NOUI,
                                            &dwPolicy,
                                            pchUrl));

            //
            // If mixed content is not allowed or the policy is query, 
            // then ask user for permission.
            //
            if (fAllow)
            {
                error = ERROR_SUCCESS;
            }
            else if (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_QUERY)
            {
                // TODO: (jbeda) Work out reentrancy issues here
                // TODO: (jbeda) carry window context down here to CDoEnableModeless
                CDoEnableModeless   dem(pDoc, NULL);
                HWND                hwnd = dem._hwnd;

                pDoc->EnterRootSslPrompt();
                
                error = InternetErrorDlg(hwnd, 
                                         NULL,      // no request
                                         ERROR_INTERNET_MIXED_SECURITY,
                                         0,         // no flags
                                         NULL       // no extra data
                                         );

                pDoc->LeaveRootSslPrompt();
            }
            else 
            {
                // security settings disallow outright...
                Assert(GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_DISALLOW);

                error = ERROR_CANCELLED;
            }

            // in case state has changed during message box,
            // grab the current security state again

            if (pMarkupPrimary != pDoc->PrimaryMarkup())
            {
                if (fPendingRoot)
                {
                    fPendingRoot = FALSE;
                }
                else
                {
                    // the regular root was navigated away while
                    // we were in the dialog.  Nothing really
                    // matters at this point since the markup
                    // is probably going to be torn down.
                    bResult = FALSE;
                    goto Cleanup;
                }
            }
            
            pDoc->GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

            if (error == ERROR_SUCCESS)
            {
                // User says "okay" to mixed content: downgrade security
                if (sslSecurity >= SSL_SECURITY_SECURE)
                    sslSecurity = SSL_SECURITY_MIXED;

                sslPrompt = SSL_PROMPT_ALLOW;
            }
            else
            {
                sslPrompt = SSL_PROMPT_DENY;
            }
            
            pDoc->SetRootSslState(fPendingRoot, sslSecurity, sslPrompt);
        }
    }
    
    bResult = (sslPrompt == SSL_PROMPT_ALLOW);
    
Cleanup:
    return bResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetRootSslState
//
//----------------------------------------------------------------------------

void
CDoc::GetRootSslState(BOOL fPendingRoot, SSL_SECURITY_STATE *psss, SSL_PROMPT_STATE *psps)
{
    if (!fPendingRoot)
    {
        *psss = _sslSecurity;
        *psps = _sslPrompt;
    }
    else
    {
        *psss = _sslSecurityPending;
        *psps = _sslPromptPending;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetRootSslState
//
//----------------------------------------------------------------------------

void
CDoc::SetRootSslState(BOOL fPendingRoot, SSL_SECURITY_STATE sss, SSL_PROMPT_STATE sps, BOOL fInit)
{
    SSL_SECURITY_STATE * psss;
    SSL_PROMPT_STATE * psps;

    if (!fPendingRoot)
    {
        psss = &_sslSecurity;
        psps = &_sslPrompt;
    }
    else
    {
        psss = &_sslSecurityPending;
        psps = &_sslPromptPending;
    }

    Assert(!(sss == SSL_SECURITY_UNSECURE && sps != SSL_PROMPT_ALLOW));
    Assert(!(sss >= SSL_SECURITY_SECURE && sps == SSL_PROMPT_ALLOW));

    *psps = sps;
    
    if (*psss != sss || fInit)
    {
        *psss = sss;
        if (!fPendingRoot && _pClientSite)
        {
            VARIANT varIn;
        
            Assert(SECURELOCK_SET_UNSECURE          == SSL_SECURITY_UNSECURE);
            Assert(SECURELOCK_SET_MIXED             == SSL_SECURITY_MIXED);
            Assert(SECURELOCK_SET_SECUREUNKNOWNBIT  == SSL_SECURITY_SECURE);
            Assert(SECURELOCK_SET_SECURE40BIT       == SSL_SECURITY_SECURE_40);
            Assert(SECURELOCK_SET_SECURE56BIT       == SSL_SECURITY_SECURE_56);
            Assert(SECURELOCK_SET_FORTEZZA          == SSL_SECURITY_FORTEZZA);
            Assert(SECURELOCK_SET_SECURE128BIT      == SSL_SECURITY_SECURE_128);

            V_VT(&varIn) = VT_I4;
            V_I4(&varIn) = sss;

            CTExec(
                _pClientSite,
                &CGID_ShellDocView,
                SHDVID_SETSECURELOCK,
                0,
                &varIn,   
                0);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AllowFrameUnsecureRedirect
//
//----------------------------------------------------------------------------
BOOL
CDoc::AllowFrameUnsecureRedirect(BOOL fPendingRoot)
{
    SSL_SECURITY_STATE sslSecurity;
    SSL_PROMPT_STATE   sslPrompt;

    GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

    if (sslSecurity >= SSL_SECURITY_SECURE)
        return FALSE;

    if (sslPrompt != SSL_PROMPT_ALLOW)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:  SecStateFromSecFlags
//
//----------------------------------------------------------------------------
SSL_SECURITY_STATE
SecStateFromSecFlags(DWORD dwFlags)
{
    if (!(dwFlags & SECURITY_FLAG_SECURE))
        return SSL_SECURITY_MIXED;

    if (dwFlags & SECURITY_FLAG_128BIT)
        return SSL_SECURITY_SECURE_128;

    if (dwFlags & SECURITY_FLAG_FORTEZZA)
        return SSL_SECURITY_FORTEZZA;

    if (dwFlags & SECURITY_FLAG_56BIT)
        return SSL_SECURITY_SECURE_56;
        
    if (dwFlags & SECURITY_FLAG_40BIT)
        return SSL_SECURITY_SECURE_40;

    return SSL_SECURITY_SECURE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnHtmDownloadSecFlags(dwFlags)
//
//----------------------------------------------------------------------------
void
CDoc::OnHtmDownloadSecFlags(BOOL fPendingRoot, DWORD dwFlags, CMarkup * pMarkup)
{
    if (pMarkup->IsPrimaryMarkup() || pMarkup->IsPendingPrimaryMarkup())
    {
        SSL_SECURITY_STATE sslSecurity;
        SSL_PROMPT_STATE   sslPrompt;

        GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

        sslSecurity = SecStateFromSecFlags(dwFlags);
                
        // we're a nonsecure top frame load...
        
        if (sslSecurity >= SSL_SECURITY_SECURE)
        {
            // We were potentially redirected to a secure URL
            
            if (sslPrompt == SSL_PROMPT_ALLOW)
                sslPrompt = SSL_PROMPT_QUERY;
                
            SetRootSslState(fPendingRoot, sslSecurity, sslPrompt);
        }
        else
        {
            // We were potentially redirected to an unsecure URL or to the cache

            SetRootSslState(fPendingRoot, SSL_SECURITY_UNSECURE, SSL_PROMPT_ALLOW);
        }
    }
    else
    {
        // Otherwise, we're a subframe load; behave like an image (except about:)
        
        if (!pMarkup->_fSslSuppressedLoad)
            OnSubDownloadSecFlags(fPendingRoot, CMarkup::GetUrl(pMarkup), dwFlags);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnSubDownloadSecFlags(dwFlags)
//
//----------------------------------------------------------------------------
void
CDoc::OnSubDownloadSecFlags(BOOL fPendingRoot, const TCHAR *pchUrl, DWORD dwFlags)
{
    SSL_SECURITY_STATE sslSecurity;
    SSL_SECURITY_STATE sslSecIn;
    SSL_SECURITY_STATE sslSecNew;
    SSL_PROMPT_STATE   sslPrompt;

    GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

    sslSecIn = SecStateFromSecFlags(dwFlags);

    sslSecNew = min(sslSecIn, sslSecurity);

    // note: SSL_SECURITY_SECURE (unknown bitness) should have been the
    // largest enum; but we can't change it because it is exported -
    // so fixup "min" by detecting the case where the smaller one was
    // SSL_SECURITY_SECURE and taking the other one
    
    if (sslSecNew == SSL_SECURITY_SECURE)
        sslSecNew = max(sslSecIn, sslSecurity);
        
    if (sslSecurity != sslSecNew && IsUrlOnNet(pchUrl))
        SetRootSslState(fPendingRoot, sslSecNew, sslPrompt);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnIgnoreFrameSslSecurity()
//
//  Synopsis:   when a non-SSL frame load has been suppressed by
//              the user, we need to touch subframe's host with a CTExec
//              SDHVID_SETSECURELOCK in LoadFromInfo so that the shell
//              doesn't ask urlmon/wininet for its idea of the frame's
//              security.
//
//----------------------------------------------------------------------------
void
CDoc::OnIgnoreFrameSslSecurity()
{
    SSL_SECURITY_STATE sslSecurity;
    SSL_PROMPT_STATE   sslPrompt;

    GetRootSslState(FALSE, &sslSecurity, &sslPrompt);
    
    if (_pClientSite)
    {

        VARIANT varIn;
    
        V_VT(&varIn) = VT_I4;
        V_I4(&varIn) = sslSecurity;

        CTExec(
            _pClientSite,
            &CGID_ShellDocView,
            SHDVID_SETSECURELOCK,
            0,
            &varIn,   
            0);
    }
}



// Implementation of the global GetFriendlyUrl

#define MAX_SUFFIX_LEN 256

#define PROTOCOL_FILE       _T("file")
#define PROTOCOL_MAILTO     _T("mailto")
#define PROTOCOL_GOPHER     _T("gopher")
#define PROTOCOL_FTP        _T("ftp")
#define PROTOCOL_HTTP       _T("http")
#define PROTOCOL_HTTPS      _T("https")
#define PROTOCOL_NEWS       _T("news")

static void Concat(TCHAR *pchDst, int sizeDst, const TCHAR *pchSrc, LONG x, LONG y)
{
    if (x >= 0)
    {
        TCHAR achTemp[pdlUrlLen + 1 + MAX_SUFFIX_LEN + 20];

        _tcscpy(achTemp, pchDst);
        Format(0, pchDst, sizeDst, _T("<0s><1s>?<2d>,<3d>"), achTemp, pchSrc, x, y);
    }
    else
        _tcscat(pchDst, pchSrc);
}

// GetFriendlyUrl
//      fShowFriendlyUrl = FALSE    
//          returns full url
//
//      fShowFriendlyUrl = TRUE     
//          replaces protocol with friendly description (like Shortcut to or Mail to),
//          strips path details: "http://sitename/path/filename.gif" -> "filename.gif at sitename"
//
//      x,y are only meaningful for server-side maps <a href="..."><img ismap=true>. With any setting, 
//      appends x,y coordinates to the end of URL: "http://sitename/path/filename.gif?123,152"
//          
TCHAR *
GetFriendlyUrl(const TCHAR *pchUrl, const TCHAR *pchBaseUrl, BOOL fShowFriendlyUrl,
               BOOL fPreface, LONG x, LONG y)
{
    TCHAR achFriendlyUrl[INTERNET_MAX_URL_LENGTH + 1 + MAX_SUFFIX_LEN + 20] = L""; // 20 is ample extra space
    TCHAR *pchFriendlyUrl = NULL;
    TCHAR achUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cchUrl;

    // Call CoInternetParseUrl from URLMON
    if (S_OK != CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, achUrl, ARRAY_SIZE(achUrl), &cchUrl, 0))
    {
        long    cch = min(INTERNET_MAX_URL_LENGTH - 1, _tcslen(pchUrl));
        
        _tcsncpy(achUrl, pchUrl, cch);
        achUrl[cch] = 0;
    }

    // Now, only call InternetCrackUrl from WININET only if we truly need to
    // (not the case for local files - fShowFriendlyUrl is not always set)
    if (fShowFriendlyUrl)
    {
        // params for InternetCrackUrl
        URL_COMPONENTS uc;
        TCHAR achScheme[INTERNET_MAX_SCHEME_LENGTH];
        TCHAR achHostName[INTERNET_MAX_HOST_NAME_LENGTH];
        TCHAR achPath[INTERNET_MAX_URL_LENGTH];
        
        memset(&uc, 0, sizeof(uc));
        uc.dwStructSize = sizeof(uc);
        uc.lpszScheme = achScheme;
        uc.dwSchemeLength = ARRAY_SIZE(achScheme);
        uc.lpszHostName = achHostName;
        uc.dwHostNameLength = ARRAY_SIZE(achHostName);
        uc.lpszUrlPath = achPath;
        uc.dwUrlPathLength = ARRAY_SIZE(achPath);

        // CAUTION: this may be the first guy to load WININET. Think twice if you want to use it for a local file.
        if (InternetCrackUrl(achUrl, _tcslen(achUrl), 0, &uc))
        {
            if (!StrCmpIC(achScheme, PROTOCOL_MAILTO))
            {
                // mailto
                Format(FMT_OUT_ALLOC, &pchFriendlyUrl, 0, MAKEINTRESOURCE(IDS_FRIENDLYURL_SENDSMAILTO),
                       &achUrl[1 + _tcslen(PROTOCOL_MAILTO)]);
            }
            else
            {
                // all other protocols
                TCHAR achSuffix[MAX_SUFFIX_LEN];
                BOOL fFriendlyString = TRUE;

                achSuffix[0] = _T('\0');

                if (!StrCmpIC(achScheme, PROTOCOL_FILE))
                {
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_LOCAL));
                    fFriendlyString = FALSE;
                }
                else if (!StrCmpIC(achScheme, PROTOCOL_GOPHER))
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_GOPHER));
                else if (!StrCmpIC(achScheme, PROTOCOL_FTP))
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_FTP));
                else if (!StrCmpIC(achScheme, PROTOCOL_HTTPS))
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_SECUREWEBSITE));
                else if (StrCmpIC(achScheme, PROTOCOL_HTTP) && StrCmpIC(achScheme, PROTOCOL_NEWS))
                    fFriendlyString = FALSE;
                        
                if (fFriendlyString)
                {
                    // "http://sitename/path/filename.gif" -> "filename.gif at sitename"
                    int length = _tcslen(achPath);
                    TCHAR *pchShortName;
                    BOOL fShowHostName = FALSE;

                    if (length && (achPath[length - 1] == _T('/')))
                        achPath[length - 1] = _T('\0');

                    if (*achHostName)
                    {
                        URL_COMPONENTS ucBase;
                        TCHAR achHostNameBase[INTERNET_MAX_HOST_NAME_LENGTH];

                        memset(&ucBase, 0, sizeof(ucBase));

                        ucBase.dwStructSize = sizeof(ucBase);
                        ucBase.lpszHostName = achHostNameBase;
                        ucBase.dwHostNameLength = ARRAY_SIZE(achHostNameBase);

                        if (    !pchBaseUrl
                            ||  !InternetCrackUrl(pchBaseUrl, _tcslen(pchBaseUrl), 0, &ucBase)
                            ||  _tcsicmp(achHostName, achHostNameBase))
                            fShowHostName = TRUE;
                    }

                    pchShortName = _tcsrchr(achPath, _T('/'));
                    if (fShowHostName && pchShortName && *(pchShortName + 1))
                    {
                        TCHAR achShortName[INTERNET_MAX_URL_LENGTH];

                        achShortName[0] = _T('\0');
                        Concat(achShortName, ARRAY_SIZE(achShortName), pchShortName + 1, x, y);
                        Format(0, achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl),
                               MAKEINTRESOURCE(IDS_FRIENDLYURL_AT), achShortName, achHostName);
                    }
                    else if (pchShortName && *(pchShortName + 1))
                        Concat(achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl), pchShortName + 1, x, y);
                    else if (*achHostName)
                        _tcscat(achFriendlyUrl, achHostName);
                }
                else
                    Concat(achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl), achUrl, x, y);

                if (fPreface)
                    Format(FMT_OUT_ALLOC, &pchFriendlyUrl, 0, MAKEINTRESOURCE(IDS_FRIENDLYURL_SHORTCUTTO),
                           achFriendlyUrl, achSuffix);
                else
                    Format(FMT_OUT_ALLOC, &pchFriendlyUrl, 0, _T("<0s> <1s>"),
                           achFriendlyUrl, achSuffix);
            }

            // NOTE: Format has allocated the memory
            return pchFriendlyUrl;
        }
    }

    // Not need to strip protocols, or InternetCrackUrl failed. Return full URL.
    Concat(achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl), achUrl, x, y);

    // Allocate the return string
    MemAllocString(Mt(GetFriendlyUrl), achFriendlyUrl, &pchFriendlyUrl);

    return pchFriendlyUrl;
}


HRESULT
ExpandUrlWithBaseUrl(LPCTSTR pchBaseUrl, LPCTSTR pchRel, TCHAR ** ppchUrl)
{
    HRESULT hr;
    TCHAR achBuf[pdlUrlLen];
    DWORD cchBuf;
    BOOL fCombine;
    DWORD dwSize;

    *ppchUrl = NULL;

    if (pchRel == NULL) // note: NULL is different from "", which is more similar to "."
    {
        hr = MemAllocString(Mt(ExpandUrlWithBaseUrl), _T(""), ppchUrl);
        goto Cleanup;
    }

    if (!pchRel)
    {
        hr = MemAllocString(Mt(ExpandUrlWithBaseUrl), pchBaseUrl, ppchUrl);
    }
    else
    {
        hr = CoInternetCombineUrl(pchBaseUrl, pchRel, URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE, achBuf, ARRAY_SIZE(achBuf), &cchBuf, 0);
        if (hr)
            goto Cleanup;

        if (S_OK == CoInternetQueryInfo(pchBaseUrl, QUERY_RECOMBINE, 0, &fCombine, sizeof(BOOL), &dwSize, 0)  &&
            fCombine)
        {
            TCHAR achBuf2[pdlUrlLen];
            DWORD cchBuf2;

            hr = CoInternetCombineUrl(pchBaseUrl, achBuf, URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE, achBuf2, ARRAY_SIZE(achBuf2), &cchBuf2, 0);
            if (hr)
                goto Cleanup;

            hr = THR(MemAllocString(Mt(ExpandUrlWithBaseUrl), achBuf2, ppchUrl));
        }
        else
        {
            hr = THR(MemAllocString(Mt(ExpandUrlWithBaseUrl), achBuf, ppchUrl));
        }
    }

Cleanup:
    RRETURN(hr);
}

BOOL
IsUrlOnNet(const TCHAR *pchUrl)
{
    DWORD fOnNet;
    ULONG cb;
    
    switch (GetUrlScheme(pchUrl))
    {
    case URL_SCHEME_FILE:
    case URL_SCHEME_RES:
    case URL_SCHEME_JAVASCRIPT:
    case URL_SCHEME_VBSCRIPT:
        return FALSE;
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
    case URL_SCHEME_FTP:
        return TRUE;
        break;

    default:
        if (!(CoInternetQueryInfo(pchUrl, QUERY_USES_NETWORK, 0, &fOnNet, sizeof(fOnNet), &cb, 0)) && cb == sizeof(fOnNet))
            return fOnNet;
        return FALSE;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\avundo.cxx ===
//+---------------------------------------------------------------------
//
//   File:      avundo.cxx
//
//  Contents:   AttrValue Undo support
//
//  Classes:    CUndoAttrValueSimpleChange
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef NO_EDIT // {

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

MtDefine(CUndoAttrValueSimpleChange, Undo, "CUndoAttrValueSimpleChange")
MtDefine(CUndoPropChangeNotification, Undo, "CUndoPropChangeNotification")
MtDefine(CUndoPropChangeNotificationPlaceHolder, Undo, "CUndoPropChangeNotificationPlaceHolder")
MtDefine(CMergeAttributesUndoUnit, Undo, "CMergeAttributesUndoUnit")

//+---------------------------------------------------------------------------
//
//  CUndoAttrValueSimpleChange Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoAttrValueSimpleChange::Init, public
//
//  Synopsis:   Initializes the undo unit for simple AttrValue change.
//
//  Arguments:  [dispidProp]   -- Dispid of property
//              [varProp]      -- unit value of property
//              [fInlineStyle]
//              [aaType]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoAttrValueSimpleChange::Init(
    DISPID             dispid,
    VARIANT &          varProp,
    BOOL               fInlineStyle,
    CAttrValue::AATYPE aaType)
{
    HRESULT hr;

    TraceTag((tagUndo, "CUndoAttrValueSimpleChange::Init"));

    hr = THR( super::Init( dispid, &varProp ) );

    _fInlineStyle = fInlineStyle;
    _aaType = aaType;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoAttrValueSimpleChange::Do, public
//
//  Synopsis:   Performs the undo of the property change.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoAttrValueSimpleChange::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT       hr;
    DWORD         dwCookie = 0;
    CUnitValue    uvOldValue;
    CUnitValue    uvCurValue;
    CAttrArray *  pAttrArray;
    CElement *    pElement = DYNCAST( CElement, _pBase );

    TraceTag((tagUndo, "CUndoAttrValueSimpleChange::Do"));

    //
    // The redo unit should be put on the stack in this call to Invoke()
    // unless we need to disable it.
    //
    if (!pUndoManager)
    {
        _pBase->BlockNewUndoUnits(&dwCookie);
    }

    Assert( _varData.vt == VT_I4 );

    uvOldValue.SetRawValue( _varData.lVal );

    pAttrArray = _fInlineStyle
                 ? pElement->GetInLineStyleAttrArray()
                 : *pElement->GetAttrArray();

    Assert( pAttrArray );

    uvCurValue.SetNull();

    if ( pAttrArray )
    {
        pAttrArray->GetSimpleAt( pAttrArray->FindAAIndex(
            _dispid, CAttrValue::AA_Attribute ),
            (DWORD *)&uvCurValue );
    }

    {
        BOOL fTreeSync;
        VARIANT vtProp;

        vtProp.vt = VT_I4;
        vtProp.lVal = uvCurValue.GetRawValue();
        pElement->QueryCreateUndo( TRUE, FALSE, &fTreeSync);

        if( fTreeSync )
        {
            PROPERTYDESC * pPropDesc;
            CBase        * pBase = pElement; 

            if( _fInlineStyle )
            {
                CStyle * pStyle;

                pElement->GetStyleObject( &pStyle );
                pBase = (CBase *)pStyle;
            }

            // NOTE (JHarding): This may be slow if we don't hit the GetIDsOfNames cache
            IGNORE_HR( pBase->FindPropDescFromDispID( _dispid, &pPropDesc, NULL, NULL ) );
            Assert( pPropDesc );

            if( pPropDesc )
            {
                CUnitValue  uvNew( V_I4(&_varData) );
                TCHAR       achOld[30];
                TCHAR       achNew[30];

                if( SUCCEEDED( uvCurValue.FormatBuffer( achOld, ARRAY_SIZE(achOld), pPropDesc ) ) &&
                    SUCCEEDED( uvNew.FormatBuffer( achNew, ARRAY_SIZE(achNew), pPropDesc ) ) )
                {
                    VARIANT     vtNew;
                    VARIANT     vtOld;

                    if( !achNew[0] )
                    {
                        // No new value
                        V_VT(&vtNew) = VT_NULL;
                    }
                    else
                    {
                        vtNew.vt = VT_LPWSTR;
                        vtNew.byref = achNew;
                    }
                    if( !achOld[0] )
                    {
                        // No old value
                        V_VT(&vtOld) = VT_NULL;
                    }
                    else
                    {
                        vtOld.vt = VT_LPWSTR;
                        vtOld.byref = achOld;
                    }

                    // Log the change
                    pBase->LogAttributeChange( _dispid, &vtOld, &vtNew );
                }
            }
        }

        IGNORE_HR( pElement->CreateUndoAttrValueSimpleChange(
            _dispid, vtProp, _fInlineStyle, _aaType ) );
    }

    if (uvOldValue.IsNull())
    {
        DWORD dwOldValue;

        Verify( pAttrArray->FindSimpleInt4AndDelete( _dispid, &dwOldValue ) );

        Assert( dwOldValue == (DWORD)uvCurValue.GetRawValue() );

        hr = S_OK;
    }
    else
    {
        hr = THR(CAttrArray::AddSimple( &pAttrArray, _dispid,
                                        *(DWORD*)&uvOldValue, _aaType ));
    }

    if (!pUndoManager)
    {
        _pBase->UnblockNewUndoUnits(dwCookie);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoPropChangeNotification Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChangeNotification::Do, public
//
//  Synopsis:   Performs the undo of the property change.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoPropChangeNotification::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT    hr;
    DWORD      dwCookie = 0;
    CElement * pElement = DYNCAST( CElement, _pBase );

    TraceTag((tagUndo, "CUndoPropChangeNotification::Do"));

    //
    // The redo unit should be put on the stack in this call to Invoke()
    // unless we need to disable it.
    //
    if (!pUndoManager)
    {
        _pBase->BlockNewUndoUnits(&dwCookie);
    }

    // For Redo, create the opposite object.

    hr = THR( pElement->CreateUndoPropChangeNotification( _dispid,
                                                          _dwFlags,
                                                          !_fPlaceHolder ) );

    // Fire the event, shall we?

    if (!_fPlaceHolder)
    {
        pElement->OnPropertyChange( _dispid, _dwFlags );
    }

    if (!pUndoManager)
    {
        _pBase->UnblockNewUndoUnits(dwCookie);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoPropChangeNotificationPlaceHolder Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChangeNotificationPlaceHolder ctor
//
//  Synopsis:   if fPost is true, it handles the ParentUndoUnit creation,
//              and (along with the dtor) CUndoPropChangeNotification posting.
//
//  Arguments:  fPost -- whether we should bother with this or not
//              pElement -- element against which we should notify upon undo
//              dispid -- dispid for notification
//              dwFlags -- flags for notification
//
//----------------------------------------------------------------------------

CUndoPropChangeNotificationPlaceHolder::CUndoPropChangeNotificationPlaceHolder(
    BOOL          fPost,
    CElement *    pElement,
    DISPID        dispid,
    DWORD         dwFlags ) : CUndoPropChangeNotification( pElement )
{
    _hr = S_FALSE;

    if (fPost && pElement->QueryCreateUndo(TRUE,FALSE))
    {
        CDoc *  pDoc = pElement->Doc();

        _pPUU = pDoc->OpenParentUnit( pDoc, IDS_UNDOGENERICTEXT );

        CUndoPropChangeNotification::Init( dispid, dwFlags, FALSE );

        IGNORE_HR( pElement->CreateUndoPropChangeNotification(
            dispid, dwFlags, FALSE ) );

        _fPost = TRUE;
    }
    else
    {
        _pPUU = NULL;
        _fPost = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChangeNotificationPlaceHolder dtor
//
//  Synopsis:   if _fPost was true at construction time, we post the
//              CUndoPropChangeNotification object and close the parent unit
//
//----------------------------------------------------------------------------

CUndoPropChangeNotificationPlaceHolder::~CUndoPropChangeNotificationPlaceHolder()
{
    if (_fPost)
    {
        CElement * pElement = DYNCAST( CElement, _pBase );
        IGNORE_HR( pElement->CreateUndoPropChangeNotification( _dispid,
            _dwFlags, TRUE ) );

        pElement->Doc()->CloseParentUnit( _pPUU, _hr );
    }
}

//+---------------------------------------------------------------------------
//
//  CMergeAttributesUndo Implementation
//
//----------------------------------------------------------------------------

CMergeAttributesUndo::CMergeAttributesUndo( CElement * pElement )
    : CUndoHelper( pElement->Doc() )
{
    Assert(pElement);
    CElement::SetPtr( &_pElement, pElement );

    _pAA = NULL;
    _pAAStyle = NULL;
    _fWasNamed = FALSE;
    _fCopyId = FALSE;
    _fRedo = FALSE;
    _fClearAttr = FALSE;
    _fPassElTarget = FALSE;

    _fAcceptingUndo = CUndoHelper::AcceptingUndo();
}

CMergeAttributesUndo::~CMergeAttributesUndo()
{
    CElement::ReleasePtr( _pElement ); 
    delete _pAA;
    delete _pAAStyle;
}

IOleUndoUnit * 
CMergeAttributesUndo::CreateUnit()
{
    CMergeAttributesUndoUnit * pUU;

    Assert( _fAcceptingUndo );

    TraceTag((tagUndo, "CMergeAttributesUndo::CreateUnit"));

    pUU = new CMergeAttributesUndoUnit( _pElement );

    if (pUU)
    {
        pUU->SetData( _pAA, _pAAStyle, _fWasNamed, _fCopyId, _fRedo, _fClearAttr, _fPassElTarget );
        _pAA = NULL;
        _pAAStyle = NULL;
    }

    return pUU;
}


//+---------------------------------------------------------------------------
//
//  CMergeAttributesUndoUnit Implementation
//
//----------------------------------------------------------------------------

CMergeAttributesUndoUnit::CMergeAttributesUndoUnit(CElement * pElement)
    : CUndoUnitBase( pElement, IDS_UNDOPROPCHANGE )
{
    CElement::SetPtr( &_pElement, pElement );
    _pAA = NULL;
    _pAAStyle = NULL;
    _fWasNamed = FALSE;
    _fCopyId = FALSE;
    _fRedo = FALSE;
    _fClearAttr = FALSE;
    _fPassElTarget = FALSE;
}

CMergeAttributesUndoUnit::~CMergeAttributesUndoUnit()
{
    CElement::ReleasePtr( _pElement ); 
    delete _pAA;
    delete _pAAStyle;
}

void 
CMergeAttributesUndoUnit::SetData( 
    CAttrArray * pAA, 
    CAttrArray * pAAStyle, 
    BOOL fWasNamed, 
    BOOL fCopyId, 
    BOOL fRedo,
    BOOL fClearAttr,
    BOOL fPassElTarget )
{
    Assert( !_pAA && !_pAAStyle );

    _pAA = pAA;
    _pAAStyle = pAAStyle;
    _fWasNamed = fWasNamed;
    _fCopyId = fCopyId;
    _fRedo = fRedo;
    _fClearAttr = fClearAttr;
    _fPassElTarget = fPassElTarget;
}

HRESULT 
CMergeAttributesUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT              hr = S_OK;
    CAttrArray *         pAttrUndo = NULL;
    CAttrArray *         pAttrSync = NULL;
    CAttrArray *         pAttrStyleUndo = NULL;
    CAttrArray *         pAttrStyleSync = NULL;
    BOOL                 fCreateUndo;
    BOOL                 fTreeSync;

    CMergeAttributesUndo Redo( _pElement );

    // If we have _pAAStyle then we must have _pAA
    Assert( !_pAAStyle || _pAA );

    // We should never have a style AA when clearing
    Assert( !_fClearAttr || !_pAAStyle );

    Redo.SetWasNamed( _pElement->_fIsNamed );
    Redo.SetCopyId( _fCopyId );
    Redo.SetClearAttr( _fClearAttr );
    Redo.SetPassElTarget( _fPassElTarget );

    if(!_fRedo)
        Redo.SetRedo();

    fCreateUndo = _pElement->QueryCreateUndo( TRUE, FALSE, &fTreeSync );
    if( _pAA && ( fCreateUndo || fTreeSync ) )
    {
        pAttrUndo       = new CAttrArray();
        pAttrStyleUndo  = new CAttrArray();
        if( !pAttrUndo || !pAttrStyleUndo )
        {
            // If we couldn't make these two arrays, we're hosed.
            fTreeSync = FALSE;
            fCreateUndo = FALSE;

            delete pAttrUndo;
            delete pAttrStyleUndo;
        }

        if( fTreeSync )
        {
            pAttrSync      = new CAttrArray();
            pAttrStyleSync = new CAttrArray();

            if( !pAttrSync || !pAttrStyleSync )
            {
                // If we couldn't make these two arrays, tree sync is hosed
                fTreeSync = FALSE;

                delete pAttrSync;
                delete pAttrStyleSync;
            }
        }
    }

    if (_pAA)
    {
        CAttrArray     **ppAATo = _pElement->GetAttrArray();

        if (_fClearAttr && _fRedo)
        {
            (*ppAATo)->Clear( pAttrUndo );

            if( pAttrSync )
            {
                // Meaning all new values are "not set"
                delete pAttrSync;
                pAttrSync = NULL;
            }
        }
        else
        {
            CElement * pelTarget = (_fRedo && _fPassElTarget) ? _pElement : NULL;

            hr = THR( _pAA->Merge( ppAATo, pelTarget, pAttrUndo, pAttrSync, !_fRedo, _fCopyId ) );
            if (hr)
                goto Cleanup;
        }

        if (!_fClearAttr)
        {
            _pElement->SetEventsShouldFire();

            // If the From has is a named element then the element is probably changed.
            if (_fWasNamed != _pElement->_fIsNamed)
            {
                _pElement->_fIsNamed = _fWasNamed;
                // Inval all collections affected by a name change
                _pElement->DoElementNameChangeCollections();
            }

            if (_pAAStyle && _pAAStyle->Size())
            {
                CAttrArray **   ppInLineStyleAATo;

                ppInLineStyleAATo = _pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
                if (!ppInLineStyleAATo)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(_pAAStyle->Merge(ppInLineStyleAATo, NULL, pAttrStyleUndo, pAttrStyleSync, !_fRedo));
                if (hr)
                    goto Cleanup;
            }
        }

        if( fTreeSync )
        {
            CStyle * pStyle = NULL;

            // Only get the style object if there were style attrs merged
            if( pAttrStyleUndo->Size() )
                IGNORE_HR( _pElement->GetStyleObject( &pStyle ) );

            IGNORE_HR( _pElement->LogAttrArray( NULL, pAttrUndo, pAttrSync ) );
            IGNORE_HR( _pElement->LogAttrArray( pStyle, pAttrStyleUndo, pAttrStyleSync ) );

            delete pAttrSync;
            delete pAttrStyleSync;
        }

        if( fCreateUndo )
        {
            Redo.SetAA( pAttrUndo );
            Redo.SetAAStyle( pAttrStyleUndo );
        }
        else
        {
            delete pAttrUndo;
            delete pAttrStyleUndo;
        }
    }

    hr = THR(_pElement->OnPropertyChange(DISPID_UNKNOWN, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS));
    if (hr)
        goto Cleanup;

    IGNORE_HR( Redo.CreateAndSubmit() );

Cleanup:
    RRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccUtil.Cxx
//
//  Contents:   Accessibility util functions
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBASE_HXX_
#define X_ACCBASE_HXX_
#include "accbase.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"    
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCFRAME_HXX_
#define X_ACCFRAME_HXX_
#include "accframe.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

//-----------------------------------------------------------------------
//  IsSupportedElement()
//
//  DESCRIPTION:
//
//          Tells if the element is a valid accessibility element or not.
//
//  PARAMETERS:
//
//      pElem            pointer to the CElement
//
//  RETURNS:
//
//      TRUE | FALSE
//-----------------------------------------------------------------------
BOOL 
IsSupportedElement(CElement *pElem )
{
    BOOL fRet = FALSE;

    if (!pElem)
        goto Cleanup;

    // An element that has an attached behavior that implements IAccessible 
    // takes precedence over a supported tag.  However, given that this function
    // does not return why a tag is supported, it is more efficient to check if the
    // TAG is in the supported list, and only do the QI if we are still unsure if
    // the tag is supported.
      
    switch ( pElem->Tag() ) 
    {
    case ETAG_INPUT:        //both input and input text are used for input elements
        if (DYNCAST(CInput, pElem)->GetAAtype() == htmlInputHidden)
        {
            fRet = FALSE;
            break;
        }
    case ETAG_BODY:
    case ETAG_FRAME:
    case ETAG_IFRAME:
    case ETAG_A:
    case ETAG_BUTTON:
    case ETAG_IMG:
    case ETAG_TEXTAREA:
    case ETAG_MARQUEE:
    case ETAG_SELECT:
    case ETAG_OBJECT:
    case ETAG_APPLET:
    case ETAG_EMBED:
    case ETAG_TABLE:
    case ETAG_TD:
    case ETAG_TH:
    case ETAG_LABEL:
        fRet = TRUE;
        break;

    default:
        //
        // if we are not in the "official list" above, we still may be supported:
        //
        // if there is a tabstop defined on this element see CDoc::OnElementEnter for comments about Tabstops
        // if we have a behavior that implements IAccessible or a viewlink 
        //

        if (pElem->HasPeerHolder())
        {
            if (pElem->HasSlavePtr())
            {
                fRet = TRUE;
            }
            else
            {
                fRet = IsIAccessiblePeer(pElem);
            }
        }

        fRet  = fRet | (pElem->GetAAtabIndex() != htmlTabIndexNotSet);
        break;
    }

Cleanup:
    return fRet;
}

//-----------------------------------------------------------------------
//
//  IsIAccessiblePeer()
//
//  DESCRIPTION:
//
//          Tells if the peer implements IAccessible
//
//          In order to conclude that we have an accessible peer,
//          We need to find an attached behavior that implements IAccessible OR 
//          Element behavior that implements IAccessible.
//
//  PARAMETERS:
//
//      pElem            pointer to the CElement
//
//  RETURNS:
//
//      TRUE | FALSE
//-----------------------------------------------------------------------

BOOL 
IsIAccessiblePeer(CElement *pElem)
{
    HRESULT hr;
    BOOL fRet  = FALSE;

    CPeerHolder * pPH;
    IAccessible * pAcc = NULL;

    Assert (pElem->HasPeerHolder());

    pPH = pElem->GetPeerHolder();

    // Element behaviors are always first in the peer chain.

    hr = THR(pPH->QueryPeerInterfaceMulti(IID_IAccessible, (void **)&pAcc, FALSE));

    if (!hr)
    {
        fRet = TRUE;
        Assert(pAcc);                 // Catch bad behavior
    }

    ReleaseInterface(pAcc);
    return fRet;
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

HRESULT 
ScrollIn_Focus( CElement* pElem )
{
    HRESULT hr;
    
    if ( !pElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    //scrollintoview.
    hr = THR( pElem->ScrollIntoView());
    if ( hr )
    {
        goto Cleanup;
    }

    //focus
    hr = THR( pElem->focus() );
        
Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
HRESULT 
ScrollIn_Focus_Click( CElement* pElem )
{
    HRESULT hr;

    if ( !pElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( ScrollIn_Focus(pElem) );
    if ( hr )
    {
        goto Cleanup;
    }

    hr = THR( pElem->DoClick( NULL, NULL, FALSE, NULL, TRUE) );
    
Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  IsFocusable
//  
//  DESCRIPTION:
//      If the document that contains the elenent has focus, the function
//      returns TRUE, since the element has the ability to receive focus.
//
//  PARAMETERS:
//      pElem   :   Pointer to the CElement 
//  
//  RETURNS :
//      TRUE if the element is focusable, FALSE otherwise
//-----------------------------------------------------------------------
BOOL
IsFocusable( CElement* pElem )
{
    CDoc* pDoc= pElem->Doc();

    // does this element have a document at all?
    if ( pDoc )
    {
        return (pDoc->HasFocus());
    }
    else
        return FALSE;
}

//-----------------------------------------------------------------------
//  GetMarkupLimits
//  
//  DESCRIPTION:
//      Receives a CElement pointer, and returns two markup pointer that
//      are places after the beginning and end tags of this element.
//      This method is counted on to be called elements with scope only. 
//      
//  PARAMETERS:
//      pElem   :   CElement * to the element 
//      ppBegin :   Address of the variable that receives the begin tag markup
//      ppEnd   :   Address of the variable that receives the end tag markup
//-----------------------------------------------------------------------
HRESULT
GetMarkupLimits( CElement* pElem, CMarkupPointer* pBegin, CMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;

    if ( !pElem || !pBegin || !pEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pBegin->MoveAdjacentToElement( pElem, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    hr = THR( pEnd->MoveAdjacentToElement( pElem, ELEM_ADJ_AfterEnd));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  GetSubMarkupLimits
//
//  DESCRIPTION:
//      Very similar to the GetMarkupLimits. However, this one is used for
//      viewlinked markups, so if the markup is created through DOM, it 
//      is not possible to place a markup pointer after the ROOT closes.
//      The end pointer is placed before the root tag in this case.
//-----------------------------------------------------------------------
HRESULT
GetSubMarkupLimits(CElement* pElem, CMarkupPointer* pBegin, CMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;

    if ( !pElem || !pBegin || !pEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pBegin->MoveAdjacentToElement( pElem, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    hr = THR( pEnd->MoveAdjacentToElement( pElem, ELEM_ADJ_BeforeEnd));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  AccStepRight
//  
//  DESCRIPTION:
//      Moves the markup pointer to the right one step. A step is considered
//      moving from one before/end tag position to the other. If the tag
//      to the right of the markup pointer belongs to a supported element
//      the function steps over the complete supported element tag. NOscope
//      elements are considered single steps
//      The method increments the counter if it steps over something that
//      would cause the child count to increase.
//  
//  PARAMETERS:
//      pMarkup :   Markup pointer to be moved
//      pCounter:   Pointer to the child counter on the caller side
//-----------------------------------------------------------------------
HRESULT
AccStepRight( CMarkupPointer* pMarkup, long * pCounter )
{
    HRESULT             hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    CTreeNode *         pElemNode = NULL;

    //get what is to our right
    hr = THR( pMarkup->Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));

    switch ( context )
    {

#if DBG==1            
        case CONTEXT_TYPE_None:     
            //if there was nothing on this side at all,
            AssertSz(FALSE, "We have hit the root..");
            break;

        case CONTEXT_TYPE_ExitScope://don't care ...
            break;
#endif

        case CONTEXT_TYPE_EnterScope:
            //check the element to see if it is a supported element
            if ( IsSupportedElement( pElemNode->Element() ) )
            {
                //go to the end of this element, since we will handle it as a container
                hr = THR( pMarkup->MoveAdjacentToElement( pElemNode->Element(), ELEM_ADJ_AfterEnd));
                if ( hr )
                    goto Cleanup;

                (*pCounter)++;      
            }
            //don't do anything if it is not a supported element.
            break;  
            
        //we jumped over text or noscope
        case CONTEXT_TYPE_NoScope:
            if ( !IsSupportedElement( pElemNode->Element() ))
                break;
            
        case CONTEXT_TYPE_Text:
            (*pCounter)++;      
            break;
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  DESCRIPTION:
//      Returns the total number of acc. children between the two markup 
//      locations
//----------------------------------------------------------------------------
HRESULT 
GetChildCount( CMarkupPointer* pStart, CMarkupPointer* pEnd, long* pChildCnt)
{
    HRESULT             hr = S_OK;
    long                lChildCnt = 0;
    MARKUP_CONTEXT_TYPE context;
    CTreeNode *         pElemNode = NULL;

    Assert( pStart );
    Assert( pEnd );
    Assert( pChildCnt );
        
    *pChildCnt = 0;
//
//TODO:   FerhanE :   We can change this for perf, to compare the left elements and
//                    contexts of two pointers.
///                   1- Get left context and element of end ptr,
//                    2- Move startptr to right and keep track of the element
//                          and context. 
//                    3- Compare the context and element of the two pointers. 
//                       if they are the same, we have the child count.
//.                     

    //we walk the pStart through the HTML using this loop
    for (; ; )
    {
        // if the two pointers are pointing to the same location, or if
        // we passed the pEnd location. If the pEnd location is inside
        // a supported element tag, then we will not have a chance to 
        // stop there, we will jump over it. 
        if ( !pStart->IsLeftOf( pEnd ) )
            break;

        //get what is to our right
        hr = THR( pStart->Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));

        switch ( context )
        {
#if DBG==1            
            case CONTEXT_TYPE_None:     
                //if there was nothing on this side at all,
                AssertSz(FALSE, "We have hit the root..");
                break;

            case CONTEXT_TYPE_ExitScope://don't care ...
                break;
#endif

            case CONTEXT_TYPE_EnterScope:
                //check the element to see if it is a supported element
                if ( IsSupportedElement( pElemNode->Element() ) )
                {
                    //go to the end of this element, since we will handle it as a container
                    hr = THR( pStart->MoveAdjacentToElement( pElemNode->Element(), ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    lChildCnt++;      
                }
                //don't do anything if it is not a supported element.
                break;  
            
            //we jumped over text or noscope
            case CONTEXT_TYPE_NoScope:
                if ( !IsSupportedElement( pElemNode->Element() ))
                    break;
            
            case CONTEXT_TYPE_Text:
                lChildCnt++;      
                break;
        }
    }

Cleanup:
    if ( hr == S_OK )
        *pChildCnt = lChildCnt;

    RRETURN( hr );
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
HRESULT 
GetHitChildID( CElement* pElem, CMessage * pMsg, VARIANT * pvarChild )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      walkerMarkup( pElem->Doc() );
    CMarkupPointer      HitMarkup(pElem->Doc());
    BOOL                bNotAtBOL;
    BOOL                bAtLogicalBOL;
    BOOL                bRightOfCp;
    MARKUP_CONTEXT_TYPE contextleft, 
                        contextright;
    CTreeNode *         pElemNodeLeft = 0;
    CTreeNode *         pElemNodeRight = 0;
    POINT               ptContent;
    CLayoutContext *    pLayoutContext;

    Assert( pvarChild );

    CDispNode* pDispNode;
    // position the markup pointer at the point that we are given
    // $$ktam: does pMsg have correct layout context already?  what about correct tree node?
    CTreeNode * pTreeNode = pElem->Doc()->GetNodeFromPoint( pMsg->pt, &pLayoutContext, FALSE, &ptContent,
                                                            NULL, NULL, NULL, &pDispNode );
    if( pTreeNode == NULL )
        goto Cleanup;

    // $$ktam: passing pTreeNode->GetFlowLayout() as the containing layout seems fishy to me..?
    hr = THR( pElem->Doc()->MovePointerToPointInternal( ptContent, 
                                                        pTreeNode,
                                                        pLayoutContext,
                                                        &HitMarkup, 
                                                        &bNotAtBOL,
                                                        &bAtLogicalBOL,
                                                        &bRightOfCp, 
                                                        FALSE,
                                                        pTreeNode->GetFlowLayout( pLayoutContext ),
                                                        NULL,
                                                        TRUE,
                                                        NULL,
                                                        pDispNode ));
    if (hr)
        goto Cleanup;
    
    // Set the HitMarkup to the current context.
    //-------------------------------------------------------------------------------
    hr = THR( HitMarkup.Left( FALSE, &contextleft, &pElemNodeLeft, NULL, NULL, NULL));
    if ( hr )
        goto Cleanup;

    hr = THR( HitMarkup.Right( FALSE, &contextright, &pElemNodeRight, NULL, NULL, NULL));
    if ( hr )
        goto Cleanup;

    //if there is text to the hit markups left, move to the closest tag on its left.
    //otherwise we are ready to count children.
    if ( contextleft == CONTEXT_TYPE_Text )
    {
        hr = THR( HitMarkup.Left( TRUE, &contextleft, NULL, NULL, NULL, NULL));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        // after placing the Markup pointers, if we are not over text then we are in one
        // of the "gutters" on our parent and possibly sitting next to a noscope supported
        // thing.  In this case we don't need to continue with context correctness of text
        // children, and can instead, just return.
        //--------------------------------------------------------------------------------
        if ((contextright != CONTEXT_TYPE_Text ) && 
                pElemNodeRight && 
                (pElem == pElemNodeRight->Element() || !IsSupportedElement(pElemNodeRight->Element()) ))
        {
            V_VT( pvarChild ) = VT_I4;
            V_I4(pvarChild) = CHILDID_SELF;
            goto Cleanup;
        }
    }
      
    //place the markup pointer to the beginning of the element's scope.
    hr = THR( walkerMarkup.MoveAdjacentToElement( pElem, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    // Count the number of children from the point we start to the point we hit
    // that number is the child id for the spot we hit.
    hr = THR( GetChildCount( &walkerMarkup, &HitMarkup, &(V_I4(pvarChild)) ) );
    if ( hr )
        goto Cleanup;

    // the contents of this variable is a 0 based index, but we want
    // the child id to be 1 based.
    V_VT(pvarChild) = VT_I4;
    V_I4(pvarChild)++;
   
  
Cleanup:

    //
    // MovePointerToPointInternal now returns CTL_E_INVALIDLINE when you attempt to
    // position a markup pointer in a table or TR.  Previously, this was returning
    // E_FAIL.  We want to prop the E_FAIL return code for compat.
    //
    if( hr == CTL_E_INVALIDLINE )
    {
        hr = E_FAIL;
    }
    
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetTextFromMarkup
//  
//  DESCRIPTION:
//      Given a markup pointer that has text to its right, retrieves the text
//      and fills a BSTR with the text read.
//      This function assumes that the markup pointer passed was placed properly
//      before text.
//      
//  PARAMETERS:
//      pMarkup     :   Markup pointer to start reading from
//      pbstrText   :   Address of the bstr to receive the text.
//----------------------------------------------------------------------------
HRESULT
GetTextFromMarkup( CMarkupPointer *pMarkup, BSTR * pbstrText )
{
    HRESULT                 hr = E_INVALIDARG;
    MARKUP_CONTEXT_TYPE     context;
    long                    lchCnt =-1;
    
    if ( !pMarkup || !pbstrText)
        goto Cleanup;

    // get the number of characters available for reading.
    hr = THR( pMarkup->Right( FALSE, &context, NULL, &lchCnt, NULL, NULL));
    if ( hr )
        goto Cleanup;

    Assert( context == CONTEXT_TYPE_Text );   //just checking.. !

    //allocate buffer
    hr = FormsAllocStringLen ( NULL, lchCnt, pbstrText );
    if ( hr )
        goto Cleanup;

    //read text
    hr = THR( pMarkup->Right( TRUE, &context, NULL, &lchCnt, *pbstrText, NULL));
    if ( hr )
    {
        // release the BSTR and reset the pointer if we have failed to get
        // the text from tree services.
        FormsFreeString( *pbstrText );
        *pbstrText = NULL;
    }    
    
Cleanup:
    RRETURN( hr );
}


//-----------------------------------------------------------------------
//  GetAccObjOfElement
//
//  DESCRIPTION:
//
//      Returns the element's associated Lookaside acc. object. 
//      if the acc object is not created it creates it and adds it to the
//      lookaside list.
//
//  PARAMETERS:
//
//      pElem   :   pointer to the element
//
//  RETURNS:
//
//      Pointer to the CAccBase that is created/looked up.
//
//  NOTES:
//
//
//----------------------------------------------------------------------------
CAccBase * GetAccObjOfElement( CElement* pElem )
{
    CAccBase *  pAccObj = NULL;

    //we require a valid pointer.
    if ( !pElem )
        return NULL;

    //if the element has a lookaside ptr, return that.
    //otherwise, create one, add to the list and return.
    if (pElem->HasAccObjPtr())
    {
        // get the acc. lookaside ptr for this element.
        pAccObj = pElem->GetAccObjPtr();

        goto Cleanup;
    }

    //
    // If the element is not a FRAME or IFRAME tag, then create the element
    // using the lookaside pointer functions in the CElement.
    // Otherwise, create a CAccWindow that represents the frame or iframe 
    //
    if (( pElem->Tag() != ETAG_FRAME ) && 
        (pElem->Tag()!=ETAG_IFRAME))
    {
        //create the accessible object
        //the CAccBase constructor also adds the object to the lookaside list,
        pAccObj = pElem->CreateAccObj();
        if ( !pAccObj )
        {
            goto Cleanup;
        }
    }
    else
    {
        // If there is a behavior attached to this frame, then create a CAccBehavior
        // instead of a CAccFrame.
        if (pElem->HasPeerHolder())
        {
            pAccObj = pElem->AccObjForBehavior();
        }

        // if there is not a behavior, or if we could not create an accessible
        // object for that behavior, then do what we would do if we did not have
        // a behavior attached.
        // In the weird case of HTML code with more FRAME tags than the ones defined, 
        // there won't be a window, so we check here if we have a valid proxy 
        // before continuing. see bug #8673 in IEv60 database
        COmWindowProxy * pWindowProxy = (DYNCAST( CFrameSite, pElem))->_pWindow;

        if (!pAccObj && pWindowProxy)
        {   
            // get the inner window for a frame tag.
            CWindow * pInnerWnd = pWindowProxy->Window();

            Assert(pInnerWnd);

            if (!(pInnerWnd->_pAccWindow))
            {
                pInnerWnd->_pAccWindow = (CAccWindow *) new CAccFrame( pInnerWnd, pElem);
                if (!pInnerWnd->_pAccWindow)
                    goto Cleanup;
            }

            pAccObj = pInnerWnd->_pAccWindow;
        }
    }

//[FerhanE]    
//we could AddRef the element here, but we don't, since most of the
//users of this function are internal, and they don't need reference
//counts on the element or they may chose not to increment (WM_GETOBJECT case)
    
Cleanup:
    return pAccObj;
}

//+---------------------------------------------------------------------------
//  SelectText
//  
//  DESCRIPTION:
//      Selects the text starting from the markup pointer that is passed, 
//      until the next tag in the markup stream.
//      
//  PARAMETERS:
//      pElem   :   The element that parents the text. 
//      pBegin  :   Pointer to the beginning markup position
//      
//----------------------------------------------------------------------------
HRESULT
SelectText( CElement* pElem, IMarkupPointer * pMarkupBegin )
{
    HRESULT             hr;
    IMarkupPointer *    pMarkupEnd = NULL;
    MARKUP_CONTEXT_TYPE context;

    if ( !pElem || !pMarkupBegin )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Since the selection manager is in another module, we have to use 
    // (IMarkupPointer *) values instead of (CMarkupPointer) values.(ferhane)

    // Create another markup pointer and place to the same spot the
    // first one is placed.
    hr = THR( pElem->Doc()->CreateMarkupPointer( &pMarkupEnd ) );
    if ( hr )
        goto Cleanup;
    
    hr = THR( pMarkupEnd->MoveToPointer( pMarkupBegin ) );
    if ( hr ) 
        goto Cleanup;

    // move the end pointer next to the first tag in the HTML stream.
    hr = THR( pMarkupEnd->Right( TRUE, &context, NULL, NULL, NULL ) );
    if ( hr )
        goto Cleanup;

    // select the range marked by the two markup pointers we have.
    hr = THR( pElem->Doc()->Select( pMarkupBegin, pMarkupEnd, SELECTION_TYPE_Text) );

Cleanup:
    ReleaseInterface( pMarkupEnd );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\acc\accwind.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccWind.Cxx
//
//  Contents:   Accessible Window object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif


extern DYNLIB g_dynlibOLEACC;

MtDefine(CAccWindowGetEnumerator_aryVariants_pv, Locals, "CAccWindow::GetEnumerator aryVariants::_pv")

//-----------------------------------------------------------------------
//  CAccWindow::CAccWindow()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pDocParent  :   The CAccWindow contains a pointer to the document 
//                      that it is related to. This parameter contains the
//                      address of the CDoc class.
// ----------------------------------------------------------------------
CAccWindow::CAccWindow( CWindow * pWndInner )
:_elemBegin(pWndInner->Doc()), _elemEnd(pWndInner->Doc())
{
    Assert( pWndInner );

    _pWindow = pWndInner;

    SetRole( ROLE_SYSTEM_CLIENT );
}

//----------------------------------------------------------------------------
//  CAccWindow::~CAccWindow()
//  
//  DESCRIPTION:
//      Destructor
//----------------------------------------------------------------------------
CAccWindow::~CAccWindow()
{
    Assert(_pWindow);
  
    //reset the window object so it can answer later requests 
    //for acc. objects. This is important if the client releases the
    //accwindow without unloading the document, and later asks for another
    //acc object on the window. Since the CWindow has no notion of 
    //reference counting the acc. object, the object has to do that

    _pWindow->_pAccWindow = NULL;  
    _pWindow = NULL;
}


//+---------------------------------------------------------------------------
//  PrivateAddRef
//  
//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the document that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccWindow::PrivateAddRef()
{
    Assert( _pWindow );
    return _pWindow->PrivateAddRef();
}

//+---------------------------------------------------------------------------
//  PrivateRelease

//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the document that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccWindow::PrivateRelease()
{
    Assert( _pWindow );
    return _pWindow->PrivateRelease();
}


//----------------------------------------------------------------------------
//  get_accParent
//  
//  DESCRIPTION:
//      Returns a pointer to the parent accessible object
//      
//      If there is no parent, then set the out parameter to NULL and 
//      return S_FALSE
//      This implementation is only for the top level windows. The frame
//      windows overwrite this method and handle it themselves.
//
//  PARAMETERS:
//      ppdispParent    :   Address of the variable to receive the parent
//                          accessible object pointer.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT hr;
    HWND    hWndParent = NULL;

    // check and reset the out parameter
    if ( !ppdispParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    // Is this the object that represents the root document?
    if (_pWindow->_pMarkup->IsPrimaryMarkup())
    {
        //get the window handle for this document's window.
        hWndParent = _pWindow->Doc()->GetHWND();

        if ( !hWndParent )
            goto Error;
        
        //get the parent window.
        hWndParent = GetParent( hWndParent );
        if ( !hWndParent )
            goto Error;

        //get the accessible object for the parent window.
        hr = AccObjFromWindow( hWndParent, (void **)ppdispParent );
    }
    else
        goto Error;
                                                    
Cleanup:
    RRETURN(hr );

Error:
    RRETURN( E_FAIL );
}

//----------------------------------------------------------------------------
//  get_accChildCount
//  
//  DESCRIPTION:
//      Get the child count for the accessible window object. This count is 
//      always one.
//      Returns E_FAIL if there is a problem getting to the child.
//      
//  PARAMETERS:
//      pChildCount :   Address of the long integer to receive the child count
//
//  RETURNS:
//      S_OK  | E_FAIL | E_POINTER
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accChildCount(long* pChildCount)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // the following function will initialize the child's acc object,
    // in addition to making sure that we have the only child of the window
    hr = THR( GetClientAccObj( &pAccChild) );
    
    // if no error, there is always one child for a window, set and return
    *pChildCount = (hr) ? 0 : 1;

Cleanup:    
    RRETURN (hr );

}

//----------------------------------------------------------------------------
//  get_accChild
//  
//  DESCRIPTION:
//      Retrieves the one and only possible child for the acc. window object
//
//  PARAMETERS:
//      varChild    :   VARIANT that contains the child index information
//      ppdispChild :   pointer to the dispatch pointer to receive the child
//                      object interface pointer
//  RETURNS:
//      E_POINTER | S_OK | E_INVALIDARG | E_FAIL        
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;
    
    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppdispChild = NULL;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;    

    // get the only child's accessible object
    hr = THR( GetClientAccObj( &pAccChild) );
    if ( hr )
        goto Cleanup;

    Assert( pAccChild );

    //increment reference count before giving out.
    pAccChild->AddRef();

    // TODO: this should eventually be a  QI (tearoffs)
    *ppdispChild = (IDispatch *) pAccChild;
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  DESCRIPTION:
//        
//      Returns the URL of the document for IE3 compatibility.
//
//
//  PARAMETERS:
//      pbstrName   :   address of the pointer to receive the URL BSTR
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accName( VARIANT varChild, BSTR* pbstrName)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        hr = THR(_pWindow->Document()->get_URL(pbstrName));
    }
    else if ( V_I4(&varChild) == 1 )
    {   
        // get the window's only child's acc. object
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )   
            goto Cleanup;

        //set the parameters and delegate the call
        //to the child
        V_I4( &varChild ) = CHILDID_SELF;
        
        hr = THR( pAccChild->get_accName( varChild, pbstrName ) );
    }
    else
    {
        // the child id passed is invalid
        hr = E_INVALIDARG;
    }
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accValue
//  
//  DESCRIPTION:
//      NOT IMPLEMENTED BY THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    return ( E_NOTIMPL );
}

//----------------------------------------------------------------------------
//  get_accDescription
//
//  DESCRIPTION :   
//      Returns the description text for the Window Acc. object. 
//
//  PARAMETERS:
//      pbstrDescription    :   pointer to the BSTR to receive data.
//
//  RETURNS:
//      S_OK | E_POINTER | E_OUTOFMEMORY | E_FAIL | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accDescription( VARIANT varChild, BSTR* pbstrDescription)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // TODO : This is here for backward compatibility. We may want to change the
        // contents of this BSTR. Also add this to the resourcestrings.
        *pbstrDescription = SysAllocString( _T("MSAAHTML Registered Handler") );

        if ( !*pbstrDescription )
            hr = E_OUTOFMEMORY;

    }
    else if ( V_I4(&varChild) == 1 )
    {   
        // get the acc. window's one and only child
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )   
            goto Cleanup;

        //set the parameters and delegate the call
        //to the child
        V_I4( &varChild ) = CHILDID_SELF;
        
        hr = THR( pAccChild->get_accDescription( varChild, pbstrDescription ) );
    }
    else
    {
        // the child id passed is invalid
        hr = E_INVALIDARG;
    }

Cleanup:
    RRETURN( hr );    
}

//-----------------------------------------------------------------------
//  get_accRole()
//
//  DESCRIPTION:
//          Returns the accessibility role of the object.
//
//  PARAMETERS:
//
//      varChild    :   Variant that contains the child information
//      pvarRole    :   Address of the variant to receive the role information
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT         hr ;      
    long            lRetRole = 0;
    CAccBase *      pAccChild = NULL;

    // validate the out parameter
    if ( !pvarRole )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // clear the out parameter
    V_VT( pvarRole ) = VT_EMPTY;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        lRetRole = GetRole();   //this acc. objects role
    }
    else if ( V_I4(&varChild) == 1 )
    {
        // get the only acc child possible and delegate
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr || pAccChild == NULL)   // Possible to leave the pointer NULL.
            goto Cleanup;

        //call child's implementation
        lRetRole = pAccChild->GetRole();
    }
       
    if ( hr == S_OK )
    {
        // pack role into out parameter
        V_VT( pvarRole ) = VT_I4;
        V_I4( pvarRole ) = lRetRole;
    }
    
Cleanup:
    RRETURN( hr );
}

// ----------------------------------------------------------------------
//  DESCRIPTION:
//          Returns the accessibility state of the object.
//
//  PARAMETERS:
//
//      pvarState:   Address of the variant to receive the state information
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | E_POINTER | E_FAIL
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accState( VARIANT varChild, VARIANT *pvarState)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    // validate the out parameter
    if ( !pvarState )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //reset the out parameter.
    V_VT( pvarState ) = VT_EMPTY;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        V_VT( pvarState ) = VT_I4;

        //always focusable
        V_I4( pvarState ) = STATE_SYSTEM_FOCUSABLE;  

        //if the client site has the focus, 
        if (_pWindow->Doc()->GetFocus())
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED; 
    }
    else if ( V_I4(&varChild) == 1 )
    {   
        // get the only acc child possible and delegate
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )   
            goto Cleanup;

        //set the parameters and delegate the call
        //to the child
        V_I4( &varChild ) = CHILDID_SELF;
        
        hr = THR( pAccChild->get_accState( varChild, pvarState ) );
    }
    else
    {
        // the child id passed is invalid
        hr = E_INVALIDARG;
    }

Cleanup:
    RRETURN( hr );    
}

//----------------------------------------------------------------------------
//  get_accKeyboardShortcut
//
//  DESCRIPTION:
//      NOT IMPLEMENTED ON THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP
CAccWindow::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  get_accFocus
//
//  DESCRIPTION:
//      Returns the object that has the focus, inside the document that the 
//      window hosts.
//  
//  PARAMETERS:
//      pvarFocusChild  :   pointer to the VARIANT to receive the child that has
//                          the focus.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT     hr = S_OK;
    CElement *  pElemFocus = NULL;
    CAccBase *  pAccChild = NULL;
    
    if ( !pvarFocusChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarFocusChild ) = VT_EMPTY;

    pElemFocus = _pWindow->Doc()->_pElemCurrent;

    //if no element has the focus, then return S_OK,
    //and VT_EMPTY in the out parameter
    if ( !pElemFocus )
        goto Cleanup;

    //an element has the focus, we have to return its
    //accessible object.
    pAccChild = GetAccObjOfElement( pElemFocus );

    if ( !pAccChild )
    {   
        hr = E_FAIL;
        goto Cleanup;
    }

    V_VT( pvarFocusChild ) = VT_DISPATCH;
    V_DISPATCH( pvarFocusChild ) = pAccChild;

    //increment reference count before handing the pointer out.
    pAccChild->AddRef();
       
Cleanup:
    RRETURN( hr );
}


STDMETHODIMP 
CAccWindow::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return E_NOTIMPL;
}

                                                    
//----------------------------------------------------------------------------
//  get_accDefaultAction
//
//  DESCRIPTION:
//      NOT IMPLEMENTED ON THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//  accSelect
//  
//  DESCRIPTION: IAccessible::accSelect implementation for the accessible window
//                  object. Always sets the focus on the element client of the 
//                  CDoc.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT     hr;
    CElement *  pClient = NULL;

    if ( flagsSel != SELFLAG_TAKEFOCUS )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // unpack varChild
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    // Window can only answer for itself and its element client.
    if ((V_I4( &varChild ) != CHILDID_SELF ) && 
        (V_I4( &varChild ) != 1) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    // always focus on the element client.
    pClient = CMarkup::GetElementClientHelper(_pWindow->_pMarkup);
    if ( !pClient )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( pClient->focus() );

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  accLocation
//  
//  DESCRIPTION :   
//      The window is the top level accessibility object and its location is 
//      relative to the top left corner of the screen. This method gets the
//      window that sites the document and gets its coordinates using a Win32
//      call. 
//  
//      The pane and the window objects return the same location.
//      
//  PARAMETERS:
//      pxLeft
//      pyTop       : (x,y) Coordinates of the left top window
//      pcxWidth    : Width of the window
//      pcxHeight   : Height of the window
//      varChild    : Child ID.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accLocation(   long* pxLeft, long* pyTop, 
                           long* pcxWidth, long* pcyHeight, 
                           VARIANT varChild)
{
    HRESULT hr;
    RECT    rectPos = { 0 };
    CDoc *  pDoc = _pWindow->Doc();

//      There is no indication that a client may want to
//      get partial location information and we should be flexible 
//      in respect to that. For simplicity and perf reasons, we are
//      assuming that all four parameters will be provided.
//      This may change, if we decide to be more flexible and let 
//      an arbitrary out parameter to be ignored.
//
    Assert( pxLeft && pyTop && pcxWidth && pcyHeight );

    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pxLeft = *pyTop = *pcxWidth = *pcyHeight = 0;

    // unpack varChild
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    // Since the element client also calls this method, we can accept 
    // both CHILDID_SELF and 1 as valid child id values.
    if ((V_I4( &varChild ) != CHILDID_SELF ) && 
        (V_I4( &varChild ) != 1 ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // for the window, the location is relative to the screen's coordinates
    // the same location is used for the pane (body/frameset) that it contains too.
    // If the window is not inplave activated, ( frames ) then the _pDoc->GetHWND
    // will return NULL. 
    if (!pDoc || 
        !pDoc->GetHWND() || 
        !::GetWindowRect( pDoc->GetHWND( ), &rectPos ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
        
    *pxLeft = rectPos.left;
    *pyTop =  rectPos.top;
    *pcxWidth = rectPos.right - rectPos.left;
    *pcyHeight = rectPos.bottom - rectPos.top;
    
Cleanup:    
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accNavigate
//  
//  DESCRIPTION:
//      Provides navigation for children. Since the window accessible object
//      can have only one child, NAVDIR_NEXT and NAVDIR_PREVIOUS are not valid.
//      The valid navigation directions are NAVDIR_FIRST and NAVDIR_LAST and
//      they both return the same accessible object, which is connected to the
//      element client of the document.
//
//  PARAMETERS:
//      navDir      :   Navigation direction information ( first, last, next, previous)
//      varStart    :   Starting child id.
//      pvarEndUpAt :   Destionation child ID
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarEndUpAt ) = VT_EMPTY;

    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varStart));
    if ( hr )
        goto Cleanup;    

    switch ( navDir )
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            // An acc object can only return its own first and last children.
            if ( V_I4(&varStart) != CHILDID_SELF )
            {
                hr = E_INVALIDARG;
                break;
            }
            
            //Retrieve the accessible child object
            hr = THR( GetClientAccObj( &pAccChild ) );
            if ( hr ) 
                break;

            Assert( pAccChild );

            //set the return parameter to our only child
            V_VT( pvarEndUpAt ) = VT_DISPATCH;
            V_DISPATCH( pvarEndUpAt ) = DYNCAST( IDispatch, pAccChild);

            //increment ref count.
            pAccChild->AddRef();
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_NEXT:
            // We know that we are not a frame.
            // Since there is only one child and we can not go 
            // left or right from that child, it does not matter what
            // values we get. We will always return S_FALSE as the return
            // value, complying with the spec in this area.
            hr = S_FALSE;

            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//
//  DESCRIPTION :   
//
//      Determine if the hit was in this object's client area.
//
//  PARAMETERS:
//      xLeft
//      yTop    :   (x,y) coordinates of the point relative to the top left
//                          of the screen.
//      pvarChildAtPoint:   pointer to VARIANT to receive the information about
//                          the child that contains the point. 
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    HRESULT     hr = S_OK;
    RECT        rectPos = {0};
    CAccBase *  pAccChild = NULL;
    
    if (!pvarChildAtPoint)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // reset out parameter, this is also the proper return value if the hit
    // point was not inside this window
    V_VT(pvarChildAtPoint) = VT_EMPTY;
    
    //for the window, the location is relative to the screen's coordinates
    //the same location is used for the pane (body/frameset) that it contains too.
    //_pDoc->GetHWND() may return NULL, if the window is not inplace activated.

    // if this is the top level markup then get the window location 
    // otherwise, this is a frame and we should get the frame location.
    if ( _pWindow->_pMarkup->IsPrimaryMarkup() )
    {
        CDoc * pDoc = _pWindow->Doc();

        if ( !pDoc->GetHWND() || 
             !::GetWindowRect( pDoc->GetHWND(), &rectPos ) )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        if (hr)
            goto Cleanup;
    }
    else
    {
        CVariant    varChild(VT_I4);
        long        lWidth;
        long        lHeight;

        // this is a frame, and we should get the frame location.
        hr = accLocation( &rectPos.left, &rectPos.top, &lWidth, &lHeight, varChild);
        if (hr)
            goto Cleanup;

        rectPos.right = rectPos.left + lWidth;
        rectPos.bottom = rectPos.top + lHeight;
    }
    
    //if (x, y) is inside us, 
    if ( ((rectPos.left < xLeft) && (rectPos.right > xLeft)) && 
         ((rectPos.top  < yTop) && (rectPos.bottom > yTop)) )
    {
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )
            goto Cleanup;

        //set the out parameter and return
        V_VT( pvarChildAtPoint ) = VT_DISPATCH;
        V_DISPATCH( pvarChildAtPoint ) = pAccChild;

        pAccChild->AddRef();    //increment the reference count
    }

    //else, the out parameter contains VT_EMPTY and return code is S_OK
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accDoDefaultAction
//
//  DESCRIPTION:
//      NOT IMPLEMENTED ON THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP
CAccWindow::accDoDefaultAction( VARIANT varChild )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  GetClientAccObj
//
//  DESCRIPTION:
//      Gets the accessible object for the element client of the window.
//----------------------------------------------------------------------------
HRESULT 
CAccWindow::GetClientAccObj( CAccBase ** ppAccChild )
{
    HRESULT             hr = S_OK;
    ELEMENT_TAG         elemTag;
    CElement *          pClient = NULL;
    Assert( ppAccChild );

    // We used to think that windows only had one child, which was the client, which was either a body or a frame.
    // However, in a viewlinked webOC situation, the window is linked directly to the root of another markup.
    // That root has, as a child, the object that is the webOC. It also has an HTML tag that contains a BODY. 
    // We want to return the OBJECT instead of the BODY as the child of the root element so that we can get
    // information from the webOC.
    
    if (_pWindow->_punkViewLinkedWebOC)
    {
        CMarkupPointer  *   pelemBegin = &_elemBegin;
        CMarkupPointer  *   pelemEnd = &_elemEnd;
        MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;

#if DBG == 1
        CMarkup * pdbgMarkup = _pWindow->Markup();
        Assert(pdbgMarkup);
        CTreeNode * pdbgNode = pdbgMarkup->RootNode();
        Assert(pdbgNode);
        CElement * pdbgElement = pdbgNode->Element();
        Assert(pdbgElement);
#endif
        
        CTreeNode * pElemNode = _pWindow->Markup()->RootNode();

        hr = GetSubMarkupLimits(pElemNode->Element(), pelemBegin, pelemEnd);

        while( !pelemBegin->IsEqualTo(pelemEnd) && pElemNode->Element()->Tag() != ETAG_OBJECT)
        {
            hr = THR( pelemBegin->Right(TRUE, &context, &pElemNode, NULL, NULL, NULL) );
            if (hr)
                goto Cleanup;
        }
        
        // we shouldn't run off the end without hitting the object
        Assert(pElemNode->Element()->Tag() == ETAG_OBJECT);
        *ppAccChild = GetAccObjOfElement(pElemNode->Element());
    }
    else
    {
        pClient = CMarkup::GetElementClientHelper(_pWindow->_pMarkup);

        if ( !pClient )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // We must have either a frameset or a body tag.
        elemTag = pClient->Tag();

        if ((elemTag != ETAG_FRAMESET) && 
            (elemTag != ETAG_BODY) )
        {
            // something weird happened, and the client is 
            // neither a frameset nor a body
            Assert(0 && "strange tree: window with no body or frameset");
            hr = E_FAIL;
            goto Cleanup;
        }

        // Get the accessible object for the element.
        *ppAccChild = GetAccObjOfElement( pClient );
        if (*ppAccChild == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // make sure that we have something going back.
    Assert( *ppAccChild );

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  put_accValue
//  
//  DESCRIPTION :   
//          Sets the value property of the accessible object. This method is not
//          supported on accessible objects that are derived from the CAccWindow
//
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      bstrValue    :   value bstr
//
//  RETURNS:
//      E_NOTIMPL
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//  AccObjFromWinwow
//
//  DESCRIPTION:
//      Helper function that wraps the code that is needed to call the OLEACC
//      API AccessibleObjectFromWindow
//
//  PARAMETERS:
//      hWnd    :   Window handle to get the acc. object for.
//      ppAccObj:   Address of the pointer to receive the address of the acc.obj.
//----------------------------------------------------------------------------
HRESULT
CAccWindow::AccObjFromWindow( HWND hWnd, void ** ppAccObj )
{
    HRESULT hr;
    
    static DYNPROC s_dynprocAccObjFromWindow =
            { NULL, &g_dynlibOLEACC, "AccessibleObjectFromWindow" };

    // Load up the AccessibleObjectFromWindow pointer.
    hr = THR(LoadProcedure(&s_dynprocAccObjFromWindow));
    if (hr)
        goto Cleanup;

    hr = THR ((*(LRESULT (APIENTRY *)(HWND, DWORD, REFIID, void**))
                s_dynprocAccObjFromWindow.pfn)( hWnd, OBJID_CLIENT, 
                                                IID_IAccessible, ppAccObj) );
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetEnumerator
//
//  DESCRIPTION:    Fills the return parameter with the address of the 
//                  implementation for the IEnumVARIANT.
//                  Since the window object has only one child and that child
//                  is the element client of the document, the list contains
//                  only one item.
//                  The return value can not be E_NOINTERFACE, since the window
//                  always has a single child.
//  RETURNS:
//          S_OK | E_POINTER | E_OUTOFMEMORY
//----------------------------------------------------------------------------
HRESULT
CAccWindow::GetEnumerator( IEnumVARIANT** ppEnum)
{
    HRESULT                     hr;
    CDataAry <VARIANT> *        pary = NULL;
    CAccBase *                  pAccChild = NULL;
    VARIANT                     varTmp;
    IDispatch *                 pDispTmp;

    VariantInit( &varTmp );

    if ( !ppEnum )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    pary = new(Mt(CAccWindowGetEnumerator_aryVariants_pv)) 
                    CDataAry<VARIANT>(Mt(CAccWindowGetEnumerator_aryVariants_pv));
    if ( !pary )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // This is the window, so it has ony one child.
    // Get the child, and append it to the child list.
    hr = THR( GetClientAccObj( &pAccChild ));
    if ( hr )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // increment the ref count and do the casting at the same time. 
    hr = THR( pAccChild->QueryInterface( IID_IDispatch, (void**)&pDispTmp));
    if ( hr )
        goto Cleanup;

    Assert( pDispTmp );    // we must have our value

    V_DISPATCH(&varTmp) = pDispTmp;
    V_VT( &varTmp ) = VT_DISPATCH;      // set the type.

    // append the variant to the list.
    hr = THR(pary->EnsureSize(1));
    if (hr)
        goto Cleanup;

    hr = THR( pary->AppendIndirect( &varTmp, NULL ) );
    if ( hr )
        goto Cleanup;

    hr = THR(pary->EnumVARIANT(VT_VARIANT, 
                                ppEnum, 
                                FALSE,  // don't copy the array being enumerated use the one we gave
                                TRUE)); // delete enumeration when no one is left to use .

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  Function    :   PrivateQueryInterface
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::PrivateQueryInterface(REFIID riid, void ** ppv)
{
    if ( riid == IID_IOleWindow )
    {
        *ppv = (IOleWindow *)this;
        ((LPUNKNOWN) *ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return super::PrivateQueryInterface(riid,ppv);
    }
}

//----------------------------------------------------------------------------
//      Function    :   EnsureAccWindow
//      
//      Description :   Helper function that ensures the window object passed in
//                      has an accessible window attached to it.
//      
//      Returns     :   S_OK if successfull, errorcode otherwise.
//----------------------------------------------------------------------------
HRESULT
EnsureAccWindow( CWindow * pWindow )
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup;
    CAccBase * pAccObj = NULL;

    if (pWindow)
        pMarkup = pWindow->_pMarkup;
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // if we already have an accwindow don't do anything.
    if (pWindow->_pAccWindow)
        goto Cleanup;

    // If this window is the window for the primary markup, then the CAccWindow
    // will be attached to the primary window. Otherwise a CAccFrame will be 
    // created and attached to the element that is containing the  window on the parent document
    if (pMarkup->IsPrimaryMarkup())
    {
        pAccObj = new CAccWindow(pWindow);
    }
    else
    {
        CRootElement * pElemRoot = pMarkup->Root();
        CElement * pElemMaster;

        // get the element on the parent markup
        Assert(pElemRoot->HasMasterPtr());

        if (!((CElement *)pElemRoot)->HasMasterPtr())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pElemMaster = ((CElement *)pElemRoot)->GetMasterPtr();

        //If the pElemMaster->Tag() is not a frame tag, navigate
        //up searching for the Frame one.
        while ((pElemMaster->Tag() != ETAG_FRAME) && (pElemMaster->Tag() != ETAG_IFRAME))
        {            
            pMarkup = pElemMaster->GetWindowedMarkupContext();
            pElemRoot =  pMarkup->Root();
            
            if (!((CElement *)pElemRoot)->HasMasterPtr())
            {
                if (pMarkup->IsPrimaryMarkup())
                {
                    pAccObj = new CAccWindow(pWindow);
                    goto Setaccwindowpointer;
                }
                else
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            
            pElemMaster = ((CElement *)pElemRoot)->GetMasterPtr();
            if (!pElemMaster)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        // this may change with view link support
        Assert((pElemMaster->Tag() == ETAG_FRAME) ||
                (pElemMaster->Tag() == ETAG_IFRAME));

        pAccObj = GetAccObjOfElement(pElemMaster);
    }
    
Setaccwindowpointer:
    Assert(pAccObj);
    
    if (pAccObj)
        pWindow->_pAccWindow = (CAccWindow *)pAccObj;
    else
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  Function    :   IServiceProvider::QueryService
//
//  Description :   Function that provides access to other objects that are 
//                  related to this accessible object, but do not have the
//                  same COM identity.
//
//                  Service requests that are supported are:
//                  IID_IHTMLWindow2
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::QueryService(  REFGUID guidService, REFIID riid, void ** ppvObject)
{
    HRESULT hr;

    if (!ppvObject)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsEqualGUID(guidService, IID_IHTMLWindow2))
    {
        hr = THR(_pWindow->QueryInterface(riid, ppvObject));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\breaker.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member:     LineBreakCompat
//
//  Notes:      Ported from IE4.  Simulates the presence of block break
//              chars.
//
//----------------------------------------------------------------------------

MtDefine(CLineBreakCompat_Misc, Tree, "Misc CLineBreakCompat arrays")

CLineBreakCompat::CLineBreakCompat ( )
  : _aryStackBS           ( Mt( CLineBreakCompat_Misc ) ),
    _aryRunEvents         ( Mt( CLineBreakCompat_Misc ) ),
    _aryBreaks            ( Mt( CLineBreakCompat_Misc ) ),
    _aryTableBreakCharIds ( Mt( CLineBreakCompat_Misc ) )
{
    _pMarkup = NULL;
    _fWantEndingBreak = FALSE;
}

HRESULT
CLineBreakCompat::Init ( CTreePos * ptp )
{
    HRESULT hr = S_OK;
    CTreeNode * pNode;
    CStackDataAry < CBlockScope, 32 > aryStackBS ( Mt( Mem ) );
    int i;

    _pMarkup = ptp->GetMarkup();

    _lMarkupContentsVersion = _pMarkup->GetMarkupContentsVersion();
            
    _aryStackBS.SetSize( 0 );
    _aryTableBreakCharIds.SetSize( 0 );

    //
    // Move back to a chunk of text
    //
    
    for ( _ptpPrevBreak = NULL, _ptpWalk = ptp ; ; _ptpWalk = _ptpWalk->PreviousTreePos() )
    {
        if (!_ptpWalk)
        {
            _ptpPrevBreak = _pMarkup->FirstTreePos();
            _ptpWalk = _ptpPrevBreak->NextTreePos();
            _ptpNextBreak = _ptpWalk;
            break;
        }
        else if (_ptpWalk->IsText() && _ptpWalk->Cch())
        {
            _ptpPrevBreak = _ptpWalk;
            _ptpNextBreak = _ptpWalk;
            break;
        }
    }

    _textInScope = TIS_NONE;
    _nNextTableBreakId = -1;
    _pElementLastBlockBreak = NULL;
    _fInTable = FALSE;
    _BreakPending.Clear();

    //
    // Prime block stack
    //

    for ( pNode = _ptpWalk->GetBranch() ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElement = pNode->Element();
        CFlowLayout * pFlowLayoutAbove = pElement->GetFlowLayout(GUL_USEFIRSTLAYOUT);   // FIRSTLAYOUT okay so long as MULTI_FORMAT is disabled
        
        if (pFlowLayoutAbove && pFlowLayoutAbove->IsElementBlockInContext( pElement ))
        {
            CBlockScope * pbsNew;
            
            hr = THR( aryStackBS.AppendIndirect( NULL, & pbsNew ) );
            
            if (hr)
                goto Cleanup;

            pbsNew->pNodeBlock = pNode;
            pbsNew->fVirgin = FALSE;
        }
    }

    for ( i = aryStackBS.Size() - 1 ; i >= 0 ; i-- )
    {
        hr = THR( _aryStackBS.AppendIndirect( & aryStackBS [ i ], NULL ) );
        
        if (hr)
            goto Cleanup;
    }

    if (aryStackBS.Size() > 0)
        _aryStackBS[ aryStackBS.Size() - 1 ].fVirgin = TRUE;

Cleanup:

    RRETURN( hr );
}

void
CLineBreakCompat::SetWantPendingBreak ( BOOL fWant )
{
    _fWantEndingBreak = fWant;
    _pMarkup = NULL;
}

HRESULT
CLineBreakCompat::QueryBreaks ( CMarkupPointer * pPointer, DWORD * pdwBreaks )
{
    HRESULT     hr;
    CTreePos *  ptp;
    long        ich;
    CTreePosGap tpg;

    ptp = pPointer->GetNormalizedReference( ich );

    //
    // Here can be no breaks between chars.
    //

    if (ptp->IsText())
    {
        if (ich > 0 && ich < ptp->Cch())
        {
            *pdwBreaks = 0;
            return S_OK;
        }

        hr = THR( tpg.MoveTo( ptp, ich == 0 ? TPG_LEFT : TPG_RIGHT ) );
    }
    else
        hr = THR( tpg.MoveTo( ptp, TPG_RIGHT ) );

    if (!hr)
        hr = THR( QueryBreaks( & tpg, pdwBreaks ) );

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::QueryBreaks ( CTreePosGap * ptpg, DWORD * pdwBreaks )
{
    HRESULT    hr = S_OK;
    CTreePos * ptp;
    int        i;
    int        nAttempts;
    BOOL       fReset;

    Assert( pdwBreaks );

    *pdwBreaks = 0;

    if (!ptpg->IsValid())
        goto Cleanup;

    ptp = ptpg->AdjacentTreePos( TPG_RIGHT );

    Assert( ptp );

    while ( ptp->IsPointer() )
        ptp = ptp->NextTreePos();

    //
    // Can only have breaks to the left of node pos's
    //
    
    if (!ptp->IsNode())
        goto Cleanup;

    //
    // Restart the breaker as neccesary.
    //

    if (!_pMarkup || _lMarkupContentsVersion != _pMarkup->GetMarkupContentsVersion() ||
        !_ptpPrevBreak || _ptpPrevBreak->InternalCompare( ptp ) >= 0)
    {
        hr = THR( Init( ptp ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Now, while ptp is greater than the end of the computed range,
    // compute the next range.  
    //
    // If we can't get in range after 5 times, then reset the
    // state machine to the ptp, and go on from there.
    //

    nAttempts = 5;
    fReset = FALSE;
    
    while ( _ptpNextBreak->InternalCompare( ptp ) < 0 )
    {
        if (!fReset && !nAttempts--)
        {
            //
            // This should get us into range
            //
            
            hr = THR( Init( ptp ) );

            if (hr)
                goto Cleanup;

            //
            // Never reset more than once.
            //
            
            fReset = TRUE;

            continue;
        }
        
        hr = THR( ComputeNextBreaks() );

        if (hr)
            goto Cleanup;
    }
    
    Assert( _ptpPrevBreak->InternalCompare( ptp ) < 0 );
    Assert( _ptpNextBreak->InternalCompare( ptp ) >= 0 );

    for ( i = _aryBreaks.Size() - 1 ; i >= 0 ; i-- )
    {
        BreakEntry * pbe = & _aryBreaks [ i ];

        if (pbe->ptp == ptp)
        {
            Assert(
                pbe->bt == BREAK_BLOCK_BREAK || 
                pbe->bt == BREAK_SITE_BREAK || 
                pbe->bt == BREAK_SITE_END );
            
            (*pdwBreaks) |= pbe->bt;
        }
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::ComputeNextBreaks ( )
{
    HRESULT    hr = S_OK;

    Assert( _lMarkupContentsVersion == _pMarkup->GetMarkupContentsVersion() );

    Assert( _ptpNextBreak );
    Assert( _ptpPrevBreak );

    //
    // Clear out the existing breaks in the current ran1ge
    //

    _aryBreaks.SetSize( 0 );
    
    //
    // Fill _aryRunEvents with events until substantive text is found
    //

    _aryRunEvents.SetSize( 0 );
    
    while ( _ptpWalk )
    {
        long cch = -1;
        
        Assert( _lMarkupContentsVersion == _pMarkup->GetMarkupContentsVersion() );
        
        if (_ptpWalk->IsNode())
        {
            if (!_ptpWalk->IsEdgeScope() || _ptpWalk->IsEndNode())
            {
                if (_ptpWalk->Branch()->Tag() == ETAG_ROOT)
                {
                    cch = 0;            // Force HandleText
                    _ptpWalk = NULL;    // Force exit of loop
                }
                else
                {
                    CRunEvent * preNew = _aryRunEvents.Append();

                    if (!preNew)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    preNew->ptp = _ptpWalk;
                    preNew->fEnd = TRUE;

                    int cIncl;
                    for ( cIncl = 0 ; ! _ptpWalk->IsEdgeScope() ; cIncl++ )
                        _ptpWalk = _ptpWalk->NextTreePos();

                    preNew->pNode = _ptpWalk->Branch();

                    if (hr)
                        goto Cleanup;

                    while ( cIncl-- )
                        _ptpWalk = _ptpWalk->NextTreePos();
                    
                    _ptpWalk = _ptpWalk->NextTreePos();
                }
            }
            else
            {
                Assert( _ptpWalk->IsBeginNode() );
                
                CRunEvent * preNew = _aryRunEvents.Append();
                
                if (!preNew)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                preNew->ptp = _ptpWalk;
                preNew->fEnd = FALSE;
                preNew->pNode = _ptpWalk->Branch();
                
                _ptpWalk = _ptpWalk->NextTreePos();
            }
        }
        else if (_ptpWalk->IsText())
        {
            long cch2 = 0;

            while ( ! _ptpWalk->IsNode() )
            {
                if (_ptpWalk->IsText())
                    cch2 += _ptpWalk->Cch();
                
                _ptpWalk = _ptpWalk->NextTreePos();
            }

            if (cch2 > 0)
                cch = cch2;
        }
        else
        {
            _ptpWalk = _ptpWalk->NextTreePos();
        }

        if (cch >= 0)
        {
            hr = THR( HandleText( _ptpWalk, cch ) );

            if (hr)
                goto Cleanup;

            _aryRunEvents.SetSize( 0 );

            //
            // If we generated any breaks, then we are done with this chunk!
            //

            if (_aryBreaks.Size())
                break;
        }
    }

    //
    // Establish the new range
    //

    _ptpPrevBreak = _ptpNextBreak;
    
    _ptpNextBreak =
        _aryBreaks.Size()
            ? _aryBreaks [ _aryBreaks.Size() - 1 ].ptp
            : _pMarkup->LastTreePos();

    Assert( _ptpPrevBreak && _ptpNextBreak );

Cleanup:

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::SetPendingBreak ( DWORD btBreakNew, CTreePos * ptpBreakNew )
{
    HRESULT hr = S_OK;
    DWORD btBreak = BREAK_NONE;
    CTreePos * ptpBreak = NULL;

    //
    // We must put the new pending break into _BreakPending so that SetBreak
    // can fixup the iRun in _BreakPending if the tree if modified.
    //

    if (_BreakPending.IsSet())
    {
        btBreak = _BreakPending.btBreak;
        ptpBreak = _BreakPending.ptpBreak;
    }

    _BreakPending.btBreak = btBreakNew;
    _BreakPending.ptpBreak = ptpBreakNew;
    _BreakPending.nBreakId = _nNextTableBreakId++;

    if (ptpBreak)
    {
        hr = THR( SetBreak( btBreak, ptpBreak ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::SetBreak ( DWORD btBreak, CTreePos * ptpBreak )
{
    BreakEntry * pbe = _aryBreaks.Append();

    if (!pbe)
        return E_OUTOFMEMORY;

    pbe->ptp = ptpBreak;
    pbe->bt = btBreak;

    return S_OK;
}

void
CLineBreakCompat::ClearPendingBlockBreak ( )
{
    if (_BreakPending.IsSet() && _BreakPending.btBreak == BREAK_BLOCK_BREAK)
        _BreakPending.Clear();
}

HRESULT
CLineBreakCompat::FlushPendingBreak ( )
{
    DWORD btBreak;
    CTreePos * ptpBreak;

    if (!_BreakPending.IsSet())
        return S_OK;

    btBreak = _BreakPending.btBreak;
    ptpBreak = _BreakPending.ptpBreak;

    _BreakPending.Clear();

    RRETURN( SetBreak( btBreak, ptpBreak ) );
}

void
CLineBreakCompat::RemoveScope ( CElement * pElement, CBlockScope & bsRemoved )
{
    int cbs = _aryStackBS.Size();

    Assert( cbs > 0 );

    //
    // Block tags CAN overlap, but that is rather rare.  Test for the most
    // common case where the block scope is the top one.
    //

    if (_aryStackBS [ cbs - 1 ].pNodeBlock->Element() == pElement)
    {
        bsRemoved = _aryStackBS [ cbs - 1 ];
        _aryStackBS.Delete( cbs - 1 );
        
        return;
    }

    int i;
    for ( i = _aryStackBS.Size() - 1 ; i >= 0 ; i-- )
    {
        if (_aryStackBS[ i ].pNodeBlock->Element() == pElement)
            break;
    }

    Assert( i >= 0 );

    bsRemoved = _aryStackBS[ i ];

    _aryStackBS.Delete( i );
}

static inline BOOL
BreaksLineInEmptyLi ( CElement * pElement )
{
    return pElement->HasFlag( TAGDESC_LIST );
}

static BOOL
RequiresTextSiteEndChar ( CTreeNode * pNode )
{
    return pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT) && ! pNode->IsContainer();
}

static BOOL
InducesTextSiteBreakChar ( CTreeNode * pNode )
{
    BOOL fBreak;
    
    if (pNode->Tag() == ETAG_TABLE)
        return TRUE;

    if (!pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
        return FALSE;

    if (pNode->IsContainer())
        return FALSE;

    //
    // If the first site above this one is not a text site, then no break.
    // This makes sure, for example, that table cells do not get a site break
    // char before them.
    //

    fBreak = FALSE;
    
    for ( pNode = pNode->Parent() ; pNode ; pNode = pNode->Parent() )
    {
        if (pNode->ShouldHaveLayout())
        {
            fBreak = pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT) != NULL;
            break;
        }
    }

    return fBreak;
}

HRESULT
CLineBreakCompat::HandleText ( CTreePos * ptpRunNow, long cchInRun )
{
    HRESULT hr = S_OK;

    //
    // Process all the element events.
    //

    for ( int i = 0 ; i < _aryRunEvents.Size() ; i++ )
    {
        CTreePos * ptp = _aryRunEvents[ i ].ptp;
        CTreeNode * pNode = _aryRunEvents[ i ].pNode;
        CElement * pElement = pNode->Element();
        CFlowLayout * pFlowLayout = pElement->HasFlowLayout(GUL_USEFIRSTLAYOUT);
        CFlowLayout * pFlowLayoutAbove = pElement->GetFlowLayout(GUL_USEFIRSTLAYOUT);   // FIRSTLAYOUT okay so long as MULTI_FORMAT is disabled
        ELEMENT_TAG etag = pElement->Tag();
        BOOL fEnd = _aryRunEvents[ i ].fEnd;
        BOOL fIsBlock = pFlowLayoutAbove ? pFlowLayoutAbove->IsElementBlockInContext( pElement ) : FALSE;
        BOOL fAlwaysBreak = etag == ETAG_LI;
        BOOL fBreakOnEmpty = !fAlwaysBreak && pElement->_fBreakOnEmpty;
        BOOL fBreaksLine = pElement->BreaksLine();
        BOOL fIs1DDiv = (etag == ETAG_DIV || etag == ETAG_FIELDSET) && pElement->ShouldHaveLayout();

        //
        // The following controls the insertion of text site break characters
        // into the correct places.
        //
        // When certain sites come into scope, this causes site break characters
        // to be inserted into the parent text site.
        //
        // When certain text sites go out of scope, they get text site break
        // characters inserted at their end.
        //
        // If we are linebreaking for a text site which is not the ped, make
        // sure that we don't attempt to place a site break char before the
        // text site we are breaking (doing so would mean that we modified
        // stuff outside of the text site we are supposed to break).
        //
        
        if (!fEnd && InducesTextSiteBreakChar( pNode ))
        {
            CTreeNode * pNodeParent;
            CElement * pFlowLayoutParent;

            hr = THR( FlushPendingBreak() );

            if (hr)
                goto Cleanup;

            //
            // Associate the break with the element directly above
            // the table/marquee
            //

            pNodeParent = pNode->Parent();

            pFlowLayoutParent = pNodeParent->GetFlowLayoutElement(GUL_USEFIRSTLAYOUT);

            if (pFlowLayoutParent)
            {
                hr = THR( SetPendingBreak( BREAK_SITE_BREAK, ptp ) );

                if (hr)
                    goto Cleanup;
            }

            //
            // If the element inducing the site break is a table, we may
            // need to clear this site break char if there are no cells in
            // the table.  Here we record the id of the break char to be used
            // when the table goes out of scope.
            //

            if (etag == ETAG_TABLE)
            {
                hr = THR( _aryTableBreakCharIds.Append( _BreakPending.nBreakId ) );

                if (hr)
                    goto Cleanup;
            }
        }
        
        if (fEnd && RequiresTextSiteEndChar( pNode ))
        {
            Assert( pFlowLayout );

            //
            // Only clear a pending block break if we have not been
            // requested to save them.  If we are asked to save them,
            // then we will, for example, produce block breaks for blocks
            // at the end of text sites.
            //

            if (!_fWantEndingBreak)
                ClearPendingBlockBreak();

            hr = THR( SetPendingBreak( BREAK_SITE_END, ptp ) );

            if (hr)
                goto Cleanup;

            //
            // Text site end chars always go in.  If we do not flush here,
            // we might not get another break to push it in.
            //

            hr = THR( FlushPendingBreak() );

            if (hr)
                goto Cleanup;
            
            //
            // No text in scope just after a text site char.  However, a table
            // going out of scope, for example, will, later, cause fake text to
            // come into scope.
            //

            _textInScope = TIS_NONE;
        }

        //
        // When a table goes out of scope, we need to check to see if we should
        // clear the pending site break for the table.
        //

        if (fEnd && etag == ETAG_TABLE)
        {
            long nIds, nIdLast;
            
            nIds = _aryTableBreakCharIds.Size();
            
            if (nIds > 0)
            {
                nIdLast = (LONG)_aryTableBreakCharIds[ nIds - 1 ];
                          
                _aryTableBreakCharIds.Delete( nIds - 1 );

                if (_BreakPending.IsSet() && nIdLast == _BreakPending.nBreakId)
                    _BreakPending.Clear();
            }
        }
        
        //
        // Keep the _fInTable state up to date
        //

        if (fEnd)
        {
            if (etag == ETAG_TABLE)
            {
                _fInTable = FALSE;
            }
            else if (pFlowLayout)
            {
                CTreeNode * pNodeTemp = pNode->Parent();

                _fInTable = FALSE;
                
                for ( ; pNodeTemp ; pNodeTemp = pNodeTemp->Parent() )
                {
                    if (pNodeTemp->Tag() == ETAG_TABLE)
                    {
                        _fInTable = TRUE;
                        break;
                    }
                    else if (pNodeTemp->HasFlowLayout(GUL_USEFIRSTLAYOUT))
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            if (etag == ETAG_TABLE)
            {
                _fInTable = TRUE;
            }
            else if (pFlowLayout)
            {
                _fInTable = FALSE;
            }
        }

        //
        // Because of flat run, some tags should not break a line.
        //

        if (pNode->ShouldHaveLayout() || _fInTable)
            fBreaksLine = FALSE;

        ///////////////////////////////////////////////////////////////////////
        //
        // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKAHCK!!
        //
        // When elements are created during editing, the break on empty bit
        // is always set on them (I'm not thrilled about this).  For some
        // elements, we must always ignore the break on empty.
        //

        if (pElement->HasFlag( TAGDESC_LIST ) || pFlowLayout)
        {
            fBreakOnEmpty = FALSE;
        }

        //
        // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKAHCK!!
        //
        ///////////////////////////////////////////////////////////////////////

        if (fIsBlock && !fEnd)
        {
            CBlockScope * pbsNew;

            //
            // Before we push the new block element onto the stack, if there is
            // a parent block element which is currently non-empty and not
            // already broken, and the new element is capable of breaking a
            // line, break it.
            //
            // This takes care of HTML like <h1>A<h2>, where the nested <h2>
            // immediately breaks the current contents of the <h1>.
            //
            // Also, for HTML like <li><h1>A, the <li> will not be broken
            // immedaitely because it will be currently empty (there is no
            // text between <li> and <h1>.
            //

            if (_aryStackBS.Size() > 0)
            {
                CBlockScope & bsTop = TopScope();
                enum BREAK { NO_BREAK, PENDING_BREAK, MANDATORY_BREAK };
                BREAK fBreak = NO_BREAK;

                //
                // If we have just seen text and this element comming into
                // scope is the kind of element which breaks lines, then break
                // a line because of it.
                //

                if (fBreaksLine && _textInScope)
                {
                    fBreak = PENDING_BREAK;

                    ///////////////////////////////////////////////////////////
                    //
                    // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
                    //
                    // Again, because of the nasty break on empty bits in
                    // ui-generated elements, we must ignore simulated text
                    // when certain elements are nested. For example,
                    // <blockquote> and <div>.
                    //

                    if (_textInScope == TIS_FAKE &&
                        (bsTop.pNodeBlock->Tag() == ETAG_BLOCKQUOTE ||
                         bsTop.pNodeBlock->Tag() == ETAG_DIV))
                    {
                        fBreak = NO_BREAK;
                    }

                    //
                    // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
                    //
                    ///////////////////////////////////////////////////////////
                }

                ///////////////////////////////////////////////////////////////
                //
                // !!HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK!!
                //
                // Hack to break certain element in the context of <LI>
                //

                if (bsTop.pNodeBlock->Tag() == ETAG_LI && bsTop.fVirgin &&
                    BreaksLineInEmptyLi( pElement ))
                {
                    fBreak = MANDATORY_BREAK;
                }

                //
                // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
                //
                ///////////////////////////////////////////////////////////////

                if (fBreak != NO_BREAK)
                {
                    hr = THR( SetPendingBreak( BREAK_BLOCK_BREAK, ptp ) );
                    
                    if (hr)
                        goto Cleanup;

                    if (fBreak == MANDATORY_BREAK)
                    {
                        hr = THR( FlushPendingBreak() );

                        if (hr)
                            goto Cleanup;
                    }

                    //
                    // Note that we do not set _pElementLastBreak to
                    // bsTop.pElementBlockhere because pElementScope is comming
                    // intpo scope, and would simply NULL it out anyway.
                    //
                }

                //
                // The parent block element is going out of scope, if it is
                // entered again we have to know if it not the first time.
                //

                bsTop.fVirgin = FALSE;
            }

            //
            // Push the new block element onto the stack.
            //

            hr = THR( _aryStackBS.AppendIndirect( NULL, & pbsNew ) );
            
            if (hr)
                goto Cleanup;

            pbsNew->pNodeBlock = pNode;
            pbsNew->fVirgin = TRUE;

            //
            // On the opening of a new block element, we must forget the last
            // element which received a block break.
            //

            _pElementLastBlockBreak = NULL;

            //
            // If the current block is marked as break on empty, then simulate
            // the presense of text, other wise we have not yet seen text after
            // this element.
            //

            _textInScope = fBreakOnEmpty ? TIS_FAKE : TIS_NONE;
        }
        else if (fIsBlock && fEnd)
        {
            //
            // Remove the scope corresponding to the element, copying the scope
            // state into bs.
            //

            CBlockScope bsEnd;

            RemoveScope( pElement, bsEnd );

            //
            // If the element going out of scope was not already broken and is
            // either non-empty or always breaks a line, the let it break a
            // line. (remember that end-tags are received in the first run they
            // don't influence after the last run they do).
            //
            // This takes care of HTML like <p>A<p> where the first <p> goes
            // out of scope, and should break.
            //
            // This also deals with empty <li>'s (the fAlwaysBreak check).
            //
            // Note that here we make sure that we break a line only the first
            // time this block is entered.
            //
            // Note here that we are associating the break char with the
            // element most recent in scope.  We have to do this because the
            // element going out of scope might not be on the top of the stack,
            // and we might split a run, and must point to the nearest element.
            //

            if (fBreaksLine && (_textInScope || (fAlwaysBreak && bsEnd.fVirgin)))
            {
                //
                // Must flush here (potentially modify the tree) before
                // inspecting the tree.
                //

                hr = THR( FlushPendingBreak() );

                if (hr)
                    goto Cleanup;

                //
                // We must not insert two breaks in a row for the same element
                //

                if (pElement != _pElementLastBlockBreak)
                {
                    hr = THR( SetPendingBreak( BREAK_BLOCK_BREAK, ptp ) );

                    if (hr)
                        goto Cleanup;
                    
                    _pElementLastBlockBreak = pElement;

                    //
                    // An 5.0 change to the measurer/renderer causes the last
                    // empty LI in a UL to have a block break when the list is
                    // in a table cell.  This was not the case for 4.0.  Thus,
                    // when an LI sets a pending block break, we force it in, so
                    // the ClearPendingBlockBreak call made when the table cell
                    // goes out of scope does not nuke the block break created
                    // by the LI.
                    //

                    if (etag == ETAG_LI)
                    {
                        hr = THR( FlushPendingBreak() );

                        if (hr)
                            goto Cleanup;
                    }
                }
            }

            //
            // If wanted, don't loose a pending break when major containers
            // go out of scope.
            //

            if (_fWantEndingBreak && etag == ETAG_BODY)
            {
                hr = THR( FlushPendingBreak() );

                if (hr)
                    goto Cleanup;
            }
            
            //
            // If a line breaking element just went out of scope, no text is in
            // scope
            //

            if (fBreaksLine)
                _textInScope = TIS_NONE;
        }

        //
        // Before flat run, some elements used to be embedded in the runs and
        // had an embedding character in the text, and had their own runs.
        // Now, in the non-flat world, these elements no longer have embedding
        // characters, but they still need to behave as though they did.  So,
        // here we check for these elements, and synthesize the presence of
        // text.
        //

        if (fEnd &&
            (etag == ETAG_TABLE ||
             etag == ETAG_MARQUEE ||
             etag == ETAG_SELECT ||
             etag == ETAG_BR ||
             etag == ETAG_HR ||
             etag == ETAG_OBJECT ||
             etag == ETAG_IMG ||
             etag == ETAG_INPUT ||
             etag == ETAG_BUTTON ||
             etag == ETAG_TEXTAREA ||
             fIs1DDiv) &&
            pNode->IsInlinedElement())
        {
            _textInScope = TIS_SIMU;
        }
    }

    _aryRunEvents.SetSize( 0 );

    if (cchInRun > 0)
    {
        //
        // If we find characters in a run, then we can flush any pending
        // breaks set prior to finding this text
        //

        hr = THR( FlushPendingBreak() );

        if (hr)
            goto Cleanup;

        //
        // There are real chars here, mark the block element owning these
        // chars to indicate that chars have been found in it scope.
        //

        _textInScope = TIS_REAL;

        //
        // When se see text, we forget the last element which received a block
        // break;
        //

        _pElementLastBlockBreak = NULL;
    }

Cleanup:

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\chnglog.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CHNGLOG_HXX_
#define X_CHNGLOG_HXX_
#include "chnglog.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif


MtDefine(CChangeLog, Tree, "CChangeLog");


CChangeLog::CChangeLog( CLogManager     *   pLogMgr,
                        IHTMLChangeSink *   pChangeSink,
                        CChangeRecord_Placeholder * pPlaceholder)
{
    _pLogMgr        = pLogMgr;
    _pPlaceholder   = pPlaceholder;
    _pChangeSink    = pChangeSink;
    _pChangeSink->AddRef();
}

CChangeLog::~CChangeLog()
{
}

//+----------------------------------------------------------------+
//
//  Method: GetNextChange
//
//  Synopsis: Gets the next Change Record for the client, if the
//      buffer provided was adequate.  Returns the required buffer
//      size, if a pointer is given.
//
//+----------------------------------------------------------------+

STDMETHODIMP
CChangeLog::GetNextChange(
    BYTE * pbBuffer,
    long   nBufferSize,
    long * pnRecordLength )
{
    HRESULT             hr      = S_OK;
    CChangeRecordBase * pchrec;
    long                nLen;
    DWORD               dwFlags = 0;

    // If they say they gave us a buffer, we need a pointer
    if( ( nBufferSize > 0 && !pbBuffer ) || !pnRecordLength )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pchrec = _pPlaceholder->GetNextRecord();

    // No further records
    if( !pchrec )
    {
        *pnRecordLength = 0;

        goto Cleanup;
    }

    nLen = pchrec->RecordLength( _pPlaceholder->_opcode );

    *pnRecordLength = nLen;

    // I think I need a bigger buffer
    if( nBufferSize < nLen )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Copy the buffer
    memcpy( pbBuffer, &(pchrec->_opcode), nLen );

    // Set the flags appropriately - turn on the bit
    // for what they're not interested in, then AND
    // the inverse of that with the opcode.
    Assert( ( _pPlaceholder->_opcode & CHANGE_RECORD_FORWARD ) || 
            ( _pPlaceholder->_opcode & CHANGE_RECORD_BACKWARD ) );

    if( !( _pPlaceholder->_opcode & CHANGE_RECORD_FORWARD ) )
    {
        dwFlags |= CHANGE_RECORD_FORWARD;
    }
    else if( !( _pPlaceholder->_opcode & CHANGE_RECORD_BACKWARD ) )
    {
        dwFlags |= CHANGE_RECORD_BACKWARD;
    }
    *(DWORD *)pbBuffer &= ~dwFlags;

    // Reposition our placeholder
    _pLogMgr->RemovePlaceholder( _pPlaceholder );
    _pLogMgr->InsertPlaceholderAfterRecord( _pPlaceholder, pchrec );

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//+----------------------------------------------------------------+
//
//  Method: SetDirection
//
//  Synopsis: Allows the client to request which direction of
//      information they're interested in.
//
//+----------------------------------------------------------------+

STDMETHODIMP
CChangeLog::SetDirection( BOOL fForward, BOOL fBackward )
{
    HRESULT hr      = S_OK;

    Assert( _pLogMgr );
    Assert( fForward || fBackward );

    if( !fForward && !fBackward )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    _pPlaceholder->_opcode = CHANGE_RECORD_OPCODE( (DWORD)_pPlaceholder->_opcode & ~CHANGE_RECORD_BOTH );
    if( fForward )
    {
        _pPlaceholder->_opcode = CHANGE_RECORD_OPCODE( (DWORD)_pPlaceholder->_opcode | CHANGE_RECORD_FORWARD );
    }
    if( fBackward )
    {
        _pPlaceholder->_opcode = CHANGE_RECORD_OPCODE( (DWORD)_pPlaceholder->_opcode | CHANGE_RECORD_BACKWARD );
    }

    // Tell the log manager what we're now interested in.
    hr = THR( _pLogMgr->SetDirection( fForward, fBackward ) );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: NotifySink
//
//  Synopsis: Helper function to notify the sink of available
//      changes
//+----------------------------------------------------------------+

HRESULT
CChangeLog::NotifySink()
{
    HRESULT hr;

    Assert( _pChangeSink );

    hr = THR( _pChangeSink->Notify() );

    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: Passivate
//
//  Synopsis: Releases our sink and unregisters us from the log
//      manager
//
//+----------------------------------------------------------------+

void
CChangeLog::Passivate()
{
    _pChangeSink->Release();
    _pLogMgr->Unregister( this );

    super::Passivate();
}

///////////////////////////////////////////
//  CBase methods

const CChangeLog::CLASSDESC CChangeLog::s_classdesc =
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
};

const CBase::CLASSDESC *
CChangeLog::GetClassDesc () const
{
    return &s_classdesc;
}

HRESULT
CChangeLog::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IHTMLChangeLog)
    }

    if (!*ppv)
        RRETURN( E_NOINTERFACE );

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}




#if DBG==1
//
// Debug ChangeSink for use in testing TreeSync
//

MtDefine(CChangeSink, Tree, "CChangeSink");

CChangeSink::CChangeSink( CLogManager * pLogMgr )
{
    _pLog    = NULL;
    _pLogMgr = pLogMgr;
    _pMarkupSync = NULL;
}

CChangeSink::~CChangeSink()
{
}

void
CChangeSink::Passivate()
{
    if( _pMarkupSync )
    {
        _pMarkupSync->Release();
    }

    super::Passivate();
}


///////////////////////////////////////////
//  CBase methods

const CChangeSink::CLASSDESC CChangeSink::s_classdesc =
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
};

const CBase::CLASSDESC *
CChangeSink::GetClassDesc () const
{
    return &s_classdesc;
}

HRESULT
CChangeSink::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IHTMLChangeSink)
    }

    if (!*ppv)
        RRETURN( E_NOINTERFACE );

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


#define DBG_RECORD_ARRAY_SIZE 20
#define DBG_STATIC_RECORD_SIZE 1024
HRESULT
CChangeSink::Notify()
{
    HRESULT hr = S_OK;
    long    nLen;
    long    nIndex = 0, nCurr;
    BYTE    abRecord[DBG_RECORD_ARRAY_SIZE][DBG_STATIC_RECORD_SIZE];
    IHTMLChangePlayback * pHCP = NULL;

    AssertSz( _pLog, "Not set up to be an IHTMLChangeSink" );

    hr = THR( _pLog->GetNextChange( NULL, 0, &nLen ) );
    if( FAILED(hr) || !nLen )
    {
        AssertSz( FALSE, "Notify called with no changes available!" );
        goto Cleanup;
    }


    InitDumpFile();
    WriteString( g_f, _T("\r\n--------------- IHTMLChangeSink Records -------------------\r\n") );

    do
    {
        hr = THR( _pLog->GetNextChange( abRecord[nIndex], DBG_STATIC_RECORD_SIZE, &nLen ) );
        if( FAILED( hr ) )
            goto Cleanup;

        if( nLen > 0 )
            nIndex++;
    }
    while( nLen > 0 && nIndex < DBG_RECORD_ARRAY_SIZE );

    if( _pMarkupSync )
    {
        // Unregister while we do our changes
        AddRef();
        _pLog->Release();
        _pMarkupSync->QueryInterface( IID_IHTMLChangePlayback, (void **)&pHCP );
    }

    for( nCurr = 0; nCurr < nIndex; nCurr++ )
    {
        _pLogMgr->DumpRecord( abRecord[nCurr] );

        if( _pMarkupSync )
        {
            // Replay this stuff forward
            hr = THR( pHCP->ExecChange( abRecord[nCurr], TRUE ) );
            // Replay this stuff backwards
            //hr = THR( _pMarkupSync->ExecChange( abRecord[nIndex - nCurr - 1], FALSE ) );
            if( hr )
                goto Cleanup;
        }
    }

    if( _pMarkupSync )
    {
        hr = THR( _pLogMgr->_pMarkup->CreateChangeLog( this, &_pLog, TRUE, TRUE ) );
        if( hr )
            goto Cleanup;

        Release();
    }

Cleanup:
    ReleaseInterface( pHCP );
    CloseDumpFile();
    RRETURN( hr );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\csite.cxx ===
//+---------------------------------------------------------------------
//
//   File:      csite.cxx
//
//  Contents:   client-site object for forms kernel
//
//  Classes:    CSite (partial)
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"       // table layout
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include "ocmm.h"
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>                   // for DB_E_DELETEDROW
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_DISPGDI16BIT_HXX_
#define X_DISPGDI16BIT_HXX_
#include "dispgdi16bit.hxx"
#endif

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#define _cxx_
#include "csite.hdl"

ExternTag(tagFormP);
ExternTag(tagMsoCommandTarget);
PerfDbgExtern(tagDocPaint)
DeclareTag(tagLayout, "Layout", "Trace SetPosition/RequestLayout");
DeclareTag(tagLayoutNoShort, "LayoutNoShort", "Prevent RequestLayout short-circuit");
DeclareTag(tagDrawBorder, "DrawBorder", "Trace DrawBorder information");

extern "C" const IID IID_IControl;

#define DRAWBORDER_OUTER    0
#define DRAWBORDER_SPACE    1
#define DRAWBORDER_INNER    2
#define DRAWBORDER_TOTAL    3
#define DRAWBORDER_INCRE    4
#define DRAWBORDER_LAST     5

CBorderInfo g_biDefault(0, 0);

void
CBorderInfo::InitFull()
{
    memset( this, 0, sizeof(CBorderInfo) );
    
    // Have to set up some default widths.
    CUnitValue cuv;
    cuv.SetValue( 4 /*MEDIUM*/, CUnitValue::UNIT_PIXELS );
    aiWidths[SIDE_TOP] = aiWidths[SIDE_BOTTOM] = cuv.GetPixelValue ( NULL, CUnitValue::DIRECTION_CY, 0, 0 );
    aiWidths[SIDE_RIGHT] = aiWidths[SIDE_LEFT] = cuv.GetPixelValue ( NULL, CUnitValue::DIRECTION_CX, 0, 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   CompareElementsByZIndex
//
//  Synopsis:   Comparison function used by qsort to compare the zIndex of
//              two elements.
//
//----------------------------------------------------------------------------

#define ELEMENT1_ONTOP 1
#define ELEMENT2_ONTOP -1
#define ELEMENTS_EQUAL 0

int RTCCONV
CompareElementsByZIndex ( const void * pv1, const void * pv2 )
{
    int        i, z1, z2;
    HWND       hwnd1, hwnd2;

    CElement * pElement1 = * (CElement **) pv1;
    CElement * pElement2 = * (CElement **) pv2;

    //
    // Only compare elements which have the same ZParent
    // TODO:   For now, since table elements (e.g., TDs, TRs, CAPTIONs) cannot be
    //         positioned, it is Ok if they all end up in the same list - even if
    //         their ZParent-age is different.
    //         THIS MUST BE RE-VISITED ONCE WE SUPPORT POSITIONING ON TABLE ELEMENTS.
    //         (brendand)
    //
    Assert(     pElement1->GetFirstBranch()->ZParent() == pElement2->GetFirstBranch()->ZParent()
           ||   (   pElement1->GetFirstBranch()->ZParent()->Tag() == ETAG_TR
                &&  pElement2->GetFirstBranch()->ZParent()->Tag() == ETAG_TR)
           ||   (   pElement1->GetFirstBranch()->ZParent()->Tag() == ETAG_TABLE
                &&  pElement2->GetFirstBranch()->ZParent()->Tag() == ETAG_TR)
           ||   (   pElement2->GetFirstBranch()->ZParent()->Tag() == ETAG_TABLE
                &&  pElement1->GetFirstBranch()->ZParent()->Tag() == ETAG_TR));

    // Sites with windows are _always_ above sites without windows.

    hwnd1 = pElement1->GetHwnd();
    hwnd2 = pElement2->GetHwnd();

    if ((hwnd1 == NULL) != (hwnd2 == NULL))
    {
        return (hwnd1 != NULL) ? ELEMENT1_ONTOP : ELEMENT2_ONTOP;
    }

    //
    // If one element contains the other, then the containee is on top.
    //
    // Since table cells cannot be positioned, we ignore any case where
    // something is contained inside a table cell. That way they essentially
    // become 'peers' of the cells and can be positioned above or below them.
    //
    if (pElement1->Tag() != ETAG_TD && pElement2->Tag() != ETAG_TD &&   // Cell
        pElement1->Tag() != ETAG_TH && pElement2->Tag() != ETAG_TH &&   // Header
        pElement1->Tag() != ETAG_TC && pElement2->Tag() != ETAG_TC)     // Caption
    {
        if (pElement1->GetFirstBranch()->SearchBranchToRootForScope(pElement2))
        {
            return ELEMENT1_ONTOP;
        }

        if (pElement2->GetFirstBranch()->SearchBranchToRootForScope(pElement1))
        {
            return ELEMENT2_ONTOP;
        }
    }

    //
    // Only pay attention to the z-index attribute if the element is positioned
    //
    // The higher z-index is on top, which means the higher z-index value
    // is "greater".
    //

    z1 = !pElement1->IsPositionStatic()
              ? pElement1->GetFirstBranch()->GetCascadedzIndex()
              : 0;

    z2 = !pElement2->IsPositionStatic()
              ? pElement2->GetFirstBranch()->GetCascadedzIndex()
              : 0;

    i = z1 - z2;

    if (i == ELEMENTS_EQUAL &&
        pElement1->IsPositionStatic() != pElement2->IsPositionStatic())
    {
        //
        // The non-static element has a z-index of 0, so we must make
        // sure it stays above anything in the flow (static).
        //
        i = (!pElement1->IsPositionStatic()) ? ELEMENT1_ONTOP : ELEMENT2_ONTOP;
    }

    //
    // Make sure that the source indices are up to date before accessing them
    //

    Assert( pElement1->Doc() == pElement2->Doc() );

    //
    // If the zindex is the same, then sort by source order.
    //
    // Later in the source is on top, which means the higher source-index
    // value is "greater".
    //

    if (i == ELEMENTS_EQUAL)
    {
        i = pElement1->GetSourceIndex() - pElement2->GetSourceIndex();
    }

    // Different elements should never be exactly equal.
    //
    // If this assert fires it's likely due to the element collection not
    // having been built yet.
    //

    Assert( i != ELEMENTS_EQUAL || pElement1 == pElement2 );

    return i;
}

//+---------------------------------------------------------------
//
//  Member:     CSite::CSite
//
//  Synopsis:   Normal constructor.
//
//  Arguments:  pParent  Site that's our parent
//
//---------------------------------------------------------------

CSite::CSite(ELEMENT_TAG etag, CDoc *pDoc)
    : CElement(etag, pDoc)
{
    TraceTag((tagCDoc, "constructing CSite"));

#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif

    // We only need to initialize non-zero state because of our redefinition
    // of operator new.
}

    
//+---------------------------------------------------------------
//
//  Member:     CSite::Init
//
//  Synopsis:   Do any element initialization here, called after the element is
//              created from CreateElement()
//
//---------------------------------------------------------------

HRESULT
CSite::Init()
{
    HRESULT hr;

    hr = THR( super::Init() );

    if (hr)
        goto Cleanup;

    //  Explicitly set this here *after* the superclass' constructor, which would set it to false.
    _fLayoutAlwaysValid = TRUE;

Cleanup:

    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member:     CSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    // IE4 shipped the interface IHTMLControlElement with the same GUID as
    // IControl.  Unfortunately, IControl is a forms^3 interface, which is bad.
    // To resolve this problem Trident's GUID for IHTMLControlElement has
    // changed however, the old GUID remembered in the QI for CSite to return
    // IHTMLControlElement.  The only side affect is that using the old GUID
    // will not marshall the interface correctly only the new GUID has the
    // correct marshalling code.  So, the solution is that QI'ing for
    // IID_IControl or IID_IHTMLControlElement will return IHTMLControlElement.

    // For VB page designer we need to emulate IE4 behavior (fail the QI if not a site)
    if(iid == IID_IControl && Doc()->_fVB && !ShouldHaveLayout())
        RRETURN(E_NOINTERFACE);

    if (iid == IID_IHTMLControlElement || iid == IID_IControl)
    {
        hr = CreateTearOffThunk(this,
                                s_apfnpdIHTMLControlElement,
                                NULL,
                                ppv,
                                (void *)s_ppropdescsInVtblOrderIHTMLControlElement);
        if (hr)
            RRETURN(hr);
    }
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

void
GetBorderColorInfoHelper(
    const CCharFormat *      pCF,
    const CFancyFormat *     pFF,
    const CBorderDefinition *pbd,
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL fAllPhysical)
{
    BYTE i;
    COLORREF clr, clrHilight, clrLight, clrDark, clrShadow;

    for ( i=0; i<SIDE_MAX ; i++ )
    {
        BOOL  fNeedSysColor = FALSE;
        // Get the base color
        const CColorValue & ccv = pbd->GetLogicalBorderColor(i, !fAllPhysical && pCF->HasVerticalLayoutFlow(), 
                                                             fAllPhysical || pCF->_fWritingModeUsed, pFF);
        if ( !ccv.IsDefined() )
        {
            clr = pCF->_ccvTextColor.GetColorRef();
            fNeedSysColor = TRUE;
        }
        else
            clr = ccv.GetColorRef();

        clrLight = clr;

        // Set up the inner and outer colors
        switch ( pborderinfo->abStyles[i] )
        {
        case fmBorderStyleNone:
        case fmBorderStyleDouble:
        case fmBorderStyleSingle:
        case fmBorderStyleDotted:
        case fmBorderStyleDashed:
            pborderinfo->acrColors[i][0] =
            pborderinfo->acrColors[i][2] = clr;
            // Don't need inner/outer colors
            break;

        default:
            {
                // Set up the color variations
                if ( pbd->_ccvBorderColorHilight.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrHilight = pbd->_ccvBorderColorHilight.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrHilight = GetSysColorQuick(COLOR_BTNHIGHLIGHT);
                    }
                    else
                        clrHilight = clr;
                }
                if ( pbd->_ccvBorderColorDark.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrDark = pbd->_ccvBorderColorDark.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrDark = GetSysColorQuick(COLOR_3DDKSHADOW);
                    }
                    else
                        clrDark = ( clr & 0xff000000 ) |
                                  ( ( (clr & 0xff0000)>>1 ) & 0xff0000 ) |
                                  ( ( (clr & 0x00ff00)>>1 ) & 0x00ff00 ) |
                                  ( ( (clr & 0x0000ff)>>1 ) & 0x0000ff );
                }
                if ( pbd->_ccvBorderColorShadow.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrShadow = pbd->_ccvBorderColorShadow.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrShadow = GetSysColorQuick(COLOR_BTNSHADOW);
                    }
                    else
                        clrShadow = ( clr & 0xff000000 ) |
                                    ( ( (clr & 0xff0000)>>2 ) & 0xff0000 ) |
                                    ( ( (clr & 0x00ff00)>>2 ) & 0x00ff00 ) |
                                    ( ( (clr & 0x0000ff)>>2 ) & 0x0000ff );
                }

                // If the Light color isn't set synthesise a light color 3/4 of clr
                if ( pbd->_ccvBorderColorLight.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrLight = pbd->_ccvBorderColorLight.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrLight = GetSysColorQuick(COLOR_BTNFACE);
                    }
                    else
                        clrLight = clrShadow + clrDark;
                }

                if (i==SIDE_TOP || i==SIDE_LEFT)
                {   // Top/left edges
                    if ( pbd->_bBorderSoftEdges || (pborderinfo->wEdges & BF_SOFT))
                    {
                        switch ( pborderinfo->abStyles[i] )
                        {
                        case fmBorderStyleRaisedMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrHilight;
                            break;
                        case fmBorderStyleSunkenMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrDark;
                            break;
                        case fmBorderStyleRaised:
                            pborderinfo->acrColors[i][0] = clrHilight;
                            pborderinfo->acrColors[i][2] = clrLight;
                            break;
                        case fmBorderStyleSunken:
                        case fmBorderStyleWindowInset:
                            pborderinfo->acrColors[i][0] = clrDark;
                            pborderinfo->acrColors[i][2] = clrShadow;
                            break;
                        case fmBorderStyleEtched:
                            pborderinfo->acrColors[i][0] = clrDark;
                            pborderinfo->acrColors[i][2] = clrLight;
                            break;
                        case fmBorderStyleBump:
                            pborderinfo->acrColors[i][0] = clrHilight;
                            pborderinfo->acrColors[i][2] = clrShadow;
                            break;
                        }
                    }
                    else
                    {
                        switch ( pborderinfo->abStyles[i] )
                        {
                        case fmBorderStyleRaisedMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrLight;
                            break;
                        case fmBorderStyleSunkenMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrShadow;
                            break;
                        case fmBorderStyleRaised:
                            pborderinfo->acrColors[i][0] = clrLight;
                            pborderinfo->acrColors[i][2] = clrHilight;
                            break;
                        case fmBorderStyleSunken:
                        case fmBorderStyleWindowInset:
                            pborderinfo->acrColors[i][0] = clrShadow;
                            pborderinfo->acrColors[i][2] = clrDark;
                            break;
                        case fmBorderStyleEtched:
                            pborderinfo->acrColors[i][0] = clrShadow;
                            pborderinfo->acrColors[i][2] = clrHilight;
                            break;
                        case fmBorderStyleBump:
                            pborderinfo->acrColors[i][0] = clrLight;
                            pborderinfo->acrColors[i][2] = clrDark;
                            break;
                        }
                    }
                }
                else
                {   // Bottom/right edges
                    switch ( pborderinfo->abStyles[i] )
                    {
                    case fmBorderStyleRaisedMono:
                        pborderinfo->acrColors[i][0] =
                        pborderinfo->acrColors[i][2] = clrDark;
                        break;
                    case fmBorderStyleSunkenMono:
                        pborderinfo->acrColors[i][0] =
                        pborderinfo->acrColors[i][2] = clrHilight;
                        break;
                    case fmBorderStyleRaised:
                        pborderinfo->acrColors[i][0] = clrDark;
                        pborderinfo->acrColors[i][2] = clrShadow;
                        break;
                    case fmBorderStyleSunken:
                    case fmBorderStyleWindowInset:
                        pborderinfo->acrColors[i][0] = clrHilight;
                        pborderinfo->acrColors[i][2] = clrLight;
                        break;
                    case fmBorderStyleEtched:
                        pborderinfo->acrColors[i][0] = clrHilight;
                        pborderinfo->acrColors[i][2] = clrShadow;
                        break;
                    case fmBorderStyleBump:
                        pborderinfo->acrColors[i][0] = clrDark;
                        pborderinfo->acrColors[i][2] = clrLight;
                        break;
                    }
                }
            }
        }

        // Set up the flat color
        if (pborderinfo->abStyles[i] == fmBorderStyleWindowInset)
        {
            pborderinfo->acrColors[i][1] = clrLight;
        }
        else
        {
            pborderinfo->acrColors[i][1] = clr;
        }
    }

    if ( pbd->_bBorderSoftEdges )
        pborderinfo->wEdges |= BF_SOFT;
}

//+------------------------------------------------------------------------
//
//  GetBorderInfoHelper
//
//  Returns border info for a node.
//  DocInfo can be NULL.  If it is not, the returned values will be transformed
//  into document sizes.  
//  The CBorderInfo can be seeded with default values.  If the format caches
//  have nothing set to override them, they will be maintained.  Default values
//  will be scaled if a CDocInfo is passed.
//
//-------------------------------------------------------------------------

DWORD
GetBorderInfoHelper(
    CTreeNode *     pNodeContext,
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    DWORD           dwFlags /* = GBIH_NONE */
    FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    Assert( pNodeContext);
    const CFancyFormat *pFF = pNodeContext->GetFancyFormat(FCPARAM);
    const CCharFormat  *pCF = pNodeContext->GetCharFormat(FCPARAM);
    Assert( pFF && pCF );

    return GetBorderInfoHelperEx(pFF, pCF, pdci, pborderinfo, dwFlags);
}

DWORD
GetBorderInfoHelperEx(
    const CFancyFormat *  pFF, 
    const CCharFormat *   pCF, 
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    DWORD           dwFlags /* = GBIH_NONE */)
{
    Assert(pborderinfo);
    Assert( pFF && pCF );

    BYTE  i;
    int   iBorderWidth = 0;

    BOOL  fAll    = (dwFlags & GBIH_ALL) ? TRUE : FALSE;
    BOOL  fPseudo = (dwFlags & GBIH_PSEUDO) ? TRUE : FALSE;
    BOOL  fAllPhysical = (dwFlags & GBIH_ALLPHY) ? TRUE : FALSE;
    BOOL  fWindowInset = FALSE;
    BOOL  fVertical = !fAllPhysical && pCF->HasVerticalLayoutFlow();
    BOOL  fWritingModeUsed = fAllPhysical || pCF->_fWritingModeUsed;
    const CBorderDefinition *pbd;
    int   iMaxBorder = pdci ? 10 * pdci->GetResolution().cx : MAX_BORDER_SPACE;
    
    if (fPseudo)
    {
        const CPseudoElementInfo *pPEI;
        Assert(pFF->_iPEI >= 0);
        pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        Assert(pPEI);
        pbd = &pPEI->_bd;
    }
    else
        pbd = &pFF->_bd;
    
    Assert( pCF );

    for (i = 0; i < SIDE_MAX; i++)
    {
        BYTE bBorderStyle = pbd->GetLogicalBorderStyle(i, fVertical, fWritingModeUsed, pFF);
        if (bBorderStyle != (BYTE)-1)
            pborderinfo->abStyles[i] = bBorderStyle;

        if (pborderinfo->abStyles[i] == fmBorderStyleWindowInset)
        {
            fWindowInset = TRUE;
        }

        if ( !pborderinfo->abStyles[i] )
        {
            pborderinfo->aiWidths[i] = 0;
            continue;
        }

        const CUnitValue & cuvBorderWidth = pbd->GetLogicalBorderWidth(i, fVertical, fWritingModeUsed, pFF);
        switch (cuvBorderWidth.GetUnitType())
        {
        case CUnitValue::UNIT_NULLVALUE:
            //  Scale any default value we were passed.
            if (pdci)
            {
                if ((i == SIDE_TOP) || (i == SIDE_BOTTOM))
                {
                    pborderinfo->aiWidths[i] = pdci->DeviceFromDocPixelsY(pborderinfo->aiWidths[i]);
                }
                else    // SIDE_RIGHT or SIDE_LEFT
                {
                    pborderinfo->aiWidths[i] = pdci->DeviceFromDocPixelsX(pborderinfo->aiWidths[i]);
                }
            }
            continue;
        case CUnitValue::UNIT_ENUM:
            {   // Pick up the default border width here.
                CUnitValue cuv;
                cuv.SetValue((cuvBorderWidth.GetUnitValue() + 1) * 2, CUnitValue::UNIT_PIXELS);
                iBorderWidth = cuv.GetPixelValue(pdci,
                                                ((i==SIDE_TOP)||(i==SIDE_BOTTOM))
                                                        ? CUnitValue::DIRECTION_CY
                                                        : CUnitValue::DIRECTION_CX,
                                                0, pCF->_yHeight);
            }
            break;
        default:
            iBorderWidth = cuvBorderWidth.GetPixelValue(pdci,
                                                        ((i==SIDE_TOP)||(i==SIDE_BOTTOM))
                                                            ? CUnitValue::DIRECTION_CY
                                                            : CUnitValue::DIRECTION_CX,
                                                        0, pCF->_yHeight);

            // If user sets tiny borderwidth, set smallest width possible (1px) instead of zero (IE5,5865).
            if (!iBorderWidth && cuvBorderWidth.GetUnitValue() > 0)
                iBorderWidth = 1;
        }
        if (iBorderWidth >= 0)
        {
            pborderinfo->aiWidths[i] = iBorderWidth < iMaxBorder ? iBorderWidth : iMaxBorder;
        }
    }

    if (fWindowInset)
    {
        pborderinfo->xyFlat = -1;
    }

    // Now pick up the edges if we set the border-style for that edge to "none"
    pborderinfo->wEdges &= ~BF_RECT;

    if ( pborderinfo->aiWidths[SIDE_TOP] )
        pborderinfo->wEdges |= BF_TOP;
    if ( pborderinfo->aiWidths[SIDE_RIGHT] )
        pborderinfo->wEdges |= BF_RIGHT;
    if ( pborderinfo->aiWidths[SIDE_BOTTOM] )
        pborderinfo->wEdges |= BF_BOTTOM;
    if ( pborderinfo->aiWidths[SIDE_LEFT] )
        pborderinfo->wEdges |= BF_LEFT;

    if ( fAll )
    {
        GetBorderColorInfoHelper(pCF, pFF, pbd, pdci, pborderinfo, fAllPhysical);

    }

    if ( pborderinfo->wEdges )
    {
        return (    pborderinfo->wEdges & BF_RECT
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_BOTTOM]
                &&  pborderinfo->aiWidths[SIDE_LEFT] == pborderinfo->aiWidths[SIDE_RIGHT]
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_LEFT]
                        ? DISPNODEBORDER_SIMPLE
                        : DISPNODEBORDER_COMPLEX);
    }
    return DISPNODEBORDER_NONE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsSimpleBorder
//
//  Synopsis:   This routine makes necessary check to determine if we can
//              use a pen and LineTo() calls to draw the border, instead
//              of calling the generic DrawBorder code. This is done for
//              performance considerations only.
//              Return value is FALSE if the border cannot be handled by the
//              simplified drawing function.
//--------------------------------------------------------------------------
#if DBG != 1
inline
#endif
BOOL
IsSimpleBorder(const CBorderInfo *pborderinfo)
{
    //  Check to see if we are a "simple" border.
    if ( 
        //  All borders must be one pixel wide.
       ((   pborderinfo->aiWidths[SIDE_TOP]
         |  pborderinfo->aiWidths[SIDE_LEFT]
         |  pborderinfo->aiWidths[SIDE_BOTTOM]
         | pborderinfo->aiWidths[SIDE_RIGHT])
         &  ~1)
        //  Can't be drawing a caption.
         ||  (pborderinfo->sizeCaption.cx || pborderinfo->sizeCaption.cy)
        //  xyFlat should be 0    
         ||  (pborderinfo->xyFlat) )
    {
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   DrawSimpleBorder
//
//  Synopsis:   This routine draws the border in the case when conditions
//              in IsSimpleBorder are TRUE
//
//--------------------------------------------------------------------------

// BF_DRAW being one enables one less addition in the code below.
#define BF_DRAW         1
#define BF_NEEDTODRAW   2

#if DBG != 1
inline
#endif
void
DrawSimpleBorder(const XHDC hdc, const CBorderInfo *pborderinfo, RECT rc, const RECT &rcClip)
{
    //  This circumstance can currently cause a bug in the clipping algorithm below.
    //  I want to be aware of issues that may cause this circumstance to see whether
    //  this needs to handle a nonintersecting clip and draw rect. (greglett)
    if (!((CRect)rc).FastIntersects(rcClip))
        return;

    int         i;
    HPEN        hPen = 0;
    HPEN        hPenOriginal = 0;
    COLORREF    colorCurrent = 0;
    BOOL        fOldMarkerEdge = FALSE;
    int         fEdges[SIDE_MAX];
    // With fEdges, we need to be able to track whether an edge:
    // 1.  Shouldn't be drawn (0)
    // 2.  Should be drawn, and hasn't been yet (NEEDTODRAW)
    // 3.  Was or will be drawn                 (DRAW)
    // NEEDTODRAW is potentially important for the LEFT & BOTTOM borders, as
    // they can be drawn by their paired borders.
    // DRAW allows borders to determine whether or not they should be responsible for corners.    
    memset(fEdges, 0, sizeof(fEdges));

    AssertSz(IsSimpleBorder(pborderinfo), "DrawSimpleBoorder is called for a border type that cannot handled");

    // Do the manual clipping (this is needed for Win9x to work) 
    if (rc.top < rcClip.top)
        rc.top = rcClip.top;
    else if (pborderinfo->wEdges & BF_TOP)
        fEdges[SIDE_TOP] = BF_NEEDTODRAW | BF_DRAW;

    if (rc.left < rcClip.left)
        rc.left = rcClip.left;
    else if (pborderinfo->wEdges & BF_LEFT)
        fEdges[SIDE_LEFT] = BF_NEEDTODRAW | BF_DRAW;

    if (rc.bottom > rcClip.bottom)
        rc.bottom = rcClip.bottom;
    else if (pborderinfo->wEdges & BF_BOTTOM)
        fEdges[SIDE_BOTTOM] = BF_NEEDTODRAW | BF_DRAW;

    if (rc.right > rcClip.right)
        rc.right = rcClip.right;
    else if (pborderinfo->wEdges & BF_RIGHT)
        fEdges[SIDE_RIGHT] = BF_NEEDTODRAW | BF_DRAW;

    // We have to do -1 because RC is for Rectangle call that does not
    // paint the bottom and the right
    rc.bottom--;
    rc.right--;

    for (i = 0; i < SIDE_MAX; i++)
    {   
        if (!(fEdges[i] & BF_NEEDTODRAW))
            continue;

        if (!hPen)
        {
            colorCurrent = pborderinfo->acrColors[i][DRAWBORDER_OUTER];
            fOldMarkerEdge = pborderinfo->IsMarkerEdge(i);
            hPen = pborderinfo->IsMarkerEdge(i)
                ?   (HPEN)CreatePen(PS_DOT, 0, colorCurrent)
                :   (HPEN)CreatePen(PS_SOLID, 0, colorCurrent);
            hPenOriginal = (HPEN)SelectObject(hdc, hPen);
        }
        else if (    colorCurrent != pborderinfo->acrColors[i][DRAWBORDER_OUTER]
                ||  fOldMarkerEdge != pborderinfo->IsMarkerEdge(i))
        {
            HPEN hPenOld = hPen;
            colorCurrent = pborderinfo->acrColors[i][DRAWBORDER_OUTER];
            fOldMarkerEdge = pborderinfo->IsMarkerEdge(i);
            hPen = pborderinfo->IsMarkerEdge(i)
                ?   (HPEN)CreatePen(PS_DOT, 0, colorCurrent)
                :   (HPEN)CreatePen(PS_SOLID, 0, colorCurrent);
            SelectObject(hdc, hPen);
            DeleteObject(hPenOld);
        }
        switch (i)
        {
        case SIDE_TOP:
            //  The TR pixel will be overwritten by a right border, if one exists.
            MoveToEx(hdc, rc.right, rc.top, NULL);
            // A small optimization that allows us to skip a new pen and MoveTo 
            //  (and also saves us  about 2% in perf for a typical table)
            if (    !fEdges[SIDE_LEFT]
                ||  colorCurrent != pborderinfo->acrColors[SIDE_LEFT][DRAWBORDER_OUTER]
                ||  fOldMarkerEdge != pborderinfo->IsMarkerEdge(SIDE_LEFT) )
            {
                LineTo(hdc, rc.left - 1, rc.top);
                break;
            }
            LineTo(hdc, rc.left, rc.top);
            //  The BL pixel will be overwritten by a bottom border, if one exists.
            LineTo(hdc, rc.left, rc.bottom + 1);
            // We already painted the left border, so reset the flag
            fEdges[SIDE_LEFT] &= ~BF_NEEDTODRAW;
            break;
        case SIDE_LEFT:
            //  Should the left border take responsibility for the first pixel?
            //  Only if no top border has been drawn
            MoveToEx(hdc, rc.left, rc.top + (fEdges[SIDE_TOP] & BF_DRAW), NULL);
            //  Should the left border take responsibility for the last pixel?
            //  Only if no bottom border has been drawn
            //  NB: BF_DRAW needs to be defined as 1 for this to work.
            LineTo(hdc, rc.left, rc.bottom + (~fEdges[SIDE_BOTTOM] & BF_DRAW));
            break;
        case SIDE_RIGHT:
            MoveToEx(hdc, rc.right, rc.top, NULL);
            // A small optimization that allows us to skip a new pen and MoveTo 
            //  (and also saves us  about 2% in perf for a typical table)
            if (    !fEdges[SIDE_BOTTOM] 
                ||  colorCurrent != pborderinfo->acrColors[SIDE_BOTTOM][DRAWBORDER_OUTER]
                ||  fOldMarkerEdge != pborderinfo->IsMarkerEdge(SIDE_BOTTOM))
            {
                LineTo(hdc, rc.right, rc.bottom + 1);
                break;
            }
            LineTo(hdc, rc.right, rc.bottom);
            LineTo(hdc, rc.left - 1, rc.bottom);
            fEdges[SIDE_BOTTOM] &= ~BF_NEEDTODRAW;
            break;
        case SIDE_BOTTOM:
            //  Should the bottom border take responsibility for the first pixel?
            //  Only if no right border has been drawn
            MoveToEx(hdc, rc.right - (fEdges[SIDE_RIGHT] & BF_DRAW), rc.bottom, NULL);
            LineTo(hdc, rc.left - 1, rc.bottom);
            break;
        }            
    }
    if (hPen)
    {
        SelectObject(hdc, hPenOriginal);
        DeleteObject(hPen);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   DrawBorder
//
//  Synopsis:   This routine is functionally equivalent to the Win95
//              DrawEdge API
//  xyFlat:     positive means, we draw flat inside, outside if negative
//
//--------------------------------------------------------------------------

void DrawBorder(CFormDrawInfo *pDI,
        LPRECT lprc,
        CBorderInfo *pborderinfo)
{   
    Assert(pborderinfo);
    Assert(lprc->left <= lprc->right);
    Assert(lprc->top <= lprc->bottom);    
    
    TraceTagEx((tagDrawBorder, TAG_NONAME,
           "DrawBorder : DrawRect[(%d, %d),(%d, %d)]",
           lprc->left, lprc->top, lprc->right, lprc->bottom));

    TraceTagEx((tagDrawBorder, TAG_NONAME,
           "DrawBorder : wEdges[(L%d, T%d, R%d, B%d)]",
           pborderinfo->wEdges & BF_LEFT,
           pborderinfo->wEdges & BF_TOP,
           pborderinfo->wEdges & BF_RIGHT,
           pborderinfo->wEdges & BF_BOTTOM));

    XHDC        hdc(pDI->GetDC(*lprc));

    // 
    BOOL    fNoZoomOrComplexRotation = hdc.IsOffsetOnly() 
                                    || hdc.HasTrivialRotation() && hdc.HasNoScale();
    
    // This simplified case handles the most comonly used border types
    // Note that for 90 degree rotation we don't want to use the simplified border code
    // (not because the border is not simple enough, just because the simple border 
    // code doesn't work right with rotation).
    if (IsSimpleBorder(pborderinfo) && hdc.IsOffsetOnly())
    {
        DrawSimpleBorder(hdc, pborderinfo, *lprc, pDI->_rcClip);
        return;
    }
    
    RECT        rc;
    RECT        rcSave; // Original rectangle, maybe adjusted for flat border.
    RECT        rcOrig; // Original rectangle of the element container.
    HBRUSH      hbrOld = NULL;
    COLORREF    crNow = COLORREF_NONE;
    COLORREF    crNew;
    HPEN        hPen;
    HPEN        hPenDotDash = NULL;
    // Ordering of the next 2 arrays are top,right,bottom,left.
    BYTE        abCanUseJoin[SIDE_MAX];
    int         aiNumBorderLines[SIDE_MAX];
    int         aiLineWidths[SIDE_MAX][DRAWBORDER_LAST];     // outer, spacer, inner
    UINT        wEdges = 0;
    int         i,j;
    POINT       polygon[8];
    BOOL        fdrawCaption = pborderinfo->sizeCaption.cx || pborderinfo->sizeCaption.cy;
    BOOL        fContinuingPoly;
    SIZE        sizeLegend;
    SIZE        sizeRect;
    POINT       ptBrushOrg;
    BOOL        afMarkerBorder[SIDE_MAX];

    memset(afMarkerBorder, 0, sizeof(BOOL) * SIDE_MAX);
    memset(aiLineWidths, 0, sizeof(int) * SIDE_MAX * DRAWBORDER_LAST);

    rc = *lprc;
    rc.top += pborderinfo->offsetCaption;

    rcOrig = rc;

    if (pborderinfo->xyFlat < 0)
    {
        InflateRect(&rc, pborderinfo->xyFlat, pborderinfo->xyFlat);
    }

    rcSave = rc;

    // save legend size
    sizeLegend = pborderinfo->sizeCaption;

    hPen = (HPEN)GetStockObject(NULL_PEN);
    int xyFlat = abs(pborderinfo->xyFlat);

    SelectObject(hdc, hPen);

    // If we are to draw the edge, initialize its net border width into the DRAWBORDER_OUTER.
    // If not, leave the width zero so that adjacent borders don't make bevelling mistakes.
    // Because the BF_X and SIDE_X are not aligned, and neither can be realigned due to other places
    // using them, we have to do these checks spread out instead of in a loop.
    if (pborderinfo->wEdges & BF_LEFT)
        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_LEFT] - xyFlat;
    if (pborderinfo->wEdges & BF_RIGHT)
        aiLineWidths[SIDE_RIGHT][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_RIGHT] - xyFlat;
    if (pborderinfo->wEdges & BF_TOP)
        aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_TOP] - xyFlat;
    if (pborderinfo->wEdges & BF_BOTTOM)
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_BOTTOM] - xyFlat;

    sizeRect.cx = rc.right - rc.left;
    sizeRect.cy = rc.bottom - rc.top;

    // set brush origin so that dither patterns are anchored correctly
    ::GetViewportOrgEx(hdc, &ptBrushOrg);
    ptBrushOrg.x += rc.left;
    ptBrushOrg.y += rc.top;

    // validate border size
    // if the broders are too big, truncate the bottom and right parts
    if (aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] +
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER] > sizeRect.cy)
    {
        aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] =
                        (aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] > sizeRect.cy) ?
                        sizeRect.cy :
                        aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER] =
                                                sizeRect.cy -
                                                aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];
    }

    if (aiLineWidths[SIDE_RIGHT][DRAWBORDER_OUTER] +
        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] > sizeRect.cx)
    {
        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] =
                        (aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] > sizeRect.cx) ?
                        sizeRect.cx :
                        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER];
        aiLineWidths[SIDE_RIGHT][DRAWBORDER_OUTER] =
                                                sizeRect.cx -
                                                aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER];
    }

    for ( i = 0; i < 4; i++ )
    {
        aiLineWidths[i][DRAWBORDER_TOTAL] = max(aiLineWidths[i][DRAWBORDER_OUTER], 0);
    }

    for ( i = 0; i < 4; i++ )
    {
        switch ( pborderinfo->abStyles[i] )
        {
        case fmBorderStyleNone:
            aiNumBorderLines[i] = 0;    // *Don't* draw a line on this side.
            aiLineWidths[i][DRAWBORDER_TOTAL] = 
            aiLineWidths[i][DRAWBORDER_OUTER] = 0;
            break;

        case fmBorderStyleDashed:
        case fmBorderStyleDotted:            
            afMarkerBorder[i] = (aiLineWidths[i][DRAWBORDER_OUTER] > 0);
            // Can use for 1 pixel style, color & style matched dotted/dashed borders.
            // It would be more efficient given the marker border algorithm to redefine
            //  abCanUseJoin to go: UL, UR, LR, LL rather than UR, LR...
            abCanUseJoin[i] =   (aiLineWidths[i][DRAWBORDER_TOTAL] == 1)
                            &&  (aiLineWidths[i][DRAWBORDER_TOTAL]
                                == aiLineWidths[(i==0)?3:i-1][DRAWBORDER_TOTAL])
                            &&  (pborderinfo->acrColors[i][DRAWBORDER_OUTER]
                                == pborderinfo->acrColors[(i==0)?3:1-1][DRAWBORDER_OUTER]);
            aiNumBorderLines[i] = 0;    // *Don't* draw a line on this side.
            break;

        case fmBorderStyleSingle:
        case fmBorderStyleRaisedMono:
        case fmBorderStyleSunkenMono:
            aiNumBorderLines[i] = 1;
            abCanUseJoin[i] = !!(aiLineWidths[i][DRAWBORDER_OUTER] > 0);
            break;

        case fmBorderStyleRaised:
        case fmBorderStyleSunken:
        case fmBorderStyleEtched:
        case fmBorderStyleBump:
        case fmBorderStyleWindowInset:
            aiNumBorderLines[i] = 3;
            aiLineWidths[i][DRAWBORDER_INNER] = aiLineWidths[i][DRAWBORDER_OUTER] >> 1;
            aiLineWidths[i][DRAWBORDER_OUTER] -= aiLineWidths[i][DRAWBORDER_INNER];
            abCanUseJoin[i] = (aiLineWidths[i][DRAWBORDER_TOTAL] > 1
                                && (aiLineWidths[(i==0?3:(i-1))][DRAWBORDER_TOTAL]
                                    == aiLineWidths[i][DRAWBORDER_TOTAL]));
            break;

        case fmBorderStyleDouble:
            aiNumBorderLines[i] = 3;
            aiLineWidths[i][DRAWBORDER_SPACE] = aiLineWidths[i][DRAWBORDER_OUTER] / 3; // Spacer
            // If this were equal to the line above,
            aiLineWidths[i][DRAWBORDER_INNER] = (aiLineWidths[i][DRAWBORDER_OUTER]
                                                - aiLineWidths[i][DRAWBORDER_SPACE]) / 2;
            // we'd get widths of 3,1,1 instead of 2,1,2
            aiLineWidths[i][DRAWBORDER_OUTER] -= aiLineWidths[i][DRAWBORDER_SPACE]
                                                + aiLineWidths[i][DRAWBORDER_INNER];
            // evaluate border join between adjacent borders
            // we don't want to have a joint polygon borders if
            // the distribution does not match
            abCanUseJoin[i] = pborderinfo->acrColors[(i==0)?3:(i-1)][0]
                                    == pborderinfo->acrColors[i][0]
                                && (aiLineWidths[i][DRAWBORDER_TOTAL] > 2)
                                && (aiLineWidths[(i==0)?3:(i-1)][DRAWBORDER_TOTAL]
                                    == aiLineWidths[i][DRAWBORDER_TOTAL]);
            break;
        }
        abCanUseJoin[i] = abCanUseJoin[i]
                            && pborderinfo->abStyles[(4 + i - 1) % 4]
                                == pborderinfo->abStyles[i];
        aiLineWidths[i][DRAWBORDER_INCRE] = 0;
    }

    // Dotted/Dashed (Marker) border code --- 
    // If we have repeating marker borders (dotted/dashed), draw them first.  That way, we don't
    // have to calculate & draw bevels for each marker - the other border code will overdraw them.
    // Top & Bottom marker borders are responsible for the corners, unless there is no top/bottom marker
    // border in which case the side marker borders take responsibility.  (greglett)
    for (i = 0; i < 4; i++)
    {        
        int iMarkerWidth;

        if (!afMarkerBorder[i])
            continue;

        iMarkerWidth = aiLineWidths[i][DRAWBORDER_OUTER];
        //  Special case for 1px markers: use the system pen instead of drawing multiple markers.
        if (iMarkerWidth == 1)
        {         
            // Set the pen to the right color & style.
            // Since we bundle lines & don't cache pens, this *is* a different pen.                
            hPenDotDash = CreatePen(PS_DOT, iMarkerWidth, pborderinfo->acrColors[i][DRAWBORDER_OUTER]);
            SelectObject(hdc, hPenDotDash);

            //  Set up the (up to 5) line verticies in the polyline.
            //  Loop through remaining edges in clockwise order.
            for (j = 0; (i + j < 5) && ((j <= 1) || abCanUseJoin[(i+j-1)%4]); j++)
            {
                //  Set vertex to the initial point on border i + j.
                //  NOTE: deliberately set up so the default is the UL corner so that i + j = 4 works w/o a modulus.
                polygon[j].x = (i+j == SIDE_RIGHT || i+j == SIDE_BOTTOM)                 
                    ? rcSave.right - 1
                    : rcSave.left;
                polygon[j].y = (i+j == SIDE_LEFT || i+j == SIDE_BOTTOM)                        
                    ? rcSave.bottom - 1                                
                    : rcSave.top;
            }

            Polyline(hdc, polygon, j);
            SelectObject(hdc, hPen);        //  Restore NULL pen.
            DeleteObject(hPenDotDash);
            
            // If we've joined with j-2 other borders, we can skip their processing in the outer loop.
            i += j - 2;
        }
        else
        {
            int cMarkers, cSpaces;
            double dLeft, dTop;
            double dPerSpaceSize;
            double dX, dY;
            BOOL fDashed = (pborderinfo->abStyles[i] == fmBorderStyleDashed);
            BOOL fTopOrBottom = (i == SIDE_TOP || i == SIDE_BOTTOM);
            BOOL fLeadingSpace = false;
            BOOL fTrailingMarker = true;
            double dMarkerLength = fDashed ? 2 * iMarkerWidth : iMarkerWidth;
            double dBorderLength;

            if (fTopOrBottom)
            {
                dBorderLength = sizeRect.cx;
            }
            else
            {
                dBorderLength = sizeRect.cy;
                // If there are top/bottom marker borders, they are responsible for the corners.
                // So... subtract out such corners for side borders.
                if (afMarkerBorder[SIDE_TOP])
                {
                    fLeadingSpace = !fDashed;
                    dBorderLength -= aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];
                }
                if (afMarkerBorder[SIDE_BOTTOM])
                {
                    dBorderLength -= aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER];
                    fTrailingMarker = fDashed;
                }
            }
                              
            //  Sub out a marker iff we will have an extra one (trailing & leading marker)
            if (fTopOrBottom || !(afMarkerBorder[SIDE_TOP] || afMarkerBorder[SIDE_BOTTOM]))
                dBorderLength -= dMarkerLength;           

            //  Sub out a half marker if we will have an extra one (trailing xor leading half-dash)
            else if (fDashed && !(afMarkerBorder[SIDE_TOP] && afMarkerBorder[SIDE_BOTTOM]))
                dBorderLength -= dMarkerLength *.5;

            //  Sub out a space iff we will have an extra one (both trailing & leading space)
            else if (!fDashed && afMarkerBorder[SIDE_TOP] && afMarkerBorder[SIDE_BOTTOM])
                dBorderLength -= iMarkerWidth;           

            if (dBorderLength < 0)
                dBorderLength = 0;

            cSpaces = cMarkers = IntFloor(dBorderLength / (dMarkerLength + iMarkerWidth));

            // Add back in a space if we previously subtracted one.
            if (!fTopOrBottom && !fDashed && afMarkerBorder[SIDE_TOP] && afMarkerBorder[SIDE_BOTTOM])
            {
                cSpaces++;
                dBorderLength += iMarkerWidth;
            }

            if (cSpaces == 0)
            {
                // An absurdly short length or fat width border.  How do we handle this?
                // Right now, we don't.  Ignore it & move onto the next border.
                // NOTE: not bailing out here may currently cause a div by zero in the next line.
                continue;
            }

            // How many pixels per space?  Using: float point math.
            dPerSpaceSize = (dBorderLength - cMarkers * dMarkerLength) / cSpaces;

            // Add back in a marker if:
            //  1.  We've subtracted out a full marker.
            //  2.  We are a side, dashed border with any half dashes to add/split.
            if (fTopOrBottom || !(afMarkerBorder[SIDE_TOP] || afMarkerBorder[SIDE_BOTTOM])
                ||  (fDashed && (afMarkerBorder[SIDE_TOP] || afMarkerBorder[SIDE_BOTTOM])))
            {
                cMarkers++;
                dBorderLength += dMarkerLength;
            }
            if (fTrailingMarker) cMarkers--;

            crNew = pborderinfo->acrColors[i][DRAWBORDER_OUTER];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }

            // Set X and Y lengths for each marker.
            dX = fTopOrBottom ? dMarkerLength : iMarkerWidth;
            dY = fTopOrBottom
                ? iMarkerWidth
                : (fDashed && afMarkerBorder[SIDE_TOP])    // Leading halfdash code.
                    ? dMarkerLength * .5
                    : dMarkerLength;
            //  Rectangle & Ellipse draw *within* the pen, currently NULL_PEN (1px wide & invisible)
            //  In order to get a shape of the right size, we need to add one to our dimensions.
            dX += 1; dY += 1;

            // Compute the upper left corner
            dLeft = (i == SIDE_RIGHT)
                ?   rcSave.right - iMarkerWidth
                :   rcSave.left;
            dTop = (i == SIDE_BOTTOM)
              ?   rcSave.bottom - iMarkerWidth
              :   (i == SIDE_TOP || !afMarkerBorder[SIDE_TOP])
                  ?   rcSave.top
                  :   rcSave.top + aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];

            if (fLeadingSpace)
            {
                if (fTopOrBottom)
                    dLeft += dPerSpaceSize;
                else
                    dTop += dPerSpaceSize;
            }

            Assert(pborderinfo->abStyles[i] == fmBorderStyleDashed || pborderinfo->abStyles[i] == fmBorderStyleDotted);
            for (j = 0; j < cMarkers; j++)
            {                
                int iLeft   = IntNear(dLeft);
                int iTop    = IntNear(dTop );
                int iRight  = IntNear(dLeft + dX);
                int iBottom = IntNear(dTop + dY);
                switch (pborderinfo->abStyles[i])
                {
                case fmBorderStyleDotted:
                    if (iMarkerWidth == 2)                        
                        ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    else
                        ::Ellipse(hdc, iLeft, iTop, iRight, iBottom);
                    break;
                case fmBorderStyleDashed:                          
                    ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    //  Turn off that leading halfdash.
                    if (j==0 && !fTopOrBottom && afMarkerBorder[SIDE_TOP])
                    {
                        dY = dMarkerLength + 1;        // Reset to fulldash size.  (really, ((dY - 1) * 2) + 1)
                        dTop -= dMarkerLength * .5;    // Counter the fulldash subbed later.
                    }

                    break;
                }

                if (fTopOrBottom)
                {
                    dLeft += dMarkerLength + dPerSpaceSize;
                }
                else
                {
                    dTop += dMarkerLength + dPerSpaceSize;  
                }
            }

            if (fTrailingMarker)
            {             
                int iLeft   = IntNear(dLeft);
                int iTop    = IntNear(dTop );
                int iRight  = IntNear(dLeft + dX);
                int iBottom = IntNear(dTop + dY);
                switch (pborderinfo->abStyles[i])
                {
                case fmBorderStyleDotted:
                    if (iMarkerWidth == 2)
                        ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    else
                        ::Ellipse(hdc, iLeft, iTop, iRight, iBottom);
                    break;
                case fmBorderStyleDashed:            
                    if (!fTopOrBottom && afMarkerBorder[SIDE_BOTTOM])
                    {
                        dY = (dMarkerLength  * .5) + 1;     // Reset to fulldash size.  (really, ((dY - 1) * 2) + 1)
                        iBottom = IntNear(dTop + dY);
                    }
                    ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    break;
                }
            }
        }
    }           
  
    // Loop: draw outer lines (j=0), spacer (j=1), inner lines (j=2)
    for ( j=DRAWBORDER_OUTER; j<=DRAWBORDER_INNER; j++ )
    {
        fContinuingPoly = FALSE;
        wEdges = pborderinfo->wEdges;
        
        if ( j != DRAWBORDER_SPACE ) // if j==1, this line is a spacer only - don't draw lines, just deflate the rect.
        {
            i = 0;
            // We'll work around the border edges CW, starting with the right edge, in an attempt to reduce calls to polygon().
            // we must draw left first to follow Windows standard

            if ( wEdges & BF_LEFT && (j < aiNumBorderLines[SIDE_LEFT]) && aiLineWidths[SIDE_LEFT][j])
            {   // There's a left edge
                // get color brush for left side
                crNew = pborderinfo->acrColors[SIDE_LEFT][j];
                if (crNew != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                    ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                }
                
                // build left side polygon

                polygon[i].x = rc.left + aiLineWidths[SIDE_LEFT][j];    // lower right corner
                polygon[i++].y = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_LEFT][j],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);
                polygon[i].x = rc.left;                         // lower left corner
                polygon[i++].y = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);

                if ( !(wEdges & BF_TOP) ||
                    ( pborderinfo->acrColors[SIDE_LEFT][j] != pborderinfo->acrColors[SIDE_TOP][j] )
                        || !abCanUseJoin[SIDE_TOP])
                {
                    polygon[i].x = rc.left;                         // upper left corner
                    polygon[i++].y = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);
                    polygon[i].x = rc.left + aiLineWidths[SIDE_LEFT][j];    // upper right corner
                    polygon[i++].y = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_LEFT][j],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);
                    ::Polygon(hdc, polygon, i);
                    i = 0;
                }
                else
                    fContinuingPoly = TRUE;
            }
            if ( wEdges & BF_TOP && (j < aiNumBorderLines[SIDE_TOP]) && aiLineWidths[SIDE_TOP][j])
            {   // There's a top edge
                if ( !fContinuingPoly )
                {
                    // get color brush for top side
                    crNew = pborderinfo->acrColors[SIDE_TOP][j];
                    if (crNew != crNow)
                    {
                        HBRUSH hbrNew;
                        SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                        if(hbrNew)
                        {
                            // not supported on WINCE
                            ::UnrealizeObject(hbrNew);
                        }
#endif
                        ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                        i = 0;
                    }
                }
                // build top side polygon

                // up left
                polygon[i].x    = rcSave.left + ((wEdges & BF_LEFT) ? 
                                                    MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                    : 0);
                polygon[i++].y  = rc.top;

                if (fdrawCaption)
                {
                    // shrink legend
                    sizeLegend.cx = sizeLegend.cx
                                        - aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE];
                    sizeLegend.cy = sizeLegend.cy
                                        - aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE];

                    polygon[i].x    = rc.left + sizeLegend.cx;
                    polygon[i++].y  = rc.top;
                    polygon[i].x    = rc.left + sizeLegend.cx;
                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];

                    polygon[i].x    = rcSave.left + ((wEdges & BF_LEFT) ? 
                                                        MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                            aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE]
                                                                + aiLineWidths[SIDE_TOP][j],
                                                            aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                        : 0);

                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];

                    ::Polygon(hdc, polygon, i);
                    i = 0;
                    polygon[i].x    = rc.left + sizeLegend.cy;
                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];
                    polygon[i].x    = rc.left + sizeLegend.cy;
                    polygon[i++].y  = rc.top;
                }

                // upper right
                polygon[i].x    = rcSave.right - ((wEdges & BF_RIGHT) ?
                                                    MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                    : 0);
                polygon[i++].y  = rc.top;

                // lower right
                polygon[i].x    = rcSave.right - ((wEdges & BF_RIGHT) ?
                                                    MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE]
                                                            + aiLineWidths[SIDE_TOP][j],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                    : 0 );
                polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];

                if (!fdrawCaption)
                {
                    polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_TOP][j],
                                                    aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL]);
                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];
                }

                ::Polygon(hdc, polygon, i);
                i = 0;
            }

            fContinuingPoly = FALSE;
            i = 0;

            if ( wEdges & BF_RIGHT && (j < aiNumBorderLines[SIDE_RIGHT]) && aiLineWidths[SIDE_RIGHT][j])
            {   // There's a right edge
                // get color brush for right side
                crNew = pborderinfo->acrColors[SIDE_RIGHT][j];
                if (crNew != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                    if(hbrNew)
                    {
                        // not supported on WINCE
                        ::UnrealizeObject(hbrNew);
                    }
#endif
                    ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                }

                // build right side polygon

                polygon[i].x    = rc.right - aiLineWidths[SIDE_RIGHT][j];     // upper left corner
                polygon[i++].y  =  rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_RIGHT][j],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);

                if (pborderinfo->abStyles[SIDE_RIGHT] == pborderinfo->abStyles[SIDE_TOP]
                        && aiLineWidths[SIDE_RIGHT][j] == 1 
                        && fNoZoomOrComplexRotation)      // with zoom, it may not be 1-pixel
                {
                    // upper right corner fix: we have to overlap one pixel to avoid holes
                    polygon[i].x    = rc.right - 1;
                    polygon[i].y    = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);

                    polygon[i+1].x    = rc.right;
                    polygon[i+1].y  = polygon[i].y;

                    i = i + 2;
                }
                else
                {
                    polygon[i].x    = rc.right;
                    polygon[i++].y    = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);
                }

                if ( !(wEdges & BF_BOTTOM) ||
                    ( pborderinfo->acrColors[SIDE_RIGHT][j] != pborderinfo->acrColors[SIDE_BOTTOM][j] )
                        || !abCanUseJoin[SIDE_BOTTOM])
                {
                    polygon[i].x    = rc.right;                                     // lower right corner
                    polygon[i++].y  = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);

                    polygon[i].x    = rc.right - aiLineWidths[SIDE_RIGHT][j];     // lower left corner
                    polygon[i++].y  = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_RIGHT][j],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);
                    ::Polygon(hdc, polygon, i);
                    i = 0;
                }
                else
                    fContinuingPoly = TRUE;
            }
            if ( wEdges & BF_BOTTOM && (j < aiNumBorderLines[SIDE_BOTTOM]) && aiLineWidths[SIDE_BOTTOM][j])
            {   // There's a bottom edge
                if ( !fContinuingPoly )
                {
                    // get color brush for bottom side
                    crNew = pborderinfo->acrColors[SIDE_BOTTOM][j];
                    if (crNew != crNow)
                    {
                        HBRUSH hbrNew;
                        SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                        if(hbrNew)
                        {
                            // not supported on WINCE
                            ::UnrealizeObject(hbrNew);
                        }
#endif
                        ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                        i = 0;
                    }
                }

                // build bottom side polygon

                polygon[i].x    = rcSave.right - MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                polygon[i++].y  = rc.bottom;

                if (pborderinfo->abStyles[SIDE_BOTTOM] == pborderinfo->abStyles[SIDE_LEFT]
                        && aiLineWidths[SIDE_RIGHT][j] == 1
                        && fNoZoomOrComplexRotation)      // with zoom, it may not be 1-pixel
                {
                    // bottom left
                    polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                    polygon[i].y    = rc.bottom;

                    // lower left fix, we have to overlap 1 pixel to avoid holes
                    polygon[i+1].x  = polygon[i].x;
                    polygon[i+1].y  = rc.bottom - 1;

                    i = i + 2;
                }
                else
                {
                    polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                    polygon[i++].y    = rc.bottom;
                }

                // upper left, we have to overlap 1 pixel to avoid holes
                polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_BOTTOM][j],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                polygon[i++].y  = rc.bottom - aiLineWidths[SIDE_BOTTOM][j];
                polygon[i].x    = rcSave.right  - MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_BOTTOM][j],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);

                polygon[i++].y  = rc.bottom - aiLineWidths[SIDE_BOTTOM][j];

                ::Polygon(hdc, polygon, i);
                i = 0;
            }

        }


        // Shrink rect for this line or spacer
        rc.top    += aiLineWidths[SIDE_TOP][j];
        rc.right  -= aiLineWidths[SIDE_RIGHT][j];
        rc.bottom -= aiLineWidths[SIDE_BOTTOM][j];
        rc.left   += aiLineWidths[SIDE_LEFT][j];

        // increment border shifts
        aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE] += aiLineWidths[SIDE_RIGHT][j];
        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE] += aiLineWidths[SIDE_TOP][j];
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE] += aiLineWidths[SIDE_BOTTOM][j];
        aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE] += aiLineWidths[SIDE_LEFT][j];
    }

    // Okay, now let's draw the flat border if necessary.
    if ( xyFlat != 0 )
    {
        if (pborderinfo->xyFlat < 0)
        {
            rc = rcOrig;
        }
        rc.right++;
        rc.bottom++;
        xyFlat++;

        if (wEdges & BF_RIGHT)
        {
            crNew = pborderinfo->acrColors[SIDE_RIGHT][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                        rc.right - xyFlat,
                        rc.top + ((wEdges & BF_TOP) ? 0 : xyFlat),
                        rc.right,
                        rc.bottom - ((wEdges & BF_BOTTOM) ? 0 : xyFlat)
                        );
        }
        if (wEdges & BF_BOTTOM)
        {
            crNew = pborderinfo->acrColors[SIDE_BOTTOM][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                        rc.left + ((wEdges & BF_LEFT) ? 0 : xyFlat),
                        rc.bottom - xyFlat,
                        rc.right - ((wEdges & BF_RIGHT) ? 0 : xyFlat),
                        rc.bottom
                        );
        }

        if (wEdges & BF_TOP)
        {
            crNew = pborderinfo->acrColors[SIDE_TOP][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                    rc.left + ((wEdges & BF_LEFT) ? 0 : xyFlat),
                    rc.top,
                    rc.right - ((wEdges & BF_RIGHT) ? 0 : xyFlat),
                    rc.top + xyFlat
                    );
        }
        if (wEdges & BF_LEFT)
        {
            crNew = pborderinfo->acrColors[SIDE_LEFT][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                        rc.left,
                        rc.top + ((wEdges & BF_TOP) ? 0 : xyFlat),
                        rc.left + xyFlat,
                        rc.bottom - ((wEdges & BF_BOTTOM) ? 0 : xyFlat)
                        );
        }
    }

    if (hbrOld)
        ReleaseCachedBrush((HBRUSH)SelectObject(hdc, hbrOld));
}

//+----------------------------------------------------------------------------
//
// Function:    CalcImgBgRect
//
// Synopsis:    Finds the rectangle to pass to Tile() to draw correct
//              background image with the attributes specified in the
//              fancy format (repeat-x, repeat-y, etc).
//
//-----------------------------------------------------------------------------
void
CalcBgImgRect(
    CTreeNode          * pNode,
    CFormDrawInfo      * pDI,
    const SIZE         * psizeObj,
    const SIZE         * psizeImg,
          CPoint       * pptBackOrig,
    CBackgroundInfo    * pbginfo )
{
    // pNode is used to a) extract formats to get the
    // background position values, and b) to get the font height so we
    // can handle em/en/ex units for position.
    const CFancyFormat * pFF = pNode->GetFancyFormat();
    const CCharFormat  * pCF = pNode->GetCharFormat();
    BOOL  fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
    BOOL  fWritingModeUsed    = pCF->_fWritingModeUsed;
    const CUnitValue & cuvBgPosX = pbginfo->GetLogicalBgPosX(fVerticalLayoutFlow, fWritingModeUsed, pFF);
    const CUnitValue & cuvBgPosY = pbginfo->GetLogicalBgPosY(fVerticalLayoutFlow, fWritingModeUsed, pFF);
    RECT *prcBackClip = &pbginfo->rcImg;
    
    // N.B. Per CSS spec, percentages work as follows:
    // (x%, y%) means that the (x%, y%) point in the image is
    // positioned at the (x%, y%) point in the bounded rectangle.

    if (cuvBgPosX.GetUnitType() == CUnitValue::UNIT_PERCENT)
    {
        pptBackOrig->x =
                  MulDivQuick(cuvBgPosX.GetPercent(),
                              psizeObj->cx - psizeImg->cx,
                              100);
    }
    else
    {
        pptBackOrig->x =
         cuvBgPosX.GetPixelValue(pDI, CUnitValue::DIRECTION_CX, 0,
                                       pNode->GetFontHeightInTwips((CUnitValue*)&cuvBgPosX));
    }

    if (cuvBgPosY.GetUnitType() == CUnitValue::UNIT_PERCENT)
    {
        pptBackOrig->y =
                  MulDivQuick(cuvBgPosY.GetPercent(),
                              psizeObj->cy - psizeImg->cy,
                              100);
    }
    else
    {
        pptBackOrig->y =
          cuvBgPosY.GetPixelValue(pDI, CUnitValue::DIRECTION_CY, 0,
                                        pNode->GetFontHeightInTwips((CUnitValue*)&cuvBgPosY));
    }
    if (fVerticalLayoutFlow)
    {
        // Background position is a phisical property, so logical origin points 
        // to top-right corner.
        //   logical-x = phisical-y (already set)
        //   logical-y = is relative to the right edge of the object
        // NOTE: image size is in physical coordinate system
        pptBackOrig->y = psizeObj->cy - psizeImg->cx - pptBackOrig->y;
    }

    if (pbginfo->GetLogicalBgRepeatX(fVerticalLayoutFlow, fWritingModeUsed, pFF))
    {
        prcBackClip->left  = 0;
        prcBackClip->right = psizeObj->cx;
    }
    else
    {
        prcBackClip->left  = pptBackOrig->x;
        // NOTE: image size is in physical coordinate system
        if (fVerticalLayoutFlow)
            prcBackClip->right = pptBackOrig->x + psizeImg->cy;
        else
            prcBackClip->right = pptBackOrig->x + psizeImg->cx;
    }

    if (pbginfo->GetLogicalBgRepeatY(fVerticalLayoutFlow, fWritingModeUsed, pFF))
    {
        prcBackClip->top    = 0;
        prcBackClip->bottom = psizeObj->cy;
    }
    else
    {
        prcBackClip->top    = pptBackOrig->y;
        // NOTE: image size is in physical coordinate system
        if (fVerticalLayoutFlow)
            prcBackClip->bottom = pptBackOrig->y + psizeImg->cx;
        else
            prcBackClip->bottom = pptBackOrig->y + psizeImg->cy;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     get_form
//
//  Synopsis:   Exposes the form element of this site.
//
//  Note:
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CSite::get_form(IHTMLFormElement **ppDispForm)
{
    HRESULT        hr = S_OK;
    CFormElement * pForm;

    if (!ppDispForm)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispForm = NULL;

    pForm = GetParentForm();
    if (pForm)
    {
        hr = THR_NOTRACE(pForm->QueryInterface(IID_IHTMLFormElement,
                                              (void**)ppDispForm));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfoPGet( hr, DISPID_CSite_form));
}

CSite::DRAGINFO::~DRAGINFO()
{
    if (_pBag)
        _pBag->Release();
}

void
CBorderInfo::FlipBorderInfo()
{
    CBorderInfo *pborderinfo = this;
    CBorderInfo biPhy;
    int side, sideL;
    
    memcpy(&biPhy, pborderinfo, sizeof(CBorderInfo));
    for (side = SIDE_TOP; side < SIDE_MAX; side++)
    {
        if (side == SIDE_TOP)
            sideL = SIDE_LEFT;
        else
            sideL = side - 1;
        pborderinfo->abStyles[sideL] = biPhy.abStyles[side];
        pborderinfo->aiWidths[sideL] = biPhy.aiWidths[side];
        pborderinfo->acrColors[sideL][0] = biPhy.acrColors[side][0];
        pborderinfo->acrColors[sideL][1] = biPhy.acrColors[side][1];
        pborderinfo->acrColors[sideL][2] = biPhy.acrColors[side][2];
    }

    pborderinfo->wEdges = 0;
    if ( pborderinfo->aiWidths[SIDE_TOP] )
        pborderinfo->wEdges |= BF_TOP;
    if ( pborderinfo->aiWidths[SIDE_RIGHT] )
        pborderinfo->wEdges |= BF_RIGHT;
    if ( pborderinfo->aiWidths[SIDE_BOTTOM] )
        pborderinfo->wEdges |= BF_BOTTOM;
    if ( pborderinfo->aiWidths[SIDE_LEFT] )
        pborderinfo->wEdges |= BF_LEFT;
}

//TODO (terrylu, alexz) pdl parser should be fixed so to avoid doing this
#if 1
HRESULT CSite::focus() { return super::focus(); };
HRESULT CSite::blur() { return super::blur(); };
HRESULT CSite::addFilter(IUnknown* pUnk) { return super::addFilter(pUnk); };
HRESULT CSite::removeFilter(IUnknown* pUnk) { return super::removeFilter(pUnk); };
HRESULT CSite::get_clientHeight(long*p) { return super::get_clientHeight(p); };
HRESULT CSite::get_clientWidth(long*p) { return super::get_clientWidth(p); };
HRESULT CSite::get_clientTop(long*p) { return super::get_clientTop(p); };
HRESULT CSite::get_clientLeft(long*p) { return super::get_clientLeft(p); };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\debugwindowguids.c ===
//
// Debug-only guids for interfaces in DebugWindow.idl
//

#if DBG==1 
#include "DebugWindow_i.c"
#endif

;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\ctxmenu.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ctxmenu.cxx
//
//  Contents:   forms kernel command handlers
//
//  Notes:      These commands are exposed at design time only, and then
//              only through context menus. The form kernel has no menu bars
//              of it's own.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef WIN16
#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif
#endif

#ifndef X_PROPUTIL_HXX_
#define X_PROPUTIL_HXX_
#include "proputil.hxx"      // For font dialog
#endif

//+---------------------------------------------------------------
//
//  Member:     CDoc::EditUndo
//
//  Synopsis:   Manage Undo command
//
//---------------------------------------------------------------

ExternTag(tagUndo);
PerfDbgExtern(tagMarkupUndo);

HRESULT
CDoc::EditUndo()
{
    TraceTag((tagUndo, "CDoc::EditUndo"));

    HRESULT hr = THR(_pUndoMgr->UndoTo(NULL));

    RRETURN(SetErrorInfo(hr)); // TODO more context needed
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EditRedo
//
//  Synopsis:   Performs a Redo
//
//---------------------------------------------------------------

HRESULT
CDoc::EditRedo()
{
    TraceTag((tagUndo, "CDoc::EditRedo"));

    HRESULT hr = THR(_pUndoMgr->RedoTo(NULL));

    RRETURN(SetErrorInfo(hr)); // TODO more context needed
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\debugger.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       stdform.cxx
//
//  Contents:   Script Debugger related code
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

// MtDefines

MtDefine(CScriptCookieTable,                   ObjectModel,         "CScriptCookieTable");
MtDefine(CScriptCookieTable_CItemsArray,       CScriptCookieTable,  "CScriptCookieTable::CItemsArray");

MtDefine(CScriptDebugDocument,                 ObjectModel,         "CScriptDebugDocument");

// trace tags

DeclareTag(tagDebuggerDocumentSize,            "Debugger",          "trace RequestDocumentSize and UpdateDocumentSize")

// CScriptDebugDocument related
#ifndef NO_SCRIPT_DEBUGGER
extern interface IProcessDebugManager * g_pPDM;
extern interface IDebugApplication *    g_pDebugApp;
#endif // NO_SCRIPT_DEBUGGER
//+------------------------------------------------------------------------
//
//  Function:     GetMarkupFromBase
//
//-------------------------------------------------------------------------

CMarkup *
GetMarkupFromBase (CBase * pBase)
{
    CMarkup *   pMarkup = NULL;

    THR_NOTRACE(pBase->PrivateQueryInterface(CLSID_CMarkup, (void**)&pMarkup));

    return pMarkup;
}

//+------------------------------------------------------------------------
//
//  Function:     GetScriptElementFromBase
//
//-------------------------------------------------------------------------

CScriptElement *
GetScriptElementFromBase (CBase * pBase)
{
    CScriptElement *   pScriptElement = NULL;

    THR_NOTRACE(pBase->PrivateQueryInterface(CLSID_HTMLScriptElement, (void**)&pScriptElement));

    return pScriptElement;
}

//+------------------------------------------------------------------------
//
//  Function:     CrackSourceObject
//
//-------------------------------------------------------------------------

void
CrackSourceObject(CBase * pSourceObject, CMarkup ** ppMarkup, CScriptElement ** ppScriptElement)
{
    Assert (ppMarkup && ppScriptElement);

    *ppScriptElement = NULL;

    *ppMarkup = GetMarkupFromBase(pSourceObject);
    if (*ppMarkup)
        goto Cleanup;   // done

    *ppScriptElement = GetScriptElementFromBase(pSourceObject);
    if ((*ppScriptElement) && (*ppScriptElement)->_fSrc)
        goto Cleanup;   // done

    *ppMarkup = (*ppScriptElement)->GetMarkup();
    *ppScriptElement = NULL;

Cleanup:
    Assert (( (*ppScriptElement) && !(*ppMarkup)) ||
            (!(*ppScriptElement) &&  (*ppMarkup)));
    return;
}

//+------------------------------------------------------------------------
//
//  Function:   GetNamesFromUrl
//
//-------------------------------------------------------------------------

HRESULT
GetNamesFromUrl(LPTSTR pchUrl, LPTSTR * ppchShortName, LPTSTR * ppchLongName)
{
    HRESULT         hr = S_OK;
    URL_COMPONENTS  uc;
    TCHAR           achPath[pdlUrlLen];
    TCHAR           achHost[pdlUrlLen];
    LPTSTR          pchFile;

    Assert (ppchShortName && ppchLongName);

    ZeroMemory(&uc, sizeof(uc));
    uc.dwStructSize = sizeof(uc);

    uc.lpszUrlPath      = achPath;
    uc.dwUrlPathLength  = ARRAY_SIZE(achPath);
    uc.lpszHostName     = achHost;
    uc.dwHostNameLength = ARRAY_SIZE(achHost);

    if (InternetCrackUrl(pchUrl, _tcslen(pchUrl), 0, &uc))
    {
        pchFile = _tcsrchr(achPath, _T('/'));
        if (!pchFile)
            pchFile = _tcsrchr (achPath, _T('\\'));

        *ppchShortName = pchFile ? (pchFile + 1) : achPath;

        // if we have no path use the host name
        if (!(*ppchShortName)[0])
            *ppchShortName = achHost;
    }
    else
    {
        *ppchShortName = _T("Unknown");
    }

    // long name is the full URL
    *ppchLongName = pchUrl;

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Stateless helpers
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Helper:     GetScriptDebugDocument
//
//-------------------------------------------------------------------------

HRESULT
GetScriptDebugDocument(CBase * pSourceObject, CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT             hr = S_OK;
    CScriptElement *    pScriptElement;
    CMarkup *           pMarkup;

    Assert (ppScriptDebugDocument);

    *ppScriptDebugDocument = NULL;

    CrackSourceObject(pSourceObject, &pMarkup, &pScriptElement);

    if (pMarkup && pMarkup->HasScriptContext())
    {
        *ppScriptDebugDocument = pMarkup->ScriptContext()->_pScriptDebugDocument;
    }
    else if (pScriptElement)
    {
        *ppScriptDebugDocument = pScriptElement->_pScriptDebugDocument;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CScriptCookieTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::CreateCookieForSourceObject
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::CreateCookieForSourceObject (DWORD_PTR * pdwCookie, CBase * pSourceObject)
{
    HRESULT     hr;

    Assert (pdwCookie && pSourceObject);

    // we may generate 0 cookie so make sure it is not treated as NO_SOURCE_CONTEXT
    Assert (0 != NO_SOURCE_CONTEXT);

    *pdwCookie = (DWORD_PTR)_aryItems.Size();

    hr = THR(MapCookieToSourceObject(*pdwCookie, pSourceObject));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::MapCookieToSourceObject
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::MapCookieToSourceObject(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    HRESULT                 hr = S_OK;
    CItem *                 pItem;
    CScriptElement *        pScriptElement;
    CMarkup *               pMarkup;
    CMarkupScriptContext *  pMarkupScriptContext;

    Assert (NO_SOURCE_CONTEXT != dwCookie && pSourceObject);

    // if the cookie is not unique bail out. Cookies will not be unique if:
    // 1) item is a script block w/o src with the same piece of code in the same markup
    //    (e.g). a script file containing doc.write of a script block w/o src, that is the
    //    src from two or more script block with src=.
    // 2) Item is an inline event handler script conating same code in same markup
    // 3) Item is a script block with src= that someone sets the text property on thru DOM

    pItem = FindItem(dwCookie);
    if (pItem)
        goto Cleanup;

    pItem = _aryItems.Append();
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pItem->_dwCookie = dwCookie;

    CrackSourceObject(pSourceObject, &pMarkup, &pScriptElement);

    if (pScriptElement)
    {
        pItem->_type = ITEMTYPE_SCRIPTELEMENT;
        pItem->_pScriptElement = (CScriptElement*)pSourceObject;
        pItem->_pScriptElement->_dwScriptCookie = pItem->_dwCookie;
    }
    else if (pMarkup)
    {
        hr = THR(pMarkup->EnsureScriptContext(&pMarkupScriptContext));
        if (hr)
            goto Cleanup;

        if (NO_SOURCE_CONTEXT == pMarkupScriptContext->_dwScriptCookie)
        {
            pItem->_type        = ITEMTYPE_MARKUP;
            pItem->_pMarkup     = pMarkup;

            pMarkupScriptContext->_dwScriptCookie = pItem->_dwCookie;
        }
        else
        {
            pItem->_type        = ITEMTYPE_REF;
            pItem->_dwCookieRef = pMarkupScriptContext->_dwScriptCookie;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::FindItem
//
//-------------------------------------------------------------------------

CScriptCookieTable::CItem *
CScriptCookieTable::FindItem(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    CItem *     pItem;
    int         c;

    //
    // optimization: first, try at index specified by the cookie.
    // (when we get to generate cookies, we generate them so that they are indexes in the array)
    //
    if (dwCookie < (DWORD_PTR)_aryItems.Size())
    {
        pItem = &_aryItems[dwCookie];

        if (pItem->IsMatch(dwCookie, pSourceObject))
            return pItem;
    }

    //
    // if failed to find, make the normal search
    //

    for (pItem = _aryItems, c = _aryItems.Size(); c; c--, pItem++)
    {
        if (pItem->IsMatch(dwCookie, pSourceObject))
            return pItem;
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::FindItemDerefed
//
//-------------------------------------------------------------------------

CScriptCookieTable::CItem *
CScriptCookieTable::FindItemDerefed(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    CItem * pItem = FindItem(dwCookie, pSourceObject);

    if (pItem && ITEMTYPE_REF == pItem->_type)
    {
        CItem *pItemRef = FindItem(pItem->_dwCookieRef, pSourceObject);

        // If we had a ref to a revoked item
        if( !pItemRef || pItemRef->_type == ITEMTYPE_NULL )
        {
            // revoke the ref and return NULL
            pItem->_type = ITEMTYPE_NULL;
            pItem = NULL;
        }
        else
        {
            Assert( pItemRef->_type == ITEMTYPE_MARKUP );
            pItem = pItemRef;
        }
    }

    return pItem;
}
//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetSourceObjects
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetSourceObjects(
    DWORD_PTR               dwCookie,
    CMarkup **              ppMarkup,
    CScriptElement **       ppScriptElement,
    CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT             hr = S_OK;
    CScriptElement *    pScriptElement;
    CItem *             pItem= FindItemDerefed(dwCookie);

    Assert (ppMarkup);

    if (!ppScriptElement)
        ppScriptElement = &pScriptElement;

    (*ppMarkup)        = NULL;
    (*ppScriptElement) = NULL;

    if (!pItem)
        goto Cleanup;

    switch (pItem->_type)
    {
    case ITEMTYPE_NULL:
            break;

    case ITEMTYPE_SCRIPTELEMENT:
            (*ppScriptElement) = pItem->_pScriptElement;
            Assert (*ppScriptElement);
            break;

    case ITEMTYPE_MARKUP:
            (*ppMarkup) = pItem->_pMarkup;
            Assert (*ppMarkup);
            break;

    default:
            Assert (FALSE);
            break;
    }

    if ((*ppScriptElement) && (*ppScriptElement)->IsInMarkup())
    {
        *ppMarkup = (*ppScriptElement)->GetMarkup();
    }

    if (ppScriptDebugDocument)
    {
        hr = THR(GetScriptDebugDocument(pItem, ppScriptDebugDocument));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetScriptDebugDocument
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetScriptDebugDocument(
    CItem *                 pItem,
    CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT     hr = S_OK;

    Assert (pItem && ppScriptDebugDocument);

    *ppScriptDebugDocument = NULL;

    switch (pItem->_type)
    {
    case ITEMTYPE_SCRIPTELEMENT:
            *ppScriptDebugDocument = pItem->_pScriptElement->_pScriptDebugDocument;
            break;

    case ITEMTYPE_MARKUP:
            *ppScriptDebugDocument = pItem->_pMarkup->HasScriptContext() ?
                pItem->_pMarkup->ScriptContext()->_pScriptDebugDocument : NULL;
            break;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetScriptDebugDocument
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetScriptDebugDocument (
    DWORD_PTR               dwCookie,
    CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT             hr = S_OK;
    CItem *             pItem = FindItemDerefed(dwCookie);

    if (!pItem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(GetScriptDebugDocument(pItem, ppScriptDebugDocument));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::RevokeSourceObject
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::RevokeSourceObject(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    HRESULT     hr = S_OK;
    CItem *     pItem = FindItem(dwCookie, pSourceObject);

    if (pItem)
    {
        // assert that we do not revoke same thing twice
        Assert (ITEMTYPE_NULL != pItem->_type);

        pItem->_type = ITEMTYPE_NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetScriptDebugDocumentContext
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetScriptDebugDocumentContext(
    DWORD_PTR                   dwCookie,
    ULONG                       uCharacterOffset,
    ULONG                       uNumChars,
    IDebugDocumentContext **    ppDebugDocumentContext)
{
    HRESULT                 hr;
    CScriptDebugDocument *  pScriptDebugDocument;

    if (!ppDebugDocumentContext)
        RRETURN(E_POINTER);

    hr = THR(GetScriptDebugDocument(dwCookie, &pScriptDebugDocument));
    if (hr)
        goto Cleanup;

    Assert (pScriptDebugDocument);

    hr = THR(pScriptDebugDocument->GetDocumentContext(dwCookie, uCharacterOffset, uNumChars, ppDebugDocumentContext));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CScriptDebugDocument
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CreateScriptDebugDocument, static helper
//
//-------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::Create(CCreateInfo * pInfo, CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT                 hr = S_OK;

    Assert (ppScriptDebugDocument);

    *ppScriptDebugDocument = NULL;

    if ( !pInfo->_pMarkup->GetScriptCollection()
#ifndef NO_SCRIPT_DEBUGGER
        || !g_pPDM || !g_pDebugApp
#endif
        )
            goto Cleanup;

    *ppScriptDebugDocument = new CScriptDebugDocument();
    if (!(*ppScriptDebugDocument))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR((*ppScriptDebugDocument)->Init(pInfo));

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument constructor
//
//-------------------------------------------------------------------------

CScriptDebugDocument::CScriptDebugDocument()
{
#if DBG == 1
    _Host._pScriptDebugDocumentDbg = this;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument destructor
//
//-------------------------------------------------------------------------

CScriptDebugDocument::~CScriptDebugDocument()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::Init
//
//-------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::Init(CCreateInfo * pInfo)
{
    HRESULT                 hr = S_OK;
    LPTSTR                  pchShortName;
    LPTSTR                  pchLongName;
    IDebugDocumentHelper *  pParentDebugHelper;

    //
    // setup data
    //

    hr = THR(_DebugHelperCriticalSection.Init());
    if (hr)
        goto Cleanup;

    _dwThreadId = pInfo->_pMarkup->Doc()->_dwTID;

    hr = THR(_cstrUrl.Set(pInfo->_pchUrl));
    if (hr)
        goto Cleanup;

    //
    // pInfo->_pMarkupHtmCtx or pInfo->_pchSource may be necessary in methods called from threads
    // other then main doc's thread. To avoid free-threading issues with access to the data,
    // we take it local (pInfo->_pchSource) or keep it SubAddRefed (pInfo->_pMarkupHtmCtx) for lifetime.
    // SubAddRef on HtmCtx is enough because it is already free-threaded.
    //

    if (pInfo->_pMarkupHtmCtx)
    {
        Assert (!pInfo->_pchScriptElementCode);

        _pMarkupHtmCtx = pInfo->_pMarkupHtmCtx;
        _pMarkupHtmCtx->SubAddRef();
    }
    else if (pInfo->_pchScriptElementCode)
    {
        hr = THR(_cstrScriptElementCode.Set(pInfo->_pchScriptElementCode));
        if (hr)
            goto Cleanup;
    }

    //
    // create and initialize
    //
#ifndef NO_SCRIPT_DEBUGGER
    hr = THR(g_pPDM->CreateDebugDocumentHelper (0, &_pDebugHelper));
    if (hr)
#endif
        goto Cleanup;

    GetDebugHelper(NULL);   // balanced by ReleaseDebugHelper in Passivate

    hr = THR(GetNamesFromUrl(_cstrUrl, &pchShortName, &pchLongName));
    if (hr)
        goto Cleanup;

#ifndef NO_SCRIPT_DEBUGGER
    hr = THR(_pDebugHelper->Init( g_pDebugApp, pchShortName, pchLongName, 0));
    if (hr)
#endif
        goto Cleanup;

    hr = THR(_pDebugHelper->SetDebugDocumentHost (&_Host));
    if (hr)
        goto Cleanup;

    //
    // set parent
    //

    pParentDebugHelper = NULL;

    if (!pInfo->_pMarkup->IsPrimaryMarkup())
    {
        CMarkup * pMarkup =  pInfo->_pMarkup->GetFrameOrPrimaryMarkup();
        CMarkup * pMarkupParent = NULL;

        // if the markup we received with the information is a frame or primary
        // markup, then we can assume that we are a frame because of the state
        // we are in.
        if ( pMarkup == pInfo->_pMarkup)
        {
            if (pMarkup->Root()->HasMasterPtr())
            {
                pMarkupParent = pMarkup->Root()->GetMasterPtr()->GetMarkup();
            }
        }
        else
        {
            // The markup that we received with the information is not a frame or primary
            // markup. It may be created in the ether or it may be an HTC. Set the parent
            // to the frame/primary markup of this markup.
            pMarkupParent = pMarkup;
        }

        // It is possible that the element that we are hanging off from is a frame/iframe
        // and in the ether.
        // In that case, we may have a NULL parent markup.
        if (pMarkupParent)
        {
            IGNORE_HR(pMarkupParent->EnsureScriptContext());

            CMarkupScriptContext * pScriptContext = pMarkupParent->ScriptContext();

            if (pScriptContext && pScriptContext->_pScriptDebugDocument)
            {
                pParentDebugHelper = pScriptContext->_pScriptDebugDocument->_pDebugHelper;
            }
        }
    }

    hr = THR(_pDebugHelper->Attach(pParentDebugHelper));
    if (hr)
        goto Cleanup;

Cleanup:

    if (hr && _pDebugHelper)
    {
        ReleaseDebugHelper(NULL);
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::Passivate
//
//-------------------------------------------------------------------------

void
CScriptDebugDocument::Passivate()
{
    ReleaseDebugHelper(NULL);   // to balance GetDebugHelper(NULL) in Init

    if (_pMarkupHtmCtx)
    {
        _pMarkupHtmCtx->SubRelease();
        _pMarkupHtmCtx = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::GetDebugHelper
//
//-------------------------------------------------------------------------

void
CScriptDebugDocument::GetDebugHelper (IDebugDocumentHelper ** ppDebugHelper)
{
    _DebugHelperCriticalSection.Enter();

    if (_pDebugHelper)
    {
        _cDebugHelperAccesses++;

        if (ppDebugHelper)
        {
            *ppDebugHelper = _pDebugHelper;
            _pDebugHelper->AddRef();
        }
    }

    _DebugHelperCriticalSection.Leave();
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::ReleaseDebugHelper
//
//-------------------------------------------------------------------------

void
CScriptDebugDocument::ReleaseDebugHelper(IDebugDocumentHelper * pDebugHelper)
{
    IDebugDocumentHelper *  pDebugHelperToDetach = NULL;

    _DebugHelperCriticalSection.Enter();

    if (_pDebugHelper)
    {
        Assert(_cDebugHelperAccesses);

        _cDebugHelperAccesses--;

        if (0 == _cDebugHelperAccesses)
        {
            pDebugHelperToDetach = _pDebugHelper;
            if (pDebugHelperToDetach)
            {
                pDebugHelperToDetach->AddRef();
                ClearInterface(&_pDebugHelper);
            }
        }
    }

    _DebugHelperCriticalSection.Leave();

    if (pDebugHelperToDetach)
    {
        IGNORE_HR(pDebugHelperToDetach->Detach());
        pDebugHelperToDetach->Release();
    }

    ReleaseInterface (pDebugHelper);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CreateDebugContext
//
//-------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::DefineScriptBlock(
    IActiveScript *     pActiveScript,
    ULONG               ulOffset,
    ULONG               ulCodeLen,
    BOOL                fScriptlet,
    DWORD_PTR *         pdwScriptCookie)
{
    HRESULT  hr = E_FAIL;

    Assert (pActiveScript && pdwScriptCookie);

    *pdwScriptCookie = NO_SOURCE_CONTEXT;

    if (_pDebugHelper)
        hr = THR(_pDebugHelper->DefineScriptBlock(ulOffset, ulCodeLen, pActiveScript, fScriptlet, pdwScriptCookie));

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::IllegalCall
//
//---------------------------------------------------------------------------

BOOL
CScriptDebugDocument::IllegalCall()
{
    if (_dwThreadId != GetCurrentThreadId())
    {
        AssertSz(FALSE, "Script debugger called across thread boundry (not an MSHTML bug)");
        return TRUE;
    }

    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::GetDocumentContext
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::GetDocumentContext(
    DWORD_PTR                   dwCookie,
    ULONG                       uCharacterOffset,
    ULONG                       uNumChars,
    IDebugDocumentContext **    ppDebugDocumentContext)
{
    HRESULT                 hr;
    ULONG                   ulStartOffset;
    IDebugDocumentHelper *  pDebugHelper = NULL;

    GetDebugHelper(&pDebugHelper);
    if (!pDebugHelper)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(pDebugHelper->GetScriptBlockInfo(dwCookie, NULL, &ulStartOffset, NULL));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pDebugHelper->CreateDebugDocumentContext(
        ulStartOffset + uCharacterOffset, uNumChars, ppDebugDocumentContext));

Cleanup:

    ReleaseDebugHelper(pDebugHelper);

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::SetDocumentSize
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::SetDocumentSize(ULONG ulSize)
{
    HRESULT     hr = S_OK;

    hr = THR(RequestDocumentSize(ulSize));
    if (hr)
        goto Cleanup;

    hr = THR(UpdateDocumentSize());

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::RequestDocumentSize
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::RequestDocumentSize(ULONG ulSize)
{
    HRESULT     hr = S_OK;

    TraceTag((
        tagDebuggerDocumentSize,
        "CScriptDebugDocument::RequestDocumentSize: url: %ls, current size = %ld, requested size = %ld",
        (LPTSTR)_cstrUrl, _ulCurrentSize, ulSize));

    _ulNewSize = max (_ulCurrentSize, ulSize);

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::UpdateDocumentSize
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::UpdateDocumentSize()
{
    HRESULT     hr = S_OK;

    TraceTag((
        tagDebuggerDocumentSize,
        "CScriptDebugDocument::UpdateDocumentSize: url: %ls, current size = %ld, new size = %ld",
        (LPTSTR)_cstrUrl, _ulCurrentSize, _ulNewSize));

    if (_ulCurrentSize < _ulNewSize )
    {
#ifndef NO_SCRIPT_DEBUGGER
        if (_pDebugHelper)
            hr = THR(_pDebugHelper->AddDeferredText (_ulNewSize - _ulCurrentSize, _ulCurrentSize));
#endif

        _ulCurrentSize = _ulNewSize;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::ViewSourceInDebugger
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::ViewSourceInDebugger (ULONG ulLine, ULONG ulOffsetInLine)
{
    HRESULT                 hr = S_OK;
    ULONG                   ulLineOffset = 0;
    IDebugDocumentText *    pDebugDocumentText = NULL;
    IDebugDocumentContext * pDebugDocumentContext = NULL;

    hr = THR(UpdateDocumentSize());
    if (hr)
        goto Cleanup;

    if (ulLine || ulOffsetInLine)
    {
        hr = THR(_pDebugHelper->QueryInterface(IID_IDebugDocumentText, (void**)&pDebugDocumentText));
        if(hr)
            goto Cleanup;

        hr = THR(pDebugDocumentText->GetPositionOfLine(ulLine, &ulLineOffset));
        if(hr)
            goto Cleanup;
    }

    hr = THR(_pDebugHelper->CreateDebugDocumentContext(ulLineOffset + ulOffsetInLine, 0, &pDebugDocumentContext));
    if (hr)
        goto Cleanup;

    hr = THR(_pDebugHelper->BringDocumentContextToTop (pDebugDocumentContext));

Cleanup:

    ReleaseInterface(pDebugDocumentText);
    ReleaseInterface(pDebugDocumentContext);

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::QueryInterface, per IUnknown
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::QueryInterface(REFIID iid, void **ppv)
{
    if (SDD()->IllegalCall())
        RRETURN(E_NOINTERFACE);

    if (!ppv)
        RRETURN(E_POINTER);

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IDebugDocumentHost)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::GetDeferredText, per IDebugDocumentHost
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::GetDeferredText(
    DWORD               dwStart,
    WCHAR *             pchText,
    SOURCE_TEXT_ATTR *  ,
    ULONG *             pcTextLen,
    ULONG               cMaxTextLen)
{
    HRESULT     hr = S_OK;

    if (!pchText || !pcTextLen)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (SDD()->_pMarkupHtmCtx)
    {
        hr = THR(SDD()->_pMarkupHtmCtx->ReadUnicodeSource(pchText, dwStart, cMaxTextLen, pcTextLen));
    }
    else
    {
        Assert (!SDD()->_cstrScriptElementCode.IsNull());
        if (SDD()->_cstrScriptElementCode.Length() <= dwStart )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        *pcTextLen = min ((ULONG)(SDD()->_cstrScriptElementCode.Length() - dwStart), cMaxTextLen - 1);

        _tcsncpy(pchText, SDD()->_cstrScriptElementCode, *pcTextLen);

        pchText[*pcTextLen] = 0;
    }

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::GetPathName, per IDebugDocumentHost
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::GetPathName(BSTR * pbstrLongName, BOOL * pfIsOriginalFile)
{
    HRESULT         hr = E_NOTIMPL;

    Assert (FALSE && "not implemeneted; not supposed to be called");

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::GetFileName, per IDebugDocumentHost
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::GetFileName(BSTR * pbstrShortName)
{
    HRESULT         hr = E_NOTIMPL;

    Assert (FALSE && "not implemeneted; not supposed to be called");

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\docdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:       docdata.cxx
//
//  Implement Data transfer support for Doc object
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetPlaintext
//
//  Synopsis:   Helper function to get plaintext in a specified codepage.
//
//---------------------------------------------------------------

HRESULT
CDoc::GetPlaintext(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere,
        CODEPAGE codepage)
{
    HRESULT     hr;

    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pUnkForRelease = NULL;

        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm));
        if (hr)
            goto Cleanup;
    }

    //
    // Save to the stream in plaintext mode, but do not word wrap (since we do
    //  not word wrap on the clipboard either).
    //
    hr = THR(DYNCAST(CDoc, pServer)->SaveToStream(pmedium->pstm,
        WBF_SAVE_PLAINTEXT|WBF_FORMATTED_PLAINTEXT|WBF_NUMBER_LISTS|
        WBF_FORMATTED|WBF_NO_WRAP,
        codepage));

Cleanup:
    //  If we failed somehow and yet created a docfile, then we will
    //      release the docfile to delete it

    if (hr && !fHere)
        ClearInterface(&pmedium->pstm);

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetTEXT
//
//  Synopsis:   Get CF_TEXT format for the CDoc object
//
//---------------------------------------------------------------

HRESULT
CDoc::GetTEXT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    RRETURN(GetPlaintext(pServer, pformatetc, pmedium, fHere, g_cpDefault));
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetUNICODETEXT
//
//  Synopsis:   Get CF_UNICODETEXT format for the CDoc object
//
//---------------------------------------------------------------

HRESULT
CDoc::GetUNICODETEXT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    RRETURN(GetPlaintext(pServer, pformatetc, pmedium, fHere, CP_UCS_2));
}

#ifndef NO_RTF
//+---------------------------------------------------------------
//
//  Member:     CDoc::GetRTF
//
//  Synopsis:   Get CF_RTF format for the CDoc object
//
//---------------------------------------------------------------

HRESULT
CDoc::GetRTF(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT                 hr = S_OK;
#ifndef WINCE
    CDoc *                  pDoc = DYNCAST(CDoc, pServer);

    if (!pDoc->RtfConverterEnabled())
        return E_FAIL;

    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pUnkForRelease = NULL;

        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm));
        if (hr)
        {
            goto Cleanup;
        }
    }

    hr = CRtfToHtmlConverter::InternalHtmlToStreamRtf(pDoc, pmedium->pstm);

Cleanup:
    //  If we failed somehow and yet created a docfile, then we will
    //      release the docfile to delete it

    if (hr && !fHere)
        ClearInterface(&pmedium->pstm);

#endif // WINCE
    RRETURN1(hr, S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\cutil.cxx ===
//+---------------------------------------------------------------------
//
//   File:      cutil.cxx
//
//  Contents:   Utility functions for CSite, move out from csite.cxx
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif

MtDefine(DoInsertObjectUI_plptszResult, Utilities, "DoInsertObjectUI *plptszResult")

extern "C" const CLSID CLSID_HTMLImg;
extern "C" const CLSID CLSID_HTMLButtonElement;
//extern "C" const CLSID CLSID_HTMLInputTextElement;
extern "C" const CLSID CLSID_HTMLTextAreaElement;
//extern "C" const CLSID CLSID_HTMLOptionButtonElement;
extern "C" const CLSID CLSID_HTMLListElement;
extern "C" const CLSID CLSID_HTMLMarqueeElement;
extern "C" const CLSID CLSID_HTMLDivPosition;
extern "C" const CLSID CLSID_HTMLHRElement;
extern "C" const CLSID CLSID_HTMLIFrame;
//extern "C" const CLSID CLSID_HTMLInputButtonElement;
//extern "C" const CLSID CLSID_HTMLInputFileElement;
extern "C" const CLSID CLSID_HTMLFieldSetElement;
extern "C" const CLSID CLSID_HTMLParaElement;
extern "C" const CLSID CLSID_HTMLInputElement;

static const struct HTMLSTRMAPPING
{
    UINT        cmd;
    const CLSID *     pClsid;
    LPCSTR      lpsz;
}
s_aHtmlMaps[] =
{   
    { 0,                    NULL,                           "<OBJECT %s></OBJECT>"},
    { IDM_IMAGE,            &CLSID_HTMLImg,                 "<IMG%s>"},
    { IDM_BUTTON,           &CLSID_HTMLButtonElement,       "<BUTTON%s></BUTTON>"},
    //{ IDM_RICHTEXT,         &CLSID_HTMLRichtextElement,     "<RICHTEXT%s></RICHTEXT"},
    { IDM_TEXTBOX,          &CLSID_HTMLInputElement,        "<INPUT TYPE = TEXT%s>"},
    { IDM_TEXTAREA,         &CLSID_HTMLTextAreaElement,     "<TEXTAREA%s></TEXTAREA>"},
    { IDM_CHECKBOX,         NULL,                           "<INPUT TYPE = CHECKBOX%s>"},   
    { IDM_RADIOBUTTON,      &CLSID_HTMLInputElement,        "<INPUT TYPE = RADIO%s>"},
    { IDM_DROPDOWNBOX,      &CLSID_HTMLListElement,         "<SELECT%s> </SELECT>"},
    { IDM_LISTBOX,          NULL,                           "<SELECT MULTIPLE%s> </SELECT>"},
    { IDM_MARQUEE,          &CLSID_HTMLMarqueeElement,      "<MARQUEE%s></MARQUEE>"},
    { IDM_1D,               &CLSID_HTMLDivPosition,         "<DIV STYLE=POSITION:RELATIVE%s></DIV>"},
    { IDM_HORIZONTALLINE,   &CLSID_HTMLHRElement,           "<HR%s>"},
    { IDM_IFRAME,           &CLSID_HTMLIFrame,              "<IFRAME%s></IFRAME>"},
    { IDM_INSINPUTBUTTON,   &CLSID_HTMLInputElement,        "<INPUT TYPE = BUTTON%s>"},
    { IDM_INSINPUTRESET,    NULL,                           "<INPUT TYPE = RESET%s>"},
    { IDM_INSINPUTSUBMIT,   NULL,                           "<INPUT TYPE = SUBMIT%s>"},
    { IDM_INSINPUTUPLOAD,   &CLSID_HTMLInputElement,        "<INPUT TYPE = FILEUPLOAD%s>"},
    { IDM_INSINPUTIMAGE,    &CLSID_HTMLInputElement,        "<INPUT TYPE = IMAGE%s>"},
    { IDM_INSINPUTHIDDEN,   NULL,                           "<INPUT TYPE = HIDDEN%s>"},
    { IDM_INSINPUTPASSWORD, NULL,                           "<INPUT TYPE = PASSWORD%s>"},
    { IDM_INSFIELDSET,      &CLSID_HTMLFieldSetElement,     "<FIELDSET%s></FIELDSET>"},
    { IDM_PARAGRAPH,        &CLSID_HTMLParaElement,         "<P%s>"},
    { IDM_NONBREAK,         NULL,                           "&nbsp;"}
};

typedef LPTSTR (*PFILEHELPER) (LPTSTR, LPTSTR, int, int *);


HRESULT
ClsidParamStrFromClsid (CLSID * pClsid, LPTSTR ptszParam, int cbParam)
{
    HRESULT     hr;

    hr = THR(Format (
        0, ptszParam, cbParam,
        _T("CLASSID = \"clsid<0g>"),
        pClsid
    ));
    if (!OK(hr))
        goto Cleanup;

    if ( (_T('{') != ptszParam[16+0]) || (_T('}') != ptszParam[16+37]) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ptszParam[16+0 ] = _T(':');
    ptszParam[16+37] = _T('"');

Cleanup:
    RRETURN (hr);
}


HRESULT
ClsidParamStrFromClsidStr (LPTSTR ptszClsid, LPTSTR ptszParam, int cbParam)
{
    HRESULT     hr;

    hr = THR(Format (
        0, ptszParam, cbParam,
        _T("CLASSID = \"clsid<0s>"),
        ptszClsid
    ));
    if (!OK(hr))
        goto Cleanup;

    if ( (_T('{') != ptszParam[16+0]) || (_T('}') != ptszParam[16+37]) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ptszParam[16+0 ] = _T(':');
    ptszParam[16+37] = _T('"');

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   HtmlTagStrFromParam
//
//  Synopsis:   If it is intrinic control, create html tag and return S_OK
//
//-------------------------------------------------------------------------
HRESULT
HtmlTagStrFromParam (LPTSTR lptszInsertParam, int *pnFound)
{
    HRESULT             hr = E_FAIL;
    int                 i;
    TCHAR               aszClsid[CLSID_STRLEN + 1];
    CLSID               clsid;
    TCHAR  *            pch;

    Assert(pnFound);

    if (!lptszInsertParam)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get clsid string from lptszInsertParam

    pch = _tcsstr(lptszInsertParam, _T(":"));
    if (!pch)
        goto Cleanup;

    _tcscpy(aszClsid, pch);

    aszClsid[0] = _T('{');
    aszClsid[CLSID_STRLEN - 1] = _T('}');
    aszClsid[CLSID_STRLEN] = 0;

    hr = CLSIDFromString(aszClsid, &clsid);
    if (hr)
        goto Cleanup;

    // find mapping
    for (i = 0; i < ARRAY_SIZE(s_aHtmlMaps); i++)
    {
        if (!s_aHtmlMaps[i].pClsid)
            continue;

        if (clsid.Data1 != s_aHtmlMaps[i].pClsid->Data1)
            continue;

        if(IsEqualCLSID(clsid, *s_aHtmlMaps[i].pClsid))
        {
            // match is found
            *pnFound = i;
            hr = S_OK;
            goto Cleanup;
        }
    }

    // No match is found
     *pnFound = -1;

Cleanup:
    RRETURN(hr);
}

#ifndef NO_OLEUI

//--------------------------------------------------------------------
// OleUIMetafilePictIconFree
//
// Purpose:
//  Deletes the metafile contained in a METAFILEPICT structure and
//  frees the memory for the structure itself.
//
// Parameters:
//  hMetaPict       HGLOBAL metafilepict structure created in
//                  OleUIMetafilePictFromIconAndLabel
//
// Return Value:
//  None
//-------------------------------------------------------------------

STDAPI_(void) OleUIMetafilePictIconFree(HGLOBAL hMetaPict)
{
    LPMETAFILEPICT      pMF;

    if (NULL==hMetaPict)
        return;

    pMF=(LPMETAFILEPICT)GlobalLock(hMetaPict);

    if (NULL!=pMF)
    {
        if (NULL!=pMF->hMF)
            DeleteMetaFile(pMF->hMF);
    }

    GlobalUnlock(hMetaPict);
    GlobalFree(hMetaPict);
}

//+----------------------------------------------------------------------------
//
//  Function:     DoInsertObjectUI
//
//  Synopsis:   executes UI for Insert / Object
//
//  Arguments   [out] dwResult      specifies what was specified in UI
//              [out] plptszResult  specifies classid, file name, etc., depending
//                                  on dwResult flags
//
//  Returns:    S_OK                OK hit in UI, plptszResult set
//              S_FALSE             CANCEL hit in UI, NULL == *plptszResult
//              other               failure
//
//-----------------------------------------------------------------------------

DYNLIB g_dynlibOLEDLG = { NULL, NULL, "OLEDLG.DLL" };

DYNPROC g_dynprocOleUIInsertObjectA =
         { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };

HRESULT
DoInsertObjectUI (CElement * pElement, DWORD * pdwResult, LPTSTR * plptszResult)
{
    HRESULT                 hr = S_OK;
    OLEUIINSERTOBJECTA      ouio;
    CHAR                    szFile[MAX_PATH] = "";
    TCHAR                   wszFile[MAX_PATH];
    UINT                    uRC;

    *pdwResult = 0;
    *plptszResult = NULL;

    // zero ouio
    memset(&ouio, 0, sizeof(ouio));

    // and fill it out
    ouio.cbStruct = sizeof(ouio);
    ouio.dwFlags =
            IOF_DISABLELINK |       // BUBUG Remove when form supports links.
            IOF_SELECTCREATENEW |
            IOF_DISABLEDISPLAYASICON |
            IOF_HIDECHANGEICON |
            IOF_VERIFYSERVERSEXIST |
            IOF_SHOWINSERTCONTROL;
    ouio.hWndOwner = pElement->Doc()->InPlace()->_hwnd;
    ouio.lpszFile = szFile;
    ouio.cchFile = ARRAY_SIZE(szFile);

    hr = THR(LoadProcedure(&g_dynprocOleUIInsertObjectA));
    if (!OK(hr))
        goto Cleanup;

    uRC = (*(UINT (STDAPICALLTYPE *)(LPOLEUIINSERTOBJECTA))
            g_dynprocOleUIInsertObjectA.pfn)(&ouio);

    hr = (OLEUI_OK     == uRC) ? S_OK :
         (OLEUI_CANCEL == uRC) ? S_FALSE :
                                 E_FAIL;
    if (S_OK != hr)
        goto Cleanup;

    Assert((ouio.dwFlags & IOF_SELECTCREATENEW) ||
           (ouio.dwFlags & IOF_SELECTCREATEFROMFILE) ||
           (ouio.dwFlags & IOF_SELECTCREATECONTROL));

    *pdwResult = ouio.dwFlags;

    if (*pdwResult & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
    {
        const int cbResult = 128;

        *plptszResult = new(Mt(DoInsertObjectUI_plptszResult)) TCHAR[cbResult];
        hr = (*plptszResult) ? S_OK : E_OUTOFMEMORY;
        if (!OK(hr))
            goto Cleanup;

        ClsidParamStrFromClsid (&ouio.clsid, *plptszResult, cbResult);
    }
    else // if (*pdwResult & IOF_SELECTCREATEFROMFILE)
    {
        int     nFile;

        nFile = MultiByteToWideChar(CP_ACP, 0,
            szFile, -1,
            wszFile, ARRAY_SIZE(wszFile));

        if (0 == nFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastWin32Error());
            Assert (!OK(hr));
            goto Cleanup;
        }

        *plptszResult = new(Mt(DoInsertObjectUI_plptszResult)) TCHAR[nFile+1];
        hr = (*plptszResult) ? S_OK : E_OUTOFMEMORY;
        if (!OK(hr))
            goto Cleanup;

        _tcscpy ((LPTSTR)(*plptszResult), wszFile);
    }
Cleanup:
    if (ouio.hMetaPict)
        OleUIMetafilePictIconFree(ouio.hMetaPict);

    if (!OK(hr))
    {
        ClearErrorInfo();
        PutErrorInfoText(EPART_ACTION, IDS_EA_INSERT_CONTROL);
        pElement->CloseErrorInfo(hr);
    }

    RRETURN1 (hr, S_FALSE);
}
#endif  // NO_OLEUI

//+------------------------------------------------------------------------
//
//  Function:   ObjectParamStrFromDO
//
//  Synopsis:   creates object param string which will then be inserted
//              into html like this: <OBJECT %s> </OBJECT>
//
//  Arguments:  [in] pDO                data object to convert
//              [in] prc                rectangle which specifies size of the object
//                                      if NULL, no size specified
//                                      if not NULL and left <= right and top <= bottom,
//                                      (right-left, bottom-top) specify the size
//              [in-out] lptszParam     output string
//              [in] cbParam            max len of output string
//              [out] pfNeedToCreateFromDO
//                                      true if this object need to
//                                      be created from a data object
//
//-------------------------------------------------------------------------

HRESULT
ObjectParamStrFromDO (IDataObject * pDO, RECT * prc,
                      LPTSTR lptszParam, int cbParam)
{
    HRESULT         hr = S_OK;
    TCHAR           tszParam[pdlUrlLen + 10] = _T("");
    TCHAR           tszHW[64] = _T("");
    TCHAR           tszClsid[CLSID_STRLEN + 1] = _T("");

    // tszParam used for both file name and clsid param, so make sure it will
    // be able to contain CLSID param
    Assert (64 < MAX_PATH);
    TCHAR *pFormatStr = _T("style=\"WIDTH = <0d>px HEIGHT = <1d>px TOP = <2d>px LEFT = <3d>px\" ");

    // set HEIGHT & WIDTH attrs if any
    if (prc && (prc->left <= prc->right) && (prc->top <= prc->bottom) )
    {
        hr = THR(Format (
            0, tszHW, ARRAY_SIZE (tszHW),
            pFormatStr,
            prc->right - prc->left, prc->bottom - prc->top,
            prc->top, prc->left ) );
        if (!OK(hr))
            goto Cleanup;
    }

    //
    if (OK(GetcfCLSIDFmt(pDO, tszClsid)))
    {
        hr = THR(ClsidParamStrFromClsidStr(tszClsid, tszParam, ARRAY_SIZE(tszParam)));
        if (!OK(hr))
            goto Cleanup;
    }
    else
    {
        tszParam[0] = 0;
        
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(Format (
        0, lptszParam, cbParam,
        _T("<0s><1s>"),
        tszHW, tszParam
    ));

Cleanup:

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetShortcutFileName
//
//  Synopsis:   Generate file name for URL shortcut
//
//  Arguments:  [pchUrl]    URL to be used for creating the shortcut (input)
//              [pchName]   Description of the URL (input)
//              [pchOut]    Buffer (must be of size MAX_PATH or more) to return
//                          file name (output)
//
//  Notes:      We should throw away this code and use the shell function
//              GetShortcutFileName() instead as and when that becomes
//              available as an exported function.
//
//----------------------------------------------------------------------------

BOOL
GetShortcutFileName(const TCHAR * pchUrl, const TCHAR * pchName, TCHAR * pchOut)
{
    TCHAR   achBuf[MAX_PATH-4];

    Assert(pchUrl && *pchUrl);
    Assert(pchOut);

    achBuf[0] = 0;

    // Use name/title if one is supplied
    if (pchName && *pchName)
    {
        _tcsncpy(achBuf, pchName, MAX_PATH - 5);

        // Force this to be null-terminated, since _tcsncpy does not always do so.
        achBuf[MAX_PATH - 5] = 0;
        
        // Remove leading space
        StrTrim(achBuf, _T(" \t\r\n"));
    }

    // Otherwise, use the URL
    if (!achBuf[0])
    {
        _tcsncpy(achBuf, PathFindFileName(pchUrl), MAX_PATH - 5);

        // Force this to be null-terminated, since _tcsncpy does not always do so.
        achBuf[MAX_PATH - 5] = 0;
        
        // Remove leading space
        StrTrim(achBuf, _T(" \t\r\n"));
    }

    // Validate the file name
    if (!PathCanonicalize(pchOut, achBuf))
    {
        return FALSE;
    }

    // Replace any remaining invalid characters with '-'
    while (*pchOut)
    {
        if (PathGetCharType(*pchOut) & (GCT_INVALID | GCT_WILD | GCT_SEPARATOR))
        {
            *pchOut = _T('-');
        }
        pchOut++;
    }


    _tcscat(pchOut, _T(".url"));
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateLinkDataObject
//
//  Synopsis:   Create a link data object as an Internet Shortcut
//
//  Arguments:  [pchUrl]    URL to be used for creating the shortcut (input)
//              [pchName]   Description of the URL (input)
//              [ppLink]    Pointer to the link data object created (output)
//
//  Notes:      Mostly copied from IE3.
//
//----------------------------------------------------------------------------
HRESULT
CreateLinkDataObject(const TCHAR *              pchUrl,
                     const TCHAR *              pchName,
                     IUniformResourceLocator ** ppLink)
{
#if defined(WIN16) || defined(WINCE)
    return E_FAIL;
#else
    HRESULT         hr = S_OK;
    IShellLink *    pisl = NULL;
    TCHAR           achFileName[MAX_PATH];

    if (!pchUrl || !*pchUrl || !ppLink)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppLink = NULL;
    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                           IID_IUniformResourceLocator, (void **)ppLink);
    if (hr)
        goto Cleanup;

    hr = (*ppLink)->SetURL(pchUrl, 0);
    if (hr)
    {
        // Translate URL-specific failure into generic failure.
        if (hr == URL_E_INVALID_SYNTAX)
            hr = E_FAIL;

        goto Cleanup;
    }

    hr = (*ppLink)->QueryInterface(IID_IShellLink, (void **)&pisl);
    if (hr != S_OK)
        goto Cleanup;

    if (!GetShortcutFileName(pchUrl, pchName, achFileName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IGNORE_HR(pisl->SetDescription(achFileName));
    ReleaseInterface(pisl);

Cleanup:
    RRETURN(hr);
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   CopyFileToClipboard
//
//  Synopsis:   Supports CF_HDROP format
//
//  Arguments:  [pchPath]   Fully expanded file path (input)
//              [pDO]       Pointer to the data object (input)
//
//  Notes:      Mostly copied from IE3.
//
//----------------------------------------------------------------------------
HRESULT
CopyFileToClipboard(const TCHAR * pchPath, CGenDataObject * pDO)
{
    HRESULT             hr = S_OK;
#ifndef WIN16
    ULONG               cchPath, cchAnsi;
    HGLOBAL             hgDropFiles = NULL;
    DROPFILES *         pdf;
    char *              pchDropPath;

    if (!pchPath || !*pchPath || !pDO)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    cchPath = _tcslen(pchPath);

    // Convert file path to ANSI. While NT shell can handle both
    // UNICODE and ANSI, Win95 shell can handle only ANSI.
    cchAnsi = WideCharToMultiByte(CP_ACP, 0, pchPath, cchPath + 1,
                NULL, 0, NULL, NULL);
    if (cchAnsi <= 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // (+ 2) for double null terminator.
    // GPTR does zero-init for us
    hgDropFiles = GlobalAlloc(GPTR,
                    sizeof(DROPFILES) + cchAnsi + 1);
    if (!hgDropFiles)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pdf = (DROPFILES *)hgDropFiles;
    if (!pdf)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pdf->pFiles = sizeof(DROPFILES);
    // pdf->fWide = FALSE; // ZeroInit takes care of this

    pchDropPath = (char *)(pdf + 1);
    WideCharToMultiByte(CP_ACP, 0, pchPath, cchPath + 1,
                pchDropPath, cchAnsi+1, NULL, NULL);

    hr = pDO->AppendFormatData(CF_HDROP, hgDropFiles);
    if (hr)
        goto Cleanup;

    // Don't free hgDropFiles on subsequent error now that
    // hgDropFiles has been added to the data object.
    // IDataObject::Release() will.
    hgDropFiles = NULL;

Cleanup:
    if (hgDropFiles)
        GlobalFree(hgDropFiles);
#endif // !WIN16
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Function: IsTabKey
//
// Test if CMessage is a TAB KEYDOWN message.
//
//-----------------------------------------------------------------------------
BOOL
IsTabKey(CMessage * pMessage)
{
    BOOL fTabOrder = FALSE;

    if (pMessage->message == WM_KEYDOWN)
    {
        if (pMessage->wParam == VK_TAB)
        {
            fTabOrder = (pMessage->dwKeyState & FCONTROL) ? (FALSE) : (TRUE);
        }
    }

    return fTabOrder;
}

//+---------------------------------------------------------------------------
//
// Function: IsFrameTabKey
//
// Test if CMessage is a CTRL+TAB or F6 KEYDOWN message.
//
//-----------------------------------------------------------------------------
BOOL
IsFrameTabKey(CMessage * pMessage)
{
    BOOL fResult = FALSE;

    if (pMessage->message == WM_KEYDOWN)
    {
        if ((pMessage->wParam == VK_TAB && (pMessage->dwKeyState & FCONTROL))
                || (pMessage->wParam == VK_F6))
        {
            fResult = TRUE;
        }
    }
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\dispserv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       dispserv.cxx
//
//  Contents:   Display pointer implementation
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_H_
#define X_TPOINTER_H_
#include "tpointer.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DISPSERV_HXX_
#define X_DISPSERV_HXX_
#include "dispserv.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

// TODO: move to global place in trident [ashrafm]
#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}
#define GetCharFmt(iCF)  (&(*_pts->_pCharFormatCache)[iCF])
#define GetParaFmt(iPF)  (&(*_pts->_pParaFormatCache)[iPF])
#define GetFancyFmt(iFF) (&(*_pts->_pFancyFormatCache)[iFF])

extern COORDINATE_SYSTEM MapToCoordinateEnum(COORD_SYSTEM eCoordSystem);

//
// DumpTree display pointer adorner
//
#if DBG == 1
static const LPCTSTR strDebugDispPointerPrefix = _T("DP");
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CreateDisplayPointer, public
//
//  Synopsis:   IDisplayServices::CreateDisplayPointer
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CreateDisplayPointer(IDisplayPointer **ppDispPointer)
{
    if (!ppDispPointer)
        return E_INVALIDARG;

    *ppDispPointer = new CDisplayPointer(this);
    if (!*ppDispPointer)
        return E_OUTOFMEMORY;

    return S_OK;
}

        
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::CDisplayPointer, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CDisplayPointer::CDisplayPointer(CDoc *pDoc)
: _mpPosition(pDoc)
{
    // arbitrary defaults since pointer is not positioned
    _fNotAtBOL = FALSE;
    _cRefs = 1;
    
#if DBG==1    
    // Ensure tree dump contains display pointer prefix
    _mpPosition.SetDebugName(strDebugDispPointerPrefix);
#endif        
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::~CDisplayPointer, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CDisplayPointer::~CDisplayPointer()
{
    _mpPosition.Unposition();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::AddRef, public
//
//  Synopsis:   IUnknown::AddRef
//
//----------------------------------------------------------------------------

ULONG
CDisplayPointer::AddRef()
{
    return ++_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::Release, public
//
//  Synopsis:   IUnknown::Release
//
//----------------------------------------------------------------------------

ULONG
CDisplayPointer::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if( 0 == _cRefs )
    {
        delete this;
        return 0;
    }

    return _cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::QueryInterface, public
//
//  Synopsis:   IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT 
CDisplayPointer::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_IDisplayPointer)
    {
        *ppvObj = (IDisplayPointer *)this;
        AddRef();    
    }
    else if (iid == CLSID_CDisplayPointer)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::PositionMarkupPointer, public
//
//  Synopsis:   Position a markup pointer at the current display pointer
//              position.
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::PositionMarkupPointer(IMarkupPointer *pPointer)
{
    HRESULT         hr;
    
    if (!pPointer)
        RRETURN(E_INVALIDARG);

    IFC( pPointer->MoveToPointer(&_mpPosition) );
    
Cleanup:        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::PositionMarkupPointer, public
//
//  Synopsis:   Internal version of PositionMarkupPointer
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::PositionMarkupPointer(CMarkupPointer *pPointer)
{
    HRESULT         hr;
    
    if (!pPointer)
        RRETURN(E_INVALIDARG);

    IFC( pPointer->MoveToPointer(&_mpPosition) );
    
Cleanup:        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveToPointer, public
//
//  Synopsis:   Move current pointer to pDispPointer.
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::MoveToPointer(IDisplayPointer *pDispPointer)
{
    HRESULT         hr;
    CDisplayPointer *pDispPointerInternal;

    if (!pDispPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );    

    if (!pDispPointerInternal->_mpPosition.IsPositioned())
    {
        IFC( _mpPosition.Unposition() );
    }
    else
    {
        IFC( _mpPosition.MoveToPointer(&pDispPointerInternal->_mpPosition) );
    }
    
    _fNotAtBOL = pDispPointerInternal->_fNotAtBOL;

Cleanup:    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveToPoint, public
//
//  Synopsis:   Display pointer hit testing method
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::MoveToPoint(
    POINT           pt, 
    COORD_SYSTEM    eCoordSystem, 
    IHTMLElement    *pElementContext,
    DWORD           dwHitTestOptions,
    DWORD           *pdwHitTestResults)
{
    HRESULT             hr = E_FAIL;
    POINT               ptContent = g_Zero.pt;      // keep compiler happy
    CTreeNode           *pTreeNode = NULL;
    CLayoutContext      *pLayoutContext = NULL;     // layout context corresponding to pTreeNode
    COORDINATE_SYSTEM   eInternalCoordSystem;
    BOOL                fNotAtBOL = FALSE;          // keep compiler happy
    BOOL                fAtLogicalBOL;
    CFlowLayout         *pContainingLayout = NULL;
    BOOL                fHitGlyph = FALSE;          // keep compiler happy
    CDispNode           *pDispNode = NULL;

    if (pdwHitTestResults)
        *pdwHitTestResults = NULL;

    g_uiDisplay.DeviceFromDocPixels(&pt);
 
    //
    // Convert external coordinate system to internal coordinate system
    //
    
    switch (eCoordSystem)
    {
        case COORD_SYSTEM_GLOBAL:   
        case COORD_SYSTEM_CONTENT:
            break;

        default:
            AssertSz(0, "Unsupported coordinate system");
            hr = E_INVALIDARG;
            goto Cleanup;
    }            

    IFC( MapToCoordinateEnum(eCoordSystem, &eInternalCoordSystem) );

    //
    // If we have a containing layout, transform to the layouts coordinate system
    //

    if (pElementContext)
    {
        CElement *pElementInternal;

        // $$ktam: TODO we're unable to get the context for pElementContext (it's passed in as
        // an IHTMLElement).  May be forced to pass GUL_USEFIRSTLAYOUT, even though that's clearly wrong.
        
        IFC( pElementContext->QueryInterface(CLSID_CElement, (void**)&pElementInternal) );
        pContainingLayout = pElementInternal->GetFlowLayout();
        if (!pContainingLayout)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // If passed global coordinates, transform to the layout's coordinate system
        //
        
        pTreeNode = pContainingLayout->GetFirstBranch();

        if (eCoordSystem == COORD_SYSTEM_GLOBAL)
        {
            if (!pTreeNode)
            {
                hr = E_UNEXPECTED;
                goto Cleanup;
            }
            
            pContainingLayout->TransformPoint((CPoint *)&pt, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
            eCoordSystem = COORD_SYSTEM_CONTENT;
        }        
        
        ptContent = pt;
    }
    else if (eCoordSystem == COORD_SYSTEM_CONTENT)
    {
        //
        // Can't hit test to COORD_SYSTEM_CONTENT without a layout element
        //

        AssertSz(0, "CDisplayPointer::MoveToPoint - missing pElementContext");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Hit test to get the node
    //
        
    if (eCoordSystem == COORD_SYSTEM_GLOBAL)
    {
        pTreeNode = GetDoc()->GetNodeFromPoint(pt, &pLayoutContext, TRUE, &ptContent,
                                               NULL, NULL, NULL, &pDispNode);

        if( pTreeNode == NULL )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (pTreeNode->Element()->Tag() == ETAG_HTML)
        {
            hr = CTL_E_INVALIDLINE;
            goto Cleanup;
        }
        
        if ((ptContent.x == 0) && (ptContent.y == 0))
        {
            //
            // Sometimes - HitTestPoint returns ptContent of 0 We take over ourselves.
            //
            CFlowLayout * pLayout = NULL;
            
            pLayout = pTreeNode->GetFlowLayout( pLayoutContext );
            if( pLayout == NULL )
            {
                hr = CTL_E_INVALIDLINE;
                goto Cleanup;
            }

            CPoint myPt( pt );
            pLayout->TransformPoint( &myPt, eInternalCoordSystem, COORDSYS_FLOWCONTENT, pDispNode );

            ptContent = myPt;

            pTreeNode = pLayout->ElementOwner()->GetFirstBranch();
            Assert( pTreeNode );
        }
    
    }

    //
    // Do the move pointer to point internal
    //
    
    hr = THR( GetDoc()->MovePointerToPointInternal(
        ptContent, 
        pTreeNode, 
        pLayoutContext,
        &_mpPosition, 
        &fNotAtBOL, 
        &fAtLogicalBOL, 
        NULL, 
        FALSE, 
        pContainingLayout, 
        NULL, 
        dwHitTestOptions & HT_OPT_AllowAfterEOL,
        &fHitGlyph,
        pDispNode) );

    if (pdwHitTestResults && fHitGlyph)
    {
        (*pdwHitTestResults) |= HT_RESULTS_Glyph;
    }
        
    _fNotAtBOL = fNotAtBOL;

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::SetPointerGravity, publiv
//
//  Synopsis:   Sets the cooresponding markup pointer gravity
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::SetPointerGravity(POINTER_GRAVITY eGravity)
{
    RRETURN( _mpPosition.SetGravity(eGravity) );
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsPositioned, publiv
//
//  Synopsis:   Is the display pointer positioned?
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsPositioned(BOOL *pfPositioned)
{
    RRETURN( _mpPosition.IsPositioned(pfPositioned) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::Unposition, public
//
//  Synopsis:   Unposition the pointer
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::Unposition()
{
    RRETURN( _mpPosition.Unposition() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::SetDebugName, public
//
//  Synopsis:   Sets the cooresponding markup pointer debug name
//
//----------------------------------------------------------------------------
#if DBG==1
void 
CDisplayPointer::SetDebugName(LPCTSTR szDebugName)
{
    CStr strDebugName;

    strDebugName.Append(strDebugDispPointerPrefix);
    strDebugName.Append(L" - ");
    strDebugName.Append(szDebugName);
    _mpPosition.SetDebugName(strDebugName);
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetCp, publiv
//
//  Synopsis:   Gets the Cp for the current display pointer
//
//----------------------------------------------------------------------------
LONG 
CDisplayPointer::GetCp()
{
    return _mpPosition.GetCp();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MapToCoordinateEnum, private
//
//  Synopsis:   Maps external coord system to internal coord system
//
//----------------------------------------------------------------------------
HRESULT 
CDisplayPointer::MapToCoordinateEnum(COORD_SYSTEM eCoordSystem, COORDINATE_SYSTEM *peCoordSystemInternal)
{   
    HRESULT             hr = S_OK;

    Assert(peCoordSystemInternal);
    
    switch (eCoordSystem)
    {
    case COORD_SYSTEM_GLOBAL:   
        *peCoordSystemInternal = COORDSYS_GLOBAL;
        break;

    case COORD_SYSTEM_PARENT: 
        *peCoordSystemInternal = COORDSYS_PARENT;
        break;

    case COORD_SYSTEM_CONTAINER:
        *peCoordSystemInternal = COORDSYS_BOX;
        break;

    case COORD_SYSTEM_CONTENT:
        *peCoordSystemInternal  = COORDSYS_FLOWCONTENT;
        break;

    default:
        hr = E_INVALIDARG;       
    }

    RRETURN(hr);
}





//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveUnit, public
//
//  Synopsis:   IDisplayServices::MoveUnit
//
//  Note:   MoveUnit takes paramter in content coordinate system!!!
// 
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::MoveUnit(DISPLAY_MOVEUNIT eMoveUnit, LONG lXCurReally)
{
    HRESULT hr = S_OK;
    CFlowLayout *pFlowLayout;
    CTreeNode   *pNode;
    CMarkup     *pMarkup = NULL;
    LONG        cp;
    BOOL        fNotAtBOL;
    BOOL        fAtLogicalBOL;
    CView       *pView = GetDoc()->GetView();

    CPoint      ptGlobalCurReally;
    ILineInfo   *pLineInfo = NULL;

    if (lXCurReally > 0)
    {
        lXCurReally = g_uiDisplay.DeviceFromDocPixelsX(lXCurReally);
    }

    switch (eMoveUnit)
    {
        case DISPLAY_MOVEUNIT_TopOfWindow:
        {
            //
            // TODO: We need to be a bit more precise about where the
            // top of the first line is
            //
            
            // Go to top of window, not container...
            CPoint pt;
            // TODO: why was this made 12?
            pt.x = 12;
            pt.y = 12;
                        
            fNotAtBOL = _fNotAtBOL;
            hr = THR( GetDoc()->MoveMarkupPointerToPointEx( pt, &_mpPosition, TRUE, &fNotAtBOL, &fAtLogicalBOL, NULL, FALSE ));
            _fNotAtBOL = fNotAtBOL;
            goto Cleanup;
        }
        
        case DISPLAY_MOVEUNIT_BottomOfWindow:
        {
            //
            // TODO: More precision about the actual end of line needed
            //
            
            // Little harder, first have to calc the window size

            CSize szScreen;
            CPoint pt;
            
            //
            // Get the rect of the document's window
            //

            if ( !pView->IsActive() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            pView->GetViewSize( &szScreen );
            pt = szScreen.AsPoint();

            Assert( pt.x > 0 && pt.y > 0 );
            pt.x -= 12;
            pt.y -= 12;
            fNotAtBOL = _fNotAtBOL;
            hr = THR( GetDoc()->MoveMarkupPointerToPointEx(pt, &_mpPosition, TRUE, &fNotAtBOL, &fAtLogicalBOL, NULL, FALSE));
            _fNotAtBOL = fNotAtBOL;
            goto Cleanup;                
        }
    }
        
    // get element for current position so we can get its flow layout
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode)
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    // get cp for current position
    cp = _mpPosition.GetCp();

    // use layout to get new position
    // Get the line where we are positioned.
    pMarkup = pNode->GetMarkup();

    LAYOUT_MOVE_UNIT eUnit;
    
    switch (eMoveUnit)
    {
        case DISPLAY_MOVEUNIT_PreviousLine:
            eUnit = LAYOUT_MOVE_UNIT_PreviousLine;
            break;
            
        case DISPLAY_MOVEUNIT_NextLine:
            eUnit = LAYOUT_MOVE_UNIT_NextLine;
            break;
            
        case DISPLAY_MOVEUNIT_CurrentLineStart:
            eUnit = LAYOUT_MOVE_UNIT_CurrentLineStart;
            break;
            
        case DISPLAY_MOVEUNIT_CurrentLineEnd:
            eUnit = LAYOUT_MOVE_UNIT_CurrentLineEnd;
            break;
            
        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    //
    // Accessing line information, ensure a recalc has been done
    //
    hr = THR(pNode->Element()->EnsureRecalcNotify(FALSE));
    if (hr)
        goto Cleanup;
    
    fNotAtBOL = _fNotAtBOL;

    pFlowLayout = pNode->GetFlowLayout();
    if(!pFlowLayout)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    //  Bug 26586: Don't try to position the pointer inside of a hidden element.
    if ( !pNode->Element()->IsVisible(TRUE) )
    {
        TraceTag((tagWarning, "Trying to position a pointer inside of a hidden element."));
        goto Cleanup;
    }

    //
    // TODO:    MoveMarkupPointer uses global coordinate since it needs to move between different
    //          layouts. In the future we should not allow MoveUnit to move out of different 
    //          its current layout.  (zhenbinx)
    //
    //
    ptGlobalCurReally.x = lXCurReally;
    if (SUCCEEDED(GetLineInfo(&pLineInfo)))
    {
        LONG lYPos;
       
        pLineInfo->get_baseLine(&lYPos);

        ptGlobalCurReally.y = g_uiDisplay.DeviceFromDocPixelsY(lYPos);
    }
    else
    {
        ptGlobalCurReally.y = 0;
    }
    pFlowLayout->TransformPoint(&ptGlobalCurReally, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
    hr = THR( pFlowLayout->MoveMarkupPointer(&_mpPosition, cp, eUnit, ptGlobalCurReally, &fNotAtBOL, &fAtLogicalBOL) );
    _fNotAtBOL = fNotAtBOL;

Cleanup:
    ReleaseInterface(pLineInfo);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetPointerGravity, public
//
//  Synopsis:   Get the markup pointer gravity
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::GetPointerGravity(POINTER_GRAVITY* peGravity)
{
    return _mpPosition.Gravity(peGravity);
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::SetDisplayGravity, public
//
//  Synopsis:   Sets the display gravity, i.e., set _fNotAtBOL.
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::SetDisplayGravity(DISPLAY_GRAVITY eGravity)
{
    switch (eGravity)
    {
        case DISPLAY_GRAVITY_PreviousLine:
            _fNotAtBOL = TRUE;
            break;

        case DISPLAY_GRAVITY_NextLine:
            _fNotAtBOL = FALSE;
            break;

        default:
            return E_INVALIDARG;
          
    }

    return S_OK;
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetDisplayGravity, public
//
//  Synopsis:   Gets the display gravity
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetDisplayGravity(DISPLAY_GRAVITY* peGravity)
{
    if (!peGravity)
        return E_INVALIDARG;

    *peGravity = _fNotAtBOL ? DISPLAY_GRAVITY_PreviousLine : DISPLAY_GRAVITY_NextLine;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::ScrollIntoView, public
//
//  Synopsis:   Scroll into view using POINTER_SCROLLPIN_Minimal
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::ScrollIntoView()
{
    RRETURN1(GetDoc()->ScrollPointerIntoView(&_mpPosition, _fNotAtBOL, POINTER_SCROLLPIN_Minimal), S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetLineInfo, public
//
//  Synopsis:   Create an ILineInfo object
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetLineInfo(ILineInfo **ppLineInfo)
{
    HRESULT     hr;
    CLineInfo   *pLineInfo = NULL;
    CTreeNode   *pNode = NULL;
    CFlowLayout *pFlowLayout;
    const CCharFormat *pCharFormat;

    //
    // Validate arguments    
    //
    
    if (!ppLineInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *ppLineInfo = NULL;

    if (!_mpPosition.IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);   
    if (!pNode && _mpPosition.Markup())
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if(pNode == NULL)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pFlowLayout = pNode->GetFlowLayout();
    pCharFormat = pNode->GetCharFormat();
    if(!pFlowLayout || !pCharFormat)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Create CLineInfo object
    //

    pLineInfo = new CLineInfo;
    if (!pLineInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    IFC( pLineInfo->Init(&_mpPosition, pFlowLayout, pCharFormat, _fNotAtBOL) );

    *ppLineInfo = pLineInfo;
    pLineInfo->AddRef();
    
Cleanup:    
    ReleaseInterface(pLineInfo);
        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveToMarkupPointer, public
//
//  Synopsis:   Position the display pointer at the specific markup pointer
//              location using the specified display pointer as line context
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::MoveToMarkupPointer(IMarkupPointer* pPointer, IDisplayPointer* pDispLineContext)
{
    HRESULT             hr;
    CDisplayPointer     *pDispPointerInternal = NULL; // keep compiler happy
    CTreeNode           *pNode;
    LONG                cpStart;
    LONG                cpStartContext = 0;           // keep compiler happy
    CLayout             *pLayout;
    CMarkupPointer      *pPointerInternal;
    const CCharFormat   *pCF;

    //
    // Validate arguments
    //
    
    if (!pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pDispLineContext)
    {
        IFC( pDispLineContext->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );    

        if (!pDispPointerInternal->_mpPosition.IsPositioned())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

    }

    //
    // Position the markup pointer
    //    
    IFC( _mpPosition.MoveToPointer(pPointer) );

    if( !_mpPosition.IsPositioned() )
        goto Cleanup;    


    //
    // Make sure that our nearest layout is a flow layout
    //

    IFC( pPointer->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerInternal) );

    pNode = pPointerInternal->CurrentScope();
    if( !pNode )
    {
        if( pPointerInternal->Markup()->GetElementClient() )
        {
            pNode = pPointerInternal->Markup()->GetElementClient()->GetFirstBranch();
        }
        else
        {
            pNode = pPointerInternal->Markup()->Root()->GetFirstBranch();
        }
        Assert( pNode );
    }

    pLayout = pNode->GetUpdatedNearestLayout( GUL_USEFIRSTLAYOUT );
    if (!pLayout || !pLayout->IsFlowLayout())
    {
        hr = CTL_E_INVALIDLINE;
        goto Cleanup;
    }

    //
    // Check for display none.  There are no valid lines here and we can't measure, so 
    // don't position a display pointer there.
    //

    pCF = pNode->GetCharFormat();
    Assert(pCF);

    if (pCF->_fDisplayNone)
    {
        hr = CTL_E_INVALIDLINE;
        goto Cleanup;
    }
    
    //
    // Get line context from display pointer
    //
    
    if (pDispLineContext)
    {
        IFC( pDispPointerInternal->GetLineStart(&cpStartContext) );
    }
    else
    {
        //
        // If no line context, we're done
        //
        goto Cleanup;
    }
    
    //
    // Position the markup pointer on the same line as pDispLineContext
    //

    IFC( GetLineStart(&cpStart) );

    if (cpStart != cpStartContext)
    {
        _fNotAtBOL = !_fNotAtBOL;
        IFC( GetLineStart(&cpStart) );

        if (cpStart != cpStartContext)
        {
            _fNotAtBOL = !_fNotAtBOL;
            hr = S_FALSE; // can't position on the same line, so return S_FALSE
        }
    }

Cleanup:    
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsEqualTo, public
//
//  Synopsis:   IDisplayServices::IsEqualTo
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsEqualTo(IDisplayPointer* pDispPointer, BOOL* pfIsEqual)
{
    HRESULT hr;
    CDisplayPointer *pDispPointerInternal;
    BOOL fBetweenLines;

    if (!pfIsEqual)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );
    
    IFC( _mpPosition.IsEqualTo(&pDispPointerInternal->_mpPosition, pfIsEqual) );
    if (*pfIsEqual == FALSE)
        goto Cleanup;

    IFC( IsBetweenLines(&fBetweenLines) );
    if (!fBetweenLines)
        goto Cleanup;
    
    *pfIsEqual = (_fNotAtBOL == pDispPointerInternal->_fNotAtBOL);

Cleanup:
    RRETURN(hr);
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsLeftOf, public
//
//  Synopsis:   IDisplayServices::IsLeftOf
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsLeftOf(IDisplayPointer* pDispPointer, BOOL* pfIsLeftOf)
{
    HRESULT hr;
    CDisplayPointer *pDispPointerInternal;
    BOOL fBetweenLines;

    if (!pfIsLeftOf)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );
    
    IFC( _mpPosition.IsLeftOf(&pDispPointerInternal->_mpPosition, pfIsLeftOf) );
    if (*pfIsLeftOf == TRUE)
        goto Cleanup;

    IFC( _mpPosition.IsEqualTo(&pDispPointerInternal->_mpPosition, pfIsLeftOf) );
    if (*pfIsLeftOf == FALSE)
        goto Cleanup;

    IFC( IsBetweenLines(&fBetweenLines) );
    if (!fBetweenLines)
    {
        *pfIsLeftOf = FALSE;
        goto Cleanup;
    }
    
    // Equal and fBetweenLines so use gravity to determine CDisplayPointer::IsLeftOf
    *pfIsLeftOf = !_fNotAtBOL && pDispPointerInternal->_fNotAtBOL;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsRightOf, public
//
//  Synopsis:   IDisplayServices::IsRightOf
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsRightOf(IDisplayPointer* pDispPointer, BOOL* pfIsRightOf)
{
    HRESULT hr;
    CDisplayPointer *pDispPointerInternal;
    BOOL fBetweenLines;

    if (!pfIsRightOf)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );
    
    IFC( _mpPosition.IsRightOf(&pDispPointerInternal->_mpPosition, pfIsRightOf) );
    if (*pfIsRightOf == TRUE)
        goto Cleanup;

    IFC( _mpPosition.IsEqualTo(&pDispPointerInternal->_mpPosition, pfIsRightOf) );
    if (*pfIsRightOf == FALSE)
        goto Cleanup;

    IFC( IsBetweenLines(&fBetweenLines) );
    if (!fBetweenLines)
    {
        *pfIsRightOf = FALSE;
        goto Cleanup;
    }

    *pfIsRightOf = _fNotAtBOL && !pDispPointerInternal->_fNotAtBOL;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsBetweenLines, public
//
//  Synopsis:   IDisplayServices::IsBetweenLines
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsBetweenLines(BOOL* pfBetweenLines)
{
    HRESULT             hr = S_OK;
    CFlowLayout *       pFlowLayout;
    CTreeNode *         pNode = NULL;
    LONG                cp;
    BOOL                fBetweenLines = TRUE;
    
    if(pfBetweenLines == NULL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( _mpPosition.IsPositioned() );
    
    cp = _mpPosition.GetCp();
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode && _mpPosition.Markup())
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if (!pNode)
        goto Cleanup;
    
    pFlowLayout = pNode->GetFlowLayout();

    if( !pFlowLayout || pFlowLayout != pNode->GetUpdatedNearestLayout() )
        goto Cleanup;

    fBetweenLines = pFlowLayout->IsCpBetweenLines( cp );

Cleanup:
    if( pfBetweenLines )
        *pfBetweenLines = fBetweenLines;
        
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsAtBOL, public
//
//  Synopsis:   IDisplayServices::IsAtBOL
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::IsAtBOL(BOOL* pfIsAtBOL)
{
    HRESULT     hr = S_OK;
    LONG        cpCurrent, cpLineStart;
    
    if (!pfIsAtBOL && !_mpPosition.IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC(IsBetweenLines(pfIsAtBOL));
    if (*pfIsAtBOL)
    {
        *pfIsAtBOL = !_fNotAtBOL;
        goto Cleanup;
    }

    cpCurrent = GetCp();
    IFC( GetLineStart(&cpLineStart) );

    *pfIsAtBOL = (cpCurrent <= cpLineStart);
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetLineStart, private
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetLineStart(LONG *pcp)
{
    HRESULT     hr = S_OK;
    CFlowLayout *pFlowLayout;
    BOOL        fNotAtBOL, fAtLogicalBOL;

    Assert(pcp);

    *pcp = -1;
    
    // get element for current position so we can get its flow layout
    pFlowLayout = GetFlowLayout();
    if(!pFlowLayout)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    fNotAtBOL = _fNotAtBOL;
    *pcp = GetCp();    
    IFC( pFlowLayout->LineStart(pcp, &fNotAtBOL, &fAtLogicalBOL, TRUE) );

Cleanup:
    RRETURN(hr);
}    

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetLineEnd, private
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetLineEnd(LONG *pcp)
{
    HRESULT     hr = S_OK;
    CFlowLayout *pFlowLayout;
    BOOL        fNotAtBOL, fAtLogicalBOL;

    Assert(pcp);

    *pcp = -1;
    
    pFlowLayout = GetFlowLayout();
    if(!pFlowLayout)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    fNotAtBOL = _fNotAtBOL;
    *pcp = GetCp();    
    IFC( pFlowLayout->LineEnd(pcp, &fNotAtBOL, &fAtLogicalBOL, TRUE) );

Cleanup:
    RRETURN(hr);
}    

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetFlowElement, public
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetFlowElement(IHTMLElement **ppLayoutElement)
{
    HRESULT hr;
    CFlowLayout *pFlowLayout;
    CTreeNode   *pNode;

    if (!_mpPosition.IsPositioned() || !ppLayoutElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    // get element for current position so we can get its flow layout
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);

    if( !pNode && _mpPosition.Markup())
    {
        if( _mpPosition.Markup()->GetElementClient() )
        {
            pNode = _mpPosition.Markup()->GetElementClient()->GetFirstBranch();
        }
        else
        {
            pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        }
        Assert( pNode );
    }
   
    pFlowLayout = pNode->GetFlowLayout();
    if(!pFlowLayout || !pFlowLayout->ElementOwner())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pFlowLayout->ElementOwner()->HasMasterPtr())
    {
        IFC( pFlowLayout->ElementOwner()->GetMasterPtr()->QueryInterface( IID_IHTMLElement, ( void**) ppLayoutElement ));
    }
    else
    {
        IFC( pFlowLayout->ElementOwner()->QueryInterface( IID_IHTMLElement, ( void**) ppLayoutElement ));
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetFlowLayout, private
//
//----------------------------------------------------------------------------
CFlowLayout *
CDisplayPointer::GetFlowLayout()
{
    CFlowLayout *pFlowLayout = NULL;
    CTreeNode   *pNode;

    if (!_mpPosition.IsPositioned())
        goto Cleanup;
    
    // get element for current position so we can get its flow layout
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode && _mpPosition.Markup())
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if (!pNode)
        goto Cleanup;

    pFlowLayout = pNode->GetFlowLayout();
    
Cleanup:
    return pFlowLayout;    
}
   
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::QueryBreaks, public
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::QueryBreaks(DWORD *pfBreaks)
{
    HRESULT         hr;
    LONG            cpEnd;
    LONG            cp = GetCp();
    CFlowLayout     *pFlowLayout;

    //
    // Validate arguments
    //
    if (!pfBreaks)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pfBreaks = DISPLAY_BREAK_None;

    pFlowLayout = GetFlowLayout();
    if (!pFlowLayout)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // If not at EOL, use previous line as the reference point
    //

    {
        CDisplay *pdp = pFlowLayout->GetDisplay();
        CLinePtr  rp(pdp);

        //
        // Accessing line information, ensure a recalc has been done
        //
        hr = THR(pFlowLayout->ElementOwner()->EnsureRecalcNotify(FALSE));
        if (hr)
            goto Cleanup;
        
        //
        // Line end is only exposed at adjusted line end
        //

        IFC( GetLineEnd(&cpEnd) );
        if (cp != cpEnd)
            goto Cleanup; // Not at the end of the line

        rp.RpSetCp(cp, TRUE);

        //
        // Position CLinePtr
        //
        if (pdp)
        {
            CLineCore *pli;

            pli = rp.CurLine();
            if (pli)
            {
                if (pli->_fHasEOP || pli->_fForceNewLine)
                    *pfBreaks |= DISPLAY_BREAK_Block;

                if (pli->_fHasBreak)
                    *pfBreaks |= DISPLAY_BREAK_Break;
                
            }        
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Member:     CLineInfo::AddRef, public
//
//  Synopsis:   IUnknown::AddRef
//
//----------------------------------------------------------------------------

ULONG
CLineInfo::AddRef()
{
    return ++_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLineInfo::Release, public
//
//  Synopsis:   IUnknown::Release
//
//----------------------------------------------------------------------------

ULONG
CLineInfo::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if( 0 == _cRefs )
    {
        delete this;
        return 0;
    }

    return _cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLineInfo::QueryInterface, public
//
//  Synopsis:   IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT 
CLineInfo::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ILineInfo)
    {
        *ppvObj = (ILineInfo *)this;
        AddRef();    
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLineInfo::Init, public
//
//  Synopsis:   CLineInfo::Init
//
//----------------------------------------------------------------------------
HRESULT
CLineInfo::Init(CMarkupPointer *pPointerInternal, CFlowLayout *pFlowLayout, const CCharFormat *pCharFormat, BOOL fNotAtBOL)
{
    HRESULT             hr;
    HTMLPtrDispInfoRec  info;
    
    IFC( pFlowLayout->GetLineInfo(pPointerInternal, fNotAtBOL, &info, pCharFormat) );

    _lXPosition = g_uiDisplay.DocPixelsFromDeviceX(info.lXPosition);
    _yBaseLine = g_uiDisplay.DocPixelsFromDeviceY(info.lBaseline);
    _yTextDescent = g_uiDisplay.DocPixelsFromDeviceY(info.lTextDescent);
    _yTextHeight = g_uiDisplay.DocPixelsFromDeviceY(info.lTextHeight);
    
    _fRTLLine = info.fRTLLine;
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CComputedStyle, public
//
//  Synopsis:   IDisplayServices::GetComputedStyle
//
//----------------------------------------------------------------------------

HRESULT
CDoc::HasFlowLayout(IHTMLElement *pIElement, BOOL *pfHasFlowLayout)
{
    HRESULT hr;
    CElement *pElement;
    CTreeNode *pNode;

    if (!pIElement || !pfHasFlowLayout)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pIElement->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr)
        goto Cleanup;

    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
        if (!pElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    pNode = pElement->GetFirstBranch();
    if(!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pfHasFlowLayout = !!pNode->HasFlowLayout();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CComputedStyle, public
//
//  Synopsis:   IDisplayServices::GetComputedStyle
//
//----------------------------------------------------------------------------

HRESULT
CDoc::GetComputedStyle(IMarkupPointer *pPointer, IHTMLComputedStyle **ppComputedStyle)
{
    HRESULT hr;
    CComputedStyle *pComputedStyle = NULL;
    CMarkupPointer *pPointerInternal;
    CTreeNode *pNode;
    long lcfIdx = -1, lpfIdx = -1, lffIdx = -1;
    THREADSTATE *pts;
    const CCharFormat *pCF;
    CColorValue ccvBackColor;
    BOOL fHasBgColor;
    
    if (!ppComputedStyle || !pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppComputedStyle = NULL;

    hr = THR(pPointer->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal));
    if (hr)
        goto Cleanup;

    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode && pPointerInternal->Markup())
    {
        pNode = pPointerInternal->Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if (!pNode)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    lcfIdx = pNode->GetCharFormatIndex();
    lpfIdx = pNode->GetParaFormatIndex();
    lffIdx = pNode->GetFancyFormatIndex();

    Assert(lcfIdx >= 0);
    Assert(lpfIdx >= 0);
    Assert(lffIdx >= 0);

    pts = GetThreadState();

    //
    // Check for background color.  This value isn't inherited in the FancyFormat, so we need to 
    // compute its value here.
    //
    
    pCF = (&(*pts->_pCharFormatCache)[lcfIdx]);
    Assert(pCF);

    ccvBackColor.Undefine();        

    if (pNode->ShouldHaveLayout())
    {
        CBackgroundInfo bginfo;
        CLayout *pLayout = pNode->GetUpdatedLayout();
        pLayout->GetBackgroundInfo(NULL, &bginfo, FALSE);
        fHasBgColor = bginfo.crBack != COLORREF_NONE;
    }
    else
    {
        fHasBgColor = pCF->_fHasBgColor;
    }
    
    if (fHasBgColor)
    {
        CElement *pElementFL = pNode->GetFlowLayoutElement();
        const CFancyFormat * pFF;

        if (pElementFL)
        {
            while(pNode)
            {
                pFF = pNode->GetFancyFormat();

                if (pFF && pFF->_ccvBackColor.IsDefined())
                {
                    ccvBackColor = pFF->_ccvBackColor;
                    break;
                }
                else
                {
                    if (DifferentScope(pNode, pElementFL))
                        pNode = pNode->Parent();
                    else
                        pNode = NULL;
                }
            }
        }
        
    }

    //
    // Create the computed style object
    //
    
    pComputedStyle = new CComputedStyle(pts, lcfIdx, lpfIdx, lffIdx, ccvBackColor);
    if (!pComputedStyle)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppComputedStyle = pComputedStyle;
    
Cleanup:    
    RRETURN(hr);
}

CComputedStyle::CComputedStyle(THREADSTATE *pts, long lcfIdx, long lpfIdx, long lffIdx, const CColorValue &ccvBgColor)
{
    _cRefs = 1;

    _lcfIdx = lcfIdx;
    _lpfIdx = lpfIdx;
    _lffIdx = lffIdx;
    
    Assert(pts);
    _pts = pts;
    pts->_pCharFormatCache->AddRefData(lcfIdx);
    pts->_pParaFormatCache->AddRefData(lpfIdx);
    pts->_pFancyFormatCache->AddRefData(lffIdx);        

    _ccvBgColor = ccvBgColor;
}

CComputedStyle::~CComputedStyle()
{
    Assert(_lcfIdx >= 0);
    Assert(_lpfIdx >= 0);
    Assert(_lffIdx >= 0);

    Assert(_pts);
    _pts->_pCharFormatCache->ReleaseData(_lcfIdx);
    _pts->_pParaFormatCache->ReleaseData(_lpfIdx);
    _pts->_pFancyFormatCache->ReleaseData(_lffIdx);        
}

ULONG
CComputedStyle::AddRef()
{
    return ++_cRefs;
}

ULONG
CComputedStyle::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if(0 == _cRefs)
    {
        delete this;
        return 0;
    }

    return _cRefs;
}

HRESULT 
CComputedStyle::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_IHTMLComputedStyle)
    {
        *ppvObj = (IHTMLComputedStyle *)this;
        AddRef();    
    }
    else if (iid == CLSID_CComputedStyle)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    return S_OK;
}

HRESULT
CComputedStyle::get_bold(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fBold ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_italic(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fItalic ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_underline(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fUnderline ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_overline(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fOverline ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_strikeOut(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fStrikeOut ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_subScript(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fSubscript ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_superScript(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fSuperscript ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_explicitFace(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fExplicitFace ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_fontWeight(long *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_wWeight;
    return S_OK;
}

HRESULT
CComputedStyle::get_fontSize(long *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_yHeight;
    return S_OK;
}

HRESULT
CComputedStyle::get_fontName(LPTSTR pchName)
{
    HRESULT hr = S_OK;

    if (!pchName)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    
    // The destination buffer must be large enough in to include the NULL
    // terminator, so we assume it is LF_FACESIZE+1.  This fact needs to 
    // be documented in the sdk and I've verified that internal calls 
    // (as of 2/20/2002) do indeed allocate a large enough buffer.

    if (FAILED(StringCchCopy(pchName, LF_FACESIZE+1, pcF->GetFaceName())))
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}

HRESULT
CComputedStyle::get_hasBgColor(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);
    *p = _ccvBgColor.IsDefined() ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_textColor(DWORD *pdwColor)
{
    if (!pdwColor)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *pdwColor = pcF->_ccvTextColor.GetIntoRGB();
    return S_OK;
}

HRESULT
CComputedStyle::get_backgroundColor(DWORD *pdwColor)
{
    if (!pdwColor)
        RRETURN(E_INVALIDARG);

    *pdwColor = _ccvBgColor.GetIntoRGB();
    return S_OK;
}

HRESULT
CComputedStyle::get_preFormatted(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = ppF->_fPre ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_direction(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = ppF->_fRTL ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_blockDirection(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = ppF->_fRTLInner ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_OL(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = (ppF->_cListing.GetType() == CListing::NUMBERING) ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::IsEqual(IHTMLComputedStyle *pComputedStyle, VARIANT_BOOL *pfEqual)
{
    HRESULT hr;
    CComputedStyle *pSrcStyle;

    if (!pComputedStyle || !pfEqual)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pComputedStyle->QueryInterface(CLSID_CComputedStyle, (void **)&pSrcStyle));
    if (hr)
        goto Cleanup;

    *pfEqual = ((_lcfIdx == pSrcStyle->_lcfIdx) && 
                (_lpfIdx == pSrcStyle->_lpfIdx) &&
                (_lffIdx == pSrcStyle->_lffIdx));

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\doclyout.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       layout.cxx
//
//  Contents:   Layout management
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

DeclareTag(tagDocSize, "DocSize tracing", "Trace changes to document size");

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetExtent, IOleObject
//
//  Synopsis:   Called when the container wants to tell us a new size.  We
//              override this method so we can maintain the logical size of
//              the form properly.
//
//  Arguments:  dwAspect    Aspect which is changing.
//              psizel      New size
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetExtent(DWORD dwAspect, SIZEL *psizel)
    {
    HRESULT hr;

    TraceTagEx((tagDocSize, TAG_NONAME,
           "Doc : SetExtent - sizel(%d, %d)",
           (psizel ? psizel->cx : 0),
           (psizel ? psizel->cy : 0)));

#ifdef WIN16
    // in case we were are on some other thread's stack (e.g. Java)...
    // impersonate our own
    CThreadImpersonate cimp(_dwThreadId);
#endif
    hr = THR(CServer::SetExtent(dwAspect, psizel));
    if (hr)
        goto Cleanup;

    //
    // Update the transform with the new extents
    //

    if (dwAspect == DVASPECT_CONTENT && psizel && (psizel->cx || psizel->cy))
    {
        // this ensures that psizel is at least one screen pixel in highmetric (about 26 for 96dpi)
        SIZE size1pixel;
        _dciRender.HimetricFromDevice(size1pixel, 1, 1);
        psizel->cx = max(psizel->cx, size1pixel.cx);
        psizel->cy = max(psizel->cy, size1pixel.cy);

        // FUTURE (alexmog, 9/6/99): I think we should review this, considering that we have WYSIWYG zoom.
        //                 Ole client calling this method, expects us to either zoom to the 
        //                 provided rectangle, or relayout to fit in it. The effect of SetViewSize
        //                 is probably relayout (but I need to see that in debugger). 
        //                 Is it what we want to do, or do we actually want to zoom?
        //
        //                 In any case, this is probably the only way to create a DocScaleInfo with
        //                 scaling ratio different from _sizeInch/2540. It probably means that if a 
        //                 different scaling is applied, we'll see a bunch of bugs. 

        SIZE size;
        _dciRender.CDocScaleInfo::DeviceFromHimetric(size, *psizel);

        //  Alter view/measuring device information
        _view.SetViewSize(size);

        TraceTagEx((tagDocSize, TAG_NONAME,
               "Doc : SetExtent - Rendering Device(%d, %d)",
               size.cx,
               size.cy));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetObjectRects, IOleInplaceObject
//
//  Synopsis:   Set position and clip rectangles.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::SetObjectRects(LPCOLERECT prcPos, LPCOLERECT prcClip)
{
    CRect rcPosPrev, rcClipPrev;
    CRect rcPos, rcClip;
    HRESULT hr;

    TraceTagEx((tagDocSize, TAG_NONAME,
           "Doc : SetObjectRects - rcPos(%d, %d, %d, %d) rcClip(%d, %d, %d, %d)",
           (!prcPos ? 0 : prcPos->left),
           (!prcPos ? 0 : prcPos->top),
           (!prcPos ? 0 : prcPos->right),
           (!prcPos ? 0 : prcPos->bottom),
           (!prcClip ? 0 : prcClip->left),
           (!prcClip ? 0 : prcClip->top),
           (!prcClip ? 0 : prcClip->right),
           (!prcClip ? 0 : prcClip->bottom)));

    Assert(State() >= OS_INPLACE);
    Assert(_pInPlace);

    rcPosPrev  = _pInPlace->_rcPos;
    rcClipPrev = _pInPlace->_rcClip;

#ifdef WIN16
    // in case we were are on some other thread's stack (e.g. Java)...
    // impersonate our own
    CThreadImpersonate cimp(_dwThreadId);
#endif
    {
        CLock   Lock(this, SERVERLOCK_IGNOREERASEBKGND);

        hr = THR(CServer::SetObjectRects(prcPos, prcClip));
        if (hr)
            goto Cleanup;
    }

    rcPos  = _pInPlace->_rcPos;
    rcClip = _pInPlace->_rcClip;

    {
        CSize sizePos;         rcPos.GetSize(&sizePos);
        CSize sizePosPrev; rcPosPrev.GetSize(&sizePosPrev);
    
        //
        // If necessary, initiate a re-layout
        //
        if (!sizePos.IsZero() && sizePos != sizePosPrev)
        {
            _view.SetViewSize(sizePos);
        }
        //
        //  Otherwise, just invalidate the view
        //
        else if (rcClip.right - rcClip.left != rcClipPrev.right - rcClipPrev.left ||
                 rcClip.bottom - rcClip.top != rcClipPrev.bottom - rcClipPrev.top  )
        {
            // TODO: We need an invalidation...will a partial work? (brendand)
            Invalidate();        
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureFormatCacheChange
//
//  Synopsis:   Clears the format caches for the client site and then
//              invalidates it.
//
//----------------------------------------------------------------------------

void
CMarkup::EnsureFormatCacheChange(DWORD dwFlags)
{
    if ((Doc()->State() < OS_RUNNING) || !Root())
        return;

    Root()->EnsureFormatCacheChange(dwFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ForceRelayout
//
//  Synopsis:   Whack the entire display
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ForceRelayout ( )
{
    HRESULT hr = S_OK;
    CNotification   nf;

    if (PrimaryMarkup())
    {
        PrimaryRoot()->EnsureFormatCacheChange( ELEMCHNG_CLEARCACHES );
        nf.DisplayChange(PrimaryRoot());
        PrimaryRoot()->SendNotification(&nf);     
    }

    _view.ForceRelayout();

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\edrouter.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       EDROUTER.CXX
//
//  Contents:   Infrastructure for appropriate routing of edit commands
//
//  Classes:    CEditRouter
//
//  History:    19-Feb-98   raminh  Created
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_EDROUTER_HXX_
#define X_EDROUTER_HXX_
#include "edrouter.hxx"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

extern "C" const CLSID  CLSID_Mshtmled;
extern "C" const GUID   SID_SEditCommandTarget;
extern "C" const GUID   CGID_EditStateCommands;

DeclareTag( tagEditRouter, "EditRouter", "EditRouter traces" );

//+-------------------------------------------------------------------------
//
//  CEditRouter constructor and destructors
//
//--------------------------------------------------------------------------
CEditRouter::CEditRouter()
{
    _pInternalCmdTarget = NULL;
    _pHostCmdTarget = NULL;
    _fHostChecked = FALSE;
}

void
CEditRouter::Passivate()
{
    TraceTag( (tagEditRouter, "CEditRouter::Passivate: this [%x]", this ) );
    
    ReleaseInterface( _pInternalCmdTarget );
    _pInternalCmdTarget = NULL;
    ReleaseInterface( _pHostCmdTarget );
    _pHostCmdTarget = NULL;
    _fHostChecked = FALSE;
}

CEditRouter::~CEditRouter()
{
    Passivate();    // Dup call just in case it wasn't already done.
}

//+-------------------------------------------------------------------------
//
//  Method:     CEditRouter::ExecEditCommand
//
//  Synopsis:   Routes and editing command to the appropriate edit handler(s);
//              last parameter provides the context in which the edit operation
//              will be carried on by the edit handler.
//
// Notes: If the host provides an edit handler, then commands are routed there 
//        and creation of the default edit handler (Mshtmled) is deferred to later. 
//        In fact, the default handler may never be created, for instance, when
//        all commands are supported by the host handler.
//
//--------------------------------------------------------------------------
HRESULT
CEditRouter::ExecEditCommand(GUID *          pguidCmdGroup,
                             DWORD           nCmdID,
                             DWORD           nCmdexecopt,
                             VARIANTARG *    pvarargIn,
                             VARIANTARG *    pvarargOut,
                             IUnknown   *    punkContext,
                             CDoc *          pDoc )
{
    int                 idm;
    HRESULT             hr = OLECMDERR_E_NOTSUPPORTED;

    if ( punkContext == NULL || ! pDoc )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    punkContext->AddRef();
    
    // If there is no host to route to yet...
    if( _pHostCmdTarget == NULL && ! _fHostChecked )
    {
        hr = THR( SetHostEditHandler( punkContext, pDoc ));
        _fHostChecked = TRUE;
    }

    //
    //  Commands are described using a pair of CmdGroup and CmdID. IDMFromCmdID an IDM, which is
    //  the canonical form of the CmdGroup + CmdID pair. 
    //  If IDM is unknown it can only be sent to the host, since it may be a new command that the
    //  host can handle. In this case the original CmdGroup + CmdID is sent to the host. Otherwise
    //  the canonical form (IDM + CGID_MSHTML) is sent to the host.
    //  MshtmlEd is only sent the canonical form, since it will not be able to handle unknown commands.
    //
    idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);

    if (_pHostCmdTarget)
    {   //
        // Route command to the host edit handler first
        //
        
        if (idm == IDM_UNKNOWN)
            hr = THR_NOTRACE( _pHostCmdTarget->Exec(
                    pguidCmdGroup, 
                    nCmdID, 
                    nCmdexecopt, 
                    pvarargIn, pvarargOut));
        else
            hr = THR_NOTRACE( _pHostCmdTarget->Exec(
                    &CGID_MSHTML, 
                    idm, 
                    nCmdexecopt, 
                    pvarargIn, pvarargOut));
        
        if( !FAILED( hr ))
            goto Cleanup; // The host handled the command so we're done.
    }

    // Okay, the host didn't like that one. Lets send it to our internal editor
    // If we don't know what it is, bail...
    if (idm == IDM_UNKNOWN)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    // Dispatch to our internal handler based on the passed in punk
    if( _pInternalCmdTarget == NULL )
    {
        hr = SetInternalEditHandler( punkContext, pDoc, TRUE );  // If we get here, our only hope is the editor
        if( hr )
            goto Cleanup;       // outta here
    }

    if( pDoc->GetHTMLEditor(FALSE) )
    {   
        hr = THR_NOTRACE( _pInternalCmdTarget->Exec(
                &CGID_MSHTML, 
                idm, 
                nCmdexecopt, 
                pvarargIn, pvarargOut));
    }

Cleanup:

    // Temporary workaround for cycle problem with addref'd
    // IOleCommandTarget's in the editor
    Passivate();
    ReleaseInterface( punkContext );
    
    SRETURN(hr);
}

//+-------------------------------------------------------------------------
//
// Method:      CEditRouter::QueryStatusEditCommand
//
// Description: This method takes QueryStatus calls from ranges and from the
//              CDoc::PrivateQueryStatus() and determines if the editor can
//              handle the command or not.
//
//              The punkContext passed in is an IUnknown pointer to a range or
//              to a CMarkup.  We use this pointer to retrieve the correct
//              IOleCommandTarget from the editor.
//
// Arguments:   pguidCmdGroup = GUID of command group
//              cCmds = Number of commands
//              rgCmds = Array of commands
//              pcmdtext =
//
//              punkContext = Context of caller.  For a range, this will be
//               a pointer to a range.  If the call is coming from 
//               CDoc::QueryStatus, this will be a markup
//
//              pMarkup = If the caller is from CDoc::QueryStatus, this 
//               will contain the CMarkup pointer.
//
//              pDoc = Pointer to main CDoc
//+-------------------------------------------------------------------------
HRESULT
CEditRouter::QueryStatusEditCommand(GUID * pguidCmdGroup,
                                    ULONG cCmds,
                                    MSOCMD rgCmds[],
                                    MSOCMDTEXT * pcmdtext,
                                    IUnknown * punkContext,
                                    CMarkup *pMarkup,
                                    CDoc * pDoc )
{ 
    ULONG               idm;
    HRESULT             hr = S_OK;

    // TODO: raminh removed the assert below.  
    //
    // Which is curious, because we certainly are NOT handling the query status
    // of multiple commands in this code.  Think about re-enabling - johnthim
    //
    // Assert( cCmds == 1 );
    MSOCMD * pCmd = & rgCmds[ 0 ];
    MSOCMD newCommand;
    
    // If there is no host to route to yet...
    if( _pHostCmdTarget == NULL && ! _fHostChecked )
    {
        hr = THR_NOTRACE(SetHostEditHandler( punkContext, pDoc ));
        _fHostChecked = TRUE;
    }

    //
    //  Commands are described using a pair of CmdGroup and CmdID. IDMFromCmdID an IDM, which is
    //  the canonical form of the CmdGroup + CmdID pair. 
    //  If IDM is unknown it can only be sent to the host, since it may be a new command that the
    //  host can handle. In this case the original CmdGroup + CmdID is sent to the host. Otherwise
    //  the canonical form (IDM + CGID_MSHTML) is sent to the host.
    //  MshtmlEd is only sent the canonical form, since it will not be able to handle unknown commands.
    //
    idm = CBase::IDMFromCmdID(pguidCmdGroup,pCmd->cmdID);
    
    newCommand.cmdf = 0;    // just initialize (alexa)
    newCommand.cmdID = idm; // store the new Command Id.
    
    if (_pHostCmdTarget)
    {   //
        // Route command to the host edit handler first
        //
        
        if (idm == IDM_UNKNOWN)
            hr = _pHostCmdTarget->QueryStatus(
                    pguidCmdGroup, 
                    cCmds,
                    &newCommand ,
                    pcmdtext );
        else
            hr = _pHostCmdTarget->QueryStatus(
                    &CGID_MSHTML, 
                    cCmds, & newCommand, 
                    pcmdtext );
        
        if( ! FAILED( hr ))
            goto Cleanup; // The host handled the command so we're done.
    }

    // If we don't know what it is, bail...
    if (idm == IDM_UNKNOWN)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    // Dispatch to our internal handler
    if( _pInternalCmdTarget == NULL )
    {
        hr = SetInternalEditHandler( punkContext, pDoc, FALSE ); // Do NOT force creation of the editor
        if( hr )
            goto Cleanup;       // outta here
    }

    if( _pInternalCmdTarget == NULL ) // We are STILL null after last check...
    {
        switch( idm )
        {
            // PUT ALL THE COMMANDS THAT SHOULD BE ENABLED EVEN IF THERE ISN'T AN EDITOR TO CHECK WITH HERE
            case IDM_SELECTALL:
                if( !pMarkup || !pMarkup->_fFrameSet )
                    newCommand.cmdf = MSOCMDSTATE_UP;
                else
                    newCommand.cmdf = MSOCMDSTATE_DISABLED;
                break;
            
            default:
                newCommand.cmdf = MSOCMDSTATE_DISABLED;
        }
        goto Cleanup;
    }
    
    // _pInternalCmdTarget  can be null if an event fired that 
    // changed the document. sadness
    if( _pInternalCmdTarget && pDoc->GetHTMLEditor(FALSE) )
    {
        //
        // HACKHACK: Outlook98 assumes that we always have either justify left, center, or right.
        // With the addition of the justify none command, this assumption is no longer valid.  
        // So, we check justify none so that Outlook's assumption holds.
        //
        // TODO: expose fOutlook98 for the editor.  Check with johnbed. [ashrafm]
        //
        
        if (pDoc->_fOutlook98 
            && newCommand.cmdID == IDM_JUSTIFYLEFT)
        {
            newCommand.cmdID = IDM_JUSTIFYNONE; // try the common case first
            
            hr = THR_NOTRACE( _pInternalCmdTarget->QueryStatus(
                            &CGID_MSHTML, 
                            cCmds, & newCommand, 
                            pcmdtext ));
    
            if (hr || newCommand.cmdf == MSOCMDSTATE_DOWN)
                goto Cleanup; // done
    
            newCommand.cmdID = IDM_JUSTIFYLEFT; // now try left
        }
    
        hr = THR_NOTRACE( _pInternalCmdTarget->QueryStatus(
                    &CGID_MSHTML, 
                    cCmds, & newCommand, 
                    pcmdtext ));
    }

Cleanup:

    Passivate();
    
    if (hr == S_OK)
        pCmd->cmdf = newCommand.cmdf;

    SRETURN( hr );
}


//+-------------------------------------------------------------------------
//
//  Method:     CEditRouter::SetHostEditHandler
//
//  Synopsis:   Helper routine to get an IOleCommandTarget from the host 
//              (if any), where editing commands will be routed.
//--------------------------------------------------------------------------
HRESULT
CEditRouter::SetHostEditHandler(IUnknown * punkContext, CDoc * pDoc )
{
    IServiceProvider      * pServiceProvider = 0;
    VARIANTARG              varParamIn;
    HRESULT                 hr = S_FALSE;
    
    hr = pDoc->QueryInterface(  IID_IServiceProvider, 
                                (void**)&pServiceProvider);
    if (hr)
        goto Cleanup;

    hr = pServiceProvider->QueryService(SID_SEditCommandTarget, 
                                        IID_IOleCommandTarget,
                                        (void **) &_pHostCmdTarget);
    if (hr)
        goto Cleanup;

    V_VT(&varParamIn)      = VT_UNKNOWN;
    V_UNKNOWN(&varParamIn) = punkContext;
    hr = _pHostCmdTarget->Exec(&CGID_EditStateCommands, 
                                   IDM_CONTEXT, 0,
                                   &varParamIn, NULL);
    if (hr)
    {   //
        // Host will not be able to process edit commands properly, 
        // since it failed to handle EditStateCommand. Nullify HostEditHandler.
        //
        ClearInterface(&_pHostCmdTarget);
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pServiceProvider );

    RRETURN( hr );
}


HRESULT
CEditRouter::SetInternalEditHandler( 
    IUnknown *      punkContext , 
    CDoc *          pDoc,
    BOOL            fForceCreate )
{
    HRESULT         hr = S_OK;
    IHTMLEditor     *ped = NULL;
    IUnknown        *punk = NULL;
    IHTMLDocument   *pTest = NULL;
    BOOL            fRange;
    
    AssertSz( _pInternalCmdTarget == NULL , "CEditRouter::SetInternalEditHandler called when it already has one." );
    
    if( _pInternalCmdTarget != NULL )
        goto Cleanup;
        
    // See if we are being passed in a range as our context
    hr = punkContext->QueryInterface( IID_IHTMLDocument , (void **) &pTest );
    ReleaseInterface( pTest );
    fRange = (hr != S_OK);

    ped = pDoc->GetHTMLEditor( fRange ? TRUE : fForceCreate );
    if( ped == NULL )
    {
        hr = S_OK;
        _pInternalCmdTarget = NULL;
        goto Cleanup;
    }


#if DBG == 1
    if( fRange )   
    {
        ISegmentList * pSLTest = NULL;
        hr = THR( punkContext->QueryInterface( IID_ISegmentList, 
                                        (void **) &pSLTest ));
        AssertSz( !FAILED( hr ) , "CEditRouter punkContext is not castable to an ISegmentList" );
        ReleaseInterface( pSLTest );
    }
#endif // DBG == 1

    hr = THR( ped->GetCommandTarget( punkContext, &punk ));
    if( hr )
        goto Cleanup;

        
    hr = THR( punk->QueryInterface( IID_IOleCommandTarget, 
                                    (void **) &_pInternalCmdTarget ));
    if( hr )
        goto Cleanup;
   
Cleanup:
    ReleaseInterface( punk );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\dom.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DOMCOLL_HXX_
#define X_DOMCOLL_HXX_
#include "domcoll.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_COMMENT_HXX
#define X_COMMENT_HXX
#include "comment.hxx"
#endif

#ifndef X_EOBJECT_HXX
#define X_EOBJECT_HXX
#include "eobject.hxx"
#endif

#define _cxx_
#include "dom.hdl"

////////////////////////////////////////////////////////////////////////////////
//
// DOM Helper methods:
//
////////////////////////////////////////////////////////////////////////////////

static 
HRESULT 
CrackDOMNode ( IUnknown *pNode, CDOMTextNode**ppTextNode, CElement **ppElement, CMarkup * pWindowedMarkupContext )
{
    CMarkup *pMarkup; // Used to check if node is of type CDocument

    HRESULT hr = THR(pNode->QueryInterface(CLSID_CElement, (void **)ppElement));
    if (hr)
    {
        // If node supports Markup, it cant be CElement or CDOMTextNode & by elimination, it has to be CDocument
        hr = THR(pNode->QueryInterface(CLSID_CMarkup, (void **)&pMarkup));
        if (hr)
        {
            if (ppTextNode)
            {
                hr = THR(pNode->QueryInterface(CLSID_HTMLDOMTextNode, (void **)ppTextNode));
                if (!hr && (pWindowedMarkupContext != (*ppTextNode)->GetWindowedMarkupContext()))
                    hr = E_INVALIDARG;
            }
        }
        else 
        {
            *ppElement = pMarkup->Root();      // If CDocument, set element to root element
            if ( pWindowedMarkupContext != pMarkup->GetWindowedMarkupContext() )
                hr = E_INVALIDARG;
        }
    }
    else 
    {
        Assert( (*ppElement)->Tag() != ETAG_ROOT );
        if ( pWindowedMarkupContext != (*ppElement)->GetWindowedMarkupContext())
            hr = E_INVALIDARG;
    }

    RRETURN ( hr );
}

static 
HRESULT 
CrackDOMNodeVARIANT ( VARIANT *pVarNode, CDOMTextNode**ppTextNode, CElement **ppElement, CMarkup * pWindowedMarkupContext )
{
    HRESULT hr = S_OK;

    switch (V_VT(pVarNode))
    {
    case VT_DISPATCH:
    case VT_UNKNOWN:
        if (V_UNKNOWN(pVarNode))
        {
            // Element OR Text Node ??
            hr = THR(CrackDOMNode(V_UNKNOWN(pVarNode), ppTextNode, ppElement, pWindowedMarkupContext));
        }
        break;
    case VT_NULL:
    case VT_ERROR:
        hr = S_OK;
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }   
    RRETURN ( hr );
}

static
HRESULT
GetDOMInsertHelper ( CElement *pRefElement, CDOMTextNode *pRefTextNode, CMarkupPointer *pmkptrPos )
{
    HRESULT hr = E_UNEXPECTED;

    Assert ( pRefElement || pRefTextNode );
    Assert ( !(pRefElement && pRefTextNode ) );
    
    if ( pRefElement )
    {
        // Element Insert
        if (!pRefElement->IsInMarkup())
            goto Cleanup;

        hr = THR(pmkptrPos->MoveAdjacentToElement ( pRefElement, pRefElement->Tag() == ETAG_ROOT? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeBegin ));
        if ( hr )
           goto Cleanup;
    }
    else 
    {
        // Text Node Insert
        // Reposition the text node, then confirm we are it's parent
        CMarkupPointer *pmkpTextPtr = NULL;

        hr = THR(pRefTextNode->GetMarkupPointer ( &pmkpTextPtr ));
        if ( hr )
            goto Cleanup;
        hr = THR(pmkptrPos->MoveToPointer ( pmkpTextPtr ));
        if ( hr )
           goto Cleanup;
    }

Cleanup:
    RRETURN ( hr );
}


static 
HRESULT 
InsertDOMNodeHelper ( CElement *pNewElement, CDOMTextNode *pNewTextNode, CMarkupPointer *pmkptrTarget )
{
    HRESULT hr = S_OK;

    Assert ( pNewTextNode || pNewElement );

    if ( pNewElement )
    {

        CDoc *pDoc = pNewElement->Doc();

        // Insert/Move element with content
        if (pNewElement->IsInMarkup() && !pNewElement->IsNoScope()) 
        {
            CMarkupPointer mkptrStart(pDoc);
            CMarkupPointer mkptrEnd(pDoc);

            Assert(pNewElement->Tag() != ETAG_PARAM);
            hr = THR(pNewElement->GetMarkupPtrRange (&mkptrStart, &mkptrEnd) );
            if ( hr )
                goto Cleanup;

            hr = THR(pDoc->Move(&mkptrStart, &mkptrEnd, pmkptrTarget, MUS_DOMOPERATION));
        }
        else
        {
            if (pNewElement->IsInMarkup())
            {
                Assert(pNewElement->Tag() != ETAG_PARAM || !DYNCAST(CParamElement, pNewElement)->_pelObjParent);
                hr = THR(pDoc->RemoveElement(pNewElement, MUS_DOMOPERATION));
                if ( hr )
                    goto Cleanup;
            }
            else if (pNewElement->Tag() == ETAG_PARAM)
            {
                // remove <PARAM> from exisiting <OBJECT> if present, first
                CParamElement *pelParam = DYNCAST(CParamElement, pNewElement);
                if (pelParam->_pelObjParent)
                {
                    Assert(pelParam->_idxParam != -1);
                    pelParam->_pelObjParent->RemoveParam(pelParam);
                    Assert(pelParam->_idxParam == -1);
                    Assert(!pelParam->_pelObjParent);
                }
            }


            hr = THR(pDoc->InsertElement(pNewElement, pmkptrTarget, NULL, MUS_DOMOPERATION));
        }

        if (hr)
            goto Cleanup;
    }
    else
    {
        // Insert Text content
        hr = THR(pNewTextNode->MoveTo ( pmkptrTarget ));
        if (hr)
            goto Cleanup;       
    }

Cleanup:
    RRETURN(hr);
}

static 
HRESULT 
RemoveDOMNodeHelper ( CDoc *pDoc, CElement *pChildElement, CDOMTextNode *pChildTextNode )
{ 
    HRESULT hr = S_OK;
    CMarkup *pMarkupTarget = NULL;

    Assert ( pChildTextNode || pChildElement );

    if ( pChildTextNode )
    {
        // Removing a TextNode
        hr = THR(pChildTextNode->Remove());
    }
    else if (pChildElement->IsInMarkup())
    {
        // Removing an element
        if (!pChildElement->IsNoScope())
        {
            CMarkupPointer mkptrStart ( pDoc );
            CMarkupPointer mkptrEnd ( pDoc );
            CMarkupPointer mkptrTarget ( pDoc );

            hr = THR(pDoc->CreateMarkup(&pMarkupTarget, pChildElement->GetWindowedMarkupContext()));
            if ( hr )
                goto Cleanup;

            hr = THR( pMarkupTarget->SetOrphanedMarkup( TRUE ) );
            if( hr )
                goto Cleanup;

            hr = THR(mkptrTarget.MoveToContainer(pMarkupTarget,TRUE));
            if (hr)
                goto Cleanup;

            hr = THR(pChildElement->GetMarkupPtrRange (&mkptrStart, &mkptrEnd) );
            if ( hr )
                goto Cleanup;

            hr = THR(pDoc->Move(&mkptrStart, &mkptrEnd, &mkptrTarget, MUS_DOMOPERATION));
        }
        else
            hr = THR(pDoc->RemoveElement(pChildElement, MUS_DOMOPERATION));
    }

Cleanup:
    ReleaseInterface ( (IUnknown*)pMarkupTarget ); // Creating it addref'd it once
    RRETURN(hr);
}


static
HRESULT 
ReplaceDOMNodeHelper ( CDoc *pDoc, CElement *pTargetElement, CDOMTextNode *pTargetNode,
    CElement *pSourceElement, CDOMTextNode *pSourceTextNode )
{
    CMarkupPointer mkptrInsert ( pDoc );
    HRESULT hr;

    // Position ourselves in the right spot
    hr = THR(GetDOMInsertHelper ( pTargetElement, pTargetNode, &mkptrInsert ));
    if ( hr )
        goto Cleanup;

    mkptrInsert.SetGravity ( POINTER_GRAVITY_Left );

    {
        // Lock the markup, to prevent it from going away in case the entire contents are being removed.
        CMarkup::CLock MarkupLock(mkptrInsert.Markup());

        // Remove myself
        hr = THR(RemoveDOMNodeHelper ( pDoc, pTargetElement, pTargetNode ));
        if ( hr )
            goto Cleanup;

        // Insert the new element & all its content
        hr = THR(InsertDOMNodeHelper( pSourceElement, pSourceTextNode, &mkptrInsert ));
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

static
HRESULT
SwapDOMNodeHelper ( CDoc *pDoc, CElement *pElem, CDOMTextNode *pTextNode,
                   CElement *pElemSwap, CDOMTextNode *pTextNodeSwap )
{
    CMarkupPointer  mkptrThisInsert ( pDoc );
    CMarkupPointer  mkptrSwapInsert ( pDoc );
    HRESULT hr;

    // Position ourselves in the right spot
    if (!pElem || pElem->IsInMarkup())
    {
        hr = THR(GetDOMInsertHelper ( pElem, pTextNode, &mkptrThisInsert ));
        if (hr)
            goto Cleanup;
    }

    if (!pElemSwap || pElemSwap->IsInMarkup())
    {
        hr = THR(GetDOMInsertHelper ( pElemSwap, pTextNodeSwap, &mkptrSwapInsert ));
        if (hr)
            goto Cleanup;
    }

    // Lock the markup, to prevent it from going away in case the entire contents are being removed.
    if (mkptrSwapInsert.Markup())
        mkptrSwapInsert.Markup()->AddRef();

    // Insert the new element & all its content
    if (mkptrThisInsert.IsPositioned())
        hr = THR(InsertDOMNodeHelper( pElemSwap, pTextNodeSwap, &mkptrThisInsert ));
    else
        hr = THR(RemoveDOMNodeHelper(pDoc, pElemSwap, pTextNodeSwap));

    if ( hr )
        goto Cleanup;

    // Insert the new element & all its content
    if (mkptrSwapInsert.IsPositioned())
    {
        hr = THR(InsertDOMNodeHelper( pElem, pTextNode, &mkptrSwapInsert ));
        mkptrSwapInsert.Markup()->Release();
    }
    else
        hr = THR(RemoveDOMNodeHelper(pDoc, pElem, pTextNode));

Cleanup:
    RRETURN(hr);
}

static
HRESULT
CreateTextNode ( CDoc *pDoc, CMarkupPointer *pmkpTextEnd, long lTextID, CDOMTextNode **ppTextNode ) 
{                        
    CMarkupPointer *pmarkupWalkBegin = NULL;
    HRESULT hr = S_OK;

    Assert ( ppTextNode );
    Assert ( !(*ppTextNode) );

    if ( lTextID != 0 )
    {
        *ppTextNode = (CDOMTextNode *)pDoc->
            _HtPvPvDOMTextNodes.Lookup ( (void *)(DWORD_PTR)(lTextID<<4) );
    }

    if ( !(*ppTextNode) )
    {
        // Need to create a Text Node
        pmarkupWalkBegin =  new CMarkupPointer (pDoc); 
        if ( !pmarkupWalkBegin )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pmarkupWalkBegin->MoveToPointer ( pmkpTextEnd ));
        if ( hr )
            goto Cleanup;

        hr = THR(pmarkupWalkBegin->Left( TRUE, NULL, NULL, NULL, NULL, &lTextID));
        if ( hr )
            goto Cleanup;

        if ( lTextID == 0 )
        {
            hr = THR(pmarkupWalkBegin->SetTextIdentity(pmkpTextEnd, &lTextID));
            if ( hr )
                goto Cleanup;
        }

        // Stick to the text
        hr = THR(pmarkupWalkBegin->SetGravity (POINTER_GRAVITY_Right));
        if ( hr )
            goto Cleanup;   
        // Need to set Glue Also!
        
        Assert( lTextID != 0 );

        *ppTextNode = new CDOMTextNode ( lTextID, pDoc, pmarkupWalkBegin );
        if ( !*ppTextNode )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        // Now give ownership of this markup pointer to the text Node
        pmarkupWalkBegin = NULL;
        
        hr = THR(pDoc->_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(lTextID<<4), (void*)*ppTextNode ) );
        if ( hr )
            goto Cleanup;
    }
    else
    {
        (*ppTextNode)->AddRef();
    }


Cleanup:
    delete pmarkupWalkBegin; 
    RRETURN(hr);
}


static
HRESULT
GetPreviousHelper ( CDoc *pDoc, CMarkupPointer *pmarkupWalk, IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CTreeNode *pNodeLeft;
    MARKUP_CONTEXT_TYPE context;
    long lTextID;

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;
    
    hr = THR(pmarkupWalk->Left( FALSE, &context, &pNodeLeft, NULL, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    switch ( context )
    {
    case CONTEXT_TYPE_Text:
        {
            // Text Node
            CDOMTextNode *pTextNode = NULL;

            // If we find text we ccannot have left the scope of our parent
            hr = THR(CreateTextNode (pDoc, pmarkupWalk, lTextID, 
                &pTextNode ));
            if ( hr )
                goto Cleanup;

            hr = THR ( pTextNode->QueryInterface ( IID_IHTMLDOMNode, (void **)ppNode ) );
            if ( hr )
                goto Cleanup;
            pTextNode->Release();
        }
        break;

    case CONTEXT_TYPE_EnterScope:
    case CONTEXT_TYPE_NoScope:
        // Return Disp to Element
        hr = THR(pNodeLeft->GetElementInterface ( IID_IHTMLDOMNode, (void **) ppNode  ));
        if ( hr )
            goto Cleanup;
        break;

    case CONTEXT_TYPE_ExitScope:
    case CONTEXT_TYPE_None:
        break;

    default:
        Assert(FALSE); // Should never happen
        break;
    }
Cleanup:
    RRETURN(hr);
}


static
HRESULT
GetNextHelper ( CDoc *pDoc, CMarkupPointer *pmarkupWalk, IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CTreeNode           *pnodeRight;
    MARKUP_CONTEXT_TYPE context;
    long lTextID;

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;
   
    hr = THR( pmarkupWalk->Right( TRUE, &context, &pnodeRight, NULL, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    switch ( context )
    {
    case CONTEXT_TYPE_Text:
        {
            // Text Node
            CDOMTextNode *pTextNode = NULL;

            // If we find text we ccannot have left the scope of our parent
            hr = THR(CreateTextNode (pDoc, pmarkupWalk, lTextID, 
                &pTextNode ));
            if ( hr )
                goto Cleanup;

            hr = THR ( pTextNode->QueryInterface ( IID_IHTMLDOMNode, (void **)ppNode ) );
            if ( hr )
                goto Cleanup;
            pTextNode->Release();
        }
        break;

    case CONTEXT_TYPE_EnterScope:
    case CONTEXT_TYPE_NoScope:
        // Return Disp to Element
        hr = THR(pnodeRight->GetElementInterface ( IID_IHTMLDOMNode, (void **) ppNode  ));
        if ( hr )
            goto Cleanup;
        break;

    case CONTEXT_TYPE_ExitScope:
    case CONTEXT_TYPE_None:
        break;

    default:
        Assert(FALSE); // Should never happen
        break;
    }
Cleanup:
    RRETURN(hr);
}

#if DBG == 1
static 
BOOL 
IsRootOnlyIfDocument(IHTMLDOMNode *pNode, CElement *pElement)
{
    HRESULT     hr;
    CMarkup *   pMarkup;

    if( pElement && pElement->Tag() == ETAG_ROOT )
    {
        hr = THR(pNode->QueryInterface(CLSID_CMarkup, (void **)&pMarkup));

        if( hr )  
        {
            return FALSE;
        }
    }

    return TRUE;
}
#endif

static
HRESULT
CurrentScope ( CMarkupPointer *pMkpPtr, IHTMLElement ** ppElemCurrent, CTreeNode ** ppNode )
{
    HRESULT     hr = S_OK;
    CTreeNode * pTreeNode = NULL;

    Assert( (!ppElemCurrent && ppNode) || (ppElemCurrent && !ppNode) );

    pMkpPtr->Validate();
    
    if (pMkpPtr->IsPositioned())
    {
        pTreeNode = pMkpPtr->Branch();
        if (pTreeNode->Tag() == ETAG_ROOT && !pTreeNode->Element()->GetMarkup()->HasDocument())
            pTreeNode = NULL;

    }

    if (ppNode)
    {
        *ppNode = pTreeNode;
        goto Cleanup;
    }
    else
    {
        Assert(ppElemCurrent);

        *ppElemCurrent = NULL;

        if (pTreeNode)
        {
            hr = THR(
                pTreeNode->GetElementInterface( IID_IHTMLElement, (void **) ppElemCurrent ) );

            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );
}

static
HRESULT
ParentNodeHelper( CTreeNode *pNode, IHTMLDOMNode **pparentNode )
{
    HRESULT     hr = S_OK;
    CElement *  pElement;
    CMarkup *   pMarkup;
    CDocument * pDocument;
    BOOL        fDocumentPresent;

    *pparentNode = NULL;

    if (pNode->Tag() == ETAG_ROOT)
    {
        pElement = pNode->Element();
        pMarkup = pElement->GetMarkup();
        Assert(pMarkup);
        fDocumentPresent = pMarkup->HasDocument();

        hr = THR(pMarkup->EnsureDocument(&pDocument));
        if ( hr )
            goto Cleanup;

        Assert(pDocument);
        if (!fDocumentPresent)
            pDocument->_lnodeType = 11;

        hr = THR(pDocument->QueryInterface( IID_IHTMLDOMNode, (void**) pparentNode ));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        hr = THR(pNode->GetElementInterface ( IID_IHTMLDOMNode, (void**) pparentNode ));
        if ( hr )
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

static
HRESULT
ScanText(CDoc *pDoc, CMarkupPointer *pMkpStart, CMarkupPointer *pMkpTxtEnd, CMarkupPointer *pMkpEnd)
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    long lTextID;
    BOOL fEnterText = FALSE;
    CDOMTextNode *pTextNode;

    do
    {
        hr = THR(pMkpTxtEnd->Right(TRUE, &context, NULL, NULL, NULL, &lTextID));
        if (hr)
            goto Cleanup;

        if (lTextID)
        {
            Assert(context == CONTEXT_TYPE_Text);
            if (!fEnterText)
            {
                hr = THR(pMkpTxtEnd->Right(FALSE, &context, NULL, NULL, NULL, NULL));
                if (hr)
                    goto Cleanup;
                
                if (context == CONTEXT_TYPE_Text)
                    fEnterText = TRUE;
            }

            if (fEnterText)
            {
                pTextNode = (CDOMTextNode *)pDoc->_HtPvPvDOMTextNodes.Lookup((void *)(DWORD_PTR)(lTextID<<4));
                pTextNode->TearoffTextNode(pMkpStart, pMkpTxtEnd);
            }
        }
        else if (fEnterText && (context != CONTEXT_TYPE_Text))
            fEnterText = FALSE;

        hr = THR(pMkpStart->MoveToPointer(pMkpTxtEnd));
        if (hr)
            goto Cleanup;

    }
    while(pMkpTxtEnd->IsLeftOf(pMkpEnd));

Cleanup:
    RRETURN(hr);
}

static
HRESULT
OwnerDocHelper(IDispatch **ppretdoc, CDOMTextNode *pDOMTextNode, CElement *pElement)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;
    CDocument *pDocument = NULL;

    Assert(!!pDOMTextNode ^ !!pElement);

    if( !ppretdoc )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppretdoc = NULL;

    pMarkup = pDOMTextNode? pDOMTextNode->GetWindowedMarkupContext() : pElement->GetWindowedMarkupContext();

    Assert( pMarkup );
    if ( ! pMarkup )
    {    
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if( pMarkup->HasDocument() )
    {
        pDocument = pMarkup->Document();
        Assert(pDocument);
        Assert(pDocument->_lnodeType == 9);
        hr = THR(pDocument->QueryInterface(IID_IDispatch, (void **)ppretdoc));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// IHTMLDOMTextNode methods:
//
////////////////////////////////////////////////////////////////////////////////

MtDefine(CDOMTextNode, ObjectModel, "CDOMTextNode")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CDOMTextNode::s_classdesc =
{
    &CLSID_HTMLDOMTextNode,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDOMTextNode,         // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

HRESULT
CDOMTextNode::PrivateQueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;

    if ( !ppv )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLDOMTextNode2, NULL)
        QI_TEAROFF(this, IHTMLDOMTextNode, NULL)
        QI_TEAROFF(this, IHTMLDOMNode, NULL)
        QI_TEAROFF(this, IHTMLDOMNode2, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    }

    if ( iid == CLSID_HTMLDOMTextNode )
    {
        *ppv = (void*)this;
        return S_OK;
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
Cleanup:
    return hr;
}

HRESULT
CDOMTextNode::UpdateTextID( CMarkupPointer *pMkpPtr )
{
    HRESULT hr = S_OK;
    long lNewTextID;

    hr = THR(_pMkpPtr->SetTextIdentity(pMkpPtr, &lNewTextID));
    if ( hr )
        goto Cleanup;

    // Update the Doc Text Node Ptr Lookup
    _pDoc->_HtPvPvDOMTextNodes.Remove ( (void *)(DWORD_PTR)(_lTextID<<4) );
    _lTextID = lNewTextID;
    hr = THR(_pDoc->_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(_lTextID<<4), (void*)this ) );
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );

}

HRESULT
CDOMTextNode::MoveToOffset( long loffset, CMarkupPointer *pMkpPtr, CMarkupPointer *pMkpEnd )
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    long lTextID;
    long lMove = loffset;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, pMkpEnd ) );
    if ( hr )
        goto Cleanup;

    pMkpEnd->SetGravity(POINTER_GRAVITY_Right);

    hr = THR(pMkpPtr->MoveToPointer(_pMkpPtr));
    if( hr )
        goto Cleanup;

    if( loffset )
    {
        hr = THR( pMkpPtr->Right( TRUE, &context, NULL, &lMove, NULL, &lTextID));
        if( hr )
            goto Cleanup;

        Assert( lTextID == _lTextID );
        Assert( context == CONTEXT_TYPE_Text );

        if ( loffset != lMove )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CDOMTextNode::InsertTextHelper( CMarkupPointer *pMkpPtr, BSTR bstrstring, long loffset)
{
    HRESULT hr = S_OK;
    
    // If loffset=0, _pMkpPtr is affected by remove / insert, & should not become unpositioned
    if(!loffset)
        _pMkpPtr->SetGravity( POINTER_GRAVITY_Left );

    pMkpPtr->SetGravity ( POINTER_GRAVITY_Right );

    hr = THR( _pDoc->InsertText( pMkpPtr, bstrstring, -1, MUS_DOMOPERATION ) );
    if ( hr )
        goto Cleanup;

    // Restore the proper gravity, so that new TextID can be set later.
    _pMkpPtr->SetGravity( POINTER_GRAVITY_Right );

Cleanup:
    RRETURN( hr );
}

HRESULT
CDOMTextNode::RemoveTextHelper(CMarkupPointer *pMkpStart, long lCount, long loffset)
{
    HRESULT hr = S_OK;
    CMarkupPointer MkpRight(_pDoc);

    if( lCount )
    {
        hr = THR(MkpRight.MoveToPointer(pMkpStart));
        if( hr )
            goto Cleanup;

        hr = THR( MkpRight.Right( TRUE, NULL, NULL, &lCount, NULL, NULL) );
        if( hr )
            goto Cleanup;
    
        // If loffset=0, _pMkpPtr is affected by remove / insert, & should not become unpositioned
        if(!loffset)
            _pMkpPtr->SetGravity ( POINTER_GRAVITY_Left );

        // Remove the Text
        hr = THR(_pDoc->Remove ( pMkpStart,  &MkpRight, MUS_DOMOPERATION ));
        if ( hr )
            goto Cleanup;

    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CDOMTextNode::get_data(BSTR *pbstrData)
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    long lCharCount = -1;
    long lTextID;

    if ( !pbstrData )
        goto Cleanup;

    *pbstrData = NULL;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer * )NULL ) );
    if ( hr )
        goto Cleanup;

    // Walk right (hopefully) over text, inital pass, don't move just get count of chars
    hr = THR( _pMkpPtr->Right( FALSE, &context, NULL, &lCharCount, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    Assert ( lTextID == _lTextID );

    if ( context == CONTEXT_TYPE_Text )
    {
        // Alloc memory
        hr = FormsAllocStringLen ( NULL, lCharCount, pbstrData );
        if ( hr )
            goto Cleanup;
        hr = THR( _pMkpPtr->Right( FALSE, &context, NULL, &lCharCount, *pbstrData, &lTextID));
        if ( hr )
            goto Cleanup;
    }  

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

CDOMTextNode::CDOMTextNode ( long lTextID, CDoc *pDoc, CMarkupPointer *pmkptr )
{ 
    Assert(pDoc);
    Assert(pmkptr);
    _pDoc = pDoc ; 
    _lTextID = lTextID ;
    _pDoc->AddRef();                // Due to lookaside table
    _pMkpPtr = pmkptr;
    // markup ptr will manage Markup in which text node is in.
    _pMkpPtr->SetKeepMarkupAlive(TRUE);
    // Add glue so that tree services can manage ptr movement
    // between markups automatically during splice operations
    _pMkpPtr->SetCling(TRUE);
}


CDOMTextNode::~CDOMTextNode()
{

    // tidy up lookaside
    _pDoc->_HtPvPvDOMTextNodes.Remove ( (void *)(DWORD_PTR)(_lTextID<<4) );

    // Tidy up markup ptr/markup
    _pMkpPtr->SetKeepMarkupAlive(FALSE);
    _pMkpPtr->SetCling(FALSE);

    _pDoc->Release();
    delete _pMkpPtr;
}


HRESULT STDMETHODCALLTYPE
CDOMTextNode::IsEqualObject(IUnknown * pUnk)
{
    HRESULT         hr;
    IUnknown   *    pUnkThis = NULL;
    CDOMTextNode *  pTargetTextNode;

    if (!pUnk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Test standard COM identity first
    hr = THR_NOTRACE(QueryInterface(IID_IUnknown, (void **)&pUnkThis));
    if (hr)
        goto Cleanup;

    if (pUnk == pUnkThis)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // Do the dodgy CLSID QI
    hr = THR(pUnk->QueryInterface(CLSID_HTMLDOMTextNode, (void**)&pTargetTextNode));
    if ( hr )
        goto Cleanup;

    hr = (_lTextID == pTargetTextNode->_lTextID) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pUnkThis);
    RRETURN1(hr, S_FALSE);
}

HRESULT
CDOMTextNode::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeCloned)
{
    HRESULT hr;
    CMarkupPointer mkpRight (_pDoc );
    CMarkupPointer mkpTarget (_pDoc );
    CMarkup *pMarkup = NULL;
    CMarkupPointer *pmkpStart = NULL;

    if ( !ppNodeCloned )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(_pDoc->CreateMarkup ( &pMarkup, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpRight ) );
    if ( hr )
        goto Cleanup;

    hr = THR(mkpTarget.MoveToContainer( pMarkup, TRUE ) );
    if ( hr )
        goto Cleanup;

    mkpTarget.SetGravity ( POINTER_GRAVITY_Right );
    
    // Copy the markup across to the new markup container
    // (mkpTarget gets moved to the right of the text as a result)
    hr = THR( _pDoc->Copy ( _pMkpPtr, &mkpRight, &mkpTarget, MUS_DOMOPERATION ) );  
    if ( hr )
        goto Cleanup;

    // Create the new text node markup pointer - will be handed off to text node
    pmkpStart = new CMarkupPointer ( _pDoc );
    if ( !pmkpStart )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pmkpStart->MoveToContainer( pMarkup, TRUE ) );
    if ( hr )
        goto Cleanup;

    // Create the new text node
    hr = THR(_pDoc->CreateDOMTextNodeHelper(pmkpStart, &mkpTarget, ppNodeCloned));
    if ( hr )
        goto Cleanup;

    pmkpStart = NULL; // Text Node owns the pointer

Cleanup:
    ReleaseInterface ( (IUnknown*)pMarkup ); // Text node addref'ed it
    delete pmkpStart;
    RRETURN( hr );
}

HRESULT
CDOMTextNode::splitText(long lOffset, IHTMLDOMNode**ppRetNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpRight (_pDoc);
    CMarkupPointer mkpEnd (_pDoc);
    CMarkupPointer *pmkpStart = NULL;
    long lMove = lOffset;
    long lTextID;
    
    if ( lOffset < 0 || !ppRetNode)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    // Split the text at the given offset to make a new text node, return the new text node

    pmkpStart = new CMarkupPointer ( _pDoc );
    if ( !pmkpStart )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpRight ) );
    if ( hr )
        goto Cleanup;

    hr = THR(pmkpStart->MoveToPointer ( _pMkpPtr ));
    if ( hr )
        goto Cleanup;

    lMove = lOffset;

    hr = THR(pmkpStart->Right ( TRUE, NULL, NULL, &lOffset, NULL, &lTextID ));
    if ( hr )
        goto Cleanup;

    // Position at point of split 
    hr = THR(mkpEnd.MoveToPointer (pmkpStart));
    if ( hr )
        goto Cleanup;

    // If my TextID changed, I moved outside my text node
    if ( lOffset != lMove )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Create the new text node
    hr = THR(_pDoc->CreateDOMTextNodeHelper(pmkpStart, &mkpRight, ppRetNode));
    if ( hr )
        goto Cleanup;

    pmkpStart = NULL; // New Text Node owns pointer

    // Re-Id the split text for original text node
    hr = THR(_pMkpPtr->SetTextIdentity(&mkpEnd, &lTextID));
    if ( hr )
        goto Cleanup;

    // Update the Doc Text Node Ptr Lookup
    _pDoc->_HtPvPvDOMTextNodes.Remove ( (void *)(DWORD_PTR)(_lTextID<<4) );
    _lTextID = lTextID;
    hr = THR(_pDoc->_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(_lTextID<<4), (void*)this ) );
    if ( hr )
        goto Cleanup;

Cleanup:
    delete pmkpStart;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::put_data(BSTR bstrData)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpRight (_pDoc);
    CMarkupPointer mkpStart (_pDoc);

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpRight ) );
    if ( hr )
        goto Cleanup;

    Assert(_pMkpPtr->Cling());

    // Set left gravity so that _pMkpPtr is not unpositioned, due to remove.
    _pMkpPtr->SetGravity ( POINTER_GRAVITY_Left );

    // Remove the old Text
    hr = THR(_pDoc->Remove ( _pMkpPtr,  &mkpRight, MUS_DOMOPERATION ));
    if ( hr )
        goto Cleanup;

    // OK, old text is out, put the new stuff in
    hr = THR(mkpStart.MoveToPointer ( _pMkpPtr ));
    if ( hr )
        goto Cleanup;
    
    // Set gravity of mkpStart to right, so that it moves to the end when text is inserted
    // at _pMkpPtr, which remains at the beginning due to left gravity.
    mkpStart.SetGravity(POINTER_GRAVITY_Right);

    hr = THR( _pDoc->InsertText( _pMkpPtr, bstrData, -1, MUS_DOMOPERATION ) );
    if ( hr )
        goto Cleanup;

    // restore gravity of _pMkpPtr to right
    _pMkpPtr->SetGravity(POINTER_GRAVITY_Right);

    hr = THR(UpdateTextID(&mkpStart));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::toString(BSTR *pbstrData)
{
    RRETURN(SetErrorInfo(get_data(pbstrData)));
}

HRESULT
CDOMTextNode::get_length(long *pLength)
{
    HRESULT hr = S_OK;
    long lCharCount = -1;
    long lTextID;
    MARKUP_CONTEXT_TYPE context;

    if ( !pLength )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = 0;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ) );
    if ( hr )
        goto Cleanup;

    // Walk right (hopefully) over text, inital pass, don't move just get count of chars
    hr = THR( _pMkpPtr->Right( FALSE, &context, NULL, &lCharCount, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    Assert ( lTextID == _lTextID );

    if ( context == CONTEXT_TYPE_Text )
    {
        *pLength = lCharCount;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::get_nodeType(long *pnodeType)
{
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pnodeType = 3; // DOM_TEXTNODE
Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::get_nodeName(BSTR *pbstrNodeName)
{
    HRESULT hr = S_OK;
    if (!pbstrNodeName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrNodeName = NULL;
    
    hr = THR(FormsAllocString ( _T("#text"), pbstrNodeName ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;
    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    pvarValue->vt = VT_BSTR;

    hr = THR(get_data(&V_BSTR(pvarValue)));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::put_nodeValue(VARIANT varValue)
{
    HRESULT hr = S_OK;
    CVariant varBSTRValue;

    hr = THR(varBSTRValue.CoerceVariantArg ( &varValue, VT_BSTR ));
    if ( hr )
        goto Cleanup;

    hr = THR( put_data ( V_BSTR((VARIANT *)&varBSTRValue)));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_firstChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CDOMTextNode::get_lastChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CDOMTextNode::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( _pDoc );

    // Move the markup pointer adjacent to the Text
    hr = THR(_pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ));
    if ( hr )
        goto Cleanup;

    hr = THR(markupWalk.MoveToPointer(_pMkpPtr));
    if ( hr )
        goto Cleanup;

    hr = THR(GetPreviousHelper ( _pDoc, &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( _pDoc );

    // Move the markup pointer adjacent to the Text
    hr = THR(_pMkpPtr->FindTextIdentity ( _lTextID, &markupWalk ));
    if ( hr )
        goto Cleanup;

    hr = THR(GetNextHelper ( _pDoc, &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::get_parentNode(IHTMLDOMNode **pparentNode)
{
    HRESULT             hr = S_OK;
    CTreeNode *         pNode;

    if (!pparentNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pparentNode = NULL;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ) );
    if ( hr )
        goto Cleanup;

    hr = CurrentScope(_pMkpPtr, NULL, &pNode);

    if ( hr )
        goto Cleanup;

    if (!pNode) 
    {
        goto Cleanup;
    }

    hr = THR(ParentNodeHelper(pNode, pparentNode));
    if ( hr )
        goto Cleanup;


Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::hasChildNodes(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

CDOMChildrenCollection *
CDOMTextNode::EnsureDOMChildrenCollectionPtr ( )
{
    CDOMChildrenCollection *pDOMPtr = NULL;
    GetPointerAt ( FindAAIndex ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,CAttrValue::AA_Internal ),
        (void **)&pDOMPtr );
    if ( !pDOMPtr )
    {
        pDOMPtr = new CDOMChildrenCollection ( this, FALSE /* fIsElement */ );
        if ( pDOMPtr )
        {
            AddPointer ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,
                (void *)pDOMPtr,
                CAttrValue::AA_Internal );
        }
    }
    else
    {
        pDOMPtr->AddRef();
    }
    return pDOMPtr;
}


HRESULT
CDOMTextNode::get_childNodes(IDispatch **ppChildCollection)
{
    HRESULT hr = S_OK;
    CDOMChildrenCollection *pChildren;

    if ( !ppChildCollection )
        goto Cleanup;

    *ppChildCollection = NULL;

    pChildren = EnsureDOMChildrenCollectionPtr();
    if ( !pChildren )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(pChildren->QueryInterface (IID_IDispatch,(void **)ppChildCollection));
    if ( hr )
        goto Cleanup;

    pChildren->Release(); // Lifetime is controlled by extrenal ref.

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_attributes(IDispatch **ppAttrCollection)
{
    HRESULT hr = S_OK;
    if (!ppAttrCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppAttrCollection = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::removeNode(VARIANT_BOOL fDeep,IHTMLDOMNode** ppnewNode)
{
    HRESULT hr = THR ( Remove () );
    if ( hr )
        goto Cleanup;

    if ( ppnewNode )
    {
        hr = THR(QueryInterface (IID_IHTMLDOMNode, (void**)ppnewNode ));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT 
CDOMTextNode::replaceNode(IHTMLDOMNode *pNodeReplace, IHTMLDOMNode **ppNodeReplaced)
{
    HRESULT hr;
    CDOMTextNode *pNewTextNode = NULL;
    CElement *pNewElement = NULL;

    if ( ppNodeReplaced )
        *ppNodeReplaced = NULL;

    if ( !pNodeReplace )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeReplace, &pNewTextNode, &pNewElement, GetWindowedMarkupContext()));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeReplace, pNewElement));

    hr = THR(ReplaceDOMNodeHelper ( _pDoc, NULL, this, pNewElement, pNewTextNode ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeReplaced )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeReplaced));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::swapNode(IHTMLDOMNode *pNodeSwap, IHTMLDOMNode **ppNodeSwapped)
{
    CElement *      pSwapElement = NULL;
    CDOMTextNode *  pSwapText = NULL;
    HRESULT         hr;

    if ( ppNodeSwapped )
        *ppNodeSwapped = NULL;

    if ( !pNodeSwap )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeSwap, &pSwapText, &pSwapElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeSwap, pSwapElement));

    hr = THR (SwapDOMNodeHelper ( _pDoc, NULL, this, pSwapElement, pSwapText ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeSwapped )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeSwapped));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}

HRESULT
CDOMTextNode::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}

HRESULT
CDOMTextNode::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, 
                           IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}

HRESULT
CDOMTextNode::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}


HRESULT 
CDOMTextNode::GetMarkupPointer( CMarkupPointer **ppMkp )
{
    HRESULT hr;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ) );
    if ( hr )
        goto Cleanup;

    *ppMkp = _pMkpPtr;

Cleanup:
    RRETURN(hr);
}

HRESULT
CDOMTextNode::Remove ( void )
{
    // Move it into it's own Markup container
    HRESULT hr;
    CMarkup *pMarkup = NULL;
    CMarkupPointer mkpPtr (_pDoc);

    hr = THR( _pDoc->CreateMarkup( &pMarkup, GetWindowedMarkupContext() ) );
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    hr = THR(mkpPtr.MoveToContainer( pMarkup, TRUE ) );
    if ( hr )
        goto Cleanup;

    hr = THR(MoveTo ( &mkpPtr ));
    if ( hr )
        goto Cleanup;


Cleanup:
    // Leave markup refcount at 1, text node is keeping it alive
    ReleaseInterface ( (IUnknown*)pMarkup );
    RRETURN(hr);
}

HRESULT 
CDOMTextNode::MoveTo ( CMarkupPointer *pmkptrTarget )
{
    HRESULT         hr;
    CMarkupPointer  mkpEnd(_pDoc);
    long            lCount;

    hr = THR(get_length(&lCount));
    if ( hr )
        goto Cleanup;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpEnd ) );
    if ( hr )
        goto Cleanup;

    pmkptrTarget->SetGravity ( POINTER_GRAVITY_Left );

    // should have right gravity, which with cling will move it also along with text
    Assert(_pMkpPtr->Gravity());    
    Assert(_pMkpPtr->Cling());    
    hr = THR(_pDoc->Move ( _pMkpPtr, &mkpEnd, pmkptrTarget, MUS_DOMOPERATION )); 

Cleanup:
    RRETURN(hr);
}

inline CMarkup *
CDOMTextNode::GetWindowedMarkupContext()
{ 
    return _pMkpPtr->Markup()->GetWindowedMarkupContext();
}

// IHTMLDOMTextNode2 methods

HRESULT
CDOMTextNode::substringData (long loffset, long lCount, BSTR* pbstrsubString)
{
    HRESULT hr = E_POINTER;
    long lMove = lCount;
    CMarkupPointer mkpptr(_pDoc);
    CMarkupPointer mkpend(_pDoc);
    BSTR bstrTemp;

    if ( !pbstrsubString )
        goto Cleanup;

    if ( lCount < 0 || loffset < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pbstrsubString = NULL;

    hr = THR(MoveToOffset(loffset, &mkpptr, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = FormsAllocStringLen( NULL, lCount, pbstrsubString );
    if ( hr )
        goto Cleanup;

    hr = THR( mkpptr.Right( FALSE, NULL, NULL, &lMove, *pbstrsubString, NULL) );
    if ( hr )
        goto Cleanup;

    if(lMove != lCount)
    {
        Assert(lMove < lCount);
        hr = FormsAllocStringLen(*pbstrsubString, lMove, &bstrTemp );
        SysFreeString(*pbstrsubString);
        *pbstrsubString = bstrTemp;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::appendData (BSTR bstrstring)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpptr(_pDoc);

    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpptr ) );
    if ( hr )
        goto Cleanup;

    hr = THR(InsertTextHelper(&mkpptr, bstrstring, -1));
    if( hr )
        goto Cleanup;

    hr = THR(UpdateTextID(&mkpptr));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::insertData (long loffset, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpptr(_pDoc);
    CMarkupPointer mkpend(_pDoc);

    if ( loffset < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(MoveToOffset(loffset, &mkpptr, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = THR(InsertTextHelper(&mkpptr, bstrstring, loffset));
    if( hr )
        goto Cleanup;

    hr = THR(UpdateTextID(&mkpend));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::deleteData (long loffset, long lCount)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpStart (_pDoc);
    CMarkupPointer mkpend (_pDoc);

    if( !lCount )
        goto Cleanup;

    if( loffset < 0 || lCount < 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(MoveToOffset(loffset, &mkpStart, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = THR(RemoveTextHelper(&mkpStart, lCount, loffset));
    if ( hr )
        goto Cleanup;
    
    _pMkpPtr->SetGravity(POINTER_GRAVITY_Right);

    hr = THR(UpdateTextID(&mkpend));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::replaceData (long loffset, long lCount, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpStart (_pDoc);
    CMarkupPointer mkpend (_pDoc);

    if( loffset < 0 || lCount < 0 )
        goto Cleanup;

    hr = THR(MoveToOffset(loffset, &mkpStart, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = THR(RemoveTextHelper(&mkpStart, lCount, loffset));
    if ( hr )
        goto Cleanup;

    hr = THR(InsertTextHelper(&mkpStart, bstrstring, loffset));
    if( hr )
        goto Cleanup;

    hr = THR(UpdateTextID(&mkpend));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_ownerDocument(IDispatch **ppretdoc)
{
    return OwnerDocHelper(ppretdoc, this, NULL);
}

HRESULT
CDOMTextNode::TearoffTextNode(CMarkupPointer *pMkpStart, CMarkupPointer *pMkpEnd)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup = NULL;
    CMarkupPointer mkpEndPtr(_pDoc);

    hr = THR(_pDoc->CreateMarkup(&pMarkup, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->SetOrphanedMarkup(TRUE));
    if (hr)
        goto Cleanup;

    hr = THR(mkpEndPtr.MoveToContainer(pMarkup, TRUE));
    if (hr)
        goto Cleanup;

    mkpEndPtr.SetGravity(POINTER_GRAVITY_Right);

    // should have right gravity, which with cling will move it also along with text
    Assert(_pMkpPtr->Gravity());    
    Assert(_pMkpPtr->Cling());    
    Assert(!pMkpEnd->Cling());    
    hr = THR(_pDoc->Move(_pMkpPtr, pMkpEnd, &mkpEndPtr, MUS_DOMOPERATION)); 
    if (hr)
        goto Cleanup;
    
    Assert(!pMkpStart->Gravity());    
    Assert(pMkpStart->IsEqualTo(pMkpEnd));
    Assert(_pMkpPtr->IsLeftOf(&mkpEndPtr));
    
    pMkpEnd->SetGravity(POINTER_GRAVITY_Right);

    Assert(_pMkpPtr->Gravity());    
    Assert(_pMkpPtr->Cling());    
    hr = THR(_pDoc->Copy(_pMkpPtr, &mkpEndPtr, pMkpEnd, MUS_DOMOPERATION));  
    if (hr)
        goto Cleanup;

    Assert(pMkpStart->IsLeftOf(pMkpEnd));

Cleanup:
    ReleaseInterface((IUnknown*)pMarkup); // Text node addref'ed it
    RRETURN(hr);

}

////////////////////////////////////////////////////////////////////////////////
//
// IHTMLDOMAttribute methods:
//
////////////////////////////////////////////////////////////////////////////////

MtDefine(CAttribute, ObjectModel, "CAttribute")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAttribute::s_classdesc =
{
    &CLSID_HTMLDOMAttribute,        // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDOMAttribute,         // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CAttribute::CAttribute(const PROPERTYDESC *pPropDesc, DISPID dispid, CElement *pElem, CDocument *pDocument)
{
    _pPropDesc = pPropDesc;
    _dispid = dispid;
    _pElem = pElem;
    if (pElem)
        pElem->SubAddRef();
    _pDocument = pDocument;    
    if (_pDocument)
    {
        _pDocument->SubAddRef();    
        _pMarkup = pDocument->Markup();
    }
    if (_pMarkup)
        _pMarkup->SubAddRef();
}

CAttribute::~CAttribute()
{
    if(_pElem)
        _pElem->SubRelease();
    if(_pMarkup)
        _pMarkup->SubRelease();
    if(_pDocument)
        _pDocument->SubRelease();
}

HRESULT
CAttribute::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLDOMAttribute, NULL)
        QI_TEAROFF(this, IHTMLDOMAttribute2, NULL)
    default:
        if (iid == CLSID_CAttribute)
        {
            *ppv = this;    // Weak ref
            return S_OK;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//
// Attribute helpers
//

static
HRESULT
GetIndexHelper(LPTSTR pchName, AAINDEX *paaIdx, AAINDEX *pvaaIdx, DISPID *pdispid, PROPERTYDESC **ppPropDesc, CElement *pElement, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    Assert(pchName && paaIdx && pdispid && ppPropDesc && pElement);

    *ppPropDesc = (PROPERTYDESC *)pElement->FindPropDescForName(pchName);
    
    if(!*ppPropDesc)
    {
        hr = THR(pElement->GetExpandoDISPID(pchName, pdispid, dwFlags));
        if (hr)
            goto Cleanup;
    }
    else
    {
        *pdispid = (*ppPropDesc)->GetDispid();
    }

    Assert(*pdispid);

    *paaIdx = pElement->FindAAIndex(*pdispid, CAttrValue::AA_DOMAttribute);

    if (pvaaIdx)
        *pvaaIdx = pElement->FindAAIndex(*pdispid, *ppPropDesc ? CAttrValue::AA_Attribute : CAttrValue::AA_Expando);

Cleanup:
    RRETURN(hr);
}

static
HRESULT
PutNodeValueHelper(CAttribute *pAttribute, AAINDEX aaIdx, VARIANT varValue)
{
    HRESULT hr;

    Assert(pAttribute);
    Assert(pAttribute->_pElem);

    if (pAttribute->_pPropDesc)
    {
        DISPPARAMS dp;

        dp.rgvarg = &varValue;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs = 1;
        dp.cNamedArgs = 0;

        hr = THR(pAttribute->_pElem->Invoke(pAttribute->_dispid,
                                       IID_NULL,
                                       g_lcidUserDefault,
                                       DISPATCH_PROPERTYPUT,
                                       &dp,
                                       NULL,
                                       NULL,
                                       NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert(pAttribute->_dispid != DISPID_UNKNOWN);
        Assert(pAttribute->_pElem->IsExpandoDISPID(pAttribute->_dispid));

        if (aaIdx == AA_IDX_UNKNOWN)
        {
            hr = THR(CAttrArray::Set(pAttribute->_pElem->GetAttrArray(), pAttribute->_dispid, &varValue, NULL, CAttrValue::AA_Expando));
        }
        else
        {
            CAttrArray *pAA = *pAttribute->_pElem->GetAttrArray();
            Assert(pAA && aaIdx == pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Expando));
            hr = THR(pAA->SetAt(aaIdx, &varValue));
        }

        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

static
HRESULT
GetNodeValueHelper(CAttribute *pAttribute, AAINDEX aaIdx, VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;

    Assert(pAttribute);
    Assert(pAttribute->_pElem);

    if (pAttribute->_pPropDesc)
    {
        if (!(pAttribute->_pPropDesc->GetPPFlags() & PROPPARAM_SCRIPTLET))
        {
            DISPPARAMS dp = { NULL, NULL, 0, 0 };

            hr = THR (pAttribute->_pElem->Invoke(pAttribute->_dispid,
                               IID_NULL,
                               g_lcidUserDefault,
                               DISPATCH_PROPERTYGET,
                               &dp,
                               pvarValue,
                               NULL,
                               NULL));
        }

        if (hr)
        {
            if (aaIdx == AA_IDX_UNKNOWN)
                aaIdx = pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Attribute);
            else
                Assert(aaIdx == pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Attribute));

            hr = THR(pAttribute->_pElem->GetVariantAt(aaIdx, pvarValue));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert(pAttribute->_dispid != DISPID_UNKNOWN);
        Assert(pAttribute->_pElem->IsExpandoDISPID(pAttribute->_dispid));

        if (aaIdx == AA_IDX_UNKNOWN)
            aaIdx = pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Expando);
        else
            Assert(aaIdx == pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Expando));

        Assert(aaIdx != AA_IDX_UNKNOWN);
        hr = THR(pAttribute->_pElem->GetVariantAt(aaIdx, pvarValue));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);    
}

static
HRESULT
RemoveAttrHelper(LPTSTR pchAttrName, PROPERTYDESC **ppPropDesc, DISPID *pdispid, AAINDEX *paaIdx, AAINDEX *pvaaIdx, CElement *pElement, IHTMLDOMAttribute **ppAttribute, DWORD dwFlags)
{
    HRESULT hr;
    CAttribute *pretAttr = NULL;

    Assert(pchAttrName && paaIdx && pvaaIdx && pdispid && ppPropDesc && pElement && ppAttribute);

    hr = THR(GetIndexHelper(pchAttrName, paaIdx, pvaaIdx, pdispid, ppPropDesc, pElement, dwFlags));
    if (hr)
        goto Cleanup;

    if (*paaIdx == AA_IDX_UNKNOWN)
    {
        if (*pvaaIdx != AA_IDX_UNKNOWN)
        {
            // No Attr Node of same name as pAttr exists, but there exists an attr value,
            // create new node for returning to caller
            pretAttr = new CAttribute(NULL, DISPID_UNKNOWN, NULL);
            if (!pretAttr)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pretAttr->_cstrName.Set(pchAttrName);
            Assert(pretAttr->_varValue.IsEmpty());

            //NOTE: may need to get invoked value here for defaults etc.
            hr = THR(pElement->GetVariantAt(*pvaaIdx, &pretAttr->_varValue));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // Attr Node of same name as pAttr already exists, just return it.
        IUnknown *pUnk;
        hr = THR(pElement->GetUnknownObjectAt(*paaIdx, &pUnk));
        if (hr)
            goto Cleanup;

        pretAttr = (CAttribute *)pUnk;
        Assert(pretAttr);
        Assert(pretAttr->_varValue.IsEmpty());
        hr = THR(GetNodeValueHelper(pretAttr, *pvaaIdx, &pretAttr->_varValue));
        if (hr)
            goto Cleanup;
    }

    if (pretAttr)
    {
        if (pretAttr->_pElem)
        {
            pretAttr->_pElem->SubRelease();
            pretAttr->_pElem = NULL;
            pretAttr->_pPropDesc = NULL;
            pretAttr->_dispid = DISPID_UNKNOWN;
        }

        Assert(!pretAttr->_pPropDesc);
        Assert(pretAttr->_dispid == DISPID_UNKNOWN);

        hr = THR(pretAttr->PrivateQueryInterface(IID_IHTMLDOMAttribute, (void **)ppAttribute));
        pretAttr->Release();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

void
CBase::RemoveDOMAttrNode(DISPID dispid)
{
    Assert(IsExpandoDISPID(dispid));
    AAINDEX aaIdx = FindAAIndex(dispid, CAttrValue::AA_DOMAttribute);
    if (aaIdx != AA_IDX_UNKNOWN)
    {
        IUnknown *pUnk;
        CAttribute *pAttr;

        IGNORE_HR(GetUnknownObjectAt(aaIdx, &pUnk));
        pAttr = (CAttribute *)pUnk;
        if (pAttr)
        {
            Assert(pAttr->_varValue.IsEmpty());
            Assert(pAttr->_pElem);
            IGNORE_HR(GetNodeValueHelper(pAttr, AA_IDX_UNKNOWN, &pAttr->_varValue));
            pAttr->_pElem->SubRelease();
            pAttr->_pElem = NULL;
            pAttr->_pPropDesc = NULL;
            pAttr->_dispid = DISPID_UNKNOWN;
            pAttr->Release();
        }
 
        DeleteAt(aaIdx);
    }
}

HRESULT
CBase::UpdateDomAttrCollection(BOOL fDelete, DISPID dispid)
{
    HRESULT hr = S_OK;
    AAINDEX collIdx;
    CAttrCollectionator *pAttrCollator = NULL;

    Assert(IsExpandoDISPID(dispid));
    
    collIdx = _pAA->FindAAIndex(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, CAttrValue::AA_Internal);
    if (collIdx != AA_IDX_UNKNOWN)
    {
        hr = THR(GetPointerAt(collIdx, (void **)&pAttrCollator));
        if (hr)
            goto Cleanup;

        if (!fDelete)
        {
            CAttrCollectionator::AttrDesc ad;
            ad._pPropdesc = NULL;
            ad._dispid = dispid;
            hr = THR(pAttrCollator->_aryAttrDescs.AppendIndirect(&ad));
            if (hr)
                goto Cleanup;
        }
        else 
        {
            long i;
            for (i = pAttrCollator->_lexpandoStartIndex; i < pAttrCollator->_aryAttrDescs.Size(); i++)
            {
                if (dispid == pAttrCollator->_aryAttrDescs[i]._dispid)
                {
                    pAttrCollator->_aryAttrDescs.Delete(i);
                    break;
                }
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CAttribute::get_nodeName(BSTR *pbstrName)
{
    HRESULT hr = E_POINTER;

    if (!pbstrName)
        goto Cleanup;

    *pbstrName = NULL;
    Assert((LPTSTR)_cstrName);

    hr = THR(_cstrName.AllocBSTR(pbstrName));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = E_POINTER;

    if (!pvarValue)
        goto Cleanup;

    Assert((LPTSTR)_cstrName);
    if (!_pElem)
    {
        // Ether Attribuite Node
        Assert(_dispid == DISPID_UNKNOWN);
        Assert(!_pPropDesc);
        hr = THR(VariantCopy(pvarValue, &_varValue));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(GetNodeValueHelper(this, AA_IDX_UNKNOWN, pvarValue));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::put_nodeValue(VARIANT varValue)
{
    HRESULT hr;

    Assert((LPTSTR)_cstrName);
    if (!_pElem)
    {
        // Ether Attribuite Node
        Assert(_dispid == DISPID_UNKNOWN);
        Assert(!_pPropDesc);
        hr = THR(_varValue.Copy(&varValue));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(PutNodeValueHelper(this, AA_IDX_UNKNOWN, varValue));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::get_specified(VARIANT_BOOL *pbSpecified)
{
    HRESULT hr = S_OK;
    CAttrValue::AATYPE aaType;
    AAINDEX aaIdx;

    Assert((LPTSTR)_cstrName);
    if (!pbSpecified)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!_pElem)
    {
        // Ether Attribuite Node
        Assert(_dispid == DISPID_UNKNOWN);
        Assert(!_pPropDesc);
        *pbSpecified = VB_FALSE;
        goto Cleanup;
    }

    aaType = _pPropDesc ? CAttrValue::AA_Attribute : CAttrValue::AA_Expando;

    // not there in AA
    aaIdx = _pElem->FindAAIndex((_dispid == DISPID_CElement_style_Str) ? DISPID_INTERNAL_INLINESTYLEAA : _dispid,
                                (_dispid == DISPID_CElement_style_Str) ? CAttrValue::AA_AttrArray : aaType);

    if (_dispid == DISPID_CElement_style_Str && aaIdx != AA_IDX_UNKNOWN)
    {
        if (!_pElem->GetAttrValueAt(aaIdx)->GetAA()->HasAnyAttribute(TRUE))
            aaIdx = AA_IDX_UNKNOWN;
    }

    *pbSpecified = (aaIdx == AA_IDX_UNKNOWN) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAttribute::get_name(BSTR *pbstrName)
{
    return get_nodeName(pbstrName);
}

HRESULT
CAttribute::get_value(BSTR *pbstrvalue)
{
    HRESULT hr;
    CVariant varValue;
    VARIANT varRet;

    if (!pbstrvalue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(get_nodeValue(&varValue));
    if (hr)
        goto Cleanup;

    VariantInit(&varRet);

    // TODO: Need to handle style properly
    hr = THR(VariantChangeTypeSpecial(&varRet, &varValue, VT_BSTR));
    if (hr)
        goto Cleanup;

    *pbstrvalue = V_BSTR(&varRet);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::put_value(BSTR bstrvalue)
{
    VARIANT varValue;

    V_VT(&varValue) = VT_BSTR;
    V_BSTR(&varValue) = bstrvalue;
    return put_nodeValue(varValue);
}

HRESULT
CAttribute::get_expando(VARIANT_BOOL *pfIsExpando)
{
    HRESULT hr = S_OK;

    if (!pfIsExpando)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    Assert((LPTSTR)_cstrName);
    Assert(!_pElem || _pPropDesc || _pElem->IsExpandoDISPID(_dispid));
    *pfIsExpando = (!_pElem || _pPropDesc) ? VB_FALSE : VB_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAttribute::get_nodeType(long *pnodeType)
{
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pnodeType = 2; // DOM_ATTRIBUTE
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::get_parentNode(IHTMLDOMNode **pparentNode)
{
    if(pparentNode)
        *pparentNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_childNodes(IDispatch **ppChildCollection)
{
    if(ppChildCollection)
        *ppChildCollection = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_firstChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_lastChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_attributes(IDispatch **ppAttrCollection)
{
    if (ppAttrCollection)
        *ppAttrCollection = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_ownerDocument(IDispatch **ppretdoc)
{
    HRESULT     hr = S_OK;

    if(!ppretdoc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if(_pDocument)
    {
        hr = E_ACCESSDENIED;
        if (   _pMarkup 
            && _pDocument->Markup() 
            && _pMarkup->AccessAllowed(_pDocument->Markup()))
        {
            hr = THR(_pDocument->QueryInterface(IID_IDispatch, (void **)ppretdoc));
        }
        goto Cleanup;
    }

    *ppretdoc = NULL;

    if(!_pElem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(_pElem->get_ownerDocument(ppretdoc));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a attribute node
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, 
                           IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::hasChildNodes(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMAttribute **ppNodeCloned)
{
    HRESULT               hr = S_OK;
    CDocument          *  pDocument;

    Assert((LPTSTR)_cstrName);

    if(!ppNodeCloned)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppNodeCloned = NULL;

    if(_pElem)
    {
        IDispatch * pIDispDocument;
        hr = THR(_pElem->get_document(&pIDispDocument));
        if(hr)
            goto Cleanup;
        hr = THR(pIDispDocument->QueryInterface(CLSID_CDocument, (void **) &pDocument));
        pIDispDocument->Release();
        if(hr)
            goto Cleanup;
    }
    else
    {
        Assert(_pDocument);
        pDocument = _pDocument;
    }

    hr = THR(pDocument->createAttribute(_cstrName, ppNodeCloned));

Cleanup:

    RRETURN(SetErrorInfo(hr));
}




////////////////////////////////////////////////////////////////////////////////
//
// IHTMLDOMNode methods:
//
////////////////////////////////////////////////////////////////////////////////

HRESULT
CElement::get_nodeType(long *pnodeType)
{
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if(Tag() != ETAG_RAW_COMMENT)
        *pnodeType = 1; // ELEMENT_NODE
    else
        *pnodeType = 8;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_nodeName(BSTR *pbstrNodeName)
{
    HRESULT hr = S_OK;

    if(Tag() != ETAG_RAW_COMMENT)
        hr = THR(get_tagName ( pbstrNodeName ));
    else
    {
        if (!pbstrNodeName)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        *pbstrNodeName = NULL;
    
        hr = THR(FormsAllocString ( _T("#comment"), pbstrNodeName ));
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (Tag() != ETAG_RAW_COMMENT)
        pvarValue->vt = VT_NULL;
    else
    {
        VariantInit(pvarValue);
        pvarValue->vt = VT_BSTR;
        return DYNCAST(CCommentElement, this)->get_data(&V_BSTR(pvarValue));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::put_nodeValue(VARIANT varValue)
{
    HRESULT hr = S_OK;

    if (Tag() == ETAG_RAW_COMMENT) 
    {

        if (V_VT(&varValue) == VT_BSTR)
        {
            return DYNCAST(CCommentElement, this)->put_data(V_BSTR(&varValue));
        }
        else
            hr = E_INVALIDARG;
    }

    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_lastChild ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_OBJECT == Tag() || ETAG_APPLET == Tag())
    {
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);
        int c = pelObj->_aryParams.Size();
        if (c)
            hr = THR(pelObj->_aryParams[c-1]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

        goto Cleanup; // done
    }

    if ( IsNoScope() )
        goto Cleanup;

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;

    hr = THR(markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd));
    if ( hr )
        goto Cleanup;

    hr = THR(GetPreviousHelper ( Doc(), &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_PARAM == Tag())
    {
        CParamElement *pelParam = DYNCAST(CParamElement, this);
        CObjectElement *pelObj = pelParam->_pelObjParent;
        if (pelObj)
        {
            Assert(pelObj->_aryParams.Size() &&
                   pelParam->_idxParam != -1 &&
                   pelParam->_idxParam < pelObj->_aryParams.Size());
            if (pelParam->_idxParam > 0)
                hr = THR(pelObj->_aryParams[pelParam->_idxParam-1]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

            goto Cleanup; // done
        }
    }

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;

    hr = THR( markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_BeforeBegin));
    if ( hr )
        goto Cleanup;

    hr = THR(GetPreviousHelper ( Doc(), &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_PARAM == Tag())
    {
        CParamElement *pelParam = DYNCAST(CParamElement, this);
        CObjectElement *pelObj = pelParam->_pelObjParent;
        if (pelObj)
        {
            Assert(pelObj->_aryParams.Size() &&
                   pelParam->_idxParam != -1 &&
                   pelParam->_idxParam < pelObj->_aryParams.Size());
            if (pelParam->_idxParam+1 < pelObj->_aryParams.Size())
                hr = THR(pelObj->_aryParams[pelParam->_idxParam+1]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

            goto Cleanup; // done
        }
    }

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;
    
    hr = THR( markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_AfterEnd));
    if ( hr )
        goto Cleanup;

    hr = THR(GetNextHelper ( Doc(), &markupWalk, ppNode ));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_firstChild ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_OBJECT == Tag() || ETAG_APPLET == Tag())
    {
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);
        if (pelObj->_aryParams.Size())
            hr = THR(pelObj->_aryParams[0]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

        goto Cleanup; // done
    }

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;

    if ( IsNoScope() )
        goto Cleanup;

    hr = THR( markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    hr = THR(GetNextHelper ( Doc(), &markupWalk, ppNode ));


Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_parentNode(IHTMLDOMNode **pparentNode)
{
    HRESULT             hr = S_OK;
    CTreeNode           *pNode;

    if (!pparentNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pparentNode = NULL;

    pNode = GetFirstBranch();
    if ( !pNode )
    {
        if (ETAG_PARAM == Tag())
        {
            CObjectElement *pelObj = DYNCAST(CParamElement, this)->_pelObjParent;
            if (pelObj)
                hr = THR(pelObj->QueryInterface(IID_IHTMLDOMNode, (void **)pparentNode));
        }
     
        goto Cleanup;
    }

    pNode = pNode->Parent();

    hr = THR(ParentNodeHelper(pNode, pparentNode));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT 
CElement::DOMWalkChildren ( long lWantItem, long *plCount, IDispatch **ppDispItem )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      markupWalk (Doc());
    CMarkupPointer      markupWalkEnd (Doc());
    CTreeNode           *pnodeRight;
    MARKUP_CONTEXT_TYPE context;
    long                lCount = 0;
    BOOL                fWantItem = (lWantItem == -1 ) ? FALSE : TRUE;
    long                lTextID;
    BOOL                fDone = FALSE;

    if (ppDispItem)
        *ppDispItem = NULL;

    if (!IsInMarkup())
        goto Cleanup;

    hr = THR( markupWalk.MoveAdjacentToElement( this, Tag() == ETAG_ROOT ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeBegin));
    if ( hr )
        goto Cleanup;

    hr = THR( markupWalkEnd.MoveAdjacentToElement( this, Tag() == ETAG_ROOT ? ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterEnd));
    if ( hr )
        goto Cleanup;

    do
    {
        hr = THR( markupWalk.Right( TRUE, &context, &pnodeRight, NULL, NULL, &lTextID));
        if ( hr )
            goto Cleanup;

        switch ( context )
        {
            case CONTEXT_TYPE_None:
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_ExitScope://don't care ...
                if ( pnodeRight->Element() == this )
                    goto NotFound;
                break;

            case CONTEXT_TYPE_EnterScope:
                if ( pnodeRight->Element() != this )
                {
                    // Add to our child list
                    lCount++;
                    // Go to the end of this element, since we will handle it as a container
                    hr = THR( markupWalk.MoveAdjacentToElement( pnodeRight->Element(), ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    // Need to test we haven't left the scope of my parent.
                    // Overlapping could cause us to move outside
                    if ( markupWalkEnd.IsLeftOf( & markupWalk ) )
                    {
                        fDone = TRUE;
                    }
                }
                break;

            case CONTEXT_TYPE_Text:
                lCount++;
                break;

            case CONTEXT_TYPE_NoScope:
                if ( pnodeRight->Element() == this )
                {
                    // Left scope of current noscope element
                    goto NotFound;
                }
                else
                {
                    // Add to our child list
                    lCount++;
                }
                break;
        }
        if (fWantItem && (lCount-1 == lWantItem ))
        {
            // Found the item we're looking for
            if ( !ppDispItem )
                goto Cleanup; // Didn't want an item, just validating index

            if ( context == CONTEXT_TYPE_Text )
            {
                // Text Node
                CDOMTextNode *pTextNode = NULL;

                hr = THR(CreateTextNode (Doc(), &markupWalk, lTextID, &pTextNode ));
                if ( hr )
                    goto Cleanup;

                hr = THR ( pTextNode->QueryInterface ( IID_IDispatch, (void **)ppDispItem ) );
                if ( hr )
                    goto Cleanup;
                pTextNode->Release();
            }
            else
            {
                // Return Disp to Element
                hr = THR(pnodeRight->GetElementInterface ( IID_IDispatch, (void **) ppDispItem  ));
                if ( hr )
                    goto Cleanup;
            }
            goto Cleanup;
        }
        // else just looking for count
    } while( !fDone );

NotFound:
    if ( fWantItem )
    {
        // Didn't find it - index must be beyond range
        hr = E_INVALIDARG;
    }

Cleanup:
    if ( plCount )
        *plCount = lCount;
    return hr;
}


HRESULT
CElement::hasChildNodes(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (!p)
        goto Cleanup;

    if (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET)
    {
        *p = DYNCAST(CObjectElement, this)->_aryParams.Size() ? VARIANT_TRUE : VARIANT_FALSE;
        goto Cleanup;
    }

    *p = VARIANT_FALSE;

    if ( !IsInMarkup() ) // Can just return FALSE
        goto Cleanup;

    // See if we have a child at Index == 0

    hr = THR( DOMWalkChildren ( 0, NULL, NULL ));
    if ( hr == E_INVALIDARG )
    {
        // Invalid Index
        hr = S_OK;
        goto Cleanup;
    }
    else if ( hr )
        goto Cleanup;

    *p = VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_childNodes(IDispatch **ppChildCollection)
{
    HRESULT hr = S_OK;
    CDOMChildrenCollection *pChildren;

    if ( !ppChildCollection )
        goto Cleanup;

    *ppChildCollection = NULL;

    pChildren = EnsureDOMChildrenCollectionPtr();
    if ( !pChildren )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(pChildren->QueryInterface (IID_IDispatch,(void **)ppChildCollection));
    if ( hr )
        goto Cleanup;

    pChildren->Release(); // Lifetime is controlled by extrenal ref.

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


CAttrCollectionator *
CElement::EnsureAttributeCollectionPtr ( )
{
    HRESULT hr = S_OK;
    CAttrCollectionator *pAttrCollator = NULL;
    IGNORE_HR(GetPointerAt(FindAAIndex(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, CAttrValue::AA_Internal), (void **)&pAttrCollator));
    if (!pAttrCollator)
    {
        pAttrCollator = new CAttrCollectionator(this);
        
        if (pAttrCollator)
        {
            pAttrCollator->EnsureCollection();

            hr = THR(AddPointer(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, (void *)pAttrCollator, CAttrValue::AA_Internal ));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        pAttrCollator->AddRef();
    }

Cleanup:
    return pAttrCollator;
}

HRESULT
CElement::get_attributes(IDispatch **ppAttrCollection)
{

    HRESULT hr = S_OK;
    CAttrCollectionator *pAttrCollator = NULL;

    if (!ppAttrCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppAttrCollection = NULL;

    if(Tag() == ETAG_RAW_COMMENT)
        // Comment tags should return NULL according to spec
        goto Cleanup;

    pAttrCollator = EnsureAttributeCollectionPtr();
    if ( !pAttrCollator )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pAttrCollator->QueryInterface(IID_IDispatch, (void **)ppAttrCollection));
    if ( hr )
        goto Cleanup;

Cleanup:    
    if (pAttrCollator)
       pAttrCollator->Release();

    RRETURN(SetErrorInfo(hr));
}


HRESULT 
CElement::GetDOMInsertPosition ( CElement *pRefElement, CDOMTextNode *pRefTextNode, CMarkupPointer *pmkptrPos )
{
    HRESULT hr = S_OK;

    if ( !pRefElement && !pRefTextNode )
    {
        // As per DOM spec, if refChild is NULL Insert at end of child list
        // but only if the elem into which it is to be inserted can have children!
        if (IsNoScope())
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        hr = THR(EnsureInMarkup());
        if ( hr )
            goto Cleanup;
        hr = THR(pmkptrPos->MoveAdjacentToElement ( this, ELEM_ADJ_BeforeEnd ));
    }
    else
    {
        hr = GetDOMInsertHelper (pRefElement, pRefTextNode, pmkptrPos ); 
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CElement::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    CVariant varEmpty(VT_NULL);

    return insertBefore ( pNewChild, *(VARIANT *)&varEmpty, ppRetNode );
}

static BOOL IsChild(CElement *pelParent, CElement *pelChild, CDOMTextNode *pTextNode)
{
    Assert(pelParent);
    Assert(!pelChild || !pTextNode);

    if (pelChild)
    {
        if ((pelParent->Tag() == ETAG_OBJECT || pelParent->Tag() == ETAG_APPLET) &&
            pelChild->Tag() == ETAG_PARAM)
        {
            CParamElement *pelParam = DYNCAST(CParamElement, pelChild);
            Assert((pelParam->_pelObjParent != pelParent) ||
                   (pelParent->Tag() == ETAG_OBJECT) ||
                   (pelParent->Tag() == ETAG_APPLET));
            return (pelParam->_pelObjParent == pelParent);

        }

        CTreeNode *pNode = pelChild->GetFirstBranch();
        if (!pNode || !pNode->Parent() || (pNode->Parent()->Element() != pelParent))
            return FALSE;
    }
    else if (pTextNode)
    {
        CElement *pelTxtNodeParent = NULL;
        IHTMLElement *pITxtNodeParent = NULL;
        Assert(pTextNode->MarkupPtr());
        Assert(pTextNode->MarkupPtr()->Cling()); // Must have Glue!
        Assert(pTextNode->MarkupPtr()->Gravity()); // Must have right gravity.

        CurrentScope(pTextNode->MarkupPtr(), &pITxtNodeParent, NULL);
        if (pITxtNodeParent)
            pITxtNodeParent->QueryInterface(CLSID_CElement, (void **)&pelTxtNodeParent);
        ReleaseInterface(pITxtNodeParent);
        if (pelTxtNodeParent != pelParent)
            return FALSE;
    }

    return TRUE;
}

HRESULT
CElement::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    HRESULT                 hr;
    CElement *              pRefElement = NULL;
    CDOMTextNode *          pRefTextNode = NULL;
    CElement *              pNewElement = NULL;
    CDOMTextNode *          pNewTextNode = NULL;
    CDoc *                  pDoc = Doc();
    CMarkupPointer          mkpPtr (pDoc);

    if (!pNewChild)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(CrackDOMNodeVARIANT(&refChild, &pRefTextNode, &pRefElement, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    hr = THR(CrackDOMNode((IUnknown*)pNewChild, &pNewTextNode, &pNewElement, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNewChild, pNewElement));

    if (!IsChild(this, pRefElement, pRefTextNode))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
                
    if (pNewElement && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET))
    {
        Assert(!pRefElement || pRefElement->Tag() == ETAG_PARAM);
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);

        hr = THR(pelObj->AddParam(pNewElement, pRefElement));
    }
    else
    {
        // Position ourselves in the right spot
        hr = THR(GetDOMInsertPosition(pRefElement, pRefTextNode, &mkpPtr));
        if (hr)
            goto Cleanup;

        // Now mkpPtr is Positioned at the insertion point, insert the new content
        hr = THR(InsertDOMNodeHelper(pNewElement, pNewTextNode, &mkpPtr));
    }

    if (hr)
        goto Cleanup;

    if (ppRetNode)
        hr = THR(pNewChild->QueryInterface(IID_IHTMLDOMNode, (void**)ppRetNode));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, IHTMLDOMNode **pRetNode)
{
    HRESULT                 hr;
    CElement *              pOldElement = NULL;
    CDOMTextNode *          pOldTextNode = NULL;
    CElement *              pNewElement = NULL;
    CDOMTextNode *          pNewTextNode = NULL;
    CDoc *                  pDoc = Doc();
    CMarkupPointer          mkpPtr(pDoc);

    // Pull pOldChild, and all its contents, out of the tree, into its own tree
    // replace it with pNewChild, and all its contents

    if (!pNewChild || !pOldChild)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pOldChild, &pOldTextNode, &pOldElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    hr = THR(CrackDOMNode((IUnknown*)pNewChild, &pNewTextNode, &pNewElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNewChild, pNewElement));

    if (!IsChild(this, pOldElement, pOldTextNode))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET)
    {
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);
        
        if (pNewElement && pOldElement)
        {
            Assert(pOldElement->Tag() == ETAG_PARAM);
            hr = THR(pelObj->ReplaceParam(pNewElement, pOldElement));
            if (hr)
                goto Cleanup;

            // Return the node being replaced
            if (pRetNode)
                hr = THR(pOldChild->QueryInterface(IID_IHTMLDOMNode, (void**)pRetNode));

            goto Cleanup; // done
        }
    }

    // Position ourselves in the right spot
    hr = THR(GetDOMInsertPosition ( pOldElement, pOldTextNode, &mkpPtr ));
    if ( hr )
        goto Cleanup;

    mkpPtr.SetGravity ( POINTER_GRAVITY_Left );

    {
        // Lock the markup, to prevent it from going away in case the entire contents are being removed.
        CMarkup::CLock MarkupLock(mkpPtr.Markup());

        hr = THR(RemoveDOMNodeHelper ( pDoc, pOldElement, pOldTextNode ));
        if ( hr )
            goto Cleanup;

        // Now mkpPtr is Positioned at the insertion point, insert the new content
        hr = THR(InsertDOMNodeHelper( pNewElement, pNewTextNode, &mkpPtr ));
        if ( hr )
            goto Cleanup;

        // Return the node being replaced
        if ( pRetNode )
            hr = THR(pOldChild->QueryInterface ( IID_IHTMLDOMNode, (void**)pRetNode));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



HRESULT
CElement::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **pRetNode)
{
    HRESULT hr;
    CDOMTextNode *pChildTextNode = NULL;
    CElement *pChildElement = NULL;
    CDoc *pDoc = Doc();

    // Remove the child from the tree, putting it in its own tree

    if ( !pOldChild )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pOldChild, &pChildTextNode, &pChildElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    if (!IsChild(this, pChildElement, pChildTextNode))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pChildElement && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET))
    {
        Assert(pChildElement->Tag() == ETAG_PARAM);
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);

        hr = THR(pelObj->RemoveParam(pChildElement));
    }
    else
        hr = THR(RemoveDOMNodeHelper(pDoc, pChildElement, pChildTextNode));

    if ( hr )
        goto Cleanup;

    // Return the node being removed
    if ( pRetNode )
        hr = THR(pOldChild->QueryInterface ( IID_IHTMLDOMNode, (void**)pRetNode));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//
// IHTMLDocument3 DOM methods
//
HRESULT CDoc::CreateDOMTextNodeHelper ( CMarkupPointer *pmkpStart, CMarkupPointer *pmkpEnd,
                                       IHTMLDOMNode **ppTextNode)
{
    HRESULT hr;
    long lTextID;
    CDOMTextNode *pTextNode;

    // ID it
    hr = THR(pmkpStart->SetTextIdentity( pmkpEnd, &lTextID ));
    if ( hr )
        goto Cleanup;

    // set right gravity so that an adjacent text node's markup ptr can never
    // move accidentally.
    hr = THR(pmkpStart->SetGravity ( POINTER_GRAVITY_Right ));
    if (hr)
        goto Cleanup;

    // Text Node takes ownership of pmkpStart
    pTextNode = new CDOMTextNode ( lTextID, this, pmkpStart ); // AddRef's the Markup
    if ( !pTextNode )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( ppTextNode )
    {
        hr = THR(pTextNode->QueryInterface ( IID_IHTMLDOMNode, (void**)ppTextNode ));
        if ( hr )
            goto Cleanup;
    }

    pTextNode->Release(); // Creating AddREf'd it once - refcount owned by external AddRef

    hr = THR(_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(lTextID<<4), (void*)pTextNode ) );
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//
//  IE5 XOM. Extensions for document construction
//

HRESULT 
CElement::GetMarkupPtrRange(CMarkupPointer *pmkptrStart, CMarkupPointer *pmkptrEnd, BOOL fEnsureMarkup)
{
    HRESULT hr;
    
    Assert(pmkptrStart);
    Assert(pmkptrEnd);
    
    if (fEnsureMarkup)
    {
        hr = THR(EnsureInMarkup());
        if (hr)
            goto Cleanup;
    }

    hr = THR(pmkptrStart->MoveAdjacentToElement(this, Tag() == ETAG_ROOT? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pmkptrEnd->MoveAdjacentToElement(this, Tag() == ETAG_ROOT? ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterEnd));

Cleanup:
    return hr;
}


HRESULT
CElement::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeCloned)
{
    HRESULT                 hr = E_OUTOFMEMORY;
    CDoc *                  pDoc = Doc();
    CMarkup *               pMarkupTarget = NULL;
    CElement *              pElement = NULL;
    CTreeNode   *           pNode;

    if ( !ppNodeCloned || Tag() == ETAG_ROOT )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppNodeCloned = NULL;

    if (!fDeep || !IsInMarkup() || IsNoScope())
    {
        hr = THR(Clone(&pElement, pDoc));
        if (hr)
            goto Cleanup;

        hr = THR(pElement->PrivateQueryInterface(IID_IHTMLDOMNode, (void **)ppNodeCloned));
        if (hr)
            goto Cleanup;

        pElement->Release();

        Assert(Tag() != ETAG_PARAM ||
               (!(DYNCAST(CParamElement, pElement)->_pelObjParent) &&
                DYNCAST(CParamElement, this)->_pelObjParent));

        if (fDeep && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET))
        {
            CParamElement *pelParamClone;
            CObjectElement *pelObj = DYNCAST(CObjectElement, this);
            CObjectElement *pelObjClone = DYNCAST(CObjectElement, pElement);
            
            Assert(pelObjClone->_aryParams.Size() == 0);

            for (int i = 0; i < pelObj->_aryParams.Size(); i++)
            {
                Assert(pelObj->_aryParams[i] && pelObj->_aryParams[i]->Tag() == ETAG_PARAM);
                hr = THR(pelObj->_aryParams[i]->Clone((CElement **)&pelParamClone, pDoc));
                if (hr)
                    goto Cleanup;

                Assert(pelParamClone->_idxParam == -1);
                Assert(!pelParamClone->_pelObjParent);

                hr = THR(pelObjClone->AddParam(pelParamClone, NULL));
                if (hr)
                    goto Cleanup;

                Assert(pelParamClone->_idxParam == i);
                Assert(pelParamClone->_pelObjParent == pelObjClone);

                pelParamClone->Release();
                Assert(pelParamClone->GetObjectRefs());;
            }

            Assert(pelObj->_aryParams.Size() == pelObjClone->_aryParams.Size());
        }
    }
    else
    {
        CMarkupPointer mkptrStart ( pDoc );
        CMarkupPointer mkptrEnd ( pDoc );
        CMarkupPointer mkptrTarget ( pDoc );

        // Get src ptrs
        hr = THR(GetMarkupPtrRange(&mkptrStart, &mkptrEnd));
        if (hr)
            goto Cleanup;

        // create new markup
        hr = THR(pDoc->CreateMarkup(&pMarkupTarget, GetWindowedMarkupContext()));
        if (hr)
            goto Cleanup;

        hr = THR( pMarkupTarget->SetOrphanedMarkup( TRUE ) );
        if( hr )
            goto Cleanup;

        // Get target ptr

        hr = THR(mkptrTarget.MoveToContainer(pMarkupTarget,TRUE));
        if (hr)
            goto Cleanup;

        // Copy src -> target
        hr = THR(pDoc->Copy(&mkptrStart, &mkptrEnd, &mkptrTarget, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;

        // This addrefs the markup too!

        // Go Right to pick up the new node ptr
        hr = THR(mkptrTarget.Right(FALSE, NULL, &pNode, 0, NULL,NULL));
        if (hr)
            goto Cleanup;

        hr = THR(pNode->Element()->PrivateQueryInterface(IID_IHTMLDOMNode, (void **)ppNodeCloned));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    // release extra markup lock
    if (pMarkupTarget)
        pMarkupTarget->Release();

    RRETURN(SetErrorInfo(hr));

}

// Surgicaly remove pElemApply out of its current context,
// Apply it over this element

HRESULT
CElement::applyElement(IHTMLElement *pElemApply, BSTR bstrWhere, IHTMLElement **ppElementApplied)
{
    HRESULT hr;
    CDoc *pDoc = Doc();
    CMarkupPointer mkptrStart(pDoc);
    CMarkupPointer mkptrEnd (pDoc);
    CElement *pElement;
    htmlApplyLocation where = htmlApplyLocationOutside;

    if ( ppElementApplied )
        *ppElementApplied = NULL;

    if ( !pElemApply )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pDoc->IsOwnerOf(pElemApply))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pElemApply->QueryInterface ( CLSID_CElement, (void**) &pElement ));
    if (hr)
        goto Cleanup;

    ENUMFROMSTRING(htmlApplyLocation, bstrWhere, (long *)&where);

    // No scoped elements cannot be applied as they cannot have children!
    // Nor can the root element, nor can you apply something outside a root
    if ( pElement->IsNoScope() || 
         pElement->Tag() == ETAG_ROOT || 
         ( Tag() == ETAG_ROOT && where == htmlApplyLocationOutside ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get src ptrs
    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    hr = THR(mkptrStart.MoveAdjacentToElement(this, where ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterBegin));
    if (hr)
        goto Cleanup;

    hr = THR(mkptrEnd.MoveAdjacentToElement(this, where ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeEnd));
    if (hr)
        goto Cleanup;

    // Surgically remove the elem to be applied if in a markup.
    if (pElement->IsInMarkup())
    {
        hr = THR(pDoc->RemoveElement(pElement, MUS_DOMOPERATION));
        if ( hr )
            goto Cleanup;
    }

    hr = THR(pDoc->InsertElement ( pElement, &mkptrStart, &mkptrEnd, MUS_DOMOPERATION ));
    if (hr)
        goto Cleanup;

    if ( ppElementApplied )
        hr = THR(pElemApply->QueryInterface ( IID_IHTMLElement, (void**) ppElementApplied ));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::removeNode (VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeRemoved)
{
    HRESULT hr = S_OK;

    // Pull element out of the tree
    if ( ppNodeRemoved )
        *ppNodeRemoved = NULL;

    Assert( Tag() != ETAG_ROOT );

    if ( fDeep )
    {
        hr = THR(RemoveDOMNodeHelper ( Doc(), this, NULL ));
        if ( hr )
            goto Cleanup;
    }
    else if (IsInMarkup())
    {
        // Surgical removal
        hr = THR(Doc()->RemoveElement ( this, MUS_DOMOPERATION ) );
        if ( hr )
            goto Cleanup;
    }

    if ( ppNodeRemoved )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeRemoved));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::replaceNode(IHTMLDOMNode *pNodeReplace, IHTMLDOMNode **ppNodeReplaced)
{
    HRESULT hr;
    CDOMTextNode *pNewTextNode = NULL;
    CElement *pNewElement = NULL;
    CDoc *pDoc = Doc();
        
    if ( ppNodeReplaced )
        *ppNodeReplaced = NULL;

    Assert( Tag() != ETAG_ROOT );

    if ( !pNodeReplace )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeReplace, &pNewTextNode, &pNewElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeReplace, pNewElement));

    hr = THR(ReplaceDOMNodeHelper ( pDoc, this, NULL, pNewElement, pNewTextNode ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeReplaced )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeReplaced));
    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}    

HRESULT
CElement::swapNode(IHTMLDOMNode *pNodeSwap, IHTMLDOMNode **ppNodeSwapped)
{
    CElement *      pSwapElement = NULL;
    CDOMTextNode *  pSwapText = NULL;
    CDoc *          pDoc = Doc();
    HRESULT         hr;
        
    if ( ppNodeSwapped )
        *ppNodeSwapped = NULL;

    Assert( Tag() != ETAG_ROOT );

    if ( !pNodeSwap )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeSwap, &pSwapText, &pSwapElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeSwap, pSwapElement));

    hr = THR (SwapDOMNodeHelper ( pDoc, this, NULL, pSwapElement, pSwapText ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeSwapped )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeSwapped));
    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::insertAdjacentElement(BSTR bstrWhere, IHTMLElement *pElemInsert, IHTMLElement **ppElementInserted)
{
    HRESULT                     hr;
    htmlAdjacency               where;
    ELEMENT_ADJACENCY           adj;
    CDoc *pDoc =                Doc();
    CMarkupPointer mkptrTarget(pDoc);
    CElement *pElement = NULL;

    if (ppElementInserted)
        *ppElementInserted = NULL;

    if (!pElemInsert)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pDoc->IsOwnerOf( pElemInsert ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(ENUMFROMSTRING(htmlAdjacency, bstrWhere, (long *)&where));
    if (hr)
        goto Cleanup;

    hr = THR(pElemInsert->QueryInterface(CLSID_CElement, (void **)&pElement));
    if (hr)
        goto Cleanup;

    // Can't insert a root, can't insert outside of root
    if( pElement->Tag() == ETAG_ROOT || 
        ( Tag() == ETAG_ROOT && 
          ( where == htmlAdjacencyBeforeBegin || 
            where == htmlAdjacencyAfterEnd ) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch (where)
    {
    case htmlAdjacencyBeforeBegin:
    default:
        adj = ELEM_ADJ_BeforeBegin;
        break;
    case htmlAdjacencyAfterBegin:
        adj = ELEM_ADJ_AfterBegin;
        break;
    case htmlAdjacencyBeforeEnd:
        adj = ELEM_ADJ_BeforeEnd;
        break;
    case htmlAdjacencyAfterEnd:
        adj = ELEM_ADJ_AfterEnd;
        break;
    }

    // Get target ptr
    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    hr = THR(mkptrTarget.MoveAdjacentToElement(this, adj));
    if (hr)
        goto Cleanup;

    // Move src -> target
    hr = THR(InsertDOMNodeHelper(pElement, NULL, &mkptrTarget));
    if (hr)
        goto Cleanup;

    if ( ppElementInserted )
    {
        *ppElementInserted = pElemInsert;
        (*ppElementInserted)->AddRef();
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

static
HRESULT
SetAdjacentTextPointer ( CElement *pElem, htmlAdjacency where, 
    MARKUP_CONTEXT_TYPE *pContext, CMarkupPointer *pmkptrStart, long *plCharCount)
{
    ELEMENT_ADJACENCY           adj;
    BOOL fLeft;
    HRESULT hr;

    switch (where)
    {
    case htmlAdjacencyBeforeBegin:
    default:
        adj = ELEM_ADJ_BeforeBegin;
        fLeft = TRUE;
        break;
    case htmlAdjacencyAfterBegin:
        adj = ELEM_ADJ_AfterBegin;
        fLeft = FALSE;
        break;
    case htmlAdjacencyBeforeEnd:
        adj = ELEM_ADJ_BeforeEnd;
        fLeft = TRUE;
        break;
    case htmlAdjacencyAfterEnd:
        adj = ELEM_ADJ_AfterEnd;
        fLeft = FALSE;
        break;
    }

    hr = THR(pmkptrStart->MoveAdjacentToElement(pElem, adj));
    if (hr)
        goto Cleanup;

    if ( fLeft )
    {
        // Need to move the pointer to the start of the text
        hr = THR(pmkptrStart->Left ( TRUE, pContext, NULL, plCharCount, NULL, NULL ));
        if ( hr )
            goto Cleanup;
    }
    else if ( plCharCount )
    {
        // Need to do a non-moving Right to get the text length
        hr = THR(pmkptrStart->Right ( FALSE, pContext, NULL, plCharCount, NULL, NULL ));
        if ( hr )
            goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}


HRESULT
CElement::getAdjacentText( BSTR bstrWhere, BSTR *pbstrText )
{
    HRESULT                     hr = S_OK;
    CMarkupPointer              mkptrStart ( Doc() );
    htmlAdjacency               where;
    long                        lCharCount = -1;
    MARKUP_CONTEXT_TYPE         context;

    hr = THR(ENUMFROMSTRING(htmlAdjacency, bstrWhere, (long *)&where));
    if (hr)
        goto Cleanup;

    if ( !pbstrText )
        goto Cleanup;

    *pbstrText = NULL;

    hr = THR(SetAdjacentTextPointer ( this, where, &context, &mkptrStart, &lCharCount ));
    if ( hr )
        goto Cleanup;

    // Is there any text to return
    if ( context != CONTEXT_TYPE_Text || lCharCount == 0 )
        goto Cleanup;

    // Alloc memory
    hr = FormsAllocStringLen ( NULL, lCharCount, pbstrText );
    if ( hr )
        goto Cleanup;

    // Read it into the buffer
    hr = THR(mkptrStart.Right( FALSE, &context, NULL, &lCharCount, *pbstrText, NULL));
    if ( hr )
        goto Cleanup;
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::replaceAdjacentText( BSTR bstrWhere, BSTR bstrText, BSTR *pbstrText )
{
    HRESULT                     hr = S_OK;
    CMarkupPointer              mkptrStart ( Doc() );
    CMarkupPointer              mkptrEnd ( Doc() );
    htmlAdjacency               where;
    long                        lCharCount = -1;
    MARKUP_CONTEXT_TYPE         context;

    hr = THR(ENUMFROMSTRING(htmlAdjacency, bstrWhere, (long *)&where));
    if (hr)
        goto Cleanup;

    if ( pbstrText )
    {
        hr = THR (getAdjacentText(bstrWhere, pbstrText ));
        if ( hr )
            goto Cleanup;
    }

    hr = THR(SetAdjacentTextPointer ( this, where, &context, &mkptrStart, &lCharCount ));
    if ( hr )
        goto Cleanup;

    hr = THR(mkptrEnd.MoveToPointer ( &mkptrStart ) );
    if ( hr )
        goto Cleanup;

    if ( context == CONTEXT_TYPE_Text && lCharCount > 0 )
    {
        hr = THR( mkptrEnd.Right ( TRUE, &context, NULL, &lCharCount, NULL, NULL ));
        if ( hr )
            goto Cleanup;        
    }

    hr = THR(Doc()->Remove ( &mkptrStart, &mkptrEnd, MUS_DOMOPERATION ));
    if ( hr )
        goto Cleanup;

    hr = THR(mkptrStart.Doc()->InsertText( & mkptrStart, bstrText, -1, MUS_DOMOPERATION ));
    if ( hr )
        goto Cleanup;
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_canHaveChildren(VARIANT_BOOL *pvb)
{
    *pvb = IsNoScope() ? VARIANT_FALSE : VARIANT_TRUE;
    return S_OK;
}

HRESULT
CElement::get_ownerDocument(IDispatch **ppretdoc)
{
    return OwnerDocHelper(ppretdoc, NULL, this);
}


HRESULT
CElement::normalize()
{
    HRESULT hr = S_OK;
    CDoc *pDoc = GetDocPtr();
    CMarkupPointer mkpStart(pDoc);
    CMarkupPointer mkpEnd(pDoc);        // Always positioned at just before the end of the element to normalize
    CMarkupPointer mkptxtend(pDoc);

    if(IsNoScope())
    {
        goto Cleanup;
    }

    hr = THR(mkpStart.MoveAdjacentToElement(this, ELEM_ADJ_AfterBegin));
    if (hr)
        goto Cleanup;
    
    hr = THR(mkpEnd.MoveAdjacentToElement(this, ELEM_ADJ_BeforeEnd));
    if (hr)
        goto Cleanup;

    hr = THR(mkptxtend.MoveToPointer(&mkpStart));
    if (hr)
        goto Cleanup;

    hr = THR(ScanText(pDoc, &mkpStart, &mkptxtend, &mkpEnd));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));

}

// Code for implementing IHTMLDOMNode for Document

HRESULT
CDocument::get_nodeType(long *pnodeType)
{
    
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pnodeType = _lnodeType;        // Get the actual node type

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_parentNode(IHTMLDOMNode **pparentNode)
{
    HRESULT hr = S_OK;

    if (!pparentNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pparentNode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::hasChildNodes(VARIANT_BOOL *p)
{
    return Markup()->Root()->hasChildNodes(p);
}

HRESULT
CDocument::get_childNodes(IDispatch **ppChildCollection)
{
    return Markup()->Root()->get_childNodes(ppChildCollection);
}

HRESULT
CDocument::get_attributes(IDispatch **ppAttrCollection)
{
    HRESULT hr = S_OK;

    if (!ppAttrCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppAttrCollection = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    return Markup()->Root()->insertBefore(pNewChild, refChild, ppRetNode);
}

HRESULT
CDocument::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, IHTMLDOMNode **ppRetNode)
{
    return Markup()->Root()->replaceChild(pNewChild, pOldChild, ppRetNode);
}

HRESULT
CDocument::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **pRetNode)
{
    return Markup()->Root()->removeChild(pOldChild, pRetNode);
}

HRESULT
CDocument::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeCloned)
{
    HRESULT         hr;
    CDoc *          pDoc = Doc();
    CMarkup *       pMarkupTarget = NULL;
    CDocument *     pDocument = NULL;

    *ppNodeCloned = NULL;
    hr = THR(pDoc->CreateMarkup(&pMarkupTarget, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;
    
    hr = THR(pMarkupTarget->SetOrphanedMarkup(TRUE));
    if( hr )
        goto Cleanup;

    Assert(!pMarkupTarget->HasDocument());
    hr = THR(pMarkupTarget->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    Assert(pDocument->_lnodeType == 9);
    pDocument->_lnodeType = 11; // document fragment

    if (fDeep)
    {
        CMarkupPointer mkptrStart ( pDoc );
        CMarkupPointer mkptrEnd ( pDoc );
        CMarkupPointer mkptrTarget ( pDoc );

        // Get src ptrs
        hr = THR(Markup()->Root()->GetMarkupPtrRange(&mkptrStart, &mkptrEnd));
        if (hr)
            goto Cleanup;

        // Get target ptr

        hr = THR(mkptrTarget.MoveToContainer(pMarkupTarget,TRUE));
        if (hr)
            goto Cleanup;

        // Copy src -> target
        hr = THR(pDocument->Doc()->Copy(&mkptrStart, &mkptrEnd, &mkptrTarget, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;
    }

    hr = THR(pDocument->QueryInterface(IID_IHTMLDOMNode, (void **)ppNodeCloned));
    if (hr)
        goto Cleanup;

Cleanup:

    // release extra markup lock
    if (pMarkupTarget)
        pMarkupTarget->Release();

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::removeNode (VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeRemoved)
{
    HRESULT hr = E_NOTIMPL;
    if (ppNodeRemoved)
        *ppNodeRemoved = NULL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::replaceNode(IHTMLDOMNode *pNodeReplace, IHTMLDOMNode **ppNodeReplaced)
{
    HRESULT hr = E_NOTIMPL;
    if (ppNodeReplaced)
        *ppNodeReplaced = NULL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::swapNode(IHTMLDOMNode *pNodeSwap, IHTMLDOMNode **ppNodeSwapped)
{
    HRESULT hr = E_NOTIMPL;
    if (ppNodeSwapped)
        *ppNodeSwapped = NULL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    return Markup()->Root()->appendChild(pNewChild, ppRetNode);
}

HRESULT
CDocument::get_nodeName(BSTR *pbstrNodeName)
{
    HRESULT hr = S_OK;

    if (!pbstrNodeName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrNodeName = NULL;
    
    if(_lnodeType == 9)
        hr = THR(FormsAllocString ( _T("#document"), pbstrNodeName ));
    else
    {
        Assert(_lnodeType == 11);
        hr = THR(FormsAllocString ( _T("#document-fragment"), pbstrNodeName ));
    }
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    pvarValue->vt = VT_NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::put_nodeValue(VARIANT varValue)
{
    HRESULT hr = S_OK;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_firstChild ( IHTMLDOMNode **ppNode )
{
    return Markup()->Root()->get_firstChild(ppNode);
}

HRESULT
CDocument::get_lastChild ( IHTMLDOMNode **ppNode )
{
    return Markup()->Root()->get_lastChild(ppNode);
}

HRESULT
CDocument::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    
    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_ownerDocument(IDispatch **ppretdoc)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;
    CDocument *pDocument;

    if( !ppretdoc )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppretdoc = NULL;

    if(_lnodeType == 11)
    {
        pMarkup = GetWindowedMarkupContext();
        Assert( pMarkup );        
        if(pMarkup->HasDocument())
        {
            Assert( pMarkup );
            pDocument = pMarkup->Document();
            Assert(pDocument);
            Assert(pDocument->_lnodeType == 9);
            hr = THR(pDocument->QueryInterface(IID_IDispatch, (void **)ppretdoc));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

// Methods for implemention IHTMLDocument5

HRESULT
CDocument::createAttribute(BSTR bstrAttrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    CAttribute *pAttribute = NULL;

    if(!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppAttribute = NULL;
    pAttribute = new CAttribute(NULL, DISPID_UNKNOWN, NULL, this);
    if (!pAttribute)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pAttribute->_cstrName.SetBSTR(bstrAttrName));
    if (hr)
        goto Cleanup;

    hr = THR(pAttribute->PrivateQueryInterface(IID_IHTMLDOMAttribute, (void **)ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pAttribute)
        pAttribute->Release();

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::getAttributeNode(BSTR bstrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr;
    AAINDEX aaIdx = AA_IDX_UNKNOWN;
    CAttribute *pAttribute = NULL;
    DISPID dispid;
    PROPERTYDESC *pPropDesc;

    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    hr = THR(GetIndexHelper(bstrName, &aaIdx, NULL, &dispid, &pPropDesc, this, 0));
    if (DISP_E_UNKNOWNNAME == hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        // No Attr Node, create new
        pAttribute = new CAttribute(pPropDesc, dispid, this);
        if (!pAttribute)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pAttribute->_cstrName.SetBSTR(bstrName));
        if (hr)
            goto Cleanup;

        hr = THR(AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttribute, CAttrValue::AA_DOMAttribute));
        if (hr)
            goto Cleanup;
    }
    else
    {
        IUnknown *pUnk;
        hr = THR(GetUnknownObjectAt(aaIdx, &pUnk));
        if (hr)
            goto Cleanup;

        pAttribute = (CAttribute *)pUnk;
    }

    Assert(pAttribute);
    hr = THR(pAttribute->QueryInterface(IID_IHTMLDOMAttribute, (void **)ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pAttribute)
        pAttribute->Release();

    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::setAttributeNode(IHTMLDOMAttribute *pAttrIn, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    CAttribute *pAttribute;
    AAINDEX aaIdx;
    AAINDEX vaaIdx;
    DISPID dispid;
    PROPERTYDESC *pPropDesc = NULL;
    
    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pAttrIn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    hr = THR(pAttrIn->QueryInterface(CLSID_CAttribute, (void **)&pAttribute));
    if (hr)
        goto Cleanup;

    if (pAttribute->_pElem)
    {
        // In use error.
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert((LPTSTR)(pAttribute->_cstrName));
    Assert(!pAttribute->_pElem);
    Assert(!pAttribute->_pPropDesc);
    Assert(pAttribute->_dispid == DISPID_UNKNOWN);

    hr = THR(RemoveAttrHelper(pAttribute->_cstrName, &pPropDesc, &dispid, &aaIdx, &vaaIdx, this, ppAttribute, fdexNameEnsure));
    if (hr)
        goto Cleanup;

    pAttribute->_pPropDesc = pPropDesc;
    pAttribute->_pElem = this;
    pAttribute->_dispid = dispid;
    SubAddRef();

    // Attr Node already exists?
    if (aaIdx == AA_IDX_UNKNOWN)
    {
        // No, set new one passed in
        hr = THR(AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttribute, CAttrValue::AA_DOMAttribute));
        if (hr)
            goto Cleanup;

        if (!pPropDesc)
        {
            hr = THR(UpdateDomAttrCollection(FALSE, dispid));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // Yes, replace it with passed in attr node
        CAttrArray *pAA = *GetAttrArray();
        VARIANT var;
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = (IUnknown *)(IPrivateUnknown *)pAttribute;
        Assert(pAA);
        hr = THR(pAA->SetAt(aaIdx, &var));
        if (hr)
            goto Cleanup;
    }
    
    // Need to set the new value now..

    if (!pAttribute->_varValue.IsEmpty())
    {
        hr = THR(PutNodeValueHelper(pAttribute, vaaIdx, pAttribute->_varValue));
        if (hr)
            goto Cleanup;

        hr = THR(pAttribute->_varValue.Clear());
        if (hr)
            goto Cleanup;
    }
    else
    {
        // Passed in Attr node doesn't have a value set yet
        if (vaaIdx != AA_IDX_UNKNOWN)
        {
            // But there is an existing value for this attr name, remove it.
            DeleteAt(vaaIdx);
        }

        // set default value of expando node to "undefined"
        if (!pPropDesc)
        {
            CVariant var; // initialized to VT_EMPTY to return undefined

            hr = THR(AddVariant(dispid, &var, CAttrValue::AA_Expando));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::removeAttributeNode(IHTMLDOMAttribute *pAttrRemove, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    CAttribute *pAttribute;
    
    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    if(!pAttrRemove)
        goto Cleanup;

    hr = THR(pAttrRemove->QueryInterface(CLSID_CAttribute, (void **)&pAttribute));
    if (hr)
        goto Cleanup;

    hr = THR(RemoveAttributeNode(pAttribute->_cstrName, ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::RemoveAttributeNode(LPTSTR pchAttrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    BOOL fUpdateDOMAttrColl = FALSE;
    CAttribute *pAttrNew = NULL;
    AAINDEX aaIdx;
    AAINDEX vaaIdx;
    DISPID dispid;
    PROPERTYDESC *pPropDesc;

    hr = THR(RemoveAttrHelper(pchAttrName, &pPropDesc, &dispid, &aaIdx, &vaaIdx, this, ppAttribute, 0));
    if (hr)
        goto Cleanup;

    // remove attrNode from this element's AA if it exists
    if (aaIdx != AA_IDX_UNKNOWN)
    {
        DeleteAt(aaIdx);
        fUpdateDOMAttrColl = TRUE;
    }

    if (vaaIdx != AA_IDX_UNKNOWN)
    {
        // There is an existing value for this attr name, remove it.
        DeleteAt(vaaIdx);
        fUpdateDOMAttrColl = TRUE;
    }

    if (pPropDesc)
    {
        // All non-expando attrs have a default value so replace removed node with new one.
        Assert(!IsExpandoDISPID(dispid));

        pAttrNew = new CAttribute(pPropDesc, dispid, this);
        if (!pAttrNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pAttrNew->_cstrName.Set(pchAttrName));
        if (hr)
            goto Cleanup;

        hr = THR(AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttrNew, CAttrValue::AA_DOMAttribute));
        if (hr)
            goto Cleanup;
    }
    else if (fUpdateDOMAttrColl)
    {
        Assert(!pPropDesc);
        hr = THR(UpdateDomAttrCollection(TRUE, dispid));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (pAttrNew)
        pAttrNew->Release();

    RRETURN(hr);
}

HRESULT
CDocument::createComment(BSTR data, IHTMLDOMNode **ppRetNode)
{
    HRESULT hr = S_OK;
    CCommentElement *pelComment = NULL;

    if(!ppRetNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pelComment = new CCommentElement(ETAG_RAW_COMMENT, Doc());
    if(!pelComment)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pelComment->_fAtomic = TRUE;

    hr = THR(pelComment->_cstrText.Set(_T("<!--"), 4));
    if( hr )
        goto Cleanup;

    hr = THR(pelComment->_cstrText.Append(data));
    if( hr )
        goto Cleanup;
    
    hr = THR(pelComment->_cstrText.Append(_T("-->"), 3));
    if( hr )
        goto Cleanup;

    hr = THR(pelComment->SetWindowedMarkupContextPtr(GetWindowedMarkupContext()));
    if( hr )
        goto Cleanup;

    pelComment->GetWindowedMarkupContextPtr()->SubAddRef();

    hr = THR(pelComment->PrivateQueryInterface(IID_IHTMLDOMNode, (void **)ppRetNode));
    if( hr )
        goto Cleanup;

Cleanup:
    if(pelComment)
        pelComment->Release();

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_doctype(IHTMLDOMNode **ppnode)
{
    HRESULT hr = S_OK;

    if(!ppnode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppnode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_implementation(IHTMLDOMImplementation **ppimplementation)
{
    HRESULT hr = S_OK;
    CDoc *pDoc = Doc();
    CDOMImplementation **pdomimpl = &pDoc->_pdomImplementation;

    if(!ppimplementation)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if(!*pdomimpl)
    {
        *pdomimpl = new CDOMImplementation(pDoc);
        if(!*pdomimpl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR((*pdomimpl)->QueryInterface(IID_IHTMLDOMImplementation, (void **)ppimplementation));
    if(hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));

}


// DOMImplementation


const CBase::CLASSDESC CDOMImplementation::s_classdesc =
{
    &CLSID_HTMLDOMImplementation,   // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif                              // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDOMImplementation,    // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

MtDefine(CDOMImplementation, Mem, "CDOMImplementation")

CDOMImplementation::CDOMImplementation(CDoc *pDoc)
{
    _pDoc = pDoc;
    _pDoc->SubAddRef();
}

void CDOMImplementation::Passivate()
{
    _pDoc->SubRelease();
    CBase::Passivate();
}

HRESULT
CDOMImplementation::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IHTMLDOMImplementation)
        QI_TEAROFF_DISPEX(this, NULL)
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}

HRESULT
CDOMImplementation::hasFeature(BSTR bstrFeature, VARIANT version, VARIANT_BOOL* pfHasFeature)
{
    HRESULT hr = S_OK;
    BSTR bstrVersion = NULL;

    if(!pfHasFeature)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pfHasFeature = VB_FALSE;

    switch (V_VT(&version))
    {
    case VT_BSTR:
        bstrVersion = V_BSTR(&version);
        break;

    case VT_NULL:
    case VT_ERROR:
    case VT_EMPTY:
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }   

    if(!_tcsicmp(bstrFeature, _T("HTML")))
    {
        if(bstrVersion && *bstrVersion)
        {
            if(!_tcsicmp(bstrVersion, _T("1.0")))
                *pfHasFeature = VB_TRUE;
        }
        else
            *pfHasFeature = VB_TRUE;

    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\dump.cxx ===
//+---------------------------------------------------------------------
//
//  File:       dump.cxx
//
//  Contents:   Diagnostic output routines
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#if DBG == 1 || defined(DUMPTREE)

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

DeclareTagOther(tagSaveDocOnDump, "TreeDump", "Save Doc in Tree Dump");
DeclareTagOther(tagSaveLBOnDump, "TreeDump", "Save LineBreaks in Tree Dump");
DeclareTagOther(tagDumpAlwaysOverwrite, "TreeDump", "Always create new file");
DeclareTagOther(tagDumpXML, "TreeDump", "Dump XML");

#define NODE_TYPE_BEGIN  -1
#define NODE_TYPE_NEUTRAL 0
#define NODE_TYPE_END     1

void
CMarkup::PrintNodeTag ( CTreeNode * pNode, int type )
{
    CElement * pElement = pNode->Element();
    
    if (type != NODE_TYPE_NEUTRAL)
    {
        if (type == NODE_TYPE_BEGIN)
            WriteHelp( g_f, _T("<<") );
        else
            WriteHelp( g_f, _T("<</") );
    }

    if (pElement->Namespace())
        WriteHelp( g_f, _T("<0s>:"), pElement->Namespace() );

    if (pNode->Tag() == ETAG_UNKNOWN)
        WriteHelp( g_f, _T("\"<0s>\""), pElement->TagName() );
    else
        WriteHelp( g_f, _T("<0s>"), pElement->TagName() );

    if (type != NODE_TYPE_NEUTRAL)
        WriteHelp( g_f, _T(">") );

    WriteHelp( g_f, _T(" [E<0d> N<1d>"), long( pElement->SN() ), pNode->SN() );

    if (pElement->_fBreakOnEmpty)
        WriteString( g_f, _T(",BreakOnEmpty"));

    WriteString( g_f, _T("]"));
}

void
CMarkup::PrintNode ( CTreeNode * pNode, BOOL fSimple, int type )
{
    PrintNodeTag( pNode, type );

    if (!fSimple)
    {
        WriteHelp( g_f, _T(" (") );

        WriteHelp(
            g_f, _T("ERefs=<0d>, EAllRefs=<1d>, <2d> <3d> <4d>"),
            (long)pNode->Element()->GetObjectRefs(), (long)pNode->Element()->GetRefs(),
            (long)pNode->_iCF, (long)pNode->_iPF, (long)pNode->_iFF);

        if (pNode->Parent())
        {
            WriteString( g_f, _T(", Parent = ") );

            PrintNodeTag( pNode->Parent() );
        }

        WriteString( g_f, _T(")") );
    }
}

void
CMarkup::DumpTree ( )
{
    if (IsTagEnabled(tagDumpXML))
    {
        DumpTreeInXML();
    }
    else
    {
        if (!InitDumpFile(IsTagEnabled(tagDumpAlwaysOverwrite)))
            return;

        DumpTreeWithMessage();

        CloseDumpFile();

        if( HasLogManager() )
        {
            GetLogManager()->DumpQueue();
        }
    }
}

void
CMarkup::DumpTreeOverwrite ( )
{
    if (!InitDumpFile(TRUE))
        return;

    DumpTreeWithMessage();

    CloseDumpFile();
}

void
DumpTreeOverwrite()
{
    if (g_pDebugMarkup)
        g_pDebugMarkup->DumpTreeOverwrite();
}

void 
CMarkup::SetDebugMarkup ( )
{ 
    g_pDebugMarkup = this; 
}


static void 
DumpFormat( FORMATETC * pfetc, TCHAR * szFormat, BOOL fUnicode )
{
#ifndef WIN16
    char          abBuf[256];
    ULONG         cbRead;
    HRESULT       hr;
    STGMEDIUM     medium = {TYMED_NULL, NULL, NULL};
    HGLOBAL       hglobal = NULL;
    LPSTREAM      pIStream = NULL;   // IStream pointer
    IDataObject*  pdo;               // Pointer to the data object on the clipboard

    WriteHelp(g_f, _T("----- FORMAT: <0s> -----\r\n"), szFormat);

    hr = OleGetClipboard(&pdo);
    if ( hr )
        goto Cleanup;

    hr = pdo->GetData(pfetc, &medium);
    if( hr )
        goto Cleanup;

    // STGFIX: t-gpease 8-13-97
    Assert(medium.tymed == TYMED_HGLOBAL);

    hglobal = medium.hGlobal;
    if( !GlobalLock(hglobal) )
    {
        hglobal = NULL;
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr  = THR(CreateStreamOnHGlobal(hglobal, FALSE, &pIStream));
    if (hr)
        goto Cleanup;

    while (S_OK == pIStream->Read(abBuf, ARRAY_SIZE(abBuf), &cbRead))
    {
        if (fUnicode)
        {
            TCHAR *     pchBuf;
            ULONG       cchLength;
            ULONG       cchRead = cbRead/2;

            for( pchBuf = (TCHAR*) abBuf, cchLength = 0;
                 cchLength < cchRead && *pchBuf;
                 pchBuf++, cchLength++ )
                ;

            if (!cchLength)
                break;

            WriteFileAnsi( g_f, abBuf, cchLength );

            if (cchLength < cchRead)
                break;
        }
        else
        {
            char *        pbBuf;
            ULONG         cchLength;
            TCHAR         achBuffer[256];
            long          cchWideChar;

            for (pbBuf = abBuf, cchLength = 0;
                 cchLength < cbRead && *pbBuf;
                 pbBuf++, cchLength++);

            if (!cchLength)
                break;

            cchWideChar = MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    abBuf,
                    cchLength,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));

            Assert(cchWideChar > 0);

            WriteFileAnsi( g_f, achBuffer, cchWideChar );

            if (cchLength < cbRead)
                break;
        }
    }

    WriteString( g_f, _T("\r\n") );

Cleanup:

    ReleaseInterface(pIStream);

    if(hglobal)
    {
        GlobalUnlock(hglobal);
    }

    ReleaseStgMedium(&medium);

    pdo->Release();
#endif //!WIN16
}

void
CMarkup::DumpClipboardText( )
{
#ifndef WIN16
    if( !InitDumpFile())
        goto Cleanup;

    WriteString(g_f, _T("----- DUMP OF CLIPBOARD CONTENTS -----\r\n"));

    DumpFormat( &g_rgFETC[iHTML], _T("CF_HTML"), FALSE );
//    DumpFormat( &g_rgFETC[iRtfFETC], _T("RTF") );
    DumpFormat( &g_rgFETC[iUnicodeFETC], _T("Unicode plain text"), TRUE );
    DumpFormat( &g_rgFETC[iAnsiFETC], _T("ANSI plain text"), FALSE );

    WriteString(g_f, _T("----- END DUMP OF CLIPBOARD CONTENTS -----\r\n\r\n"));

Cleanup:
    CloseDumpFile( );
#endif //!WIN16
}

static void DumpNumber ( int n )
{
    if (n < 10)
        WriteHelp( g_f, _T("   ") );
    else if (n < 100)
        WriteHelp( g_f, _T("  ") );
    else if (n < 1000)
        WriteHelp( g_f, _T(" ") );
        
    WriteHelp( g_f, _T("<0d>"), long( n ) );
}

static void DumpSerialNumber ( TCHAR * pchType, int n )
{
    WriteHelp( g_f, _T("[<0s>"), pchType );
    DumpNumber( n );
    WriteHelp( g_f, _T("]") );
}

void
CMarkup::DumpTextTreePos ( CTreePos * ptpCurr )
{
    long cch;

    cch = ptpCurr->Cch();

    WriteString( g_f, _T("  ") );
    
    WriteString( g_f, _T("'") );
    
    if (cch)
    {
        CTxtPtr rpTX(this);
        TCHAR chBuff [ 30 ];
        long cpCurr = ptpCurr->GetCp();
        BOOL fNotEnoughCharacters = FALSE;

        if( cpCurr + cch > rpTX.GetTextLength() )
        {
            cch = rpTX.GetTextLength() - cpCurr;
            fNotEnoughCharacters = TRUE;
        }

        
        if(cch > 0)
        {
            rpTX.BindToCp(cpCurr);

            if (cch <= ARRAY_SIZE( chBuff ))
            {
                rpTX.GetRawText( cch, chBuff );

                WriteFormattedString( g_f, chBuff, cch );
            }
            else
            {
                long cchDiv2 = ARRAY_SIZE( chBuff ) / 2;

                rpTX.GetRawText( cchDiv2, chBuff );

                WriteFormattedString( g_f, chBuff, cchDiv2 );

                WriteString( g_f, _T( "..." ) );

                rpTX.AdvanceCp( cch - cchDiv2 );

                rpTX.GetRawText( cchDiv2, chBuff );

                WriteFormattedString( g_f, chBuff, cchDiv2 );

                rpTX.AdvanceCp( - (cch - cchDiv2) );
            }
        }


        if (fNotEnoughCharacters)
        {
            WriteString( g_f, _T(", Not enough text in the story") );
        }
    }
    
    WriteString( g_f, _T("'"));
    
    WriteHelp( g_f, _T(", _sid(<0s>)"), SidName( ptpCurr->Sid() ) );

    if( ptpCurr->TextID() )
    {
        WriteHelp( g_f, _T(", _lTextID(<0d>)"), long( ptpCurr->TextID() ) );
    }
}

void
CMarkup::DumpTreeWithMessage ( TCHAR * szMessage )
{
    if (szMessage && szMessage[0])
        WriteHelp( g_f, _T("<0s>\r\n\r\n"), szMessage );

    if (IsTagEnabled(tagSaveDocOnDump))
    {
        //
        // Print out the saved version of the tree
        //

        HGLOBAL     hg;
        IStream *   pStm;

        THR(CreateStreamOnHGlobal(NULL, TRUE, &pStm));
        {
            SaveToStream( pStm, 0, CP_1252 );
        }

        THR(GetHGlobalFromStream(pStm, &hg));

        if (hg)
        {
            long nChars = GlobalSize( hg );

            char * pChar = (char *) GlobalLock( hg );

            for ( ; nChars > 0 ; nChars--, pChar++ )
            {
                WriteChar(g_f, *pChar);
            }

            GlobalUnlock( hg );
            GlobalFree( hg );
        }

        WriteString( g_f, _T("\r\n\r\n"));
    }

    CTreePos * ptpCurr = FirstTreePos();
    CLineBreakCompat * pLineBreaks = NULL;
    CTreePosGap tpg;
    MarkupTextFrag *ptf = NULL;
    long            ctf = 0;

    if (IsTagEnabled(tagSaveLBOnDump))
    {
        pLineBreaks = new CLineBreakCompat;
    }

    if (HasTextFragContext())
    {
        CMarkupTextFragContext * ptfc = GetTextFragContext();

        Assert( ptfc );

        ctf = ptfc->_aryMarkupTextFrag.Size();
        ptf = ptfc->_aryMarkupTextFrag;
    }
        
    WriteHelp(
        g_f, _T("Tree Dump For Markup: M<0d>, TreeVer=<1d>, ContentsVer=<2d>"),
        SN(), GetMarkupTreeVersion(), GetMarkupContentsVersion() );

    WriteHelp( g_f, _T(" Cch = <0d>" ), long( GetTextLength() ) );
    

    WriteString( g_f, _T("\r\n\r\n") );
    if (pLineBreaks)
        WriteString( g_f, _T("Type   Pos   Cp  Cch Brk\r\n") );
    else
        WriteString( g_f, _T("Type   Pos   Cp  Cch\r\n") );


    while (ptpCurr)
    {
        long cch = 999;
        long depth = 0;
        
        switch( ptpCurr->Type() )
        {
        case CTreePos::NodeBeg :
            WriteHelp( g_f, _T("Begin ") );
            cch = ptpCurr->GetCch();
            depth = ptpCurr->Branch()->Depth();
            break;
            
        case CTreePos::NodeEnd :
            WriteHelp( g_f, _T("End   ") );
            cch = ptpCurr->GetCch();
            depth = ptpCurr->Branch()->Depth();
            break;
            
        case CTreePos::Text    :
            WriteHelp( g_f, _T("Text  ") );
            cch = ptpCurr->Cch();
            depth = ptpCurr->GetInterNode()->Depth();
            break;
            
        case CTreePos::Pointer :
            cch = 0;
            depth = ptpCurr->GetInterNode()->Depth();
            WriteString( g_f, _T("Ptr ") );
            WriteString( g_f, ptpCurr->Gravity() == POINTER_GRAVITY_Left ? _T("<") : _T(">") );
            WriteString( g_f, ptpCurr->Cling() ? _T("*") : _T(" ") );
            break;
            
        default:
            AssertSz( 0, "Yikes!" );
        }

        DumpNumber( ptpCurr->_nSerialNumber );
        
        WriteHelp( g_f, _T(" ") );

        if (cch > 0)
            DumpNumber( ptpCurr->GetCp() );
        else
            WriteHelp( g_f, _T("   -") );
        
        WriteHelp( g_f, _T(" ") );
        
        if (ptpCurr->Type() == CTreePos::NodeBeg || ptpCurr->Type() == CTreePos::NodeEnd)
        {
            if( ptpCurr->IsEdgeScope() )
                WriteHelp( g_f, _T("   *") );
            else
                WriteHelp( g_f, _T("   -") );
        }
        else if (cch > 0 || ptpCurr->Type() == CTreePos::Text)
            DumpNumber( cch );
        else
            WriteHelp( g_f, _T("   -") );

        if (pLineBreaks)
        {
            WriteHelp( g_f, _T(" ") );
            
            if (ptpCurr->Type() == CTreePos::NodeBeg || ptpCurr->Type() == CTreePos::NodeEnd)
            {
                DWORD dwBreaks = BREAK_NONE;

                if (pLineBreaks && ptpCurr->Branch()->Tag() != ETAG_ROOT)
                {
                    tpg.MoveTo( ptpCurr, TPG_LEFT );
            
                    IGNORE_HR( pLineBreaks->QueryBreaks( & tpg, & dwBreaks ) );
                }


                WriteHelp( g_f, (dwBreaks & BREAK_BLOCK_BREAK) ? _T("B") : _T(" ") );
                WriteHelp( g_f, (dwBreaks & BREAK_SITE_BREAK)  ? _T("S") : _T(" ") );
                WriteHelp( g_f, (dwBreaks & BREAK_SITE_END)    ? _T("E") : _T(" ") );
            }
            else
            {
                WriteHelp( g_f, _T("   ") );
            }
        }
        
        WriteHelp( g_f, _T(" | ") );

        for ( int i = depth - 1 ; i > 0 ;i-- )
            WriteString( g_f, _T("  "));
        
        switch( ptpCurr->Type() )
        {
        case CTreePos::NodeBeg :
        case CTreePos::NodeEnd :
            PrintNode(
                ptpCurr->Branch(), 
                ! ptpCurr->IsBeginNode(),
                ptpCurr->IsEdgeScope()
                    ? (ptpCurr->IsBeginNode() 
                        ? NODE_TYPE_BEGIN 
                        : NODE_TYPE_END) 
                    : NODE_TYPE_NEUTRAL );

            if (CTxtPtr( this, ptpCurr->GetCp() ).GetChar() != WCH_NODE)
            {
                TCHAR ch = CTxtPtr( this, ptpCurr->GetCp() ).GetChar();
                WriteString( g_f, _T(" '") );
                WriteFormattedString( g_f, & ch, 1 );
                WriteString( g_f, _T("'") );
            }

            break;
            
        case CTreePos::Text    :
            DumpTextTreePos(ptpCurr);
            break;
            
        case CTreePos::Pointer :
                
            WriteHelp( g_f, _T("  <<=== "));

            if (ctf > 0 && ptf->_ptpTextFrag == ptpCurr)
            {
                TCHAR chBuff [ 30 ];
                long  cchTextFrag = _tcslen(ptf->_pchTextFrag);

                Assert( !ptpCurr->MarkupPointer() );

                WriteHelp( g_f, _T("TextFrag: '") );

                if (cchTextFrag <= ARRAY_SIZE( chBuff ))
                {
                    WriteFormattedString( g_f, ptf->_pchTextFrag, cchTextFrag );
                }
                else
                {
                    long cchDiv2 = ARRAY_SIZE( chBuff ) / 2;

                    _tcsncpy(chBuff, ptf->_pchTextFrag, cchDiv2);

                    WriteFormattedString( g_f, chBuff, cchDiv2 );

                    WriteString( g_f, _T( "..." ) );

                    _tcsncpy( chBuff, ptf->_pchTextFrag + cchTextFrag - cchDiv2, cchDiv2 );

                    WriteFormattedString( g_f, chBuff, cchDiv2 );
                }

                WriteHelp( g_f, _T("'") );

                ctf--;
                ptf++;
            }
            else
            {
                CMarkupPointer * pmp = ptpCurr->MarkupPointer();
                TCHAR *pchCollapsedWhitespace = ptpCurr->GetCollapsedWhitespace();
            
                if (pmp)
                {
                    WriteHelp( g_f, _T(" P<0d>"), pmp->SN() );

                    if (pmp->CpIsCached())
                        WriteHelp( g_f, _T(" cp=<0d>, ver=<1d>"), pmp->_cpCache, pmp->_verCp );

                    if (LPTSTR( pmp->_cstrDbgName ))
                        WriteHelp( g_f, _T(" <0s>"), LPTSTR( pmp->_cstrDbgName ) );
                }

                if (pchCollapsedWhitespace)
                {                    
                    WriteString( g_f, _T( "[" ) );
                    WriteFormattedString( g_f, pchCollapsedWhitespace, _tcslen(pchCollapsedWhitespace) );
                    WriteString( g_f, _T( "]" ) );
                }
            break;
        }
        }
        
        WriteString( g_f, _T("\r\n"));

        CMarkupPointer * pmp;

        for ( pmp = _pmpFirst ; pmp ; pmp = pmp = pmp->_pmpNext )
        {
            Assert( ! pmp->_fEmbedded );
            
            if (pmp->_ptpRef != ptpCurr)
                continue;

            WriteString( g_f, _T("ptr ") );
            WriteString( g_f, pmp->Gravity() == POINTER_GRAVITY_Left ? _T("<") : _T(">") );
            WriteString( g_f, pmp->Cling() ? _T("*") : _T(" ") );
            
            if (IsTagEnabled(tagSaveLBOnDump))
                WriteString( g_f, _T("   -    -    -     | "));
            else
                WriteString( g_f, _T("   -    -    - | "));

            for ( i = depth - 1 ; i > 0 ;i-- )
                WriteString( g_f, _T("  "));

            if (ptpCurr->IsText())
            {
                for ( i = 0 ; i < pmp->_ichRef ; i++ )
                    WriteHelp( g_f, _T(" ") );
            
                WriteHelp( g_f, _T("   ^===") );
            }
            else
            {
                WriteHelp( g_f, _T("^===") );
            }

            WriteHelp( g_f, _T(" ") );
            
            WriteHelp( g_f, _T("  P<0d>"), pmp->SN() );

            if (pmp->CpIsCached())
                WriteHelp( g_f, _T("  cp=<0d>, ver=<1d>"), pmp->_cpCache, pmp->_verCp );
            
            WriteHelp( g_f, _T(" ich=<0d>"), pmp->_ichRef );

            if (LPTSTR( pmp->_cstrDbgName ))
                WriteHelp( g_f, _T(" <0s>"), LPTSTR( pmp->_cstrDbgName ) );
            
            WriteString( g_f, _T("\r\n"));
        }

        ptpCurr = ptpCurr->NextTreePos();
    }
    
    WriteString( g_f, _T("\r\n"));

    if (pLineBreaks)
        delete pLineBreaks;
}

void __cdecl WriteXMLTagBegin( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fCR, TCHAR *pchFormat, ...);
void WriteXMLTagEnd( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fDoIndent = FALSE, BOOL fCR = TRUE );
void __cdecl WriteXMLNoScope( HANDLE hFile, int &nIndex, TCHAR *pchTagName, TCHAR *pchFormat, ... );
void __cdecl WriteXMLElement( HANDLE hFile, int &nIndent, TCHAR *pchTagName, TCHAR *pchFormat, ... );
void WriteXMLFormattedString( HANDLE hFile, TCHAR * pch, long cch );

void 
__cdecl
WriteXMLTagBegin( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fCR, TCHAR *pchFormat, ...)
{
    va_list arg;

    va_start( arg, pchFormat );

    WriteChar( hFile, _T(' '), nIndent );
    WriteHelp( hFile, _T("<<<0s>"), pchTagName );

    if (pchFormat)
    {
        WriteChar( hFile, _T(' ') );
        WriteHelpV( hFile, pchFormat, &arg );
    }

    WriteChar( hFile, _T('>') );
    
    if (fCR)
        WriteString( hFile, _T("\r\n") );

    nIndent++;
}

void 
WriteXMLTagEnd( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fDoIndent, BOOL fCR)
{
    nIndent--;

    if (fDoIndent)
        WriteChar( hFile, _T(' '), nIndent );

    WriteHelp( hFile, _T("<</<0s>>"), pchTagName );
    
    if (fCR)
        WriteString( hFile, _T("\r\n") );
}

void 
__cdecl
WriteXMLNoScope( HANDLE hFile, int &nIndent, TCHAR *pchTagName, TCHAR *pchFormat, ... )
{
    va_list arg;

    va_start( arg, pchFormat );

    WriteChar( hFile, _T(' '), nIndent );
    WriteHelp( hFile, _T("<<<0s>"), pchTagName );

    if (pchFormat)
    {
        WriteChar( hFile, _T(' ') );
        WriteHelpV( hFile, pchFormat, &arg );
    }
    
    WriteString( hFile, _T("/>\r\n") );
}


void 
__cdecl
WriteXMLElement( HANDLE hFile, int &nIndent, TCHAR *pchTagName, TCHAR *pchFormat, ... )
{
    va_list arg;

    va_start( arg, pchFormat );

    WriteXMLTagBegin( hFile, nIndent, pchTagName, FALSE, NULL );

    if (pchFormat)
        WriteHelpV( hFile, pchFormat, &arg );

    WriteXMLTagEnd( hFile, nIndent, pchTagName );
}

void 
WriteXMLFormattedString( HANDLE hFile, TCHAR * pch, long cch )
{
    if (!pch)
        return;

    for ( int i = 0 ; i < cch ; i++ )
    {
        TCHAR ch = pch[i];

        if (ch >= 1 && ch <= 26)
        {
            if (ch == _T('\r'))
                WriteString( hFile,  _T("\\r"));
            else if (ch == _T('\n'))
                WriteString( hFile, _T("\\n"));
            else
            {
                WriteHelp( hFile, _T("[<0d>]"), (long)int(ch) );
            }
        }
        else
        {
            switch ( ch )
            {
            case 0 :
                WriteString( hFile, _T("[NULL]"));
                break;

            case _T('<'):
                WriteString( hFile, _T("&lt;"));
                break;

            case _T('>'):
                WriteString( hFile, _T("&gt;"));
                break;

            case _T('&'):
                WriteString( hFile, _T("&amp;"));
                break;

            case WCH_NODE:
                WriteString( hFile, _T("[Node]"));
                break;

            case WCH_NBSP :
                WriteString( hFile, _T("[NBSP]"));
                break;

            default :
                if (ch < 256 && _istprint(ch))
                {
                    WriteChar(hFile, ch);
                }
                else
                {
                    TCHAR achHex[9];

                    Format( 0, achHex, ARRAY_SIZE(achHex), _T("<0x>"), ch);

                    StrCpy( achHex, TEXT("[U+") );
                    StrCpy( achHex + 3, achHex + 4 );
                    StrCpy( achHex + 7, TEXT("]") );

                    WriteString( hFile, achHex );
                }

                break;
            }
        }
    }
}

void
CMarkup::DumpTreeInXML ( )
{
    HANDLE  hFile = 0;
    int     nIndent = 0;

    // TODO: I don't handle unembeded pointers yet.
    Verify( ! EmbedPointers() );

    hFile = CreateFile(
            _T("c:\\tridump.xml"),
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        AssertSz(0, "CreateFile failed for DumpTreeInXML");
        return;
    }

    // Write out the root XML element
    WriteXMLTagBegin( hFile, nIndent, _T("Markup"), TRUE, NULL );

    WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), SN() );
    WriteXMLElement( hFile, nIndent, _T("Length"), _T("<0d>"), long( GetTextLength() ) );

    // Walk the tree, dumping info for each tree pos
    WriteXMLTagBegin( hFile, nIndent, _T("TreePoses"), TRUE, NULL );

    {
        CTreePos * ptp;

        ptp = FirstTreePos();

        while(ptp)
        {
            switch (ptp->Type())
            {
            case CTreePos::NodeBeg:
            case CTreePos::NodeEnd:
                {
                    TCHAR * pchType;

                    if (ptp->IsBeginNode())
                        pchType = _T("NodeBeg");
                    else
                        pchType = _T("NodeEnd");

                    WriteXMLTagBegin( hFile, nIndent, pchType, TRUE, NULL );

                    WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), ptp->SN() );
                    if (ptp->IsEdgeScope())
                        WriteXMLNoScope( hFile, nIndent, _T("Edge"), NULL );
                    WriteXMLElement( hFile, nIndent, _T("NodeSN"), _T("<0d>"), ptp->Branch()->SN() );

                    WriteXMLTagEnd( hFile, nIndent, pchType, TRUE );
                }

                break;
            case CTreePos::Text:
                WriteXMLTagBegin( hFile, nIndent, _T("Text"), TRUE, NULL );

                WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), ptp->SN() );
                WriteXMLElement( hFile, nIndent, _T("Length"), _T("<0d>"), ptp->Cch() );
                WriteXMLElement( hFile, nIndent, _T("ScriptID"), _T("<0s>"), SidName( ptp->Sid() ) );
                if (ptp->TextID())
                    WriteXMLElement( hFile, nIndent, _T("TextID"), _T("<0d>"), ptp->TextID() );

                WriteXMLTagBegin( hFile, nIndent, _T("Content"), FALSE, NULL );
                {
                    TCHAR * pch;
                    long    cch = ptp->Cch();
                    long    cp = ptp->GetCp();
                    CTxtPtr tp(this, cp);

                    pch = (TCHAR*)MemAlloc(Mt(Mem), sizeof(TCHAR)*cch);
                    Assert(pch);

                    Assert( cch == tp.GetRawText( cch, pch ) );

                    WriteXMLFormattedString( hFile, pch, cch );

                    MemFree( pch );
                }

                WriteXMLTagEnd( hFile, nIndent, _T("Content"), FALSE );

                WriteXMLTagEnd( hFile, nIndent, _T("Text"), TRUE );

                break;
            case CTreePos::Pointer:
                {
                    CMarkupPointer * pmp = ptp->MarkupPointer();
                    LPTSTR pchDbgName = pmp ? LPTSTR( pmp->_cstrDbgName ) : NULL;

                    WriteXMLTagBegin( hFile, nIndent, _T("Pointer"), TRUE, NULL );

                    WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), ptp->SN() );
                    WriteXMLElement( hFile, nIndent, _T("Gravity"), _T("<0s>"), ptp->Gravity() ? _T("Right") : _T("Left") );
                    if (ptp->Cling())
                        WriteXMLNoScope( hFile, nIndent, _T("Cling"), NULL );
                    if (pchDbgName)
                        WriteXMLElement( hFile, nIndent, _T("DebugName"), _T("<0s>"), pchDbgName );

                    WriteXMLTagEnd( hFile, nIndent, _T("Pointer"), TRUE );
                }
                break;
            }

            ptp = ptp->NextTreePos();
        }
    }
    WriteXMLTagEnd( hFile, nIndent, _T("TreePoses"), TRUE );

    // Walk the tree, dumping info for each tree node
    WriteXMLTagBegin( hFile, nIndent, _T("TreeNodes"), TRUE, NULL );
    {
        CTreePos * ptp;

        ptp = FirstTreePos();

        while(ptp)
        {
            if (ptp->IsBeginNode())
            {
                CTreeNode * pNode = ptp->Branch();
                CElement * pElement = pNode->Element();

                WriteXMLTagBegin( hFile, nIndent, _T("Node"), TRUE, NULL );

                WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), pNode->SN() );
                if (!pNode->IsLastBranch())
                    WriteXMLElement( hFile, nIndent, _T("NextBranchSN"), _T("<0d>"), pNode->NextBranch()->SN() );
                if (!pNode->IsFirstBranch())
                    WriteXMLElement( hFile, nIndent, _T("PreviousBranchSN"), _T("<0d>"), pNode->PreviousBranch()->SN() );
                if (pNode->Parent())
                    WriteXMLElement( hFile, nIndent, _T("ParentSN"), _T("<0d>"), pNode->Parent()->SN() );
                if (pNode->_iCF != -1)
                    WriteXMLElement( hFile, nIndent, _T("CharFormat"), _T("<0d>"), pNode->_iCF );
                if (pNode->_iPF != -1)
                    WriteXMLElement( hFile, nIndent, _T("ParaFormat"), _T("<0d>"), pNode->_iPF );
                if (pNode->_iFF != -1)
                    WriteXMLElement( hFile, nIndent, _T("FancyFormat"), _T("<0d>"), pNode->_iFF );
                WriteXMLElement( hFile, nIndent, _T("ElementSN"), _T("<0d>"), pElement->SN() );
                WriteXMLElement( hFile, nIndent, _T("BeginPosSN"), _T("<0d>"), pNode->GetBeginPos()->SN() );
                WriteXMLElement( hFile, nIndent, _T("EndPosSN"), _T("<0d>"), pNode->GetEndPos()->SN() );

                WriteXMLTagEnd( hFile, nIndent, _T("Node"), TRUE );
            }

            ptp = ptp->NextTreePos();
        }
    }
    WriteXMLTagEnd( hFile, nIndent, _T("TreeNodes"), TRUE );

    // Walk the tree, dumping info for each element
    WriteXMLTagBegin( hFile, nIndent, _T("Elements"), TRUE, NULL );
    {
        CTreePos * ptp;

        ptp = FirstTreePos();

        while(ptp)
        {
            if (ptp->IsBeginElementScope())
            {
                CTreeNode * pNode = ptp->Branch();
                CElement * pElement = pNode->Element();

                WriteXMLTagBegin( hFile, nIndent, _T("Element"), TRUE, NULL );

                WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), pElement->SN() );
                WriteXMLElement( hFile, nIndent, _T("TagName"), _T("<0s>"), pElement->TagName() );
                if (pElement->Namespace())
                    WriteXMLElement( hFile, nIndent, _T("Namespace"), _T("<0s>"), pElement->Namespace() );
                if (pElement->Tag() == ETAG_UNKNOWN)
                    WriteXMLNoScope( hFile, nIndent, _T("Unknown"), NULL );
                if (pElement->_fBreakOnEmpty)
                    WriteXMLNoScope( hFile, nIndent, _T("BreakOnEmpty"), NULL );

                WriteXMLTagBegin( hFile, nIndent, _T("ElementNodes"), TRUE, NULL );
                {
                    CTreeNode * pNode = pElement->GetFirstBranch();
                    while( pNode )
                    {
                        WriteXMLElement( hFile, nIndent, _T("NodeSN"), _T("<0d>"), pNode->SN() );
                        pNode = pNode->NextBranch();
                    }
                }
                WriteXMLTagEnd( hFile, nIndent, _T("ElementNodes"), TRUE );
                

                WriteXMLTagEnd( hFile, nIndent, _T("Element"), TRUE );
            }

            ptp = ptp->NextTreePos();
        }
    }
    WriteXMLTagEnd( hFile, nIndent, _T("Elements"), TRUE );

    // Write out the end of the root XML element
    WriteXMLTagEnd( hFile, nIndent, _T("Markup"), TRUE );

    CloseHandle( hFile );    
}

void
CMarkup::DumpTextChanges ( )
{
    if (!InitDumpFile())
        return;

    WriteString( g_f, _T("Text Change Dump For ped: " ) );

    WriteHelp( g_f, _T("Tree Dump For Markup: M<0d>"), SN() );

    //
    //  TODO: Do this through a DEBUG only notification sent through the tree
    //  TODO: Make this routine into "dump dirty ranges" and have all things
    //        that track ranges respond (e.g., collections, CFlowLayout).
    //

    WriteString( g_f, _T("Unimplemented"));

    WriteString( g_f, _T("\r\n\r\n") );

    CloseDumpFile();
}

void
CMarkup::DumpSplayTree(CTreePos *ptpStart, CTreePos *ptpFinish)
{
    if (!InitDumpFile())
        return;

    if (ptpStart == NULL)
        ptpStart = FirstTreePos();
    if (ptpFinish == NULL)
        ptpFinish = LastTreePos();

    CTreePos *ptpCurr = ptpStart;
    long cDepth = ptpCurr->Depth();

    // for each TreePos in the desired range...
    for (;;)
    {
        // print structure
        for (long i=0; i<cDepth-1; ++i)
            WriteString(g_f, _T("  "));

        if (cDepth > 0)
            WriteString(g_f, ptpCurr->IsLeftChild() ? _T("v ") : _T("^ "));

        // print content
        switch (ptpCurr->Type())
        {
        case CTreePos::NodeBeg:
        case CTreePos::NodeEnd:
            WriteChar(g_f, _T('N'));
            WriteChar(g_f, ptpCurr->IsBeginNode() ? _T('+') : _T('-'));
            if (ptpCurr->IsEdgeScope())
                WriteChar(g_f, _T('*'));
            WriteHelp(g_f, _T(" <0s> <1x>"), ptpCurr->Branch()->Element()->TagName(), ptpCurr->Branch());
            break;
        case CTreePos::Text:
            WriteChar(g_f, _T('T'));
            WriteHelp(g_f, _T("<0d> "), ptpCurr->Cch());
            break;
        case CTreePos::Pointer:
            WriteChar(g_f, _T('P'));
            break;
        }

        // finish printing
        WriteHelp(g_f, _T("  <0x>\r\n"), ptpCurr);

        // terminate loop
        if (ptpCurr == ptpFinish)
            break;

        // advance to next TreePos
        CTreePos *ptpChild = ptpCurr->RightChild();
        if (ptpChild)
        {
            while (ptpChild)
            {
                ++ cDepth;
                ptpCurr = ptpChild;
                ptpChild = ptpCurr->LeftChild();
            }
        }
        else
        {
            while (!ptpCurr->IsLeftChild())
            {
                -- cDepth;
                ptpCurr = ptpCurr->Parent();
            }
            -- cDepth;
            ptpCurr = ptpCurr->Parent();
        }
    }

    CloseDumpFile();
}
#endif


#if DBG==1
void
CMarkup::DumpDisplayTree()
{
    Doc()->GetView()->DumpDisplayTree();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\element3.cxx ===
//+---------------------------------------------------------------------
//
//   File:      element3.cxx
//
//  Contents:   Element class related member functions
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif


#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_IEXTAG_HXX_
#define X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X__IME_H_
#define X__IME_H_
#include "_ime.h"
#endif

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_SCROLLBARCONTROLLER_HXX_
#define X_SCROLLBARCONTROLLER_HXX_
#include "scrollbarcontroller.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(CElement_pAccels, PerProcess, "CElement::_pAccels")
MtDefine(CElementGetNextSubDivision_pTabs, Locals, "CElement::GetNextSubdivision pTabs")
MtDefine(CLayoutAry, CLayout, "CLayoutAry::_pv")

ExternTag(tagMsoCommandTarget);
ExternTag(tagNotifyPath);
ExternTag(tagLayoutTrackMulti);

DeclareTag(tagEdImm, "Edit", "IMM association and IME controls");

extern DWORD GetBorderInfoHelper(CTreeNode * pNode,
                                CDocInfo * pdci,
                                CBorderInfo * pbi,
                                DWORD dwFlags
                                FCCOMMA FORMAT_CONTEXT FCPARAM);
extern HRESULT CreateImgDataObject(
                 CDoc            * pDoc,
                 CImgCtx         * pImgCtx,
                 CBitsCtx        * pBitsCtx,
                 CElement        * pElement,
                 CGenDataObject ** ppImgDO);

extern IActiveIMMApp * GetActiveIMM();
extern HIMC ImmGetContextDIMM(HWND hWnd);


//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetBorderInfo
//
//  Synopsis:   get the elements border information.
//
//  Arguments:  pdci        - Current CDocInfo
//              pborderinfo - pointer to return the border information
//              fAll        - (FALSE by default) return all border related
//                            related information (border style's etc.),
//                            if TRUE
//
//  Returns:    0 - if no borders
//              1 - if simple border (all sides present, all the same size)
//              2 - if complex border (present, but not simple)
//
//----------------------------------------------------------------------------
DWORD
CElement::GetBorderInfo(
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fAll,
    BOOL            fAllPhysical
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD dwFlags = GBIH_NONE;
    DWORD retVal;
    BOOL  fObjectHasBorderAttribute = FALSE;
    
    if(fAll)
        dwFlags |= GBIH_ALL;

    dwFlags |= GBIH_ALLPHY;
    
    // We need to emulate the CSS border info fo OBJECT tags that have the border Attribute set
    // If both border attribute is set and the tag has border set usign CSS we ignore the border
    //    attribute
    if(Tag() == ETAG_OBJECT)
    {
        CUnitValue   uvBorder  = (DYNCAST(CObjectElement, this))->GetAAborder();

        if(!uvBorder.IsNull())
        {
            long lWidth = uvBorder.GetPixelValue();
            pborderinfo->aiWidths[0] = lWidth;
            pborderinfo->aiWidths[1] = lWidth;
            pborderinfo->aiWidths[2] = lWidth;
            pborderinfo->aiWidths[3] = lWidth;
            pborderinfo->abStyles[0] = fmBorderStyleSingle;
            pborderinfo->abStyles[1] = fmBorderStyleSingle;
            pborderinfo->abStyles[2] = fmBorderStyleSingle;
            pborderinfo->abStyles[3] = fmBorderStyleSingle;
            pborderinfo->wEdges = BF_RECT;

            fObjectHasBorderAttribute = TRUE;
        }
    }

    retVal = GetBorderInfoHelper(GetFirstBranch(), pdci, pborderinfo, dwFlags FCCOMMA FCPARAM);

    if(fObjectHasBorderAttribute &&  retVal == DISPNODEBORDER_NONE)
        retVal = DISPNODEBORDER_SIMPLE;

    if (!fAllPhysical && HasVerticalLayoutFlow())
    {
        pborderinfo->FlipBorderInfo();
    }
    return retVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFirstCp
//
//  Synopsis:   Get the first character position of this element in the text
//              flow. (relative to the Markup)
//
//  Returns:    LONG        - start character position in the flow. -1 if the
//                            element is not found in the tree
//
//----------------------------------------------------------------------------
long
CElement::GetFirstCp()
{
    CTreePos *  ptpStart;

    GetTreeExtent( &ptpStart, NULL );

    return ptpStart ? ptpStart->GetCp() + 1 : -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetLastCp
//
//  Synopsis:   Get the last character position of this element in the text
//              flow. (relative to the Markup)
//
//  Returns:    LONG        - end character position in the flow. -1 if the
//                            element is not found in the tree
//
//----------------------------------------------------------------------------
long
CElement::GetLastCp()
{
    CTreePos *  ptpEnd;

    GetTreeExtent( NULL, &ptpEnd );

    return ptpEnd ? ptpEnd->GetCp() : -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFirstAndLastCp
//
//  Synopsis:   Get the first and last character position of this element in
//              the text flow. (relative to the Markup)
//
//  Returns:    no of characters influenced by the element, 0 if the element
//              is not found in the tree.
//
//----------------------------------------------------------------------------
LONG
CElement::GetFirstAndLastCp(long * pcpFirst, long * pcpLast)
{
    CTreePos *  ptpStart, *ptpLast;
    long        cpFirst, cpLast;

    Assert (pcpFirst || pcpLast);

    if (!pcpFirst)
        pcpFirst = &cpFirst;

    if (!pcpLast)
        pcpLast = &cpLast;

    GetTreeExtent( &ptpStart, &ptpLast );

    Assert( (ptpStart && ptpLast) || (!ptpStart && !ptpLast) );

    if( ptpStart )
    {
        *pcpFirst = ptpStart->GetCp() + 1;
        *pcpLast = ptpLast->GetCp();
    }
    else
    {
        *pcpFirst = *pcpLast = 0;
    }

    Assert( *pcpLast - *pcpFirst >= 0 );

    return *pcpLast - *pcpFirst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::TakeCapture
//
//  Synopsis:   Set the element with the mouse capture.
//
//----------------------------------------------------------------------------

void
CElement::TakeCapture(BOOL fTake)
{
    CDoc * pDoc = Doc();

    if (fTake)
    {
        pDoc->SetMouseCapture(
                MOUSECAPTURE_METHOD(CElement, HandleCaptureMessage,
                                           handlecapturemessage),
                this);
    }
    else
    {
        pDoc->ClearMouseCapture(this);
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// The following seciton has the persistence support routines.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+------------------------------------------------------------------------
//
//  Member:     GetPersistID
//
//  Synopsis:   Helper function to return the ID that is used for matching up
//          persistence data to this element.  By default this is the nested ID of the
//          frame, but if no ID is specified, then we construct one using the
//          nested position of the frame in the name space of its parent.
//
// TODO (jbeda) get rid of the bstr crap
//-------------------------------------------------------------------------

BSTR
CElement::GetPersistID (BSTR bstrParentName)
{
    // TODO: (jbeda) this routine is really screwy.  KTam says we
    // should be able to get rid of the GetUpdatedParentLayout call here.
    // Here is my conclusion for what this actually is.  All normal elements
    // have an ID of <DOC/MARKUPID>#SourceIndex.  However, if your parent layout
    // is a frameset (where did this come from?) you have an id of 
    // <DOC/MARKUPID>#SourceIndexOfFrameSet#SouceIndex.  The <DOC/MARKUPID> is the
    // PersistID of your master element.  
    
    TCHAR       ach[MAX_PERSIST_ID_LENGTH];
    LPCTSTR     pstrID;
    BOOL        fNeedToFree = FALSE;
    CLayout   * pParentLayout = GetUpdatedParentLayout();   // NOTE: (jbeda) this will climb out of slave

    // TODO: (jbeda) If we want to extend this model to view-links
    // we now need to make sure that every markup transition takes 2 #? because
    // otherwise we can run into conflicts.

    CMarkup *   pMarkup = GetMarkup();
    if (pMarkup == NULL)
        return SysAllocString(_T(""));

    // Special case for parent layout of FRAMESET
    if (pParentLayout && pParentLayout->Tag() == ETAG_FRAMESET)
    {
        fNeedToFree = TRUE;
        bstrParentName = pParentLayout->ElementOwner()->GetPersistID(bstrParentName);
    }
    else
    {
        if (!bstrParentName)
        {
            fNeedToFree = TRUE;
            if (pMarkup->Root()->HasMasterPtr())
                bstrParentName = pMarkup->Root()->GetMasterPtr()->GetPersistID();
            else
                bstrParentName = SysAllocString(_T("DOC"));
        }
    }

    // Now get this ID and with the name base, concatenate and leave.
    if ((pstrID = GetAAid()) == NULL)
        IGNORE_HR(Format(0, ach, ARRAY_SIZE(ach), _T("<0s>#<1d>"),
                                                  bstrParentName,
                                                  GetSourceIndex()));
    else
        IGNORE_HR(Format(0, ach, ARRAY_SIZE(ach), _T("<0s>_<1s>"),
                                                  bstrParentName,
                                                  pstrID));

    if (fNeedToFree)
        SysFreeString(bstrParentName);

    return SysAllocString(ach);
}
//+-----------------------------------------------------------------------------
//
//  Member : GetPeerPersist
//
//  Synopsis : this hepler function consolidates the test code that gets the
//      IHTmlPersistData interface from a peer, if there is one.
//      this is used in numerous ::Notify routines.
//+-----------------------------------------------------------------------------
IHTMLPersistData *
CElement::GetPeerPersist()
{
    IHTMLPersistData * pIPersist = NULL;

    if( HasPeerHolder() )
    {
        IGNORE_HR( GetPeerHolder()->QueryPeerInterfaceMulti( IID_IHTMLPersistData, (void **)&pIPersist, FALSE ) );
    }

    return pIPersist;
}
//+-----------------------------------------------------------------------------
//
//  Member : GetPersistenceCache
//
//  Synopsis : Creates and returns the XML DOC.
//      TODO (carled) this needs to check the registry for a pluggable XML store
//
//------------------------------------------------------------------------------
HRESULT
CElement::GetPersistenceCache( IXMLDOMDocument **ppXMLDoc )
{
    HRESULT         hr = S_OK;
    IObjectSafety * pObjSafe = NULL;

    Assert(ppXMLDoc);
    *ppXMLDoc = NULL;

    // 3efaa428-272f-11d2-836f-0000f87a7782
    hr = THR(CoCreateInstance(CLSID_DOMDocument,
                              0,
                              CLSCTX_INPROC_SERVER,
                              IID_IXMLDOMDocument,
                              (void **)ppXMLDoc));
    if (hr)
        goto ErrorCase;

    hr = (*ppXMLDoc)->QueryInterface(IID_IObjectSafety,
                                     (void **)&pObjSafe);
    if (hr)
        goto ErrorCase;

    hr = pObjSafe->SetInterfaceSafetyOptions( IID_NULL,
                                              INTERFACE_USES_SECURITY_MANAGER,
                                              INTERFACE_USES_SECURITY_MANAGER);
    if (hr)
        goto ErrorCase;

Cleanup:
    ReleaseInterface(pObjSafe);
    RRETURN( hr );

ErrorCase:
    delete *ppXMLDoc;
    *ppXMLDoc = NULL;
    goto Cleanup;
}

//+-----------------------------------------------------------------------------
//
//  Member : TryPeerSnapshotSave
//
//  synopsis : notification helper
//
//+-----------------------------------------------------------------------------
HRESULT
CElement::TryPeerSnapshotSave (IUnknown * pDesignDoc)
{
    // check to see if we are a persistence XTag
    HRESULT hr = S_OK;
    IHTMLPersistData * pIPersist = GetPeerPersist();

    // Better be true
    Assert(!IsInMarkup() ||
        GetMarkup()->MetaPersistEnabled((long)htmlPersistStateSnapshot));

    if (pIPersist)
    {
        VARIANT_BOOL       fContinue;

        hr = THR(pIPersist->save(pDesignDoc,
                                 htmlPersistStateSnapshot,
                                 &fContinue));
    }

    ReleaseInterface(pIPersist);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Member : TryPeerPersist
//
//  synopsis : notification helper
//
//+-----------------------------------------------------------------------------

HRESULT
CElement::TryPeerPersist(PERSIST_TYPE sn, void * pvNotify)
{
    // check to see if we are a persistence XTag
    HRESULT hr = S_OK;
    IHTMLPersistData * pIPersist = GetPeerPersist();

    if (pIPersist)
    {
        VARIANT_BOOL       fSupported = VB_FALSE;
        htmlPersistState   hps = (sn==XTAG_HISTORY_SAVE ||
                                  sn==XTAG_HISTORY_LOAD) ? htmlPersistStateHistory:
                                                          htmlPersistStateFavorite;

        // Better be true
        Assert(!IsInMarkup() ||
            GetMarkup()->MetaPersistEnabled((long)hps));

        // one last check, before going through the effort of calling:
        //  Is this particular persist Tag, appropriate for this event
        hr = THR(pIPersist->queryType((long)hps, &fSupported));
        if (!hr && fSupported == VB_TRUE)
        {
            // this can return S_FALSE to stop the propogation of
            // Notify.
            switch (sn)
            {
            case XTAG_HISTORY_SAVE:
                hr = THR(DoPersistHistorySave(pIPersist, pvNotify));
                break;

            case XTAG_HISTORY_LOAD:
                hr = THR(DoPersistHistoryLoad(pIPersist, pvNotify));
                break;

            case FAVORITES_LOAD:
            case FAVORITES_SAVE:
                hr = THR(DoPersistFavorite(pIPersist, pvNotify, sn));
                break;
            }
        }

        ReleaseInterface(pIPersist);
    }

    RRETURN1( hr, S_FALSE );
}

//+-----------------------------------------------------------------------------
//
// Member : DoPersistHistorySave
//
//  Synopsis: helper function for saving this element's/XTags's data into the
//      history stream.  Save is an odd case, since EACH element can have the
//      authordata from the Peer, as well as its own state info (e.g. checkboxs)
//      Most of our work is related to managing the two forms of information, and
//      getting it back to the correct place.
//
//------------------------------------------------------------------------------

HRESULT
CElement::DoPersistHistorySave(IHTMLPersistData *pIPersist,
                               void *            pvNotify)
{
    HRESULT              hr = S_OK;
    IXMLDOMDocument    * pXMLDoc = NULL;
    IUnknown           * pUnk       = NULL;
    VARIANT_BOOL         fContinue  = VB_TRUE;
    VARIANT_BOOL         vtbCleanThisUp;
    CMarkup            * pMarkup = GetMarkup();
    CMarkupBehaviorContext * pContext = NULL;

    if (!pIPersist || !pMarkup)
        return E_INVALIDARG;

    hr = THR(pMarkup->EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    // get the XML cache for the history's userdata block
    if (!pContext->_pXMLHistoryUserData)
    {
        BSTR bstrXML;

        // we haven't needed one yet so create one...
        bstrXML = SysAllocString(_T("<ROOTSTUB />"));
        if (!bstrXML)
            return  E_OUTOFMEMORY;

        // get the xml chache and initialize it.
        hr = GetPersistenceCache(&pXMLDoc);
        if (!hr)
        {
            hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
        }
        SysFreeString(bstrXML);
        if (hr)
            goto Cleanup;

        pContext->_pXMLHistoryUserData = pXMLDoc;
    }
    else
    {
        pXMLDoc = pContext->_pXMLHistoryUserData;
    }

    Assert(pXMLDoc);

    hr = pXMLDoc->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (hr)
        goto Cleanup;

     // call the XTAG and let it save  any userdata
     hr = pIPersist->save(pUnk, htmlPersistStateHistory, &fContinue);
     if (hr)
        goto Cleanup;

    // now in the std History stream give the element a chance
    // to do all its normal saveing. Do this by turning around
    // and giving the element the SN_SAVEHISTORY, this will catch
    // all scope elemnts too. cool.
    // although history does an outerHTML this is really necesary
    //  for object tags to get caught properly.
    if (SUCCEEDED(hr) &&
        fContinue==VB_TRUE &&
        ShouldHaveLayout())
    {
        CNotification   nf;
        nf.SaveHistory1(this, pvNotify);

        // fire against ourself.
        Notify(&nf);

        if (nf.IsSecondChanceRequested())
        {
            nf.SaveHistory2(this, pvNotify);
            Notify(&nf);
        }
    }

    hr = (fContinue==VB_TRUE) ? hr : S_FALSE;

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------
//
// Member : DoPesistHistoryLoad
//
//  synposis: notification helper function, undoes what DoPersistHistory Save
//      started
//+-------------------------------------------------------------

HRESULT
CElement::DoPersistHistoryLoad(IHTMLPersistData *pIPersist,
                               void *            pvNotify)
{
    HRESULT             hr = E_INVALIDARG;
    IUnknown          * pUnk     = NULL;
    VARIANT_BOOL        fContinue = VB_TRUE;
    VARIANT_BOOL        vtbCleanThisUp;
    IXMLDOMDocument   * pXMLDoc  = NULL;
    CMarkup           * pMarkup = GetMarkup();
    CLock               lock(this);
    CMarkupBehaviorContext * pContext = NULL;

    if (!pIPersist || !pMarkup)
        goto Cleanup;

    hr = THR(pMarkup->EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    // if we are loading the the doc's XML History is NULL,
    //  then this is the first call. so create it and
    //  intialize it from the string.
    if (!pContext->_pXMLHistoryUserData &&
         pContext->_cstrHistoryUserData &&
         pContext->_cstrHistoryUserData.Length())
    {
        BSTR bstrXML;

        if (FAILED(THR(GetPersistenceCache(&pXMLDoc))))
            goto Cleanup;

        hr = pContext->_cstrHistoryUserData.AllocBSTR( &bstrXML );
        if (SUCCEEDED( hr) )
        {   
            hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
            if (SUCCEEDED(hr))
            {
                pContext->_pXMLHistoryUserData = pXMLDoc;
                pXMLDoc->AddRef();
                hr = S_OK;
            }
            SysFreeString(bstrXML);
        }
    }
    else if (pContext->_pXMLHistoryUserData)
    {
        pXMLDoc = pContext->_pXMLHistoryUserData;
        pXMLDoc->AddRef();
        hr = S_OK;
    }

    if (!pXMLDoc)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // if for some reason the cache is not yet init'd. do the default
    //---------------------------------------------------------------
    if (hr)
    {
        BSTR bstrXML;

        bstrXML = SysAllocString(_T("<ROOTSTUB />"));
        if (!bstrXML)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
        SysFreeString(bstrXML);
        if (hr)
            goto Cleanup;
    }

    hr = pXMLDoc->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (hr)
        goto Cleanup;

    // now that the xml object is initialized properly... call the XTag
    //  give the persist data xtag the chance to load its own information
    hr = pIPersist->load(pUnk, (long)htmlPersistStateHistory, &fContinue);

    hr = (fContinue==VB_TRUE) ? hr : S_FALSE;

Cleanup:
    ReleaseInterface(pUnk);
    ReleaseInterface(pXMLDoc);
    RRETURN1( hr, S_FALSE );
}


//+--------------------------------------------------------------------------
//
//  Member : PersistUserData
//
//  Synopsis : Handles most of the cases where persistence XTags are responsible
//      for handling favorites firing events and gathering user data associated with
//      this element.  in a nutshell :-
//          1> load/create and initialize and XML store
//          2> call the appropriate save/load method on the Peer's IHTMLPersistData
//          3> do any final processing (e.g. for shortcuts, put the xml store into
//                  the shortcut object via INamedPropertyBag)
//
//+--------------------------------------------------------------------------

HRESULT
CElement::DoPersistFavorite(IHTMLPersistData *pIPersist,
                            void *            pvNotify,
                            PERSIST_TYPE      sn)
{
    // This is called when we actually have a persistence cache and the meta tag is
    // enabling it's use
    HRESULT             hr = S_OK;
    BSTR                bstrStub  = NULL;
    VARIANT_BOOL        fContinue = VB_TRUE;
    VARIANT_BOOL        vtbCleanThisUp;
    CVariant            varValue;
    BSTR                bstrXMLText=NULL;
    IUnknown          * pUnk     = NULL;
    IXMLDOMDocument   * pXMLDoc  = NULL;
    INamedPropertyBag * pINPB    = NULL;
    IPersistStreamInit * pIPSI   = NULL;

    if (!pIPersist)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // first initialize the cache
    pINPB = ((FAVORITES_NOTIFY_INFO*)pvNotify)->pINPB;
    hr = GetPersistenceCache(&pXMLDoc);
    if (hr)
        goto Cleanup;

    // don't even initialize with this, if the permissions are wrong
    if (PersistAccessAllowed(pINPB))
    {
        PROPVARIANT  varValue;

        // shortcuts get the xml data into the INPB as the value of the property
        // "XMLUSERDATA"
        bstrStub = GetPersistID();
        if (!bstrStub)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // ask for a value of this type, if this type can't be served, then VT_ERROR
        //  comes back
        V_VT(&varValue) = VT_BLOB;
        hr = THR(pINPB->ReadPropertyNPB(bstrStub, _T("XMLUSERDATA"), &varValue));

        if (hr==S_OK && V_VT(&varValue) == VT_BLOB)
        {
            BSTR bstrXML;

            // turn the blob into a bstr
            bstrXML = SysAllocStringLen((LPOLESTR)varValue.blob.pBlobData,
                                              (varValue.blob.cbSize/sizeof(OLECHAR)));

            // now that we have the string for the xml object.
            if (bstrXML)
            {
                hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
                SysFreeString(bstrXML);
            }
            CoTaskMemFree(varValue.blob.pBlobData);
            hr = S_OK;
        }
    }
    else hr = S_FALSE;

    // if for some reason the cache is not yet init'd. do the default
    if (hr)
    {
        BSTR bstrXML;

        bstrXML = SysAllocString(_T("<ROOTSTUB />"));
        if (!bstrXML)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
        SysFreeString(bstrXML);
    }

    hr = pXMLDoc->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (hr)
        goto Cleanup;

    // now that the xml object is initialized properly... call the XTag
    switch (sn)
    {
    case FAVORITES_LOAD:
        //  give the persist data xtag the chance to load its own information
        hr = pIPersist->load(pUnk, htmlPersistStateFavorite, &fContinue);
        break;

    case FAVORITES_SAVE:
        {
            PROPVARIANT varXML;

            hr = pIPersist->save(pUnk, htmlPersistStateFavorite, &fContinue);

            // now that we have fired the event and given the persist object the oppurtunity to
            // save its information, we need to actually save it.
            // First, load the variant with the XML Data

            // get the text of the XML document
            hr = THR(pXMLDoc->get_xml( &bstrXMLText));
            if (hr)
                goto Cleanup;

            // now save this in the ini file
            SysFreeString(bstrStub);
            bstrStub = GetPersistID();
            if (!bstrStub)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // set up the BLOB, don't free this
            V_VT(&varXML) = VT_BLOB;
            varXML.blob.cbSize = (1+SysStringLen(bstrXMLText))*sizeof(OLECHAR);
            varXML.blob.pBlobData = (BYTE*)bstrXMLText;

            // NOTE: security, don't allow more than 32K per object
            // otherwise, just fail silently and free thing up on the way out
            if (varXML.blob.cbSize < PERSIST_XML_DATA_SIZE_LIMIT)
            {
                // write the XML user data
                hr = THR(pINPB->WritePropertyNPB(bstrStub, _T("XMLUSERDATA"), &varXML));
                if (hr)
                    goto Cleanup;

                // now use the propvariant for the other value to write
                V_VT(&varXML) = VT_BSTR;
                if (S_OK != FormsAllocString(Doc()->GetPrimaryUrl(), &V_BSTR(&varXML)))
                    goto Cleanup;

                // and write the user data security url
                hr = THR(pINPB->WritePropertyNPB(bstrStub, _T("USERDATAURL"), &varXML));
                SysFreeString(V_BSTR(&varXML));
                if (hr)
                    goto Cleanup;
            }
        };
        break;
    }

    hr = (fContinue==VB_TRUE) ? hr : S_FALSE;


Cleanup:
    SysFreeString(bstrXMLText);
    SysFreeString(bstrStub);
    ReleaseInterface(pIPSI);
    ReleaseInterface(pUnk);
    ReleaseInterface(pXMLDoc);
    RRETURN1( hr, S_FALSE );
}


//+------------------------------------------------------------------------------
//
//  Member : AccessAllowed()
//
//  Synopsis : checks the security ID of hte document against he stored security
//      id of the XML user data section
//
//-------------------------------------------------------------------------------
BOOL
CElement::PersistAccessAllowed(INamedPropertyBag * pINPB)
{
    BOOL     fRes = FALSE;
    BSTR     bstrDomain;
    HRESULT  hr;
    PROPVARIANT varValue;
    CMarkup * pMarkup = GetMarkup();

    V_VT(&varValue) = VT_BSTR;
    V_BSTR(&varValue) = NULL;

    bstrDomain = GetPersistID();
    if (!bstrDomain)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pINPB->ReadPropertyNPB(bstrDomain,
                                     _T("USERDATAURL"),
                                     &varValue));
    SysFreeString(bstrDomain);
    if (hr)
        goto Cleanup;

    if (V_VT(&varValue) != VT_BSTR)
        goto Cleanup;

    fRes = pMarkup->AccessAllowed(V_BSTR(&varValue));

Cleanup:
    if (V_BSTR(&varValue))
        SysFreeString(V_BSTR(&varValue));
    return fRes;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//          END PERSISTENCE ROUTINES
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+---------------------------------------------------------------------------
//
// Member:      HandleMnemonic
//
//  Synopsis:   This function is called because the user tried to navigate to
//              this element. There at least four ways the user can do this:
//                  1) by pressing Tab or Shift+Tab
//                  2) by pressing the access key for this element
//                  3) by clicking on a label associated with this element
//                  4) by pressing the access key for a label associated with
//                     this element
//
//              Typically, this function sets focus/currency to this element.
//              Click-able elements usually override this function to call
//              DoClick() on themselves if fTab is FALSE (i.e. navigation
//              happened due to reasons other than tabbing).
//
//----------------------------------------------------------------------------
HRESULT
CElement::HandleMnemonic(CMessage * pmsg, BOOL fDoClick, BOOL * pfYieldFailed)
{
    HRESULT     hr      = S_FALSE;
    CDoc *      pDoc    = Doc();

    Assert( IsInMarkup() );
    Assert(pmsg);

    if (IsFrameTabKey(pmsg))
    {
        // Allow this only for the main element inside a FRAME
        CMarkup *   pMarkup     = GetMarkup();
        CElement *  pElemMaster = pMarkup->Root()->GetMasterPtr();

        if (pElemMaster && pElemMaster->Tag() != ETAG_FRAME)
            goto Cleanup;
        
        if (this != pMarkup->GetElementClient())
            goto Cleanup;
    }

    if (IsEditable(TRUE))
    {
        if (Tag() == ETAG_ROOT || Tag() == ETAG_BODY)
        {
            Assert( Tag() != ETAG_ROOT || this == pDoc->PrimaryRoot() );
            hr = THR(BecomeCurrentAndActive(pmsg->lSubDivision, pfYieldFailed, NULL, TRUE, 0, TRUE));
        }
        else
        {
            // BugFix 14600 / 14496 (JohnBed) 03/26/98
            // If the current element does not have layout, just fall
            // out of this so the parent element can handle the mnemonic

            CLayout * pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

            if (!pLayout)
                goto Cleanup;

            // Site-select the element
            {
                CMarkupPointer      ptrStart(pDoc);
                CMarkupPointer      ptrEnd(pDoc);
                IMarkupPointer *    pIStart;
                IMarkupPointer *    pIEnd;

                hr = ptrStart.MoveAdjacentToElement(this, ELEM_ADJ_BeforeBegin);
                if (hr)
                    goto Cleanup;
                hr = ptrEnd.MoveAdjacentToElement(this, ELEM_ADJ_AfterEnd);
                if (hr)
                    goto Cleanup;

                Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
                Verify(S_OK == ptrEnd.QueryInterface(IID_IMarkupPointer, (void**)&pIEnd));
                hr = pDoc->Select(pIStart, pIEnd, SELECTION_TYPE_Control);
                if (hr)
                {
                    if (hr == E_INVALIDARG)
                    {
                        // This element was not site-selectable. Return S_FALSE, so
                        // that we can try the next element
                        hr = S_FALSE;
                    }
                }
                pIStart->Release();
                pIEnd->Release();
                if (hr)
                    goto Cleanup;
            }

            hr = THR(ScrollIntoView());
        }
    }
    else
    {
        Assert(IsFocussable(pmsg->lSubDivision));

        CLock lock(this);
        hr = THR(BecomeCurrentAndActive(pmsg->lSubDivision, pfYieldFailed, pmsg, TRUE, 0, TRUE));
        if (hr)
            goto Cleanup;

        //
        // we may have changed currency during the focus change ( events may have fired)
        // IE6 Bug# 16476
        // so we only do the below if we are indeed the current element
        // 

        if ( pDoc->_pElemCurrent == this )
        {
            hr = THR(ScrollIntoView());
            if (FAILED(hr))
                goto Cleanup;

            if (fDoClick 
                && (    _fActsLikeButton
                    ||  Tag() == ETAG_INPUT && DYNCAST(CInput, this)->IsOptionButton()))
            {
                IGNORE_HR(DoClick(pmsg));
            }

            hr = GotMnemonic(pmsg);
        }
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CElement::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagMsoCommandTarget, "CSite::QueryStatus"));

    Assert(IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *    pCmd = &rgCmds[0];
    HRESULT     hr = S_OK;
    CScrollbarController* pSBC;

    Assert(!pCmd->cmdf);

    switch (IDMFromCmdID(pguidCmdGroup, pCmd->cmdID))
    {
    case IDM_DYNSRCPLAY:
    case IDM_DYNSRCSTOP:
        // The selected site wes not an image site, return disabled
       pCmd->cmdf = MSOCMDSTATE_DISABLED;
       break;

    case  IDM_SIZETOCONTROL:
    case  IDM_SIZETOCONTROLHEIGHT:
    case  IDM_SIZETOCONTROLWIDTH:
        // will be executed only if the selection is not a control range
       pCmd->cmdf = MSOCMDSTATE_DISABLED;
       break;

    case IDM_SETWALLPAPER:
        if (Doc()->_pOptionSettings->dwNoChangingWallpaper)
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }
        // fall through
    case IDM_SAVEBACKGROUND:
    case IDM_COPYBACKGROUND:
    case IDM_SETDESKTOPITEM:
        pCmd->cmdf = GetNearestBgImgCtx() ? MSOCMDSTATE_UP
                                          : MSOCMDSTATE_DISABLED;
        break;

    case IDM_SELECTALL:
        if (HasFlag(TAGDESC_CONTAINER))
        {
            // Do not bubble to parent if this is a container.
            pCmd->cmdf =  DisallowSelection()
                            ? MSOCMDSTATE_DISABLED
                            : MSOCMDSTATE_UP;
        }
        break;

    case IDM_SCROLL_HERE:
    case IDM_SCROLL_TOP:
    case IDM_SCROLL_BOTTOM:
    case IDM_SCROLL_PAGEUP:
    case IDM_SCROLL_PAGEDOWN:
    case IDM_SCROLL_UP:
    case IDM_SCROLL_DOWN:
    case IDM_SCROLL_LEFTEDGE:
    case IDM_SCROLL_RIGHTEDGE:
    case IDM_SCROLL_PAGELEFT:
    case IDM_SCROLL_PAGERIGHT:
    case IDM_SCROLL_LEFT:
    case IDM_SCROLL_RIGHT:
        pSBC = TLS(pSBC);
        if (ShouldHaveLayout() && pSBC->GetLayout() == GetUpdatedLayout(GUL_USEFIRSTLAYOUT))
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    }

//    if (!pCmd->cmdf )
//        hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));


    RRETURN_NOTRACE(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSite::Exec
//
//  Synopsis:   Called to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------

HRESULT
CElement::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CSite::Exec"));

    Assert(IsCmdGroupSupported(pguidCmdGroup));

    UINT    idm;
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    //
    // default processing
    //

    switch (idm = IDMFromCmdID(pguidCmdGroup, nCmdID))
    {
        case IDM_SAVEBACKGROUND:
        case IDM_SETWALLPAPER:
        case IDM_SETDESKTOPITEM:
        {
            CImgCtx *pImgCtx = GetNearestBgImgCtx();

            if (pImgCtx)
                Doc()->SaveImgCtxAs(pImgCtx, NULL, idm);

            hr = S_OK;
            break;
        }
        case IDM_COPYBACKGROUND:
        {
            CImgCtx *pImgCtx = GetNearestBgImgCtx();

            if (pImgCtx)
                CreateImgDataObject(Doc(), pImgCtx, NULL, NULL, NULL);

            hr = S_OK;
            break;
        }

        case IDM_SCROLL_HERE:
        case IDM_SCROLL_TOP:
        case IDM_SCROLL_BOTTOM:
        case IDM_SCROLL_PAGEUP:
        case IDM_SCROLL_PAGEDOWN:
        case IDM_SCROLL_UP:
        case IDM_SCROLL_DOWN:
        case IDM_SCROLL_LEFTEDGE:
        case IDM_SCROLL_RIGHTEDGE:
        case IDM_SCROLL_PAGELEFT:
        case IDM_SCROLL_PAGERIGHT:
        case IDM_SCROLL_LEFT:
        case IDM_SCROLL_RIGHT:
        {
            CScrollbarController* pSBC = TLS(pSBC);
            if (ShouldHaveLayout() && pSBC->GetLayout() == GetUpdatedLayout(GUL_USEFIRSTLAYOUT))
            {
                pSBC->DoContextMenuScroll(idm);
            }
            hr = S_OK;
            break;
        }
    }
    if (hr != OLECMDERR_E_NOTSUPPORTED)
        goto Cleanup;

    //
    // behaviors
    //

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->ExecMulti(
                        pguidCmdGroup,
                        nCmdID,
                        nCmdexecopt,
                        pvarargIn,
                        pvarargOut));
        if (hr != OLECMDERR_E_NOTSUPPORTED)
            goto Cleanup;
    }

Cleanup:

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member: CElement::IsParent
//
//  Params: pElement: Check if pElement is the parent of this site
//
//  Descr:  Returns TRUE is pSite is a parent of this site, FALSE otherwise
//
//----------------------------------------------------------------------------
BOOL
CElement::IsParent(CElement *pElement)
{
    CTreeNode *pNodeSiteTest = GetFirstBranch();

    while (pNodeSiteTest)
    {
        if (SameScope(pNodeSiteTest, pElement))
        {
            return TRUE;
        }
        pNodeSiteTest = pNodeSiteTest->GetUpdatedParentLayoutNode();
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::GetNearestBgImgCtx
//
//--------------------------------------------------------------------------
CImgCtx *
CElement::GetNearestBgImgCtx()
{
    CTreeNode * pNodeSite;
    CImgCtx * pImgCtx;

    for (pNodeSite = GetFirstBranch();
         pNodeSite;
         pNodeSite = pNodeSite->GetUpdatedParentLayoutNode())
    {
        pImgCtx = pNodeSite->Element()->GetBgImgCtx();
        if (pImgCtx && (pImgCtx->GetState() & IMGLOAD_COMPLETE))
            return pImgCtx;
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     Celement::GetParentForm()
//
//  Synopsis:   Returns the site's containing form if any.
//
//-------------------------------------------------------------------------
CFormElement *
CElement::GetParentForm()
{
    CElement * pElement = GetFirstBranch() ?
        GetFirstBranch()->SearchBranchToRootForTag(ETAG_FORM)->SafeElement() :
        NULL;

    if (pElement)
        return DYNCAST(CFormElement, pElement);
    else
        return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     get_form
//
//  Synopsis:   Exposes the form element, NULL otherwise.
//
//  Note:
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::get_form(IHTMLFormElement **ppDispForm)
{
    HRESULT        hr = S_OK;
    CFormElement * pForm;

    if (!ppDispForm)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispForm = NULL;

    pForm = GetParentForm();
    if (pForm)
    {
        hr = THR_NOTRACE(pForm->QueryInterface(IID_IHTMLFormElement,
                                              (void**)ppDispForm));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+-------------------------------------------------------------------------
//
//  Method:   CDoc::TakeFocus
//
//  Synopsis: To have trident window take focus if it does not already have it.
//
//--------------------------------------------------------------------------
BOOL
CDoc::TakeFocus()
{
    BOOL fRet = FALSE;

    if (_pInPlace && !_pInPlace->_fDeactivating)
    {
        if (::GetFocus() != _pInPlace->_hwnd)
        {
            SetFocusWithoutFiringOnfocus();
            fRet = TRUE;
        }
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pElementNew    New Element that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
CElement::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr = S_OK;
    CLayout * pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
    CDoc* pDoc = Doc();
    if (pLayout)
    {
        CFlowLayout * pFlowLayout = pLayout->IsFlowLayout();
        if (pFlowLayout)
        {
            hr = THR(pFlowLayout->YieldCurrencyHelper(pElemNew));
            if (hr)
                goto Cleanup;
        }
    }

#ifndef NO_IME

    // Restore the IMC if we've temporarily disabled it.  See BecomeCurrent().
    if (pDoc && pDoc->_pInPlace && !pDoc->_pInPlace->_fDeactivating
        && pDoc->_pInPlace->_hwnd && pElemNew)
    {
        // Terminate any IME compositions which are currently in progress
        IUnknown    *pUnknown = NULL;
        IHTMLEditor *pIEditor = NULL;

        IGNORE_HR( this->QueryInterface(IID_IUnknown, (void**) & pUnknown) );
        pIEditor = pDoc->GetHTMLEditor(FALSE);
        
        if( pIEditor )
        {
            IGNORE_HR( pIEditor->TerminateIMEComposition() );
        }

        ReleaseInterface(pUnknown);
    }
#endif

    // 
    // Hide caret (but don't clear selection!) when focus changes
    // in the same frame
    //
    if (IsInMarkup() && pElemNew->GetMarkup() )
    {
        CMarkup* pMarkup = GetMarkup();
        CMarkup* pNewMarkup = pElemNew->GetMarkup();
        
        // 
        // make sure we're done parsing, make sure we are switching
        // to another element in the same frame
        //
        if ( ( ( pMarkup->LoadStatus() == LOADSTATUS_DONE ) ||
               ( pMarkup->LoadStatus() == LOADSTATUS_PARSE_DONE ) ||
               ( pMarkup->LoadStatus() == LOADSTATUS_UNINITIALIZED ) )
                && ( _etag != ETAG_ROOT && pElemNew->_etag != ETAG_DEFAULT) 
                && ( pMarkup->GetFrameOrPrimaryMarkup() == pNewMarkup->GetFrameOrPrimaryMarkup()) )
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( pElemNew->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            hr = THR( pDoc->NotifySelection( EDITOR_NOTIFY_YIELD_FOCUS , pUnknown ));
            ReleaseInterface( pUnknown );
        }
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::YieldUI
//
//  Synopsis:   Relinquish UI, opposite of BecomeUIActive
//
//  Arguments:  pElementNew    New site that wants UI
//
//--------------------------------------------------------------------------

void
CElement::YieldUI(CElement *pElemNew)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::BecomeUIActive
//
//  Synopsis:   Force ui activity on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
CElement::BecomeUIActive()
{
    HRESULT hr = S_FALSE;
    CLayout *pLayout = NULL;

    // NOTE: (krisma) We somethimes can set focus to 
    // an element that's no longer in the tree. (See bug
    // 81787.) In this case, we should return S_FALSE.
    CMarkup *pMarkup = GetMarkup();
    if (!pMarkup)
        goto Cleanup;

    pLayout = GetUpdatedParentLayout();

    // This site does not care about grabbing the UI.
    // Give the parent a chance.
    if (pLayout)
    {
        hr = THR(pLayout->ElementOwner()->BecomeUIActive());
    }
    else
    {
        hr = pMarkup->Root()->BecomeUIActive();
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::BecomeCurrent
//
//  Synopsis:   Force currency on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become current.
//
//--------------------------------------------------------------------------

HRESULT
CElement::BecomeCurrent(
    long        lSubDivision,
    BOOL *      pfYieldFailed,
    CMessage *  pmsg,
    BOOL        fTakeFocus /*=FALSE*/,
    LONG        lButton /*=0*/,
    BOOL *      pfDisallowedByEd /*=NULL*/, 
    BOOL        fFireFocusBlurEvents /*=TRUE*/,
    BOOL        fMnemonic /*=FALSE*/)
{
    HRESULT     hr              = S_FALSE;
    CDoc *      pDoc            = Doc();
    CElement *  pElemOld        = pDoc->_pElemCurrent;
    long        lSubOld         = pDoc->_lSubCurrent;
    CLock       lock(this);

#ifdef MOHANB_WINDOW_FOCUS // need to turn this on sometime soon
    HWND        hwndFocus;
    HWND        hwndCurrent;
    BOOL        fPrevHasFocus   = FALSE;
#endif // MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    Assert(IsInMarkup());


    // Hack for slave. The editing code calls BecomeCurrent() on slave.
    // For now, make the master current, Need to think about the nested slave tree case
    if (HasMasterPtr())
    {
        return GetMasterPtr()->BecomeCurrent(lSubDivision, pfYieldFailed, pmsg, fTakeFocus, lButton );
    }

#ifdef MOHANB_WINDOW_FOCUS // need to turn this on sometime soon
    // We may need to force fTakeFocus to TRUE. Check if a child window of
    // Trident window has focus. If yes, that child window must be the window
    // associated with the current element. Note that this window is not
    // necessarily _pElemCurrent->GetHwnd(). For example, there are OLE
    // controls that claim to be windowless but internally have a window which
    // is given focus when the control is current (e.g. Active Movie control).
    // Also, the current element could be the child of a windowed element, in
    // case, the parent element's window has focus. In all these cases, Trident
    // needs to makes sure that remove focus from this window. 
    hwndFocus = ::GetFocus();
    fPrevHasFocus = (       hwndFocus
                        &&  pDoc->_pInPlace
                        &&  hwndFocus != pDoc->_pInPlace->_hwnd
                        &&  ::IsChild(pDoc->_pInPlace->_hwnd, hwndFocus)
                    );

#if DBG==1
    if (fPrevHasFocus)
    {
        Assert(pDoc->_pElemCurrent);
        hwndCurrent = pDoc->_pElemCurrent->GetHwnd();
        if (hwndCurrent)
        {
            Assert(hwndFocus == hwndCurrent || ::IsChild(hwndCurrent, hwndFocus));
        }
    }
#endif
#endif // MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    Assert(pDoc->_fForceCurrentElem || pDoc->_pInPlace);
    if (!pDoc->_fForceCurrentElem && pDoc->_pInPlace->_fDeactivating)
        goto Cleanup;

    if (!IsFocussable(lSubDivision))
        goto Cleanup;

    hr = THR(PreBecomeCurrent(lSubDivision, pmsg));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->SetCurrentElem(this,
                                  lSubDivision,
                                  pfYieldFailed,
                                  lButton,
                                  pfDisallowedByEd,
                                  fFireFocusBlurEvents,
                                  fMnemonic));
    if (hr)
    {
        IGNORE_HR(THR(BecomeCurrentFailed(lSubDivision, pmsg)));

        // Take focus if necessary, whether or not current element has changed #99296
        if (fTakeFocus && !pDoc->HasFocus())
        {
            pDoc->TakeFocus();
        }

        goto Cleanup;
    }

    //  The event might have killed the element

    if (! IsInMarkup() )
        goto Cleanup;

    // Do not inhibit if Currency did not change. Onfocus needs to be fired from
    // WM_SETFOCUS handler if clicking in the address bar and back to the same element
    // that previously had the focus.

    pDoc->_fInhibitFocusFiring = (this != pElemOld);

    if ( IsEditable( FALSE ) && !pDoc->_fPopupDoc)
    {
        //
        // An editable element has just become current.
        // We create the editor if one doesn't already exist.
        //
        
        if (  _etag != ETAG_ROOT ) // make sure we're done parsing
        {
            //
            // marka - we need to put in whether to select the text or not.
            //

            Verify( pDoc->GetHTMLEditor( TRUE ));


        }

    }

#ifdef MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    if (fPrevHasFocus)
    {
        hwndFocus = ::GetFocus();
        hwndCurrent = GetHwnd();

        if (    hwndFocus
            &&  hwndCurrent
            &&  (hwndFocus == hwndCurrent || ::IsChild(hwndCurrent, hwndFocus))
           ) 
        {
            // Leave focus alone, it's already with the new current element
        }
        else
        {
            // TODO (MohanB) I am ignoring the case where the focus is with
            // the window of a parent element of the current element. We currently
            // don't have windowed elements whose children could become current.
            fTakeFocus = TRUE;
        }
    }
#endif // MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    //
    // Take focus only if told to do so, and the element becoming current is not 
    // the root and not an olesite.  Olesite's will do it themselves.  
    //
    
    if (fTakeFocus && !TestClassFlag(ELEMENTDESC_OLESITE))
    {
        pDoc->TakeFocus();
    }

#ifndef NO_IME
    if (pDoc->_pInPlace && !pDoc->_pInPlace->_fDeactivating && pDoc->_pInPlace->_hwnd)
    {
        // If ElementOwner is not editable, disable current imm and cache the HIMC.  The 
        // HIMC is restored in YieldCurrency.
        //
        BOOL fIsPassword = ( Tag() == ETAG_INPUT 
                             && (DYNCAST(CInput, this))->GetType() == htmlInputPassword );

        // If the current object is a non-password edit field or object, we must
        // disable the IME and cache the IMM input context so we can re-enable it
        // in the future
        if ((!IsEditable(/*fCheckContainerOnly*/FALSE) && Tag() != ETAG_OBJECT) || fIsPassword)
        {
            //
            // If this has been disabled. We won't disable it again
            //
            if (NULL == Doc()->_himcCache)
            {
                HIMC himc = ImmGetContext(Doc()->_pInPlace->_hwnd);

                if (himc)
                {
                    // Disable the IME
                    himc = ImmAssociateContext(Doc()->_pInPlace->_hwnd, NULL);
                    Doc()->_himcCache = himc;
                    TraceTag((tagEdImm, "Element %d Disable IME 0x%x for window 0x%x _pDocDbg %x", 
                                        _etagDbg, himc, Doc()->_pInPlace->_hwnd, _pDocDbg)
                                        );
                }            
             }
        }
        else
        {
            // If we previously disabled the IME, we need to re-enable it for this 
            // editable object. 
            if (Doc()->_himcCache)
            {
                TraceTag((tagEdImm, "Element %d Enable IME 0x%x for window 0x%x _pDocDbg %x", 
                                    _etagDbg, _pDocDbg->_himcCache, Doc()->_pInPlace->_hwnd, _pDocDbg)
                                    );
                ImmAssociateContext(Doc()->_pInPlace->_hwnd, Doc()->_himcCache);
                Doc()->_himcCache = NULL;
            }

            //
            // Set the IME state for inputs and textareas.  
            //
            // Note:  We have to do this even when it has been called since the 
            //        above code might have enabled IME again even though it is 
            //        supposed to be disabled! #94387  [zhenbinx]
            //
            //
            if( Tag() == ETAG_INPUT || Tag() == ETAG_TEXTAREA )
            {
                IGNORE_HR(SetImeState());
            }
        }
    }
#endif // NO_IME

    pDoc->_fInhibitFocusFiring = FALSE;
    hr = S_OK;

    if (HasPeerHolder() && GetPeerHolder()->_pPeerUI)
    {
        GetPeerHolder()->_pPeerUI->OnReceiveFocus(TRUE, pDoc->_lSubCurrent);
    }

    if (pElemOld->HasPeerHolder() &&
        pElemOld->GetPeerHolder()->_pPeerUI)
    {
        pElemOld->GetPeerHolder()->_pPeerUI->OnReceiveFocus(
            FALSE,
            lSubOld);
    }

    if (Tag() != ETAG_ROOT && pDoc->_pInPlace)
    {
        CLayout * pLayout = GetUpdatedLayout( pmsg ? pmsg->pLayoutContext : GUL_USEFIRSTLAYOUT );

        if (pLayout && pLayout->IsFlowLayout())
        {
            hr = THR(pLayout->IsFlowLayout()->BecomeCurrentHelper(lSubDivision, pfYieldFailed, pmsg));
            if (hr)
                goto Cleanup;
        }
    }


    hr = THR(PostBecomeCurrent(pmsg, fTakeFocus));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::BecomeCurrentAndActive
//
//  Synopsis:   Force currency and uiactivity on the site.
//
//--------------------------------------------------------------------------

HRESULT
CElement::BecomeCurrentAndActive(long           lSubDivision    /*=0*/,
                                 BOOL *         pfYieldFailed   /*=NULL*/,
                                 CMessage *     pmsg            /*=NULL*/,
                                 BOOL           fTakeFocus      /*=FALSE*/,
                                 LONG           lButton         /*=0*/,
                                 BOOL           fMnemonic       /*=FALSE*/)
{
    HRESULT     hr          = S_FALSE;
    CDoc *      pDoc        = Doc();
    CElement *  pElemOld    = pDoc->_pElemCurrent;
    long        lSubOld     = pDoc->_lSubCurrent;
    CLock       lock(this);

    // Store the old current site in case the new current site cannot
    // become ui-active.  If the becomeuiactive call fails, then we
    // must reset currency to the old guy.
    //

    if (pDoc->IsPrintDialogNoUI())
        goto Cleanup;

    hr = THR(BecomeCurrent(lSubDivision, pfYieldFailed, pmsg, fTakeFocus, lButton, NULL, TRUE, fMnemonic));
    if (hr)
        goto Cleanup;

    hr = THR(BecomeUIActive());
    if (OK(hr))
    {
        hr = S_OK;
    }
    else
    {
        if (pElemOld)
        {
            // Don't take focus in this case
            Verify(!pElemOld->BecomeCurrent(lSubOld));
        }
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CElement::BubbleBecomeCurrent
//
//  Synopsis:   Bubble up BecomeCurrent requests through parent chain.
//
//----------------------------------------------------------------------------
HRESULT
CElement::BubbleBecomeCurrent(long       lSubDivision,
                              BOOL     * pfYieldFailed,
                              CMessage * pMessage,
                              BOOL       fTakeFocus, 
                              LONG       lButton /* = 0*/ )
    {
    CTreeNode * pNode           = NULL;
    HRESULT     hr              = S_OK;
    BOOL        fDisallowedByEd = FALSE;
    BOOL        fYieldFailed    = FALSE;
    CDoc *      pDoc            = Doc();
    unsigned    cCurrentElemChangesOld;
    
    if (HasMasterPtr())
    {
        return GetMasterPtr()->BubbleBecomeCurrent(lSubDivision, pfYieldFailed, pMessage, fTakeFocus, lButton );
    }

    pNode = GetFirstBranch();
    if (!pNode)
        goto Cleanup;


    hr = S_FALSE;
    cCurrentElemChangesOld = pDoc->_cCurrentElemChanges;

    while (hr == S_FALSE && pNode && !fDisallowedByEd && !fYieldFailed)
    {
        hr = THR(pNode->Element()->BecomeCurrent(
                                    lSubDivision, & fYieldFailed, pMessage, fTakeFocus, lButton, & fDisallowedByEd  ));

        if (hr == S_FALSE)
        {
            // We do not want to retry if currency was changed
            if (cCurrentElemChangesOld != pDoc->_cCurrentElemChanges)
            {
                hr = S_OK;
            }
            else
            {
                pNode = pNode->Parent();
                lSubDivision = 0; // Don't need to set this except in the first iteration, but..
            }
        }
    }

Cleanup:
    if (pfYieldFailed)
    {
        *pfYieldFailed = fYieldFailed;
    }
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::RequestYieldCurrency
//
//  Synopsis:   Check if OK to Relinquish currency
//
//  Arguments:  BOOl fForce -- if TRUE, force change and don't ask user about
//                             usaveable data.
//
//  Returns:    S_OK        ok to yield currency
//              S_FALSE     ok to yield currency, but user explicitly reverted
//                          the value to what the database has
//              E_*         not ok to yield currency
//
//--------------------------------------------------------------------------

HRESULT
CElement::RequestYieldCurrency(BOOL fForce)
{
    HRESULT hr = S_OK;
#ifndef NO_DATABINDING
    CElement * pElemBound;
    DBMEMBERS *pdbm;
    DBINFO dbi;
    CDoc* pDoc = Doc();

    if (!IsValid())
    {
        // TODO     Need to display error message here.
        //          May not be able to handle synchronous
        //          display, so consider deferred display.
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!ShouldHaveLayout())
        goto Cleanup;

    pElemBound = GetElementDataBound();
    pdbm = pElemBound->GetDBMembers();

    if (pdbm == NULL)
    {
        goto Cleanup;
    }

#ifndef NO_IME
    // IEV6-26259
    // if we have a databinding session, need to terminate IME before 
    // data is saved. 
    if (pDoc && pDoc->_pInPlace && !pDoc->_pInPlace->_fDeactivating
        && pDoc->_pInPlace->_hwnd)
    {
        // Terminate any IME compositions which are currently in progress
        IUnknown    *pUnknown = NULL;
        IHTMLEditor *pIEditor = NULL;

        IGNORE_HR( this->QueryInterface(IID_IUnknown, (void**) & pUnknown) );
        pIEditor = pDoc->GetHTMLEditor(FALSE);
        
        if( pIEditor )
        {
            IGNORE_HR( pIEditor->TerminateIMEComposition() );
        }

        ReleaseInterface(pUnknown);
    }    
#endif

    // Save, with accompanying cancellable notifications
    hr = THR(pElemBound->SaveDataIfChanged(ID_DBIND_ALL, /* fLoud */ !fForce));
    if (fForce)
    {
        hr = S_OK;
    }

Cleanup:
#endif // ndef NO_DATABINDING
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member: CElement::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CElement::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_ISCOMPLETED:
        return TRUE;

    case GETINFO_HISTORYCODE:
        return Tag();
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
// Method:      CElement::HaPercentBgImg
//
// Synopsis:    Does this element have a background image whose width or
//              height is percent based.
//
//----------------------------------------------------------------------------

BOOL
CElement::HasPercentBgImg()
{
    CImgCtx * pImgCtx = GetBgImgCtx();
    const CFancyFormat * pFF = GetFirstBranch()->GetFancyFormat();

    // Logical/Physical does not matter here since we look at both.
    return pImgCtx &&
           (pFF->GetBgPosX().GetUnitType() == CUnitValue::UNIT_PERCENT ||
            pFF->GetBgPosY().GetUnitType() == CUnitValue::UNIT_PERCENT);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::IsVisible
//
//  Synopsis:   Is this layout element visible?
//
//  Parameters: fCheckParent - check the parent first
//
//----------------------------------------------------------------------------

BOOL
CElement::IsVisible (BOOL fCheckParent FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    CTreeNode *pNode         = GetUpdatedNearestLayoutNode();
    BOOL       fVisible      = !!pNode;

    // If we don't have an ancestor w/ layout, check if
    // we have a master.  If so, we're in a inner-slave relationship,
    // and we have the visibility of our master.  Else we're not
    // visible (probably not in tree).
    if (!pNode)
    {
        if (HasMasterPtr())
        {
            return GetMasterPtr()->IsVisible(fCheckParent);
        }
        return FALSE;
    }

    // Certain controls are marked as invisible.
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        if (DYNCAST(COleSite, this)->_fInvisibleAtRuntime)
            fVisible = FALSE;
    }

    while (fVisible)
    {
        const CCharFormat * pCF;
        
        if (!pNode)
            break;

        if (!pNode->Element()->IsInMarkup())
        {
            fVisible = FALSE;
            break;
        }

        // Visibility is inherited per CSS2, thus it suffices to check
        // ourself (instead of every element in the parent element chain).
        pCF = GetFirstBranch()->GetCharFormat( FCPARAM );

        if ( pCF->IsDisplayNone() || pCF->IsVisibilityHidden())
        {
            fVisible = FALSE;
            break;
        }
        
        if (!fCheckParent)
        {
            fVisible = TRUE;
            break;
        }
#ifdef MULTI_FORMAT
        if (FCPARAM)
        {
            CTreeNode * pTempNode = pNode;
            pNode = pNode->Element()->GetParentFormatNode(pTempNode, FCPARAM);
            FCPARAM = pNode->Element()->GetParentFormatContext(pTempNode, FCPARAM);
        }
        else
#endif         
        {
            pNode = pNode->GetUpdatedParentLayoutNode();
        }
    }
    return fVisible;
}

BOOL 
CElement::IsParentEditable()
{
    CTreeNode* pNode = GetFirstBranch();
    CTreeNode* pParent = pNode ? pNode->Parent() : NULL ;

    if ( pParent && 
         pParent->Element() )
    {
        return pParent->Element()->IsEditable(/*fCheckContainerOnly*/FALSE);
    }
    else
        return FALSE;
}

BOOL
CElement::IsMasterParentEditable()
{
    CMarkup * pMarkup  = GetMarkup();
    CElement* pMaster = pMarkup->Root()->HasMasterPtr() ? 
                            pMarkup->Root()->GetMasterPtr() :
                            NULL ;

    return ( pMaster && ( pMaster->IsParentEditable() || pMaster->IsMasterParentEditable() ) );
}


BOOL CElement::IsEditable(BOOL fCheckContainerOnly 
                          FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (IsRoot() || (fCheckContainerOnly && Tag() == ETAG_BODY))
    {
        return IsDesignMode();
    }
    else
    {
        CTreeNode *pNode = GetFirstBranch();

        return (pNode && pNode->IsEditable(fCheckContainerOnly FCCOMMA FCPARAM));
    }
}

BOOL CElement::IsFrozen()
{  
    CDefaults * pDefaults = GetDefaults();
    if (pDefaults)
    {
        return pDefaults->GetAAfrozen();
    }

    return FALSE;    
}

BOOL CElement::IsParentFrozen()
{
    if (IsInMarkup())        
    {
        return GetFirstBranch()->GetCharFormat()->_fParentFrozen;
    }

    return FALSE;
}

BOOL CElement::IsUnselectable()
{
    HRESULT hr = S_OK;
    VARIANT var;
    BOOL    fUnselectable = FALSE;

    VariantInit(&var);
    V_VT(&var)   = VT_BSTR ;
    V_BSTR(&var) =  NULL ;

    hr = THR( getAttribute(_T("unselectable"), 0, &var) );
    if (hr != S_OK)
        goto Cleanup;

    if (V_VT(&var) == VT_BSTR)
    {
        fUnselectable = !!(_tcsicmp(var.bstrVal, _T("on")) == 0);
    }
    else if (V_VT(&var) == VT_BOOL)
    {
        fUnselectable = !!(V_BOOL(&var));
    }
Cleanup:
    return fUnselectable;
}



//+---------------------------------------------------------------------------
//
//  Member:     CElement::IsEnabled
//
//  Synopsis:   Is this element enabled? Try to get the cascaded info cached
//              in the char format. If the element is not in any markup,
//              use the 'disabled attribute directly.
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
CElement::IsEnabled(FORMAT_CONTEXT FCPARAM)
{
    CTreeNode * pNode = GetFirstBranch();

    return !(pNode
            ? pNode->GetCharFormat(FCPARAM)->_fDisabled
            : GetAAdisabled());
}


BOOL
CElement::IsLocked(FORMAT_CONTEXT FCPARAM)
{
    // only absolute sites can be locked.
    if(IsAbsolute(FCPARAM))
    {
        CVariant var;
        CStyle *pStyle;

        pStyle = GetInLineStylePtr();

        if (!pStyle || pStyle->getAttribute(L"Design_Time_Lock", 0, &var))
            return FALSE;

        return var.boolVal;
    }
    return FALSE;
}

// Accelerator Table handling
//
CElement::ACCELS::ACCELS(ACCELS * pSuper, WORD wAccels)
{
    _pSuper = pSuper;
    _wAccels = wAccels;
    _fResourcesLoaded = FALSE;
    _pAccels = NULL;
}

CElement::ACCELS::~ACCELS()
{
    delete _pAccels;
}

HRESULT
CElement::ACCELS::LoadAccelTable()
{
    HRESULT hr = S_OK;
    HACCEL  hAccel;
    int     cLoaded;

    if (!_wAccels)
        goto Cleanup;

    hAccel = LoadAccelerators(GetResourceHInst(), MAKEINTRESOURCE(_wAccels));
    if (!hAccel)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _cAccels = CopyAcceleratorTable(hAccel, NULL, 0);
    Assert (_cAccels);

    _pAccels = new(Mt(CElement_pAccels)) ACCEL[_cAccels];
    if (!_pAccels)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    cLoaded = CopyAcceleratorTable(hAccel, _pAccels, _cAccels);
    if (cLoaded != _cAccels)
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:
    if (hr)
    {
        _cAccels = 0;
        _pAccels = NULL;
    }
    RRETURN (hr);
}


HRESULT
CElement::ACCELS::EnsureResources()
{
    if (!_fResourcesLoaded)
    {
        CGlobalLock     glock;

        if (!_fResourcesLoaded)
        {
            HRESULT hr;

            hr = THR(LoadAccelTable ());

            _fResourcesLoaded = TRUE;

            RRETURN (hr);
        }
    }

    return S_OK;
}


DWORD
CElement::ACCELS::GetCommandID(LPMSG pmsg)
{
    HRESULT     hr;
    DWORD       nCmdID = IDM_UNKNOWN;
    WORD        wVKey;
    ACCEL *     pAccel;
    int         i;
    DWORD       dwKeyState = FormsGetKeyState();

    if (WM_KEYDOWN != pmsg->message && WM_SYSKEYDOWN != pmsg->message)
        goto Cleanup;

    if (_pSuper)
    {
        nCmdID = _pSuper->GetCommandID(pmsg);
        if (IDM_UNKNOWN != nCmdID) // found id, nothing more to do
            goto Cleanup;
    }

    hr = THR(EnsureResources());
    if (hr)
        goto Cleanup;

    // loop through the table
    for (i = 0, pAccel = _pAccels; i < _cAccels; i++, pAccel++)
    {
// WINCEREVIEW - don't have VkKeyScan
#ifndef WINCE
        if (!(pAccel->fVirt & FVIRTKEY))
        {
            wVKey = LOBYTE(VkKeyScan(pAccel->key));
        }
        else
#endif // WINCE
        {
            wVKey = pAccel->key;
        }

        if (wVKey == pmsg->wParam &&
            EQUAL_BOOL(pAccel->fVirt & FCONTROL, dwKeyState & MK_CONTROL) &&
            EQUAL_BOOL(pAccel->fVirt & FSHIFT,   dwKeyState & MK_SHIFT) &&
            EQUAL_BOOL(pAccel->fVirt & FALT,     dwKeyState & MK_ALT))
        {
            nCmdID = pAccel->cmd;
            break;
        }
    }

Cleanup:
    return nCmdID;
}

CElement::ACCELS CElement::s_AccelsElementDesign =
                 CElement::ACCELS(NULL, IDR_ACCELS_SITE_DESIGN);
CElement::ACCELS CElement::s_AccelsElementDesignNoHTML =
                 CElement::ACCELS(NULL, IDR_ACCELS_INPUTTXT_DESIGN);
CElement::ACCELS CElement::s_AccelsElementRun    =
                 CElement::ACCELS(NULL, IDR_ACCELS_SITE_RUN);


//+---------------------------------------------------------------
//
//  Member:     CElement::PerformTA
//
//  Synopsis:   Forms implementation of TranslateAccelerator
//              Check against a list of accelerators for the incoming
//              message and if a match is found, fire the appropriate
//              command.  Return true if match found, false otherwise.
//
//  Input:      pMessage    Ptr to incoming message
//
//---------------------------------------------------------------
HRESULT
CElement::PerformTA(CMessage *pMessage)
{
    HRESULT     hr = S_FALSE;
    DWORD       cmdID;
    MSOCMD      msocmd;
    CDoc *      pDoc = Doc();

    cmdID = GetCommandID(pMessage);

    if (cmdID == IDM_UNKNOWN)
        goto Cleanup;

    // CONSIDER: (anandra) Think about using an Exec
    // call directly here, instead of sendmessage.
    //
    msocmd.cmdID = cmdID;
    msocmd.cmdf  = 0;

    // So QueryStatus() should be called, instead of QueryStatusHelper() with
    // Document() as the context.  The reason for this is because the SendMessage
    // which actually executes the command below is routed to CDoc::Exec.  This
    // means that the Exec() call has no context of which CDocument originated
    // the call.  Therefore, we should QueryStatus the same way we exec, with 
    // CDoc having no knowledge of its originating document.

    hr = THR(pDoc->QueryStatus(
            (GUID *)&CGID_MSHTML,
            1,
            &msocmd,
            NULL));
    if (hr)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (msocmd.cmdf == 0)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (msocmd.cmdf == MSOCMDSTATE_DISABLED)
        goto Cleanup; // hr == S_OK;

    SendMessage(
            pDoc->_pInPlace->_hwnd,
            WM_COMMAND,
            GET_WM_COMMAND_MPS(cmdID, NULL, 1));
    hr = S_OK; 

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CElement::GetCommandID
//
//---------------------------------------------------------------
DWORD
CElement::GetCommandID(LPMSG lpmsg)
{
    DWORD   nCmdID;
    ACCELS  *pAccels = NULL;
    HRESULT hr = S_OK;
    
    //
    // Only one set of design time accelerators is now available.  This is
    // because any element can have contentEditable set, so accels have
    // to work for potentially any element.  Removed the design time
    // accels from the classdesc for each element - johnthim
    //
    if( !IsEditable(/*fCheckContainerOnly*/FALSE) )
    {
        pAccels = ElementDesc()->_pAccelsRun;
    }
    else
    {
        VARIANT_BOOL fSupportsHTML;
    
        hr = get_canHaveHTML(&fSupportsHTML);
        if( !FAILED(hr) )
        {
            pAccels = (fSupportsHTML == VB_TRUE) ? &CElement::s_AccelsElementDesign : &CElement::s_AccelsElementDesignNoHTML;
        }
    }

    nCmdID = pAccels ? pAccels->GetCommandID(lpmsg) : IDM_UNKNOWN;

    // IE5 73627 -- If the SelectAll accelerator is received by an element
    // that does not allow selection (possibly because it is in a dialog),
    // treat the accelerator as unknown instead of disabled. This allows the
    // accelerator to bubble up.
    if (nCmdID == IDM_SELECTALL && DisallowSelection())
    {
        nCmdID = IDM_UNKNOWN;
    }

    return nCmdID;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::OnContextMenu
//
//  Synopsis:   Handles WM_CONTEXTMENU message.
//
//--------------------------------------------------------------------------
HRESULT
CElement::OnContextMenu(int x, int y, int id)
{
    int cx = x;
    int cy = y;
    CDoc *  pDoc = Doc();


    if (cx == -1 && cy == -1)
    {
        RECT rcWin;

        GetWindowRect(pDoc->InPlace()->_hwnd, &rcWin);
        cx = rcWin.left;
        cy = rcWin.top;
    }

    {
        EVENTPARAM  param(pDoc, this, NULL, TRUE);
        CTreeNode  *pNode;

        pNode = (pDoc->HasCapture() && pDoc->_pNodeLastMouseOver) ?
                    pDoc->_pNodeLastMouseOver : GetFirstBranch();

        param.SetNodeAndCalcCoordinates(pNode);
        param.SetType(_T("MenuExtUnknown"));

        //
        // we should release out capture
        //

        pDoc->SetMouseCapture(NULL, NULL);
        RRETURN1(THR(pDoc->ShowContextMenu(cx, cy, id, this)), S_FALSE);
    }
}

#ifndef NO_MENU
//+---------------------------------------------------------------
//
//  Member:     CElement::OnMenuSelect
//
//  Synopsis:   Handle WM_MENUSELECT by updating status line text.
//
//----------------------------------------------------------------
HRESULT
CElement::OnMenuSelect(UINT uItem, UINT fuFlags, HMENU hmenu)
{

    CDoc * pDoc = Doc();
    TCHAR  achMessage[FORMS_BUFLEN + 1];

    if (hmenu == NULL && fuFlags == 0xFFFF) // menu closed
    {
        pDoc->SetStatusText(NULL, STL_ROLLSTATUS, GetMarkup());
        return S_OK;
    }
    else if ((fuFlags & (MF_POPUP|MF_SYSMENU)) == 0 && uItem != 0)
    {
        LoadString(
                GetResourceHInst(),
                IDS_MENUHELP(uItem),
                achMessage,
                ARRAY_SIZE(achMessage));
    }

#if 0
    // what's this supposed to do????????????

    else if ((fuFlags & MF_POPUP) && (pDoc->InPlace()->_hmenuShared == hmenu))
    {
        // For top level popup menu
        //
        LoadString(
                GetResourceHInst(),
                IDS_MENUHELP(uItem),
                achMessage,
                ARRAY_SIZE(achMessage));
    }
#endif

    else
    {
        achMessage[0] = TEXT('\0');
    }

    pDoc->SetStatusText(achMessage, STL_ROLLSTATUS, GetMarkup());

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CElement::OnInitMenuPopup
//
//  Synopsis:   Handles WM_CONTEXTMENU message.
//
//---------------------------------------------------------------
inline BOOL IsMenuItemFontOrEncoding(ULONG idm)
{
    return  ( idm >= IDM_MIMECSET__FIRST__ && idm <= IDM_MIMECSET__LAST__)
    ||  ( (idm >= IDM_BASELINEFONT1 && idm <= IDM_BASELINEFONT5)
                       || (idm == IDM_DIRLTR || idm == IDM_DIRRTL) );
}
HRESULT
CElement::OnInitMenuPopup(HMENU hmenu, int item, BOOL fSystemMenu)
{
    int             i;
    MSOCMD          msocmd;
    UINT            mf;

    for(i = 0; i < GetMenuItemCount(hmenu); i++)
    {
        msocmd.cmdID = GetMenuItemID(hmenu, i);
        if (msocmd.cmdID > 0 && !IsMenuItemFontOrEncoding(msocmd.cmdID))
        {
            Doc()->QueryStatusHelper(
                    Document(),
                    (GUID *) &CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
            switch (msocmd.cmdf)
            {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case MSOCMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
            }
            CheckMenuItem(hmenu,  msocmd.cmdID, mf & ~(MF_ENABLED | MF_DISABLED | MF_GRAYED));
            EnableMenuItem(hmenu, msocmd.cmdID, mf & ~(MF_CHECKED | MF_UNCHECKED));
        }
    }
    return S_OK;
}
#endif // NO_MENU

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetColors
//
//  Synopsis:   Gets the color set for the Element.
//
//  Returns:    The return code is as per GetColorSet.
//              If any child site fails, that is our return code.  If any
//              child site returns S_OK, that is our return code, otherwise
//              we return S_FALSE.
//
//----------------------------------------------------------------------------
HRESULT
CElement::GetColors(CColorInfo *pCI)
{
    DWORD_PTR dw = 0;
    HRESULT   hr = S_FALSE;

    CLayout * pLayoutThis = GetUpdatedLayout();
    CLayout * pLayout;

    Assert(pLayoutThis && "CElement::GetColors() should not be called here !!!");
    if (!pLayoutThis)
        goto Error;

    for (pLayout = pLayoutThis->GetFirstLayout(&dw);
         pLayout && !pCI->IsFull() ;
         pLayout = pLayoutThis->GetNextLayout(&dw))
    {
        HRESULT hrTemp = pLayout->ElementOwner()->GetColors(pCI);
        if (FAILED(hrTemp) && hrTemp != E_NOTIMPL)
        {
            hr = hrTemp;
            goto Error;
        }
        else if (hrTemp == S_OK)
            hr = S_OK;
    }

Error:
    if (pLayoutThis)
        pLayoutThis->ClearLayoutIterator(dw, FALSE);
    RRETURN1(hr, S_FALSE);
}

#ifndef NO_DATABINDING

CElement *
CElement::GetElementDataBound()
{
    CElement * pElement = this;
    Assert(ShouldHaveLayout() && "CElement::GetElementDataBound() should not be called !!!");
    return pElement;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::SaveDataIfChanged
//
//  Synopsis:   Determine whether or not is appropate to save the value
//              in  a control to a datasource, and do so.  Fire any appropriate
//              events.
//
//  Arguments:  id     - identifies which binding is being saved
//              fLoud  - should we put an alert in user's face on failure?
//              fForceIsCurrent - treat the element as if it were the current
//                          focus element, even if it's not
//
//  Returns:    S_OK        no work to do, or transfer successful
//              S_FALSE     user reverted value to database version
//
//--------------------------------------------------------------------------
HRESULT
CElement::SaveDataIfChanged(LONG id, BOOL fLoud, BOOL fForceIsCurrent)
{
    HRESULT     hr = S_OK;
    DBMEMBERS * pdbm;

    pdbm = GetDBMembers();
    if (!pdbm)
        goto Cleanup;

    hr = pdbm->SaveIfChanged(this, id, fLoud, fForceIsCurrent);

Cleanup:
    RRETURN1(hr, S_FALSE);
}
#endif // NO_DATABINDING


HRESULT
CElement::ScrollIntoView(SCROLLPIN spVert, SCROLLPIN spHorz, BOOL /*fScrollBits*/)
{
    HRESULT hr = S_OK;
    
    if(GetFirstBranch())
    {
        // If <OPTION> scroll the <SELECT> instead
        if (Tag() == ETAG_OPTION)
        {
            CElement * pElementParent = GetFirstBranch()->Parent()->SafeElement();

            if(pElementParent && pElementParent->Tag() == ETAG_SELECT)
            {
                hr = pElementParent->ScrollIntoView(spVert, spHorz);
            }
        }
        else
        { 
            CLayout *   pLayout;

            hr = THR(EnsureRecalcNotify());
            if (!hr)
            {           
                pLayout = GetUpdatedParentLayout();

                if (pLayout)
                {
                    hr = pLayout->ScrollElementIntoView(this, spVert, spHorz);
                }
            }
        }
    }

    return hr;
}

HRESULT DetectSiteState(CElement * pElement)
{
    CDoc *     pDoc = pElement->Doc();

    if (!pElement->IsInMarkup())
        return E_UNEXPECTED;

    if (pDoc->State() < OS_INPLACE ||
        pDoc->_fHidden == TRUE ||
        !pElement->IsVisible(TRUE) ||
        !pElement->IsEnabled())
        return CTL_E_CANTMOVEFOCUSTOCTRL;

    return S_OK;
}

STDMETHODIMP
CElement::setActive()
{
    CDoc *      pDoc = Doc();
    FOCUS_ITEM  fi;
    HRESULT hr = S_OK ;
    
    if ( ! pDoc->_pInPlace )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if (ETAG_AREA == Tag())
    {
        fi = DYNCAST(CAreaElement, this)->GetFocusItem();
        if (!fi.pElement)
            goto Cleanup;
    }
    else
    {
        fi.pElement = this;
        fi.lSubDivision = 0;
    }

    if (    !(pDoc->_pElemCurrent == fi.pElement && pDoc->_lSubCurrent == fi.lSubDivision)
        &&  fi.pElement->IsFocussable(fi.lSubDivision))
    {
        hr = fi.pElement->BecomeCurrent(fi.lSubDivision,
                                        /* pfYieldFailed        */  NULL,
                                        /* pMessage             */  NULL,
                                        /* fTakeFocus           */  FALSE,
                                        /* lButton              */  0,
                                        /* pfDisallowedByEd     */  NULL,
                                        /* fFireFocusBlurEvents */  FALSE);
    }
    
Cleanup:
    if (S_OK == hr && this != pDoc->_pElemCurrent)
    {
        hr = S_FALSE;
    }
    RRETURN1(SetErrorInfo(hr), S_FALSE);
}

STDMETHODIMP
CElement::focus()
{
    RRETURN(THR(
        (ETAG_AREA == Tag())?
                DYNCAST(CAreaElement, this)->focus()
            :   focusHelper(0)
    ));
}


HRESULT
CElement::focusHelper(long lSubDivision)
{
    HRESULT     hr              = S_OK;
    CDoc *      pDoc        = Doc();
    BOOL        fTakeFocus;

    // TODO(sramani): Hack for IE5 bug# 56032. Don't allow focus() calls on
    // hidden elements in outlook98 organize pane to return an error.

    if (!_tcsicmp(pDoc->GetPrimaryUrl(), _T("outday://")) && !IsVisible(TRUE))
        goto Cleanup;

    // bail out if the site has been detached, or the doc is not yet inplace, etc.
    hr = THR(DetectSiteState(this));
    if (hr)
        goto Cleanup;

    // if called on body, delegate to the window
    if (Tag() == ETAG_BODY)
    {
        if (IsInMarkup())
        {
            CMarkup *   pMarkup = GetMarkup();
            if (pMarkup->HasWindow())
            {
                hr = THR(pMarkup->Window()->focus());
                if (hr)
                    goto Cleanup;
            }
        }
        goto Cleanup;
    }

    if (!IsFocussable(lSubDivision))
        goto Cleanup;

    // if our thread does not have any active windows, make ourselves the foreground window
    // (above all other top-level windows) only if the current foreground is a browser window
    // else make ourselves come above the topmost browser window if any, else do nothing.
    fTakeFocus = pDoc->_pInPlace && !MakeThisTopBrowserInProcess(pDoc->_pInPlace->_hwnd);

    pDoc->_fFirstTimeTab = FALSE;

    hr = BecomeCurrent(lSubDivision, NULL, NULL, fTakeFocus);
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    IGNORE_HR(ScrollIntoView(SP_MINIMAL, SP_MINIMAL));

    hr = THR(BecomeUIActive());

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


STDMETHODIMP
CElement::blur()
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    if (ETAG_AREA == Tag())
    {
        hr = THR(DYNCAST(CAreaElement, this)->blur());
        goto Cleanup;
    }

    if (!IsInMarkup())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // if called on body, delegate to the window
    if (Tag() == ETAG_BODY)
    {
        if (IsInMarkup())
        {
            CMarkup *   pMarkup = GetMarkup();
            if (pMarkup->HasWindow())
            {
                hr = THR(pMarkup->Window()->blur());
                if (hr)
                    goto Cleanup;
            }
        }
        goto Cleanup;
    }

    // Don't blur current object in focus if called on
    // another object that does not have the focus or if the
    // frame in which this object is does not currently have the focus
    if (    this != pDoc->_pElemCurrent 
        ||  (       (::GetFocus() != pDoc->_pInPlace->_hwnd)
                &&  Tag() != ETAG_SELECT))
        goto Cleanup;

    hr = THR(GetMarkup()->GetElementTop()->BecomeCurrent(0));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::addFilter(IUnknown *pUnk)
{
    HRESULT hr = E_NOTIMPL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::removeFilter(IUnknown *pUnk)
{
    HRESULT hr = E_NOTIMPL;
    RRETURN(SetErrorInfo(hr));
}

BOOL
CElement::HasVerticalLayoutFlow()
{
    BOOL fVert = FALSE;

    if (   GetMarkup()
        && GetMarkup()->_fHaveDifferingLayoutFlows)
    {
        CTreeNode * pNode = GetFirstBranch();

        if (pNode)
        {
            const CCharFormat  * pCF = pNode->GetCharFormat();
            if (pCF)
                fVert = pCF->HasVerticalLayoutFlow();
        }
    }
    return fVert;
}

//+----------------------------------------------------------
//
//  member  :   get_clientWidth, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      width (not counting scrollbar, borders..)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientWidth( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientWidth_Logical(pl);
    }
    else 
    {
        return get_clientHeight_Logical(pl);
    }
}

HRESULT CElement::get_clientWidth_Logical( long * pl)
{
    HRESULT hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        CLayout * pLayout;
        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if(pLayout)
        {
            RECT    rect;
            const CUnitInfo *pUnitInfo = &g_uiDisplay;

            // TR's are strange beasts since they have layout but
            // no display (unless they are positioned....
            if (Tag() == ETAG_TR)
            {
                CDispNode * pDispNode = pLayout->GetElementDispNode();
                if (!pDispNode)
                {
                    // we don't have a display so GetClientRect will return 0
                    // so rather than this, default to the offsetWidth.  This
                    // is the same behavior as scrollWidth
                    hr = get_offsetWidth(pl);
                    goto Cleanup;
                }
            }

            pLayout->GetClientRect(&rect, CLIENTRECT_CONTENT);

            *pl = rect.right - rect.left;

            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout) 
                            ? (pLayout->LayoutContext()) 
                                    ? pLayout->LayoutContext() 
                                    : pLayout->DefinedLayoutContext() 
                            : NULL;

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());

               pUnitInfo = pdiTemp->GetUnitInfo();
            }

            *pl = pUnitInfo->DocPixelsFromDeviceX(*pl);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientHeight, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      Height of the body
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientHeight( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientHeight_Logical(pl);
    }
    else 
    {
        return get_clientWidth_Logical(pl);
    }
}

HRESULT
CElement::get_clientHeight_Logical( long * pl)
{
    HRESULT hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        CLayout * pLayout;
        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if(pLayout)
        {
            RECT    rect;
            const   CUnitInfo *pUnitInfo = &g_uiDisplay;

            // TR's are strange beasts since they have layout but
            // no display (unless they are positioned....
            if (Tag() == ETAG_TR)
            {
                CDispNode * pDispNode = pLayout->GetElementDispNode();
                if (!pDispNode)
                {
                    // we don't have a display so GetClientRect will return 0
                    // so rather than this, default to the offsetHeight. This
                    // is the same behavior as scrollHeight
                    hr = get_offsetHeight(pl);
                    goto Cleanup;
                }
            }

            pLayout->GetClientRect(&rect, CLIENTRECT_CONTENT);

            *pl = rect.bottom - rect.top;
            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout) 
                            ? (pLayout->LayoutContext()) 
                                    ? pLayout->LayoutContext() 
                                    : pLayout->DefinedLayoutContext() 
                            : NULL;

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());
               pUnitInfo = pdiTemp->GetUnitInfo();
            }

            *pl = pUnitInfo->DocPixelsFromDeviceY(*pl);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientTop, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      Top (inside borders)
//
//-----------------------------------------------------------
HRESULT
CElement::get_clientTop( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientTop_Logical(pl);
    }
    else 
    {
        return get_clientLeft_Logical(pl);
    }
}


//+----------------------------------------------------------
//
//  member  :   get_clientTop_Logical
//
//  synopsis    :   returns a long value of the client window
//      Top (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientTop_Logical( long * pl)
{
    HRESULT     hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout *   pLayout;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        if (pLayout)
        {
            CDispNode * pDispNode= pLayout->GetElementDispNode();

            if (pDispNode)
            {
                CRect rcBorders;
                const CUnitInfo *pUnitInfo = &g_uiDisplay;

                pDispNode->GetBorderWidths(&rcBorders);

                *pl = rcBorders.top;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }

                *pl = pUnitInfo->DocPixelsFromDeviceY(*pl);
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientLeft, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      Left (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientLeft( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientLeft_Logical(pl);
    }
    else 
    {
        return get_clientBottom_Logical(pl);
    }
}

//+----------------------------------------------------------
//
//  member  :   get_clientLeft_Logical
//
//  synopsis    :   returns a long value of the client window
//      Left (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientLeft_Logical( long * pl)
{
    HRESULT     hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout *   pLayout;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout   = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            CDispNode * pDispNode= pLayout->GetElementDispNode();

            if (pDispNode)
            {
                // border and scroll widths are dynamic. This method
                // provides a good way to get the client left amount
                // without having to have special knowledge of the
                // display tree workings. We are getting the distance
                // between the top left of the client rect and the
                // top left of the container rect.
                CRect rcClient;
                pLayout->GetClientRect(&rcClient);
                CPoint pt;
                const CUnitInfo *pUnitInfo = &g_uiDisplay;

                pDispNode->TransformPoint(rcClient.TopLeft(), COORDSYS_FLOWCONTENT, &pt, COORDSYS_BOX);

                *pl = pt.x;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }

                *pl = pUnitInfo->DocPixelsFromDeviceX(*pl);
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientBottom_Logical
//
//  synopsis    :   returns a long value of the client window
//      Bottom (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientBottom_Logical( long * pl)
{
    HRESULT     hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout *   pLayout;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout   = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            CDispNode * pDispNode= pLayout->GetElementDispNode();

            if (pDispNode)
            {
                // border and scroll widths are dynamic. This method
                // provides a good way to get the client left amount
                // without having to have special knowledge of the
                // display tree workings. We are getting the distance
                // between the top left of the client rect and the
                // top left of the container rect.
                CRect rcClient;
                pLayout->GetClientRect(&rcClient);
                CPoint pt;
                CSize sz;
                
                pDispNode->TransformPoint(rcClient.BottomRight(), COORDSYS_FLOWCONTENT, &pt, COORDSYS_BOX);
                sz = pDispNode->GetSize();
                *pl = sz.cy - pt.y;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                    *pl = pdiTemp->DocPixelsFromDeviceY(*pl);
                }
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::SetDefaultElem
//
//  Synopsis:   Set the default element
//  Parameters:
//              fFindNew = TRUE: we need to find a new one
//                       = FALSE: set itself to be the default if appropriate
//
//-------------------------------------------------------------------------
void
CElement::SetDefaultElem(BOOL fFindNew /* FALSE */)
{
    CFormElement    * pForm = GetParentForm();
    CElement        **ppElem;
    CDoc            * pDoc  = Doc();

    ppElem = pForm ? &pForm->_pElemDefault : &pDoc->_pElemDefault;

    Assert(TestClassFlag(ELEMENTDESC_DEFAULT));
    if (fFindNew)
    {
        // Only find the new when the current is the default and
        // the document is not deactivating
        *ppElem = (*ppElem == this
                    && pDoc->_pInPlace
                    && !pDoc->_pInPlace->_fDeactivating) ?
                                    FindDefaultElem(TRUE, TRUE) : 0;
        Assert(*ppElem != this);
    }
    else if (!*ppElem || (*ppElem)->GetSourceIndex() > GetSourceIndex())
    {
                if (IsEnabled() && IsVisible(TRUE))
        {
            *ppElem = this;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::FindDefaultElem
//
//  Synopsis:   Find the default element
//
//-------------------------------------------------------------------------

CElement *
CElement::FindDefaultElem(BOOL fDefault,
                          BOOL fFull    /* = FALSE */)
{
    CElement        * pElem = NULL;
    CFormElement    * pForm = NULL;
    CDoc *            pDoc = Doc();

    if (!pDoc || !pDoc->_pInPlace || pDoc->_pInPlace->_fDeactivating)
        return NULL;

    if (!fFull && (fDefault ? _fDefault : FALSE))
        return this;

    pForm = GetParentForm();

    if (pForm)
    {
        if (fFull)
        {
            pElem = pForm->FindDefaultElem(fDefault, FALSE);
            if (fDefault)
            {
                pForm->_pElemDefault = pElem;
            }
        }
        else
        {
            Assert(fDefault);
            pElem = pForm->_pElemDefault;
        }
    }
    else
    {
        if (fFull)
        {
            pElem = GetMarkup()->FindDefaultElem(fDefault, FALSE);
            if (fDefault)
            {
                pDoc->_pElemDefault = pElem;
            }
        }
        else
        {
            Assert(fDefault);
            pElem = pDoc->_pElemDefault;
        }
    }

    return pElem;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::get_uniqueNumber
//
//  Synopsis:   Compute a unique ID of the element regardless of the id
//              or name property (these could be non-unique on our page).
//              This function guarantees a unique name which will not change
//              for the life of this document.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_uniqueNumber(long *plUniqueNumber)
{
    HRESULT     hr = S_OK;
    CStr        cstrUniqueName;
    TCHAR      *pFoundStr;

    hr = THR(GetUniqueIdentifier(&cstrUniqueName, TRUE));
    if (hr)
        goto Cleanup;

    pFoundStr = StrStr(cstrUniqueName, UNIQUE_NAME_PREFIX);
    if (pFoundStr)
    {
        pFoundStr += lstrlenW(UNIQUE_NAME_PREFIX);

        if (ttol_with_error(pFoundStr, plUniqueNumber))
        {
            *plUniqueNumber = 0;            // Unknown number.
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::get_uniqueID
//
//  Synopsis:   Compute a unique ID of the element regardless of the id
//              or name property (these could be non-unique on our page).
//              This function guarantees a unique name which will not change
//              for the life of this document.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_uniqueID(BSTR * pUniqueStr)
{
    HRESULT     hr = S_OK;
    CStr        cstrUniqueName;

    hr = THR(GetUniqueIdentifier(&cstrUniqueName, TRUE));
    if (hr)
        goto Cleanup;

    hr = cstrUniqueName.AllocBSTR(pUniqueStr);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::NoUIActivate
//
//  Synopsis:   Determines if this site does not allow UIActivation
//
//  Arguments:  none
//
//--------------------------------------------------------------------------
BOOL
CElement::NoUIActivate()
{
    return (    _fNoUIActivate
            || (    IsEditable(/*fCheckContainerOnly*/TRUE)
                &&  _fNoUIActivateInDesign));
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::GetSubDivisionCount
//
//  Synopsis:   Get the count of subdivisions for this element
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetSubDivisionCount(long *pc)
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2;
    ISubDivisionProvider *  pProvider = NULL;

    *pc = 0;
    if (HasPeerHolder())
    {
        CPeerHolder *pHolder = GetPeerHolder();

        if (pHolder->_pPeerUI)
        {
            hr2 = THR(pHolder->_pPeerUI->GetSubDivisionProvider(&pProvider));
            if (hr2)
            {
                // if this failed - e.g. peer does not implement subdivision provider, -
                // we still want to keep looking for next tab stop, so we supress the error here
                Assert (S_OK == hr);
                goto Cleanup;
            }

            hr = THR(pProvider->GetSubDivisionCount(pc));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::GetSubDivisionTabs
//
//  Synopsis:   Get the tabindices of subdivisions for this element
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetSubDivisionTabs(long *pTabs, long c)
{
    HRESULT                 hr = S_OK;
    ISubDivisionProvider *  pProvider = NULL;

    if (HasPeerHolder())
    {
        CPeerHolder *pHolder = GetPeerHolder();

        if (pHolder->_pPeerUI)
        {
            hr = THR(pHolder->_pPeerUI->GetSubDivisionProvider(&pProvider));
            if (hr)
                goto Cleanup;

            hr = THR(pProvider->GetSubDivisionTabs(c, pTabs));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert(c == 0);
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SubDivisionFromPt
//
//  Synopsis:   Perform a hittest of subdivisions for this element
//
//-------------------------------------------------------------------------

HRESULT
CElement::SubDivisionFromPt(POINT pt, long *plSub)
{
    HRESULT                 hr = S_OK;
    ISubDivisionProvider *  pProvider = NULL;

    *plSub = 0;
    if (HasPeerHolder())
    {
        CPeerHolder *pHolder = GetPeerHolder();

        if (pHolder->_pPeerUI)
        {
            hr = THR_NOTRACE(pHolder->_pPeerUI->GetSubDivisionProvider(&pProvider));
            if (hr)
                goto Cleanup;

            hr = THR(pProvider->SubDivisionFromPt(pt, plSub));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetNextSubdivision
//
//  Synopsis:   Finds the next tabbable subdivision which has tabindex
//              == 0.  This is a helper meant to be used by SearchFocusTree.
//
//  Returns:    The next subdivision in plSubNext.  Set to -1, if there is no
//              such subdivision.
//
//  Notes:      lSubDivision coming in can be set to -1 to search for the
//              first possible subdivision.
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetNextSubdivision(
    FOCUS_DIRECTION dir,
    long lSubDivision,
    long *plSubNext)
{
    HRESULT hr = S_OK;
    long    c;
    long *  pTabs = NULL;
    long    i;

    hr = THR(GetSubDivisionCount(&c));
    if (hr)
        goto Cleanup;

    if (!c)
    {
        *plSubNext = (lSubDivision == -1) ? 0 : -1;
        goto Cleanup;
    }

    pTabs = new (Mt(CElementGetNextSubDivision_pTabs)) long[c];
    if (!pTabs)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(GetSubDivisionTabs(pTabs, c));
    if (hr)
        goto Cleanup;

    if (lSubDivision < 0 && dir == DIRECTION_BACKWARD)
    {
        lSubDivision = c;
    }

    //
    // Search for the next subdivision if possible to tab to it.
    //

    for (i = (DIRECTION_FORWARD == dir) ? lSubDivision + 1 :  lSubDivision - 1;
         (DIRECTION_FORWARD == dir) ? i < c : i >= 0;
         (DIRECTION_FORWARD == dir) ? i++ : i--)
    {
        if (pTabs[i] == 0 || pTabs[i] == htmlTabIndexNotSet)
        {
            //
            // Found something to tab to! Return it.  We're
            // only checking for zero here because negative
            // tab indices means cannot tab to them.  Positive
            // ones would already have been put in the focus array
            //

            *plSubNext = i;
            goto Cleanup;
        }
    }

    //
    // To reach here means that there are no further tabbable
    // subdivisions in this element.
    //

    *plSubNext = -1;

Cleanup:
    delete [] pTabs;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasTabIndex
//
//  Synopsis:   Checks if this element already has a tabIndex
//
//----------------------------------------------------------------------------

BOOL
CElement::HasTabIndex()
{
    long    lCount;

    return (OK(GetSubDivisionCount(&lCount)) && 
            lCount == 0                      && 
            GetAAtabIndex() > 0               );
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasCurrency
//
//  Synopsis:   Checks if this element has currency. If this element is a slave,
//              check if its master has currency.
//
//  Notes:      Can't inline, because that would need including the defn of
//              CDoc in element.hxx.
//
//----------------------------------------------------------------------------

BOOL
CElement::HasCurrency()
{
    CElement * pElemCurrent = Doc()->_pElemCurrent;

    return (    this
            &&  pElemCurrent
            &&  (pElemCurrent == this || (HasMasterPtr() && pElemCurrent == GetMasterPtr())));
}

BOOL
CElement::IsInPrimaryMarkup() const
{
    CMarkup * pMarkup = GetMarkup();

    return pMarkup ? pMarkup->IsPrimaryMarkup() : FALSE;
}

BOOL
CElement::IsInThisMarkup ( CMarkup* pMarkupIn ) const
{
    CMarkup * pMarkup = GetMarkup();

    return pMarkup == pMarkupIn;
}

CRootElement *
CElement::MarkupRoot()
{
    CMarkup * pMarkup = GetMarkup();

    return (pMarkup ? pMarkup->Root() : NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::Init
//
//  Synopsis:   Do any element initialization here, called after the element is
//              created from CreateElement()
//
//----------------------------------------------------------------------------

HRESULT
CElement::Init()
{
    HRESULT hr;

    hr = THR( super::Init() );

    if (hr)
        goto Cleanup;

    //  CSite derived classes will overwrite this in their constructor.
    _fLayoutAlwaysValid = !!TestClassFlag(ELEMENTDESC_NOLAYOUT);

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

// Assert and fix up layout context so that it doesn't mess up this element's layouts
void CElement::ValidateLayoutContextCore(CLayoutContext **ppLayoutContext) const
{
    CLayout *pLayoutOwner;
    CElement *pElementOwner;

    // We expect a valid pointer and a valid layout
    Assert(ppLayoutContext);
    if (IsFirstLayoutContext(*ppLayoutContext))
        return;

    Assert(!IsBadWritePtr(*ppLayoutContext, sizeof(CLayoutContext)));
    Assert((*ppLayoutContext)->IsValid());

    pLayoutOwner = (*ppLayoutContext)->GetLayoutOwner();   

    Assert(pLayoutOwner);
    Assert(!IsBadWritePtr(pLayoutOwner, sizeof(CLayout)));
    pElementOwner = pLayoutOwner->ElementOwner();
    
    Assert(pElementOwner);
    Assert(!IsBadWritePtr(pElementOwner, sizeof(CElement)));
    
    // VALID CASE: A child is trying to get parent layout with context passed by parent.
    //             If this is the context we define, change it to our containing context.
    if ((*ppLayoutContext)->GetLayoutOwner()->ElementOwner() == this)
    {
        // return containing context
        // TODO LRECT 112511: The intention of this method is to catch places where layout context is
        //                         incorrect. As a validator, it should be debug-only. If there is work it 
        //                         needs to do in retail, it should be split into retail and debug parts
        
        *ppLayoutContext = (*ppLayoutContext)->GetLayoutOwner()->LayoutContext();
        return;
    }
    
    // Check that this context is not from one of our children 
    {
        for (CElement *pElement = pElementOwner; pElement;)
        {
            // Do we see ourselves?
            if (pElement == this)
            {
                AssertSz(0, "Child layout context used on parent");
                goto Bad;
            }

            // get parent. go to master markup if necessary
            if (pElement->HasMasterPtr())
            {
                Assert(pElement != GetMasterPtr());
                pElement = GetMasterPtr();
            }
            else
            {
                CTreeNode *pNode = pElement->GetFirstBranch();
                if (pNode)
                    pNode = pNode->Parent();

                if (pNode)
                    pElement = pNode->Element();
                else
                    pElement = NULL;
            }

            // Do we see the context owner again?
            if (pElement == pElementOwner)
            {
                AssertSz(0, "Loop in layout contexts detected");
                goto Bad;
            }
        }
    }

    // More stuff can be verified here...
    return;
    
Bad:
    *ppLayoutContext = NULL;
}

#if DBG == 1
void CElement::AssertAppropriateLayoutContextInGetUpdatedLayout(CLayoutContext *pLayoutContext)
{
    if (IsFirstLayoutContext(pLayoutContext) 
        && !IsExplicitFirstLayoutContext(pLayoutContext)
        && HasLayoutAry()
        && GetLayoutAry()->Size() > 1)
    {
        // If we get here, we are a context-free call and we know we
        // are supposed to have at least 1 layout with context.  
        // This _may_ be a bug;
        // all such calls should be examined. There are cases where
        // the caller doesn't care about context; once it's been
        // determined that a particular caller legitimately isn't
        // passing context, that caller should be modified to pass
        // GUL_USEFIRSTLAYOUT, which is an explicit statement that
        // getting the first layout associated with the element is
        // good enough.

        // In retail we always just allow it silently.
        // In debug, we only allow it if GUL_USEFIRSTLAYOUT was
        // explicitly passed -- otherwise we assert, unless the
        // AllowGULBugs trace tag is on, in which case we log it.
        // Returning the first layout in our collection.
        if ( IsTagEnabled(tagLayoutAllowGULBugs) )
        {
            // In debug, log the fact that we allowed a buggy call
            TraceTag((tagLayoutAllowGULBugs, "GULBUG: Call to GetUpdatedLayout w/o context when required!"));
        }
        else
        {
            // We can only be here if in debug and the tag is off.
            Assert( FALSE && "GULBUG: Call to GetUpdatedLayout w/o context when required!" );
        }
    }
}
#endif

//
//  In the single layout case (null context):
//  If we already have a layout, this will return it whether we really need it or not.
//  This harmless cheat significantly speeds up calls to this function (though it may
//  result in a little extra work being done by people diddling with transient layouts).
//  Right now, this is a small perf win, esp. with tables.
//  If we really need to know if we need a layout, call ShouldHaveLayout .
//  In the multiple layout case (non-null context):
//  If we should have layout, we get it (creating it if necessary).
//  Otherwise we return NULL.
//
CLayout *
CElement::GetUpdatedLayoutWithContext( CLayoutContext *pLayoutContext )
{
    ValidateLayoutContext(&pLayoutContext);
    
    // Asking for the first available?
    if (IsFirstLayoutContext(pLayoutContext))
    {
        if ( HasLayoutPtr() )
        {
            // NOTE: GetUpdatedLayout handles this, but the context may be changed by ValidateLayoutContext
            return GetLayoutPtr();
        }

        if ( HasLayoutAry() )
        {
            AssertAppropriateLayoutContextInGetUpdatedLayout(pLayoutContext);
            return EnsureLayoutAry()->GetLayoutWithContext(NULL);
        }

        // Create a layout if we need one.
        // NOTE: we don't check this up-front, because it is an expensive check, involving format calculation
        if ( ShouldHaveLayout())
        {
            // No layouts exist so far. Search for default layout context.
            // CAUTION: this call forces layout creation for all layout parents
            CLayout *pLayout = EnsureLayoutInDefaultContext();

            // note: this assert goes after EnsureLayout, so that we know what kind of layout is there.
            AssertAppropriateLayoutContextInGetUpdatedLayout(pLayoutContext);
            return pLayout;
        }
        
        return NULL;
    }
    
    // Explicit multiple layout case (non-NULL layout context)
    
    // PERF: MAJOR potential perf problem here.  Really need to think about how to
    // make this efficient in face of lots of callers.  One problem is that it's unclear whether
    // checking for existing layout w/ context (which requires walking the collection) is cheaper
    // than asking whether the element needs layout (which may require format computation).

    if ( ShouldHaveLayout()) // TODO (t-michda) ShouldHaveLayout should be passed
                             // context, but I can't pass it a format context since
                             // CLayoutContext::GetFormatContext won't compile here...
    {
        CLayout *pLayout = EnsureLayoutAry()->GetLayoutWithContext( pLayoutContext );
        return ( pLayout ? pLayout : CreateLayout( pLayoutContext ) );
    }
    return NULL;
}


//
// Create layout in default context. 
// Ensures that all layout parents have layouts.
//
CLayout * 
CElement::EnsureLayoutInDefaultContext()
{
    Assert(ShouldHaveLayout()); // This really shouldn't be caled if element doesn't need a layout

    // first, see if we have a valid layout
    if (CurrentlyHasAnyLayout())
    {
        Assert(GetUpdatedLayout(GUL_USEFIRSTLAYOUT));        
        return GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
    }
    
    // OK, we don't have any layout yet. Find layout parent to get context from them.
    // This should go up the master chain if needed (see assert below).
    CElement * pParent = GetUpdatedParentLayoutElement();   // if there is a parent layout element, go there
    Assert(!HasMasterPtr() || pParent == GetMasterPtr());

    CLayoutContext *pLayoutContext = NULL;

    // If we have a parent, recursively ensure its default layout and get context from it.
    // Otherwise we are the root, and we'll create a layout with NULL context
    if (pParent)
    {
        // Recursively call the parent.
        // NOTE: we'll be in trouble here if we fail to detect cycles
        CLayout *pParentDefaultLayout = pParent->EnsureLayoutInDefaultContext();
        
        Assert(pParentDefaultLayout);
        if (pParentDefaultLayout->HasDefinedLayoutContext())
            pLayoutContext = pParentDefaultLayout->DefinedLayoutContext();
        else
            pLayoutContext = pParentDefaultLayout->LayoutContext();
    }
    AssertValidLayoutContext(pLayoutContext);

    // Now create a layout with this context
    return CreateLayout( pLayoutContext );
}

CLayoutAry *
CElement::EnsureLayoutAry()
{
    CLayoutAry *pLA;
    
    if ( HasLayoutAry() )
    {
        pLA = (CLayoutAry*)_pLayoutInfo;
        Assert( _pLayoutAryDbg == pLA );
    }
    else
    {
        // Need to instantiate a layout array and hook it up to the __pvChain. 

        // If we already have a layout, we need to get rid of it.  We can't make use
        // of it anymore because it was created w/o context (for speed/space reasons in the old world).
        if ( HasLayoutPtr() )
        {
            // TODO LRECT 112511: Change this assert to only fire for actual bugs.
            //                 We should be able to figure out when a layout should not be
            //                 removed, or when the old layout should not be there withoug a context.
            AssertSz( !IsTagEnabled(tagLayoutTrackMulti), "removing a layout in EnsureLayoutAry");

            // If we are deleting a layout which defines a context, we'll probably crash soon.
            // TODO LRECT 112511: we need to be more robust in regards to layout/layoutcontext lifetime
            AssertSz( !GetLayoutPtr()->HasDefinedLayoutContext(), "removing a layout with defined context in EnsureLayoutAry");
        
            CLayout * pLayout = DelLayoutPtr();

            if (Tag() == ETAG_TABLE)
            {
                WHEN_DBG(pLayout->_fSizeThis    = FALSE);
                WHEN_DBG(pLayout->_fForceLayout = FALSE);

                // In a case of table element we shouldn't delete layout but instead of this 
                // just save it into element as a table layout cache
                DYNCAST(CTable, this)->SetTableLayoutCache(DYNCAST(CTableLayout, pLayout));

                // (bug # 90460) restore markup pointer on layout cache
#if DBG ==1
                if ( _fHasMarkupPtr )
                {
                    pLayout->_pMarkupDbg = _pMarkupDbg;
                }
#endif
                pLayout->__pvChain = __pvChain;
                pLayout->_fHasMarkupPtr = _fHasMarkupPtr;
            }
            else if (Tag() == ETAG_TR)
            {
                // In a case of table row element we shouldn't delete layout but instead of this 
                // just save it into element as a table layout cache
                DYNCAST(CTableRow, this)->SetRowLayoutCache(DYNCAST(CTableRowLayout, pLayout));

                // (bug # 90460) restore markup pointer on layout cache
#if DBG ==1
                if ( _fHasMarkupPtr )
                {
                    pLayout->_pMarkupDbg = _pMarkupDbg;
                }
#endif
                pLayout->__pvChain = __pvChain;
                pLayout->_fHasMarkupPtr = _fHasMarkupPtr;
            }
            else
            {
                pLayout->Detach();
                pLayout->Release();
            }
        }

        Assert( !HasLayoutPtr() );

        pLA = new CLayoutAry( this );
        if ( !pLA )
        {
            goto Cleanup;
        }

        // Layout array's __pvChain behaves like a layout's; could point at
        // a markup or doc.
        pLA->__pvChain = __pvChain;
        _pLayoutInfo = pLA;

#if DBG ==1
        if ( _fHasMarkupPtr )
        {
            pLA->_pMarkupDbg = _pMarkupDbg;
        }
#endif
        pLA->_fHasMarkupPtr = _fHasMarkupPtr;
        
        WHEN_DBG(_pLayoutAryDbg = pLA);
        _fHasLayoutAry = TRUE;

    }

    
Cleanup:
    Assert( pLA && "Must have an array" );
    return pLA;
}

//+----------------------------------------------------------------
//
//  Memeber : DelLayoutAry
//
//  Synopsis : responsible for cleaning up the layout arrays and 
//      cached layouts under a number of situations.
//
//  Argument : fComplete - TRUE if alls layouts should be detached
//                       - FALSE if the ary should be detached, and the cache restored.
//
//-----------------------------------------------------------------
void
CElement::DelLayoutAry( BOOL fComplete /* == TRUE */)
{
    Assert( HasLayoutAry() );
    Assert( (CLayoutAry *)_pLayoutInfo == _pLayoutAryDbg );
    
    if (fComplete)
    {
        // If we are a table detach table cache first.
        // Note : order is important (CTable::TableLayoutCache() will be confused after 
        // layout array is destroyed!)
        if (Tag() == ETAG_TABLE)
        {
            CLayout *pLayout = DYNCAST(CTable, this)->TableLayoutCache();
            pLayout->Detach();
            pLayout->Release();
            DYNCAST(CTable, this)->SetTableLayoutCache(NULL);
        }
        // If we are a table row detach row cache first.
        // Note : order is important (CTableRow::RowLayoutCache() will be confused after 
        // layout array is destroyed!)
        else if (Tag() == ETAG_TR)
        {
            CLayout *pLayout = DYNCAST(CTableRow, this)->RowLayoutCache();
            pLayout->Detach();
            pLayout->Release();
            DYNCAST(CTableRow, this)->SetRowLayoutCache(NULL);
        }
    }

    // Detach layouts in the array.
    CLayoutAry * pLA = (CLayoutAry*)_pLayoutInfo;

    __pvChain = pLA->__pvChain;

    WHEN_DBG( _pLayoutAryDbg = NULL);
    _fHasLayoutAry = FALSE;

    if (HasMarkupPtr())
        pLA->DelMarkupPtr();
    delete pLA;

    if (!fComplete)
    {
        // at this point the layout Array is gone, but the cache remains.
        // we need to move the cache into the layoutPtr position
        if (Tag() == ETAG_TABLE)
        {
            CLayout *pLayout = DYNCAST(CTable, this)->TableLayoutCache();

            //  Before call to SetLayoutPtr delete markup ptr on cached layout if any
            //  (consistency with CElement::EnsureLayoutAry)
            if (pLayout->_fHasMarkupPtr)
                pLayout->DelMarkupPtr();

            SetLayoutPtr(pLayout);

            DYNCAST(CTable, this)->SetTableLayoutCache(NULL);
        }
        else if (Tag() == ETAG_TR)
        {
            CLayout *pLayout = DYNCAST(CTableRow, this)->RowLayoutCache();

            //  Before call to SetLayoutPtr delete markup ptr on cached layout if any
            //  (consistency with CElement::EnsureLayoutAry)
            if (pLayout->_fHasMarkupPtr)
                pLayout->DelMarkupPtr();

            SetLayoutPtr(pLayout);

            DYNCAST(CTableRow, this)->SetRowLayoutCache(NULL);
        }
    }
}

// TODO (KTam): Why aren't these implemented as virtuals on CLayoutInfo?
// (possible excuse: we may have done this before introducing CLayoutInfo)

BOOL
CElement::LayoutContainsRelative()
{
    if ( HasLayoutPtr() )
    {
        return GetLayoutPtr()->_fContainsRelative;
    }
    else if ( HasLayoutAry() )
    {
        return GetLayoutAry()->ContainsRelative();
    }
    return FALSE;
}

BOOL
CElement::LayoutGetEditableDirty()
{
    if ( HasLayoutPtr() )
    {
        return GetLayoutPtr()->_fEditableDirty;
    }
    else if ( HasLayoutAry() )
    {
        return GetLayoutAry()->GetEditableDirty();
    }
    return FALSE;
}

void
CElement::LayoutSetEditableDirty( BOOL fEditableDirty )
{
    if ( HasLayoutPtr() )
    {
        GetLayoutPtr()->_fEditableDirty = fEditableDirty;
    }
    else if ( HasLayoutAry() )
    {
        GetLayoutAry()->SetEditableDirty( fEditableDirty );
    }
}

void            
CElement::SetLayoutPtr( CLayout * pLayout )
{ 
    Assert( ! HasLayoutPtr() );
    Assert( ! pLayout->_fHasMarkupPtr );

    pLayout->__pvChain = __pvChain; 
    _pLayoutInfo = pLayout;

#if DBG ==1
    if ( _fHasMarkupPtr )
    {
        pLayout->_pMarkupDbg = _pMarkupDbg;
    }
#endif
    pLayout->_fHasMarkupPtr = _fHasMarkupPtr;

    WHEN_DBG(_pLayoutDbg = pLayout);
    _fHasLayoutPtr = TRUE;
}

CLayout *       
CElement::DelLayoutPtr()
{ 
    Assert( HasLayoutPtr() );

    Assert( (CLayout *) _pLayoutInfo == _pLayoutDbg );
    CLayout * pLayoutRet = (CLayout*)_pLayoutInfo;

    __pvChain = pLayoutRet->__pvChain;

    WHEN_DBG( _pLayoutDbg = NULL);
    _fHasLayoutPtr = FALSE;

    if (HasMarkupPtr())
        pLayoutRet->DelMarkupPtr();

    return pLayoutRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetMarkupPtr
//
//  Synopsis:   Get the markup pointer if any
//
//----------------------------------------------------------------------------
CMarkup *
CElement::GetMarkupPtr() const
{
    if (HasMarkupPtr())
    {
        void * pv = __pvChain;

        if (CurrentlyHasAnyLayout())
            pv = _pLayoutInfo->__pvChain;

        Assert( pv == _pMarkupDbg );
        return (CMarkup *)pv;
    }

    Assert( NULL == _pMarkupDbg );

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::SetMarkupPtr
//
//  Synopsis:   Set the markup pointer
//
//----------------------------------------------------------------------------
void
CElement::SetMarkupPtr( CMarkup * pMarkup )
{
    Assert( ! HasMarkupPtr() );
    Assert( pMarkup );

    if (CurrentlyHasAnyLayout())
    {
        Assert(     (HasLayoutPtr() &&  (CLayout *)_pLayoutInfo == _pLayoutDbg )
               ||   (HasLayoutAry() &&  (CLayoutAry *)_pLayoutInfo == _pLayoutAryDbg ));
        _pLayoutInfo->SetMarkupPtr(pMarkup);
    }
    else
    {
        Assert( pMarkup->Doc() == _pDocDbg );
        _pMarkup = pMarkup;
    }

    WHEN_DBG( _pMarkupDbg = pMarkup );
    _fHasMarkupPtr = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DelMarkupPtr
//
//  Synopsis:   Remove the markup pointer
//
//----------------------------------------------------------------------------
void
CElement::DelMarkupPtr( )
{
    Assert( HasMarkupPtr() );

    if (CurrentlyHasAnyLayout())
    {
        Assert(     (HasLayoutPtr() &&  (CLayout *)_pLayoutInfo == _pLayoutDbg )
               ||   (HasLayoutAry() &&  (CLayoutAry *)_pLayoutInfo == _pLayoutAryDbg ));
        Assert(_pLayoutInfo->_pMarkup == _pMarkupDbg );
        _pLayoutInfo->DelMarkupPtr();
    }
    else
    {
        Assert( _pMarkup == _pMarkupDbg);
        _pDoc = _pMarkup->Doc();
    }

    WHEN_DBG( _pMarkupDbg = NULL );
    _fHasMarkupPtr = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetDocPtr
//
//  Synopsis:   Get the CDoc pointer
//
//----------------------------------------------------------------------------
CDoc *
CElement::GetDocPtr() const
{
    void *  pv = __pvChain;

    if (CurrentlyHasAnyLayout())
        pv = _pLayoutInfo->__pvChain;

    if (HasMarkupPtr())
        pv = ((CMarkup *)pv)->Doc();

    Assert( pv == _pDocDbg );

    return (CDoc*)pv;
}

#pragma optimize("", on)


//+------------------------------------------------------------------
//
//  Members: [get/put]_scroll[top/left] and get_scroll[height/width]
//
//  Synopsis : CElement members. _dp is in pixels.
//
//------------------------------------------------------------------

HRESULT
CElement::get_scrollHeight(long *plValue)
{
    HRESULT     hr = S_OK;

    if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout *   pLayout;

        // make sure that current is calced
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            const CUnitInfo *pUnitInfo = &g_uiDisplay;

            // If we are a scrolling parent then we do not want to get the actual size, rather
            // we want to get the size of scroll value -- that is to include any outlying
            // abspos'd elements.
            BOOL fActualSize = !IsScrollingParent() || pLayout->LayoutContext();
            *plValue = HasVerticalLayoutFlow() ? pLayout->GetContentWidth(fActualSize) : pLayout->GetContentHeight(fActualSize);

            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout->LayoutContext()) 
                                            ? pLayout->LayoutContext() 
                                            : pLayout->DefinedLayoutContext();

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());

               pUnitInfo = pdiTemp->GetUnitInfo();
            }


            *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceX(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceY(*plValue);
        }

        // we don't want to return a zero for the Height (only happens
        // when there is no content). so default to the offsetHeight
        if (!pLayout || *plValue==0)
        {
            // NOTE(SujalP): get_offsetHeight is already in physical coordinates, so no need to flip.
            // return the offsetWidth instead
            hr = THR(get_offsetHeight(plValue));
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_scrollWidth(long *plValue)
{
    HRESULT     hr = S_OK;

    if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout *   pLayout;

        // make sure that current is calced
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            const CUnitInfo *pUnitInfo = &g_uiDisplay;

            // If we are a scrolling parent then we do not want to get the actual size, rather
            // we want to get the size of scroll value -- that is to include any outlying
            // abspos'd elements.
            BOOL fActualSize = !IsScrollingParent() || pLayout->LayoutContext();
            *plValue = HasVerticalLayoutFlow() ? pLayout->GetContentHeight(fActualSize) : pLayout->GetContentWidth(fActualSize);

            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout->LayoutContext()) 
                                            ? pLayout->LayoutContext() 
                                            : pLayout->DefinedLayoutContext();

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());

               pUnitInfo = pdiTemp->GetUnitInfo();
            }

            *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceY(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceX(*plValue);
        }

        // we don't want to return a zero for teh width (only haoppens
        // when there is no content). so default to the offsetWidth
        if (!pLayout || *plValue==0)
        {
            // NOTE(SujalP): get_offsetWidth is already in physical coordinates, so no need to flip.
            // return the offsetWidth instead
            hr = THR(get_offsetWidth(plValue));
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_scrollTop(long *plValue)
{
    HRESULT     hr = S_OK;

     if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout *   pLayout;
        CDispNode * pDispNode;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if ( pLayout &&
            (pDispNode = pLayout->GetElementDispNode()) != NULL)
        {
            if (pDispNode->IsScroller())
            {
                CSize   sizeOffset;
                const   CUnitInfo *pUnitInfo = &g_uiDisplay;

                DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                *plValue = HasVerticalLayoutFlow() ? sizeOffset.cx : sizeOffset.cy;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }
                *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceX(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceY(*plValue);
            }
            else
            {
                // if this isn't a scrolling element, then the scrollTop must be 0
                // for IE4 compatability
                *plValue = 0;
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_scrollLeft(long *plValue)
{
    HRESULT     hr = S_OK;

    if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout    *pLayout;
        CDispNode  *pDispNode;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if ( pLayout &&
            (pDispNode = pLayout->GetElementDispNode()) != NULL)
        {
            if (pDispNode->IsScroller())
            {
                CSize   sizeOffset;
                const   CUnitInfo *pUnitInfo = &g_uiDisplay;

                DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

                if (!HasVerticalLayoutFlow())
                {
                    *plValue = sizeOffset.cx;
                }
                else
                {
                    CRect rcClient;
                    CSize size;
                            
                    pDispNode->GetClientRect(&rcClient, CLIENTRECT_CONTENT);
                    pLayout->GetContentSize(&size, FALSE);
                    *plValue = size.cy - rcClient.Height() - sizeOffset.cy;
                    Assert(*plValue >= 0);
                }

                CLayoutContext *pContext  = (pLayout->LayoutContext()) 
                                            ? pLayout->LayoutContext() 
                                            : pLayout->DefinedLayoutContext();

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }

                // NOTE: keep this insync wrt x,y with the test above
                *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceY(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceX(*plValue);

            }
            else
            {
                // if this isn't a scrolling element, then the scrollTop must be 0
                // for IE4 compatability
                *plValue = 0;
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::put_scrollTop(long lPixels)
{
    if(!GetFirstBranch())
    {
        RRETURN(E_FAIL);
    }
    else
    {
        CLayout *   pLayout;
        CDispNode * pDispNode;

        // make sure that the element is calc'd
        if (S_OK != EnsureRecalcNotify())
            RRETURN(E_FAIL);

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        pDispNode = pLayout
                        ? pLayout->GetElementDispNode()
                        : NULL;

        if (    pDispNode
            &&  pDispNode->IsScroller())
        {

            // the display tree uses negative numbers to indicate nochange,
            // but the OM uses negative nubers to mean scrollto the top.
            if (!HasVerticalLayoutFlow())
            {
                lPixels = g_uiDisplay.DeviceFromDocPixelsY(lPixels);
                pLayout->ScrollToY((lPixels <0) ? 0 : lPixels);
            }
            else
            {
                lPixels = g_uiDisplay.DeviceFromDocPixelsX(lPixels);
                pLayout->ScrollToX((lPixels <0) ? 0 : lPixels);
            }
        }
    }

    return S_OK;
}


HRESULT
CElement::put_scrollLeft(long lPixels)
{
    if(!GetFirstBranch())
    {
        RRETURN(E_FAIL);
    }
    else
    {
        CLayout *   pLayout;
        CDispNode * pDispNode;

        // make sure that the element is calc'd
        if (S_OK != EnsureRecalcNotify())
            RRETURN(E_FAIL);

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        pDispNode = pLayout
                        ? pLayout->GetElementDispNode()
                        : NULL;

        if (    pDispNode
            &&  pDispNode->IsScroller())
        {
            if (!HasVerticalLayoutFlow())
            {
                lPixels = g_uiDisplay.DeviceFromDocPixelsX(lPixels);
                pLayout->ScrollToX((lPixels<0) ? 0 : lPixels );
            }
            else
            {
                CRect rcClient;
                CSize size;

                lPixels = g_uiDisplay.DeviceFromDocPixelsY(lPixels);

                pDispNode->GetClientRect(&rcClient, CLIENTRECT_CONTENT);
                pLayout->GetContentSize(&size, FALSE);
                lPixels = max(0l, lPixels);
                lPixels = min(lPixels, size.cy - rcClient.Height());
                lPixels = size.cy - rcClient.Height() - lPixels;
                Assert(lPixels >= 0);
                pLayout->ScrollToY(lPixels);
            }
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------------------
//
//  Member:     createControlRange
//
//  Synopsis:   Implementation of the automation interface method.
//              This creates a default structure range (CAutoTxtSiteRange) and
//              passes it back.
//
//+-------------------------------------------------------------------------------

HRESULT
CElement::createControlRange(IDispatch ** ppDisp)
{
    HRESULT             hr = E_INVALIDARG;
    CAutoTxtSiteRange * pControlRange = NULL;

    if (! ppDisp)
        goto Cleanup;

    if (! HasFlowLayout() )
    {
        hr = S_OK;
        goto Cleanup;
    }

    pControlRange = new CAutoTxtSiteRange(this);
    if (! pControlRange)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pControlRange->QueryInterface(IID_IDispatch, (void **) ppDisp) );
    pControlRange->Release();
    if (hr)
    {
        *ppDisp = NULL;
        goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


//+-------------------------------------------------------------------------------
//
//  Member:     clearAttributes
//
//+-------------------------------------------------------------------------------

HRESULT
CElement::clearAttributes()
{
    HRESULT hr = S_OK;
    CAttrArray *pAA = *(GetAttrArray());
    CMergeAttributesUndo Undo( this );

    Undo.SetClearAttr( TRUE );
    Undo.SetWasNamed( _fIsNamed );

    if (pAA)
    {
        CAttrArray * pAttrUndo = NULL;
        BOOL fTreeSync;
        BOOL fCreateUndo = QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if( fTreeSync || fCreateUndo )
        {
            pAttrUndo = new CAttrArray();
            if( !pAttrUndo )
            {
                fTreeSync = fCreateUndo = FALSE;
            }
        }

        pAA->Clear(pAttrUndo);
        // TODO (sramani) for now call onpropchange here, even though it will be duplicated
        // again if someone calls clear immediately followed by mergeAttributes (effectively
        // to do a copy). Will revisit in RTM

/*
        // TODO(sramani) since ID is preserved by default, we will re-enable this in IE6
        // if\when optional param to nuke id is implemented.

        // If the element was named it's not anymore.
        if (_fIsNamed)
        {
            _fIsNamed = FALSE;
            // Inval all collections affected by a name change
                    DoElementNameChangeCollections();
        }
*/

        hr = THR(OnPropertyChange(DISPID_UNKNOWN, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS));
        if (hr)
            goto Cleanup;

        if( fTreeSync )
        {
            IGNORE_HR( LogAttrArray( NULL, pAttrUndo, NULL ) );
        }

        if( fCreateUndo )
        {
            Undo.SetAA( pAttrUndo );
        }
        else
        {
            delete pAttrUndo;
        }
    }

    IGNORE_HR(Undo.CreateAndSubmit());

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  member : ComputeExtraFormat
//
//  Synopsis : Uses a modified ComputeFomrats call to return requested
//              property. Only some of the properties can be returned this way.
//              if eCmpType is ComputeFormatsType_GetValue  only this element is searched
//              if eCmpType is ComputeFormatsType_GetInheritedValue this element
//                         and its ancestors are searched, till we meet a table cell
//              if eCmpType is ComputeFormatsType_GetInheritedIntoTableValue this element
//                         and its all ancestors are searched
//+---------------------------------------------------------------------------

HRESULT
CElement::ComputeExtraFormat(DISPID dispID,
                             COMPUTEFORMATSTYPE eCmpType,
                             CTreeNode * pTreeNode,
                             VARIANT *pVarReturn)
{
    BYTE            ab[sizeof(CFormatInfo)];
    CFormatInfo   * pInfo = (CFormatInfo *)ab;
    HRESULT         hr;

    Assert(pVarReturn);
    Assert(pTreeNode);
    Assert(eCmpType == ComputeFormatsType_GetValue || 
            eCmpType == ComputeFormatsType_GetInheritedValue || 
            eCmpType == ComputeFormatsType_GetInheritedIntoTableValue); 

    // Make sure that the formats are calculated
    pTreeNode->GetCharFormatIndex();
    pTreeNode->GetFancyFormatIndex();

    VariantInit(pVarReturn);

    // Set the special mode flag so that ComputeFormats does not use
    // cached info,
    pInfo->_eExtraValues = eCmpType;

    // Save the requested property dispID
    pInfo->_dispIDExtra = dispID;
    pInfo->_pvarExtraValue = pVarReturn;
    pInfo->_lRecursionDepth = 0;
    hr = THR(ComputeFormats(pInfo, pTreeNode));
    if (hr)
        goto Cleanup;

Cleanup:
    pInfo->Cleanup();

    RRETURN(hr);
}


//+-------------------------------------------------------------------------------
//
//  Memeber:    SetImeState
//
//  Synopsis:   Check imeMode to set state of IME.
//
//+-------------------------------------------------------------------------------
HRESULT
CElement::SetImeState()
{
    HRESULT hr = S_OK;

#ifndef NO_IME
    CDoc *          pDoc = Doc();
    Assert( pDoc->_pInPlace->_hwnd );
    HIMC            himc = ImmGetContext(pDoc->_pInPlace->_hwnd);
    styleImeMode    sty;
    BOOL            fSuccess;
    VARIANT         varValue;
    DWORD           dwConversion, dwSentence;
    UINT            nCodePage;
    
    if (!himc)
        goto Cleanup;

    hr = THR(ComputeExtraFormat(
        DISPID_A_IMEMODE,
        ComputeFormatsType_GetValue,
        GetUpdatedNearestLayoutNode(),
        &varValue));
    if(hr)
        goto Cleanup;
   
    sty = (((CVariant *)&varValue)->IsEmpty())
                            ? styleImeModeNotSet
                            : (styleImeMode) V_I4(&varValue);

    if( sty != styleImeModeNotSet )
    {

        nCodePage = GetKeyboardCodePage();
        
        fSuccess = ImmGetConversionStatus( himc, &dwConversion, &dwSentence );
        if( !fSuccess )
            goto Cleanup;

        switch (sty)
        {
            case styleImeModeActive:

                TraceTag((tagEdImm, "styleImeModeActive conv 0x%x, sent 0x%x", dwConversion, dwSentence));
                if (_JAPAN_CP == nCodePage)
                {
                    //
                    // We have to set open status to open and close japanese IMEs
                    // There are simply too many JPN IME conversion modes that 
                    // are very confusing and buggy. So we set open status instead. 
                    // Also, this seems to be the only way to switch on/off 
                    // direct input mode
                    //
                    fSuccess = ImmSetOpenStatus( himc, TRUE );           
                    if (!fSuccess)
                    {
                        AssertSz(FALSE, "IME Mode Active - Failed to open JPN IME");
                        goto Cleanup;
                    }
                }
                else
                {
                    dwConversion = IME_CMODE_NATIVE;  // Turn on IME
                    TraceTag((tagEdImm, "styleImeModeActive conv 0x%x, sent 0x%x", dwConversion, dwSentence));
                    
                    fSuccess = ImmSetConversionStatus(himc, dwConversion, dwSentence);
                    if( !fSuccess )
                    {
                        AssertSz(FALSE, "IME Mode Active -- Failed at set conversion status");
                        goto Cleanup;
                    }
                }
                break;

            case styleImeModeInactive:

                TraceTag((tagEdImm, "styleImeModeInactive conv 0x%x, sent 0x%x", dwConversion, dwSentence));
                //
                // TODO:
                //
                // GIME JPN cannot be set to IME_CMODE_ALPHANUMERIC
                // before it is closed. Otherwise it will have problem
                // activating. So we handle JPN specially.
                //
                // [zhenbinx]
                //
                // Japanese IME has a special mode for alphanumeric 
                // (half/full width ascii) We don't want to stay in 
                // half width ascii mode so we need to we need to set 
                // open status to off for direct input.
                //
                if (_JAPAN_CP == nCodePage)
                {
                    fSuccess = ImmSetOpenStatus( himc, FALSE );
                    
                    if (!fSuccess)
                        goto Cleanup;
                }
                else
                {
                    dwConversion = IME_CMODE_ALPHANUMERIC;   // Turn off IME 
                    
                    fSuccess = ImmSetConversionStatus(himc, dwConversion, dwSentence);
                    if (!fSuccess)
                    {
                        AssertSz(FALSE, "IME Mode InActive -- Failed at set conversion status");
                        goto Cleanup;
                    }
                
                }
                
                break;

            case styleImeModeDisabled:
                pDoc->_himcCache = ImmAssociateContext(pDoc->_pInPlace->_hwnd, NULL);

                break;

            default:
                break;
        }
    }

Cleanup:
#endif //ndef NO_IME
    RRETURN(hr);
}

//+-------------------------------------------------------------------------------
//
//  Member:     mergeAttributes
//
//+-------------------------------------------------------------------------------

HRESULT
CElement::mergeAttributes(IHTMLElement *pIHTMLElementMergeThis, VARIANT *pvarFlags)
{
    BOOL fPreserveID = (V_VT(pvarFlags) == VT_BOOL) ? V_BOOL(pvarFlags) : TRUE;
    RRETURN(SetErrorInfo(MergeAttributesInternal(pIHTMLElementMergeThis, !fPreserveID)));
}

HRESULT
CElement::mergeAttributes(IHTMLElement *pIHTMLElementMergeThis)
{
    RRETURN(SetErrorInfo(MergeAttributesInternal(pIHTMLElementMergeThis)));
}

HRESULT
CElement::MergeAttributesInternal(IHTMLElement *pIHTMLElementMergeThis, BOOL fCopyID)
{
    HRESULT hr = E_INVALIDARG;
    CElement *pSrcElement;

    if (!pIHTMLElementMergeThis)
        goto Cleanup;

    hr = THR(pIHTMLElementMergeThis->QueryInterface(CLSID_CElement, (void **)&pSrcElement));
    if (hr)
        goto Cleanup;

    hr = THR(MergeAttributes(pSrcElement, fCopyID));
    if (hr)
        goto Cleanup;

    hr = THR(OnPropertyChange(DISPID_UNKNOWN, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetBstrFromElement
//
//  Synopsis:   A helper for data binding, fetches the text of some Element.
//
//  Arguments:  [fHTML]     - does caller want HTML or plain text?
//              [pbstr]     - where to return the BSTR holding the contents
//
//  Returns:    S_OK if successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::GetBstrFromElement ( BOOL fHTML, BSTR * pbstr )
{
    HRESULT hr;

    *pbstr = NULL;

    if (fHTML)
    {
        //
        //  Go through the HTML saver
        //
        hr = GetText(pbstr, 0);
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        //  Grab the plaintext directly from the runs
        //
        CStr cstr;

        hr = GetPlainTextInScope(&cstr);
        if (hr)
            goto Cleanup;

        hr = cstr.AllocBSTR(pbstr);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   EnsureInMarkup()
//
//  Synopsis:   Creates a private markup for the element, if it is
//                  outside any markup.
//
//
//  Returns:    S_OK if successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::EnsureInMarkup()
{
    HRESULT   hr = S_OK;

    if (!IsInMarkup())
    {
        Assert( !IsPassivated() );
        if( IsPassivating() )
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        hr = THR(Doc()->CreateMarkupWithElement(NULL, this));
        if (hr)
            goto Cleanup;

        WHEN_DBG( GetMarkupPtr()->_fEnsuredMarkupDbg = TRUE );
    }

    Assert(GetMarkup());

Cleanup:
    RRETURN(hr);
}

CElement *CElement::GetFocusBlurFireTarget(long lSubDiv)
{
    HRESULT hr;
    CElement *pElemFireTarget = this;

    if (Tag() == ETAG_IMG)
    {
        CAreaElement *pArea = NULL;
        CImgElement *pImg = DYNCAST(CImgElement, this);

        pImg->EnsureMap();
        if (!pImg->GetMap())
            goto Cleanup;

        Assert(lSubDiv >= 0);
        hr = THR(pImg->GetMap()->GetAreaContaining(lSubDiv, &pArea));
        if (hr)
            goto Cleanup;

        Assert(pArea);
        pElemFireTarget = pArea;
    }

Cleanup:
    return pElemFireTarget;
}


//+----------------------------------------------------------------------------
//  Member:     GetDefaultFocussability
//
//  Synopsis:   Returns the default focussability of this element.
//
//-----------------------------------------------------------------------------
FOCUSSABILITY
CElement::GetDefaultFocussability()
{
    switch (Tag())
    {
    // FOCUSSABILITY_TABBABLE
    // These need to be in the tab order by default

    case ETAG_A:
    case ETAG_BODY:
    case ETAG_BUTTON:
    case ETAG_EMBED:
    case ETAG_FRAME:
    case ETAG_IFRAME:
    case ETAG_IMG:
    case ETAG_INPUT:
    case ETAG_ISINDEX:
    case ETAG_OBJECT:
    case ETAG_SELECT:
    case ETAG_TEXTAREA:

        return FOCUSSABILITY_TABBABLE;


    // FOCUSSABILITY_FOCUSSABLE
    // Not recommended. Better have a good reason for each tag why
    // it it is focussable but not tabbable

    //  Don't tab to applet.  This is to fix ie4 bug 41206 where the
    //  VM cannot call using IOleControlSite correctly.  If we allow
    //  tabbing into the VM, we can never ever tab out due to this.
    //  (AnandRa 8/21/97)
    case ETAG_APPLET:

    // Should be MAYBE, but for IE4 compat (IE5 #63134)
    case ETAG_CAPTION:

    // special element
    case ETAG_DEFAULT:

    // Should be MAYBE, but for IE4 compat
    case ETAG_DIV:

    // Should be MAYBE, but for IE4 compat (IE5 63626)
    case ETAG_FIELDSET:

    // special element
    case ETAG_FRAMESET:

    // Should be MAYBE, but for IE4 compat (IE5 #62701)
    case ETAG_MARQUEE:

    // special element
    case ETAG_ROOT:

    // Should be MAYBE, but for IE4 compat
    case ETAG_SPAN:

    // Should be MAYBE, but for IE4 compat
    case ETAG_TABLE:    
    case ETAG_TD:

        return FOCUSSABILITY_FOCUSSABLE;


    // Any tag that can render/have renderable content (and does not appear in the above lists)

    case ETAG_ACRONYM:
    case ETAG_ADDRESS:
    case ETAG_B:
    case ETAG_BDO:
    case ETAG_BIG:
    case ETAG_BLINK:
    case ETAG_BLOCKQUOTE:
    case ETAG_CENTER:
    case ETAG_CITE:
    case ETAG_DD:
    case ETAG_DEL:
    case ETAG_DFN:
    case ETAG_DIR:
    case ETAG_DL:
    case ETAG_DT:
    case ETAG_EM:
    case ETAG_FONT:
    case ETAG_FORM:
    case ETAG_GENERIC:
    case ETAG_GENERIC_BUILTIN:
    case ETAG_GENERIC_LITERAL:
    case ETAG_H1:
    case ETAG_H2:
    case ETAG_H3:
    case ETAG_H4:
    case ETAG_H5:
    case ETAG_H6:
    case ETAG_HR:
    case ETAG_I:
    case ETAG_INS:
    case ETAG_KBD:

    // target is always focussable, label itself is not (unless forced by tabIndex) 
    case ETAG_LABEL:
    case ETAG_LEGEND:

    case ETAG_LI:
    case ETAG_LISTING:
    case ETAG_MENU:
    case ETAG_OL:
    case ETAG_P:
    case ETAG_PLAINTEXT:
    case ETAG_PRE:
    case ETAG_Q:
    //case ETAG_RB:
    case ETAG_RT:
    case ETAG_RUBY:
    case ETAG_S:
    case ETAG_SAMP:
    case ETAG_SMALL:
    case ETAG_STRIKE:
    case ETAG_STRONG:
    case ETAG_SUB:
    case ETAG_SUP:
    case ETAG_TBODY:
    case ETAG_TC:
    case ETAG_TFOOT:
    case ETAG_TH:
    case ETAG_THEAD:
    case ETAG_TR:
    case ETAG_TT:
    case ETAG_U:
    case ETAG_UL:
    case ETAG_VAR:
    case ETAG_XMP:

        return FOCUSSABILITY_MAYBE;

    // All the others - tags that do not ever render

    // this is a subdivision, never takes focus direcxtly
    case ETAG_AREA:
    
    case ETAG_BASE:
    case ETAG_BASEFONT:
    case ETAG_BGSOUND:
    case ETAG_BR:
    case ETAG_CODE:
    case ETAG_COL:
    case ETAG_COLGROUP:
    case ETAG_COMMENT:
    case ETAG_HEAD:
    case ETAG_LINK:
    case ETAG_MAP:
    case ETAG_META:
    case ETAG_NEXTID:
    case ETAG_NOBR:
    case ETAG_NOEMBED:
    case ETAG_NOFRAMES:
    case ETAG_NOSCRIPT:

    // May change in future when we re-implement SELECT
    case ETAG_OPTION:
    case ETAG_OPTGROUP:

    case ETAG_PARAM:
    case ETAG_RAW_BEGINFRAG:
    case ETAG_RAW_BEGINSEL:
    case ETAG_RAW_CODEPAGE:
    case ETAG_RAW_COMMENT:
    case ETAG_RAW_DOCSIZE:
    case ETAG_RAW_ENDFRAG:
    case ETAG_RAW_ENDSEL:
    case ETAG_RAW_EOF:
    case ETAG_RAW_SOURCE:
    case ETAG_RAW_TEXT:
    case ETAG_RAW_TEXTFRAG:
    case ETAG_SCRIPT:
    case ETAG_STYLE:
    case ETAG_TITLE_ELEMENT:
    case ETAG_TITLE_TAG:
    case ETAG_WBR:
    case ETAG_UNKNOWN:

        return FOCUSSABILITY_NEVER;

    // Special case: If CSS1+ doctype, the HTML needs to be focusable
    //               If backcompat mode, HTML is not focusable
    case ETAG_HTML:
        return (IsInMarkup() &&  GetMarkup()->IsHtmlLayout())
                ? FOCUSSABILITY_FOCUSSABLE
                : FOCUSSABILITY_NEVER;

    default:
        AssertSz(FALSE, "Focussability undefined for this tag");
        return FOCUSSABILITY_NEVER;
    }
}


BOOL
CElement::IsFocussable(long lSubDivision)
{
    // avoid visibilty and other checks for special elements
    if (Tag() == ETAG_ROOT || Tag() == ETAG_DEFAULT)
        return TRUE;

    CDoc      *pDoc      = Doc();
    CDefaults *pDefaults = GetDefaults();
    FOCUSSABILITY       fcDefault       = GetDefaultFocussability();

    if (pDefaults && pDefaults->GetAAtabStop())
    {
        fcDefault = FOCUSSABILITY_TABBABLE;
    }
    
    if (    fcDefault <= FOCUSSABILITY_NEVER
        ||  !IsInMarkup()
        ||  !IsEnabled()
        ||  !IsVisible(TRUE)
        ||  NoUIActivate()
        ||  !(this == GetMarkup()->GetCanvasElement() || GetUpdatedParentLayoutNode())
        ||  GetFirstBranch()->SearchBranchToRootForTag(ETAG_HEAD)
        ||  IsParentFrozen()
        ||  IsFrozen()
        ||  !IsInViewTree()
       )
    {
        return FALSE;
    }

    if ( fcDefault <= FOCUSSABILITY_MAYBE && IsParentEditable() )
    {
        if ( pDoc->IsElementUIActivatable( this ) )
            return TRUE;
    }


    //
    // If the element has contentEditable set to true, we can
    // set the focus
    //
    if( fcDefault == FOCUSSABILITY_MAYBE )
    {
        htmlEditable enumEditable;

        enumEditable = GetAAcontentEditable();

        if( (enumEditable == htmlEditableInherit) && pDefaults )
            enumEditable = pDefaults->GetAAcontentEditable();
     
        if( enumEditable == htmlEditableTrue )
            return TRUE;
    }

    if (!IsVisible(FALSE))
        return FALSE ;
           
    // do not  query for focussability if tabIndex is set.
    if (GetAAtabIndex() != htmlTabIndexNotSet)
        return TRUE;

    if (fcDefault < FOCUSSABILITY_FOCUSSABLE)
        return FALSE;

    // Hack for DIV and SPAN which want focus only they have a layout
    // I don't want to send them a queryfocussable because the hack is
    // more obvious here and we will try to get rid of it in IE6
    if ((Tag() == ETAG_DIV || Tag() == ETAG_SPAN) && !GetUpdatedLayout(GUL_USEFIRSTLAYOUT))
        return FALSE;

    BOOL fNotify = FALSE;

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_A:
        case ETAG_IMG:
        case ETAG_SELECT:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        CQueryFocus qf;

        qf._lSubDivision    = lSubDivision;
        qf._fRetVal         = TRUE;

        SendNotification(NTYPE_ELEMENT_QUERYFOCUSSABLE, &qf);
        return qf._fRetVal;
    }
    else
    {
        return TRUE;
    }
}


BOOL
CElement::IsTabbable(long lSubDivision)
{
    FOCUSSABILITY       fcDefault       = GetDefaultFocussability();
    BOOL                fDesignMode     = IsEditable(/*fCheckContainerOnly*/TRUE);
    CDefaults *         pDefaults       = GetDefaults();
    htmlEditable        enumEditable    = GetAAcontentEditable();
    
    if (pDefaults && pDefaults->GetAAtabStop())
    {
        fcDefault = FOCUSSABILITY_TABBABLE;
    }


    if (IsParentFrozen())
    {
        return FALSE;
    }

    if (fDesignMode)
    {
        // design-time tabbing checks for site-selectability

        // avoid visibilty and other checks for special elements
        if (Tag() == ETAG_ROOT || Tag() == ETAG_DEFAULT)
            return FALSE;

        if (!IsInMarkup() || !IsVisible(TRUE))
            return FALSE;
    }
    else
    {
        // browse-time tabbing checks for focussability
        if (!IsFocussable(lSubDivision))
            return FALSE;
    }

    long lTabIndex = GetAAtabIndex();

    // Specifying an explicit tabIndex overrides the rest of the checks
    if (!(Tag() == ETAG_INPUT
            && DYNCAST(CInput, this)->GetType() == htmlInputRadio)
        && lTabIndex != htmlTabIndexNotSet)
    {
        return (lTabIndex >= 0);
    }

    //
    // If the element has contentEditable set to true, we can
    // tab to this element.
    //
    if( (enumEditable == htmlEditableInherit) && pDefaults )
        enumEditable = pDefaults->GetAAcontentEditable();
 
    if( enumEditable == htmlEditableTrue )
        return TRUE;

    if (    fcDefault < FOCUSSABILITY_TABBABLE
         && !(fDesignMode && GetUpdatedLayout(GUL_USEFIRSTLAYOUT) && Doc()->IsElementSiteSelectable(this))
       )
    {      
        return FALSE;
    }

    BOOL fNotify = FALSE;

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_BODY:
        case ETAG_IMG:
        case ETAG_INPUT:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        CQueryFocus qf;

        qf._lSubDivision    = lSubDivision;
        qf._fRetVal         = TRUE;
        SendNotification(NTYPE_ELEMENT_QUERYTABBABLE, &qf);
        return qf._fRetVal;
    }
    else
    {
        return TRUE;
    }
}

BOOL
CElement::IsMasterTabStop()
{
    Assert(HasSlavePtr() && Tag() != ETAG_INPUT);

    switch (Tag())
    {
    case ETAG_FRAME:
        return FALSE;
        
    case ETAG_IFRAME:
        return IsParentEditable() ; // we want Iframes that are in editable regions to be "tab stops"

    default:
        {
            Assert(TagType() == ETAG_GENERIC);
            CDefaults * pDefaults = GetDefaults();
            return (!pDefaults || pDefaults->GetAAviewMasterTab());
        }
    }
}

HRESULT
CElement::PreBecomeCurrent(long lSubDivision, CMessage * pMessage)
{
    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        CSetFocus   sf;

        sf._pMessage        = pMessage;
        sf._lSubDivision    = lSubDivision;
        sf._hr              = S_OK;
        SendNotification(NTYPE_ELEMENT_SETTINGFOCUS, &sf);
        return sf._hr;
    }
    else
    {
        return S_OK;
    }
}


HRESULT
CElement::BecomeCurrentFailed(long lSubDivision, CMessage * pMessage)
{
    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        CSetFocus   sf;

        sf._pMessage        = pMessage;
        sf._lSubDivision    = lSubDivision;
        sf._hr              = S_OK;
        SendNotification(NTYPE_ELEMENT_SETFOCUSFAILED, &sf);
        return sf._hr;
    }
    else
    {
        return S_OK;
    }
}

HRESULT
CElement::PostBecomeCurrent(CMessage * pMessage, BOOL fTakeFocus)
{
    BOOL fNotify = FALSE;

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_A:
        case ETAG_BODY:
        case ETAG_BUTTON:
        case ETAG_IMG:
        case ETAG_INPUT:
        case ETAG_SELECT:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        CSetFocus   sf;

        sf._pMessage        = pMessage;
        sf._hr              = S_OK;
        sf._fTakeFocus      = fTakeFocus;
        SendNotification(NTYPE_ELEMENT_SETFOCUS, &sf);
        return sf._hr;
    }
    else
    {
        return S_OK;
    }
}

HRESULT
CElement::GotMnemonic(CMessage * pMessage)
{
    // Send only to the listeners
    switch (Tag())
    {
    case ETAG_FRAME:
    case ETAG_IFRAME:
    case ETAG_INPUT:
    case ETAG_TEXTAREA:
        {
            CSetFocus   sf;

            sf._pMessage    = pMessage;
            sf._hr          = S_OK;
            SendNotification(NTYPE_ELEMENT_GOTMNEMONIC, &sf);
            return sf._hr;
        }
    }
    return S_OK;
}


HRESULT
CElement::LostMnemonic()
{
    // Send only to the listeners
    switch (Tag())
    {
    case ETAG_INPUT:
    case ETAG_TEXTAREA:
        {
            CSetFocus   sf;

            sf._pMessage    = NULL;
            sf._hr          = S_OK;
            SendNotification(NTYPE_ELEMENT_LOSTMNEMONIC, &sf);
            return sf._hr;
        }
    }
    return S_OK;
}

FOCUS_ITEM
CElement::GetMnemonicTarget(long lSubDivision)
{
    BOOL        fNotify = FALSE;
    FOCUS_ITEM  fi;

    fi.pElement = this;
    fi.lSubDivision = lSubDivision;
    // fi.lTabIndex is unused

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_AREA:
        case ETAG_LABEL:
        case ETAG_LEGEND:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        SendNotification(NTYPE_ELEMENT_QUERYMNEMONICTARGET, &fi);
    }
    return fi;
}

HRESULT
CElement::get_tabIndex(short * puTabIndex)
{
    short tabIndex = GetAAtabIndex();

    *puTabIndex = (tabIndex == htmlTabIndexNotSet) ? 0 : tabIndex;
    return S_OK;
}

//+----------------------------------------------------------------------------
//  Member:     DestroyLayout
//
//  Synopsis:   Destroy the current layout attached to the element. This is
//              called from CFlowLayout::DoLayout to destroy the layout lazily
//              when an element loses layoutness.
//
//-----------------------------------------------------------------------------

void
CElement::DestroyLayout( CLayoutContext * pLayoutContext )
{
    AssertSz(CurrentlyHasAnyLayout() && !ShouldHaveLayout()
             // media change causes layout destruction on elements that still need them
             // TODO LRECT 112511: does it delete child layouts?
             || Tag() == ETAG_GENERIC && !FormsStringICmp(TagName(), _T("DEVICERECT")),
             "hold on! we still ned a layout here!");
    Assert(!_fLayoutAlwaysValid);

    CLayout  *  pLayout = GetLayoutPtr();
    if ( pLayout )
    {
        pLayout->ElementContent()->_fOwnsRuns = FALSE;

        Verify(Doc()->OpenView());
        Verify(pLayout == DelLayoutPtr());
    
        pLayout->Detach();
        pLayout->Release();
    }
    else
    {
        CLayoutAry *pLA = GetLayoutAry();
        if ( pLA )
        {
            delete pLA;
        }
    }
}

BOOL
CElement::IsOverlapped()
{
    CTreeNode *pNode = GetFirstBranch();

    return pNode && !pNode->IsLastBranch();
}

//+---------------------------------------------------------------------------
//
//  Method:     SetSurfaceFlags
//
//  Synopsis:   Set/clear the surface flags
//
//----------------------------------------------------------------------------
void
CElement::SetSurfaceFlags(BOOL fSurface, BOOL f3DSurface, BOOL fDontFilter )// = FALSE 
{
    //
    // f3DSurface is illegal without fSurface
    //
    Assert(!f3DSurface || fSurface);
    fSurface |= f3DSurface;

    // Normalize the BOOLs
    fSurface = !!fSurface;
    f3DSurface = !!f3DSurface;

    if (IsConnectedToPrimaryWindow())
    {
        if ((unsigned)fSurface != _fSurface)
        {
            if (fSurface)
                Doc()->_cSurface++;
            else
                Doc()->_cSurface--;
        }
        if ((unsigned)f3DSurface != _f3DSurface)
        {
            if (f3DSurface)
                Doc()->_c3DSurface++;
            else
                Doc()->_c3DSurface--;
        }
    }

    _fSurface = (unsigned)fSurface;
    _f3DSurface = (unsigned)f3DSurface;
}

//+---------------------------------------------------------------------------
//
//  Method:   HasInlineMBP
//
//  Synopsis: The function determines whether a an inline node contributes
//            any margins/borders/padding.
//
//  Return: BOOL
//
//----------------------------------------------------------------------------
BOOL
CTreeNode::HasInlineMBP(FORMAT_CONTEXT FCPARAM)
{
    if (   GetCharFormat(FCPARAM)->MayHaveInlineMBP()
        && !_fBlockNess // We have done a getcharformat which will refresh this bit if needed
        && !ShouldHaveLayout()
        && !Element()->HasFlag(TAGDESC_TEXTLESS)
       )
    {
        const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
        BOOL fHasMBP;

        // We are checking all sides (top/bottom/left/right), so it doesn't matter if we get
        // logical or physical values. For performance we get physical.
        fHasMBP =    pFF->_bd.GetBorderStyle(SIDE_TOP) != fmBorderStyleNone
                  || pFF->_bd.GetBorderStyle(SIDE_RIGHT) != fmBorderStyleNone
                  || pFF->_bd.GetBorderStyle(SIDE_BOTTOM) != fmBorderStyleNone
                  || pFF->_bd.GetBorderStyle(SIDE_LEFT) != fmBorderStyleNone
                  || !pFF->GetMargin(SIDE_TOP).IsNull()
                  || !pFF->GetMargin(SIDE_BOTTOM).IsNull()
                  || !pFF->GetMargin(SIDE_LEFT).IsNull()
                  || !pFF->GetMargin(SIDE_RIGHT).IsNull()
                  || !pFF->GetPadding(SIDE_TOP).IsNull()
                  || !pFF->GetPadding(SIDE_BOTTOM).IsNull()
                  || !pFF->GetPadding(SIDE_LEFT).IsNull()
                  || !pFF->GetPadding(SIDE_RIGHT).IsNull();
                
        return fHasMBP;
    }
    else
        return FALSE;
}

BOOL
IsInlineBPNode(CCalcInfo *pci, CTreeNode *pNode, BOOL fTop)
{
    BOOL fHasBPParent;
    if (pNode->HasInlineMBP())
    {
        BOOL fJunk;
        CRect rc;
        pNode->GetInlineMBPContributions(pci, GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY, &rc, &fJunk, &fJunk);
        fHasBPParent = fTop ? (rc.top != 0) : (rc.bottom != 0);
    }
    else
    {
        fHasBPParent = FALSE;
    }
    return fHasBPParent;
}

BOOL IsInlineTopBPNode   (CTreeNode * pNode, void *pvData) { return IsInlineBPNode((CCalcInfo *)pvData, pNode, TRUE);  }
BOOL IsInlineBottomBPNode(CTreeNode * pNode, void *pvData) { return IsInlineBPNode((CCalcInfo *)pvData, pNode, FALSE); }

BOOL
IsTableCellNode(CTreeNode * pNode)
{
    return !!pNode->Element()->TestClassFlag(CElement::ELEMENTDESC_TABLECELL);
}

BOOL
IsWidthNode(CTreeNode * pNode)
{
    const CFancyFormat * pFF     = pNode->GetFancyFormat();
    const CCharFormat  * pCF     = pNode->GetCharFormat();
    BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    
    // If width specified, then we can stop
    return !cuvWidth.IsNullOrEnum();
}

BOOL IsDoublyNestedCell(CTreeNode *pCell)
{
    BOOL fDoublyNested = FALSE;
    Assert(pCell);
    Assert(pCell->Element()->TestClassFlag(CElement::ELEMENTDESC_TABLECELL));
    CTreeNode *pTable = pCell->GetMarkup()->SearchBranchForTagInStory(pCell, ETAG_TABLE);
    if (pTable)
    {
        fDoublyNested = !!pTable->GetMarkup()->SearchBranchForCriteriaInStory(pTable->Parent(), IsTableCellNode);
    }
    return fDoublyNested;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetParentWidth
//
//  Synopsis:   This function computes the width of a parent when we have
//              % margins or % padding.
//
//  Return:     LONG: The width to be used to %age computations. Note its
//              NOT correct to use the return value for anything other than
//              %age computations.
//
//----------------------------------------------------------------------------
LONG
CTreeNode::GetParentWidth(CCalcInfo *pci, LONG xOriginalWidth)
{
    LONG xParentWidth = xOriginalWidth;
    
    // If we have any horz percent attr, then we need to find out if this node is parented by a
    // TD. The reason is that inside TD's, its impossible to compute widths of the % padding/margins
    // since those are a percent of the size of the TD, and in min-max mode we are computing
    // the size of the TD itself. Also, since we did not do it in min-max mode, we cannot suddenly come
    // up with a size in natural pass either.
    CTreeNode *pCell = GetMarkup()->SearchBranchForCriteriaInStory(this, IsTableCellNode);
    if (pCell)
    {
        // If it is, then find out if its parent by a node which has width specified on it
        // (that node could be the table itself). If so then it benefits us to use that
        // width in the %age computations.
        CTreeNode *pWidthNode = GetMarkup()->SearchBranchForCriteriaInStory(this, IsWidthNode);

        if (pWidthNode)
        {
            const CCharFormat *pCF = pWidthNode->GetCharFormat();
            const CFancyFormat *pFF = pWidthNode->GetFancyFormat();
            BOOL fVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVertical, fWritingModeUsed);

            // If the element with width itself has %age width, then there is nothing we can do
            if (   cuvWidth.IsNullOrEnum()
                || cuvWidth.IsPercent()
               )
            {
                xParentWidth = IsDoublyNestedCell(pCell) ? 0 : pci->_sizeParent.cx;
            }
            else
            {
                LONG lFontHeight = pCF->GetHeightInTwips(Doc());
                xParentWidth = max(0l, cuvWidth.XGetPixelValue(pci, 0, lFontHeight));
            }
        }
        else
        {
            xParentWidth = IsDoublyNestedCell(pCell) ? 0 : pci->_sizeParent.cx;
        }
    }

    // WARNING: Return value should be used only when computing %age values!!
    return xParentWidth;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBPContributions
//
//  Synopsis:   This function computes the actual M/B/P values for a given
//              inline node. Note, that HasInlineMBP has to be called before
//              calling this one to ensure that the node does indeed contribute
//              M/B/P
//
//  Return:     BOOL: False if all of left/top/bottom/right are 0. This could
//              happen even if HasInlineMBP is true because of negative margins.
//
//----------------------------------------------------------------------------
BOOL
CTreeNode::GetInlineMBPContributions(CCalcInfo *pci,
                                     DWORD dwFlags,
                                     CRect *pResults,
                                     BOOL *pfHorzPercentAttr,
                                     BOOL *pfVertPercentAttr)
{
    CBorderInfo borderinfo;
    const CCharFormat  *pCF = GetCharFormat();
    const CFancyFormat *pFF = GetFancyFormat();
    LONG lFontHeight = pCF->GetHeightInTwips(Doc());
    CElement *pElement = Element();
    CRect rcEmpty(CRect::CRECT_EMPTY);
    BOOL fThisVertical = pCF->HasVerticalLayoutFlow();
    Assert(fThisVertical == IsParentVertical());
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    Assert(HasInlineMBP());
    LONG xParentWidth;

    BOOL fMargin  = (dwFlags & GIMBPC_MARGINONLY ) ? TRUE : FALSE;
    BOOL fBorder  = (dwFlags & GIMBPC_BORDERONLY ) ? TRUE : FALSE;
    BOOL fPadding = (dwFlags & GIMBPC_PADDINGONLY) ? TRUE : FALSE;

    Assert(fMargin || fBorder || fPadding);

    pResults->SetRectEmpty();

    //
    // Handle the borders first
    //
    if (fBorder)
    {
        pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(this, pci, &borderinfo, GBIH_NONE FCCOMMA LC_TO_FC(pci->GetLayoutContext()));
        if (!pElement->_fDefinitelyNoBorders)
        {
            pResults->left = borderinfo.aiWidths[SIDE_LEFT];
            pResults->right = borderinfo.aiWidths[SIDE_RIGHT];
            pResults->top = borderinfo.aiWidths[SIDE_TOP];
            pResults->bottom = borderinfo.aiWidths[SIDE_BOTTOM];
        }
    }

    if (fPadding || fMargin)
    {
        const CUnitValue & cuvPaddingTop    = pFF->GetLogicalPadding(SIDE_TOP, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvPaddingRight  = pFF->GetLogicalPadding(SIDE_RIGHT, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvPaddingBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvPaddingLeft   = pFF->GetLogicalPadding(SIDE_LEFT, fThisVertical, fWritingModeUsed);

        const CUnitValue & cuvMarginLeft   = pFF->GetLogicalMargin(SIDE_LEFT, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginRight  = pFF->GetLogicalMargin(SIDE_RIGHT, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginTop    = pFF->GetLogicalMargin(SIDE_TOP, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginBottom = pFF->GetLogicalMargin(SIDE_BOTTOM, fThisVertical, fWritingModeUsed);

        // If we have horizontal padding in percentages, flag the display
        // so it can do a full recalc pass when necessary (e.g. parent width changes)
        *pfHorzPercentAttr = (   cuvPaddingLeft.IsPercent()
                              || cuvPaddingRight.IsPercent()
                              || cuvMarginLeft.IsPercent()
                              || cuvMarginRight.IsPercent()
                             );
        *pfVertPercentAttr = (   cuvPaddingTop.IsPercent()
                              || cuvPaddingBottom.IsPercent()
                              || cuvMarginTop.IsPercent()
                              || cuvMarginBottom.IsPercent()
                             );

        xParentWidth = (*pfHorzPercentAttr) ? GetParentWidth(pci, pci->_sizeParent.cx) : pci->_sizeParent.cx;

        //
        // Handle the padding next (only positive padding allowed)
        //
        if (fPadding)
        {
            pResults->left   += max(0l, cuvPaddingLeft.XGetPixelValue(pci, cuvPaddingLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
            pResults->right  += max(0l, cuvPaddingRight.XGetPixelValue(pci, cuvPaddingRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
            pResults->top    += max(0l, cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight));
            pResults->bottom += max(0l, cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight));
        }

        //
        // Finally, handle the margin information
        //
        if (fMargin)
        {
            LONG topMargin, bottomMargin;
            pResults->left   += cuvMarginLeft.XGetPixelValue(pci, cuvMarginLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
            pResults->right  += cuvMarginRight.XGetPixelValue(pci, cuvMarginRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
            
            topMargin = cuvMarginTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            if (   topMargin
                && GetMarkup()->SearchBranchForCriteria(Parent(), IsInlineTopBPNode, (void*)pci)
               )
            {
                pResults->top  += topMargin;
            }
            bottomMargin = cuvMarginBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            if (   bottomMargin
                && GetMarkup()->SearchBranchForCriteria(Parent(), IsInlineBottomBPNode, (void*)pci)
               )
            {
                pResults->bottom += bottomMargin;
            }
        }
    }
    
    return *pResults != rcEmpty;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBPForPseudo
//
//  Synopsis:   Similar to above, except that this function is to MBP contributed
//              by the pseudo element.
//
//  Return:     BOOL
//
//----------------------------------------------------------------------------
BOOL
CTreeNode::GetInlineMBPForPseudo(CCalcInfo *pci,
                                 DWORD dwFlags,
                                 CRect *pResults,
                                 BOOL *pfHorzPercentAttr,
                                 BOOL *pfVertPercentAttr)
{
    CRect rcEmpty(CRect::CRECT_EMPTY);
    const CCharFormat  *pCF = GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    const CFancyFormat *pFF = GetFancyFormat(LC_TO_FC(pci->GetLayoutContext()));
    BOOL  fInlineBackground = FALSE;

    if (pFF->_iPEI >= 0)
    {
        CBorderInfo borderinfo;
        const CPseudoElementInfo *pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        LONG lFontHeight = pCF->GetHeightInTwips(Doc());
        BOOL fVertical = pCF->HasVerticalLayoutFlow();
        BOOL fWM = pCF->_fWritingModeUsed;
        Assert(fVertical == IsParentVertical());
        LONG xParentWidth;

        BOOL fMargin  = (dwFlags & GIMBPC_MARGINONLY ) ? TRUE : FALSE;
        BOOL fBorder  = (dwFlags & GIMBPC_BORDERONLY ) ? TRUE : FALSE;
        BOOL fPadding = (dwFlags & GIMBPC_PADDINGONLY) ? TRUE : FALSE;

        Assert(fMargin || fBorder || fPadding);

        //
        // Handle the borders first
        //
        if (fBorder && GetBorderInfoHelper(this, pci, &borderinfo, GBIH_PSEUDO FCCOMMA LC_TO_FC(pci->GetLayoutContext())))
        {
            pResults->left = borderinfo.aiWidths[SIDE_LEFT];
            pResults->right = borderinfo.aiWidths[SIDE_RIGHT];
            pResults->top = borderinfo.aiWidths[SIDE_TOP];
            pResults->bottom = borderinfo.aiWidths[SIDE_BOTTOM];
        }
        else
        {
            pResults->SetRectEmpty();
        }

        //
        // Handle the padding next (only positive padding allowed)
        //
        if (fPadding || fMargin)
        {
            const CUnitValue & cuvPaddingTop    = pPEI->GetLogicalPadding(SIDE_TOP,    fVertical, fWM, pFF);
            const CUnitValue & cuvPaddingRight  = pPEI->GetLogicalPadding(SIDE_RIGHT,  fVertical, fWM, pFF);
            const CUnitValue & cuvPaddingBottom = pPEI->GetLogicalPadding(SIDE_BOTTOM, fVertical, fWM, pFF);
            const CUnitValue & cuvPaddingLeft   = pPEI->GetLogicalPadding(SIDE_LEFT,   fVertical, fWM, pFF);

            const CUnitValue & cuvMarginLeft   = pPEI->GetLogicalMargin(SIDE_LEFT,   fVertical, fWM, pFF);
            const CUnitValue & cuvMarginRight  = pPEI->GetLogicalMargin(SIDE_RIGHT,  fVertical, fWM, pFF);
            const CUnitValue & cuvMarginTop    = pPEI->GetLogicalMargin(SIDE_TOP,    fVertical, fWM, pFF);
            const CUnitValue & cuvMarginBottom = pPEI->GetLogicalMargin(SIDE_BOTTOM, fVertical, fWM, pFF);

            // If we have horizontal padding in percentages, flag the display
            // so it can do a full recalc pass when necessary (e.g. parent width changes)
            // Also see ApplyLineIndents() where we do this for horizontal indents.
            *pfHorzPercentAttr = (   cuvPaddingLeft.IsPercent()
                                  || cuvPaddingRight.IsPercent()
                                  || cuvMarginLeft.IsPercent()
                                  || cuvMarginRight.IsPercent()
                                 );
            *pfVertPercentAttr = (   cuvPaddingTop.IsPercent()
                                  || cuvPaddingBottom.IsPercent()
                                  || cuvMarginTop.IsPercent()
                                  || cuvMarginBottom.IsPercent()
                                 );

            xParentWidth = (*pfHorzPercentAttr) ? GetParentWidth(pci, pci->_sizeParent.cx) : pci->_sizeParent.cx;

            //
            // Handle the padding next (only positive padding allowed)
            //
            if (fPadding)
            {
                pResults->left   += max(0l, cuvPaddingLeft.XGetPixelValue(pci, cuvPaddingLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->right  += max(0l, cuvPaddingRight.XGetPixelValue(pci, cuvPaddingRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->top    += max(0l, cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
                pResults->bottom += max(0l, cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
            }

            //
            // Finally, handle the margin information
            //
            if (fMargin)
            {
                pResults->left   += cuvMarginLeft.XGetPixelValue(pci, cuvMarginLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->right  += cuvMarginRight.XGetPixelValue(pci, cuvMarginRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->top    += cuvMarginTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
                pResults->bottom += cuvMarginBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            }
        }

        fInlineBackground = pFF->HasBackgrounds(TRUE);
    }
    else
    {
        *pResults = rcEmpty;
    }
    
    return (   *pResults != rcEmpty
            || fInlineBackground);
}

LONG
CTreeNode::GetRotationAngleForVertical(const CFancyFormat *pFF FCCOMMA  FORMAT_CONTEXT FCPARAM)
{
    CTreeNode *pZParent = ZParentBranch();
    LONG lAngle;
    
    if (   SameScope(Parent(), pZParent)
        || !pZParent
       )
    {
        lAngle = pFF->_fLayoutFlowChanged
                 ? (GetCharFormat(FCPARAM)->HasVerticalLayoutFlow() ? 270 : 90)
                 : 0;
    }
    else
    {
        Assert(pZParent);
        const CCharFormat *pCF = GetCharFormat(FCPARAM);
        const CCharFormat *pCFZParent = pZParent->GetCharFormat(FCPARAM);
        if (!!pCF->HasVerticalLayoutFlow() == !!pCFZParent->HasVerticalLayoutFlow())
        {
            // My Z-Parent and I have the same layout flow. Do nothing.
            lAngle = 0;
        }
        else
        {
            // It is different from my parent.
            lAngle = pCF->HasVerticalLayoutFlow() ? 270 : 90;
        }
    }
    return lAngle;
}

LONG
CTreeNode::GetLogicalUserWidth(CDocScaleInfo const * pdsi, BOOL fVerticalLayoutFlow)
{
    LONG lWidth;
    const CCharFormat  * pCF = GetCharFormat();
    const CFancyFormat * pFF = GetFancyFormat();

    const CUnitValue & cuvWidth = pFF->GetLogicalWidth(fVerticalLayoutFlow, pCF->_fWritingModeUsed);
    if (cuvWidth.IsNullOrEnum() || cuvWidth.IsPercent())
    {
        lWidth = Parent() ? Parent()->GetLogicalUserWidth(pdsi, fVerticalLayoutFlow) : 0;

        if (cuvWidth.IsPercent())
        {
            lWidth = cuvWidth.XGetPixelValue(pdsi, lWidth, GetFontHeightInTwips(&cuvWidth));
        }
    }
    else
    {
        lWidth = cuvWidth.XGetPixelValue(pdsi, 0, GetFontHeightInTwips(&cuvWidth));
    }

    return lWidth;
}

BOOL
CTreeNode::HasEllipsis()
{
    const CFancyFormat * pFF = GetFancyFormat();
    BOOL fHasEllipsis = (pFF->GetTextOverflow() == styleTextOverflowEllipsis);
    if (fHasEllipsis)
    {
        const CCharFormat * pCF = GetCharFormat();
        styleOverflow overflow = pFF->GetLogicalOverflowX(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
        fHasEllipsis =    !pFF->_fContentEditable
                       && !Element()->_fEditable
                       && (overflow == styleOverflowHidden || overflow == styleOverflowScroll || overflow == styleOverflowAuto);
    }
    return fHasEllipsis;
}


//+-----------------------------------------------------------------------------
//
//  Method: CElement::DrawToDC, IHTMLElementRender
//
//------------------------------------------------------------------------------
HRESULT 
CElement::DrawToDC(HDC hDC)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        hr = Doc()->GetView()->RenderElement(this, hDC);
    }

    RRETURN(hr);
}
//  Method: CElement::DrawToDC, IHTMLElementRender

CMarkup *
CElement::GetMarkupForBaseUrl()
{
    return GetWindowedMarkupContext();
}

CElementFactory::~CElementFactory()
{
    if (_pMarkup)
        _pMarkup->SubRelease();
}

CDocument *
CElement::Document()
{
    CMarkup * pMarkup = GetMarkup();
    if (pMarkup) {
        COmWindowProxy * pOmWindow = pMarkup->Window();
        if (pOmWindow)      
        {
            return pOmWindow->Document();
        }
    }
    return NULL;
}

CDocument *
CElement::DocumentOrPendingDocument()
{
    CDocument * pDocument = Document();
    if(!pDocument)
    {
        // No document yet, try the pendind window
        COmWindowProxy * pWin;
        pWin = IsInMarkup() ? GetMarkup()->GetWindowPending() : NULL;
        if(pWin)
            pDocument = pWin->Document();
        AssertSz(!pDocument || pDocument->GetPageTransitionInfo()->GetTransitionFromMarkup(),
                    "Page Transitions - We should need to get the Document from pending window only when called from ApplyPage Transitions");
    }

    return pDocument;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::glyphMode, public
//
//  Synopsis:   return the glyph mode:
//
//              0 - no glyphs
//              1 - glyph on start
//              2 - glyph on end
//              3 - glyph on both start and end
//
//----------------------------------------------------------------------------

HRESULT
CElement::get_glyphMode(LONG *plGlyphMode)
{
    HRESULT     hr = S_OK;
    CTreePos    *ptpBegin = NULL;
    CTreePos    *ptpEnd = NULL;
    
    //
    // Validate args
    //
    
    if (!plGlyphMode )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plGlyphMode = 0;

    if( !GetMarkup()->HasGlyphTable())
        goto Cleanup; // no glyph

    //
    // Find the TreePos where we're supposed to start looking
    //

    GetTreeExtent(&ptpBegin, &ptpEnd);

    Assert(ptpBegin && (ptpEnd || IsNoScope()));

    if (ptpBegin->ShowTreePos())
        *plGlyphMode |= htmlGlyphModeBegin;

    if (!IsNoScope() && ptpEnd->ShowTreePos())
        *plGlyphMode |= htmlGlyphModeEnd;
        
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DeferredFireEvent
//
//----------------------------------------------------------------------------

void 
CElement::DeferredFireEvent (DWORD_PTR pDesc)
{
    FireEvent ((const PROPERTYDESC_BASIC *) pDesc);
}

BOOL 
CElement::IsTablePart( )
{
    switch( _etag )
    {
        case ETAG_TD:
        case ETAG_TR:
        case ETAG_TBODY:
        case ETAG_TFOOT:
        case ETAG_TH:
        case ETAG_THEAD:
        case ETAG_CAPTION:
        case ETAG_TC:
        case ETAG_COL:
        case ETAG_COLGROUP:
        
            return TRUE;

        default:
            return FALSE;
    }
}

CMarkup *
CElement::GetWindowedMarkupContext()
{
    if (Tag() == ETAG_DEFAULT)
        return Doc()->PrimaryMarkup();

#if DBG==1
    // Compiler was puking if this assert was merged together.
    if( IsInMarkup() )
    {
        Assert( GetMarkupPtr()->GetWindowedMarkupContext() );
    }
    else
    {
        Assert( HasWindowedMarkupContextPtr() );
    }
#endif // DBG

    return IsInMarkup() ? GetMarkupPtr()->GetWindowedMarkupContext() : GetWindowedMarkupContextPtr();
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::GetCWindowPtr()
//
//--------------------------------------------------------------------------
CWindow * CElement::GetCWindowPtr()
{
    CMarkup * pMarkup = GetWindowedMarkupContext();

    Assert(pMarkup);
    
    COmWindowProxy * pWindowProxy = pMarkup->Window();

    if (pWindowProxy)
    {
        return pWindowProxy->Window();
    }
    
    return NULL;
}

BOOL
CElement::IsBodySizingForStrictCSS1NeededCore()
{
    Assert(Tag() == ETAG_BODY);
    return    GetMarkup()->IsStrictCSS1Document()
           && !GetFirstBranch()->IsScrollingParent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\element2.cxx ===
//+---------------------------------------------------------------------
//
//   File:      element2.cxx
//
//  Contents:   Element class
//
//  Classes:    CElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"    // for body's dispids
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_OMRECT_HXX_
#define X_OMRECT_HXX_
#include "omrect.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_CURSTYLE_HXX_
#define X_CURSTYLE_HXX_
#include "curstyle.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_STRING_H_
#define X_STRING_H_
#include "string.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_FRAMESET_HXX
#define X_FRAMESET_HXX
#include "frameset.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DOMCOLL_HXX_
#define X_DOMCOLL_HXX_
#include "domcoll.hxx"
#endif

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif

#ifndef X_URLCOMP_HXX_
#define X_URLCOMP_HXX_
#include "urlcomp.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

MtDefine(CElementGetBoundingRect_aryRects_pv, Locals, "CElement::GetBoundingRect aryRects::_pv")
MtDefine(CElementgetClientRects_aryRects_pv, Locals, "CElement::getClientRects aryRects::_pv")
PerfDbgTag(tagInject, "Inject", "Inject");

DeclareTag(tagOM_DontFireMouseEvents, "ObjectModel", "don't fire mouse events");

ExternTag(tagRecalcStyle);
ExternTag(tagFilterChange);

class CAnchorElement;

// Helper for firing focus/mouse enter/leave events
CTreeNode *
ParentOrMaster(CTreeNode * pNode)
{
    Assert(pNode);
    return (pNode->Tag() == ETAG_ROOT && pNode->Element()->HasMasterPtr())
                ? pNode->Element()->GetMasterPtr()->GetFirstBranch()
                : pNode->Parent();
}

BOOL
IsAncestorMaster(CElement * pElem1, CTreeNode * pNode2)
{
    if (!pNode2 || !pElem1->HasSlavePtr())
        return FALSE;
    Assert(!pNode2->IsDead());
    Assert(pNode2->Element() != pElem1);

    CElement * pElem2 = pNode2->Element();

    for(;;)
    {
        pElem2 = pElem2->GetMarkup()->Root();
        if (!pElem2->HasMasterPtr())
            return FALSE;
        pElem2 = pElem2->GetMasterPtr();
        if (pElem1 == pElem2)
            return TRUE;
        if (!pElem2->IsInMarkup())
            return FALSE;
    }  
}

//+------------------------------------------------------------------------
//
//  Member:     IElement, Get_document
//
//  Synopsis:   Returns the Idocument of this
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_document(IDispatch ** ppIDoc)
{
    HRESULT     hr = CTL_E_METHODNOTAPPLICABLE;
    CMarkup *   pMarkup;
    CDocument * pDocument;
    BOOL        fIsDocFrag = FALSE;

    if (!ppIDoc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIDoc = NULL;

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkup = GetMarkup();

    Assert(pMarkup);

    if(!pMarkup->HasDocument())
        fIsDocFrag = TRUE;

    hr = THR(pMarkup->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;
    
    // Set the node type, if Document Fragment
    if (fIsDocFrag)
        pDocument->_lnodeType = 11;

    hr = THR_NOTRACE(pDocument->QueryInterface(IID_IHTMLDocument2, (void**)ppIDoc));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     GettagName
//
//  Synopsis:   Returns the tag name of the current node.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_tagName(BSTR * pTagName)
{
    *pTagName = SysAllocString(TagName());

    RRETURN( SetErrorInfoPGet(*pTagName ? S_OK : E_OUTOFMEMORY, DISPID_CElement_tagName));
}

//+------------------------------------------------------------------------
//
//  Member:     GetscopeName
//
//  Synopsis:   Returns the scope name of the current node.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_scopeName(BSTR * pScopeName)
{
    *pScopeName = SysAllocString(NamespaceHtml());

    RRETURN( SetErrorInfoPGet(*pScopeName ? S_OK : E_OUTOFMEMORY, DISPID_CElement_scopeName));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_parentElement
//
//  Synopsis:   Exposes the parent element of this element.
//
//  Note:       This pays close attention to whether or not this interface is
//              based on a proxy element.  If so, use the parent of the proxy.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_parentElement(IHTMLElement * * ppDispParent, CTreeNode * pNode)
{
    HRESULT hr = S_OK;

    *ppDispParent = NULL;

    // Root element by defintion has no parent.
    if( Tag() == ETAG_ROOT )
        goto Cleanup;

    if (!pNode || pNode->IsDead() )
    {
        pNode = GetFirstBranch();
        // Assert that either the node is not in the tree or that if it is, it is not dead
        Assert( !pNode || !pNode->IsDead() );
    }

    // if still no node, we are not in the tree, return NULL
    if (!pNode)
        goto Cleanup;

    Assert(pNode->Element() == this);

    pNode = pNode->Parent();

    // don't hand out root node
    if (!pNode || pNode->Tag() == ETAG_ROOT)
        goto Cleanup;

    hr = THR( pNode->GetElementInterface( IID_IHTMLElement, (void **) ppDispParent ) );

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, STDPROPID_XOBJ_PARENT));
}

STDMETHODIMP
CElement::get_children(IDispatch **ppDispChildren)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;

    if ( !ppDispChildren )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDispChildren = NULL;

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkup = GetMarkupPtr();

    hr = THR(pMarkup->InitCollections());
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->CollectionCache()->CreateChildrenCollection(CMarkup::ELEMENT_COLLECTION, this, ppDispChildren, FALSE));

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CElement_children));
}

HRESULT
GetAll(CElement *pel, IDispatch **ppDispChildren)
{
    HRESULT             hr = S_OK;
    CMarkup           * pMarkup;

    if ( !ppDispChildren )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert(pel);
    *ppDispChildren = NULL;

    hr = THR(pel->EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkup = pel->GetMarkupPtr();

    hr = THR(pMarkup->InitCollections());
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->CollectionCache()->CreateChildrenCollection(CMarkup::ELEMENT_COLLECTION, pel, ppDispChildren, TRUE));

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CElement::get_all(IDispatch **ppDispChildren)
{
    HRESULT hr;
    hr = THR(GetAll(this, ppDispChildren));
    RRETURN(SetErrorInfoPGet(hr, DISPID_CElement_all));
}

HRESULT
CElement::getElementsByTagName(BSTR v, IHTMLElementCollection** ppDisp)
{
    HRESULT hr = E_INVALIDARG;
    IDispatch *pDispChildren = NULL;
    CElementCollection *pelColl = NULL;

    if (!ppDisp || !v)
        goto Cleanup;

    *ppDisp = NULL;

    if (IsInMarkup() && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET) && !StrCmpIC(_T("PARAM"), v))
    {
        hr = THR(GetMarkup()->CollectionCache()->GetDisp(
                    CMarkup::ELEMENT_COLLECTION,
                    v,
                    CacheType_Tag,
                    (IDispatch **)ppDisp,
                    FALSE)); // Case sensitivity ignored for TagName

        goto Cleanup;
    }

    hr = THR(GetAll(this, &pDispChildren));
    if (hr)
        goto Cleanup;

    Assert(pDispChildren);

    // Check for '*' which means return the 'all' collection
    if ( !StrCmpIC(_T("*"), v) )
    {
        hr = THR(pDispChildren->QueryInterface(IID_IHTMLElementCollection, (void **)ppDisp));
    }
    else
    {
        hr = THR(pDispChildren->QueryInterface(CLSID_CElementCollection, (void **)&pelColl));
        if (hr)
            goto Cleanup;

        Assert(pelColl);

        // Get a collection of the specified tags.
        hr = THR(pelColl->Tags(v, (IDispatch **)ppDisp));
    }

Cleanup:
    ReleaseInterface(pDispChildren);
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------------
//
//  Memvber : IsOverflowFrame
//
//  Synopsis : Returns TRUE if the element passed in is a frame, and is in a frameset,
//      and is beyond the number of frames that are provided for in the frameset.
//      this is here for NS compat (and ie4.0X) compat.
//      e.g. <FRAMESET rows = "50%,50%> <Frame id=f1 /> <Frame id=f2 /> <Frame id-f3 /></FS>
//      only frame f1 & f2 are passed (false return) and f3 is blockec (returns true)
//+------------------------------------------------------------------------------

BOOL
CElement::IsOverflowFrame()
{
    BOOL fRes = FALSE;

    // do we have a frame element at all?
    if (Tag() != ETAG_FRAME &&
        Tag() != ETAG_IFRAME &&
        Tag() != ETAG_FRAMESET)
        goto Cleanup;

    // To fix bug 33055(et al.), don't remember this frame if it's overflowing
    if (GetFirstBranch())
    {
        if (GetFirstBranch()->Parent())
        {
            CTreeNode *pNodeFS = GetFirstBranch()->Parent()->SearchBranchToRootForTag(ETAG_FRAMESET);

            if (pNodeFS)
            {
                CFrameSetSite *pFS = DYNCAST(CFrameSetSite, pNodeFS->Element());
                if (pFS)
                {
                    fRes = pFS->IsOverflowFrame(this);
                }
            }
        }
    }

Cleanup:
    return fRes;
}

//+-------------------------------------------------------------------
//      Member : get_style
//
//      Synopsis : for use by IDispatch Invoke to retrieve the
//      IHTMLStyle for this object's inline style.  Get it from
//      CStyle. If none currently exists, make one.
//+-------------------------------------------------------------------

HRESULT
CElement::get_style(IHTMLStyle ** ppISTYLE)

{
    HRESULT hr = S_OK;
    CStyle *pStyleInline = NULL;
    *ppISTYLE = NULL;


    //
    // styles may have expressions in them, and these are not set up until we have 
    // measured.  Like the layout OM methods, we need to ensure that we have recalc'ed
    // before returning this object (bug 88449).
    //
    if (Doc()->_aryPendingExpressionElements.Size())
    {
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;
    }

    hr = GetStyleObject(&pStyleInline);
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pStyleInline->QueryInterface(IID_IHTMLStyle, (LPVOID *)ppISTYLE));

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, STDPROPID_XOBJ_STYLE));
}



//+----------------------------------------------------
//
//  member : get_currentStyle: IHTMLElement2
//
//  synopsis : returns the IHTMLCurrentStyle interface to
//             the currentStyle Object
//
//-----------------------------------------------------

HRESULT
CElement::get_currentStyle ( IHTMLCurrentStyle ** ppICurStyle, CTreeNode * pNode )
{
    HRESULT hr = S_OK;
    CCurrentStyle * pCurStyleObj = NULL;

    if (!ppICurStyle)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppICurStyle = NULL;

    if (!pNode || pNode->IsDead() )
    {
        pNode = GetFirstBranch();
        // Assert that either the node is not in the tree or that if it is, it is not dead
        Assert( !pNode || !pNode->IsDead() );
    }

    // if still no node, we are not in the tree, return NULL
    if (!pNode)
        goto Cleanup;

    Assert(pNode->Element() ==  this);

    // Reuse a current style object if we have one
    if( pNode->HasCurrentStyle() )
    {
        pCurStyleObj = pNode->GetCurrentStyle();
        pCurStyleObj->PrivateAddRef();
    }
    else
    {
        pCurStyleObj = new CCurrentStyle();
        if (!pCurStyleObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = THR( pCurStyleObj->Init(pNode) );
        if( hr )
            goto Cleanup;

        // Add the CCurrentStyle to a lookaside on the node
        // If we run out of memory here -- no big deal, we will
        // just won't ever reuse this current style
        IGNORE_HR( pNode->SetCurrentStyle( pCurStyleObj ) );
    }

    hr = THR_NOTRACE(pCurStyleObj->PrivateQueryInterface(IID_IHTMLCurrentStyle,
        (VOID **)ppICurStyle));
    if ( hr )
    {
        pCurStyleObj->PrivateRelease();
        goto Cleanup;
    }

Cleanup:
    if( pCurStyleObj )
        pCurStyleObj->PrivateRelease();

    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------------------
//  
//  Method:     CElement::EnsureRuntimeStyle
//  
//  Synopsis:   Ensures a runtime style object on the element.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CStyle ** ppStyle - CStyle returned
//
//+----------------------------------------------------------------------------

HRESULT
CElement::EnsureRuntimeStyle( CStyle ** ppStyle )
{
    HRESULT  hr = S_OK;
    CStyle * pStyleObj = NULL;

    Assert( ppStyle );

    pStyleObj = GetRuntimeStylePtr();

    if( !pStyleObj )
    {
        pStyleObj = new CStyle(
            this, DISPID_INTERNAL_RUNTIMESTYLEAA, 0);
        if (!pStyleObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( AddPointer ( DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE,
                               (void *)pStyleObj,
                               CAttrValue::AA_Internal ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    if( hr )
    {
        delete pStyleObj;
        pStyleObj = NULL;
    }

    *ppStyle = pStyleObj;

    RRETURN( hr );
}
    
//+----------------------------------------------------
//
//  member : get_runtimeStyle: IHTMLElement
//
//  synopsis : returns the runtime Style Object
//
//-----------------------------------------------------

HRESULT
CElement::get_runtimeStyle ( IHTMLStyle ** ppIStyle )
{
    HRESULT hr = S_OK;
    CStyle * pStyleObj = NULL;

    if (!ppIStyle)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIStyle = NULL;

    GetPointerAt ( FindAAIndex ( DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE,
                             CAttrValue::AA_Internal ),
                   (void **)&pStyleObj );

    //Get existing styleObject or create a new one
    if (pStyleObj)
    {
        hr = THR_NOTRACE(pStyleObj->PrivateQueryInterface(IID_IHTMLStyle,
            (VOID **)ppIStyle));
    }
    else
    {
        pStyleObj = new CStyle(
            this, DISPID_INTERNAL_RUNTIMESTYLEAA, 0);
        if (!pStyleObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR_NOTRACE(pStyleObj->PrivateQueryInterface(IID_IHTMLStyle,
            (VOID **)ppIStyle)); // My SubRef count +1
        if ( hr )
        {
            delete pStyleObj;
            goto Cleanup;
        }

        AddPointer ( DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE,
                     (void *)pStyleObj,
                     CAttrValue::AA_Internal );

    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_sourceIndex
//
//  Synopsis:   Returns the source index (order of appearance) of this element
//              If the element is no longer in the source tree, return -1
//              as source index and hr = S_OK.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_sourceIndex ( long *pSourceIndex )
{
    HRESULT hr = S_OK;

    if (!pSourceIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pSourceIndex = GetSourceIndex();

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+------------------------------------------------------------------------
//
//  Class:      CAAScriptletIterator
//
//  Synopsis:   a helper class iterating all scriptlets in attr array which
//              need to be commited to script engines via AddScriptlet.
//              While iterating, the class also collect all the necessary
//              data from attr array.
//
//-------------------------------------------------------------------------

class CScriptletIterator
{
public:

    // methods

    void    Init(CBase * pObj, CPeerHolder * pPeerHolder);
    HRESULT Next();
    HRESULT NextStd();
    HRESULT NextPeer();
    BOOL    Done() { return fStdDone && fPeerDone; };

    //data

    CBase *                 pObject;

    LPCTSTR                 pchScriptletName;
    LPTSTR                  pchCode;

    LPTSTR                  pchData;
    ULONG                   uOffset;
    ULONG                   uLine;

    BOOL                    fStdDone;
    BOOL                    fPeerDone;

    CAttrArray *            pAA;
    BASICPROPPARAMS *       pBPP;
    const PROPERTYDESC *    pPropDesc;
    CAttrValue *            pAttrValue;
    CAttrValue *            pAV;
    AAINDEX                 aaIdx;

    CPeerHolder *           pPeerHolder;
    CPeerHolder::CEventsBag * pPeerEvents;
    int                     iPeerEvents;
};

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::Init
//
//  Synopsis:   attaches iterator to CBase object and resets it.
//
//-------------------------------------------------------------------------

void
CScriptletIterator::Init(CBase * pObj, CPeerHolder * pPH)
{
    pObject = pObj;
    pAA = * pObject->GetAttrArray();

    aaIdx = (AAINDEX) -1;

    pPeerHolder = pPH;
    pPeerEvents = NULL;
    iPeerEvents = 0;

    fStdDone  = FALSE;
    fPeerDone = FALSE;
};

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::Next
//
//  Synopsis:   finds the next scriptlet to commit via AddScriptlet and
//              collects all the necessary information for that.
//
//-------------------------------------------------------------------------

HRESULT
CScriptletIterator::Next()
{
    HRESULT     hr = S_OK;

    Assert (!fStdDone || !fPeerDone);

    if (!fStdDone)
    {
        hr = THR(NextStd());
        if (hr)
            goto Cleanup;
    }

    // when standard events are iterated completely, fStdDone is set to true in NextStd.

    if (fStdDone)
    {
        hr = THR(NextPeer());
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::NextStd
//
//  Synposis:   finds the next standard scriptlet in AA_Attribute section
//
//-------------------------------------------------------------------------

HRESULT
CScriptletIterator::NextStd()
{
    HRESULT     hr = S_OK;

    while ((pAttrValue = pAA->Find(DISPID_UNKNOWN, CAttrValue::AA_Attribute, &aaIdx)) != NULL)
    {
        //
        // find out if it is a scriptlet
        //

        pPropDesc = pAttrValue->GetPropDesc();
        if (!pPropDesc)
            continue;

        pBPP = (BASICPROPPARAMS *)(pPropDesc + 1);

        if (!(pBPP->dwPPFlags & PROPPARAM_SCRIPTLET))
            continue;

        //
        // get code
        //

        hr = THR (pObject->GetStringAt(aaIdx, (const TCHAR**)&pchCode));
        if (hr)
            goto Cleanup;

        if (!pchCode)
            continue; // this could happen, e.g., in this case: <img language = VBScript onclick>

        //
        // try to get line/offset information
        //

        hr = THR(GetLineAndOffsetInfo(pAA, pBPP->dispid, &uLine, &uOffset));
        if (S_FALSE == hr)      // if no line/offset information stored, which happens if we connected the event
        {                       // using function pointers mechanism
            hr = S_OK;
            continue;
        }
        if (hr)
            goto Cleanup;

        //
        // finalize
        //

        pchScriptletName = pPropDesc->pstrName;

        goto Cleanup; // found the next scriptlet to commit; get out now
    }

    fStdDone = TRUE;   // done iterating standard scriptlets

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::NextPeer
//
//  Synposis:   finds the next custom peer event in pPeerEvents bag
//
//-------------------------------------------------------------------------

HRESULT
CScriptletIterator::NextPeer()
{
    HRESULT     hr;
    DISPID      dispidEvent;
    DISPID      dispidExpando;

    //
    // find the next custom peer event to hook up
    //

    while (pPeerHolder)
    {
        pPeerEvents = pPeerHolder->_pEventsBag;

        while (pPeerEvents && iPeerEvents < pPeerHolder->CustomEventsCount())
        {
            pchScriptletName = pPeerHolder->CustomEventName  (iPeerEvents);
            dispidEvent      = pPeerHolder->CustomEventDispid(iPeerEvents);
            iPeerEvents++;

            hr = pObject->GetExpandoDispID((LPTSTR)pchScriptletName, &dispidExpando, 0);
            if (S_OK == hr)
            {
                //
                // check if it is connected already - as indicated by presence of
                // corresponding IDispatch attr in AA_Internal section of attr array
                //

                aaIdx = AA_IDX_UNKNOWN;
                pAV = pAA->Find(
                    dispidEvent,
                    CAttrValue::AA_Internal,
                    &aaIdx);
                if (pAV && VT_DISPATCH == pAV->GetAVType())
                {
                    continue;
                }

                //
                // try to get line/offset information (stored with dispid of expando)
                //

                hr = THR(GetLineAndOffsetInfo(pAA, dispidExpando, &uLine, &uOffset));
                // if no line/offset information stored, which happens if we connected the event
                // using function pointers mechanism, then the function returns S_FALSE and uLine = uOffset = 0
                if (FAILED(hr))
                    goto Cleanup;

                //
                // get code
                //

                aaIdx = AA_IDX_UNKNOWN;
                pAV = pAA->Find(dispidExpando, CAttrValue::AA_Expando, &aaIdx);
                if (!pAV || VT_LPWSTR != pAV->GetAVType())
                {
                    continue;
                }

                hr = pObject->GetStringAt(aaIdx, (LPCTSTR*)&pchCode);

                goto Cleanup; // found the next event
            }
        } // eo while (pPeerEvents && iPeerEvents < pPeerHolder->CustomEventsCount())

        iPeerEvents = 0;
        pPeerHolder = pPeerHolder->_pPeerHolderNext;
    } // eo for (;;)

    hr = S_OK;

    fPeerDone = true;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::AddAllScriptlets
//
//  Arguments:  pchExposedName  name exposed in type info; could be id, name,
//                              or calculated unique id. If incoming value is
//                              NULL, and there is a scriptlet here to hookup,
//                              it will be set in this function to unique id.
//
//-------------------------------------------------------------------------

HRESULT
CElement::AddAllScriptlets(TCHAR * pchExposedName)
{
    HRESULT                 hr = S_OK;
    TCHAR *                 pchScope;
    TCHAR *                 pchLanguage;
    BSTR                    bstrFuncName;
    BOOL                    fBodyOrFrameset=FALSE;
    CStr                    cstrUniqueName;
    CBase **                ppPropHost;
    CBase *                 pPropHosts[3];
    BOOL                    fSetUniqueName = FALSE;
    CAttrArray *            pAA = *GetAttrArray();
    CScriptCollection *     pScriptCollection = GetMarkup()->GetScriptCollection();
    CScriptletIterator      itr;

    switch (Tag())
    {
    case ETAG_BODY:
    case ETAG_FRAMESET:
        fBodyOrFrameset = TRUE;
        break;
    }

    if (!pScriptCollection)
        goto Cleanup;

    if (!fBodyOrFrameset &&     // (1) for body or frameset, always attempt the hookup -
                                // there may be attrs stored attr array of window
        !pAA)                   // (2) for other elements, attempt hookup only if attr array present
        goto Cleanup;

    SetEventsShouldFire();

    //
    // calculate scope
    //

    switch (Tag())
    {
    case ETAG_BODY:
    case ETAG_FRAMESET:
    case ETAG_A:
        pchScope = (TCHAR *)DEFAULT_OM_SCOPE;
        break;

    default:
        pchScope = (TCHAR *) NameOrIDOfParentForm(); // this can return NULL

        if (!pchScope)
            pchScope = (TCHAR *)DEFAULT_OM_SCOPE;

        break;
    }

    Assert (pchScope); // VBScript is paranoid about this

    //
    // get language
    //

    if (!pAA ||
        !pAA->FindString (DISPID_A_LANGUAGE, (const TCHAR **) &pchLanguage, CAttrValue::AA_Attribute))
    {
        pchLanguage = NULL;
    }

    //
    // setup prop hosts
    //
    // prop hosts are:
    //      (1) normally, only 'this' element,
    //      (2) for body or frameset, 'this' element and window

    if (fBodyOrFrameset)
    {
        Assert (3 <= ARRAY_SIZE(pPropHosts));

        pPropHosts[0] = this;
        pPropHosts[1] = GetOmWindow();
        pPropHosts[2] = NULL;
    }
    else
    {
        Assert (2 <= ARRAY_SIZE(pPropHosts));

        pPropHosts[0] = this;
        pPropHosts[1] = NULL;
    }

    //
    // for all prop hosts ...
    //

    for (
        ppPropHost = pPropHosts;
        *ppPropHost;
        ppPropHost++, pchExposedName = (TCHAR *)DEFAULT_OM_SCOPE)
    {
        if (!*((*ppPropHost)->GetAttrArray()))
            continue;

        //
        //  for each scriptlet in this prop host ...
        //

        itr.Init(
            *ppPropHost,
            (this == (*ppPropHost)) ? GetPeerHolder() : NULL);

        for (;;)
        {
            hr = THR(itr.Next());
            if (hr)
                goto Cleanup;

            if (itr.Done())
                break;

            // set pchExposedName if not yet
            if (!pchExposedName)
            {
                // pchExposedName could be empty only when we get here first time when
                // this == pPropHost; if pPropHost is OM window, then pchExposedName is set to "window".
                Assert (this == (*ppPropHost));

                // NOTE: because we are looping through attr array, we should not attempt to modify the
                // array by setting UniqueName into it within this loop
                hr = THR(GetUniqueIdentifier(&cstrUniqueName,FALSE));
                if (hr)
                    goto Cleanup;

                fSetUniqueName = TRUE;

                pchExposedName = (TCHAR*) cstrUniqueName;
            }

            //
            // add scriptlet
            //

            bstrFuncName = NULL;

            // we ignore hr so that in case of syntax error it still adds other scriptlets
            IGNORE_HR(pScriptCollection->AddScriptlet(
                pchLanguage,                    // pchLanguage
                GetMarkup(),                    // pMarkup
                NULL,                           // pchType
                itr.pchCode,                    // pchCode
                pchScope,                       // pchItemName
                pchExposedName,                 // pchSubItemName
                (LPTSTR) itr.pchScriptletName,  // pchEventName
                _T("\""),                       // pchDelimiter
                itr.uOffset,                    // ulOffset
                itr.uLine,                      // ulStartingLine
                GetMarkup(),                    // pSourceObject
                SCRIPTTEXT_ISVISIBLE | SCRIPTPROC_HOSTMANAGESSOURCE, // dwFlags
                &bstrFuncName));                // pbstrName

            FormsFreeString(bstrFuncName);

        } // eo for (;;)

        if (fSetUniqueName)
        {
            fSetUniqueName = FALSE;

            hr = THR(SetUniqueNameHelper(pchExposedName));
            if (hr)
                goto Cleanup;
        }
    } // eo for (ppPropHost)


Cleanup:

    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     Inject
//
//  Synopsis:   Stuff text or HTML is various places relative to an element
//
//-----------------------------------------------------------------------------

static BOOL
IsInTableThingy ( CTreeNode * pNode )
{
    //
    // See if we are between a table and its cells
    //
    
    for ( ; pNode ; pNode = pNode->Parent() )
    {
        switch ( pNode->Tag() )
        {
        case ETAG_TABLE :
            return TRUE;
            
        case ETAG_TH :
        case ETAG_TC :
        case ETAG_CAPTION :
        case ETAG_TD :
            return FALSE;
        }
    }

    return FALSE;
}

HRESULT
CElement::Inject (
    Where where, BOOL fIsHtml, LPTSTR pStr, long cch )
{
    HRESULT        hr = S_OK;
    CDoc *         pDoc = Doc();
    CMarkup *      pMarkup;
    BOOL           fEnsuredMarkup = FALSE;
    CMarkupPointer pointerStart ( pDoc );
    CMarkupPointer pointerFinish ( pDoc );
    CParentUndo    Undo(pDoc);
    ELEMENT_TAG    etag = Tag();
    IHTMLEditingServices * pedserv  = NULL;

    PerfDbgLog1( tagInject, this, "+Inject %ls", TagName() );

    //
    // See if one is attempting to place stuff IN a noscope element
    //

    if ((where == Inside || where == AfterBegin || where == BeforeEnd))
    {
        if (fIsHtml)
        {
            CDefaults *     pDefaults       = GetDefaults();
            VARIANT_BOOL    fSupportsHTML;

            if (    ETAG_INPUT == etag
                ||  (pDefaults && pDefaults->GetAAcanHaveHTML(&fSupportsHTML) && !fSupportsHTML)
               )
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }
        }

        if (IsNoScope())
        {
            //
            // Some elements can do inside, but in the slave tree.
            // Also, disallow HTML for those things with a slave markup.  If you
            // can't get to them with the DOM or makrup services, you should not
            // be able to with innerHTML.
            //

            Assert( Tag() != ETAG_GENERIC_NESTED_LITERAL );

            switch (Tag())
            {
            case ETAG_INPUT:

                if (HasSlavePtr() && IsContainer() && !TestClassFlag(CElement::ELEMENTDESC_OMREADONLY))
                {
                    hr = THR( GetSlavePtr()->Inject( where, fIsHtml, pStr, cch ) );

                    goto Cleanup; // done
                }
                break;
        
            case ETAG_GENERIC_LITERAL:

                {
                    CGenericElement *   pGenericElement = DYNCAST(CGenericElement, this);

                    pGenericElement->_cstrContents.Free();

                    hr = THR(pGenericElement->_cstrContents.Set(pStr));

                    goto Cleanup; // done
                }

                break;
            }

            hr = CTL_E_INVALIDPASTETARGET;
            goto Cleanup;
        }
    }

    //
    // Disallow inner/outer on the head and html elements
    //

    if ((etag == ETAG_HTML || etag == ETAG_HEAD || etag == ETAG_TITLE_ELEMENT) &&
        (where == Inside || where == Outside))
    {
        hr = CTL_E_INVALIDPASTETARGET;
        goto Cleanup;
    }

    //
    // Prevent the elimination of the client element
    //
    
    pMarkup = GetMarkup();
    
    if (pMarkup && (where == Inside || where == Outside))
    {
        CElement * pElementClient = pMarkup->GetElementClient();

        //
        // It's ok to do an inner on the client
        //

        if (pElementClient && (where != Inside || this != pElementClient))
        {
            //
            // If we can see the client above this, then the client
            // will get blown away.  Prevent this.
            //
            
            if (pMarkup->SearchBranchForScopeInStory( pElementClient->GetFirstBranch(), this ))
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }
        }
    }
    
    //
    // In IE4, an element had to be in a markup to do this operation.  Now,
    // we are looser.  In order to do validation, the element must be in a
    // markup.  Here we also remember is we placed the element in a markup
    // so that if the injection fails, we can restore it to its "original"
    // state.
    //

    if (!pMarkup)
    {
        hr = THR( EnsureInMarkup() );

        if (hr)
            goto Cleanup;
        
        fEnsuredMarkup = TRUE;
        
        pMarkup = GetMarkup();
        
        Assert( pMarkup );
    }

    //
    // Locate the pointer such that they surround the stuff which should
    // go away, and are located where the new stuff should be placed.
    //

    {
        ELEMENT_ADJACENCY adjLeft = ELEM_ADJ_BeforeEnd;
        ELEMENT_ADJACENCY adjRight = ELEM_ADJ_BeforeEnd;

        switch ( where )
        {
            case Inside :
                adjLeft = ELEM_ADJ_AfterBegin;
                adjRight = ELEM_ADJ_BeforeEnd;
                break;
                
            case Outside :
                adjLeft = ELEM_ADJ_BeforeBegin;
                adjRight = ELEM_ADJ_AfterEnd;
                break;
                
            case BeforeBegin :
                adjLeft = ELEM_ADJ_BeforeBegin;
                adjRight = ELEM_ADJ_BeforeBegin;
                break;
                
            case AfterBegin :
                adjLeft = ELEM_ADJ_AfterBegin;
                adjRight = ELEM_ADJ_AfterBegin;
                break;
                
            case BeforeEnd :
                adjLeft = ELEM_ADJ_BeforeEnd;
                adjRight = ELEM_ADJ_BeforeEnd;
                break;
                
            case AfterEnd :
                adjLeft = ELEM_ADJ_AfterEnd;
                adjRight = ELEM_ADJ_AfterEnd;
                break;
        }

        hr = THR( pointerStart.MoveAdjacentToElement( this, adjLeft ) );

        if (hr)
            goto Cleanup;

        hr = THR( pointerFinish.MoveAdjacentToElement( this, adjRight ) );

        if (hr)
            goto Cleanup;
    }

    Assert( pointerStart.IsPositioned() );
    Assert( pointerFinish.IsPositioned() );

    {
        CTreeNode * pNodeStart  = pointerStart.Branch();
        CTreeNode * pNodeFinish = pointerFinish.Branch();

        //
        // For the 5.0 version, because we don't have contextual parsing,
        // make sure tables can't be messed with.
        //

        if (fIsHtml)
        {
            //
            // See if the beginning of the inject is in a table thingy
            //
            
            if (pNodeStart && IsInTableThingy( pNodeStart ))
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }

            //
            // See if the end of the inject is different from the start.
            // If so, then also check it for being in a table thingy.
            //
            
            if (pNodeFinish && pNodeStart != pNodeFinish &&
                IsInTableThingy( pNodeStart ))
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }
        }

        //
        // Make sure we record undo information if we should.  I believe that
        // here is where we make the decision to not remembers automation
        // like manipulation, but do remember user editing scenarios.
        //
        // Here, we check the elements above the start and finish to make sure
        // they are editable (in the user sense).
        //

        if (pNodeStart && pNodeFinish &&
            pNodeStart->IsEditable(/*fCheckContainerOnly*/FALSE) &&
            pNodeFinish->IsEditable(/*fCheckContainerOnly*/FALSE))
        {
            Undo.Start( IDS_UNDOGENERICTEXT );
        }
    }

    //
    // Perform the HTML/text injection
    //

    if (fIsHtml)
    {
        HRESULT HandleHTMLInjection (
            CMarkupPointer *, CMarkupPointer *,
            const TCHAR *, long, CElement * );

        hr = THR(
            HandleHTMLInjection(
                & pointerStart, & pointerFinish, pStr, cch,
                where == Inside ? this : NULL ) );

        if (hr == S_FALSE)
        {
            hr = CTL_E_INVALIDPASTESOURCE;
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;
    }
    else
    {
        IHTMLEditor * phtmed;

        HRESULT RemoveWithBreakOnEmpty (
            CMarkupPointer * pPointerStart, CMarkupPointer * pPointerFinish );

        hr = THR( RemoveWithBreakOnEmpty( & pointerStart, & pointerFinish ) );
        
        if (hr)
            goto Cleanup;

        if (where == Inside)
        {
            HRESULT UnoverlapPartials ( CElement * );

            hr = THR( UnoverlapPartials( this ) );

            if (hr)
                goto Cleanup;
        }

        //
        // Get the editing services interface with which I can
        // insert sanitized text
        //

        phtmed = Doc()->GetHTMLEditor();

        if (!phtmed)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(
            phtmed->QueryInterface(
                IID_IHTMLEditingServices, (void **) & pedserv ) );

        if (hr)
            goto Cleanup;

        hr = THR(
             pedserv->InsertSanitizedText(
                & pointerStart, pStr, cch, TRUE ) );

        if (hr)
            goto Cleanup;

        //
        // TODO - Launder spaces here on the edges
        //
    }

Cleanup:

    //
    // If we are failing, and we had to put this element into a markup
    // at the beginning, take it out now to restore to the origianl state.
    //

    if (hr != S_OK && fEnsuredMarkup && GetMarkup())
        IGNORE_HR( THR( Doc()->RemoveElement( this ) ) );
    
    //
    //
    //

    ReleaseInterface( pedserv );

    Undo.Finish( hr );

    PerfDbgLog( tagInject, this, "-Inject" );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     InsertAdjacent
//
//  Synopsis:   Inserts the given element into the tree, positioned relative
//              to 'this' element as specified.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::InsertAdjacent ( Where where, CElement * pElementInsert )
{
    HRESULT        hr = S_OK;
    CMarkupPointer pointer( Doc() );

    Assert( IsInMarkup() );
    Assert( pElementInsert && !pElementInsert->IsInMarkup() );
    Assert( !pElementInsert->IsRoot() );
    Assert( ! IsRoot() || where == AfterBegin || where == BeforeEnd );

    //
    // Figure out where to put the element
    //

    switch ( where )
    {
    case BeforeBegin :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_BeforeBegin ) );
        break;

    case AfterEnd :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_AfterEnd ) );
        break;

    case AfterBegin :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
        break;

    case BeforeEnd :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd ) );
        break;
    }

    if (hr)
        goto Cleanup;

    hr = THR( Doc()->InsertElement( pElementInsert, & pointer, NULL ) );

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     RemoveOuter
//
//  Synopsis:   Removes 'this' element and everything which 'this' element
//              influences.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::RemoveOuter ( )
{
    HRESULT        hr;
    CMarkupPointer p1( Doc() ), p2( Doc() );

    hr = THR( p1.MoveAdjacentToElement( this, ELEM_ADJ_BeforeBegin ) );

    if (hr)
        goto Cleanup;

    hr = THR( p2.MoveAdjacentToElement( this, ELEM_ADJ_AfterEnd ) );

    if (hr)
        goto Cleanup;

    hr = THR( Doc()->Remove( & p1, & p2 ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     GetText
//
//  Synopsis:   Gets the specified text for the element.
//
//  Note: invokes saver.  Use WBF_NO_TAG_FOR_CONTEXT to determine whether
//  or not the element itself is saved.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::GetText(BSTR * pbstr, DWORD dwStmFlags)
{
    HRESULT     hr = S_OK;
    IStream * pstm = NULL;

    if(!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstr = NULL;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
    if (hr)
        goto Cleanup;

    {
        CStreamWriteBuff swb(pstm, CP_UCS_2);

        hr = THR( swb.Init() );
        if( hr )
            goto Cleanup;

        swb.SetFlags(dwStmFlags);
        swb.SetElementContext(this);

        // Save the begin tag of the context element
        hr = THR( Save(&swb, FALSE) );
        if (hr)
            goto Cleanup;

        if (IsInMarkup())
        {
            CTreeSaver ts(this, &swb);
            hr = ts.Save();
            if (hr)
                goto Cleanup;
        }

        // Save the end tag of the context element
        hr = THR( Save(&swb, TRUE) );
        if (hr)
            goto Cleanup;

        hr = swb.Terminate();
        if (hr)
            goto Cleanup;
    }

    hr = GetBStrFromStream(pstm, pbstr, TRUE);

Cleanup:
    ReleaseInterface(pstm);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     put_innerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_innerHTML ( BSTR bstrHTML )
{
    RECALC_PUT_HELPER(DISPID_CElement_innerHTML)

    HRESULT hr = S_OK;

    hr = THR( Inject( Inside, TRUE, bstrHTML, FormsStringLen( bstrHTML ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        OnPropertyChange(
            s_propdescCElementinnerHTML.b.dispid,
            s_propdescCElementinnerHTML.b.dwFlags,
            (PROPERTYDESC *)&s_propdescCElementinnerHTML) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_innerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_innerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_innerHTML ( BSTR * bstrHTML )
{
    RECALC_GET_HELPER(DISPID_CElement_innerHTML)

    HRESULT hr = THR(GetText(bstrHTML, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_innerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_innerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_innerText ( BSTR bstrText )
{
    HRESULT hr = S_OK;

    hr = THR( Inject( Inside, FALSE, bstrText, FormsStringLen( bstrText ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(OnPropertyChange ( s_propdescCElementinnerText.b.dispid,
                                s_propdescCElementinnerText.b.dwFlags,
                                (PROPERTYDESC *)&s_propdescCElementinnerText ));

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_innerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_innerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_innerText ( BSTR * pbstrText )
{
    HRESULT hr = THR(GetText(pbstrText,
        WBF_SAVE_PLAINTEXT|WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_innerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_outerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_outerHTML ( BSTR bstrHTML )
{
    HRESULT hr = S_OK;
    CElement::CLock Lock(this);


    hr = THR( Inject( Outside, TRUE, bstrHTML, FormsStringLen( bstrHTML ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        OnPropertyChange(
            s_propdescCElementouterHTML.b.dispid,
            s_propdescCElementouterHTML.b.dwFlags,
            (PROPERTYDESC *)&s_propdescCElementouterHTML ) );

    if (hr)
        goto Cleanup;
    
    if ( GetFirstBranch() )
    {
        CTreeNode * pCurrentNode = GetFirstBranch()->Parent();

        // Our accessible parent needs to know that about the change

        while(   pCurrentNode != NULL
              && !((   pCurrentNode->Element()->HasAccObjPtr() 
                    || IsSupportedElement(pCurrentNode->Element()))))
        {
            pCurrentNode = pCurrentNode->Parent();
        }
        
        if (pCurrentNode)
            pCurrentNode->Element()->FireAccessibilityEvents(DISPID_IHTMLELEMENT_INNERHTML);
    }
    
Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_outerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_outerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_outerHTML ( BSTR * pbstrHTML )
{
    HRESULT hr = THR(GetText(pbstrHTML, WBF_NO_WRAP));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_outerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_outerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_outerText ( BSTR bstrText )
{
    HRESULT hr = S_OK;
    CElement::CLock Lock(this);

    hr = THR( Inject( Outside, FALSE, bstrText, FormsStringLen( bstrText ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(OnPropertyChange ( s_propdescCElementouterText.b.dispid,
                                s_propdescCElementouterText.b.dwFlags,
                                (PROPERTYDESC *)&s_propdescCElementouterText ));

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_outerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_outerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_outerText ( BSTR * pbstrText )
{
    HRESULT hr = THR(GetText(pbstrText,
        WBF_SAVE_PLAINTEXT|WBF_NO_WRAP));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_outerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     insertAdjacentHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

static inline CElement::Where ConvertAdjacent ( htmlAdjacency where )
{
    switch ( where )
    {
    case htmlAdjacencyBeforeBegin : return CElement::BeforeBegin;
    case htmlAdjacencyAfterBegin  : return CElement::AfterBegin;
    case htmlAdjacencyBeforeEnd   : return CElement::BeforeEnd;
    case htmlAdjacencyAfterEnd    : return CElement::AfterEnd;
    default                       : Assert( 0 );
    }

    return CElement::BeforeBegin;
}

STDMETHODIMP
CElement::insertAdjacentHTML ( BSTR bstrWhere, BSTR bstrHTML )
{
    HRESULT hr = S_OK;
    htmlAdjacency where;

    hr = THR( ENUMFROMSTRING( htmlAdjacency, bstrWhere, (long *) & where ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        Inject(
            ConvertAdjacent( where ), TRUE, bstrHTML, FormsStringLen( bstrHTML ) ) );

    if (hr)
        goto Cleanup;

    if ( GetFirstBranch() )
    {
        CTreeNode * pCurrentNode = GetFirstBranch();
        
        if (where == htmlAdjacencyBeforeBegin || where == htmlAdjacencyAfterEnd)
            pCurrentNode = pCurrentNode->Parent();

        // accessible clients need to know if we've added HTML
        while(   pCurrentNode != NULL
              && !((   pCurrentNode->Element()->HasAccObjPtr() 
                    || IsSupportedElement(pCurrentNode->Element()))))
        {
            pCurrentNode = pCurrentNode->Parent();
        }
        
        if (pCurrentNode)
            pCurrentNode->Element()->FireAccessibilityEvents(DISPID_IHTMLELEMENT_INNERHTML);    
    }    

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     insertAdjacentText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::insertAdjacentText ( BSTR bstrWhere, BSTR bstrText )
{
    HRESULT hr = S_OK;
    htmlAdjacency where;

    hr = THR( ENUMFROMSTRING( htmlAdjacency, bstrWhere, (long *) & where ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        Inject(
            ConvertAdjacent( where ), FALSE, bstrText, FormsStringLen( bstrText ) ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_parentTextEdit
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_parentTextEdit ( IHTMLElement * * ppDispParent )
{
    HRESULT hr = S_OK;
    CTreeNode * pNodeContext;

    if (!ppDispParent)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDispParent = NULL;

    pNodeContext = GetFirstBranch();

    if (!pNodeContext)
        goto Cleanup;

    while ( (pNodeContext = pNodeContext->Parent()) != NULL )
    {
        VARIANT_BOOL vb;

        hr = THR( pNodeContext->Element()->get_isTextEdit ( & vb ) );

        if (hr)
            goto Cleanup;

        if (vb)
            break;
    }

    if (!pNodeContext)
        goto Cleanup;

    hr = THR( pNodeContext->Element()->QueryInterface(
        IID_IHTMLElement, (void * *) ppDispParent ) );

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_parentTextEdit ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_isTextEdit
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_isTextEdit ( VARIANT_BOOL * pvb )
{
    HRESULT hr = S_OK;

    if (!pvb)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    switch ( Tag() )
    {
    case ETAG_BODY :
    case ETAG_TEXTAREA :
#ifdef  NEVER
    case ETAG_HTMLAREA :
#endif
    case ETAG_BUTTON :
        *pvb = VB_TRUE;
        break;

    case ETAG_INPUT :
        switch (DYNCAST(CInput, this)->GetType())
        {
            case htmlInputButton:
            case htmlInputReset:
            case htmlInputSubmit:
            case htmlInputText:
            case htmlInputPassword:
            case htmlInputHidden:
            case htmlInputFile:
                *pvb = VB_TRUE;
                break;
            default :
                *pvb = VB_FALSE;
                break;
        }
        break;

    default :
        *pvb = VB_FALSE;
        break;
    }

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_isTextEdit ) );
}

// Used to help determine if a Visual Hebrew codpage is specified
static BOOL LocateCodepageMeta ( CMetaElement * pMeta )
{
    return pMeta->IsCodePageMeta();
}


CAttrArray *CElement::GetInLineStyleAttrArray ( void )
{
    CAttrArray *pAA = NULL;
        
    // Apply the in-line style attributes
    AAINDEX aaix = FindAAIndex ( DISPID_INTERNAL_INLINESTYLEAA,
            CAttrValue::AA_AttrArray );
    if ( aaix != AA_IDX_UNKNOWN )
    {
        CAttrValue *pAttrValue = (CAttrValue *)**GetAttrArray();
        pAA = pAttrValue[aaix].GetAA();
    }
    return pAA;
}

CAttrArray **CElement::CreateStyleAttrArray ( DISPID dispID )
{
    AAINDEX aaix = AA_IDX_UNKNOWN;
    if ( ( aaix = FindAAIndex ( dispID,
            CAttrValue::AA_AttrArray ) ) == AA_IDX_UNKNOWN )
    {
            CAttrArray *pAA = new CAttrArray;
            AddAttrArray ( dispID, pAA,
                CAttrValue::AA_AttrArray );
            aaix = FindAAIndex ( dispID,
                CAttrValue::AA_AttrArray );
    }
    if ( aaix == AA_IDX_UNKNOWN )
    {
        return NULL;
    }
    else
    {
        CAttrValue *pAttrValue = (CAttrValue *)**GetAttrArray();
        return (CAttrArray**)(pAttrValue[aaix].GetppAA());
    }
}

//----------------------------------------------------------------
//
//      Member:         CElement::GetStyleObject
//
//  Description Helper function to create the .style sub-object
//
//----------------------------------------------------------------
HRESULT
CElement::GetStyleObject(CStyle **ppStyle)
{
    HRESULT hr;
    CStyle *pStyle = 0;

    hr = GetPointerAt(FindAAIndex( DISPID_INTERNAL_CSTYLEPTRCACHE,CAttrValue::AA_Internal), (void **)&pStyle);

    if (!pStyle)
    {
        pStyle = new CStyle(this, DISPID_INTERNAL_INLINESTYLEAA, 0);
        if (!pStyle)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = AddPointer(DISPID_INTERNAL_CSTYLEPTRCACHE, (void *)pStyle, CAttrValue::AA_Internal);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (!hr)
    {
        *ppStyle = pStyle;
    }
    else
    {
        *ppStyle = NULL;
        delete pStyle;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::SetDim, public
//
//  Synopsis:   Sets a given property (either on the inline style or the
//              attribute directly) to a given pixel value, preserving the
//              original units of that attribute.
//
//  Arguments:  [dispID]       -- Property to set the value of
//              [fValue]       -- Value of the property
//              [uvt]          -- Units [fValue] is in. If UNIT_NULLVALUE then
//                                 [fValue] is assumed to be in whatever the
//                                 current units are for this property.
//              [lDimOf]       -- For percentage values, what the percent is of
//              [fInlineStyle] -- If TRUE, the inline style is changed,
//                                otherwise the HTML attribute is changed
//              [pfChanged]    -- Place to indicate if the value actually
//                                changed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CElement::SetDim(DISPID                    dispID,
                 float                     fValue,
                 CUnitValue::UNITVALUETYPE uvt,
                 long                      lDimOf,
                 CAttrArray **             ppAttrArray,
                 BOOL                      fInlineStyle,
                 BOOL *                    pfChanged)
{
    CUnitValue          uvValue;
    HRESULT             hr;
    long                lRawValue;

    Assert(pfChanged);
    uvValue.SetNull();

    if (!ppAttrArray)
    {
        if (fInlineStyle)
        {
            ppAttrArray = CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
        }
        else
        {
            ppAttrArray = GetAttrArray();
        }
    }

    Assert(ppAttrArray);
    
    if (*ppAttrArray)
    {
        (*ppAttrArray)->GetSimpleAt(
            (*ppAttrArray)->FindAAIndex(dispID, CAttrValue::AA_Attribute),
            (DWORD*)&uvValue );
    }

    lRawValue = uvValue.GetRawValue();

    if (uvt == CUnitValue::UNIT_NULLVALUE)
    {
        uvt = uvValue.GetUnitType();

        if (uvt == CUnitValue::UNIT_NULLVALUE)
        {
            uvt = CUnitValue::UNIT_PIXELS;
        }
    }

    if ( dispID == STDPROPID_XOBJ_HEIGHT || dispID == STDPROPID_XOBJ_TOP )
    {
        hr = THR(uvValue.YSetFloatValueKeepUnits (fValue,
                                                  uvt,
                                                  lDimOf,
                                                  GetFirstBranch()->GetFontHeightInTwips(&uvValue)));
    }
    else
    {
        hr = THR(uvValue.XSetFloatValueKeepUnits(fValue,
                                                 uvt,
                                                 lDimOf,
                                                 GetFirstBranch()->GetFontHeightInTwips(&uvValue)));
    }
    if ( hr )
        goto Cleanup;

    if ( uvValue.GetRawValue() == lRawValue ) // Has anything changed ??
        goto Cleanup;

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            VARIANT vtProp;

            vtProp.vt = VT_I4;
            vtProp.lVal = lRawValue;

            if( fTreeSync )
            {
                PROPERTYDESC  * pPropDesc;
                CBase * pBase = this;

                if( fInlineStyle )
                {
                    CStyle * pStyle;

                    IGNORE_HR( GetStyleObject( &pStyle ) );
                    pBase = pStyle;
                }

                // NOTE (JHarding): This may be slow if we don't hit the GetIDsOfNames cache
                IGNORE_HR( pBase->FindPropDescFromDispID( dispID, &pPropDesc, NULL, NULL ) );
                Assert( pPropDesc );

                if( pPropDesc )
                {
                    CUnitValue  uvOld( lRawValue );
                    TCHAR       achOld[30];
                    TCHAR       achNew[30];

                    if( SUCCEEDED( uvOld.FormatBuffer( achOld, ARRAY_SIZE(achOld), pPropDesc ) ) &&
                        SUCCEEDED( uvValue.FormatBuffer( achNew, ARRAY_SIZE(achNew), pPropDesc ) ) )
                    {
                        VARIANT     vtNew;
                        VARIANT     vtOld;

                        // Shouldn't have been able to set to what converts to an empty string
                        Assert( achNew[0] );

                        vtNew.vt = VT_LPWSTR;
                        vtNew.byref = achNew;

                        if( !achOld[0] )
                        {
                            // No old value
                            V_VT(&vtOld) = VT_NULL;
                        }
                        else
                        {
                            vtOld.vt = VT_LPWSTR;
                            vtOld.byref = achOld;
                        }

                        // Log the change
                        pBase->LogAttributeChange( dispID, &vtOld, &vtNew );
                    }
                }
            }

            if( fCreateUndo )
            {
                IGNORE_HR(CreateUndoAttrValueSimpleChange(
                    dispID, vtProp, fInlineStyle, CAttrValue::AA_StyleAttribute ) );
            }
        }
    }
#endif // NO_EDIT

    hr = THR(CAttrArray::AddSimple ( ppAttrArray, dispID, uvValue.GetRawValue(),
                                     CAttrValue::AA_StyleAttribute ));

    if (hr)
        goto Cleanup;

    *pfChanged = TRUE;

Cleanup:
    RRETURN(hr);
}

HRESULT
CElement::fireEvent(BSTR bstrEventName, VARIANT *pvarEventObject, VARIANT_BOOL *pfCancelled)
{
    HRESULT hr = S_OK;
    const PROPERTYDESC *ppropdesc;
    EVENTPARAM *pParam = NULL;
    BOOL fCreateLocal = FALSE;
    CEventObj *pSrcEventObj = NULL;
    IHTMLEventObj *pIEventObject = NULL;
    CTreeNode *pNode = GetFirstBranch();
    CElement *pelFireWith = this;
    
    if (!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!bstrEventName || !*bstrEventName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (HasMasterPtr())
        pelFireWith = GetMasterPtr();

    //TODO(sramani): what about Case sensitivity?
    Assert(pelFireWith);
    ppropdesc = pelFireWith->FindPropDescForName(bstrEventName);
    if (!ppropdesc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pvarEventObject && V_VT(pvarEventObject) == VT_DISPATCH && V_DISPATCH(pvarEventObject))
    {
        pIEventObject = (IHTMLEventObj *)V_DISPATCH(pvarEventObject);

        hr = THR(pIEventObject->QueryInterface(CLSID_CEventObj, (void **)&pSrcEventObj));
        if (hr)
            goto Cleanup;

        pSrcEventObj->GetParam(&pParam);
        if (!pParam)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        // event object passed in already pushed on stack --- we are inside an event handler, copy it locally and use.
        if (pParam->_fOnStack)
            fCreateLocal = TRUE;
    }
    else // no event obj passed in, create one implicitly on the stack and init it.
    {
        fCreateLocal = TRUE;
    }

    if (fCreateLocal)
    {
        EVENTPARAM param(Doc(), this, NULL, !pParam, TRUE, pParam);

        param.SetType(ppropdesc->pstrName + 2); // all events start with on...

        // if offsetX or offsetY or both was explicity set on a eventobj that was locked on stack
        // (i.e from inside an event handler that was invoked by passing a heap eventobj to fireEvent)
        if (pSrcEventObj && pSrcEventObj->_fReadWrite && (pParam->_fOffsetXSet || pParam->_fOffsetYSet))
        {
            // srcElement; translate clientX, clientY , screenX, screenY based on offsetX, offsetY
            param.SetNodeAndCalcCoordsFromOffset(pNode);
            param._fOffsetXSet = FALSE;
            param._fOffsetYSet = FALSE;
        }
        else
        {
            // srcElement; translate x, y , offsetX, offsetY based on clientX, clientY
            param._pNode = pNode;
            param.CalcRestOfCoordinates();
        }

        if (ppropdesc->GetDispid() == DISPID_EVPROP_ONBEFOREEDITFOCUS)
           param._pNodeTo = pNode;

        param.fCancelBubble = FALSE;
        V_VT(&param.varReturnValue) = VT_EMPTY;

        hr = FireEvent((const PROPERTYDESC_BASIC *)ppropdesc, FALSE);
    }
    else // explicitly created event object passed in, re-use it by locking it on stack
    {
        Assert(pIEventObject);
        Assert(pParam);

        pParam->SetType(ppropdesc->pstrName + 2); // all events start with on...
        
        // if offsetX or offsetY or both was explicity set on a heap eventobj
        if (pParam->_fOffsetXSet || pParam->_fOffsetYSet)
        {
            // srcElement; translate clientX, clientY , screenX, screenY based on offsetX, offsetY
            pParam->SetNodeAndCalcCoordsFromOffset(pNode);
            pParam->_fOffsetXSet = FALSE;
            pParam->_fOffsetYSet = FALSE;
        }
        else
        {
            // srcElement; translate x, y , offsetX, offsetY based on clientX, clientY
            pParam->_pNode = pNode;
            pParam->CalcRestOfCoordinates(); 
        }

        pParam->fCancelBubble = FALSE;
        V_VT(&pParam->varReturnValue) = VT_EMPTY;

        CEventObj::COnStackLock onStackLock(pIEventObject);

        hr = FireEvent((const PROPERTYDESC_BASIC *)ppropdesc, FALSE);
    }

    if (pfCancelled && !FAILED(hr))
    {
        if (ppropdesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_CANCELABLE)
            *pfCancelled = (hr) ? VB_TRUE : VB_FALSE;
        else
            *pfCancelled = VB_TRUE;
    
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::FireEvent, public
//
//  Synopsis:   Central event firing routine that supports any combination of bubbling
//              and cancelable events for an ELEMENT
//
//  Arguments:  [pDesc]         -- propdesc of event fired, for access to DISPIDs
//                                 and event type string and cancel\bubble flags.
//              [fPush]         -- if FALSE, caller needs to push EVENTPARAM on
//                                 stack, else this function does.
//              [pNodeContext]  -- Reqd. for bubbling events
//              [lSubDivision]  -- Reqd. for bubbling events
//
//  Returns:    HRESULT if not cancelable;
//              if cancelable, 0(S_OK) == cancel; 1(S_FALSE) == default
//
//----------------------------------------------------------------------------

HRESULT
CElement::FireEvent(
    const PROPERTYDESC_BASIC *pDesc,
    BOOL fPush,
    CTreeNode *pNodeContext,
    long lSubDivision,
    EVENTINFO * pEvtInfo, BOOL fDontFireMSAA)
{
    Assert(pDesc);

    CDoc         * pDoc = Doc();
    CPeerHolder  * pPeerHolder = NULL;
    DWORD           dwPPFlags = pDesc->b.dwPPFlags;
    BOOL            fShouldFire = TRUE;
    BOOL            fCancelable = dwPPFlags & PROPPARAM_CANCELABLE;
    BOOL            fBubble = dwPPFlags & PROPPARAM_BUBBLING;
    DISPID          dispidEvent = (DISPID)(pDesc->c);
    DISPID          dispidProp = pDesc->b.dispid;

    // Note that we are using the HRESULT itself as the return value for cancelable events.
    // So the default value of the BOOL, TRUE (1) would be == the HRESULT, S_FALSE (also 1).
    HRESULT         hr = fCancelable ? S_FALSE : S_OK; 

    Assert(dispidEvent);
    Assert(!_fExittreePending);

    // HACKHACKHACK: (jbeda) There is a known reentrancy problem with ValidateSecureUrl.
    // The last clause here (pDoc->_cInSslPrompt) works around that so we don't see this
    // assert firing all over the place.

    //
    // HACKHACK2: marka - reentrancy issue during error during document.write
    // tree is in a bad place. script error hits and we bring up a scripting dialog
    // and then fire the OnFocusOut method.
    // 

    
    Assert(!GetMarkup() || !GetMarkup()->__fDbgLockTree || pDoc->_cInSslPrompt
           || (pDoc->_fModalDialogInScript ));

    BOOL fFireNormalEvent = !fBubble && !fCancelable;
    BOOL fBubbleCancelableEvent = fBubble && fCancelable;

    if (fBubble)
    {
        if (!pNodeContext)
            pNodeContext = GetFirstBranch();

        if (!pNodeContext)
            goto Cleanup;

        //  TODO: Moved this here because this event could possibly fire on a dead node.
        //  What should really happen though is that we should fire the event before the
        //  node is deleted from the tree.

        Assert(pNodeContext && (HasCapture() || pNodeContext->Element() == this));
    }
    else
    {
        // Onloads can happen before the document is done parsing and before the message pump is hit so
        // deferred scripts may not be hooked up when onload is fired.  If the onload is being fired then
        // hook up any event handlers.
        if (fFireNormalEvent && (dispidEvent == DISPID_EVMETH_ONLOAD))
        {
            IGNORE_HR(pDoc->CommitDeferredScripts(TRUE, GetMarkup()));
        }

        // No nearest layout->assume enabled (dbau)
        fShouldFire = ShouldFireEvents();
        if( fShouldFire )
        {
            CElement *pElem = GetUpdatedNearestLayoutElement();
            fShouldFire = (!pElem || !pElem->GetAAdisabled());
        }
    }

    if (fShouldFire)
    {
        if (fFireNormalEvent)
        {
            pPeerHolder = GetPeerHolder();

            // don't fire standard events if there is a behavior attached that wants to fire them instead
            //  or if there is no event handler or connection point attached to this element, don't bother 
            //  with the the work (perffix )
            if (pPeerHolder &&
                IsStandardDispid(dispidProp) &&
                pPeerHolder->CanElementFireStandardEventMulti(dispidProp)) 
                goto Cleanup;
        }
    
        {
            CPeerHolder::CLock lock(pPeerHolder);
            BOOL fRet = DISPID_EVMETH_ONMOUSEOVER != dispidEvent; // false for onmouseover

            EVENTPARAM  param(fPush ? pDoc : NULL, this, NULL, TRUE);

            if (fPush)
            {
                Assert(pDoc->_pparam == &param);
                CTreeNode *pNC = pNodeContext;

                if (fBubbleCancelableEvent && pDoc->HasCapture() && pDoc->_pNodeLastMouseOver &&
                    (   (dispidEvent == DISPID_EVMETH_ONCLICK)
                    ||  (dispidEvent == DISPID_EVMETH_ONDBLCLICK)
                    ||  (dispidEvent == DISPID_EVMETH_ONCONTEXTMENU)))
                {
                    if (dispidEvent == DISPID_EVMETH_ONCONTEXTMENU && !pEvtInfo->_fContextMenuFromMouse)
                    {
                        pNC = pDoc->_pElemCurrent ? pDoc->_pElemCurrent->GetFirstBranch() : pNodeContext;
                    }
                    else
                    {
                        pNC = pDoc->_pNodeLastMouseOver;
                    }
                }

                // NEWTREE: GetFirstBranch is iffy here
                //          I've seen this be null on a timer event.
                param.SetNodeAndCalcCoordinates(fBubble ? pNC : GetFirstBranch());
                param.SetType(pDesc->a.pstrName + 2); // all events start with on...
            }

            if (fBubble)
            {
                if (fPush)
                {
                    param._lSubDivisionSrc = lSubDivision;
                    if (fCancelable && dispidEvent == DISPID_EVMETH_ONBEFOREEDITFOCUS)
                        param._pNodeTo = pNodeContext;
                }

                if ( pEvtInfo )
                {
                    pEvtInfo->_dispId = dispidEvent;
                    //
                    // Deleted from destructor of EventObject.
                    //            
                    pEvtInfo->_pParam = new EVENTPARAM( & param );

                    if ( pEvtInfo->_fCopyButton )
                    {
                        param._lButton = pEvtInfo->_lButton ;
                    }

                    if( pEvtInfo->_fDontFireEvent )
                        goto Cleanup;            
                }
                
                hr = THR(BubbleEventHelper(pNodeContext, lSubDivision, dispidEvent, dispidProp, FALSE, (fCancelable ? &fRet : NULL)));
                if (fCancelable)
                {
                    Assert(pDoc->_pparam);
                    if (DISPID_EVMETH_ONMOUSEOVER != dispidEvent)
                        fRet = fRet && !pDoc->_pparam->IsCancelled();
                    else
                    {
                        // for the onmouseover event, returning true by EITHER methods 
                        // (event.returnValue or return statement) cancels the default action
                        fRet = (fRet || ((V_VT(&pDoc->_pparam->varReturnValue) == VT_BOOL) &&
                                         (V_BOOL(&pDoc->_pparam->varReturnValue) == VB_TRUE)));
                    }
                }
            }
            else
            {
                if ( pEvtInfo )
                {
                    pEvtInfo->_dispId = dispidEvent;
                    //
                    // Deleted from destructor of EventObject.
                    //            
                    pEvtInfo->_pParam = new EVENTPARAM( & param );

                    if ( pEvtInfo->_fCopyButton )
                    {
                        param._lButton = pEvtInfo->_lButton ;
                    }     

                    if( pEvtInfo->_fDontFireEvent )
                        goto Cleanup;            
                    
                }
            
                if (pDoc->_pparam->_pNode)
                    pDoc->_pparam->_pNode->NodeAddRef();
                hr = THR(CBase::FireEvent(pDoc, this, NULL, dispidEvent, dispidProp, NULL, (fCancelable ? &fRet : NULL)));
                if (pDoc->_pparam->_pNode)
                    pDoc->_pparam->_pNode->NodeRelease();
            }

            if (fCancelable)
            {
                // if this function doesn't, caller should have pushed EVENTPARAM
                Assert(!fPush && pDoc->_pparam || pDoc->_pparam == &param);
                hr = fRet;
            }
        }
    }

    if (fFireNormalEvent)
    {
        //
        // since focus/blur do not bubble, and things like accessibility
        // need to have a centralized place to handle focus changes, if
        // we just fired focus or blur for someone other than the doc,
        // then fire the doc's onfocuschange/onblurchange methods, keeping
        // the event param structure intact.
        //
        // TODO (carled) the ONCHANGEFOCUS/ONCHANGEBLUR need to be removed
        //   from the document's event interface
        //

        if (!fDontFireMSAA && !hr &&
            ((dispidEvent==DISPID_EVMETH_ONFOCUS)||(dispidEvent==DISPID_EVMETH_ONBLUR)) && 
            (Tag()!=ETAG_ROOT))
        {
            // We have to check is the document has the focus, before firing this, 
            // to prevent firing of accessible focus/blur events when the document
            // does not have the focus. 
            if (pDoc->HasFocus())
            {
                hr = THR(FireAccessibilityEvents(dispidEvent));
            }
        }
    }
    else if (!fDontFireMSAA && !hr && (dispidEvent==DISPID_EVMETH_ONACTIVATE) && (Tag()!=ETAG_ROOT) && pDoc->_fPopupDoc)
    {         
        hr = THR(FireAccessibilityEvents(DISPID_EVMETH_ONFOCUS));     
    }
    
    else if (!fDontFireMSAA && SUCCEEDED(hr) && dispidEvent == DISPID_ONCONTROLSELECT)
    {
        IGNORE_HR(FireAccessibilityEvents(DISPID_ONCONTROLSELECT));
    }
    

Cleanup:
    RRETURN1(hr, S_FALSE);
}


// Helper
void
TransformToThisMarkup(CTreeNode ** ppNode, CMarkup * pMarkup, long * plSubDiv)
{
    Assert(ppNode && pMarkup && plSubDiv);

    CTreeNode * pNode = *ppNode;
    while (pNode && pNode->GetMarkup() != pMarkup)
    {
        *plSubDiv = -1; // reset subdivision if going to a different markup
        while (pNode && !pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Parent();
        }
        if (pNode)
        {
            pNode = pNode->Element()->GetMasterPtr()->GetFirstBranch();
        }
    }
    *ppNode = pNode;
}

void
CheckAndReleaseNode(CTreeNode ** ppNode)
{
    Assert(ppNode);

    if (*ppNode)
    {
        BOOL fDead = (*ppNode)->IsDead();
        (*ppNode)->NodeRelease();
        if (fDead)
        {
            *ppNode = NULL;
        }
    }
}

BOOL
AllowBubbleToMaster(DISPID dispidEvent)
{
    switch (dispidEvent)
    {
    case DISPID_EVMETH_ONBEFORECOPY:
    case DISPID_EVMETH_ONBEFORECUT:
    case DISPID_EVMETH_ONBEFOREEDITFOCUS:
    case DISPID_EVMETH_ONBEFOREPASTE:
    case DISPID_EVMETH_ONCLICK:
    case DISPID_EVMETH_ONDBLCLICK:
    case DISPID_EVMETH_ONCONTEXTMENU:
    case DISPID_EVMETH_ONCUT:
    case DISPID_EVMETH_ONCOPY:
    case DISPID_EVMETH_ONPASTE:
    case DISPID_EVMETH_ONDRAG:
    case DISPID_EVMETH_ONDRAGEND:
    case DISPID_EVMETH_ONDRAGENTER:
    case DISPID_EVMETH_ONDRAGLEAVE:
    case DISPID_EVMETH_ONDRAGOVER:
    case DISPID_EVMETH_ONDRAGSTART:
    case DISPID_EVMETH_ONDROP:
    case DISPID_EVMETH_ONHELP:
    case DISPID_EVMETH_ONKEYDOWN:
    case DISPID_EVMETH_ONKEYPRESS:
    case DISPID_EVMETH_ONKEYUP:
    case DISPID_EVMETH_ONMOUSEDOWN:
    case DISPID_EVMETH_ONMOUSEMOVE:
    case DISPID_EVMETH_ONMOUSEWHEEL:
    case DISPID_EVMETH_ONMOUSEUP:
    case DISPID_EVMETH_ONSELECTSTART:
    case DISPID_ONCONTROLSELECT:
        return TRUE;
    default:
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   BubbleEventHelper
//
//  Synopsis:   Fire the specified event. All the sites in the parent chain
//              are supposed to fire the events (if they can).  Caller has
//              responsibility for setting up any EVENTPARAM.
//
//  Arguments:  [dispidEvent]   -- dispid of the event to fire.
//              [dispidProp]    -- dispid of prop containing event func.
//              [pvb]           -- Boolean return value
//              [pbTypes]       -- Pointer to array giving the types of parms
//              [...]           -- Parameters
//
//  Returns:    S_OK if successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::BubbleEventHelper(
    CTreeNode * pNodeContext,
    long        lSubDivision,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    BOOL        fRaisedByPeer,
    BOOL      * pfRet)
{
    CPeerHolder *   pPeerHolder = GetPeerHolder();
    HRESULT         hr = S_OK;
    BOOL            fReleasepNode       = FALSE;
    BOOL            fReleasepNodeFrom   = FALSE;
    BOOL            fReleasepNodeTo     = FALSE;

    // don't fire standard events if there is a behavior attached that wants to fire them instead
    if (pPeerHolder && !fRaisedByPeer &&
        IsStandardDispid(dispidProp) &&
        pPeerHolder->CanElementFireStandardEventMulti(dispidProp))
        return S_OK;

    CPeerHolder::CLock lock(pPeerHolder);

    CDoc * pDoc = Doc();

    Assert(pNodeContext && (pNodeContext->Element() == this || HasCapture()));
    Assert(pDoc->_pparam);

    if (!pNodeContext)
        return S_OK;

    CTreeNode *     pNode = pNodeContext;
    CElement *      pElementReal;
    CElement *      pElementLayout = NULL;
    unsigned int    cInvalOld = pDoc->_cInval;
    long            cSub = 0;
    BOOL            fAllowBubbleToMaster = AllowBubbleToMaster(dispidEvent);

    // By default do not cancel events
    pDoc->_pparam->fCancelBubble = FALSE;

    //
    // If there are any subdivisions, let the subdivisions handle the
    // event.
    //

    if (OK(GetSubDivisionCount(&cSub)) && cSub)
    {
        IGNORE_HR(DoSubDivisionEvents(
                lSubDivision,
                dispidEvent,
                dispidProp,
                pfRet));
    }

    // if the srcElement is the rootsite, return the HTML element
    Assert(pDoc->_pparam->_pNode);

    if (    (pDoc->_pparam->_pNode->Element()->IsRoot())
        &&  !(fAllowBubbleToMaster && pDoc->_pparam->_pNode->Element()->HasMasterPtr())
        &&  !pDoc->HasCapture(this))
    {
        CElement * pElemHead;

        pElemHead = pDoc->_pparam->_pNode->Element()->GetMarkup()->GetHtmlElement();
        pDoc->_pparam->SetNodeAndCalcCoordinates(
                    pElemHead ? pElemHead->GetFirstBranch() : NULL);
    }

    CDoc::CLock Lock(pDoc);

    // if Bubbling cancelled by a sink. Don't bubble anymore
    while (pNode && !pDoc->_pparam->fCancelBubble)
    {
        BOOL fListenerPresent = FALSE;

        // if we're disabled 
        // then pass the event to the parent
        //
        pElementLayout = pNode->GetUpdatedNearestLayoutElement();
        if (pElementLayout && pElementLayout->GetAAdisabled() && ! pDoc->HasContainerCapture( pNode) )
        {
            pNode = pNode->GetUpdatedNearestLayoutNode()->Parent();
            continue;
        }

        pElementReal = pNode->Element();
        CBase * pBase = pElementReal;

        TransformToThisMarkup(&pDoc->_pparam->_pNodeFrom, pNode->GetMarkup(), &pDoc->_pparam->_lSubDivisionFrom);
        TransformToThisMarkup(&pDoc->_pparam->_pNodeTo, pNode->GetMarkup(), &pDoc->_pparam->_lSubDivisionTo);

        // If this is the root element in the tree, then the
        // event is to be fired by the CDoc containing the
        // rootsite, rather than the rootsite itself.
        // we do this so that the top of the bubble goes to the doc
        if (pElementReal->IsRoot())
        {
            CMarkup * pMarkup = pElementReal->GetMarkup();

            fListenerPresent = TRUE;
            if (pMarkup->HasDocument())
            {
                BOOL fBubbleToDoc = TRUE;
                if (pElementReal->HasMasterPtr())
                {
                    CElement *pElemMaster = pElementReal->GetMasterPtr();
                    if (pElemMaster->Tag() == ETAG_INPUT)
                        fBubbleToDoc = FALSE;
                }

                if (fBubbleToDoc)
                    pBase = pMarkup->Document();
            }
        }

        // this is an element in the tree. Check to see if there
        // are any possible listeners for this event. if so, continue
        // if not, don't call FireEvent and let the event continue 
        // in its bubbling.
        fListenerPresent = fListenerPresent || pElementReal->ShouldFireEvents();

        hr = THR( pNode->NodeAddRef() );
        if( hr )
            goto Cleanup;
        fReleasepNode = TRUE;

        if (pDoc->_pparam->_pNodeFrom)
        {
            hr = THR( pDoc->_pparam->_pNodeFrom->NodeAddRef() );
            if( hr )
                goto Cleanup;
            fReleasepNodeFrom = TRUE;
        }
        if (pDoc->_pparam->_pNodeTo)
        {
            hr = THR( pDoc->_pparam->_pNodeTo->NodeAddRef() );
            if( hr )
                goto Cleanup;
            fReleasepNodeTo = TRUE;
        }

        if (fListenerPresent && pBase)
        {
            IGNORE_HR(pBase->FireEvent(pDoc, this, NULL, dispidEvent, dispidProp, NULL, pfRet, TRUE));
        }

        CheckAndReleaseNode(&pDoc->_pparam->_pNodeFrom);
        CheckAndReleaseNode(&pDoc->_pparam->_pNodeTo);
        fReleasepNodeFrom = fReleasepNodeTo = FALSE;

        // If the node is no longer valid we're done.  Script in the event handler caused
        // the tree to change.
        if (!pNode->IsDead())
        {
            if (pNode->HasPrimaryTearoff())
                pNode->NodeRelease();
            fReleasepNode = FALSE;

            if (ETAG_MAP == pNode->Tag())
            {
                //
                // If we're the map, break out right now, since the associated
                // IMG has already fired its events.
                //
                break;
            }

            if (    fAllowBubbleToMaster
                &&  pElementReal->IsRoot()
                &&  pElementReal->HasMasterPtr())
            {
                CElement * pElemMaster = pElementReal->GetMasterPtr();

                if (    pElemMaster->IsInMarkup()
                    &&  pElemMaster->TagType() == ETAG_GENERIC
                   )
                {
                    pNode = pElemMaster->GetFirstBranch();
                    pDoc->_pparam->SetNodeAndCalcCoordinates(pNode, TRUE);
                }
                else
                {
                    pNode = NULL;
                }
            }
            else
            {
                pNode = pNode->Parent();
                if(!pNode)
                {
                    pNode = pElementReal->GetFirstBranch();
                    if(pNode)
                    {
                        pNode = pNode->Parent();
                    }
                }
            }
        }
        else
        {
            if (pNode->HasPrimaryTearoff())
                pNode->NodeRelease();
            fReleasepNode = FALSE;
            pNode = NULL;
        }
    }

    // if we're still bubbling, we need to go all the way up to the window also.
    // Currently the only event that does this, is onhelp so this test is here to
    // minimize the work
    if (!pDoc->_pparam->fCancelBubble &&
        IsInMarkup() &&
        GetMarkup()->HasWindow() &&
        dispidEvent == DISPID_EVMETH_ONHELP)
    {
        CBase      *pBase = GetOmWindow();

        IGNORE_HR(pBase->FireEvent(pDoc, this, NULL, dispidEvent, dispidProp, NULL, pfRet, TRUE));
    }

    // set a flag in doc, if the script caused an invalidation
    if (cInvalOld != pDoc->_cInval)
        pDoc->_fInvalInScript = TRUE;

Cleanup:
    Assert( ( !fReleasepNode && !fReleasepNodeFrom && !fReleasepNodeTo ) || hr );
    if( hr )
    {
        // These only should have been left on if there was an error.
        if( fReleasepNode )
        {
            pNode->NodeRelease();
        }
        if( fReleasepNodeFrom )
        {
            pDoc->_pparam->_pNodeFrom->NodeRelease();
        }
        if( fReleasepNodeTo )
        {
            pDoc->_pparam->_pNodeTo->NodeRelease();
        }
    }
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   DoSubDivisionEvents
//
//  Synopsis:   Fire the specified event on the given subdivision.
//
//  Arguments:  [dispidEvent]   -- dispid of the event to fire.
//              [dispidProp]    -- dispid of prop containing event func.
//              [pvb]           -- Boolean return value
//              [pbTypes]       -- Pointer to array giving the types of parms
//              [...]           -- Parameters
//
//-----------------------------------------------------------------------------

HRESULT
CElement::DoSubDivisionEvents(
    long        lSubDivision,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    BOOL      * pfRet)
{
    return S_OK;
}


BOOL AllowCancelKeydown(CMessage * pMessage)
{
    Assert(pMessage->message == WM_SYSKEYDOWN || pMessage->message == WM_KEYDOWN);

    WPARAM wParam = pMessage->wParam;
    DWORD  dwKeyState = pMessage->dwKeyState;
    int i;

    struct KEY
    { 
        WPARAM  wParam;
        DWORD   dwKeyState;
    };

    static KEY s_aryVK[] =
    {
        VK_F1,      0,
        VK_F2,      0,
        VK_F3,      0,
        VK_F4,      0,
        VK_F5,      0,
        VK_F7,      0,
        VK_F8,      0,
        VK_F9,      0,
        VK_F10,     0,
        VK_F11,     0,
        VK_F12,     0,
        VK_SHIFT,   MK_SHIFT,
        VK_F4,      MK_CONTROL,
        70,         MK_CONTROL, // ctrl-f
        79,         MK_CONTROL, // ctrl-o
        80,         MK_CONTROL, // ctrl-p
    };

    if (dwKeyState == MK_ALT && wParam != VK_LEFT && wParam != VK_RIGHT)
        return FALSE;

    for (i = 0; i < ARRAY_SIZE(s_aryVK); i++)
    {
        if (    s_aryVK[i].wParam == wParam
            &&  s_aryVK[i].dwKeyState == dwKeyState)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     FireEventOnMessage
//
//  Synopsis:   fires event corresponding to message
//
//  Arguments:  [pMessage]   -- message
//
//  Returns:    return value satisfies same rules as HandleMessage:
//              S_OK       don't do anything - event was cancelled;
//              S_FALSE    keep processing the message - event was not cancelled
//              other      error
//
//----------------------------------------------------------------------------

MtDefine(CStackAryMouseEnter_pv, Locals, "CStackAryMouseEnter::_pv")
DECLARE_CPtrAry(    CStackAryMouseEnter,
                    CElement *,
                    Mt(Mem),
                    Mt(CStackAryMouseEnter_pv))

HRESULT
CElement::FireStdEventOnMessage(CTreeNode * pNodeContext,
                                CMessage * pMessage,
                                CTreeNode * pNodeBeginBubbleWith /* = NULL */,
                                CTreeNode * pNodeEvent , /* = NULL */
                                EVENTINFO* pEvtInfo /* = NULL */ )
{
    Assert(pNodeContext && pNodeContext->Element() == this);

    if (pMessage->fEventsFired)
        return S_FALSE;

    HRESULT     hr = S_FALSE;
    HRESULT     hr2;
    POINT       ptEvent = pMessage->pt;
    CDoc *      pDoc = Doc();
    CTreeNode * pNodeThisCanFire = pNodeContext;
    CLayoutContext *pOldMsgContext;
    CTreeNode::CLock lock;

    hr2 = THR( lock.Init(pNodeThisCanFire) );
    if( hr2 )
    {
        hr = hr2;
        goto Cleanup;
    }

    // TODO (alexz) (anandra) need this done in a generic way for all events.
    // about to fire an event; if there are deferred scripts, commit them now.
    pDoc->CommitDeferredScripts(TRUE, GetMarkup()); // TRUE - early, so don't commit downloaded deferred scripts

    //
    // Keyboard events are fired only once before the message is
    // dispatched.
    //

    switch (pMessage->message)
    {
    case WM_HELP:
        hr = pNodeThisCanFire->Element()->Fire_onhelp(
                pNodeThisCanFire, pMessage ? pMessage->lSubDivision : 0) ? S_FALSE : S_OK;
        break;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        hr = pNodeThisCanFire->Element()->FireStdEvent_KeyHelper(
                                                        pNodeThisCanFire, 
                                                        pMessage, 
                                                        (int*)&pMessage->wParam,
                                                        pEvtInfo )
                                                            ? S_FALSE : S_OK;

        if (    hr == S_OK
            &&  (   (pDoc->_dwCompat & URLCOMPAT_KEYDOWN)
                 || (!(HasMarkupPtr() && GetMarkup()->IsMarkupTrusted()) 
                    && !AllowCancelKeydown(pMessage))))
        {
            hr = S_FALSE;
        }

        break;

    case WM_SYSKEYUP:
    case WM_KEYUP:
        pNodeThisCanFire->Element()->FireStdEvent_KeyHelper(
                                                    pNodeThisCanFire, 
                                                    pMessage, 
                                                    (int*)&pMessage->wParam,
                                                    pEvtInfo );
        break;

    case WM_CHAR:
        hr = pNodeThisCanFire->Element()->FireStdEvent_KeyHelper(
                    pNodeThisCanFire, 
                    pMessage, 
                    (int*)&pMessage->wParam,
                    pEvtInfo )
                        ? S_FALSE : S_OK;
        break;

    case WM_LBUTTONDBLCLK:
        pDoc->_fGotDblClk = TRUE;
        goto Cleanup;       // To not set the event fired bit.

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    {
        FireStdEvent_MouseHelper(
            pNodeContext,
            pMessage,
            VBButtonState((short)pMessage->wParam),
            VBShiftState(),
            ptEvent.x, ptEvent.y,
            pNodeContext,
            pNodeContext,
            pNodeBeginBubbleWith,
            pNodeEvent,
            pEvtInfo );
        break;
    }

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        {
            short      sParam;


            // pMessage->wParam represents the button state
            // not button transition, on up, nothing is down.
            if (pMessage->message == WM_LBUTTONUP)
                sParam = VB_LBUTTON;
            else if (pMessage->message == WM_RBUTTONUP)
                sParam = VB_RBUTTON;
            else if (pMessage->message == WM_MBUTTONUP)
                sParam = VB_MBUTTON;
            else
                sParam = 0;

            Assert( pNodeThisCanFire );
            
            pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                                pNodeThisCanFire,
                                pMessage,
                                sParam,
                                VBShiftState(),
                                ptEvent.x, ptEvent.y,
                                NULL,
                                NULL,
                                pNodeBeginBubbleWith,
                                pNodeEvent,
                                pEvtInfo );
        }
        break;

    case WM_MOUSELEAVE:   // fired for MouseOut event
        if (!HasCapture() && IsAncestorMaster(this, pDoc->_pNodeLastMouseOver))
            break;
        pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                            pNodeThisCanFire,
                            pMessage,
                            VBButtonState((short)pMessage->wParam),
                            VBShiftState(),
                            ptEvent.x,
                            ptEvent.y,
                            pNodeContext,
                            pDoc->_pNodeLastMouseOver,
                            pNodeBeginBubbleWith,
                            pNodeEvent,
                            pEvtInfo );

        // fire Mouseleave event
        if (pNodeContext == pDoc->_pNodeLastMouseOver || pEvtInfo->_fDontFireEvent)
            break;
        {
            CTreeNode *pNode;
            CElement  *pElement;

            for ( pNode = pNodeContext; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 0;
            }

            for ( pNode = pDoc->_pNodeLastMouseOver; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 1;
            }

            pOldMsgContext = pMessage->pLayoutContext;
            pMessage->pLayoutContext = GUL_USEFIRSTLAYOUT;

            for (   pNode = pNodeContext;
                    pNode && pNode->IsInMarkup();
                    pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                if (pElement->_fFirstCommonAncestor)
                    break;
                if (ETAG_ROOT == pElement->Tag())
                    continue;
                {
                    EVENTINFO evtInfo;
                    pElement->FireEventMouseEnterLeave(
                                        pNode,
                                        pMessage,
                                        VBButtonState((short)pMessage->wParam),
                                        VBShiftState(),
                                        ptEvent.x,
                                        ptEvent.y,
                                        pNodeContext,
                                        pDoc->_pNodeLastMouseOver,
                                        pNodeBeginBubbleWith,
                                        pNodeEvent,
                                        &evtInfo );
                }

                // If we reached a master starting from a slave node, fire onmouseout
                // on master
                if (pElement->HasSlavePtr() && pElement != pNodeContext->Element())
                {
                    EVENTINFO evtInfo;

                    pNode->Element()->FireStdEvent_MouseHelper(
                                        pNode,
                                        pMessage,
                                        VBButtonState((short)pMessage->wParam),
                                        VBShiftState(),
                                        ptEvent.x,
                                        ptEvent.y,
                                        pNodeContext,
                                        pDoc->_pNodeLastMouseOver,
                                        pNode,
                                        pNode,
                                        &evtInfo );
                }
            }
            pMessage->pLayoutContext = pOldMsgContext;
        }
        break;

    case WM_MOUSEOVER:    // essentially an Enter event
        if (!HasCapture() && IsAncestorMaster(this, pDoc->_pNodeLastMouseOver))
            break;
        pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                            pNodeThisCanFire,
                            pMessage,
                            VBButtonState((short)pMessage->wParam),
                            VBShiftState(),
                            ptEvent.x,
                            ptEvent.y,
                            pDoc->_pNodeLastMouseOver,
                            pNodeContext,
                            pNodeBeginBubbleWith,
                            pNodeEvent,
                            pEvtInfo );

        // fire Mouseenter event
        if (pNodeContext == pDoc->_pNodeLastMouseOver || pEvtInfo->_fDontFireEvent)
            break;
        {
            CTreeNode *pNode;
            CElement  *pElement;
            CStackAryMouseEnter aryStackMouseEnter;
            int        cMouseEnter = 0;
            int        i;

            for ( pNode = pNodeContext; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 0;
            }

            for ( pNode = pDoc->_pNodeLastMouseOver; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 1;
            }

            for ( pNode = pNodeContext; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                if (pElement->_fFirstCommonAncestor)
                    break;
                if (ETAG_ROOT == pElement->Tag())
                    continue;
                pElement->AddRef();
                aryStackMouseEnter.Append(pElement);
                cMouseEnter++;
            }

            pOldMsgContext = pMessage->pLayoutContext;
            pMessage->pLayoutContext = GUL_USEFIRSTLAYOUT;

            for (i = cMouseEnter - 1; i >= 0; i--)
            {
                EVENTINFO  evtInfo;

                pElement = aryStackMouseEnter[i];
                pNode    = pElement->GetFirstBranch();

                if (!pElement->IsInViewTree())
                {
                    pElement->Release();
                    continue;
                }

                pElement->FireEventMouseEnterLeave(
                                    pNode,
                                    pMessage,
                                    VBButtonState((short)pMessage->wParam),
                                    VBShiftState(),
                                    ptEvent.x,
                                    ptEvent.y,
                                    pDoc->_pNodeLastMouseOver,
                                    pNodeContext,
                                    pNodeBeginBubbleWith,
                                    pNodeEvent,
                                    &evtInfo);
                // If we reached a master starting from a slave node, fire onmouseover
                // on master

                if (pElement->HasSlavePtr() && pElement != pNodeContext->Element() && pElement->IsInViewTree())
                {
                    EVENTINFO  evtInfo;
    
                    pElement->FireStdEvent_MouseHelper(
                                        pNode,
                                        pMessage,
                                        VBButtonState((short)pMessage->wParam),
                                        VBShiftState(),
                                        ptEvent.x,
                                        ptEvent.y,
                                        pDoc->_pNodeLastMouseOver,
                                        pNode,
                                        pNode,
                                        pNode,
                                        &evtInfo );
                }

                pElement->Release();
            }

            pMessage->pLayoutContext = pOldMsgContext;
        }
        break;

    case WM_MOUSEWHEEL:
    case WM_MOUSEMOVE:
        // now fire the mousemove event
        hr = (pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                            pNodeThisCanFire,
                            pMessage,
                            VBButtonState((short)pMessage->wParam),
                            VBShiftState(),
                            ptEvent.x,
                            ptEvent.y,
                            pDoc->_pNodeLastMouseOver,
                            pNodeContext,
                            pNodeBeginBubbleWith,
                            pNodeEvent,
                            pEvtInfo ))
                               ? S_FALSE : S_OK;
        break;

    case WM_CONTEXTMENU:
        {
            pEvtInfo->_fContextMenuFromMouse = MAKEPOINTS(pMessage->lParam).x != -1 || MAKEPOINTS(pMessage->lParam).y != -1;

            hr = pNodeThisCanFire->Element()->FireEvent(&s_propdescCElementoncontextmenu, TRUE, NULL, -1, pEvtInfo);
        }
        break;

    default:
        goto Cleanup;  // don't set fStdEventsFired
    }

    pMessage->fEventsFired = TRUE;

Cleanup:
    RRETURN1 (hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     CElement::FireStdEvent_KeyHelper
//
//  Synopsis:   Fire a key event.
//
//  Returns:    TRUE: Take default action, FALSE: Don't take default action
//
//-----------------------------------------------------------------------------

BOOL
CElement::FireStdEvent_KeyHelper(CTreeNode * pNodeContext, 
                                    CMessage *pMessage, 
                                    int *piKeyCode,
                                    EVENTINFO* pEvtInfo /*= NULL */)
{
    BOOL            fRet = TRUE;
    CDoc *          pDoc = Doc();
    const PROPERTYDESC_BASIC* pDesc;
    
    Assert(pNodeContext && pNodeContext->Element() == this);

    if (pDoc)
    {
        EVENTPARAM          param(pDoc, this, NULL, TRUE);

        pDoc->InitEventParamForKeyEvent(
                                & param, 
                                pNodeContext, 
                                pMessage, 
                                piKeyCode,
                                & pDesc );                                

        if ( pEvtInfo )
        {
            pEvtInfo->_dispId = (DISPID)(pDesc->c);
            //
            // Deleted from destructor of EventObject.
            //
            pEvtInfo->_pParam = new EVENTPARAM( & param );

            if( pEvtInfo->_fDontFireEvent )
                goto Cleanup;
        }

        fRet = !!FireEvent(
                    pDesc,
                    FALSE,
                    pNodeContext,
                    pMessage->lSubDivision);

        *piKeyCode = (int)param._lKeyCode;
        if (pEvtInfo && pEvtInfo->_pParam)
        {
            pEvtInfo->_pParam->_lKeyCode = (int)param._lKeyCode;
        }
    }
Cleanup:
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::FireEventMouseEnterLeave
//
//  Synopsis:   Fire mouse enter and mouse leave events.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

BOOL
CElement::FireEventMouseEnterLeave(
    CTreeNode * pNodeContext,
    CMessage *  pMessage,
    short       button,
    short       shift,
    long        x,
    long        y,
    CTreeNode * pNodeFrom,                   // = NULL
    CTreeNode * pNodeTo,                     // = NULL
    CTreeNode * pNodeBeginBubbleWith,        // = NULL
    CTreeNode * pNodeEvent,                  // = NULL
    EVENTINFO * pEvtInfo)
{
    BOOL            fRet = TRUE;
    CDoc          * pDoc = Doc();
    CMarkup       * pMarkupContext;
    CTreeNode     * pNodeSrcElement = pNodeEvent ? pNodeEvent : pNodeContext;
    HRESULT         hr = S_OK;
    EVENTPARAM      param(pDoc, this, NULL, FALSE);
    POINT           pt;
    const PROPERTYDESC_BASIC *pDesc;

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!pNodeBeginBubbleWith)
        pNodeBeginBubbleWith = pNodeContext;

    if (!pDoc)
        goto Cleanup;

    pt.x = x;
    pt.y = y;

    param.SetClientOrigin(this, &pt);

    param._pLayoutContext = pMessage->pLayoutContext;

    param.SetNodeAndCalcCoordinates(pNodeSrcElement);

    if (pDoc->_pInPlace)
        ClientToScreen(pDoc->_pInPlace->_hwnd, &pt);

    param._screenX = pt.x;
    param._screenY = pt.y;

    param._sKeyState = shift;

    param._fShiftLeft   = !!(GetKeyState(VK_LSHIFT) & 0x8000);
    param._fCtrlLeft    = !!(GetKeyState(VK_LCONTROL) & 0x8000);
    param._fAltLeft     = !!(GetKeyState(VK_LMENU) & 0x8000);

    param._lButton      = button;
    param._lSubDivisionSrc  = pMessage->lSubDivision;

    param._pNodeFrom    = pNodeFrom;
    param._pNodeTo      = pNodeTo;
    pMarkupContext = pNodeContext->GetMarkup();
    TransformToThisMarkup(&param._pNodeFrom, pMarkupContext, &param._lSubDivisionFrom);
    TransformToThisMarkup(&param._pNodeTo, pMarkupContext, &param._lSubDivisionTo);

    if (pMessage->message==WM_MOUSEOVER)
    {
        pDesc = &s_propdescCElementonmouseenter;
    }
    else
    {
        Assert(pMessage->message==WM_MOUSELEAVE);
        pDesc = &s_propdescCElementonmouseleave;
    }

    param.SetType(pDesc->a.pstrName + 2 );

    if ( pEvtInfo )
    {
        pEvtInfo->_dispId = (DISPID)(pDesc->c);
        //
        // Deleted from destructor of EventObject.
        //
        pEvtInfo->_pParam = new EVENTPARAM( & param );

        if( pEvtInfo->_fDontFireEvent )
            goto Cleanup;
    }

#if DBG == 1
    if (IsTagEnabled(tagOM_DontFireMouseEvents))
        goto Cleanup;
#endif

    hr = THR(pNodeBeginBubbleWith->Element()->FireEvent(
            pDesc,
            FALSE,
            pNodeBeginBubbleWith,
            pMessage->lSubDivision));

    fRet = !!hr;

Cleanup:
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::FireStdEvent_MouseHelper
//
//  Synopsis:   Fire any mouse event.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

BOOL
CElement::FireStdEvent_MouseHelper(
    CTreeNode * pNodeContext,
    CMessage *  pMessage,
    short       button,
    short       shift,
    long        x,
    long        y,
    CTreeNode * pNodeFrom,                   /* = NULL */
    CTreeNode * pNodeTo,                     /* = NULL */
    CTreeNode * pNodeBeginBubbleWith,        /* = NULL */
    CTreeNode * pNodeEvent,                   /* = NULL */
    EVENTINFO * pEvtInfo )
{
    BOOL    fRet = TRUE;
    CDoc *  pDoc = Doc();
    CTreeNode * pNodeSrcElement = pNodeEvent ? pNodeEvent : pNodeContext;

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!pNodeBeginBubbleWith)
        pNodeBeginBubbleWith = pNodeContext;

    if (pDoc)
    {
        HRESULT         hr = S_OK;
        EVENTPARAM      param(pDoc, this, NULL, FALSE);
        POINT           pt;
        BOOL            fOverOut = FALSE;
        BOOL            fCancelable = FALSE;
        BOOL            fHasMouseOverCancelled = FALSE;
        const PROPERTYDESC_BASIC *pDesc;

        pt.x = x;
        pt.y = y;

        param.SetClientOrigin(this, &pt);

        param._htc = pMessage->htc;
        param._lBehaviorCookie = pMessage->lBehaviorCookie;
        param._lBehaviorPartID = pMessage->lBehaviorPartID;

        param._pLayoutContext = pMessage->pLayoutContext;
        
        param.SetNodeAndCalcCoordinates(pNodeSrcElement);

        if (pDoc->_pInPlace)
            ClientToScreen(pDoc->_pInPlace->_hwnd, &pt);

        param._screenX = pt.x;
        param._screenY = pt.y;

        param._sKeyState = shift;
        
        param._fShiftLeft = !!(GetKeyState(VK_LSHIFT) & 0x8000);
        param._fCtrlLeft = !!(GetKeyState(VK_LCONTROL) & 0x8000);
        param._fAltLeft = !!(GetKeyState(VK_LMENU) & 0x8000);

        param._lButton = button;
        param._lSubDivisionSrc = pMessage->lSubDivision;

        switch(pMessage->message)
        {
            // these have a different parameter lists. i.e. none,
            //  and, they initialize two more members of EVENTPARAM
        case WM_MOUSEOVER:    
            fOverOut = TRUE;
            fHasMouseOverCancelled = TRUE;
            pDesc = &s_propdescCElementonmouseover;
            param._pNodeFrom   = pNodeFrom;
            param._pNodeTo     = pNodeTo;
            break;

        case WM_MOUSELEAVE: 
            fOverOut = TRUE;
            pDesc = &s_propdescCElementonmouseout;
            param._pNodeFrom   = pNodeFrom;
            param._pNodeTo     = pNodeTo;
            break;

        case WM_MOUSEMOVE:
            fCancelable = TRUE;
            pDesc = &s_propdescCElementonmousemove;
            break;

        case WM_MOUSEWHEEL:
            fCancelable = TRUE;
            param._wheelDelta = GET_WHEEL_DELTA_WPARAM(pMessage->wParam);
            pDesc = &s_propdescCElementonmousewheel;
            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
            pDesc = &s_propdescCElementonmouseup;
            break;

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            pDesc = &s_propdescCElementonmousedown;
            break;

        default:
            Assert(0 && "Unknown mouse event!");
            goto Cleanup;
        }

        param.SetType(pDesc->a.pstrName + 2 );

        if ( pEvtInfo )
        {
            pEvtInfo->_dispId = (DISPID)(pDesc->c);
            //
            // Deleted from destructor of EventObject.
            //            
            pEvtInfo->_pParam = new EVENTPARAM( & param );

            if( pEvtInfo->_fDontFireEvent )
                goto Cleanup;            
        }

#if DBG == 1
        if (!IsTagEnabled(tagOM_DontFireMouseEvents))
        {
#endif

            hr = THR(pNodeBeginBubbleWith->Element()->FireEvent(
                    pDesc,
                    FALSE,
                    pNodeBeginBubbleWith,
                    pMessage->lSubDivision));

            // Don't propagate ret value to caller(s) for onmouseover. Action that
            // needs to be done if it is cancelled is taken here itself.
            if (fCancelable)
            {
                Assert(OK(hr));
                fRet = !!hr;
            }
#if DBG == 1
        }
#endif

        // if the return value is true, then for anchors and areas we
        //  need to set the flag to prevent the status text from being
        //  set.
        if (fOverOut && (!fHasMouseOverCancelled || !!hr))
        {
            if ((Tag() == ETAG_A) || (Tag() == ETAG_AREA))
                DYNCAST(CHyperlink, this)->_fHasMouseOverCancelled = fHasMouseOverCancelled;
            else
            {
                // if we are within the scope of an anchor....
                CTreeNode * pAnchor = GetFirstBranch()->Ancestor(ETAG_A);
                if (pAnchor)
                    DYNCAST(CHyperlink, pAnchor->Element())->_fHasMouseOverCancelled = fHasMouseOverCancelled;
            }
        }
    }

Cleanup:
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  member  :   click()   IHTMLElement method
//
//-----------------------------------------------------------------------------

HRESULT BUGCALL
CElement::click(CTreeNode *pNodeContext)
{
    HRESULT hr = DoClick(NULL, pNodeContext, FALSE, NULL, TRUE );
    if(hr == S_FALSE)
        hr = S_OK;
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::DoClick
//
//  Arguments:  pMessage    Message that resulted in the click. NULL when
//                          called by OM method click().
//              if this is called on a disabled site, we still want to
//              fire the event (the event code knows to do the right thing
//              and start above the disabled site). and we still want to
//              call click action... but not on us, on the parent
//
//-------------------------------------------------------------------------

HRESULT
CElement::DoClick(CMessage * pMessage /*=NULL*/, CTreeNode *pNodeContext /*=NULL*/,
                  BOOL fFromLabel , /*=FALSE*/
                  EVENTINFO *pEvtInfo /*=NULL*/,
                  BOOL fFromClick /*=FALSE*/)
{
    HRESULT hr = S_OK;

    if(!pNodeContext)
        pNodeContext = GetFirstBranch();

    if(!pNodeContext)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!TestLock(ELEMENTLOCK_CLICK))
    {
        CLock              Lock(this, ELEMENTLOCK_CLICK);
        CTreeNode::CLock   NodeLock;

        hr = THR( NodeLock.Init(pNodeContext) );
        if( hr )
            goto Cleanup;
        
        if (Fire_onclick(pNodeContext, pMessage ? pMessage->lSubDivision : 0, pEvtInfo ))
        {
            // Bubble clickaction up the parent chain,
            CTreeNode * pNode = pNodeContext;
            while (pNode)
            {
                if (!(pNode->ShouldHaveLayout() && pNode->Element()->GetAAdisabled()))
                {
                    //
                    // if the node is editable - we want to not call click action - and not continue
                    // to bubble the event
                    
                    if ( pNode->Element()->IsEditable(/*fCheckContainerOnly*/FALSE) )
                    {
                        BOOL fSkipEdit = TRUE;

                        //
                        // Handle InputFile weirdness. Half of control is editable
                        // other half ( the button ) is not
                        // 
                        if( pNode->Element()->Tag() == ETAG_INPUT )
                        {
                            CInput * pInput = DYNCAST(CInput, pNode->Element());

                            // We only want the htmlInputFile version of CInput
                            if (pInput->GetType() == htmlInputFile)
                            {
                                CElement* pParent = pNode->Parent() && 
                                                    pNode->Parent()->Element() ? 
                                                        pNode->Parent()->Element()
                                                        : NULL ;
                                
                                // We are really in edit mode, if the button does not have focus
                                // or our parent is editable
                                // 
                                fSkipEdit = ( fFromClick ? FALSE : !pInput->_fButtonHasFocus ) || 
                                            ( pParent && pParent->IsEditable(/*fCheckContainerOnly*/FALSE) ) ;
                            }         
                        }  
                        
                        if ( fSkipEdit )
                        {
                            hr = S_FALSE;
                            break;
                        }
                    }
                    
                    
                    // we're not a disabled site
                    hr = THR(pNode->Element()->ClickAction(pMessage));
                    if (hr != S_FALSE)
                        break;
                }

                // We need to break if we are called because
                // a label was clicked in case the element is a child
                // of the label. (BUG 19132 - krisma)
                if (ETAG_MAP == pNode->Tag() || fFromLabel == TRUE)
                {
                    //
                    // If we're the map, break out right now, since the associated
                    // IMG has already fired its events.
                    //

                    break;
                }

                if (pNode->Element()->HasMasterPtr())
                {
                    pNode = pNode->Element()->GetMasterPtr()->GetFirstBranch();
                }
                else if (pNode->Parent())
                {
                    pNode = pNode->Parent();
                }
                else
                {
                    pNode = pNode->Element()->GetFirstBranch();
                    if(pNode)
                        pNode = pNode->Parent();
                }
            }

            // Propagate error codes from ClickAction, but not S_FALSE
            // because that could confuse callers into thinking that the
            // message was not handled.?
            if (S_FALSE == hr)
                hr = S_OK;
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::ClickAction
//
//  Arguments:  pMessage    Message that resulted in the click. NULL when
//                          called by OM method click().
//
//  Synopsis:   Returns S_FALSE if this should bubble up to the parent.
//              Returns S_OK otherwise.
//
//-------------------------------------------------------------------------

HRESULT
CElement::ClickAction(CMessage * pMessage)
{
    return S_FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::GetIdentifier
//
//  This fn looks in the current elements' attr array & picks out
// this
//-------------------------------------------------------------------------

LPCTSTR
CElement::GetIdentifier(void)
{
    LPCTSTR             pStr;
    CAttrArray         *pAA;
    
    if ( !IsNamed() )
        return NULL;

    pAA = *GetAttrArray();

    // We're leveraging the fact that we know the dispids of name & ID, & we
    // also have a single _pAA in CElement containing all the attributes
    if (pAA &&
        pAA->HasAnyAttribute() &&
        ((pAA->FindString (STDPROPID_XOBJ_NAME,        &pStr) && pStr) ||
         (pAA->FindString (DISPID_CElement_id,         &pStr) && pStr) ||
          pAA->FindString (DISPID_CElement_uniqueName, &pStr)))
    {
        // This looks dodgy but is safe as long as the return value is treated
        // as a temporary value that is used immediatly, then discarded
        return pStr;
    }
    else
    {
        return NULL;
    }
}


HRESULT
CElement::GetUniqueIdentifier (CStr * pcstr, BOOL fSetWhenCreated /* = FALSE */, BOOL *pfDidCreate /* = NULL */)
{
    HRESULT             hr;
    LPCTSTR             pchUniqueName = GetAAuniqueName();

    if ( pfDidCreate )
        *pfDidCreate = FALSE;

    if (!pchUniqueName)
    {
        CDoc * pDoc = Doc();

        hr = THR(pDoc->GetUniqueIdentifier(pcstr));
        if (hr)
            goto Cleanup;

        if (fSetWhenCreated)
        {
            if ( pfDidCreate )
                *pfDidCreate = TRUE;
            hr = THR(SetUniqueNameHelper(*pcstr));
        }
    }
    else
    {
        hr = THR(pcstr->Set(pchUniqueName));
    }

Cleanup:
    RRETURN(hr);
}

LPCTSTR CElement::GetAAname() const
{
    LPCTSTR     pv;
    CAttrArray *pAA;
    
    if ( !IsNamed() )
        return NULL;

    pAA = *GetAttrArray();

    // We're leveraging the fact that we know the dispids of name & ID, & we
    // also have a single _pAA in CElement containing all the attributes
    if ( pAA && pAA->FindString ( STDPROPID_XOBJ_NAME, &pv) )
    {
        return pv;
    }
    else
    {
        return NULL;
    }
}

BOOL CElement::IsDesignMode ( void )
{
    CMarkup *pMarkup = GetMarkup();
    return pMarkup ? pMarkup->_fDesignMode : GetWindowedMarkupContext()->_fDesignMode;
}

// abstract name property helpers
STDMETHODIMP CElement::put_name(BSTR v)
{
    // If Browse time, setting the name changes the submit name
    if ( IsDesignMode() )
    {
        return s_propdescCElementpropdescname.b.SetStringProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
    }
    else
    {
        return s_propdescCElementsubmitName.b.SetStringProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
    }
}

STDMETHODIMP CElement::get_name(BSTR * p)
{
    // If browse time, get the submit name if set, else get the real name
    if ( IsDesignMode() )
    {
        return s_propdescCElementpropdescname.b.GetStringProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
    }
    else
    {
        RRETURN( SetErrorInfo ( THR( FormsAllocString( GetAAsubmitname(), p ) ) ));
    }
}

LPCTSTR CElement::GetAAsubmitname() const
{
    LPCTSTR             pv;
    CAttrArray         *pAA = *GetAttrArray();

    // We're leveraging the fact that we know the dispids of name & ID, & we
    // also have a single _pAA in CElement containing all the attributes
    if ( pAA )
    {
        if (pAA->FindString ( DISPID_CElement_submitName, &pv) )
        {
            return pv;
        }
        else if (IsNamed() && pAA->FindString ( STDPROPID_XOBJ_NAME, &pv) )
        {
            return pv;
        }
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Member:      GetBgImgCtx()
//
// Synopsis:    Return the image ctx if the element has a background Image
//
//-----------------------------------------------------------------------------

CImgCtx *
CElement::GetBgImgCtx(FORMAT_CONTEXT FCPARAM)
{
    if (g_fHighContrastMode)
        return NULL;        // in high contrast mode there is no background image

    long lCookie = GetFirstBranch()->GetFancyFormat(FCPARAM)->_lImgCtxCookie;

    return lCookie ? Doc()->GetUrlImgCtx(lCookie) : NULL;
}

//+---------------------------------------------------------------------------
//
//  Members : the following get_on* and put_on* members are primarily here
//      in order to delegate the assigments to the window.  They are currently
//      mainly used by body and frameset to remap to the window object (Nav
//      compat & consistency).  You should also see GetBaseObjectFor() to see
//      the other place this assignment happens.
//
//      The other half of the work is in the fire_on* code which detects when we
//      are a body, and redirects.
//
//----------------------------------------------------------------------------

#define IMPLEMENT_PUT_PROP(prop)                    \
    HRESULT hr = S_OK;                              \
    if (    IsInMarkup()                            \
        &&  GetMarkup()->HasWindow())               \
    {                                               \
        hr = THR(GetMarkup()->Window()->put_##prop(v)); \
        if (hr)                                         \
            goto Cleanup;                               \
    }                                               \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_PUT_PROP_EX(prop)                 \
    HRESULT hr;                                     \
    if (    (   Tag()==ETAG_BODY                    \
            ||  Tag()==ETAG_FRAMESET)               \
        &&  IsInMarkup()                            \
        &&  GetMarkup()->HasWindow())               \
    {                                               \
        hr = THR(GetMarkup()->Window()->put_##prop(v)); \
        if (hr)                                     \
            goto Cleanup;                           \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty( \
                    HANDLEPROP_SET | HANDLEPROP_AUTOMATION |    \
                    (PROPTYPE_VARIANT << 16),                   \
                    &v,                                         \
                    this,                                       \
                    CVOID_CAST(GetAttrArray())));               \
    }                                                           \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_PUT_PROP_EX2(prop)                \
    HRESULT hr;                                     \
    if (    IsInMarkup()                            \
        &&  (   (   (   Tag()==ETAG_BODY                    \
                    ||  Tag()==ETAG_FRAMESET)               \
                &&  !GetMarkup()->IsHtmlLayout())   \
            ||  (   Tag() == ETAG_HTML              \
                &&  GetMarkup()->IsHtmlLayout()))   \
        &&  GetMarkup()->HasWindow())               \
    {                                               \
        hr = THR(GetMarkup()->Window()->put_##prop(v)); \
        if (hr)                                     \
            goto Cleanup;                           \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty( \
                    HANDLEPROP_SET | HANDLEPROP_AUTOMATION |    \
                    (PROPTYPE_VARIANT << 16),                   \
                    &v,                                         \
                    this,                                       \
                    CVOID_CAST(GetAttrArray())));               \
    }                                                           \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \


#define IMPLEMENT_GET_PROP(prop)                    \
    HRESULT hr = S_OK;                              \
    if (IsInMarkup())                               \
    {                                               \
        CMarkup *pMarkup = GetMarkup();             \
        if (pMarkup->HasWindow())                   \
        {                                           \
            hr = THR(pMarkup->Window()->get_##prop(v));\
            goto Cleanup;                           \
        }                                           \
    }                                               \
    V_VT(v) = VT_EMPTY;                             \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_GET_PROP_EX(prop)                 \
    HRESULT hr = S_OK;                              \
    if ((Tag() == ETAG_BODY) || Tag() == ETAG_FRAMESET) \
    {                                               \
        if (IsInMarkup())                           \
        {                                           \
            CMarkup *pMarkup = GetMarkup();         \
            if (pMarkup->HasWindow())               \
            {                                       \
                hr = THR(pMarkup->Window()->get_##prop(v));\
                goto Cleanup;                       \
            }                                       \
        }                                           \
        V_VT(v) = VT_EMPTY;                         \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty(     \
                HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),   \
                v,                                                  \
                this,                                               \
                CVOID_CAST(GetAttrArray())));                       \
    }                                               \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_GET_PROP_EX2(prop)                \
    HRESULT hr = S_OK;                              \
    if  (   (   Tag() == ETAG_HTML                  \
            &&  IsInMarkup()                        \
            &&  GetMarkup()->IsHtmlLayout())\
        ||  (   (   Tag() == ETAG_BODY              \
                ||  Tag() == ETAG_FRAMESET)         \
            && !(   IsInMarkup()                    \
                &&  GetMarkup()->IsHtmlLayout())))  \
    {                                               \
        if (IsInMarkup())                           \
        {                                           \
            CMarkup *pMarkup = GetMarkup();         \
            if (pMarkup->HasWindow())               \
            {                                       \
                hr = THR(pMarkup->Window()->get_##prop(v));\
                goto Cleanup;                       \
            }                                       \
        }                                           \
        V_VT(v) = VT_EMPTY;                         \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty(     \
                HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),   \
                v,                                                  \
                this,                                               \
                CVOID_CAST(GetAttrArray())));                       \
    }                                               \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

HRESULT
CElement:: put_onload(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onload)
}

HRESULT
CElement:: get_onload(VARIANT *v)
{
    IMPLEMENT_GET_PROP(onload)
}


HRESULT
CElement:: put_onunload(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onunload)
}
HRESULT
CElement:: get_onunload(VARIANT *v)
{
    IMPLEMENT_GET_PROP(onunload)
}


STDMETHODIMP
CElement::put_onbeforeunload(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onbeforeunload)
}

STDMETHODIMP
CElement::get_onbeforeunload(VARIANT * v)
{
    IMPLEMENT_GET_PROP(onbeforeunload)
}

STDMETHODIMP
CElement::get_onhelp(VARIANT * v)
{
    IMPLEMENT_GET_PROP_EX(onhelp)
}

STDMETHODIMP
CElement::put_onhelp(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onhelp)
}


HRESULT
CElement:: put_onblur(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onblur)
}

HRESULT
CElement:: get_onblur(VARIANT *v)
{
    IMPLEMENT_GET_PROP_EX(onblur)
}

HRESULT
CElement:: put_onfocus(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onfocus)
}

HRESULT
CElement:: get_onfocus(VARIANT *v)
{
    IMPLEMENT_GET_PROP_EX(onfocus)
}

// NOTE (greglett): onafterprint/onbeforeprint events are implemented
// on CElement only for the body and frameset elements

STDMETHODIMP
CElement::put_onbeforeprint(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onbeforeprint)
}

STDMETHODIMP
CElement::get_onbeforeprint(VARIANT * v)
{
    IMPLEMENT_GET_PROP(onbeforeprint)
}

STDMETHODIMP
CElement::put_onafterprint(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onafterprint)
}

STDMETHODIMP
CElement::get_onafterprint(VARIANT * v)
{
    IMPLEMENT_GET_PROP(onafterprint)
}


STDMETHODIMP
CElement::put_onscroll(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX2(onscroll)
}


STDMETHODIMP
CElement::get_onscroll(VARIANT * v)
{
    IMPLEMENT_GET_PROP_EX2(onscroll)
}


//+-----------------------------------------------------------------
//
//  member : Fire_onresize
//
//  synopsis : IHTMLTextContainer event implementation
//
//------------------------------------------------------------------

void
CElement::Fire_onresize()
{
    if (    (   Tag() == ETAG_BODY        
            ||  Tag() == ETAG_FRAMESET )    
        &&  IsInMarkup() 
        &&  GetMarkup()->HasWindow())
    {                                    
     
        GetMarkup()->Window()->Fire_onresize();                         
    }
    else
    {
        FireEvent(&s_propdescCElementonresize);
    }
}


//+-----------------------------------------------------------------
//
//  member : Fire_onscroll
//
//  synopsis : IHTMLTextContainer event implementation
//
//------------------------------------------------------------------
void
CElement::Fire_onscroll()
{    
    if (    IsInMarkup() 
        &&  this == GetMarkup()->GetCanvasElement()
        &&  GetMarkup()->HasWindow())
    {
            GetMarkup()->Window()->Fire_onscroll();                     
    }
    else
    {
        FireOnChanged(DISPID_IHTMLELEMENT2_SCROLLTOP);
        FireOnChanged(DISPID_IHTMLELEMENT2_SCROLLLEFT);

        FireEvent(&s_propdescCElementonscroll);
    }
}

STDMETHODIMP
CElement::put_onresize(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onresize)
}


STDMETHODIMP
CElement::get_onresize(VARIANT * v)
{
    IMPLEMENT_GET_PROP_EX(onresize)
}

void CElement::Fire_onfocus(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();
    if (!IsConnectedToPrimaryMarkup() || pDoc->IsPassivated())
        return;

    CDoc::CLock LockForm(pDoc, FORMLOCK_CURRENT);
    CLock LockFocus(this, ELEMENTLOCK_FOCUS);
    FireEvent(&s_propdescCElementonfocus, TRUE, NULL, -1, NULL, dwContext);    
}

void CElement::Fire_onblur(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();
    if (!IsConnectedToPrimaryMarkup() || pDoc->IsPassivated())
        return;

    CDoc::CLock LockForm(pDoc, FORMLOCK_CURRENT);
    CLock LockBlur(this, ELEMENTLOCK_BLUR);
    pDoc->_fModalDialogInOnblur = (BOOL)dwContext;
    FireEvent(&s_propdescCElementonblur);
    pDoc->_fModalDialogInOnblur = FALSE;
}

void CElement::Fire_onfilterchange(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();
    if (!IsInMarkup() || pDoc->IsPassivated())
        return;

    TraceTag((tagFilterChange, "Fire onfilterchange for %ls-%d",
                TagName(), SN()));

    CDoc::CLock LockForm(pDoc, FORMLOCK_CURRENT);
    FireEvent(&s_propdescCElementonfilterchange);
}

BOOL
CElement::Fire_ActivationHelper(long        lSubThis,
                                CElement *  pElemOther,
                                long        lSubOther,
                                BOOL        fPreEvent,
                                BOOL        fDeactivation,
                                BOOL        fFireFocusBlurEvents, 
                                EVENTINFO * pEvtInfo,               /* = NULL */
                                BOOL        fFireActivationEvents   /* = TRUE */)
{
    CElement *  pElement;
    BOOL        fRet        = TRUE;
    CDoc *      pDoc        = Doc();
    CElement *  pElemFire;

    Assert( fPreEvent && pEvtInfo || ! pEvtInfo ); // we only expect an event info for OnBeforeDeactivate
    Assert(!fPreEvent || fFireActivationEvents);
    
    if (    !IsConnectedToPrimaryMarkup()
        ||  pDoc->IsPassivated())
    {
        return fRet;
    }

    if (fDeactivation && pDoc->_fForceCurrentElem)
    {
        // Don't post blur event if shutting down
        fFireFocusBlurEvents = FALSE;
    }
    else if (!fFireFocusBlurEvents && pDoc->HasFocus())
    {
        // always fire focus/blur events if Doc has focus
        fFireFocusBlurEvents = TRUE;
    }

    pElement = this;
    for(;;)
    {
        pElement->_fFirstCommonAncestor = 0;
        
        pElement = pElement->GetMarkup()->Root();
        if (!pElement->HasMasterPtr())
            break;
        pElement = pElement->GetMasterPtr();
    }

    if (pElemOther)
    {
        pElement = pElemOther;
        for (;;)
        {
            pElement->_fFirstCommonAncestor = 1;

            if (!pElement->IsInMarkup())
                break;
            pElement = pElement->GetMarkup()->Root();
            if (!pElement->HasMasterPtr())
                break;
            pElement = pElement->GetMasterPtr();
        }
    }

    pElement = this;
    for(;;)
    {
        if (pElement->_fFirstCommonAncestor)
        {
            if (this == pElement && this == pElemOther)
            {
                Assert(lSubThis != lSubOther); // continue to fire the events
            }
            else
                break;
        }
        EVENTPARAM  param(pDoc, pElement, NULL, TRUE);
        CTreeNode * pNodeOtherLoop;
        long lSubOtherLoop = lSubOther;
        
        Assert(!param._pNodeTo);
        Assert(param._lSubDivisionTo == -1);
        Assert(!param._pNodeFrom);
        Assert(param._lSubDivisionFrom == -1);
        param.SetNodeAndCalcCoordinates(pElement->GetFirstBranch());
        if (pElement->IsInMarkup() && pElemOther && pElemOther->IsInMarkup())
        {
            pNodeOtherLoop = pElemOther->GetFirstBranch()->GetNodeInMarkup(pElement->GetMarkup());
        }
        else
        {
            pNodeOtherLoop = NULL;
        }
        if (!pNodeOtherLoop || pNodeOtherLoop->Element() != pElemOther)
        {
            lSubOtherLoop = -1;
        }

        if (fPreEvent)
        {
            if (fDeactivation)
            {
                param.SetType(s_propdescCElementonbeforedeactivate.a.pstrName + 2);
                param._pNodeTo = pNodeOtherLoop;
                param._lSubDivisionTo = lSubOtherLoop;

                if ( pEvtInfo )
                {
                    pEvtInfo->_dispId = (DISPID) s_propdescCElementonbeforedeactivate.c ;
                    //  
                    //  The check-in by marka 2000/07/05 indicates that we only populate
                    //  pEvtInfo for OnBeforeDeactivate. However, this process could have
                    //  been repeated due to nested viewlinking and event routing outside
                    //  viewlink. For now, we only care about the first param._pNodeTo in 
                    //  the viewlink chain.
                    //  
                    //  [zhenbinx]
                    //
                    if (!pEvtInfo->_pParam)
                    {
                        pEvtInfo->_pParam = new EVENTPARAM( & param );                 // Deleted from destructor of EventObject.
                        //
                        // HACKHACK-IEV6-5397-2000/07/26-zhenbinx:
                        //
                        // We need _pNodeTo to be the same as pElemOther! Before we expose
                        // OnBeforeDeactivate to Designers, Trident was routing pElemOther
                        // to Editor, So the Editor was written based on the assumption that
                        // the new element could be in different markup than the source element.
                        // Now we are routing Event Object and both Src/To elements are in 
                        // the same markup! This breaks Editor so here I am hacking to
                        // put the _pNodeTo back to the element that is in a different markup.
                        //
                        //
                        pEvtInfo->_pParam->_pNodeTo = pElemOther->GetFirstBranch();
                    }
                }    
                
                fRet = (S_FALSE == pElement->FireEvent(&s_propdescCElementonbeforedeactivate, FALSE, NULL, lSubThis));
                if (!fRet)
                    break;
            }
            else
            {
                if ( ! pElement->TestLock(CElement::ELEMENTLOCK_BEFOREACTIVATE))
                {
                    param.SetType(s_propdescCElementonbeforeactivate.a.pstrName + 2);
                    param._pNodeFrom = pNodeOtherLoop;
                    param._lSubDivisionFrom = lSubOtherLoop;

                    CLock LockFocus(this, ELEMENTLOCK_BEFOREACTIVATE);
        
                    fRet = (S_FALSE == pElement->FireEvent(&s_propdescCElementonbeforeactivate, FALSE, NULL, lSubThis));
                    if (!fRet)
                        break;
                }                    
            }
        }
        else if (fDeactivation)
        {
            if (fFireActivationEvents)
            {
                param.SetType(s_propdescCElementondeactivate.a.pstrName + 2);
                param._pNodeTo = pNodeOtherLoop;
                param._lSubDivisionTo = lSubOtherLoop;
                pElement->FireEvent(&s_propdescCElementondeactivate, FALSE, NULL, lSubThis);
            }
            if (fFireFocusBlurEvents && !pDoc->_fPopupDoc)
            {
                EVENTPARAM  param2(pDoc, pElement, NULL, TRUE);

                pElemFire = (this == pElement) ? GetFocusBlurFireTarget(lSubThis) : pElement;

                if (pElemFire->Doc() == Doc())
                {
                    // fire onfocusout
                    param2.SetNodeAndCalcCoordinates(pElement->GetFirstBranch());
                    param2.SetType(s_propdescCElementonfocusout.a.pstrName + 2);
                    param2._pNodeTo = pNodeOtherLoop;
                    param2._lSubDivisionTo = lSubOtherLoop;
                    pElemFire->FireEvent(&s_propdescCElementonfocusout, FALSE, NULL, 0);

                    // post onblur
                    Verify(S_OK == GWPostMethodCall(
                                        pElemFire,
                                        ONCALL_METHOD(CElement, Fire_onblur, fire_onblur),
                                        0, TRUE, "CElement::Fire_onblur"));
                }
            }
        }
        else
        {
            if (fFireActivationEvents)
            {
                param.SetType(s_propdescCElementonactivate.a.pstrName + 2);
                param._pNodeFrom = pNodeOtherLoop;
                param._lSubDivisionFrom = lSubOtherLoop;
                pElement->FireEvent(&s_propdescCElementonactivate, FALSE, NULL, lSubThis);
            }
            if (   fFireFocusBlurEvents && !pDoc->_fPopupDoc)
            {
                EVENTPARAM  param2(pDoc, pElement, NULL, TRUE);
                
                pElemFire = (this == pElement) ? GetFocusBlurFireTarget(lSubThis) : pElement;                

                BOOL fDontFireMSAAEvent = (this != pElemFire) && 
                                          ((pElemFire->Tag() == ETAG_IFRAME) || 
                                          (pElemFire->Tag() == ETAG_FRAME) || 
                                          (pElemFire->Tag() == ETAG_GENERIC));
                
                if (pElemFire->Doc() == Doc())
                {
                    // fire onfocusin
                    param2.SetNodeAndCalcCoordinates(pElement->GetFirstBranch());
                    param2.SetType(s_propdescCElementonfocusin.a.pstrName + 2);
                    param2._pNodeFrom = pNodeOtherLoop;
                    param2._lSubDivisionFrom = lSubOtherLoop;
                    pElemFire->FireEvent(&s_propdescCElementonfocusin, FALSE, NULL, 0);

                    // post onfocus
                    Verify(S_OK == GWPostMethodCall(
                                        pElemFire,
                                        ONCALL_METHOD(CElement, Fire_onfocus, fire_onfocus),
                                        fDontFireMSAAEvent, TRUE, "CElement::Fire_onfocus"));
                }
            }
        }
        if (!pElement->IsInMarkup() || pElement->_fExittreePending)
            break;

        pElement = pElement->GetMarkup()->Root();
        if (!pElement->HasMasterPtr())
            break;
        pElement = pElement->GetMasterPtr();
    }

    return fRet;
}

//+----------------------------------------------------
//
//  member : get_offsetTop, IHTMLElement
//
//  synopsis : returns the top, coordinate of the
//      element
//
//-----------------------------------------------------

HRESULT
CElement::get_offsetTop ( long *plValue )
{
    HRESULT         hr = S_OK;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if(!IsInMarkup() || !Doc()->GetView()->IsActive())
    {
        *plValue = 0;
    }
    else
    {
        *plValue = 0;
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        switch (_etag)
        {
        case ETAG_MAP :
            break;

        case ETAG_AREA:
            {
                RECT rectBound;
                DYNCAST(CAreaElement, this)->GetBoundingRect(&rectBound);
                *plValue = rectBound.top;
            }
            break;

        default :
            {
                POINT     pt = g_Zero.pt;
                CLayout * pLayout = NULL;                
                CLayoutContext *pContext;
                
                hr = THR(EnsureRecalcNotify());

                if (!hr)
                    hr = THR(GetElementTopLeft(pt));
                else
                    goto Cleanup;
                
                *plValue = pt.y;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);  // Incorrect for paginated element behaviors (greglett)
                pContext  = pLayout
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());
                   pUnitInfo = pdiTemp->GetUnitInfo();
                }
            }
            break;
        }
        *plValue = pUnitInfo->DocPixelsFromDeviceY(*plValue);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+----------------------------------------------------
//
//  member : get_OffsetLeft, IHTMLElement
//
//  synopsis : returns the left coordinate of the
//      element
//
//-----------------------------------------------------

HRESULT
CElement::get_offsetLeft ( long *plValue )
{
    HRESULT       hr = S_OK;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if(!IsInMarkup() || !Doc()->GetView()->IsActive())
    {
        *plValue = 0;
    }
    else
    {
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        *plValue = 0;
        switch (_etag)
        {
        case ETAG_MAP :
            break;

        case ETAG_AREA:
            {
                RECT rectBound;
                DYNCAST(CAreaElement, this)->GetBoundingRect(&rectBound);

                *plValue = rectBound.left;
            }
            break;

        default :
            {
                POINT     pt = g_Zero.pt;
                CLayout * pLayout = NULL;
                CLayoutContext *pContext;
                
                hr = THR(EnsureRecalcNotify());
                if (!hr)
                    hr = THR(GetElementTopLeft(pt));
                else
                    goto Cleanup;
                
                *plValue = pt.x;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);    // Incorrect for paginated element behaviors (greglett)
                pContext  = pLayout
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }
            }
            break;
        }
        *plValue = pUnitInfo->DocPixelsFromDeviceX(*plValue);
    }
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

// helper function for offset left and top
HRESULT
CElement::GetElementTopLeft(POINT & pt)
{
    HRESULT hr = S_OK;

    pt = g_Zero.pt;

    if (IsInMarkup())
    {
        Assert(GetFirstBranch());

        CLayout *   pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        if (pLayout)
        {
            CDispNode *pDispNode = pLayout->GetElementDispNode();

            //--------------------------------------------------------------------------
            //
            // If you look inside GetPosition, you will see a hack to handle TR's. Instead
            // of duplicating that hack here, we just call GetPosition instead of calling
            // GetApparentBounds on the TR. Since the TR is always horizontal, this hack
            // is actually a good one which is also compat with what it used to do before.
            //
            //--------------------------------------------------------------------------
            if (ETAG_TR == Tag())
            {
                pLayout->GetPosition(&pt);
            }
            else if (pDispNode && ShouldHaveLayout())
            {
                CRect rcBounds;
                BOOL fParentVertical = FALSE;
                CLayout *pParentLayout = NULL;

                if (   GetFirstBranch()
                    && GetFirstBranch()->ZParentBranch()
                   )
                {
                    CElement *pParentElement = GetFirstBranch()->ZParentBranch()->Element();
                    if (   pParentElement
                        && pParentElement->HasVerticalLayoutFlow()
                       )
                    {
                        fParentVertical = TRUE;
                        pParentLayout = pParentElement->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
                    }
                }
                pDispNode->GetApparentBounds(&rcBounds);
                if (!fParentVertical)
                {
                    pt.x = rcBounds.left;
                    pt.y = rcBounds.top;
                }
                else
                {
                    Assert(pParentLayout);
                    pt.x = pParentLayout->GetContentHeight(FALSE) - rcBounds.bottom;
                    pt.y = rcBounds.left;
                }
                
                // NOTE(SujalP): None of the following transformations being applied
                // to the pt are different in a vertical-layout enabled scenario. That
                // is because the table is *never* vertical. Hence all the transformations
                // between a table and a TD are always the same irrespective of the
                // orientation of the TD.
                
                // if we are a table, then adjust for a caption and table borders.
                //---------------------------------------------------------------
                if (   (Tag() == ETAG_TD)
                    || (Tag() == ETAG_TH))
                {
                    CTableCellLayout *   pCellLayout  = (CTableCellLayout *)pLayout;
                    CTableLayout * pTableLayout = pCellLayout->TableLayout();
                    if (pTableLayout)
                    {
                        CDispNode * pGridNode = pTableLayout->GetTableInnerDispNode();
                        if (     pCellLayout->_pDispNode
                             && (pCellLayout->_pDispNode->GetParentNode() == pGridNode))
                        {
                            // if cell is positioned or lives inside of the positioned row - do nothing.
                            if (pTableLayout->_pDispNode != pGridNode)
                            {
                                // if table has a caption and as a result GridNode and the Table Display Node is 
                                // not the same, we need to offset the cell by the caption height and the table border
                                pGridNode->TransformPoint(pt, COORDSYS_FLOWCONTENT, (CPoint *)&pt, COORDSYS_PARENT);
                            }
                            else
                            {
                                // need to offset the cell by the border width
                                if (pGridNode->HasBorder())
                                {
                                    CRect rcBorderWidths;
                                    pGridNode->GetBorderWidths(&rcBorderWidths);
                                    pt.x += rcBorderWidths.left;
                                    pt.y += rcBorderWidths.top;
                                }
                            }
                        }
                    }
                }
                else if (!pLayout->ElementOwner()->IsAbsolute())
                {
                    // Absolutely positined elements are already properly reporting their position
                    //
                    // we are not a TD/TH, but our PARENT might be!
                    // if we are in a table cell, then we need to adjust for the cell insets,
                    // in case the content is vertically aligned.
                    //-----------------------------------------------------------
                    CLayout *pParentLayout = pLayout->GetUpdatedParentLayout();

                    if (   pParentLayout 
                        && (   (pParentLayout->Tag() == ETAG_TD) 
                            || (pParentLayout->Tag() == ETAG_TH) 
                            || (pParentLayout->Tag() == ETAG_CAPTION) ))
                    {
                        CDispNode * pDispNode = pParentLayout->GetElementDispNode();

                        if (pDispNode && pDispNode->HasInset())
                        {
                            const CSize & sizeInset = pDispNode->GetInset();
                            pt.x += sizeInset.cx;
                            pt.y += sizeInset.cy;
                        }
                    }

                }
            }
            else if (!ShouldHaveLayout())
            {
                // there is a display node from the nearest layout, but the layout
                //   is not Our OWN

                hr = THR(pLayout->GetChildElementTopLeft(pt, this));

                // If we're a positioned elem w/o layout (and only relatively positioned
                // elements can possibly not have layouts), the situation is more complicated.
                // We need to determine the layout parent's relationship to the positioning
                // (offset) parent.  The pt we've retrieved is wrt to the layout parent,
                // but it needs to be wrt the positioning parent.
                if ( IsRelative() )
                {
                    Assert( GetOffsetParentHelper() );

                    POINT     ptAdjust = g_Zero.pt;
                    CElement *pOffsetParentElement = GetOffsetParentHelper()->Element();
                    CElement *pLayoutParentElement = pLayout->ElementOwner();
                    CTreeNode *pIterNode = GetFirstBranch()->Parent();   // start looking from our parent
                    BOOL      fLayoutParentFirst = FALSE;
                    BOOL      fOffsetParentFirst = FALSE;

                    Assert( this != pLayoutParentElement && this != pOffsetParentElement );

                    // If our offset parent and layout parent are the same, no
                    // adjustment work needs to be done.
                    if ( pOffsetParentElement != pLayoutParentElement )
                    {
                        // Discover the relationship between the offset parent and
                        // the layout parent: which is nested under which?
                        while (pIterNode)
                        {
                            if (pIterNode->Element() == pLayoutParentElement)
                            {
                                fLayoutParentFirst = TRUE;
                                break;
                            }
                            if (pIterNode->Element() == pOffsetParentElement)
                            {
                                fOffsetParentFirst = TRUE;
                                break;
                            }
                            pIterNode = pIterNode->Parent();
                        }

                        if (pIterNode)
                        {
                            if (fLayoutParentFirst)
                            {
                                // TODO: Our relative story for nesting of the form 
                                // <rel non-layout><layout><layout><rel non-layout>
                                // has always been broken (bug #105716).  This code only tries to make
                                // <positioned layout><layout>...<rel non-layout> work.

                                // pt is wrt the layout parent, which we found first.  We need to
                                // keep walking outwards, accumulating into pt the offsets of all
                                // layouts between us and our offset parent.

                                while (   pLayoutParentElement
                                       && pLayoutParentElement != pOffsetParentElement)
                                {
                                    Assert( !pLayoutParentElement->IsPositioned() );
                                    Assert( pLayoutParentElement->IsInMarkup() );

                                    pLayoutParentElement->GetElementTopLeft( ptAdjust );
                                    pt.x += ptAdjust.x;
                                    pt.y += ptAdjust.y;

                                    pLayoutParentElement = pLayoutParentElement->GetFirstBranch()->ZParentBranch()->Element();
                                }
                            }
                            else if (fOffsetParentFirst)
                            {
                                // Since we found our offset parent before our nearest layout, our offset parent
                                // can't have layout.  In fact, it must be true that our offset parent has the
                                // same nearest layout as us.
                                Assert(    pOffsetParentElement->IsInMarkup()
                                        && !pOffsetParentElement->ShouldHaveLayout()
                                        && pOffsetParentElement->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT) == pLayout );

                                hr = THR(pLayout->GetChildElementTopLeft(ptAdjust, pOffsetParentElement));

                                // Fix pt so that it's wrt our offset parent
                                pt.x -= ptAdjust.x;
                                pt.y -= ptAdjust.y;
                            }
                        }
                    }
                }
            }
            //else
            //{
            //      TODO (carled) in this case, we HAVE a layout but no Display node.  
            //      We should not get here, but occasionally are. and so we should just 
            //      return 0,0
            //}
        }
    }

    RRETURN(hr);
}

//************************************************
//
// IF YOU CHANGE THIS ROUTINE - YOU MUST CHANGE THE FUNCTION OF THE SAME NAME IN EDTRACK
// OR ELSE SELECTION IN FRAMES WILL HAVE ISSUES
//
//************************************************

void
CElement::GetClientOrigin(POINT * ppt)
{
    *ppt = g_Zero.pt;

    if (!HasMarkupPtr())
        return;

    CElement*   pRoot = GetMarkup()->Root();

    if (!pRoot->HasMasterPtr())
        return;

    CLayout * pLayout = pRoot->GetMasterPtr()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

    if (!pLayout)
        return;

    // TODO (MohanB) Need to subtract the master's borders, etc.
    CPoint pt(*ppt);
    pLayout->TransformPoint(&pt, COORDSYS_SCROLL, COORDSYS_GLOBAL);
    *ppt = pt;
}


//+----------------------------------------------------
//
//  member : GetInheritedBackgroundColor
//
//  synopsis : returns the actual background color
//
//-----------------------------------------------------

COLORREF
CElement::GetInheritedBackgroundColor(CTreeNode * pNodeContext /* = NULL */)
{
    CColorValue ccv;

    IGNORE_HR(GetInheritedBackgroundColorValue(&ccv, pNodeContext));

    return ccv.GetColorRef();
}


//+----------------------------------------------------
//
//  member : GetInheritedBackgroundColorValue
//
//  synopsis : returns the actual background color as a CColorValue
//
//-----------------------------------------------------

HRESULT
CElement::GetInheritedBackgroundColorValue(CColorValue *pVal, CTreeNode * pNodeContext /* = NULL */ )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode = pNodeContext ? pNodeContext : GetFirstBranch();

    if(!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(pVal != NULL);

    do
    {
        *pVal   = pNode->GetFancyFormat()->_ccvBackColor;
        if (pVal->IsDefined())
            break;

        // Inherit from the master if this element is in a viewlink behavior and
        // wants to inherit style from the master.
        if (pNode->Tag() == ETAG_ROOT && pNode->Element()->IsInViewLinkBehavior(FALSE))
        {
            CElement * pElemMaster = pNode->Element()->GetMasterPtr();

            Assert(     pElemMaster
                    &&  pElemMaster->TagType() == ETAG_GENERIC
                    &&  (   !pElemMaster->HasDefaults()
                         || pElemMaster->GetDefaults()->GetAAviewInheritStyle()
                        )
                  );
            pNode = pElemMaster->GetFirstBranch();
        }
        else
        {
            pNode = pNode->Parent();
        }
    }
    while (pNode);

    // The root site should always have a background color defined.
    Assert(pVal->IsDefined());

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------
//
//  member  :   get_offsetWidth,  IHTMLElement
//
//  Synopsis:   Get the calculated height in doc units. if *this*
//          is a site then just return based on the size
//          if it is an element, then we need to get the regions
//          of its parts and add it up.
//
//-------------------------------------------------------------

HRESULT
CElement::get_offsetWidth ( long *plValue )
{
    HRESULT hr = S_OK;
    SIZE    size;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout * pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(GetBoundingSize(size));
        if (hr)
            goto Cleanup;

        *plValue = HasVerticalLayoutFlow() ? size.cy : size.cx;

        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());

           pUnitInfo = pdiTemp->GetUnitInfo();
        }
        *plValue = HasVerticalLayoutFlow() 
                        ? pUnitInfo->DocPixelsFromDeviceY(size.cy) 
                        : pUnitInfo->DocPixelsFromDeviceX(size.cx);
    }
    else
    {
        *plValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------
//
//  member  :   get_offsetHeight,  IHTMLElement
//
//  Synopsis:   Get the calculated height in doc units. if *this*
//          is a site then just return based on the size
//          if it is an element, then we need to get the regions
//          of its parts and add it up.
//
//-------------------------------------------------------------

HRESULT
CElement::get_offsetHeight ( long *plValue )
{
    HRESULT hr = S_OK;
    SIZE    size;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout * pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(GetBoundingSize(size));
        if (hr)
            goto Cleanup;

        *plValue = HasVerticalLayoutFlow() ? size.cx : size.cy;

        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());
            pUnitInfo = pdiTemp->GetUnitInfo();
        }

        *plValue = HasVerticalLayoutFlow() 
                        ? pUnitInfo->DocPixelsFromDeviceX(size.cx) 
                        : pUnitInfo->DocPixelsFromDeviceY(size.cy);
    }
    else
    {
        *plValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

// helper function for offset height and width
HRESULT
CElement::GetBoundingSize(SIZE & sizeBounds)
{
    CRect       rcBound;

    sizeBounds.cx=0;
    sizeBounds.cy=0;

    if (S_OK != EnsureRecalcNotify())
        return E_FAIL;

    GetBoundingRect(&rcBound);

    sizeBounds = rcBound.Size();

    return S_OK;
}


//+----------------------------------------------------
//
//  member : get_offsetParent, IHTMLElement
//
//  synopsis : returns the parent container (site) which
//      defines the coordinate system of the offset*
//      properties above.
//              returns NULL when no parent makes sense
//
//-----------------------------------------------------

HRESULT
CElement::get_offsetParent (IHTMLElement ** ppIElement)
{
    HRESULT  hr = S_OK;
    CTreeNode * pNodeRet = NULL;

    if (!ppIElement)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    else if(!GetFirstBranch())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppIElement= NULL;

    pNodeRet = GetOffsetParentHelper();

    if (pNodeRet &&
        pNodeRet->Tag() != ETAG_ROOT)
    {
        hr = THR( pNodeRet->GetElementInterface( IID_IHTMLElement, (void**) ppIElement ) );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

CTreeNode *
CElement::GetOffsetParentHelper()
{
    CTreeNode * pNodeRet = NULL;
    CTreeNode * pNodeContext = GetFirstBranch();

    switch( _etag)
    {
    case ETAG_HTML:
    case ETAG_BODY:
    case ETAG_MAP :
        // return NULL. Maps don't necessarily have a parent
        break;

    case ETAG_AREA:
        // the area's parent is the map
        if (pNodeContext->Parent())
        {
            pNodeRet = pNodeContext->Parent();
        }
        break;

    case ETAG_TD:
    case ETAG_TH:
        if (pNodeContext->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT))
        {
            pNodeRet = (ShouldHaveLayout())
                                ? pNodeContext->ZParentBranch()
                                : pNodeContext->GetUpdatedNearestLayoutNode();

            if (pNodeRet && pNodeRet->IsPositionStatic())
            {
                // return pNodeRet's parent
                pNodeRet = pNodeRet->ZParentBranch();
                Assert(pNodeRet && pNodeRet->Tag()==ETAG_TABLE);

            }
        }
        break;

    default:
        if (pNodeContext->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT))
            pNodeRet = pNodeContext->ZParentBranch();
        break;
    }

    return pNodeRet;
}

htmlComponent 
CElement::ComponentFromHTC(HTC htc)
{
    switch (htc)
    {
    case HTC_YES:
        return htmlComponentClient;
    case HTC_NO:
        return htmlComponentOutside;
    case HTC_TOPLEFTHANDLE :
        return htmlComponentGHTopLeft;
    case HTC_LEFTHANDLE :
        return htmlComponentGHLeft;
    case HTC_TOPHANDLE :
        return htmlComponentGHTop;
    case HTC_BOTTOMLEFTHANDLE :
        return htmlComponentGHBottomLeft;
    case HTC_TOPRIGHTHANDLE :
        return htmlComponentGHTopRight;
    case HTC_BOTTOMHANDLE :
        return htmlComponentGHBottom;
    case HTC_RIGHTHANDLE :
        return htmlComponentGHRight;
    case HTC_BOTTOMRIGHTHANDLE :
        return htmlComponentGHBottomRight;
    }
    return htmlComponentOutside;
}

HTC
CElement::HTCFromComponent(htmlComponent component)
{
    switch (component)
    {
    case htmlComponentClient:
        return HTC_YES;
    case htmlComponentOutside:
        return HTC_NO;
    case htmlComponentSbLeft:
    case htmlComponentSbPageLeft:
    case htmlComponentSbHThumb:
    case htmlComponentSbPageRight:
    case htmlComponentSbRight:
    case htmlComponentSbLeft2:
    case htmlComponentSbPageLeft2:
    case htmlComponentSbRight2:
    case htmlComponentSbPageRight2:
    case htmlComponentSbUp2:
    case htmlComponentSbPageUp2:
    case htmlComponentSbDown2:
    case htmlComponentSbPageDown2:
        return HTC_HSCROLLBAR;
    case htmlComponentSbUp:
    case htmlComponentSbPageUp:
    case htmlComponentSbVThumb:
    case htmlComponentSbPageDown:
    case htmlComponentSbDown:
    case htmlComponentSbTop:
    case htmlComponentSbBottom:
        return HTC_VSCROLLBAR;
    case htmlComponentGHTopLeft:
        return HTC_TOPLEFTHANDLE;
    case htmlComponentGHLeft:
        return HTC_LEFTHANDLE;
    case htmlComponentGHTop:
        return HTC_TOPHANDLE;
    case htmlComponentGHBottomLeft:
        return HTC_BOTTOMLEFTHANDLE;
    case htmlComponentGHTopRight:
        return HTC_TOPRIGHTHANDLE;
    case htmlComponentGHBottom:
        return HTC_BOTTOMHANDLE;
    case htmlComponentGHRight:
        return HTC_RIGHTHANDLE;
    case htmlComponentGHBottomRight:
        return HTC_BOTTOMRIGHTHANDLE;
    }

    return HTC_YES;
}


//+-------------------------------------------------------------------------------
//
//  Member:     componentFromPoint
//
//  Synopsis:   Base Implementation of the automation interface IHTMLELEMENT2 method.
//              This method returns none, meaning no component is hit, and is here
//              for future expansion when the component list includes borders and
//              margins and such.
//              Currently, only scrollbar components are implemented, so there is an
//              overriding implementation in CLayout which handles the hit testing
//              against the scrollbar, and determines which component is hit.
//
//+-------------------------------------------------------------------------------
STDMETHODIMP
CElement::componentFromPoint( long x, long y, BSTR * pbstrComponent)
{
    HRESULT         hr              = S_OK;
    WORD            eComp           = htmlComponentOutside;
    CTreeNode *     pNodeElement    = NULL;
    HTC             htc;
    CMessage        msg;
    CElement *      pRoot;

    x = g_uiDisplay.DeviceFromDocPixelsX(x);
    y = g_uiDisplay.DeviceFromDocPixelsY(y);

    msg.pt.x = x;
    msg.pt.y = y;
    msg.lBehaviorPartID = 0;

    if (!pbstrComponent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (!IsInViewTree())
        goto Cleanup;

    pRoot = GetMarkup()->Root();
    // If this isn't the primary document, transform to the global coordinate system.
    if (pRoot->HasMasterPtr())
    {
        CLayout *   pLayout;
        CElement *  pElemMaster = pRoot->GetMasterPtr();

        if (S_OK != pElemMaster->EnsureRecalcNotify())
            goto Cleanup;

        pLayout = pElemMaster->GetUpdatedLayout();
        Assert(pLayout);

        pLayout->TransformPoint(&msg.pt, COORDSYS_SCROLL, COORDSYS_GLOBAL);
    }

    //
    // Thinking of making changes ? Pls regress against bugs
    // 101383 & 98334
    //
    // Bear in mind that the hit test has to go to the peer
    // if there's a peer attached or you will break access
    // 

    // find what element we are hitting
    htc = Doc()->HitTestPoint(&msg, &pNodeElement, HT_VIRTUALHITTEST);

    if (htc == HTC_BEHAVIOR)
    {
        CPeerHolder *pPH = pNodeElement->Element()->FindPeerHolder(msg.lBehaviorCookie);
        if (pPH)
        {
            hr = pPH->StringFromPartID(msg.lBehaviorPartID, pbstrComponent);
            if (hr != S_FALSE)
                goto Cleanup;
        }
    }
    
    if (ShouldHaveLayout())
    {
        eComp = GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->ComponentFromPoint(msg.pt.x, msg.pt.y);
    }
    else 
    {         
        eComp = ComponentFromHTC(htc);

        if (this != pNodeElement->Element())
        {
            eComp = htmlComponentOutside;
        }
        else
        {
            Assert(eComp == htmlComponentClient);
        }
    }
    hr = THR( STRINGFROMENUM( htmlComponent, eComp, pbstrComponent));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+-------------------------------------------------------------------------------
//
//  Member:     doScroll
//
//  Synopsis:   Implementation of the automation interface method.
//              this simulates a click on the particular component of the scrollbar
//              (if this txtsite has one)
//
//+-------------------------------------------------------------------------------
STDMETHODIMP
CElement::doScroll( VARIANT varComponent)
{
    HRESULT       hr;
    htmlComponent eComp;
    int           iDir;
    WORD          wComp;
    CVariant      varCompStr;
    CDoc *        pDoc = Doc();
    CLayout *     pLayout;
    BOOL          fVert = HasVerticalLayoutFlow();
    
    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

    //
    // don't scroll if we are still loading the page or not UIActive
    if (pDoc->IsLoading() || pDoc->State() < OS_INPLACE)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    //
    // the paramter is optional, and if nothing was provide then use the default
    hr = THR(varCompStr.CoerceVariantArg(&varComponent, VT_BSTR));
    if ( hr == S_OK )
    {
        if (!SysStringLen(V_BSTR(&varCompStr)))
            eComp = htmlComponentSbPageDown;
        else
        {
            hr = THR( ENUMFROMSTRING( htmlComponent,
                                  V_BSTR(&varCompStr),
                                  (long *) &eComp) );
            if (hr)
                goto Cleanup;
        }
    }
    else if ( hr == S_FALSE )
    {
        // when no argument
        eComp = htmlComponentSbPageDown;
        hr = S_OK;
    }
    else
        goto Cleanup;


    // no that we know what we are doing, initialize the parametes for
    // the onscroll helper fx
    switch (eComp) {
    case htmlComponentSbLeft :
    case htmlComponentSbLeft2:
        iDir = 0;
        wComp = !fVert ? SB_LINELEFT : SB_LINEDOWN;
        break;
    case htmlComponentSbPageLeft :
    case htmlComponentSbPageLeft2:
        iDir = 0;
        wComp = !fVert ? SB_PAGELEFT : SB_PAGEDOWN;
        break;
    case htmlComponentSbPageRight :
    case htmlComponentSbPageRight2:
        iDir = 0;
        wComp = !fVert ? SB_PAGERIGHT : SB_PAGEUP;
        break;
    case htmlComponentSbRight :
    case htmlComponentSbRight2:
        iDir = 0;
        wComp = !fVert ? SB_LINERIGHT : SB_LINEUP;
        break;
    case htmlComponentSbUp :
    case htmlComponentSbUp2:
        // equivalent to up arrow
        iDir = 1;
        wComp = !fVert ? SB_LINEUP : SB_LINELEFT;
        break;
    case htmlComponentSbPageUp :
    case htmlComponentSbPageUp2:
        iDir = 1;
        wComp = !fVert ? SB_PAGEUP : SB_PAGELEFT;
        break;
    case htmlComponentSbPageDown :
    case htmlComponentSbPageDown2:
        iDir = 1;
        wComp = !fVert ? SB_PAGEDOWN : SB_PAGERIGHT;
        break;
    case htmlComponentSbDown :
    case htmlComponentSbDown2:
        iDir = 1;
        wComp = !fVert ? SB_LINEDOWN: SB_LINERIGHT;
        break;
    case htmlComponentSbTop:
        iDir = 1;
        wComp = SB_TOP;
        break;
    case htmlComponentSbBottom:
        iDir = 1;
        wComp = SB_BOTTOM;
        break;
    default:
        // nothing to do in this case.  hr is S_OK
        goto Cleanup;

    }

    if (fVert)
    {
        iDir = iDir == 0 ? 1 : 0;
    }
    
    //  Send the request to the layout, if any
    if (pLayout)
    {
        hr = THR(pLayout->OnScroll(iDir, wComp, 0));
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_onpropertychange
//
//  Synopsis:   Fires the onpropertychange event, sets up the event param
//
//+----------------------------------------------------------------------------

void
CElement::Fire_onpropertychange(LPCTSTR strPropName)
{
    CDoc *pDoc = Doc();
    EVENTPARAM param(pDoc, this, NULL, TRUE);

    param.SetType(s_propdescCElementonpropertychange.a.pstrName + 2);
    param.SetPropName(strPropName);
    param.SetNodeAndCalcCoordinates(GetFirstBranch());

    FireEvent(&s_propdescCElementonpropertychange, FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_PropertyChangeHelper
//
//  Synopsis:   Fires the onpropertychange event, sets up the event param
//
//+----------------------------------------------------------------------------
HRESULT
CElement::Fire_PropertyChangeHelper(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT       hr = S_OK;
    BSTR          bstrName = NULL;
    DISPID        expDispid;
    PROPERTYDESC  *pPropDesc = (PROPERTYDESC *)ppropdesc;
    LPCTSTR       pchName = NULL;
    CBufferedStr  cBuf;

    Assert(!ppropdesc || ppropdesc->GetDispid() == dispid);
    //Assert(!ppropdesc || ppropdesc->GetdwFlags() == dwFlags);

    // first, find the appropriate propdesc for this property.
    // NOTE: If you change the "if" conditions, make sure you confirm
    // that the deferred event firing code below works!
    if (dwFlags & ELEMCHNG_INLINESTYLE_PROPERTY)
    {
        CBase *pStyleObj = GetInLineStylePtr();

        if (pStyleObj)
        {

            cBuf.Set( (dwFlags & ELEMCHNG_INLINESTYLE_PROPERTY) ? 
                _T("style.") : 
                _T("runtimeStyle."));
            // if we still can't find it, or have no inline
            // then bag this, and continue
            if (!pPropDesc)
            {
                hr = THR(pStyleObj->FindPropDescFromDispID(dispid, &pPropDesc, NULL, NULL));
            }
            if (S_OK == hr)
            {

                cBuf.QuickAppend((pPropDesc->pstrExposedName)?
                                    pPropDesc->pstrExposedName :
                                    pPropDesc->pstrName);
                pchName = LPTSTR(cBuf);
            }
            else if (IsExpandoDISPID(dispid, &expDispid))
            {
                LPCTSTR pszName;
                if (S_OK == pStyleObj->GetExpandoName(expDispid, &pszName))
                {
                    cBuf.QuickAppend(pszName);
                    pchName = LPTSTR(cBuf);
                }
            }
        }
    }
    else
    {
        HRESULT     hr2;

        if( !ppropdesc )
        {
            hr2 = THR_NOTRACE(GetMemberName(dispid, &bstrName));
            if(hr2)
            {
                bstrName = NULL;
            }
            else
            {
                pchName = bstrName;
            }
        }
        else
        {
            pchName = ppropdesc->pstrExposedName ?
                        ppropdesc->pstrExposedName :
                        ppropdesc->pstrName;
        }
    }

    // we have a property name, and can fire the event
    if(pchName)
    {
        // If the element is currently being sized, we don't want to fire the event synchronously,
        // because script for the event might cause us to do things that are only possible when we
        // aren't being sized (pasting text etc).  In that case, defer the event firing until the
        // next EnsureView. (Bug #101803)
        if (   TestLock(CElement::ELEMENTLOCK_SIZING)
            && !(dwFlags & ELEMCHNG_INLINESTYLE_PROPERTY)) // TODO: Ditch this condition; requires reworking event queues to clean up data inside 'em
        {
            // don't want to pass a strName (then we need to manage its lifetime),
            // so we use the dispid.  See CView::ExecuteEventTasks().
            Doc()->GetView()->AddEventTask(this, DISPID_EVMETH_ONPROPERTYCHANGE, dispid );
        }
        else
        {
            Fire_onpropertychange(pchName);
        }

        SysFreeString(bstrName);
    }

    return S_OK;
}




CDragStartInfo::CDragStartInfo(CElement *pElementDrag, DWORD dwStateKey, IUniformResourceLocator * pUrlToDrag)
{
    _pElementDrag = pElementDrag;
    _pElementDrag->SubAddRef();
    _dwStateKey = dwStateKey;
    _pUrlToDrag = pUrlToDrag;
    if (_pUrlToDrag)
        _pUrlToDrag->AddRef();
    _dwEffectAllowed = DROPEFFECT_UNINITIALIZED;
}

CDragStartInfo::~CDragStartInfo()
{
    _pElementDrag->SubRelease();
    ReleaseInterface(_pUrlToDrag);
    ReleaseInterface(_pDataObj);
    ReleaseInterface(_pDropSource);
}

HRESULT
CDragStartInfo::CreateDataObj()
{
    CLayout * pLayout = _pElementDrag->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);

    RRETURN(pLayout ? pLayout->DoDrag(_dwStateKey, _pUrlToDrag, TRUE) : E_FAIL);
}

HRESULT
CElement::dragDrop(VARIANT_BOOL *pfRet)
{
    HRESULT hr = S_OK;
    BOOL fRet;
    CTreeNode* pNode;
    CLayout *pLayout ;
    CDoc *pDoc = Doc();
    CElement* pElemCurrentReally;
    
    if (pDoc->_pElemCurrent)
    {
        if ( pDoc->_pElemCurrent->_etag == ETAG_FRAMESET )
        {
            pElemCurrentReally = GetFlowLayoutElement();
        }
        else
            pElemCurrentReally = pDoc->_pElemCurrent;
            
        pNode = pElemCurrentReally->GetFirstBranch();
        if (!pNode)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // call GetUpdated to ensure we have a layout.
        //
        pElemCurrentReally->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        
        pLayout = pNode->GetFlowLayout();
    }
    else
    {
        pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
    }     
    
    if (!pLayout)
    {
        hr = E_FAIL;
        AssertSz(0,"No layout to drag with");
        goto Cleanup;
    }

    fRet = DragElement(pLayout, 0, NULL, -1, TRUE /*fCheckSelection*/ );

    if (pfRet)
        *pfRet = fRet ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::DragElement
//
//  Synopsis:   calls Fire_ondragstart then executes DoDrag on the
//              layout
//
//-----------------------------------------------------------------------------
BOOL
CElement::DragElement(CLayout *                 pLayout,
                      DWORD                     dwStateKey,
                      IUniformResourceLocator * pUrlToDrag,
                      long                      lSubDivision,
                      BOOL                      fCheckSelection /*=FALSE*/ )
{
    BOOL fRet = FALSE;
    CDoc * pDoc = Doc();
    CTreeNode::CLock  Lock;

    // Layouts are detached and released when their elementOwner leaves the tree. because
    // drag/drop can cause this to happen, we need to be careful that pLayout doesn't release
    // out from under us. 
    if (pLayout)
        pLayout->AddRef();

    if( Lock.Init(GetFirstBranch()) )
    {
        Assert( !fRet );
        goto Cleanup;
    }

    if (IsUnselectable())
        goto Cleanup;

    Assert(!pDoc->_pDragStartInfo);
    pDoc->_pDragStartInfo = new CDragStartInfo(this, dwStateKey, pUrlToDrag);

    if (!pDoc->_pDragStartInfo)
        goto Cleanup;

    fRet = Fire_ondragstart(NULL, lSubDivision);

    if (!GetFirstBranch())
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (fRet)
    {
        Assert(pLayout->ElementOwner()->IsInMarkup());
        IGNORE_HR(pLayout->DoDrag(dwStateKey, pUrlToDrag, FALSE, & fRet, fCheckSelection) );
    }

Cleanup:
    if (pLayout)
        pLayout->Release();

    if (pDoc->_pDragStartInfo)
    {
        delete pDoc->_pDragStartInfo;
        pDoc->_pDragStartInfo = NULL;
    }
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_ondragenterover
//
//  Synopsis:   Fires the ondragenter or ondragover event, sets up the event param
//              and returns the dropeffect
//
//+----------------------------------------------------------------------------

BOOL
CElement::Fire_ondragHelper(
    long lSubDivision,
    const PROPERTYDESC_BASIC *pDesc,
    DWORD * pdwDropEffect)
{
    EVENTPARAM param(Doc(), this, NULL, TRUE);
    BOOL fRet;
    CTreeNode *pNodeContext = GetFirstBranch();

    Assert(pdwDropEffect);

    param.dwDropEffect = *pdwDropEffect;

    param.SetNodeAndCalcCoordinates(pNodeContext);
    param.SetType(pDesc->a.pstrName + 2);

    fRet = !!FireEvent(
            pDesc,
            FALSE,
            pNodeContext,
            lSubDivision);

    if (!fRet)
        *pdwDropEffect = param.dwDropEffect;

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_ondragend
//
//  Synopsis:   Fires the ondragend event
//
//+----------------------------------------------------------------------------
void
CElement::Fire_ondragend(long lSubDivision, DWORD dwDropEffect)
{
    EVENTPARAM param(Doc(), this, NULL, TRUE);
    CTreeNode *pNodeContext = GetFirstBranch();

    param.dwDropEffect = dwDropEffect;

    param.SetNodeAndCalcCoordinates(pNodeContext);
    param.SetType(s_propdescCElementondragend.a.pstrName + 2);

    FireEvent(
        &s_propdescCElementondragend,
        FALSE,
        pNodeContext,
        lSubDivision);
}

//+-----------------------------------------------------------------
//
//  member : CElement::getBoundingClientRect() - External method
//
//  Synopsis:   Returns Bounding rect of the text under element's
//              influence in client coordinates
//------------------------------------------------------------------

HRESULT
CElement::getBoundingClientRect(IHTMLRect **ppIRect)
{
    HRESULT             hr = S_OK;
    CRect               Rect;
    COMRect           * pOMRect = NULL;
    POINT               ptOrg;

    if (!ppIRect)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppIRect = NULL;

    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    hr = THR(GetBoundingRect(&Rect, RFE_SCREENCOORD));
    if (hr)
        goto Cleanup;

    GetClientOrigin(&ptOrg);
    Rect.OffsetRect(-ptOrg.x, -ptOrg.y);

    g_uiDisplay.DocPixelsFromDevice(Rect, Rect);

    // Create the rectangle object
    pOMRect = new COMRect(&Rect);
    if (!pOMRect)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Return  rectangle
    *ppIRect = (IHTMLRect *) pOMRect;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-----------------------------------------------------------------
//
//  member : CElement::GetBoundingRect
//
//  Synopsis:   Get the region corresponding to the element
//
//  Arguments:  pRect   - bounding rect of the element
//              dwFlags - flags to control the coordinate system
//                        the rect.
//                        0 - returns the region relative to the
//                            parent content
//                        RFE_SCREENCOORD - window/document/global
//
//------------------------------------------------------------------

HRESULT
CElement::GetBoundingRect(CRect *pRect, DWORD dwFlags)
{
    HRESULT         hr      = S_OK;
    CTreeNode *     pNode   = GetFirstBranch();
    CDataAry<RECT>  aryRects(Mt(CElementGetBoundingRect_aryRects_pv));

    Assert(pRect);
    pRect->SetRectEmpty();

    if (!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    GetElementRegion(&aryRects, pRect, dwFlags);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-----------------------------------------------------------------
//
//  Member :    CElement::GetElementRegion
//
//  Synopsis:   Get the region corresponding to the element
//
//  Arguments:  paryRects - array to hold the rects corresponding to
//                          region
//              dwFlags   - flags to control the coordinate system
//                          the rects are returned in.
//                          0 - returns the region relative to the
//                              parent content
//                          RFE_SCREENCOORD - window/document/global
//
//------------------------------------------------------------------

void
CElement::GetElementRegion(CDataAry<RECT> * paryRects, RECT * prcBound, DWORD dwFlags)
{
    CRect   rect;
    BOOL    fAppendRect = FALSE;

    if(!prcBound)
        prcBound = &rect;

    switch (Tag())
    {
    case ETAG_MAP :
        DYNCAST(CMapElement, this)->GetBoundingRect(prcBound);
        fAppendRect = TRUE;
        break;

    case ETAG_AREA:
        DYNCAST(CAreaElement, this)->GetBoundingRect(prcBound);
        fAppendRect = TRUE;
        break;

    case ETAG_OPTION:
    case ETAG_OPTGROUP:
        *prcBound = g_Zero.rc;
        fAppendRect = TRUE;
        break;

    case ETAG_HTML:
        if (!GetMarkup()->IsHtmlLayout())
        {
            if (GetMarkup()->Root()->HasMasterPtr())
            {
                // We are viewslaved.  Get the size of our master element.
                // (greglett) Will the rect be at the correct position?
                Assert(GetMarkup()->Root()->HasMasterPtr());
                GetMarkup()->Root()->GetMasterPtr()->GetElementRegion(paryRects, prcBound, dwFlags);
            }
            else
            {
                CSize  size;

                // We are the primary HTML element.  As such, we own the view.
                Doc()->GetView()->GetViewSize(&size);
                prcBound->top =
                prcBound->left = 0;
                prcBound->right = size.cx;
                prcBound->bottom = size.cy;
            }

            fAppendRect = TRUE;
            break;
        }

    //  NOTE: Intentional fallthrough for ETAG_HTML, StrictCSS!
    default:
        {
            CLayout * pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);

            if (pLayout)
            {
                // Get the array that contains bounding rects for each line of the text
                // We want to account for aligned content contained within the element
                // when computing the region.
                dwFlags |= RFE_ELEMENT_RECT | RFE_INCLUDE_BORDERS;
                pLayout->RegionFromElement(this, paryRects, prcBound, dwFlags);
            }
        }
        break;
    }

    if(fAppendRect)
    {
        paryRects->AppendIndirect((RECT *)prcBound);
    }
}

//+-----------------------------------------------------------------
//
//  member : CElement::getClientRects() - External method
//
//  Synopsis:   Returns the collection of rectangles for the text under
//               element's influence in client coordinates.
//              Each rectangle represents a line of text on the screen.
//------------------------------------------------------------------

HRESULT
CElement::getClientRects(IHTMLRectCollection **ppIRects)
{
    HRESULT              hr;
    COMRectCollection  * pOMRectCollection;
    CDataAry<RECT>       aryRects(Mt(CElementgetClientRects_aryRects_pv));
    CTreeNode          * pNode;

    if (!ppIRects)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIRects = NULL;

    pNode = GetFirstBranch();
    if(!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // make sure that current will be calced
    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;


    GetElementRegion(&aryRects, NULL, RFE_SCREENCOORD);
    for (int i = 0; i < aryRects.Size(); i++)
    {
        g_uiDisplay.DocPixelsFromDevice(aryRects[i], aryRects[i]);
    }

    // Create a rectangle collection class instance
    pOMRectCollection = new COMRectCollection();
    if (!pOMRectCollection)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Fill the collection with values from aryRects
    hr = THR(pOMRectCollection->SetRects(&aryRects));
    if(hr)
        goto Cleanup;

    // Return  rectangle
    *ppIRects = (IHTMLRectCollection *) pOMRectCollection;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


CDOMChildrenCollection *
CElement::EnsureDOMChildrenCollectionPtr ( )
{
    CDOMChildrenCollection *pDOMPtr = NULL;
    GetPointerAt ( FindAAIndex ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,CAttrValue::AA_Internal ),
        (void **)&pDOMPtr );
    if ( !pDOMPtr )
    {
        pDOMPtr = new CDOMChildrenCollection ( this, TRUE /* fIsElement */ );
        if ( pDOMPtr )
        {
            AddPointer ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,
                (void *)pDOMPtr,
                CAttrValue::AA_Internal );
            }
    }
    else
    {
        pDOMPtr->AddRef();
    }
    return pDOMPtr;
}



#ifndef NO_EDIT
HRESULT
CElement::CreateUndoAttrValueSimpleChange(
    DISPID dispid,
    VARIANT &  vtProp,
    BOOL fInlineStyle,
    CAttrValue::AATYPE aaType )
{
    HRESULT                      hr;
    CUndoAttrValueSimpleChange * pUndo = NULL;

    if (!QueryCreateUndo(TRUE))
        return S_OK;

    TraceTag((tagUndo,
              "CElement::CreateUndoAttrValueSimpleChange creating an object."));

    pUndo = new CUndoAttrValueSimpleChange(this);
    if (!pUndo)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pUndo->Init(dispid, vtProp, fInlineStyle, aaType));
    if (hr)
        goto Cleanup;

    hr = THR(UndoManager()->Add(pUndo));

Cleanup:

    ReleaseInterface(pUndo);

    RRETURN(hr);
}

HRESULT
CElement::CreateUndoPropChangeNotification(
    DISPID dispid,
    DWORD dwFlags,
    BOOL fPlaceHolder )
{
    HRESULT                       hr;
    CUndoPropChangeNotification * pUndo = NULL;

    if (!QueryCreateUndo(TRUE))
        return S_OK;

    TraceTag((tagUndo,
              "CElement::CreateUndoPropChangeNotification creating an object."));

    pUndo = new CUndoPropChangeNotification( this );
    if (!pUndo)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pUndo->Init(dispid, dwFlags, fPlaceHolder));
    if (hr)
        goto Cleanup;

    hr = THR(UndoManager()->Add(pUndo));

Cleanup:

    ReleaseInterface(pUndo);

    RRETURN(hr);
}

#endif // NO_EDIT


//
// Recalc methods
// These methods are tiny stubs that point directly to the recalc host code
//
STDMETHODIMP
CElement::removeExpression(BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    CTreeNode *pNode = GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(Doc()->_recalcHost.removeExpression(this, strPropertyName, pfSuccess)));
}

STDMETHODIMP
CElement::setExpression(BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    if ( IsPrintMedia() )
        return S_OK;
                   
    _fHasExpressions = TRUE;

    CTreeNode *pNode = GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(Doc()->_recalcHost.setExpression(this, strPropertyName, strExpression, strLanguage)));
}

STDMETHODIMP
CElement::getExpression(BSTR strPropertyName, VARIANT *pvExpression)
{
    CTreeNode *pNode = GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(Doc()->_recalcHost.getExpression(this, strPropertyName, pvExpression)));
}

//+---------------------------------------------------------------------
//
// Method: Fire_ondblclick
//
// Synopsis: Fire On Double Click. We construct the _pparam object
//           and push on the doc - in case the pEvtInfo is not null 
//           ( to copy the param for editing)
//
//+---------------------------------------------------------------------

BOOL 
CElement::Fire_ondblclick(CTreeNode * pNodeContext /*= NULL*/, long lSubDivision /*= -1*/, EVENTINFO * pEvtInfo /*=NULL*/)
{
    if (!Doc()->_fCanFireDblClick)
        return FALSE;
        
    return !!FireEvent(&s_propdescCElementondblclick, TRUE, pNodeContext, lSubDivision, pEvtInfo );
}

BOOL 
CElement::Fire_onclick(CTreeNode * pNodeContext /*= NULL*/, long lSubDivision /*= -1*/, EVENTINFO * pEvtInfo /*=NULL*/)
{
    return !!FireEvent(&s_propdescCElementonclick, TRUE, pNodeContext, lSubDivision, pEvtInfo );
}

//+------------------------------------------------------------------------------------------
//
// Member : EnsureRecalcNotify
//
// called when synchronous calls (usually OM) require layout to be up to
// date to return a property.
//
//   Parameter : fForceEnsure - this flag indicates that the View queues should be processed .
//          This is true by default, because all OM GET operations require that the queued 
//          work be done synchronously in order to answer the query appropriately.
//          HOWEVER (!) some callers (e.g. MoveMarkupPointerToPointEx) MAY have the view open
//          because they are actively changing the queues.  In this case we want to 
//          process the view queues if the tree is *closed*, and if the tree is open, the 
//          queues will be processed later when the postcloseview happens.
//
// WARNING (greglett)
//    EnsureRecalcNotify may cause calcs which will propagate contexts down from containers to submarkups.
//    This means that elements in markups that are paginated (LayoutRects) or WYSIWYG (DeviceRects)
//    may throw away their layouts and replace them with layout arrays.
//    This means that any refernces you have to layouts through this call may become invalid.
//    Do not assume any layout pointers you have are still valid (including this pointers!)
//    This is good policy anyway, as need-for-layout status may change due to format computation.
//
//------------------------------------------------------------------------------------------
HRESULT
CElement::EnsureRecalcNotify(BOOL fForceEnsure /* == true */)
{
    CView * pView = Doc()->GetView();
    CMarkup * pMarkup = GetMarkup();

    Assert(pView);

    // if we are blocked for OM calls, fail
    if (pView->IsInState(CView::VS_BLOCKED))
    {
        return E_FAIL;
    }

    // send the notification that work is about to be done
    // (greglett) Oh, the pain.  See warnings on EnsureRecalcNotify.
    //            This prevents us from being in a layout and deleting our this *
    //            This should really be for paginated elements, not PrintMedia elements.
    if (    pMarkup
        &&  !pMarkup->IsPrintMedia() )
    {
        SendNotification(NTYPE_ELEMENT_ENSURERECALC);
    }

    // ensure view will pick up any addition work gets done.
    if (   fForceEnsure
        || !(pView->IsInState(CView::VS_OPEN)))
    {
        pView->EnsureView(LAYOUT_SYNCHRONOUS);
    }
    // else
    // the view is open which means someone is making changes.
    // in this case, we can't necessarily answer correctly, but 
    // the work will be done eventually. 

    return S_OK;
}

CPeerHolder *
CElement::FindPeerHolder(LONG lCookie)
{
    CPeerHolder::CPeerHolderIterator iter;

    for (iter.Start(GetPeerHolder()); !iter.IsEnd(); iter.Step())
    {
        if (iter.PH()->CookieID() == lCookie)
        {
            return iter.PH();
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\element.cxx ===
//+---------------------------------------------------------------------
//
//   File:      element.cxx
//
//  Contents:   Element class
//
//  Classes:    CElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include "cguid.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif


#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"    // for body's dispids
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_OCIDL_H_
#define X_OCIDL_H_
#include <ocidl.h>
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_EXTDL_HXX_
#define X_EXTDL_HXX_
#include "extdl.hxx"
#endif

// Note - The enums in types are defined in this file

#ifndef X_STRING_H_
#define X_STRING_H_
#include "string.h"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_IEXTAG_HXX_
#define X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>       // for CDataMemberMgr
#endif

#ifndef X_ACCHDRS_HXX_
#define X_ACCHDRS_HXX_
#include "acchdrs.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_DXTRANS_H_
#define X_DXTRANS_H_
#include "dxtrans.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_COMMENT_HXX
#define X_COMMENT_HXX
#include "comment.hxx"
#endif

#ifdef UNIX
#include "mainwin.h"
extern "C" HANDLE MwGetPrimarySelectionData();
#include "quxcopy.hxx"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

BEGIN_TEAROFF_TABLE(CElement, IProvideMultipleClassInfo)
    TEAROFF_METHOD(super, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(super, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CElement, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CElement, GetInfoOfIndex, getinfoofindex, (ULONG iti, DWORD dwFlags, ITypeInfo** pptiCoClass, DWORD* pdwTIFlags, ULONG* pcdispidReserved, IID* piidPrimary, IID* piidSource))
END_TEAROFF_TABLE()

MtDefine(Elements, Mem, "Elements")
MtDefine(CElementCLock, Locals, "CElement::CLock")
MtDefine(CElementHitTestPoint_aryRects_pv, Locals, "CElement::HitTestPoint aryRects::_pv")
MtDefine(CElementHitTestPoint_aryElements_pv, Locals, "CElement::HitTestPoint aryElements::_pv")
MtDefine(CElementGetElementRc_aryRects_pv, Locals, "CElement::GetElementRc aryRects::_pv")

MtDefine(CMessage, Locals, "CMessage")

MtDefine(CLayoutAry_aryLE_pv, Layout, "CLayoutAry::_aryLE::_pv")

#define _cxx_
#include "types.hdl"

#define _cxx_
#include "element.hdl"

DeclareTag(tagNotifyZChange,       "Notify: ZChange", "Trace ELEMENT_ZCHANGE notification");
DeclareTagOther(tagFormatTooltips, "Format", "Show format indices with tooltips");
ExternTag(tagDisableLockAR);

ExternTag(tagHtmSrcTest);

class CAnchorElement;

// Each property which has a url image has an associated internal property
// which holds the cookie for the image stored in the cache.

static const struct {
    DISPID propID;          // url image property
    DISPID cacheID;         // internal cookie property
}

// make sure that DeleteImageCtx is modified, if any dispid's
// are added to this array
s_aryImgDispID[] = {
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX },
    { DISPID_A_LISTSTYLEIMAGE,  DISPID_A_LIURLIMGCTXCACHEINDEX },
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE },
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER }
};

extern "C" const IID IID_DataSource;

BEGIN_TEAROFF_TABLE_(CElement, IServiceProvider)
        TEAROFF_METHOD(CElement, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(CElement, IRecalcProperty)
    TEAROFF_METHOD(CElement, GetCanonicalProperty, getcanonicalproperty, (DISPID dispid, IUnknown **ppUnk, DISPID *pdispid))
END_TEAROFF_TABLE()

//  Default property page list for elements that don't have their own.
//  This gives them the allpage by default.

#ifndef NO_PROPERTY_PAGE
const CLSID * const CElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1
    NULL
};
#endif // NO_PROPERTY_PAGE

class CControlledFormatter
{
public:
    CControlledFormatter(CElement *pElement, DISPID dispid, DWORD dwFlags);
    ~CControlledFormatter();
    BOOL Init(HRESULT *phr);

    CLayout *GetUpdatedNearestLayout() const { ok(); return _pNearestLayout; }
    CLayoutInfo *GetUpdatedNearestLayoutInfo() const { ok(); return _pNearestLayoutInfo;}
    BOOL HadLayoutBeforeFormatsChange() const { return _fHadLayoutBeforeFormatsChange; }
    BOOL HasLayoutAfterFormatsChange() const { ok(); return _fHasLayoutAfterFormatsChange; }
    BOOL ShouldComputeFormats() { Assert(_fInited); return _fShouldComputeFormatsForDISPID; }
    
private:
    BOOL ShouldComputeFormatsForDISPID();
    HRESULT SetupToComputeFormats();
    BOOL SendZNotification();
    
#if DBG==1
    VOID ok() const
    {
        AssertSz(_fInited, "Not initialized yet!");
        AssertSz(_fShouldComputeFormatsForDISPID, "Calling compute formats during OPP incorrectly");
    }
#else
    VOID ok() const {}
#endif
    
private:
    CElement  *_pElement;
    CTreeNode *_pNode;
    DISPID     _dispid;
    DWORD      _dwFlags;
    
    WHEN_DBG(BOOL      _fInited;)

    // Following not valid before we call Init
    BOOL         _fHadLayoutBeforeFormatsChange;
    BOOL         _fShouldComputeFormatsForDISPID;
    BOOL         _fHasLayoutAfterFormatsChange;
    CLayoutInfo *_pNearestLayoutInfo;
    CLayout     *_pNearestLayout;
};

typedef void (CALLBACK* NOTIFYWINEVENTPROC)(UINT, HWND, LONG, LONG);
extern NOTIFYWINEVENTPROC g_pfnNotifyWinEvent;
extern CAccBase * GetAccObjOfElement( CElement* pElem );

//+------------------------------------------------------------------------
//
//  Class:     CMessage
//
//-------------------------------------------------------------------------

DWORD
FormsGetKeyState()
{
    static int vk[] =
    {
        VK_LBUTTON,     // MK_LBUTTON = 0x0001
        VK_RBUTTON,     // MK_RBUTTON = 0x0002
        VK_SHIFT,       // MK_SHIFT   = 0x0004
        VK_CONTROL,     // MK_CONTROL = 0x0008
        VK_MBUTTON,     // MK_MBUTTON = 0x0010
        VK_MENU,        // MK_ALT     = 0x0020
    };

    DWORD dwKeyState = 0;

    for (int i = 0; i < ARRAY_SIZE(vk); i++)
    {
        if (GetKeyState(vk[i]) & 0x8000)
        {
            dwKeyState |= (1 << i);
        }
    }

    return dwKeyState;
}

void
CMessage::CommonCtor()
{
    memset(this, 0, sizeof(*this));
    dwKeyState = FormsGetKeyState();
    resultsHitTest._cpHit = -1;
    pLayoutContext = GUL_USEFIRSTLAYOUT;
}

CMessage::CMessage(const MSG * pmsg)
{
    CommonCtor();
    if (pmsg)
    {
        memcpy(this, pmsg, sizeof(MSG));
        htc = HTC_YES;
    }
}


CMessage::CMessage(
    HWND hwndIn,
    UINT msg,
    WPARAM wParamIn,
    LPARAM lParamIn)
{
    CommonCtor();
    hwnd      = hwndIn;
    message   = msg;
    wParam    = wParamIn;
    lParam    = lParamIn;
    htc       = HTC_YES;
    time      = GetMessageTime();
    DWORD  dw = GetMessagePos();
    MSG::pt.x = (short)LOWORD(dw);
    MSG::pt.y = (short)HIWORD(dw);

    Assert(!fEventsFired);
    Assert(!fSelectionHMCalled);
}

CMessage::~CMessage()
{
    // NEWTREE: same subref note here
    Verify( !CTreeNode::ReplacePtr(&pNodeHit, NULL) );
}

//+---------------------------------------------------------------------------
//
// Member : CMessage : SetNodeHit
//
//  Synopsis : things like the tracker cache the message and then access it
//  on a timer callback. inorder to ensure that the elements that are in the
//  message are still there, we need to sub(?) addref the element.
//
//----------------------------------------------------------------------------

HRESULT
CMessage::SetNodeHit( CTreeNode * pNodeHitIn )
{
    // NEWTREE: same subref note here
    RRETURN( CTreeNode::ReplacePtr( &pNodeHit, pNodeHitIn ) );
}

//+-----------------------------------------------------------------------------
//
//  Member : CMessage::SetElementClk
//
//  Synopsis : consolidating the click firing code requires a helper function
//      to set the click element member of the message structure.
//              this function should only be called from handling a mouse buttonup
//      event message which could fire off a click (i.e. LButton only)
//
//------------------------------------------------------------------------------
void
CMessage::SetNodeClk( CTreeNode * pNodeClkIn )
{
    CTreeNode * pNodeDown = NULL;

    Assert(pNodeClkIn && !pNodeClk || pNodeClkIn == pNodeClk);

    // get the element that this message is related to or if there
    // isn't one use the pointer passed in
    pNodeClk = (pNodeHit) ? pNodeHit : pNodeClkIn;

    Assert( pNodeClk );

    // if this is not a LButtonUP just return, using the value
    // set (i.e. we do not need to look for a common ancester)
    if ( message != WM_LBUTTONUP)
    {
        return;
    }

    // now go get the _pEltGotButtonDown from the doc and look for
    // the first common ancester between the two. this is the lowest
    // element that the mouse went down and up over.
    pNodeDown = pNodeClk->Element()->Doc()->_pNodeGotButtonDown;

    if (!pNodeDown)
    {
        // Button down was not on this doc, or cleared due to capture.
        // so this is not a click
        pNodeClk = NULL;
    }
    else
    {
        // Convert both nodes from from slave to master before comparison
        if (pNodeDown->Element()->HasMasterPtr())
        {
            pNodeDown = pNodeDown->Element()->GetMasterPtr()->GetFirstBranch();
        }
        if (pNodeClk->Element()->HasMasterPtr())
        {
            pNodeClk = pNodeClk->Element()->GetMasterPtr()->GetFirstBranch();
        }

        if (!pNodeDown)
            pNodeClk = NULL;
        if (!pNodeClk)
            return;

        if (pNodeDown != pNodeClk)
        {
            if (!pNodeDown->Element()->TestClassFlag(CElement::ELEMENTDESC_NOANCESTORCLICK))
            {
                // The mouse up is on a different element than us.  This
                // can only happen if someone got capture and
                // forwarded the message to us.  Now we find the first
                // common anscestor and fire the click event from
                // there.
                pNodeClk = pNodeDown->GetFirstCommonAncestor(pNodeClk, NULL);
            }
            else
                pNodeClk = NULL;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::CElement
//
//-------------------------------------------------------------------------

CElement::CElement (ELEMENT_TAG etag, CDoc *pDoc)
#if DBG == 1 || defined(DUMPTREE)
    : _nSerialNumber( CTreeNode::s_NextSerialNumber++ )
#endif
{
    _pDoc = pDoc;
    WHEN_DBG( _pDocDbg = pDoc );
    pDoc->SubAddRef();

    Assert( pDoc && pDoc->AreLookasidesClear( this, LOOKASIDE_ELEMENT_NUMBER ) );
    Assert( pDoc->AreLookasides2Clear( this, LOOKASIDE2_ELEMENT_NUMBER ) );

    IncrementObjectCount(&_dwObjCnt);

     _etag = etag;
     WHEN_DBG( _etagDbg = etag );
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::~CElement
//
//-------------------------------------------------------------------------

CElement::~CElement()
{
    // NOTE:  Please cleanup in Passivate() if at all possible.
    //        Thread local storage can be deleted by the time this runs.
    Assert(!IsInMarkup());
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::CLock::CLock
//
//  Synopsis:   Lock resources in CElement object.
//
//-------------------------------------------------------------------------

CElement::CLock::CLock(CElement *pElement, ELEMENTLOCK_FLAG enumLockFlags)
{
    Assert(enumLockFlags < (1 <<(sizeof(_wLockFlags)*8) ));//USHRT_MAX);

#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pElement = pElement;
    if (_pElement)
    {
        _wLockFlags = pElement->_wLockFlags;
        pElement->_wLockFlags |= (WORD) enumLockFlags;
#if DBG==1
        if (!IsTagEnabled(tagDisableLockAR))
#endif
        {
            pElement->PrivateAddRef();
        }
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}


//+------------------------------------------------------------------------
//
//  Member:     CElement::CLock::~CLock
//
//  Synopsis:   Unlock resources in CElement object.
//
//-------------------------------------------------------------------------

CElement::CLock::~CLock()
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    if (_pElement)
    {
        _pElement->_wLockFlags = _wLockFlags;
#if DBG==1
        if (!IsTagEnabled(tagDisableLockAR))
#endif
        {
            _pElement->PrivateRelease();
        }
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}

//+------------------------------------------------------------------------
//
//  Member:     Passivate
//
//-------------------------------------------------------------------------

void
CElement::Passivate()
{
    CDoc * pDoc = Doc();

    // If we are in a tree, the tree will keep us alive
    Assert(!IsInMarkup());

    // Make sure we aren't on some delay release list somewhere
    Assert(!_fDelayRelease);

    // If we are passivating the current element (can only be the root), set it to NULL
    if (this == pDoc->_pElemCurrent)
    {
        Assert(Tag() == ETAG_ROOT);   // needed because ROOT doesn't get ExitTree
        pDoc->_pElemCurrent = NULL;
    }

    // Make sure we don't have any pending event tasks on the view
    if (_fHasPendingEvent)
    {
        pDoc->GetView()->RemoveEventTasks(this);
    }

    Assert(!HasMasterPtr());

    // Destroy slave markup, if any
    if (HasSlavePtr())
    {
        CElement * pElemSlave = DelSlavePtr();

        pElemSlave->DelMasterPtr();
        pElemSlave->Release();
    }

    if (HasPeerHolder())
    {
#if DBG == 1
        if (HasIdentityPeerHolder())
        {
            Assert (GetIdentityPeerHolder()->_ulRefs == 1);
        }
#endif
        // delete peer holder ptr and release the peer holder
        DelPeerHolder()->PrivateRelease();
    }

    if (HasPeerMgr())
    {
        CPeerMgr::EnsureDeletePeerMgr(this, /* fForce = */ TRUE);
    }

    if( HasWindowedMarkupContextPtr() )
    {
        CMarkup *pMakup = DelWindowedMarkupContextPtr();
        if (pMakup)
            pMakup->SubRelease();
    }

#ifndef NO_DATABINDING
    if (HasDataBindPtr())
    {
        DetachDataBindings();
    }
#endif // ndef NO_DATABINDING

    TakeCapture(FALSE);

    GWKillMethodCall (this, NULL, 0);

    if (_fHasImage)
    {
        ReleaseImageCtxts();
    }

    // Release layout engines if any.
    // Usual case is that we have at most one layout (HasLayoutPtr() == TRUE)
    if ( HasLayoutPtr() )
    {
        CLayout * pLayout = DelLayoutPtr();

        pLayout->Detach();
        pLayout->Release();
    }
    // We may have multiple layouts!
    else if ( HasLayoutAry() )
    {
        DelLayoutAry(); // will take care of detaching/releasing its layouts
    }

    //delete the related accessible object if there is one
    if ( HasAccObjPtr() )
    {
        delete DelAccObjPtr();
    }

    if (_fHasPendingFilterTask)
        Doc()->RemoveFilterTask(this);

    if (_fHasPendingRecalcTask)
        Doc()->RemoveExpressionTask(this);

    if (_pAA)
    {
        // clear up the FiltersCollection

        if( _fHasFilterSitePtr )
        {
            GetFilterSitePtr()->Release();
        }

        // Kill the cached style pointer if present.  super::passivate
        // will delete the attribute array holding it.
        if (_pAA->IsStylePtrCachePossible())
        {
            delete GetInLineStylePtr();
            delete GetRuntimeStylePtr();
        }
#if DBG==1
        else
            Assert( !GetInLineStylePtr() && !GetRuntimeStylePtr() );
#endif
    }

    super::Passivate();

    // Ensure Lookaside cleanup.  Go directly to document to avoid bogus flags
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_DATABIND) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_PEER) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_PEERMGR) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_ACCESSIBLE) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_SLAVE) == NULL);
    Assert(Doc()->GetLookasidePtr2((DWORD *) this + LOOKASIDE2_MASTER) == NULL);
    Assert(Doc()->GetLookasidePtr2((DWORD *) this + LOOKASIDE2_WINDOWEDMARKUP) == NULL);

    pDoc->SubRelease();

    DecrementObjectCount(&_dwObjCnt);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF((CBase *)this, ISpecifyPropertyPages, NULL)
        QI_TEAROFF((CBase *)this, IPerPropertyBrowsing, NULL)
        QI_TEAROFF(this, ISupportErrorInfo, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement3, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement4, NULL)
        QI_TEAROFF(this, IHTMLUniqueName, NULL);
        QI_TEAROFF(this, IHTMLDOMNode, NULL);
        QI_TEAROFF(this, IHTMLDOMNode2, NULL)
        QI_TEAROFF(this, IHTMLElementRender, NULL);
        QI_TEAROFF(this, IObjectIdentity, NULL);
        QI_TEAROFF(this, IServiceProvider, NULL);
        QI_TEAROFF(this, IRecalcProperty, NULL);
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) =
                    new CConnectionPointContainer(this, NULL);

            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);

            SetEventsShouldFire();
            break;
        }
#ifndef NO_DATABINDING
        QI_CASE(IHTMLDatabinding)
        {
            if (GetDBindMethods() == NULL)
                RRETURN(E_NOINTERFACE);

            hr = THR(CreateTearOffThunk(this, s_apfnIHTMLDatabinding, NULL, ppv));
            if (hr)
                RRETURN(hr);
            break;
        }
#endif // ndef NO_DATABINDING

        default:
        {
            const CLASSDESC *pclassdesc = ElementDesc();

            if (iid == CLSID_CElement)
            {
                *ppv = this;    // Weak ref
                return S_OK;
            }
            
            // If QI for IMarshal do not delegate to the behavior
            // because Trident does not support free-threaded calls in the case 
            // where the behavior supports custom marshaling
            if (iid == IID_IMarshal)
            {
                hr = E_NOINTERFACE;
                RRETURN (hr);
            }

            // Primary default interface, or the non dual
            // dispinterface return the same object -- the primary interface
            // tearoff.
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface ||
                 DispNonDualDIID(iid)))
            {
#ifndef WIN16
                hr = THR(CreateTearOffThunk(this, pclassdesc->_apfnTearOff, NULL, ppv, (void *)pclassdesc->_classdescBase._apHdlDesc->ppVtblPropDescs));
#else
                BYTE *pThis = ((BYTE *) (void *) ((CBase *) this)) - m_baseOffset;
                hr = THR(CreateTearOffThunk(pThis, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
#endif
                if (hr)
                    RRETURN(hr);

                break;
            }

            if (HasIdentityPeerHolder())
            {
                CPeerHolder *   pPeerHolder = GetIdentityPeerHolder();
                IUnknown *      pUnk;

                //
                // delegate to identity behavior;
                // thunk the interface pointers to element identity -
                // use element's IUnknown for subsequent QIs
                //
                hr = THR_NOTRACE(pPeerHolder->QueryPeerInterface(iid, (void**)&pUnk));
                if (S_OK == hr)
                {
                    hr = THR(::CreateTearOffThunk(
                        pUnk,
                        *(void **)pUnk,
                        NULL,
                        ppv,
                        (IPrivateUnknown*)this,
                        *(void **)(IPrivateUnknown*)this,
                        QI_MASK,
                        NULL));
                    ReleaseInterface(pUnk);
                }

                break;
            }

            hr = E_NOINTERFACE;
            RRETURN (hr);
            break;
        }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    DbgTrackItf(iid, "CElement", FALSE, ppv);

    return S_OK;
}


#if DBG == 1
BOOL        g_fDisableMarkupTrace;
CMarkup *   g_pMarkupTrace;
int         g_nSNMarkupTrace;
#endif

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateAddRef, IUnknown
//
//  Synopsis:   Private unknown AddRef.
//
//-------------------------------------------------------------------------
ULONG
CElement::PrivateAddRef()
{
    if( _ulRefs == 1 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        GetMarkupPtr()->AddRef();

#if DBG==1
        if (g_pMarkupTrace && !g_fDisableMarkupTrace &&
            (g_nSNMarkupTrace == 0 || g_nSNMarkupTrace == SN()) &&
            g_pMarkupTrace == GetMarkupPtr())
        {
            TraceTag((0, "markup %x AR from %ls %d", g_pMarkupTrace, TagName(), SN()));
            TraceCallers(0, 0, 12);
        }
#endif

    }

    return super::PrivateAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateRelease, IUnknown
//
//  Synopsis:   Private unknown Release.
//
//-------------------------------------------------------------------------
ULONG
CElement::PrivateRelease()
{
    CMarkup * pMarkup = NULL;

    if( _ulRefs == 2 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        pMarkup = GetMarkupPtr();

#if DBG==1
        if (g_pMarkupTrace && !g_fDisableMarkupTrace &&
            (g_nSNMarkupTrace == 0 || g_nSNMarkupTrace == SN()) &&
            g_pMarkupTrace == pMarkup)
        {
            TraceTag((0, "markup %x Rel from  %ls %d", g_pMarkupTrace, TagName(), SN()));
            TraceCallers(0, 0, 12);
        }
#endif

    }

    ULONG ret =  super::PrivateRelease();

    if( pMarkup )
    {
        pMarkup->Release();
    }

    return ret;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateEnterTree
//
//  Synopsis:   Ref counting fixup as tree entered.
//
//-------------------------------------------------------------------------
void
CElement::PrivateEnterTree()
{
    Assert( IsInMarkup() );
    super::PrivateAddRef();
    GetMarkupPtr()->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateExitTree
//
//  Synopsis:   Ref counting fixup as tree exited.
//
//-------------------------------------------------------------------------
void
CElement::PrivateExitTree( CMarkup * pMarkupOld)
{
    BOOL fReleaseMarkup = _ulRefs > 1;

    Assert( ! IsInMarkup() );
    Assert( pMarkupOld );

    // If we sent the EXITTREE_PASSIVATEPENDING bit then we
    // must also passivate right here.
    AssertSz( !_fPassivatePending || _ulRefs == 1, 
        "EXITTREE_PASSIVATEPENDING set and element did not passivate.  Talk to JBeda." );

    super::PrivateRelease();

    if ( fReleaseMarkup )
    {
        pMarkupOld->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     contains
//
//  Synopsis:   IHTMLElement method. returns a boolean  if PIelement is within
//              the scope of this
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::contains(IHTMLElement * pIElement, VARIANT_BOOL *pfResult)
{
    CTreeNode     *pNode = NULL;
    HRESULT hr = S_OK;

    Assert ( pfResult );

    if ( !pfResult )
        goto Cleanup;

    *pfResult = VB_FALSE;
    if ( !pIElement )
        goto Cleanup;

    // get a CTreeNode pointer
    hr = THR(pIElement->QueryInterface(CLSID_CTreeNode, (void **)&pNode) );
    if ( hr == E_NOINTERFACE )
    {
        CElement *pElement;
        hr = THR(pIElement->QueryInterface(CLSID_CElement, (void **)&pElement) );
        if( hr )
            goto Cleanup;

        pNode = pElement->GetFirstBranch();
    }
    else if( hr )
        goto Cleanup;

    while (pNode &&
           DifferentScope(pNode, this))
    {
        // stop after the HTML tag
        if (pNode->Tag() == ETAG_ROOT)
            pNode = NULL;
        else
            pNode = pNode->Parent();
    }

    if ( pNode )
        *pfResult = VB_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::ClearRunCaches(DWORD dwFlags)
{
    CMarkup * pMarkup = GetMarkup();

    if (pMarkup)
    {
        pMarkup->ClearRunCaches(dwFlags, this);
    }

    RRETURN(S_OK);
}

BOOL
CElement::IsFormatCacheValid()
{
    CTreeNode * pNode;
    
    pNode = GetFirstBranch();
    while (pNode)
    {
        if (!pNode->IsFancyFormatValid() ||
            !pNode->IsCharFormatValid() ||
            !pNode->IsParaFormatValid())
            return FALSE;
        pNode = pNode->NextBranch();
    }

    return TRUE;
}


HRESULT
CElement::EnsureFormatCacheChange ( DWORD dwFlags)
{
    HRESULT hr = S_OK;

    //
    // If we're not in the tree, it really isn't
    // very safe to do what we do.  Since putting
    // the element in the tree will call us again,
    // simply returning should be safe
    //
    if (GetFirstBranch() == 0)
        goto Cleanup;

    if ( dwFlags & (ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF) )
    {
        hr = THR(ClearRunCaches(dwFlags));
        if(hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CElement::FireAccessibilityEvents(DISPID dispidEvent)
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();

    if (pDoc)
    {
        // fire accesibility state change event.
        hr = THR(pDoc->FireAccessibilityEvents( dispidEvent, (CBase *)this, FALSE));
    }

    RRETURN(hr);
}

DeclareTag(tagPropChange, "Property changes", "OnPropertyChange");

//+------------------------------------------------------------------------
//
//  Member:     CElement::OnPropertyChange
//
//
//-------------------------------------------------------------------------

HRESULT
CElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT             hr = S_OK;
    CControlledFormatter cfo(this, dispid, dwFlags);
    BOOL                fYieldCurrency = FALSE;
    CTreeNode *         pNode = GetFirstBranch();
    CDoc *              pDoc = Doc();
    CCollectionCache *  pCollectionCache;
    CElement *          pElemCurrent = pDoc->_pElemCurrent;
    
    Assert( !ppropdesc || ppropdesc->GetDispid() == dispid );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );


    TraceTag((tagPropChange, "Property changed, flags:%ld", dwFlags));

    // if this is an event property that has just been hooked up then we need to 
    // start firing events for this element. we want to do this event if this 
    // element is not yet in the tree (i.e. no pNode) so that when it IS put into
    // the tree we can fire events.
    //
    // NOTE: a good alternative implementation is to have this flag on the AttrArray.
    // then with dword stored, we could have event level granularity and control.
    // to support this all we need to do is change the implementation fo SetEventsShouldFire()
    // and ShouldEventsFire() to use the AA.
    if (dispid >= DISPID_EVENTS && dispid < DISPID_EVENTS + DISPID_EVPROPS_COUNT)
    {
        SetEventsShouldFire();

        // don't expose this to the outside.
        if ( dispid == DISPID_EVPROP_ONATTACHEVENT)
            goto Cleanup;
    }

    if (DISPID_A_BEHAVIOR == dispid || DISPID_CElement_className == dispid || DISPID_UNKNOWN == dispid)
    {
        if (DISPID_A_BEHAVIOR == dispid)
        {
            pDoc->SetCssPeersPossible();
        }

        hr = THR(ProcessPeerTask(PEERTASK_RECOMPUTEBEHAVIORS));
        if (hr)
            goto Cleanup;
    }

    // NOTE (alexz) a lot of stuff below this check is supposed to work when the element is not in a markup
    if(!IsInMarkup() || !pNode)
        goto Cleanup;

    Verify(OpenView());

    // some changes invalidate collections
    if ( dwFlags & ELEMCHNG_UPDATECOLLECTION )
    {
        // TODO rgardner, for now Inval all the collections, whether they are filtered on property values
        // or not. We should tweak the PDL code to indicate which collections should be invaled, or do
        // this intelligently through some other mechanism, we should tweak this
        // when we remove the all collection.
        Assert(IsInMarkup());

        pCollectionCache = GetMarkup()->CollectionCache();
        if (pCollectionCache)
            pCollectionCache->InvalidateAllSmartCollections();

        // Clear this flag: exclusive or
        dwFlags ^= ELEMCHNG_UPDATECOLLECTION;
    }

    switch(dispid)
    {
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_A_LISTSTYLEIMAGE:
        // Release any dispid's which hold image contexts
        DeleteImageCtx(dispid);
        break;
    }

    if (!cfo.Init(&hr))
        goto Cleanup;
    
    switch (dispid)
    {
    case DISPID_A_CURSOR:
        // Do a lazy cursor update
        pDoc->DeferSetCursor();
        break;
    case DISPID_A_HIDEFOCUS:
        if (this == pDoc->_pElemCurrent)
        {
            //Refresh the focus rect
            pDoc->GetView()->SetFocus(this, pDoc->_lSubCurrent);
        }
        break;
    case DISPID_A_POSITION:
        if (IsInMarkup())
        {
            pCollectionCache = GetMarkup()->CollectionCache();
            if (pCollectionCache)
                pCollectionCache->InvalidateItem(CMarkup::REGION_COLLECTION);

            SendNotification(NTYPE_ZPARENT_CHANGE);
        }
        break;

    case STDPROPID_XOBJ_LEFT:
    case STDPROPID_XOBJ_RIGHT:
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            const CCharFormat  * pCF = pNode->GetCharFormat();
            BOOL fElementVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            if (pFF->IsPositioned())
            {
                //
                // If positioned absolute and width is auto, left & right control the width
                // of the element, so fire a resize instead of reposition.
                // Relatively positioned elements reposition, not resize.
                // Also, We do not resize absolute positioned table cells, so reposition. (bug 77275)
                //
                if(   pFF->IsAbsolute() 
                   && pFF->GetLogicalWidth(fElementVertical, fWritingModeUsed).IsNullOrEnum() 
                   && !IsTablePart())
                {
                    dwFlags |= ELEMCHNG_SIZECHANGED;
                }               
                else
                {
                    RepositionElement();
                }
            }

            if (dispid == STDPROPID_XOBJ_LEFT)
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELLEFT));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSLEFT));
            }
            else
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_PIXELRIGHT));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_POSRIGHT));
            }
        }
        break;

    case STDPROPID_XOBJ_TOP:
    case STDPROPID_XOBJ_BOTTOM:
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            const CCharFormat  * pCF = pNode->GetCharFormat();
            BOOL fElementVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            //
            // if height is auto, and the bottom is not auto then the size
            // of the element if absolute can change based on it's top & bottom.
            // So, fire a resize instead of reposition. If bottom is auto,
            // then the element is sized to content.
            //
            if (    pFF->IsAbsolute()
                &&  pFF->GetLogicalHeight(fElementVertical, fWritingModeUsed).IsNullOrEnum()
                &&  (dispid != STDPROPID_XOBJ_TOP || !pFF->GetLogicalPosition(SIDE_BOTTOM, fElementVertical, fWritingModeUsed).IsNullOrEnum()))
            {
                dwFlags |= ELEMCHNG_SIZECHANGED;
            }
            else if (!pFF->IsPositionStatic())
            {
                RepositionElement();
            }

            if (dispid == STDPROPID_XOBJ_TOP)
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELTOP));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSTOP));
            }
            else
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_PIXELBOTTOM));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_POSBOTTOM));
            }
        }
        break;

    case STDPROPID_XOBJ_WIDTH:
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELWIDTH));
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSWIDTH));
        break;

    case STDPROPID_XOBJ_HEIGHT:
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELHEIGHT));
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSHEIGHT));
        break;

    case DISPID_A_ZINDEX:
        if (!IsPositionStatic())
        {
            ZChangeElement();
        }

        pDoc->FixZOrder();
        break;

    case DISPID_CElement_tabIndex:
        hr = OnTabIndexChange();
        break;
    
    case DISPID_CElement_disabled:
        // if (fHasLayout)
        {
            BOOL        fEnabled    = !GetAAdisabled();
            CElement *  pNewDefault = 0;
            CElement *  pOldDefault = 0;
            CElement *  pSavDefault = 0;

            // we should not be the default button before becoming enabled
            Assert(!(fEnabled && _fDefault));

            if (!_fDefault && fEnabled)
            {
                // this is not the previous default button
                // look for it
                pOldDefault = FindDefaultElem(TRUE);
            }

            if (pDoc->_pElemCurrent == this && !fEnabled)
            {
                // this is the case where the button disables itself
                pOldDefault = this;
            }

            // if this element act like a button
            // becomes disabled or enabled
            // we need to make sure this is recorded in the cached
            // default element of the doc or form
            if (TestClassFlag(CElement::ELEMENTDESC_DEFAULT))
            {
                // try to find a new default
                // set _fDefault to FALSE in order to avoid
                // FindDefaultLayout returning this site again.
                // because FindDefaultLayout will use _fDefault
                _fDefault = FALSE;
                pSavDefault = FindDefaultElem(TRUE, TRUE);
                if (pSavDefault == this || !fEnabled)
                {
                    CFormElement    *pForm = GetParentForm(); 
                    if (pSavDefault)
                    {
                        pSavDefault->_fDefault = TRUE;
                    }
                    if (pForm)
                        pForm->_pElemDefault = pSavDefault;
                    else
                        pDoc->_pElemDefault = pSavDefault;
                }
            }
            if (!pDoc->_pElemCurrent->_fActsLikeButton || _fDefault)
            {
                _fDefault = FALSE;
                pNewDefault = pSavDefault ? pSavDefault : FindDefaultElem(TRUE, TRUE);
            }

            // if this was the default, and now becoming disabled
            _fDefault = FALSE;

            if (pNewDefault != pOldDefault)
            {
                if (pOldDefault)
                {
                    CNotification   nf;

                    nf.AmbientPropChange(pOldDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);

                    // refresh the old button
                    pOldDefault->_fDefault = FALSE;
                    pOldDefault->Notify(&nf);
                    pOldDefault->Invalidate();
                }

                if (pNewDefault)
                {
                    CNotification   nf;

                    Assert(pNewDefault->_fActsLikeButton);
                    nf.AmbientPropChange(pNewDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
                    pNewDefault->_fDefault = TRUE;
                    pNewDefault->Notify(&nf);
                    pNewDefault->Invalidate();
                }
            }
        }
        break;

    case DISPID_A_VISIBILITY:
        {
            //
            //  Notify element and all descendents of the change
            //

            SendNotification(NTYPE_VISIBILITY_CHANGE);

            //
            //  If the element is being hidden, ensure it and any descendent which inherits visibility are the current element
            //  (Do this by, within this routine, pretending that this element is the current element)
            //

            fYieldCurrency = !!pNode->GetCharFormat()->IsVisibilityHidden();

            CTreeNode *pMasterCurrent = pDoc->_pElemCurrent->GetFirstBranch()->GetNodeInMarkup( GetMarkupPtr() );

            if (    fYieldCurrency
                &&  pElemCurrent
                &&  ( pMasterCurrent && pMasterCurrent->SearchBranchToRootForScope(this) )
                &&  pElemCurrent->GetFirstBranch()->GetCharFormat()->IsVisibilityHidden())
            {
                pElemCurrent = this;
            }
        }
        break;

    case DISPID_A_DISPLAY:
        //
        //  If the element is being hidden, ensure it and none of its descendents are the current element
        //  (Do this by, within this routine, pretending that this element is the current element)
        //

        if (pNode->GetCharFormat()->IsDisplayNone())
        {
            fYieldCurrency = TRUE;

            if (pElemCurrent && pElemCurrent->GetFirstBranch()->SearchBranchToRootForScope(this))
            {
                pElemCurrent = this;
            }
        }
#ifdef NEVER
        else
        {
            dwFlags |= ELEMCHNG_REMEASUREALLCONTENTS;
        }
#endif
        break;

    case DISPID_A_ROTATE:
    case DISPID_A_ZOOM:
        // Explicit tranformation forces us to have a layout
        // Change of layoutness will be handled by common code below.
        
        // If layoutness doesn't change, the element doesn't need to
        // be remeasured, but parents need to be resized because of change 
        // in aparent bounds of this element.
        if (   cfo.HasLayoutAfterFormatsChange()
            && cfo.HadLayoutBeforeFormatsChange()
           )
        {
            dwFlags |= ELEMCHNG_REMEASUREINPARENT;
        }
        break;

    case DISPID_A_MARGINTOP:
    case DISPID_A_MARGINLEFT:
    case DISPID_A_MARGINRIGHT:
    case DISPID_A_MARGINBOTTOM:
        // BackCompat: Margins act like padding on the BODY
        // StrictCSS1: Margins act normally.
        if (    (   Tag() == ETAG_FRAMESET
                 || Tag() == ETAG_BODY     )
            &&  !GetMarkup()->IsHtmlLayout() )
        {
            dwFlags |= ELEMCHNG_REMEASURECONTENTS;
            dwFlags &= ~(ELEMCHNG_SIZECHANGED | ELEMCHNG_REMEASUREINPARENT);
        }
        break;
    case DISPID_A_CLIP:
    case DISPID_A_CLIPRECTTOP:
    case DISPID_A_CLIPRECTRIGHT:
    case DISPID_A_CLIPRECTBOTTOM:
    case DISPID_A_CLIPRECTLEFT:
        // NOTE (KTam): If element providing pNearestLayout has multi layouts, we need
        // to figure out how to apply clip rects to all of them.  Fix this later, for now
        // we'll just get the nearest layout.
        if (cfo.HasLayoutAfterFormatsChange())
        {
            CDispNode* pDispNode = cfo.GetUpdatedNearestLayout()->GetElementDispNode(this);
            if (pDispNode)
            {
                if (pDispNode->HasUserClip())
                {
                    CSize size;

                    cfo.GetUpdatedNearestLayout()->GetSize(&size);
                    cfo.GetUpdatedNearestLayout()->SizeDispNodeUserClip(pDoc->GetView()->GetMeasuringDevice(mediaTypeNotSet), size);
                }

                // we need to create a display node that can have user
                // clip information, and ResizeElement will force this
                // node to be created.  Someday, we might be able to morph
                // the existing display node for greater efficiency.
                else
                {
                    ResizeElement();
                }
            }
        }
        break;
    }

    if(cfo.ShouldComputeFormats())
    {
        //
        // Notify the layout of the property change, layout fixes up
        // its display node to handle visibility/background changes.
        //
        if (cfo.HasLayoutAfterFormatsChange())
        {
            cfo.GetUpdatedNearestLayoutInfo()->OnPropertyChange(dispid, dwFlags);
        }
    
        if(     (cfo.HadLayoutBeforeFormatsChange() && !cfo.HasLayoutAfterFormatsChange())
            ||  (!cfo.HadLayoutBeforeFormatsChange() && cfo.HasLayoutAfterFormatsChange()))
        {
            if(this == pDoc->_pElemCurrent)
            {
                cfo.GetUpdatedNearestLayoutInfo()->ElementOwner()->BecomeCurrent(pDoc->_lSubCurrent);
            }

            dwFlags |= ELEMCHNG_REMEASUREINPARENT;
            dwFlags &= ~ELEMCHNG_SIZECHANGED;
        }
    }
    
    if (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED))
    {
        MinMaxElement();
    }

    // TODO (dmitryt, 8/22/00) I need to cleanup this code.
    // 1. Some ELEMCHNG_ bits come from PDL files, like style.pdl, while others are 
    //      calculated here. This should be in one single place - in the code.
    // 2. I need to eliminate "RemeasureElement" and "RemeasureAndResize" 
    //      and "RemeasureInParentContext" and replace them all with "ResizeElement"
    //      There is no difference between them except layered bugs.
    //      RESIZE starts recalc from the element in question and if its size changes as a result
    //      of recalc - then cp range in parent is invalidated. Remeasure starts recalc right 
    //      at the cp range in parent. The only case when we need a remeasure is when 
    //      size of child doesn't change but we need action in parent (to hook the child's 
    //      dispnode, like in case when child is getting display:block back)
    // 3. Invalidate the whole text of element in this combined notification (as in
    //    code below where CharsResize+ResizeElement are called)
    
    if(dispid == DISPID_A_DISPLAY)
    {
        CNotification   nf;
        nf.CharsResize(0, GetElementCch(), pNode);
        GetMarkup()->Notify(nf);

        RemeasureInParentContext();
    }
    else if(dispid == DISPID_A_ZOOM)
    {
        ResizeElement(NFLAGS_FORCE);
    }
    else if (dwFlags & ELEMCHNG_REMEASUREINPARENT)
    {
        //(dmitryt) should be ResizeElement
        RemeasureInParentContext();
    }
    else if (   dwFlags & ELEMCHNG_SIZECHANGED
             || (   (dwFlags & ELEMCHNG_RESIZENONSITESONLY)
                 && !cfo.HasLayoutAfterFormatsChange()
                )
            )
    {
        ResizeElement();
    }

    if (dwFlags & (ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS))
    {
        RemeasureElement( dwFlags & ELEMCHNG_REMEASUREALLCONTENTS
                            ? NFLAGS_FORCE
                            : 0);
    }

    // we need to send the display change notification after sending
    // the RemeasureInParent notification. RemeasureInParent marks the
    // ancestors dirty, therefore any ZParentChange notifications fired
    // from DisplayChange are queued up until the ZParent is calced.
    if (    dispid == DISPID_A_DISPLAY
        ||  dispid == DISPID_CElement_className
        ||  dispid == DISPID_UNKNOWN)
    {
        CNotification   nf;

        nf.DisplayChange(this);

        SendNotification(&nf);
    }


    if (this == pElemCurrent)
    {

        
        if (    !IsEnabled()
            ||  fYieldCurrency)
        {         
            CElement* pElemPrev = pDoc->_pElemCurrent;
            
            IGNORE_HR(pNode->Parent()->Element()->BubbleBecomeCurrent(0));

            if ( pDoc->_pCaret &&               
                 pDoc->_pCaret->IsInsideElement( pElemPrev ) == S_OK )
            {
                pDoc->_pCaret->Hide();
            }                   
        }

        else if (   dispid == DISPID_A_VISIBILITY
                ||  dispid == DISPID_A_DISPLAY)
        {
            pDoc->GetView()->SetFocus(pDoc->_pElemCurrent, pDoc->_lSubCurrent);
        }
    }

    if (!(dwFlags & ELEMCHNG_DONTFIREEVENTS))
    {
    
        // once we start firing events, the pLayout Old is not reliable since script can
        // change the page.


        IGNORE_HR(FireOnChanged(dispid));

        pDoc->OnDataChange();

        // fire the onpropertychange script event, but only if it is possible
        //   that someone is actually listeing. otherwise, don't waste the time.
        //
        if (ShouldFireEvents() && DISPID_UNKNOWN != dispid)
        {
            hr = THR(Fire_PropertyChangeHelper(dispid, dwFlags, ppropdesc));
            if ( hr )
                goto Cleanup;
        }

        // Accessibility state change check and event firing
        if (   (   (    (ppropdesc 
                    && ((dwFlags | ppropdesc->GetdwFlags()) & ELEMCHNG_ACCESSIBILITY) )
                || (dwFlags & ELEMCHNG_ACCESSIBILITY) ))
            && (HasAccObjPtr() || IsSupportedElement(this)))
        {
            hr = THR(FireAccessibilityEvents(NULL));
        }        
    }

    dwFlags &= ~(ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF);

    if ( dispid == DISPID_A_EDITABLE )
    {
        IUnknown* pUnknown = NULL;
        IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
        IGNORE_HR( pDoc->NotifySelection( EDITOR_NOTIFY_EDITABLE_CHANGE, pUnknown ));
        ReleaseInterface( pUnknown );
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     OpenView
//
//  Synopsis:   Open the view associated with the element - That view is the one
//              associated with the CDoc (the only view there is right now!)
//
//  Returns:    TRUE if the view was successfully opened, FALSE if we're in the
//              middle of rendering
//
//-----------------------------------------------------------------------------
BOOL
CElement::OpenView()
{
    // So far there's only 1 view, so just get it from the doc.  Multiple views
    // will obviously change this.

    return Doc()->OpenView();
}


//+----------------------------------------------------------------------------
//
//  Member:     MinMaxElement
//              ResizeElement
//              RemeasureElement
//              RemeasureInParentContext
//              RepositionElement
//              ZChangeElement
//
//  Synopsis:   Notfication send helpers
//
//  Arguments:  grfFlags - NFLAGS_xxxx flags
//
//-----------------------------------------------------------------------------

// NOTE (KTam): There may be an issue here wrt elements with
// multiple layouts sending notifications to layouts which haven't
// been expecting them.  E.g. consider MinMaxElement called on an
// element w/ 2 layouts, one of which is _fMinMaxValid and one which
// isn't.  Currently, because at least one is _fMinMaxValid, the
// notification will be sent, and the generic broadcast mechanism
// in CMarkup::NotifyElement() will send it to all its layouts,
// even the one for which _fMinMaxValid == FALSE (and hence, if it
// were the only layout, would not have gotten this notification).
// The same situation arises with ResizeElement() CMarkup::NotifyElement() will send it to all its layouts,
// even the one for which _fMinMaxValid == FALSE (and hence, if it
// were the only layout, would not have gotten this notification).
// The same situation arises with ResizeElement().  The approach I've
// taken is that it's safer to fire more notifications than fewer,
// and if we discover we can optimize (say, by unifying checking with
// sending for multiple layouts such that "check and send" for
// each layout int he array) later, then we can do so.
void
CElement::MinMaxElement(DWORD grfFlags)
{

    CLayout * pLayout;
    if ( !HasLayoutAry() )
    {
        // Element has at most 1 layout.  GetLayoutPtr() will ret.
        // NULL if it doesn't have a layout (we have never created
        // layouts in this fn, and so don't want to call GetUpdatedLayout)
        // It probably doesn't make sense to create layouts here anyways,
        // because they would get created w/ _fMinMaxValid == FALSE, and
        // hence the notification still wouldn't fire (i.e. the only
        // effect of this fn would be to create a layout, which should
        // not be an intentional sideeffect).

        pLayout = GetLayoutPtr();


        if (    pLayout
            &&  (   pLayout->_fMinMaxValid 
                //  Table row does it on behalf of table cells
                ||  Tag() == ETAG_TR)
            )
        {
            SendNotification(NTYPE_ELEMENT_MINMAX, grfFlags);
        }
    }
    else
    {
        if ( EnsureLayoutAry()->WantsMinMaxNotification() )
            SendNotification(NTYPE_ELEMENT_MINMAX, grfFlags);
    }
}

void
CElement::ResizeElement(DWORD grfFlags)
{
    //
    //  Resize notifications are only fired when:
    //    a) The element does not have a layout (and must always notify its container) or
    //    b) It has a layout, but it's currently "clean" and
    //        The element is not presently being sized by its container
    //

    CLayout * pLayout;
    CLayout * pParentLayout = NULL;
    CElement * pParentElement = NULL;

    if ( !HasLayoutAry() )
    {
        // Element has at most 1 layout.  GetLayoutPtr() will ret.
        // NULL if it doesn't have a layout (we have never created
        // layouts in this fn, and so don't want to call GetUpdatedLayout)
        pLayout = GetLayoutPtr();

        // TODO: IsCalcingSize() tells us whether we are being calc'ed,
        // but not whether our parent is calcing us (since we can be in
        // CalcSize() either due to our parent calling us, or due to
        // a DoLayout() on us).  So in order to meet condition b, we need
        // to check out Parent->IsCalcingSize().

        // THIS CHANGE IS NOT REFLECTED IN CLayoutAry::WantsResizeNotification()
        // since it's not an interesting scenario for IE5.5 RTM.  Revisit for
        // live view templates.

        pParentElement = GetUpdatedParentLayoutElement();
        if ( pParentElement )
            pParentLayout = pParentElement->HasLayoutPtr() ? pParentElement->GetLayoutPtr() : NULL;

        //don't send notification if (pLayout && pParentLayout && pParentLayout->IsCalcingSize())

        if (    !pLayout
            ||  !pParentLayout 
            ||  !pParentLayout->IsCalcingSize())
        {
            SendNotification(NTYPE_ELEMENT_RESIZE, grfFlags);
        }
    }
    else
    {
        if ( EnsureLayoutAry()->WantsResizeNotification() )
            SendNotification(NTYPE_ELEMENT_RESIZE, grfFlags);
    }
}

void
CElement::RemeasureInParentContext(DWORD grfFlags)
{
    SendNotification(NTYPE_ELEMENT_RESIZEANDREMEASURE, grfFlags);
}

void
CElement::RemeasureElement(DWORD grfFlags)
{
    SendNotification(NTYPE_ELEMENT_REMEASURE, grfFlags);
}

void
CElement::RepositionElement(DWORD grfFlags, CPoint *ppt, CLayoutContext *pLayoutContext FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    CNotification   nf;
    Assert(!IsPositionStatic(FCPARAM) || GetFirstBranch()->GetCharFormat(FCPARAM)->_fRelative);

    nf.Initialize(NTYPE_ELEMENT_REPOSITION, this, GetFirstBranch(), NULL, grfFlags);
    if (ppt)
        nf.SetData(*ppt);

    nf.SetLayoutContext(pLayoutContext);

    SendNotification(&nf);
}

void
CElement::ZChangeElement(DWORD grfFlags, CPoint * ppt, CLayoutContext *pLayoutContext FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    // NOTE (KTam): Another way to create this notification is via the generated
    // ElementZChange fn -- currently not in use.
    
    CMarkup *       pMarkup = GetMarkup();
    CNotification   nf;

    Assert(!IsPositionStatic(FCPARAM) || GetFirstBranch()->GetCharFormat(FCPARAM)->_fRelative);
    Assert(pMarkup);

    nf.Initialize(NTYPE_ELEMENT_ZCHANGE, this, GetFirstBranch(), NULL, grfFlags);
    if (ppt)
        nf.SetData(*ppt);

    nf.SetLayoutContext(pLayoutContext);

    TraceTagEx((tagNotifyZChange, TAG_NONAME|TAG_INDENT, "(ZChangeElement: e=0x%x,%s pt(%d,%d)",
                this, TagName(), ppt ? ppt->x : 0, ppt ? ppt->y : 0 ));
    TraceCallers(tagNotifyZChange, 1, 1);

    pMarkup->Notify(nf);

    TraceTagEx((tagNotifyZChange, TAG_NONAME|TAG_OUTDENT, ")ZChangeElement"));
}


//+----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send a notification associated with this element
//
//-----------------------------------------------------------------------------

void
CElement::SendNotification(CNotification *pNF)
{
    CMarkup * pMarkup = GetMarkup();

    if (pMarkup)
    {
        pMarkup->Notify(pNF);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send a notification associated with this element
//
//  Arguments:  ntype    - NTYPE_xxxxx flag
//              grfFlags - NFLAGS_xxxx flags
//
//-----------------------------------------------------------------------------
void
CElement::SendNotification(
    NOTIFYTYPE  ntype,
    DWORD       grfFlags,
    void *      pvData)
{
    CMarkup *   pMarkup = GetMarkup();

    if ( pMarkup )
    {
        CNotification   nf;

        Assert( GetFirstBranch() );

        nf.Initialize(ntype, this, GetFirstBranch(), pvData, grfFlags);

        pMarkup->Notify(nf);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     DirtyLayout
//
//  Synopsis:   Dirty the layout engine associated with an element
//
//-----------------------------------------------------------------------------
void
CElement::DirtyLayout(
    DWORD   grfLayout)
{
    if (ShouldHaveLayout())
    {
        GetUpdatedLayoutInfo()->Dirty( grfLayout );
    }
}

#ifdef WIN16
#pragma code_seg ("ELEMENT_2_TEXT")
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HitTestPoint, public
//
//  Synopsis:   Determines if this element is hit by the given point
//
//  Arguments:  [pt]        -- Point to check against.
//              [ppSite]    -- If there's a hit, the site that was hit.
//              [ppElement] -- If there's a hit, the element that was hit.
//              [dwFlags]   -- HitTest flags.
//
//  Returns:    HTC
//
//  Notes:      Only ever returns a hit if this element is a relatively
//              positioned element.
//
//----------------------------------------------------------------------------

HTC
CElement::HitTestPoint(CMessage*    pMessage,
                       CTreeNode ** ppNodeElement,
                       DWORD        dwFlags)
{
    // TODO (KTam): I suspect we don't even need to get a layout here; the only
    // apparent reason for its retrieval is to get the view.  However, there may
    // be issues with this call creating the layout in question?
    CLayout *   pLayout = GetUpdatedNearestLayout( GUL_USEFIRSTLAYOUT );
    HTC         htc     = HTC_NO;
    CLayoutContext * pLayoutContext = NULL;

    if (pLayout)
    {
        CDispNode * pDispNodeOut = NULL;
        COORDINATE_SYSTEM cs = COORDSYS_GLOBAL;
        CView *     pView        = pLayout->GetView();
        POINT       ptContent;

        if (pView)
        {
            *ppNodeElement = GetFirstBranch();

            htc = pLayout->GetView()->HitTestPoint(
                                                pMessage->pt,
                                                &cs,
                                                this,
                                                dwFlags,
                                                &pMessage->resultsHitTest,
                                                ppNodeElement,
                                                ptContent,
                                                &pDispNodeOut,
                                                &pLayoutContext);
        }
    }

    return htc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetRange
//
//  Synopsis:   Returns the range of char's under this element including the
//              end nodes
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetRange(long * pcpStart, long * pcch)
{
    CTreePos *ptpStart, *ptpEnd;

    Assert(GetFirstBranch());

    GetTreeExtent(&ptpStart, &ptpEnd);

    //
    // The range returned include the WCH_NODE characters for the element
    //
    *pcpStart = ptpStart->GetCp();
    *pcch = ptpEnd->GetCp() - *pcpStart + 1;
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//  Notes:      This default implementation assumes that the element encloses
//              a text range (e.g. anchor, label). Other elements (buttons,
//              body, image, checkbox, radio button, input file, image map
//              area) must override this function to supply the correct shape.
//
//  $$ktam:     Think about what is the desired behaviour for focus shapes in
//              multilayout scenarios; consider an element broken across two
//              containers -- we may need to return a collection of shapes.
//              Right now we just return the shape corresponding to the first
//              layout.
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    HRESULT hr = S_FALSE;

    Assert(ppShape);

    *ppShape = NULL;

    if (GetAAhideFocus())
    {
        hr = S_OK;
        goto Cleanup;
    }

    // First check if the identity behavior wants to supply a focus rect
    if (HasIdentityPeerHolder())
    {
        IElementBehaviorFocus * pIFocus = NULL;

        if (S_OK == GetIdentityPeerHolder()->QueryPeerInterface(
                                            IID_IElementBehaviorFocus,
                                            (void**)&pIFocus))
        {
            RECT rect = g_Zero.rc;

            if (S_OK == pIFocus->GetFocusRect(&rect))
            {
                CRectShape *pShape = new CRectShape;
                if (!pShape)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pShape->_rect = rect;
                    *ppShape = pShape;
                    hr = S_OK;
                }
            }
            ReleaseInterface(pIFocus);
            goto Cleanup;
        }
    }

    // By default, provide focus shape only for 
    // 1) elements that had focus shape in IE4 (compat)
    // 2) elements that have a tab index specified (#40434)
    //
    // In IE6, we will introduce a CSS style that lets elements override this
    // this behavior to turn on/off focus shapes.

    if (GetAAtabIndex() < 0)
    {
        switch (Tag())
        {
        case ETAG_A:
        case ETAG_LABEL:
        case ETAG_IMG:
            break;
        default:
            {
                CDefaults * pDefaults = GetDefaults();

                // Draw the focus rect if defaults.tabStop is set.
                if (pDefaults && pDefaults->GetAAtabStop())
                    break;
            }
            goto Cleanup;
        }
    }

    if (ShouldHaveLayout())
    {
        CRect       rc;
        CLayout *   pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );

        if (!pLayout)
            goto Cleanup;

        pLayout->GetClientRect(&rc);
        if (rc.IsEmpty())
            goto Cleanup;

        CRectShape *pShape = new CRectShape;
        if (!pShape)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (_fEditable && GetFirstBranch()->GetFancyFormat()->_fContentEditable)
            rc.InflateRect(1, 1);

        pShape->_rect = rc;
        *ppShape = pShape;

        hr = S_OK;
    }
    else
    {
        long            cpStart, cch;
        CFlowLayout *   pFlowLayout     = GetFlowLayout( GUL_USEFIRSTLAYOUT );

        if (!pFlowLayout)
            goto Cleanup;

        cch = GetFirstAndLastCp( &cpStart, NULL );
        // GetFirstAndLast gets a cpStart + 1. We need the element's real cpStart
        // Also, the cch is less than the real cch by 2. We need to add this back
        // in so RegionFromElement can get the correct width of this element.
        hr = THR(pFlowLayout->GetWigglyFromRange(pdci, cpStart - 1, cch + 2, ppShape));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  CElement::GetImageUrlCookie
//
//  Returns a Adds the specified URL to the url image cache on the doc
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetImageUrlCookie(LPCTSTR lpszURL, LONG *plCtxCookie, BOOL fForceReload)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    LONG            lNewCookie = 0;

    // Element better be in the tree when this function is called
    Assert (pDoc);

    if (lpszURL && *lpszURL)
    {
        hr = pDoc->AddRefUrlImgCtx(lpszURL, this, &lNewCookie, fForceReload);
        if(hr)
            goto Cleanup;
    }

Cleanup:
    *plCtxCookie = lNewCookie;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  CElement::AddImgCtx
//
//  Adds the info specified in ImgCtxInfo on the attr array, releasing
//  the current value if there is one.
//
//-------------------------------------------------------------------------

HRESULT
CElement::AddImgCtx(DISPID dispID, LONG lCookie)
{
    HRESULT hr = S_OK;
    CDoc    * pDoc = Doc();
    AAINDEX iCookieIndex;

    iCookieIndex = FindAAIndex(dispID, CAttrValue::AA_Internal);

    if (iCookieIndex != AA_IDX_UNKNOWN)
    {
        // Remove the current entry
        DWORD dwCookieOld = 0;

        if (GetSimpleAt(iCookieIndex, &dwCookieOld) == S_OK)
        {
            pDoc->ReleaseUrlImgCtx(LONG(dwCookieOld), this);
        }
    }

    _fHasImage = TRUE;

    hr = THR(AddSimple(dispID, DWORD(lCookie), CAttrValue::AA_Internal));

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseImageCtxts
//
//  Synopsis:   Finds any image contexts associated with this element,
//              and frees them up.  Cookies can be held for LI bullets
//              and for background images.
//
//-----------------------------------------------------------------------------

void
CElement::ReleaseImageCtxts()
{
    CDoc * pDoc = Doc();
    AAINDEX iCookieIndex;
    DWORD   dwCookieOld = 0;
    int     n;

    if (!_fHasImage)
        return;         // nothing to do, bail

    for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
    {
        // Check for a bg url image cookie in the standard attr array
        iCookieIndex = FindAAIndex(s_aryImgDispID[n].cacheID,
                                   CAttrValue::AA_Internal);

        if (iCookieIndex != AA_IDX_UNKNOWN &&
            GetSimpleAt(iCookieIndex, &dwCookieOld) == S_OK)
        {
            pDoc->ReleaseUrlImgCtx((LONG)dwCookieOld, this);
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteImageCtx
//
//  Synopsis:   Finds any image contexts associated with this element,
//              corresponding to the dispid and free it up.  Cookies
//              can be held for LI bullets and for background images.
//
//-----------------------------------------------------------------------------

void
CElement::DeleteImageCtx(DISPID dispid)
{
    CDoc *      pDoc = Doc();
    CAttrArray* pAA;

    if (_fHasImage && (pAA = *GetAttrArray()) != NULL)
    {
        int n;
        for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
        {
            if (dispid == s_aryImgDispID[n].propID)
            {
                long lCookie;

                if ( pAA->FindSimpleInt4AndDelete(s_aryImgDispID[n].cacheID,
                                               (DWORD *)&lCookie) )
                {
                    // Release UrlImgCtxCacheEntry
                    pDoc->ReleaseUrlImgCtx(lCookie, this);
                }
                break;
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     GetSourceIndex
//
//-------------------------------------------------------------------------


long
CElement::GetSourceIndex ()
{
    CTreeNode * pNodeCurr;

    if ( Tag() == ETAG_ROOT )
        return -1;

    pNodeCurr = GetFirstBranch();
    if ( !pNodeCurr )
        return -1;
    else
    {
        Assert( !pNodeCurr->GetBeginPos()->IsUninit() );
        return pNodeCurr->GetBeginPos()->SourceIndex()-1; // subtract one because of ETAG_ROOT
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CompareZOrder
//
//  Synopsis:   Compare the z-order of two elements
//
//  Arguments:  pElement - The CElement to compare against
//
//  Returns:    Greater than zero if this element is greater
//              Less than zero if this element is less
//              Zero if they are equal
//
//----------------------------------------------------------------------------

MtDefine( ZCompares, Metrics, "Calls to CElement::CompareZOrder" )

long
CElement::CompareZOrder(
    CElement *  pElement)
{
    long    lCompare;

    MtAdd( Mt(ZCompares), +1, 0 );

    lCompare = GetFirstBranch()->GetCascadedzIndex() - pElement->GetFirstBranch()->GetCascadedzIndex();

    if (!lCompare)
    {
        lCompare = GetSourceIndex() - pElement->GetSourceIndex();
    }

    return lCompare;
}


//+------------------------------------------------------------------------
//
//  Member:     GetTreeExtent
//
//  Synopsis:   Return the edge node pos' for this element.  Pretty
//              much just walks the context chain and gets the first
//              and last node pos'.
//
//-------------------------------------------------------------------------
void
CElement::GetTreeExtent(
    CTreePos ** pptpStart,
    CTreePos ** pptpEnd )
{
    CTreeNode * pNodeCurr = GetFirstBranch();

    if (pptpStart)
        *pptpStart = NULL;

    if (pptpEnd)
        *pptpEnd = NULL;

    if (!pNodeCurr)
        goto Cleanup;

    Assert(     ! pNodeCurr->GetBeginPos()->IsUninit()
            &&  ! pNodeCurr->GetEndPos()->IsUninit() );

    if (pptpStart)
    {
        *pptpStart = pNodeCurr->GetBeginPos();

        Assert( *pptpStart );
        Assert( (*pptpStart)->IsBeginNode() && (*pptpStart)->IsEdgeScope() );
        Assert( (*pptpStart)->Branch() == pNodeCurr );
    }

    if (pptpEnd)
    {
        while( pNodeCurr->NextBranch() )
            pNodeCurr = pNodeCurr->NextBranch();

        Assert( pNodeCurr );

        *pptpEnd = pNodeCurr->GetEndPos();

        Assert( *pptpEnd );
        Assert( (*pptpEnd)->IsEndNode() && (*pptpEnd)->IsEdgeScope() );
        Assert( (*pptpEnd)->Branch() == pNodeCurr );
    }

Cleanup:
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     GetLastBranch
//
//  Synopsis:   Like GetFirstBranch, but gives the last one.
//
//-------------------------------------------------------------------------
CTreeNode *
CElement::GetLastBranch()
{
    CTreeNode *pNode = GetFirstBranch();
    CTreeNode *pNodeLast = pNode;

    while (pNode)
    {
        pNodeLast = pNode;
        pNode = pNode->NextBranch();
    }

    return pNodeLast;
}

//+------------------------------------------------------------------------
//
//  Member:     ParanoidGetLastBranch
//
//  Synopsis:   Like GetFirstBranch, but gives the last one.  More resistent to
//              corrupt data structures.
//
//-------------------------------------------------------------------------
CTreeNode *
CElement::ParanoidGetLastBranch()
{
    CTreeNode *pNode = GetFirstBranch();
    CTreeNode *pNodeLast = pNode;

    while (pNode)
    {
        pNodeLast = pNode;
        pNode = pNode->ParanoidNextBranch();
    }

    return pNodeLast;
}

//+------------------------------------------------------------------------
//
//  Static Member:  CElement::ReplacePtr, CElement::ClearPtr
//
//  Synopsis:   Do a CElement* assignment, but worry about refcounts
//
//-------------------------------------------------------------------------

void
CElement::ReplacePtr ( CElement * * pplhs, CElement * prhs )
{
    if (pplhs)
    {
        CElement * plhsLocal = *pplhs;
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
        if (plhsLocal)
        {
            plhsLocal->Release();
        }
    }
}

//+------------------------------------------------------------------------
//
//  Static Member:  CElement::ReplacePtrSub, CElement::ClearPtr
//
//  Synopsis:   Do a CElement* assignment, but worry about weak refcounts
//
//-------------------------------------------------------------------------

void
CElement::ReplacePtrSub ( CElement * * pplhs, CElement * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->SubAddRef();
        }
        if (*pplhs)
        {
            (*pplhs)->SubRelease();
        }
        *pplhs = prhs;
    }
}

void
CElement::SetPtr ( CElement ** pplhs, CElement * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
    }
}

void
CElement::StealPtrSet ( CElement ** pplhs, CElement * prhs )
{
    SetPtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CElement::StealPtrReplace ( CElement ** pplhs, CElement * prhs )
{
    ReplacePtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CElement::ClearPtr ( CElement * * pplhs )
{
    if (pplhs && * pplhs)
    {
        CElement * pElement = *pplhs;
        *pplhs = NULL;
        pElement->Release();
    }
}

void
CElement::ReleasePtr ( CElement * pElement )
{
    if (pElement)
    {
        pElement->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsBlockElement
//
//  Synopsis:   Describes whether or not this node is a block element
//
//  Returns:    BOOL indicating a block element
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsBlockElement ( FORMAT_CONTEXT FCPARAM )
{
    CTreeNode * pTreeNode = GetFirstBranch();

    if (pTreeNode->_iFF == -1)
        pTreeNode->GetFancyFormat(FCPARAM);

    return BOOL( pTreeNode->_fBlockNess );
}

HRESULT
CElement::get_canHaveHTML(VARIANT_BOOL *pfCanHaveHTML)
{
    HRESULT hr = S_OK;
    CDefaults *pDefaults;
    
    if (!pfCanHaveHTML)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsNoScope() ||
        Tag() == ETAG_PLAINTEXT ||
        Tag() == ETAG_SELECT ||
        Tag() == ETAG_XMP)
    {
        *pfCanHaveHTML = VARIANT_FALSE;
        goto Cleanup;
    }

    // see if behaviour set default canHaveHTML
    pDefaults = GetDefaults();
    if (pDefaults && pDefaults->GetAAcanHaveHTML(pfCanHaveHTML))
        goto Cleanup;
    else if (IsInMarkup())
    {
        CTreeNode *pNode = GetFirstBranch();
        Assert(pNode);
        if (!pNode->Parent() || pNode->Parent()->Tag() != ETAG_ROOT || pNode->Tag() == ETAG_HTML)
        {
            CElement *pContainer = pNode->GetContainer();
            *pfCanHaveHTML = (pContainer && pContainer->HasFlag(TAGDESC_ACCEPTHTML)) ? VARIANT_TRUE : VARIANT_FALSE;
            goto Cleanup;
        }
    }

    // if we are here, this element is in ether or is directly parented to the root and is not an <HTML> Element
    *pfCanHaveHTML = HasFlag(TAGDESC_CONTAINER) && !HasFlag(TAGDESC_ACCEPTHTML) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT 
CElement::get_isMultiLine(VARIANT_BOOL *pfMultiLine) 
{
    HRESULT hr = S_OK;
    CDefaults *pDefaults;

    if (!pfMultiLine)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfMultiLine = VARIANT_TRUE;

    // see if behaviour set default isMultiLine
    pDefaults = GetDefaults();
    if (pDefaults)
    {
        *pfMultiLine = pDefaults->GetAAisMultiLine();
        goto Cleanup;
    }

    if (Tag() == ETAG_INPUT)
        *pfMultiLine = IsTypeMultiline(DYNCAST(CInput, this)->GetType()) ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_inflateBlock(VARIANT_BOOL *pfInflate)
{
    HRESULT hr = S_OK;
    
    if (!pfInflate)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfInflate = _fBreakOnEmpty ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::put_inflateBlock(VARIANT_BOOL fInflate)
{
    HRESULT hr = S_OK;
    
    if (_fBreakOnEmpty ^ !!fInflate)
    {
        CNotification nf;
        CMarkup      *pMarkupNotify;

        _fBreakOnEmpty  = fInflate;

        pMarkupNotify = GetMarkup();
        if (!pMarkupNotify)
            goto Cleanup;

        nf.ElementResize(this, 0);
        pMarkupNotify->Notify(&nf);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_isContentEditable(VARIANT_BOOL *pfEditable)
{
    HRESULT hr = S_OK;
    
    if (!pfEditable)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfEditable = IsEditable(/*fCheckContainerOnly*/FALSE) ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_isDisabled(VARIANT_BOOL *pfDisabled)
{
    HRESULT hr = S_OK;
    
    if (!pfDisabled)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfDisabled = IsEnabled() ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsOwnLineElement
//
//  Synopsis:   Tells us if the element is a ownline element
//
//  Returns:    BOOL indicating an ownline element
//
//-----------------------------------------------------------------------------
BOOL
CElement::IsOwnLineElement(CFlowLayout *pFlowLayoutContext)
{
    BOOL fRet;
    
    if (   (   HasFlag(TAGDESC_OWNLINE)
            || pFlowLayoutContext->IsElementBlockInContext(this)
           )
        && IsInlinedElement(LC_TO_FC(pFlowLayoutContext->LayoutContext()))
       )
    {
        fRet = TRUE;
    }
    else
        fRet = FALSE;
    
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsBlockTag
//
//  Synopsis:   Describes whether or not this element is a block tag
//              This should rarely be used - it returns the same value no
//              matter what the display: style setting on the element is.
//              To determine if you should break lines before and after the
//              element use IsBlockElement().
//
//  Returns:    BOOL indicating a block tag
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsBlockTag ( void )
{
    return HasFlag(TAGDESC_BLOCKELEMENT) || Tag() == ETAG_OBJECT;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::BreaksLine
//
//  Synopsis:   Describes whether or not this node starts a new line
//
//  Returns:    BOOL indicating start of new line
//
//-------------------------------------------------------------------------

BOOL
CElement::BreaksLine ( void )
{
    return (IsBlockElement() &&
                !HasFlag(TAGDESC_WONTBREAKLINE));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::HasFlag
//
//  Synopsis:   Checks if the element has an given tag
//
//  Returns:    TRUE if it has an end tag else FALSE
//
//-------------------------------------------------------------------------

BOOL
CElement::HasFlag(TAGDESC_FLAGS flag) const
{
    const CTagDesc *ptd = TagDescFromEtag(Tag());
    return ptd ? (ptd->_dwTagDescFlags & flag) ? TRUE : ptd->HasFlag(flag)
               : FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::TagName
//
//  Synopsis:   Chases the proxy and the returns the tag name of
//
//  Returns:    const TCHAR *
//
//-------------------------------------------------------------------------

const TCHAR *
CElement::TagName ()
{
    CExtendedTagDesc * pTagDesc = GetExtendedTagDesc();
    if (!pTagDesc)
    {
        return NameFromEtag(Tag());
    }
    else
    {
        Assert (pTagDesc->TagName());
        return pTagDesc->TagName();
    }
}

const TCHAR *
CElement::Namespace( )
{
    CExtendedTagDesc * pTagDesc = GetExtendedTagDesc();
    if (!pTagDesc)
    {
        return NULL;
    }
    else
    {
        Assert (pTagDesc->Namespace());
        return pTagDesc->Namespace();
    }
}

const TCHAR *
CElement::NamespaceHtml()
{
    LPCTSTR  pchNamespace = Namespace();

    return pchNamespace ? pchNamespace : _T("HTML");
}

BOOL
SameScope ( CTreeNode * pNode1, const CElement * pElement2 )
{
    // Both NULL
    if(!pNode1 && !pElement2)
        return TRUE;

    return pNode1 && pElement2
        ? pNode1->Element() == pElement2
        : FALSE;
}

BOOL
SameScope ( const CElement * pElement1, CTreeNode * pNode2 )
{
    // Both NULL
    if(!pElement1 && !pNode2)
        return TRUE;

    return pElement1 && pNode2
        ? pElement1 == pNode2->Element()
        : FALSE;
}

BOOL
SameScope ( CTreeNode * pNode1, CTreeNode * pNode2 )
{
    if (pNode1 == pNode2)
        return TRUE;

    return pNode1 && pNode2
        ? pNode1->Element() == pNode2->Element()
        : FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::NameOrIDOfParentForm
//
//  Synopsis:   Return the name or id of a parent form if one exists.
//              NULL if not.
//
//-------------------------------------------------------------------------

LPCTSTR
CElement::NameOrIDOfParentForm()
{
    CElement *  pElementForm;
    LPCTSTR     pchName = NULL;

    pElementForm = GetFirstBranch()->SearchBranchToRootForTag( ETAG_FORM )->SafeElement();

    if (pElementForm)
    {
        pchName = pElementForm->GetIdentifier();
    }
    return pchName;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttribute
//
//  Synopsis:   Save a single attribute to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttribute (
    CStreamWriteBuff *      pStreamWrBuff,
    LPTSTR                  pchName,
    LPTSTR                  pchValue,
    const PROPERTYDESC *    pPropDesc /* = NULL */,
    CBase *                 pBaseObj /* = NULL */,
    BOOL                    fEqualSpaces /* = TRUE */,    // TODO (dbau) fix all the test cases so that it never has spaces
    BOOL                    fAlwaysQuote /* = FALSE */)
    
{
    HRESULT     hr;
    DWORD       dwOldFlags;

    hr = THR(pStreamWrBuff->Write(_T(" "), 1));
    if (hr)
        goto Cleanup;

    hr = THR(pStreamWrBuff->Write(pchName, _tcslen(pchName)));
    if (hr)
        goto Cleanup;

    if (pchValue || pPropDesc)
    {
        // Quotes are necessary for pages like ASP, that might have
        // <% =x %>. This will mess up the parser if we don't output
        // the quotes around such ASP expressions.
        BOOL fForceQuotes = fAlwaysQuote || !pchValue || !pchValue[0] || 
            (pchValue && ( StrChr(pchValue, _T('<')) || StrChr(pchValue, _T('>')) ));

        if (fEqualSpaces)
            hr = THR(pStreamWrBuff->Write(_T(" = ")));
        else
            hr = THR(pStreamWrBuff->Write(_T("=")));
        if (hr)
            goto Cleanup;

        // We dont want to break the line in the middle of an attribute value
        dwOldFlags = pStreamWrBuff->SetFlags(WBF_NO_WRAP);

        if (pchValue)
        {
            hr = THR(pStreamWrBuff->WriteQuotedText(pchValue, fForceQuotes));
        }
        else
        {
            Assert (pPropDesc && pBaseObj);
            hr = THR(pPropDesc->HandleSaveToHTMLStream (pBaseObj, (void *)pStreamWrBuff));
        }
        if (hr)
            goto Cleanup;

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
// Member:     CElement::SaveUnknown
//
// Synopsis:   Write these guys out
//
// Returns:    HRESULT
//
//+------------------------------------------------------------------------

HRESULT
CElement::SaveUnknown(CStreamWriteBuff * pStreamWrBuff, BOOL *pfAny)
{
    HRESULT hr = S_OK;
    AAINDEX aaix = AA_IDX_UNKNOWN;
    LPCTSTR lpPropName;
    LPCTSTR lpszValue = NULL;
    BSTR bstrTemp = NULL;
    DISPID expandoDISPID;
    BOOL fAny = FALSE;

    // Look for all expandos & dump them out
    while ( (aaix = FindAAType (CAttrValue::AA_Expando, aaix ) )
        != AA_IDX_UNKNOWN )
    {
        CAttrValue *pAV = _pAA->FindAt(aaix);

        Assert (pAV);

        // Get value into a string, but skip VT_DISPATCH & VT_UNKNOWN
        if (pAV->GetAVType() == VT_DISPATCH || pAV->GetAVType() == VT_UNKNOWN )
            continue;

        // TODO rgardner - we should smarten this up so we don't need to allocate a string

        // Found a literal attrValue
        hr = pAV->GetIntoString( &bstrTemp, &lpszValue );

        if ( hr == S_FALSE )
        {
            // Can't convert to string
            continue;
        }
        else if ( hr )
        {
            goto Cleanup;
        }

        fAny = TRUE;

        expandoDISPID = GetDispIDAt ( aaix );
        if (TestClassFlag(ELEMENTDESC_OLESITE))
        {
            expandoDISPID = expandoDISPID + DISPID_EXPANDO_BASE - DISPID_ACTIVEX_EXPANDO_BASE;
        }

        hr = GetExpandoName ( expandoDISPID, &lpPropName );
        if (hr)
            goto Cleanup;

        hr = THR(SaveAttribute(pStreamWrBuff, (LPTSTR)lpPropName, (LPTSTR)lpszValue, NULL, NULL, FALSE, TRUE)); // Always quote value: IE5 57717
        if (hr)
            goto Cleanup;

        if ( bstrTemp )
        {
            SysFreeString ( bstrTemp );
            bstrTemp = NULL;
        }
    }

    if (pfAny)
        *pfAny = fAny;

Cleanup:
    if ( bstrTemp )
        FormsFreeString ( bstrTemp );
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Member:     CElement::SaveUnknown
//
// Synopsis:   Write these guys out
//
// Returns:    HRESULT
//
//+------------------------------------------------------------------------

HRESULT
CElement::SaveUnknown(IPropertyBag * pPropBag, BOOL fSaveBlankAttributes )
{
    HRESULT     hr = S_OK;
    AAINDEX     aaix = AA_IDX_UNKNOWN;
    LPCTSTR     lpPropName;
    CVariant    var;
    DISPID      dispidExpando;

    while ( (aaix = FindAAType ( CAttrValue::AA_Expando, aaix )) != AA_IDX_UNKNOWN )
    {
        var.vt = VT_EMPTY;

        hr = THR(GetIntoBSTRAt(aaix, &(var.bstrVal)));
        if (hr == S_FALSE)
        {
            // Can't convert to string
            continue;
        }
        else if (hr)
        {
            goto Cleanup;
        }

        // We do not save attributes with null string values for netscape compatibility of
        // <EMBED src=thisthat loop> attributes which have no value - the loop attribute
        // in the example.   Pluginst.cxx passes in FALSE for fSaveBlankAttributes, everybody
        // else passes in TRUE via a default param value.
        if( !fSaveBlankAttributes && (var.bstrVal == NULL || *var.bstrVal == _T('\0') ) )
        {
            VariantClear (&var);
            continue;
        }

        var.vt = VT_BSTR;

        dispidExpando = GetDispIDAt(aaix);
        if (TestClassFlag(ELEMENTDESC_OLESITE))
        {
            dispidExpando = dispidExpando +
                DISPID_EXPANDO_BASE - DISPID_ACTIVEX_EXPANDO_BASE;
        }
        hr = THR(GetExpandoName(dispidExpando, &lpPropName));
        if (hr)
            goto Cleanup;

        hr = THR(pPropBag->Write(lpPropName, &var));
        if (hr)
            goto Cleanup;

        VariantClear (&var);
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Helper:     StoreLineAndOffsetInfo
//
//  Synopsis:   stores line and offset information for a property in attr array of the object
//
//-------------------------------------------------------------------------

HRESULT
StoreLineAndOffsetInfo(CBase * pBaseObj, DISPID dispid, ULONG uLine, ULONG uOffset)
{
    HRESULT         hr;
    // pchData will be of the form "ulLine ulOffset", for example: "13 1313"
    TCHAR           pchData [30];   // in only needs to be 21, but let's be safe

    hr = Format(0, &pchData, 30, _T("<0du> <1du>"), uLine, uOffset);
    if (hr)
        goto Cleanup;

    hr = THR(pBaseObj->AddString(dispid, pchData, CAttrValue::AA_Internal));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetLineAndOffsetInfo
//
//  Synopsis:   retrieves line and offset information for a property from attr array
//
//  Returns:    S_OK        successfully retrieved the data
//              S_FALSE     no error, but the information in attr array is not
//                          a line/offset string
//              FAILED(hr)  generic error condition
//
//-------------------------------------------------------------------------

HRESULT
GetLineAndOffsetInfo(CAttrArray * pAA, DISPID dispid, ULONG * puLine, ULONG * puOffset)
{
    HRESULT         hr;
    CAttrValue *    pAV;
    AAINDEX         aaIdx;
    LPTSTR          pchData;
    TCHAR *         pchTempStart;
    TCHAR *         pchTempEnd;

    Assert (puOffset && puLine);

    (*puOffset) = (*puLine) = 0;      // set defaults

    //
    // get the information string
    //

    aaIdx = AA_IDX_UNKNOWN;
    pAV = pAA->Find(dispid, CAttrValue::AA_Internal, &aaIdx);
    if (!pAV || VT_LPWSTR != pAV->GetAVType())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    pchData = pAV->GetString();

    //
    // pchData is of the format: "lLine lOffset", for example: "13 1313"
    // Here we crack the string apart.
    //

    pchTempStart = pchData;
    pchTempEnd = _tcschr(pchData, _T(' '));

    Assert (pchTempEnd);

    *pchTempEnd = _T('\0');
    hr = THR(ttol_with_error(pchTempStart, (LONG*)puLine));
    *pchTempEnd = _T(' ');
    if (hr)
        goto Cleanup;

    pchTempStart = ++pchTempEnd;

    hr = THR(ttol_with_error(pchTempStart, (LONG*)puOffset));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::ConnectEventHandler
//
//  Synopsis:   retrieves string with the specified dispid from attr array, constructs
//              code from the string and puts it in attr array with dispidCode.
//              When fStandard is set, meaning that the event handler is standard,
//              such as onclick, dispid identifies script text in AA_Attribute
//              section of attr array. If fStandard is false, then dispid identifies script
//              text in AA_Expando section of attr array.
//              Also caches language attribute in ppchLanguageCached if provided.
//              uOffset and uLine specify line and offset of script text in source html -
//              this information is necessary for script debugger.
//
//-------------------------------------------------------------------------

HRESULT
CElement::ConnectInlineEventHandler(
    DISPID      dispid,
    DISPID      dispidCode,
    ULONG       uOffset,
    ULONG       uLine,
    BOOL        fStandard,
    LPCTSTR *   ppchLanguageCached,
    CHtmlComponent *pComponent)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pchCode = NULL;
    IDispatch *     pDispCode = NULL;
    CAttrArray *    pAA = *GetAttrArray();
    CAttrValue *    pAV = NULL;
    CBase *         pBaseObj;
    LPCTSTR         pchLanguageLocal;
    CMarkup *       pMarkup = GetMarkup();
    WHEN_DBG(CDoc *          pDoc = Doc();)

    Assert(pMarkup);

    // Don't hook up script event handlers in print mode
    // TODO (KTam): It may be more correct to put a query to
    // ProcessURLAction(URLACTION_SCRIPT_RUN) in the callers of this fn;
    // this is already happening in some cases (consider changing
    // CPeerSite::GetEventCookieHelper)
    if (pMarkup->DontRunScripts())
        goto Cleanup;
    //
    // get language
    //

    if (!ppchLanguageCached)
    {
        pchLanguageLocal = NULL;
        ppchLanguageCached = &pchLanguageLocal;
    }

    if (!(*ppchLanguageCached))
    {
        if (pAA == NULL || !pAA->FindString (DISPID_A_LANGUAGE, ppchLanguageCached, CAttrValue::AA_Attribute))
        {
            (*ppchLanguageCached) = _T("");
        }
    }

    //
    // get base object and code
    //

    pBaseObj = GetBaseObjectFor (dispid);

    if (!pBaseObj || !(*(pBaseObj->GetAttrArray())))
        goto Cleanup;

    // this is supposed to be found because of the logic dispid-s passed in this function (alexz)
    //   however, for peers on the object tag, the expandos are saved as activeX_EXPANDOS and we
    //   need to search for a differnt dispid
    // (JHarding) It's also possible the dispatch has already been set up.  We'll take that, too.
    pAV = (*(pBaseObj->GetAttrArray()))->Find( dispid, fStandard ? CAttrValue::AA_Attribute :
                                                                   CAttrValue::AA_Expando );
    if( !pAV )
        pAV = (*(pBaseObj->GetAttrArray()))->Find( ((dispid - DISPID_EXPANDO_BASE) + DISPID_ACTIVEX_EXPANDO_BASE),
                                                   CAttrValue::AA_Expando );
    if( !pAV )
        goto Cleanup;

    if( pAV->GetAVType() == VT_DISPATCH )
    {
        pDispCode = pAV->GetDispatch();
        if( pDispCode )
            pDispCode->AddRef();
    }
    else if( pAV->GetAVType() == VT_LPWSTR )
    {
        pchCode = pAV->GetLPWSTR();
    }

    if( !pchCode && !pDispCode )
        goto Cleanup;

    //
    // debug stuff
    //

#if DBG==1
    if (pchCode && IsTagEnabled(tagHtmSrcTest))
    {
        TCHAR achSrc[512];
        ULONG cch;

        HRESULT hrT;

        hrT = pDoc->GetHtmSourceText(uOffset, ARRAY_SIZE(achSrc) - 1,
                achSrc, &cch);

        if (hrT == S_OK)
        {
            cch = min(cch, (ULONG)_tcslen(pchCode));
            achSrc[cch] = 0;

            TraceTag((
                tagHtmSrcTest,
                "Expect \"%.64ls\", (ln=%ld pos=%ld) \"%.64ls\"",
                pchCode, uLine, uOffset, achSrc));
        }
    }
#endif

    //
    // get previously stored line/offset information
    //

    if (!fStandard && !pDispCode)
    {
        Assert (0 == uLine && 0 == uOffset);

        hr = THR(GetLineAndOffsetInfo(pAA, dispid, &uLine, &uOffset));
        if (!OK(hr))        // if not S_OK or S_FALSE
            goto Cleanup;
    }

    //
    // construct code and handle result
    //

    if( !pDispCode )
    {
        CScriptCollection *pScriptCollection;
        TCHAR *pchNamespace = (LPTSTR)NameOrIDOfParentForm();
        
        if (!pchNamespace && !pMarkup->HasWindowPending())
        {
            if (pComponent)
            {
                pchNamespace = pComponent->GetNamespace();
            }
            else
            {
                CMarkupScriptContext *pScriptContext;
                hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
                if (!hr)
                    pchNamespace = pScriptContext->GetNamespace();
            }

            Assert(pchNamespace || (pMarkup->_fMarkupServicesParsing && (Tag() == ETAG_OBJECT)));
        }

        pScriptCollection = pMarkup->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = THR_NOTRACE(pScriptCollection->ConstructCode(
                pchNamespace,                       // pchScope
                (LPTSTR)pchCode,                    // pchCode
                NULL,                               // pchFormalParams
                (LPTSTR)(*ppchLanguageCached),      // pchLanguage
                pMarkup,                            // pMarkup
                NULL,                               // pchType (valid on script tags only)
                uOffset,                            // ulOffset
                uLine,                              // ulStartingLine
                pMarkup,                            // pSourceObject
                SCRIPTPROC_HOSTMANAGESSOURCE,       // dwFlags
                &pDispCode,                         // ppDispCode result
                TRUE,                               // fSingleLine
                pComponent));                       // An instance of lightwight behavior whose <ATTACH> tag is being hooked up
        }
    }

    if (S_OK == hr && pDispCode)
    {
        // pDispCode can be NULL if the script was parsed
        // but it contained no executeable statements
        hr = THR(pBaseObj->AddDispatchObject(
            dispidCode,
            pDispCode,
            CAttrValue::AA_Internal,
            CAttrValue::AA_Extra_OldEventStyle));
        ClearInterface (&pDispCode);
        if (hr)
            goto Cleanup;

        // if we add a data event to an element, make sure the event can fire
        CDataMemberMgr::EnsureDataEventsFor(pBaseObj, dispid);
    }
    else if (E_NOTIMPL == hr && !pDispCode)
    {
        //
        // ConstructCode must have failed because we are parsing VBScript and it does not support
        // function pointers. In this case, we will do AddScriptlet in CElement::AddAllScriptlets.
        // The only thing we need to do now is to store line/offset numbers in attr array in
        // AA_Internal section, if it is not there yet.
        // There are 2 codepaths which can lead us here:
        // 1.   We call this method from CElement::InitAttrBag to connect standard inline
        // event handlers, such as onclick. We call it passing actual line/offset information
        // available there from CHtmlTag * pht. In this case line/offset information is passed
        // and we store it
        // 2.   We call this method from CPeerHolder::RegisterEvent to connect custom peer event
        // handler. In this case the event handler is an expando and line/offset information was
        // stored for it in CElement::InitAttrBag; we don't need to do anything.

        if (fStandard) // equivalent to condition (0 != uLine || 0 != uOffset)
        {
            hr = StoreLineAndOffsetInfo (pBaseObj, dispid, uLine, uOffset);
            if (hr)
                goto Cleanup;
        }
    }
    
    // Don't propagate the last error - code construction could have failed due to
    // syntax errors so try to construct other event handlers
    hr = S_OK;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::InitAttrBag
//
//  Synopsis:   Fetch values from CHtmTag and put into the bag
//
//  Arguments:  pht : parsed attributes in text format
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::InitAttrBag(CHtmTag *pht, CMarkup * pMarkup)
{
    int i;
    CHtmTag::CAttr *pattr = NULL;
    HRESULT hr = S_OK;
    const PROPERTYDESC * ppropdesc;
    CBase *pBaseObj;
    InlineEvts  *pInlineEvts = NULL;
    WORD    wMaxstrlen = 0;
    TCHAR   chOld = _T('\0');
    THREADSTATE * pts = GetThreadState();
// HACK HACK 47681 start: ignore height/width for inputs not input/image
    BOOL    fHackForInput;
    BOOL    fHackForInputProp;
// HACK HACK 47681 end

    BOOL fIsStrictCSS1;

    if (*GetAttrArray())
    {
        // InitAttrBag must have already been called.
        return S_OK;
    }

    pts->fInInitAttrBag = TRUE;

// HACK HACK 47681 start: ignore height/width for inputs not input/image
    fHackForInput = (Tag() == ETAG_INPUT && DYNCAST(CInput, this)->GetType() != htmlInputImage);
// HACK HACK 47681 end

    // Loop over all attr pairs in the tag, and see if their BYTE in the known-attr array
    // is set; if not, add the attr and any val to the CaryUnknownAttrs in the attr bag
    // (create one if needed).

    for (i = pht ? pht->GetAttrCount() : 0; --i >= 0; )
    {
        pattr = pht->GetAttr(i);

        if (!pattr->_pchName)
            continue;

// HACK HACK 47681 start: ignore height/width for inputs not input/image
        fHackForInputProp = fHackForInput && 
                (StrCmpIC(s_propdescCInputheight.a.pstrName, pattr->_pchName) == 0
                || StrCmpIC(s_propdescCInputwidth.a.pstrName, pattr->_pchName) == 0);

        if (!fHackForInputProp && (ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
//
// HACK HACK 47681 end. uncomment the following line when removing the HACK section
        // if ((ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
        {
            // Allow some elements to redirect to another attr array
            pBaseObj = GetBaseObjectFor(ppropdesc->GetDispid(), pMarkup);

            if (!pBaseObj)
            {
                continue;
            }

#ifndef WIN16
            // BUGWIN16: HandleLoadFromHTMLString is a class method, I am amazed that we can check
            // for it being non - null !? - vamshi - 4/29/97
#ifndef UNIX
// Unix gets, Error: Taking address of the bound function PROPERTYDESC::HandleLoadFromHTMLString(CBase*, wchar_t*) const.
//             AssertSz(ppropdesc->HandleLoadFromHTMLString != NULL, "attempt to load abstract property from html");
#endif
#endif
            wMaxstrlen = (ppropdesc->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 :
                         (ppropdesc->GetBasicPropParams()->wMaxstrlen ? ppropdesc->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE);

            if (wMaxstrlen && pattr->_pchVal && _tcslen(pattr->_pchVal) > wMaxstrlen)
            {
                chOld = pattr->_pchVal[wMaxstrlen];
                pattr->_pchVal[wMaxstrlen] = _T('\0');
            }

            // InitAttrBag (this function) is responsible for applying the attributes on an html element. Normal attributes, i.e. all attributes on html
            // except "style", doesn't take care about css1 strictness. Only when applying the inline style attribute value it has to be taken into account
            // if we are in strict css1 or not. In <HTMLELEM style="...">  the DISPID for the "style" attribute is DISPID_CElement_style_Str.
            fIsStrictCSS1 = pMarkup->IsStrictCSS1Document() && (ppropdesc->GetDispid() == DISPID_CElement_style_Str);

            hr = THR_NOTRACE( ppropdesc->HandleLoadFromHTMLString ( pBaseObj, pattr->_pchVal, fIsStrictCSS1 ? HANDLEPROP_STRICTCSS1 : 0 ));

            if (ppropdesc->GetPPFlags() & PROPPARAM_SCRIPTLET)
            {
                if (!pInlineEvts)
                    pInlineEvts = new InlineEvts;

                if (pInlineEvts)
                {
                    pInlineEvts->adispidScriptlets[pInlineEvts->cScriptlets] = ppropdesc->GetDispid();
                    pInlineEvts->aOffsetScriptlets[pInlineEvts->cScriptlets] = pattr->_ulOffset;
                    pInlineEvts->aLineScriptlets[pInlineEvts->cScriptlets++] = pattr->_ulLine;
                }
                else
                    goto Cleanup;
            }

            if ( hr )
            {
                // Create an "unknown" attribute containing the original string from the HTML
                // SetString with fIsUnkown set to TRUE
                if (chOld)
                {
                    pattr->_pchVal[wMaxstrlen] = chOld;
                    chOld = 0;
                }
                hr = CAttrArray::SetString ( pBaseObj->GetAttrArray(), ppropdesc,
                    pattr->_pchVal, TRUE, CAttrValue::AA_Extra_DefaultValue );
            }

            // If the parameter was invalid, value will get set to default &
            // parameter will go into the unknown bag
            if ( !hr )
            {
                if ( ppropdesc->GetDispid() == DISPID_A_BACKGROUNDIMAGE )
                {
                    // Fork off an early download for background images
                    LPCTSTR lpszURL;
                    if ( !(*(pBaseObj->GetAttrArray()))->FindString(DISPID_A_BACKGROUNDIMAGE, &lpszURL) )
                    {
                        LONG lCookie;

                        if (GetImageUrlCookie(lpszURL, &lCookie, TRUE) == S_OK)
                        {
                            hr = THR(AddImgCtx(DISPID_A_BGURLIMGCTXCACHEINDEX, lCookie));
                            if (hr)
                            {
                                Doc()->ReleaseUrlImgCtx(lCookie, this);
                                goto Cleanup;
                            }
                        }
                    }
                }
            }
            else if (hr == E_OUTOFMEMORY)
            {
                goto Cleanup;
            }
        }
        else if (pMarkup->_fExpando)
        {
            DISPID  expandoDISPID;

            if (pMarkup->HasBehaviorContext() && ETAG_GENERIC_BUILTIN == Tag())
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                // NOTE: Need to make sure that the parser ensures that the first buitin tag in a htc
                // is the HTC or COMPONENT tag for this to work reliably.
                if (pComponent &&
                    !pComponent->Dirty() &&
                    pComponent->_fFactoryComponent &&
                    !pComponent->_fLightWeight &&
                    (HTC_BEHAVIOR_DESC & TagNameToHtcBehaviorType(TagName())) &&
                    (StrCmpIC(_T("lightweight"), pattr->_pchName) == 0) &&
                    StringToBool(pattr->_pchVal))
                {
                    pComponent->_fLightWeight = TRUE;
                }

                if (pComponent &&
                    !pComponent->Dirty() &&
                    (pComponent->_fLightWeight || (!pComponent->_fFactoryComponent && pComponent->_fFirstInstance)) &&
                    pattr->_pchVal &&
                    *(pattr->_pchVal) &&
                    (HTC_BEHAVIOR_PROPERTYORMETHOD & TagNameToHtcBehaviorType(TagName())) &&
                    StrCmpIC(_T("NAME"), pattr->_pchName) == 0)
                {
                    if (pComponent->_fLightWeight)
                    {
                        Assert(pComponent->_fFactoryComponent);
                        pComponent->AddAtom(pattr->_pchVal, (LPVOID)this);
                    }
                    else if (!pComponent->_fFactoryComponent && pComponent->_fFirstInstance)
                    {
                        // cache the name of htc prop\method for faster retreival later in EnterTree
                        Assert(!DYNCAST(CGenericElement, this)->GetName());
                        DYNCAST(CGenericElement, this)->_cstrContents.Set(pattr->_pchVal);
                    }
                }
            }

            // Create an expando

            hr = THR_NOTRACE(AddExpando(pattr->_pchName, &expandoDISPID));

            Assert(expandoDISPID);

            if (hr == DISP_E_MEMBERNOTFOUND)
            {
                hr = S_OK;
                continue; // Expando not turned on
            }
            if (hr)
                goto Cleanup;

            if (TestClassFlag(ELEMENTDESC_OLESITE))
            {
                expandoDISPID = expandoDISPID - DISPID_EXPANDO_BASE +
                    DISPID_ACTIVEX_EXPANDO_BASE;
            }

            // Note that we always store expandos in the current object - we never redirect them
            hr = THR(AddString(
                    expandoDISPID,
                    pattr->_pchVal,
                    CAttrValue::AA_Expando));
            if (hr)
                goto Cleanup;

            // if begins with "on", this can be a peer registered event - need to store line/offset numbers
            if (0 == StrCmpNIC(_T("on"), pattr->_pchName, 2))
            {
                hr = THR(StoreLineAndOffsetInfo(this, expandoDISPID, pattr->_ulLine, pattr->_ulOffset));
                if (hr)
                    goto Cleanup;
            }
        }

        if (chOld)
        {
            pattr->_pchVal[wMaxstrlen] = chOld;
            chOld = _T('\0');
        }
    }

    if (pInlineEvts && pInlineEvts->cScriptlets && (ETAG_UNKNOWN != Tag()) && pMarkup && pMarkup->GetScriptCollection())
    {
        SetEventsShouldFire();

        StoreEventsToHook(pInlineEvts);
        pInlineEvts = NULL; // Make sure we don't free it.
    }

Cleanup:
    if (pInlineEvts)
        delete pInlineEvts;
    if (chOld)
        pattr->_pchVal[wMaxstrlen] = chOld;

    pts->fInInitAttrBag = FALSE;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::MergeAttrBag
//
//  Synopsis:   Add any value from CHtmTag that are not already present
//              in the attrbag
//
//              Note: currently, expandos are not merged.
//
//  Arguments:  pht : parsed attributes in text format
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::MergeAttrBag(CHtmTag *pht)
{
    int i;
    CHtmTag::CAttr *pattr = NULL;
    HRESULT hr = S_OK;
    const PROPERTYDESC * ppropdesc;
    InlineEvts inlineEvts;
    CBase *pBaseObj;
    WORD    wMaxstrlen = 0;
    TCHAR   chOld = _T('\0');
    CDoc *  pDoc = Doc();

    // Loop over all attr pairs in the tag, and see if their BYTE in the known-attr array
    // is set; if not, add the attr and any val to the CaryUnknownAttrs in the attr bag
    // (create one if needed).

    for (i = pht ? pht->GetAttrCount() : 0; --i >= 0; )
    {
        pattr = pht->GetAttr(i);

        if (!pattr->_pchName)
            continue;

        if ((ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
        {
            // Allow some elements to redirect to another attr array
            pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

            // Only add the attribute if it has not been previously defined
            // style attribute requires special handling
            if (!pBaseObj
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_Attribute))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_UnknownAttr))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_Internal))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_AttrArray))
                || (ppropdesc == (PROPERTYDESC *)&s_propdescCElementstyle_Str && AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(DISPID_INTERNAL_INLINESTYLEAA, CAttrValue::AA_AttrArray)))
            {
                continue;
            }

            wMaxstrlen = (ppropdesc->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 :
                         (ppropdesc->GetBasicPropParams()->wMaxstrlen ? ppropdesc->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE);

            if (wMaxstrlen && pattr->_pchVal && _tcslen(pattr->_pchVal) > wMaxstrlen)
            {
                chOld = pattr->_pchVal[wMaxstrlen];
                pattr->_pchVal[wMaxstrlen] = _T('\0');
            }
            hr = THR ( ppropdesc->HandleMergeFromHTMLString ( pBaseObj, pattr->_pchVal ) );

            if (ppropdesc->GetPPFlags() & PROPPARAM_SCRIPTLET)
            {
                inlineEvts.adispidScriptlets[inlineEvts.cScriptlets] = ppropdesc->GetDispid();
                inlineEvts.aOffsetScriptlets[inlineEvts.cScriptlets] = pattr->_ulOffset;
                inlineEvts.aLineScriptlets[inlineEvts.cScriptlets++] = pattr->_ulLine;
            }

            if (hr)
            {
                // Create an "unknown" attribute containing the original string from the HTML
                // SetString with fIsUnkown set to TRUE
                hr = CAttrArray::SetString ( pBaseObj->GetAttrArray(), ppropdesc,
                    pattr->_pchVal, TRUE, CAttrValue::AA_Extra_DefaultValue );
            }

            // If the parameter was invalid, value will get set to default &
            // parameter will go into the unknown bag
            if ( !hr )
            {
                if ( ppropdesc->GetDispid() == DISPID_A_BACKGROUNDIMAGE )
                {
                    // Fork off an early download for background images
                    LPCTSTR lpszURL;
                    if ( !(*(pBaseObj->GetAttrArray()))->FindString(DISPID_A_BACKGROUNDIMAGE, &lpszURL) )
                    {
                        LONG lCookie;

                        if (GetImageUrlCookie(lpszURL, &lCookie, TRUE) == S_OK)
                        {
                            hr = THR(AddImgCtx(DISPID_A_BGURLIMGCTXCACHEINDEX, lCookie));
                            if (hr)
                            {
                                pDoc->ReleaseUrlImgCtx(lCookie, this);
                                goto Cleanup;
                            }
                        }
                    }
                }
            }
            else if (hr == E_OUTOFMEMORY)
            {
                goto Cleanup;
            }
        }
        
        if (chOld)
        {
            pattr->_pchVal[wMaxstrlen] = chOld;
            chOld = _T('\0');
        }
    }
    
     hr = THR(inlineEvts.Connect(pDoc, this));
     if (hr)
         goto Cleanup;

Cleanup:
    if (chOld)
        pattr->_pchVal[wMaxstrlen] = chOld;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Init2
//
//  Synopsis:   Perform any element level initialization
//
//-------------------------------------------------------------------------

HRESULT
CElement::Init2(CInit2Context * pContext)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pch;
    CDoc *          pDoc = Doc();
    CAttrArray *    pAAInline;

    Assert( !IsInMarkup() && pContext->_pTargetMarkup );
    Assert( !HasWindowedMarkupContextPtr() );
    
    hr = THR(SetWindowedMarkupContextPtr( pContext->_pTargetMarkup->GetWindowedMarkupContext() ) );
    if( hr )
        goto Cleanup;

    GetWindowedMarkupContextPtr()->SubAddRef();

    pch = GetIdentifier();
    if (pch)
    {
        hr = THR(pDoc->_AtomTable.AddNameToAtomTable(pch, NULL));
        if (hr)
            goto Cleanup;
    }

    //
    // behaviors support
    //

    // TODO (alexz) see if it is possible to make it without parsing inline styles here
    pAAInline = GetInLineStyleAttrArray();
    if (pAAInline && pAAInline->Find(DISPID_A_BEHAVIOR))
    {
        pDoc->SetCssPeersPossible();
    }

#ifdef NEVER
    //
    // Set the _fTabStop bit for all the default tags.
    //

    switch (etag)
    {
    case ETAG_HR:
    case ETAG_DIV:
    case ETAG_TABLE:
    case ETAG_IMG:
        if (pDoc->_fDesignMode)
        {
            _fTabStop = TRUE;
        }
        break;

    case ETAG_LABEL:
    case ETAG_A:
    case ETAG_FRAME:
    case ETAG_EMBED:
    case ETAG_LEGEND:
        if (etag == ETAG_FRAME && _fSynthesized)
            break;

        if (!pDoc->_fDesignMode)
        {
            _fTabStop = TRUE;
        }
        break;

    case ETAG_INPUT:
    case ETAG_SELECT:
    case ETAG_TEXTAREA:
    case ETAG_BUTTON:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_IFRAME:
    case ETAG_OBJECT:
    case ETAG_APPLET:
        if (etag == ETAG_IFRAME && _fSynthesized)
            break;

        _fTabStop = TRUE;
       break;

    case ETAG_MAP:
    case ETAG_AREA:
        _fTabStop = FALSE;
        break;

    default:
        if (GetAAtabIndex() > 0)
        {
            _fTabStop = TRUE;
        }
        break;
    }
#endif

    hr = THR(InitExtendedTag(pContext));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    if (fEnd && HasFlag(TAGDESC_SAVEINDENT))
    {
        pStreamWrBuff->EndIndent();
    }

    hr = WriteTag(pStreamWrBuff, fEnd);
    if(hr)
        goto Cleanup;

    if (!fEnd && HasFlag(TAGDESC_SAVEINDENT))
    {
        pStreamWrBuff->BeginIndent();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttributes
//
//  Synopsis:   Save the attributes to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttributes ( CStreamWriteBuff * pStreamWrBuff, BOOL *pfAny )
{
    HRESULT hr = S_OK;
    BOOL fSave;
    LPCTSTR lpstrUnknownValue;
    CBase *pBaseObj;
    BOOL fAny = FALSE;

    // For printing, we let behaviors save their attributes first -- this is a hack to get
    // around the fact that if both the behavior and the element have the same attribute, they'll
    // both be persisted.  The parser lets the first one encountered win, and we want the behavior
    // to win.  Bug #94236 (KTam, JHarding)
    if (pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if (HasPeerHolder())
        {
            IGNORE_HR(GetPeerHolder()->SaveMulti(pStreamWrBuff, fAny ? NULL : &fAny));
        }
    }
    
    CPtrBagVTableAggregate::CIterator vTableIterator(GetStringTableAggregate());

    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        Assert(pVTblDesc);
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        // NOTE for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
        {
            continue;
        }

        pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

        if (!pBaseObj)
        {
            continue;
        }

        lpstrUnknownValue = NULL;
        if ( ppropdesc->GetPPFlags() & PROPPARAM_ATTRARRAY)
        {
            AAINDEX aaIx = AA_IDX_UNKNOWN;
            CAttrValue *pAV = NULL;
            CAttrArray *pAA = *(pBaseObj->GetAttrArray());

            if (pAA)
                pAV = pAA->Find(ppropdesc->GetDispid(), CAttrValue::AA_Attribute, &aaIx);

            if (pAA && (!pAV || pAV->IsDefault()))
            {
                if (pAV)
                    aaIx++;

                pAV = pAA->FindAt(aaIx);
                if (pAV)
                {
                    if ((pAV->GetDISPID() == ppropdesc->GetDispid()) &&
                        (pAV->GetAAType() == CAttrValue::AA_UnknownAttr))
                    {
                        // Unknown attrs are always strings
                        lpstrUnknownValue = pAV->GetLPWSTR();
                    }
                    else
                        pAV = NULL;
                }
            }
            fSave = !!pAV;

            // don't save databinding attributes during printing, so that we
            // print the current content instead of re-binding
            if (pStreamWrBuff->TestFlag(WBF_NO_DATABIND_ATTRS))
            {
                DISPID dispid = ppropdesc->GetDispid();
                if (    dispid == DISPID_CElement_dataSrc ||
                        dispid == DISPID_CElement_dataFld ||
                        dispid == DISPID_CElement_dataFormatAs)
                    fSave = FALSE;
            }
        }
        else
        {
            // Save the property if it was not the same as the default.
            // Do not save if we got an error retrieving it.
            fSave = ppropdesc->HandleCompare ( pBaseObj,
                (void *)&ppropdesc->ulTagNotPresentDefault ) == S_FALSE;
        }

        if (fSave)
        {
            fAny = TRUE;

            if (lpstrUnknownValue)
            {
                hr = THR(SaveAttribute(
                    pStreamWrBuff,
                    (LPTSTR)ppropdesc->pstrName,
                    (LPTSTR)lpstrUnknownValue,  // pchValue
                    NULL,                       // ppropdesc
                    NULL,                       // pBaseObj
                    FALSE));                    // fEqualSpaces
            }
            else
            {
                if (ppropdesc->IsBOOLProperty())
                {
                    hr = THR(SaveAttribute(
                        pStreamWrBuff,
                        (LPTSTR)ppropdesc->pstrName,
                        NULL,                       // pchValue
                        NULL,                       // ppropdesc
                        NULL,                       // pBaseObj
                        FALSE));                    // fEqualSpaces
                }
                else
                    hr = THR(SaveAttribute(
                        pStreamWrBuff,
                        (LPTSTR)ppropdesc->pstrName,
                        NULL,                       // pchValue
                        ppropdesc,                  // ppropdesc
                        pBaseObj,                   // pBaseObj
                        FALSE));                    // fEqualSpaces
            }
        }
    }

    hr = SaveUnknown(pStreamWrBuff, fAny ? NULL : &fAny);
    if (hr)
        goto Cleanup;

    // If we are persisting for anything other than printing, then
    // save behavior attributes at this point (compat).
    if (!pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if (HasPeerHolder())
        {
            IGNORE_HR(GetPeerHolder()->SaveMulti(pStreamWrBuff, fAny ? NULL : &fAny));
        }
    }

    if (pfAny)
        *pfAny = fAny;

Cleanup:
    RRETURN (hr);

}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttributes
//
//  Synopsis:   Save the attributes into property bag
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttributes ( IPropertyBag * pPropBag, BOOL fSaveBlankAttributes )
{
    CPtrBagVTableAggregate::CIterator vTableIterator(const_cast<CPtrBagVTableAggregate *>(GetStringTableAggregate()));

    HRESULT             hr = S_OK;
    CVariant            Var;
    BOOL                fSave;
    CBase               *pBaseObj;

    if (!vTableIterator._pAggregateTable)
        goto Cleanup;
        
    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        Assert(pVTblDesc);
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        // NOTE for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
        {
            continue;
        }

        pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

        if (!pBaseObj)
        {
            continue;
        }

        if (ppropdesc->GetPPFlags() & PROPPARAM_ATTRARRAY)
        {
            AAINDEX aaIx;
            aaIx = pBaseObj->FindAAIndex ( ppropdesc->GetDispid(), CAttrValue::AA_Attribute );
            fSave = ( aaIx == AA_IDX_UNKNOWN ) ? FALSE : TRUE;
        }
        else
        {
            // Save the property if it was not the same as the default.
            // Do not save if we got an error retrieving it.
            fSave = ppropdesc->HandleCompare ( pBaseObj,
                (void *)&ppropdesc->ulTagNotPresentDefault ) == S_FALSE;
        }

        if (fSave)
        {
            // If we're dealing with a BOOL type, don't put a value
            if ( ppropdesc->IsBOOLProperty() )
            {
                // Boolean (flag), skip the =<val>
                Var.vt = VT_EMPTY;
            }
            else
            {
                hr = THR(ppropdesc->HandleGetIntoBSTR ( pBaseObj, &V_BSTR(&Var) ));
                if (hr)
                    continue;
                V_VT(&Var) = VT_BSTR;
            }
            hr = pPropBag->Write(ppropdesc->pstrName, &Var);
            if (hr)
                goto Cleanup;
            // if Var has an Allocated value, we need to free it before
            // going around the loop again.
            VariantClear(&Var);
        }
    }

    hr = SaveUnknown(pPropBag, fSaveBlankAttributes);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::HandleMessage
//
//  Synopsis:   Perform any element specific mesage handling
//
//  Arguments:  pmsg    Ptr to incoming message
//
//  Notes:      pBranch should always be non-scoped. This is the only way
//              that the context information can be maintained. each element
//              HandleMessage which uses pBranch needs to be very careful
//              to scope first.
//
//-------------------------------------------------------------------------

HRESULT
CElement::HandleMessage(CMessage *pmsg)
{
    HRESULT     hr                  = S_FALSE;

    // Only the marquee is allowed to cheat and pass the wrong
    // context in
    Assert(IsInMarkup());

    if (pmsg->message == WM_SETCURSOR && pmsg->htc == HTC_BEHAVIOR && pmsg->lBehaviorCookie )
    {
        if ( CHECK_EDIT_BIT( GetMarkup(), _fOverrideCursor ))
        {
            hr = S_OK; // we don't touch the cursor - up to the host.        
            goto Cleanup;
        }
        
        CPeerHolder *pPH = FindPeerHolder(pmsg->lBehaviorCookie);

        if (pPH)
        {
            hr = pPH->SetCursor(pmsg->lBehaviorPartID);
        }
    }

    if (hr != S_OK)
    {
        CLayout * pLayout = GetUpdatedLayout( pmsg->pLayoutContext );

        if (pLayout)
        {
            Assert(!pmsg->fStopForward);
            hr = THR(pLayout->HandleMessage(pmsg));
            if (hr != S_FALSE || pmsg->fStopForward)
                goto Cleanup;
        }
        else if (   WM_CONTEXTMENU == pmsg->message
                &&  HasCapture()
                &&  !Doc()->_pInPlace->_fBubbleInsideOut)
        {
            hr = THR(OnContextMenu(
                    (short) LOWORD(pmsg->lParam),
                    (short) HIWORD(pmsg->lParam),
                    CONTEXT_MENU_DEFAULT));
        }


        if (pmsg->message == WM_SETCURSOR)
        {
            hr = THR_NOTRACE(SetCursorStyle((LPTSTR)NULL, GetFirstBranch()));
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     DisallowSelection
//
//  Synopsis:   Returns TRUE iff selection must be diallowed.
//
//-------------------------------------------------------------------------

BOOL
CElement::DisallowSelection()
{
    // In dialogs, only editable controls can be selected
    return ((Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
         && !(ShouldHaveLayout() && GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->_fAllowSelectionInDialog && IsEnabled()));
}


//+------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo
//
//  Synopsis:   Pass the call to the form so it can return its clsid
//              instead of the object's clsid as in CBase.
//
//-------------------------------------------------------------------------

HRESULT
CElement::CloseErrorInfo(HRESULT hr)
{
    Doc()->CloseErrorInfo(hr);

    return hr;
}

LPCTSTR GetCursorForStyle( BYTE iIndex )
{

    static const LPCTSTR aStyleToCursor[] = 
    {
        IDC_ARROW,                       // auto map to arrow
        IDC_CROSS,                       // map to crosshair
        IDC_ARROW,                       // default map to arrow
        MAKEINTRESOURCE(IDC_HYPERLINK),  // hand map to IDC_HYPERLINK
        IDC_SIZEALL,                     // move map to SIZEALL
        IDC_SIZEWE ,                     // e-resize
        IDC_SIZENESW,                    // ne-resize
        IDC_SIZENWSE,                    // nw-resize
        IDC_SIZENS,                      // n-resize
        IDC_SIZENWSE,                    // se-resize
        IDC_SIZENESW,                    // sw-resize
        IDC_SIZENS,                      // s-resize
        IDC_SIZEWE ,                     // w-resize
        IDC_IBEAM,                       // text
        IDC_WAIT,                        // wait
#if(WINVER >= 0x0400)
        IDC_HELP,                        // help as IDC_help
#else
        IDC_ARROW,                       // help as IDC_ARROW
#endif
        MAKEINTRESOURCE(IDC_HYPERLINK),  // pointer maps to IDC_HYPERLINK

        //
        // New cursors
        //
        IDC_APPSTARTING,                 // "spinning"
        IDC_NO,                          // "not-allowed"
                
        MAKEINTRESOURCE(IDC_HYPERLINK_OFFLINE),               // "no-drop"        
        MAKEINTRESOURCE(IDC_HIBEAM),                          // vertical text
        MAKEINTRESOURCE(IDC_NOSCROLLVH),                      // all-scroll - need to find    
        MAKEINTRESOURCE(IDC_RESIZECOL2),                      // "col-resize"
        MAKEINTRESOURCE(IDC_RESIZEROW2),                      // "row-resize"
    };
    Assert(iIndex >= 0 && iIndex < ARRAY_SIZE(aStyleToCursor));

    return aStyleToCursor[iIndex];
}

CCustomCursor*
GetCustomCursorForNode(CTreeNode* pStartNode)
{
    const CFancyFormat* pFF = pStartNode->GetFancyFormat();  
    CTreeNode * pNodeParent;

    if ( pStartNode->Element()->HasMasterPtr() )
    {
        pNodeParent = pStartNode->Element()->GetMasterIfSlave()->GetFirstBranch();
    }
    else
        pNodeParent = pStartNode->Parent();
                
    while (  pFF->_iCustomCursor == -1 && pNodeParent )
    {            
        pFF = pNodeParent->GetFancyFormat();

        if ( pNodeParent->Element()->HasMasterPtr() )
        {
            pNodeParent = pNodeParent->Element()->GetMasterIfSlave()->GetFirstBranch();
        }
        else
            pNodeParent = pNodeParent->Parent();
    }
    
    if ( pFF->_iCustomCursor != -1 )
    {
        return GetCustomCursorFromCacheEx( pFF->_iCustomCursor );             
    }          

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member  :   SetCursorStyle
//
//  Synopsis : if the element.style.cursor property is set then on the handling
//      of the WM_CURSOR we should set the cursor to the one specified in
//      the style.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::SetCursorStyle(LPCTSTR idcArg, CTreeNode* pContext /* = NULL */)
{
    HRESULT hr = E_FAIL;
    LPCTSTR idc = NULL;
    HCURSOR hCurNew = NULL;
    
    
    const CCharFormat * pCF;

    if (!IsInMarkup())
        goto Cleanup;

    if (CHECK_EDIT_BIT( GetMarkup(), _fOverrideCursor ))
    {
        return S_OK; // we don't touch the cursor - up to the host.        
    }

    
    pContext = pContext ? pContext : GetFirstBranch();
    if (!pContext)
        goto Cleanup;

    pCF = pContext->GetCharFormat();
    Assert(pCF);


    if (GetMarkup()->_fShowWaitCursor)
    {
        // Waiting for page to navigate.  Show wait cursor.
        idc = IDC_APPSTARTING;
    }
    else if (  !IsParentEditable() 
             && pCF->_bCursorIdx 
             && pCF->_bCursorIdx  != styleCursorNotSet)
    {
        // The style is set to something other than auto
        // so use g_aStyleToCursor to map the enum to a cursor id.

        if ( pCF->_bCursorIdx != styleCursorcustom )
        {
            idc = GetCursorForStyle( pCF->_bCursorIdx );
        }
        else
        {
            CCustomCursor* pCust = GetCustomCursorForNode( pContext );
            if ( pCust )
            {
                hCurNew = pCust->GetCursor();
            }
#if DBG == 1
            else
            {
                AssertSz(0,"Didn't find Custom Cursor");
            }
#endif      
        }
    }
    else if (pCF->HasVerticalLayoutFlow() && idcArg == IDC_IBEAM)
    {
        idc = MAKEINTRESOURCE(IDC_HIBEAM);
    }
    else if (idcArg)
    {
        idc = idcArg;
    }
    else
    {
        // We didn't handle it.
        idc = NULL;

        //
        // check for style of 'auto' + style set on parent. 
        //
        if ( ! IsParentEditable() &&
             pCF->_bCursorIdx == styleCursorAuto )
        {
            CTreeNode* pNode = pContext->Parent();
            pCF = pNode ? pNode->GetCharFormat() : NULL ;
            
            if ( pNode && pCF &&
                 pCF->_bCursorIdx != styleCursorAuto &&
                 pCF->_bCursorIdx != styleCursorNotSet )
            {
                idc = idcArg ? idcArg : 
                               ( pCF->HasVerticalLayoutFlow() ? MAKEINTRESOURCE(IDC_HIBEAM) : IDC_IBEAM);
            }                 
        }
    }

    if (idc || hCurNew )
    {
        SetCursorIDC(idc, hCurNew );
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE );
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMSuperscript
//
//  Synopsis:   Tests the element passed is a superscript
//
//  Arguments:  CTreeNode *  element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a superscript element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMSuperscript(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return etag == ETAG_SUP;
}

//+------------------------------------------------------------------------
//
//  Function:   IsIDMSubscript
//
//  Synopsis:   Tests the element passed is a subscript
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a subscript element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMSubscript(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return etag == ETAG_SUB;
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMBold
//
//  Synopsis:   Tests the element passed is a Bold or Strong element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a bold/strong element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMBold(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return (etag == ETAG_B || etag == ETAG_STRONG);
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMCharAttr
//
//  Synopsis:   Tests the element passed is a character attribute.  This
//              function is used to determine whether an element is a
//              candidate for deletion when the user selects "remove
//              character formatting" (aka "set to normal.")
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a not "normal"
//
//-----------------------------------------------------------------------------

BOOL
IsIDMCharAttr(CTreeNode * pNode)
{
    return pNode->Element()->HasFlag(TAGDESC_EDITREMOVABLE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsIDMItalic
//
//  Synopsis:   Tests the element passed is a Italic or Cite element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a Italic/Cite element
//
//-----------------------------------------------------------------------------

BOOL
IsIDMItalic(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return (etag == ETAG_I || etag == ETAG_EM || etag == ETAG_CITE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsIDMUnderlined
//
//  Synopsis:   Tests the element passed is a Underline element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a Underline element
//
//-----------------------------------------------------------------------------

BOOL
IsIDMUnderlined(CTreeNode * pNode)
{
    return (pNode->Tag() == ETAG_U);
}


//+----------------------------------------------------------------------------
//
//  Function:   WriteTag
//
//  Synopsis:   writes an open/end tag to the stream buffer
//
//  Arguments:  pStreamWrBuff   -   stream buffer
//              fEnd            -   TRUE if End tag is to be written out
//              fForce          -   Force writing of tag
//              fAtomic         -   Save as atomic tag (ie, <tagname />)
//
//  Returns:    S_OK    if  successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::WriteTag(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd, BOOL fForce, BOOL fAtomic)
{
    HRESULT         hr = S_OK;
    DWORD           dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
    const TCHAR *   pszTagName = TagName();
    const TCHAR *   pszScopeName;
    ELEMENT_TAG     etag = Tag();

    //
    // Do not write tags out in plaintext mode or when we are
    // explicitly asked not to.
    //
    if (pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT)
        || !pszTagName[0]
        || (this == pStreamWrBuff->GetElementContext()
            && pStreamWrBuff->TestFlag(WBF_NO_TAG_FOR_CONTEXT)
           )
        || (fEnd
            && (TagHasNoEndTag(Tag())
                || (!_fExplicitEndTag
                    && !HasFlag(TAGDESC_SAVEALWAYSEND)
                    && !fForce
                   )
                || fAtomic
               )
           )
       )
    {
        goto Cleanup;
    }

    if(fEnd)
    {
        hr = pStreamWrBuff->Write(_T("</"), 2);
    }
    else
    {
        CExtendedTagDesc *  pExtendedTagDesc = GetExtendedTagDesc();
        if ( pExtendedTagDesc && !pStreamWrBuff->TestFlag( WBF_FOR_TREESYNC ) )
        {
            hr = THR(pStreamWrBuff->EnsurePIsSaved(this, pExtendedTagDesc, HasIdentityPeerHolder() ? XMLNAMESPACEDECL_IMPORT : XMLNAMESPACEDECL_TAG));
            if (hr)
                goto Cleanup;
        }

        if (pStreamWrBuff->TestFlag(WBF_FOR_RTF_CONV) &&
            Tag() == ETAG_DIV)
        {
            // For the RTF converter, transform DIV tags into P tags.
            pszTagName = SZTAG_P;
        }

        // NOTE: In IE4, we would save a NewLine before every
        // element that was a ped.  This is roughly equivalent
        // to saving it before every element that is a container now
        // However, this does not round trip properly so I'm taking
        // that check out.

        if (    ! pStreamWrBuff->TestFlag(WBF_NO_PRETTY_CRLF)
            &&  (   HasFlag(TAGDESC_SAVETAGOWNLINE)
                ||  IsBlockTag() ) )
        {
            hr = pStreamWrBuff->NewLine();
            if (hr)
                goto Cleanup;
        }
        hr = pStreamWrBuff->Write(_T("<"), 1);
    }

    if(hr)
        goto Cleanup;


    pszScopeName = pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && 
               pStreamWrBuff->TestFlag(WBF_SAVE_FOR_XML) &&
               Tag() != ETAG_GENERIC
                    ? NamespaceHtml() : Namespace();

    if (pszScopeName)
    {
        hr = pStreamWrBuff->Write(pszScopeName);
        if(hr)
            goto Cleanup;

        hr = pStreamWrBuff->Write(_T(":"));
        if(hr)
            goto Cleanup;
    }

    hr = pStreamWrBuff->Write(pszTagName);
    if(hr)
        goto Cleanup;

    if(!fEnd)
    {
        BOOL fAny;

        hr = SaveAttributes(pStreamWrBuff, &fAny);
        if(hr)
            goto Cleanup;

        if (ETAG_HTML == etag)
        {
            Assert (IsInMarkup());

            hr = THR(GetMarkup()->SaveXmlNamespaceAttrs(pStreamWrBuff));
            if (hr)
                goto Cleanup;
        }

        // If saving as an atomic tag, add a trailing slash
        if( fAtomic )
        {
            hr = THR( pStreamWrBuff->Write(_T(" /"), 2 ) );
            if( hr )
                goto Cleanup;
        }
    }

    hr = pStreamWrBuff->Write(_T(">"), 1);
    if (hr)
        goto Cleanup;

#if 0
    if(fEnd && HasFlag(TAGDESC_SAVENEWLINEATEND))
    {
            hr = pStreamWrBuff->NewLine();
            if (hr)
                    goto Cleanup;
    }
#endif

Cleanup:
    pStreamWrBuff->RestoreFlags(dwOldFlags);

    RRETURN(hr);
}


HRESULT STDMETHODCALLTYPE
CElement::scrollIntoView(VARIANTARG varargStart)
{
    HRESULT                hr;
    SCROLLPIN              spVert;
    BOOL                   fStart;
    CVariant               varBOOLStart;

    hr = THR(varBOOLStart.CoerceVariantArg(&varargStart, VT_BOOL));
    if ( hr == S_OK )
    {
        fStart = V_BOOL(&varBOOLStart);
    }
    else if ( hr == S_FALSE )
    {
        // when no argument
        fStart = TRUE;
    }
    else
        goto Cleanup;

    spVert = fStart ? SP_TOPLEFT : SP_BOTTOMRIGHT;

    hr = THR(ScrollIntoView(spVert, SP_TOPLEFT));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::DeferScrollIntoView(SCROLLPIN spVert, SCROLLPIN spHorz )
{
    HRESULT hr;

    GWKillMethodCall (this, ONCALL_METHOD(CElement, DeferredScrollIntoView, deferredscrollintoview), 0);
    hr = THR(GWPostMethodCall (this, ONCALL_METHOD(CElement, DeferredScrollIntoView, deferredscrollintoview),
                                (DWORD_PTR)(spVert | (spHorz << 16)), FALSE, "CElement::DeferredScrollIntoView"));
    return hr;
}

void
CElement::DeferredScrollIntoView(DWORD_PTR dwParam)
{
    SCROLLPIN spVert = (SCROLLPIN)((DWORD)dwParam & 0xffff);
    SCROLLPIN spHorz = (SCROLLPIN)((DWORD)dwParam >> 16);

    IGNORE_HR(ScrollIntoView(spVert, spHorz));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetAtomTable, virtual override from CBase
//
//-------------------------------------------------------------------------

CAtomTable *
CElement::GetAtomTable (BOOL *pfExpando)
{
    CAtomTable  *pat = NULL;
    CDoc        *pDoc;

    pDoc = Doc();
    if (pDoc)
    {
        pat = &(pDoc->_AtomTable);
        if (pfExpando)
        {
            CMarkup *pMarkupContext = IsInMarkup() ? GetMarkupPtr()->GetWindowedMarkupContext()
                                                   : (HasWindowedMarkupContextPtr() ?  GetWindowedMarkupContextPtr() : NULL);
            *pfExpando = pMarkupContext ? pMarkupContext->_fExpando : TRUE;
        }
    }

    // We should have an atom table otherwise there's a problem.
    Assert(pat && "Element is not associated with a CDoc.");

    return pat;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetPlainTextInScope
//
//  Synopsis:   Returns a text string containing all the plain text in the
//              scope of this element. The caller must free the memory.
//              This function can be used to merely retrieve the text
//              length by setting ppchText to NULL.
//
//  Arguments:  pstrText    If NULL,
//                              no text is returned.
//                          If not NULL but there is no text,
//                              *pstrText is set to NULL.
//                          Otherwise
//                              *pstrText points to a new CStr
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetPlainTextInScope(CStr * pstrText)
{
    HRESULT     hr = S_OK;
    long        cp, cch;

    Assert(pstrText);

    if(!IsInMarkup())
    {
        pstrText->Set(NULL);
        goto Cleanup;
    }

    cp = GetFirstCp();
    cch = GetElementCch();

    {
        CTxtPtr     tp( GetMarkup(), cp );

        cch = tp.GetPlainTextLength(cch);

        // copy text into buffer

        pstrText->SetLengthNoAlloc(0);
        hr = pstrText->ReAlloc(cch);
        if (hr)
        {
            pstrText->Set(NULL);
            goto Cleanup;
        }

        cch = tp.GetPlainText(cch, (LPTSTR)*pstrText);

        Assert(cch >= 0);

        if (cch)
        {
            // Terminate with 0. GetPlainText() does not seem to do this.
            pstrText->SetLengthNoAlloc(cch);
            *(LPTSTR(*pstrText) + cch) = 0;
        }
        else
        {
            // just making sure...
            pstrText->Free();
        }
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Member: GetAccessKey & MatchAccessKey
//
//-----------------------------------------------------------------------------

// In lieu of the C Run-time function _totlower() that we are not linking with
#define TOTLOWER(ch)  (TCHAR((DWORD)(DWORD_PTR)CharLower((LPTSTR)(DWORD_PTR)ch)))
// TODO - yinxie, need to make sure this will work for non IBM compatible keyboards
// Caps Lock scan code = 0x3a, all keys higher than this will not be allowed in access key
#ifndef UNIX
#define ISVALIDKEY(x)   (((x >> 16) & 0x00FF) < 0x3a)
#else
inline BOOL ISVALIDKEY(LPARAM x) { return (MwCharacterFromWM_KEY(x) != 0); }
#endif

#define VIRTKEY_TO_SCAN 0

VOID
ConvertMessageToUnicode(CMessage* pmsg, WCHAR* pwchKey )
{
    Assert( pwchKey );
    *pwchKey = (TCHAR) pmsg->wParam;

    if(pmsg->message == WM_SYSKEYDOWN && pmsg->wParam > 31)
    {
        BYTE bKeyState[256];
        if(GetKeyboardState(bKeyState))
        {
            WORD cBuf[2];
            int cchBuf;
            HKL hkl = GetKeyboardLayout(0);

            UINT wScanCode = MapVirtualKeyEx(pmsg->wParam, VIRTKEY_TO_SCAN, hkl);
            cchBuf = ToAsciiEx(pmsg->wParam, wScanCode, bKeyState, cBuf, 1, hkl);

            if(cchBuf == 1)
            {
                WCHAR wBuf[2];
                UINT  uKbdCodePage = GetKeyboardCodePage();

                MultiByteToWideChar(uKbdCodePage, 0, (char *)cBuf, 2, wBuf, 2);
                *pwchKey = wBuf[0];
            }
        }
    }   
}

BOOL
CElement::MatchAccessKey(CMessage * pmsg, long lSubDivision, WCHAR* pwch )
{
    // TODO (MohanB) lSubDivision is ignored for now. Should make this work
    // to get accesskey working on AREAs.

    BOOL    fMatched = FALSE;
    LPCTSTR lpAccKey = GetAAaccessKey();
    WCHAR chKey;
    
    // Raid 57053
    // If we are in HTML dialog, accessKey can be matched with/without
    // SHIFT/CTRL/ALT keys.
    //
    if ( ! pwch )
    {
        pwch = & chKey;     
        ConvertMessageToUnicode( pmsg, pwch );
    }
    
    // 60711 - Translate the virtkey to unicode for foreign languages.
    // We only test for 0x20 (space key) or above. This way we avoid
    // coming in here for other system type keys

 
    if ((pmsg->message == WM_SYSKEYDOWN ||
                    (Doc()->_fInHTMLDlg && pmsg->message == WM_CHAR))
            && lpAccKey
            && lpAccKey[0]
            && TOTLOWER((TCHAR) *pwch) == TOTLOWER(lpAccKey[0])
            && ISVALIDKEY(pmsg->lParam))
    {
        fMatched = TRUE;
    }
    return fMatched;
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowMessage
//
//--------------------------------------------------------------------------

HRESULT __cdecl
CElement::ShowMessage(
        int * pnResult,
        DWORD dwFlags,
        DWORD dwHelpContext,
        UINT  idsMessage, ...)
{
    CDoc *              pDoc = Doc();
    HRESULT             hr = S_OK;
    va_list             arg;

    va_start(arg, idsMessage);

    if (pDoc)
    {
        hr = THR(pDoc->ShowMessageV(
            pnResult,
            dwFlags,
            dwHelpContext,
            idsMessage,
            &arg));
    }

    va_end(arg);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowMessageV
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowMessageV(
                int   * pnResult,
                DWORD   dwFlags,
                DWORD   dwHelpContext,
                UINT    idsMessage,
                void  * pvArgs)
{
    RRETURN (Doc()->ShowMessageV(pnResult, dwFlags, dwHelpContext, idsMessage, pvArgs));
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowLastErrorInfo
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowLastErrorInfo(HRESULT hr, int iIDSDefault)
{
    RRETURN (Doc()->ShowLastErrorInfo(hr, iIDSDefault));
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowHelp
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowHelp(TCHAR * szHelpFile, DWORD dwData, UINT uCmd, POINT pt)
{
    RRETURN (Doc()->ShowHelp(szHelpFile, dwData, uCmd, pt));
}

CBase *CElement::GetOmWindow(CMarkup * pMarkup /* = NULL */)
{
    if (!pMarkup && IsInMarkup())
    {
        pMarkup = GetMarkup();
    }

    if (pMarkup)
    {
        Assert(!IsInMarkup() || pMarkup == GetMarkup());
      
        return pMarkup->Window();
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::UndoManager
//
//  Synopsis:   Get the undo manager
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
IOleUndoManager *
CElement::UndoManager()
{
    return Doc()->UndoManager();
}
#endif // NO_EDIT

//+-------------------------------------------------------------------------
//
//  Method:     CElement::QueryCreateUndo
//
//  Synopsis:   Query whether to create undo or not.  Also dirties the doc.
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
BOOL
CElement::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = FALSE */, BOOL * pfTreeSync /* = NULL */)
{
    if( pfTreeSync )
    {
        CMarkup * pMarkup;
        *pfTreeSync = FALSE;

        if( IsInMarkup() )
        {
            pMarkup = GetMarkup();
            
            *pfTreeSync = pMarkup->HasLogManager() && pMarkup->GetLogManager()->IsAnyoneListening();
        }
    }

    if( fDirtyChange && IsInMarkup() )
    {
        GetMarkup()->SetDirtyFlag();
    }

    return Doc()->QueryCreateUndo( fRequiresParent, fDirtyChange, NULL );
}

HRESULT
CElement::LogAttributeChange( CStyle * pStyle, DISPID dispidProp, VARIANT * pvarOld, VARIANT * pvarNew )
{
    CMarkup * pMarkup;
    ATTR_CHANGE_FLAGS lFlags = ATTR_CHANGE_NONE;
    CBase * pBase = this;

    AssertSz( IsInMarkup(), "Shouldn't be trying to log attr change w/out a markup" );
    pMarkup = GetMarkup();

    Assert( pMarkup->HasLogManager() && pMarkup->GetLogManager()->IsAnyoneListening() );

    if( pStyle )
    {
        lFlags = ( GetRuntimeStylePtr() == pStyle ) ? ATTR_CHANGE_RUNTIMESTYLE : ATTR_CHANGE_INLINESTYLE;
        pBase = pStyle;
    }

    IGNORE_HR( pMarkup->GetLogManager()->AttrChangeProp( this, pBase, lFlags, dispidProp, pvarOld, pvarNew ) );

    return S_OK;
}

#endif // NO_EDIT


//+-------------------------------------------------------------------------
//
//  Method:     CElement::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowTooltipInternal(CMessage *pmsg, POINT pt, CDoc * pDoc)
{
    HRESULT hr = S_FALSE;
    RECT    rc;
    TCHAR * pchString;
    BOOL fRTL = FALSE;

    if (pDoc->State() < OS_INPLACE)
        goto Cleanup;

#if DBG == 1
    TCHAR  achBuf[100];

    if (IsTagEnabled(tagFormatTooltips))
    {
        CTreeNode *pNode = pmsg->pNodeHit;

        Format(0,
               achBuf,
               100,
               L"<0s>  SN=<1d>\n_iCF=<2d>  _iPF=<3d>  _iFF=<4d>",
               pNode->Element()->TagName(),
               pNode->SN(),
               pNode->_iCF,
               pNode->_iPF,
               pNode->_iFF);

        pchString = achBuf;
    }
    else
#endif
    //
    // if there is a title property, use it as tooltip
    //

    pchString = (LPTSTR) GetAAtitle();
    if (pchString != NULL)
    {
        GetElementRc(&rc, GERC_CLIPPED | GERC_ONALINE, &pt);

        //It is possible to have an empty rect when an
        //element doesn't have a TxtSite above it.
        //Should this be an ASSERT or TODO?
        if(IsRectEmpty(&rc))
        {
            rc.left = pt.x - 10;
            rc.right = pt.x + 10;
            rc.top = pt.y - 10;
            rc.bottom = pt.y + 10;
        }

        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        // COMPLEXSCRIPT - determine if element is right to left for tooltip style setting
        if(GetFirstBranch())
        {
            fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;
        }
        
        if (!pDoc->_pDocPopup)
        {
            FormsShowTooltip(pchString, pDoc->_pInPlace->_hwnd, *pmsg, &rc, (DWORD_PTR) GetMarkup(), (DWORD_PTR) this, fRTL);
        }

        hr = S_OK;
    }

Cleanup:
    return hr;
}

#ifndef WIN16
BEGIN_TEAROFF_TABLE(CElementFactory, IDispatchEx)
    //  IDispatch methods
    TEAROFF_METHOD(super, GetTypeInfoCount, gettypeinfocount, (UINT *pcTinfo))
    TEAROFF_METHOD(super, GetTypeInfo, gettypeinfo, (UINT itinfo, ULONG lcid, ITypeInfo ** ppTI))
    TEAROFF_METHOD(super, GetIDsOfNames, getidsofnames, (REFIID riid,
                                          LPOLESTR *prgpsz,
                                          UINT cpsz,
                                          LCID lcid,
                                          DISPID *prgid))
    TEAROFF_METHOD(super, Invoke, invoke, (DISPID dispidMember,
                                   REFIID riid,
                                   LCID lcid,
                                   WORD wFlags,
                                   DISPPARAMS * pdispparams,
                                   VARIANT * pvarResult,
                                   EXCEPINFO * pexcepinfo,
                                   UINT * puArgErr))
    TEAROFF_METHOD(super, GetDispID, getdispid, (BSTR bstrName,
                                      DWORD grfdex,
                                      DISPID *pid))
    TEAROFF_METHOD(CElementFactory, InvokeEx, invokeex, (DISPID id,
                             LCID lcid,
                             WORD wFlags,
                             DISPPARAMS *pdp,
                             VARIANT *pvarRes,
                             EXCEPINFO *pei,
                             IServiceProvider *pSrvProvider))
    TEAROFF_METHOD(super, DeleteMemberByName, deletememberbyname, (BSTR bstr,DWORD grfdex))
    TEAROFF_METHOD(super, DeleteMemberByDispID, deletememberbydispid, (DISPID id))
    TEAROFF_METHOD(super, GetMemberProperties, getmemberproperties, (DISPID id,
                                                DWORD grfdexFetch,
                                                DWORD *pgrfdex))
    TEAROFF_METHOD(super, GetMemberName, getmembername, (DISPID id,
                                          BSTR *pbstrName))
    TEAROFF_METHOD(super, GetNextDispID, getnextdispid, (DWORD grfdex,
                                          DISPID id,
                                          DISPID *pid))
    TEAROFF_METHOD(super, GetNameSpaceParent, getnamespaceparent, (IUnknown **ppunk))
END_TEAROFF_TABLE()
#endif

HRESULT
CElementFactory::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
#ifndef WIN16
        QI_TEAROFF_DISPEX(this, NULL)
#else
    case Data1_IDispatchEx:
        CBase::PrivateQueryInterface(iid, ppv);
        break;
#endif
    QI_TEAROFF(this, IObjectIdentity, NULL)

    default:
        {
            const CLASSDESC *pclassdesc = (const CLASSDESC *) BaseDesc();
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface ))
            {
                hr = THR(CreateTearOffThunk(this, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
            }
        }
    }

    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

HRESULT
CElementFactory::InvokeEx(DISPID dispidMember,
                          LCID lcid,
                          WORD wFlags,
                          DISPPARAMS * pdispparams,
                          VARIANT * pvarResult,
                          EXCEPINFO * pexcepinfo,
                          IServiceProvider *pSrvProvider)
{
    if ( (wFlags & DISPATCH_CONSTRUCT) && (dispidMember == DISPID_VALUE) )
    {
        // turn it into a method call ( expect dispid=0 )
        wFlags &= ~DISPATCH_CONSTRUCT;
        wFlags |= DISPATCH_METHOD;
    }

    RRETURN(super::InvokeEx(dispidMember,
                            lcid,
                            wFlags,
                            pdispparams,
                            pvarResult,
                            pexcepinfo,
                            pSrvProvider));
}


//+----------------------------------------------------------------------------
//
//  Method: LogAttrArray
//
//  Synopsis: Logs the attribute array differences to the Log Manager
//      One AttrArray can be null signifying a CLEAR of an attr array.
//
//      [CStyle *]      pStyle          -   Style object for attr arrays, or NULL
//      [CAttrArray *]  pAttrArrayOld   -   Attr Array of old values
//      [CAttrArray *]  pAttrArrayNew   -   Attr Array of new values
//
//+----------------------------------------------------------------------------
HRESULT CElement::LogAttrArray( CStyle * pStyle, CAttrArray * pAttrArrayOld, CAttrArray *pAttrArrayNew )
{
    CAttrValue * pAVOld;
    CAttrValue * pAVNew;
    CAttrValue * pAV;
    long         cAV;
    CBase      * pBase = pStyle ? (CBase *)pStyle : (CBase *)this;

    AssertSz( pAttrArrayOld || pAttrArrayNew, "Only one attr array can be null here" );

    if( pAttrArrayOld && pAttrArrayNew && pAttrArrayOld->Size() != pAttrArrayNew->Size() )
    {
        AssertSz( FALSE, "Unbalanced Attr Arrays" );
        return E_FAIL;
    }

    pAVOld = pAttrArrayOld ? (CAttrValue *)*pAttrArrayOld : NULL;
    pAVNew = pAttrArrayNew ? (CAttrValue *)*pAttrArrayNew : NULL;
    pAV    = pAVOld ? pAVOld : pAVNew;
    cAV = pAttrArrayOld ? pAttrArrayOld->Size() : pAttrArrayNew->Size();

    for( ; cAV; cAV-- )
    {
        VARIANT                 vtOld;
        VARIANT                 vtNew;
        DISPID                  dispid;
        const PROPERTYDESC  *   pPropDesc;

        // TODO (JHarding): Skipping the nested inline style attr array for now
        if( pAV->GetAAType() == CAttrValue::AA_AttrArray )
            goto NextAttr;

        if( pAV->GetPropDesc() )
        {
            pPropDesc = pAV->GetPropDesc();
            dispid = pPropDesc->GetDispid();
        }
        else
        {
            dispid = pAV->GetDISPID();
            pBase->FindPropDescFromDispID( dispid, const_cast<PROPERTYDESC **>(&pPropDesc), NULL, NULL );
        }

        AssertSz( pPropDesc, "Couldn't find propdesc!" );
        if( pPropDesc )
        {
            VariantInit( &vtOld );
            VariantInit( &vtNew );

            if( pAVOld )
                pAVOld->GetIntoDispatchableVariant( &vtOld, pPropDesc );
            if( pAVNew )
                pAVNew->GetIntoDispatchableVariant( &vtNew, pPropDesc );

            IGNORE_HR( LogAttributeChange( pStyle, dispid, &vtOld, &vtNew ) );

            VariantClear(&vtOld);
            VariantClear(&vtNew);
        }

NextAttr:
        if( pAVOld )
            pAVOld++;
        if( pAVNew )
            pAVNew++;
        pAV++;
    }

    return S_OK;
}
//+----------------------------------------------------------------------------
//
// Member:      CopyCommonAttributes
//
// Synopsis:    Copy the common attributes for a given element to the current
//              element (generally used when replacing an element with another
//              while editing).
//
//-----------------------------------------------------------------------------

HRESULT
CElement::MergeAttributes(CElement *pElementFrom, BOOL fCopyID)
{
    HRESULT         hr = S_OK;
    CAttrArray *    pInLineStyleAAFrom;
    CAttrArray **   ppInLineStyleAATo;
    CAttrArray *    pAAFrom = *(pElementFrom->GetAttrArray());
    CBase *         pelTarget = this;
    CAttrArray *    pAttrUndo = NULL;
    CAttrArray *    pAttrSync = NULL;
    CAttrArray *    pAttrStyleUndo = NULL;
    CAttrArray *    pAttrStyleSync = NULL;
    CMergeAttributesUndo Undo( this );
    BOOL            fCreateUndo;
    BOOL            fTreeSync;

    if (pElementFrom->Tag() == Tag())
        pelTarget = NULL;

    Undo.SetWasNamed( _fIsNamed );
    Undo.SetCopyId( fCopyID );
    Undo.SetPassElTarget( !!pelTarget );

    fCreateUndo = QueryCreateUndo( TRUE, FALSE, &fTreeSync );
    if( pAAFrom && ( fCreateUndo || fTreeSync ) )
    {
        pAttrUndo       = new CAttrArray();
        pAttrStyleUndo  = new CAttrArray();
        if( !pAttrUndo || !pAttrStyleUndo )
        {
            // If we couldn't make these two arrays, we're hosed.
            fTreeSync = FALSE;
            fCreateUndo = FALSE;

            delete pAttrUndo;
            delete pAttrStyleUndo;
        }

        if( fTreeSync )
        {
            pAttrSync      = new CAttrArray();
            pAttrStyleSync = new CAttrArray();

            if( !pAttrSync || !pAttrStyleSync )
            {
                // If we couldn't make these two arrays, tree sync is hosed
                fTreeSync = FALSE;

                delete pAttrSync;
                delete pAttrStyleSync;
            }
        }
    }

    if (pAAFrom)
    {
        CAttrArray     **ppAATo = GetAttrArray();

        hr = THR(pAAFrom->Merge(ppAATo, pelTarget, pAttrUndo, pAttrSync, FALSE, fCopyID));
        if (hr)
            goto Cleanup;

        SetEventsShouldFire();

        // If the From has is a named element then the element is probably changed.
        if (pElementFrom->_fIsNamed && fCopyID)
        {
            _fIsNamed = TRUE;
            // Inval all collections affected by a name change
            DoElementNameChangeCollections();
        }

        pInLineStyleAAFrom = pElementFrom->GetInLineStyleAttrArray();
        if (pInLineStyleAAFrom && pInLineStyleAAFrom->Size())
        {
            ppInLineStyleAATo = CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
            if (!ppInLineStyleAATo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = THR(pInLineStyleAAFrom->Merge(ppInLineStyleAATo, NULL, pAttrStyleUndo, pAttrStyleSync));
            if (hr)
                goto Cleanup;
        }

        if( fTreeSync )
        {
            CStyle     * pStyle = NULL;

            if( pAttrStyleSync->Size() )
                IGNORE_HR( GetStyleObject( &pStyle ) );

            IGNORE_HR( LogAttrArray( NULL, pAttrUndo, pAttrSync ) );
            IGNORE_HR( LogAttrArray( pStyle, pAttrStyleUndo, pAttrStyleSync ) );
                
            delete pAttrSync;
            delete pAttrStyleSync;
        }

        if( fCreateUndo )
        {
            Undo.SetAA( pAttrUndo );
            Undo.SetAAStyle( pAttrStyleUndo );
        }
        else
        {
            delete pAttrUndo;
            delete pAttrStyleUndo;
        }
    }

    IGNORE_HR(Undo.CreateAndSubmit());

Cleanup:

    RRETURN(hr);
}

HRESULT
CElement::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;
    CTreeNode * pNodeForm;
    CTreeNode * pNodeContext = GetFirstBranch();
    CMarkup *   pMarkup;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    if (pNodeContext && pNodeContext->Parent())
    {
        pNodeForm = pNodeContext->Parent()->SearchBranchToRootForTag( ETAG_FORM );

        if (pNodeForm)
        {
            hr = THR( pNodeForm->GetElementInterface( IID_IDispatchEx, (void **) ppunk ) );

            goto Cleanup;
        }
    }

    pMarkup = GetMarkup();
    if (!pMarkup)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(pMarkup->GetDefaultDocument()->PrivateQueryInterface(IID_IDispatchEx, (void**) ppunk));

Cleanup:

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::CanShow
//
//  Synopsis:   Determines whether an element can be shown at this moment.
//
//--------------------------------------------------------------------------
BOOL
CElement::CanShow()
{
    BOOL fRet = TRUE;
    CTreeNode *pNodeSite = GetFirstBranch()->GetUpdatedNearestLayoutNode();

    while (pNodeSite)
    {
        if (!pNodeSite->Element()->GetInfo(GETINFO_ISCOMPLETED))
        {
            fRet = FALSE;
            break;
        }
        pNodeSite = pNodeSite->GetUpdatedParentLayoutNode();
    }
    return fRet;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::OnCssChangeStable
//
//-------------------------------------------------------------------------

HRESULT
CElement::OnCssChange(BOOL fStable, BOOL fRecomputePeers)
{
    HRESULT     hr = S_OK;

    if (IsInMarkup())
    {
        hr = THR(GetMarkup()->OnCssChange(fStable, fRecomputePeers));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Invalidate
//
//  Synopsis:   Invalidates the area occupied by the element.
//
//-------------------------------------------------------------------------
void
CElement::Invalidate()
{
    if(!IsInMarkup())
        return;

    SendNotification(NTYPE_ELEMENT_INVALIDATE);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetElementRc
//
//  Synopsis:   Get the bounding rect for the element
//
//  Arguments:  prc:      the rc to be returned
//              dwFlags:  flags indicating desired behaviour
//                           GERC_ONALINE: rc on a line, line indicated by ppt.
//                           GERC_CLIPPED: rc clipped by visible client rect.
//              ppt:      the point around which we want the rect
//
//  Returns:    hr
//
//--------------------------------------------------------------------------

HRESULT
CElement::GetElementRc(RECT *prc, DWORD dwFlags, POINT *ppt)
{
    CDataAry<RECT> aryRects(Mt(CElementGetElementRc_aryRects_pv));
    HRESULT        hr = S_FALSE;
    LONG           i;

    Assert(prc);

    // make sure that current will be calced
    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    // Get the region for the element
    GetElementRegion(&aryRects,
                    !(dwFlags & GERC_ONALINE)
                        ? prc
                        : NULL,
                    RFE_SCREENCOORD);

    if (dwFlags & GERC_ONALINE)
    {
        Assert(ppt);
        for (i = 0; i < aryRects.Size(); i++)
        {
            if (PtInRect(&aryRects[i], *ppt))
            {
                *prc = aryRects[i];
                hr = S_OK;
                break;
            }
        }
    }

    if (   (S_OK == hr)
        && (dwFlags & GERC_CLIPPED)
       )
    {
        CRect      rcVisible;
        CDispNode *pDispNode;
        CLayout   *pLayout = GetUpdatedNearestLayout();

        if(!pLayout)
        {
            CElement *pElementClient = CMarkup::GetElementClientHelper(GetMarkup());
            if(pElementClient)
                pLayout = pElementClient->GetUpdatedNearestLayout();
            else
            {
                prc->left = prc->top = prc->right = prc->bottom = 0;
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        Assert(pLayout);
        pDispNode = pLayout->GetElementDispNode(this);

        if (!pDispNode)
        {
            pDispNode = pLayout->GetElementDispNode(pLayout->ElementOwner());
        }


        if (pDispNode)
        {
            pDispNode->GetClippedBounds(&rcVisible, COORDSYS_GLOBAL);
            IntersectRect(prc, prc, &rcVisible);
        }
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Member:      CElement::ComputeHorzBorderAndPadding
//
// Synopsis:    Compute horizontal border and padding for a given element
//              The results represent cumulative border and padding up the
//              element's ancestor chain, up to but NOT INCLUDING element's
//              containing layout.  The layout's border should not be counted
//              when determining a contained element's indent, because it lies
//              outside the box boundary from which we are measuring.  The 
//              layout's padding usually does need to be accounted for; the caller
//              must do this! (via GetPadding on the layout's CDisplay).
//
//-----------------------------------------------------------------------------

void
CElement::ComputeHorzBorderAndPadding(CCalcInfo * pci, CTreeNode * pNodeContext, CElement * pElementStop,
                                  LONG * pxBorderLeft, LONG * pxPaddingLeft,
                                  LONG * pxBorderRight, LONG * pxPaddingRight)
{
    Assert(pNodeContext && SameScope(this, pNodeContext));

    Assert(pxBorderLeft || pxPaddingLeft || pxBorderRight || pxPaddingRight);

    CTreeNode * pNode = pNodeContext;
    CBorderInfo borderinfo;
    CElement *  pElement;
    const CFancyFormat * pFF;
    const CParaFormat *  pPF;
    const CCharFormat *  pCF;
    BOOL fNodeVertical;
    BOOL fWritingModeUsed;

    Assert(pxBorderLeft && pxPaddingLeft && pxBorderRight && pxPaddingRight);

    *pxBorderLeft = 0;
    *pxBorderRight = 0;
    *pxPaddingLeft = 0;;
    *pxPaddingRight = 0;

    while(pNode && pNode->Element() != pElementStop)
    {
        pElement = pNode->Element();
        pFF = pNode->GetFancyFormat();
        pPF = pNode->GetParaFormat();
        pCF = pNode->GetCharFormat();
        fNodeVertical = pCF->HasVerticalLayoutFlow();
        fWritingModeUsed = pCF->_fWritingModeUsed;

        // We only want to compute the border and padding for 
        // block elements. Inline border and padding should not
        // be accounted for here.
        if (pFF->_fBlockNess)
        {
            if ( !pElement->_fDefinitelyNoBorders )
            {
                pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, pci, &borderinfo, GBIH_NONE );

                *pxBorderRight  += borderinfo.aiWidths[SIDE_RIGHT];
                *pxBorderLeft   += borderinfo.aiWidths[SIDE_LEFT];
            }

            *pxPaddingLeft  += pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed).XGetPixelValue(pci,
                                        pci->_sizeParent.cx, pPF->_lFontHeightTwips);
            *pxPaddingRight += pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed).XGetPixelValue(pci,
                                        pci->_sizeParent.cx, pPF->_lFontHeightTwips);
        }

        pNode = pNode->Parent();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::Clone
//
//  Synopsis:   Make a new one just like this one
//
//-------------------------------------------------------------------------

HRESULT
CElement::Clone ( CElement * * ppElementClone, CDoc * pDoc )
{
    HRESULT          hr;
    CAttrArray *     pAA;
    CStr             cstrPch;
    CElement       * pElementNew = NULL;
    const CTagDesc * ptd;
    CHtmTag          ht;
    BOOL             fDie = FALSE;
    ELEMENT_TAG      etag = Tag();
    
    Assert( ppElementClone );

    if (IsGenericTag( etag ))
    {
        hr = THR( cstrPch.Set( Namespace() ) );

        if (hr)
            goto Cleanup;

        hr = THR( cstrPch.Append( _T( ":" ) ) );

        if (hr)
            goto Cleanup;

        hr = THR( cstrPch.Append( TagName() ) );

        if (hr)
            goto Cleanup;
    }
    else if (etag == ETAG_UNKNOWN)
    {
        hr = THR( cstrPch.Append( TagName() ) );

        if (hr)
            goto Cleanup;
    }

    ptd = TagDescFromEtag( etag );

    if (!ptd)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ht.Reset();
    ht.SetTag( etag );
    ht.SetPch( cstrPch );
    ht.SetCch( cstrPch.Length() );

    if (etag == ETAG_INPUT)
    {
        hr = THR(CInput::CreateElement(&ht, pDoc, &pElementNew, (htmlInput)(DYNCAST(CInput, this)->GetType())));
        if (hr)
            goto Cleanup;

        DYNCAST(CInput, pElementNew)->_fScriptCreated = TRUE;
    }
    else
        hr = ptd->_pfnElementCreator( & ht, pDoc, & pElementNew );

    if (hr)
        goto Cleanup;

    if (fDie)
        goto Die;

    hr = THR( pElementNew->Init() );

    if (hr)
        goto Cleanup;

    if (fDie)
        goto Die;

    pElementNew->_fBreakOnEmpty = _fBreakOnEmpty;
    pElementNew->_fExplicitEndTag = _fExplicitEndTag;

    pAA = * GetAttrArray();

    if (pAA)
    {
        CAttrArray * * ppAAClone = pElementNew->GetAttrArray();

        hr = THR( pAA->Clone( ppAAClone ) );

        if (hr)
            goto Cleanup;

        if (fDie)
            goto Die;
    }

    pElementNew->_fIsNamed = _fIsNamed;

    if( HasIdentityPeerHolder() )
    {
        ht.SetExtendedTag();
        ht.SetDynamic();
    }

    {
        CInit2Context   context(&ht, IsInMarkup() ? GetMarkupPtr() : GetWindowedMarkupContext(), INIT2FLAG_EXECUTE);

        hr = THR( pElementNew->Init2(&context) );
    }
    if (hr)
        goto Cleanup;

    if (etag == ETAG_INPUT)
    {
        CStr cstrValue;

        hr = THR(DYNCAST(CInput, this)->GetValueHelper(&cstrValue));
        if (hr)
            goto Cleanup;

        hr = THR(DYNCAST(CInput, pElementNew)->SetValueHelper(&cstrValue));
        if (hr)
            goto Cleanup;
    }

    if (fDie)
        goto Die;

    pElementNew->SetEventsShouldFire();

    if (ETAG_RAW_COMMENT == etag)
    {
        hr = THR(DYNCAST(CCommentElement, pElementNew)->_cstrText.Set(DYNCAST(CCommentElement, this)->_cstrText));
        if  (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr && pElementNew)
        CElement::ClearPtr( & pElementNew );

    *ppElementClone = pElementNew;
    RRETURN(hr);

Die:
    hr = E_ABORT;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::StealAttributes, public
//
//  Synopsis:   Steals the attributes from another element.
//
//  Arguments:  [pElementVictim] -- Element to steal attributes from.
//
//  Returns:    HRESULT
//
//  Notes:      Used when we want to replace one element with another, after
//              we've computed all the formats and created the attribute bag.
//
//----------------------------------------------------------------------------

HRESULT
CElement::StealAttributes(CElement * pElementVictim)
{
    _pAA = pElementVictim->_pAA;
    pElementVictim->_pAA = NULL;


    // TODO rgardner - Why do we do this ? Why not just steal the attr array & the format indices,
    // and set the indices in the victim to -1 ????


    // After we have stolen the attr array, we must adjust
    // any addrefs for images that the victim may be holding on to.

    if (pElementVictim->_fHasImage)
    {
        int n;
        long lCookie;

        // Add ref any image context cookies this element holds

        for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
        {
            if ( _pAA->FindSimple(s_aryImgDispID[n].cacheID, (DWORD *)&lCookie,
                                  CAttrValue::AA_Internal) )
            {
                CDoc *  pDoc = Doc();

                // Replace ref on victim with one on thief
                pDoc->AddRefUrlImgCtx(lCookie, this);
                pDoc->ReleaseUrlImgCtx(lCookie, pElementVictim);
            }
        }

        _fHasImage = TRUE;
        pElementVictim->_fHasImage = FALSE;
    }

    // some of the properties depend on the element being
    // a site so do not copy format indicies.

    return S_OK;
}



//+-----------------------------------------------------------------
//
//  members : get_filters
//
//  synopsis : IHTMLELement implementaion to return the filter collection
//
//-------------------------------------------------------------------
HRESULT
CElement::get_filters(IHTMLFiltersCollection **ppFilters)
{
    HRESULT    hr;
    BOOL       fAdded;

    CFilterBehaviorSite *  pFilterSite;

    // make sure ComputeFormats is called so that filter tasks are interted
    //  into the queue
    CTreeNode * pNode = GetFirstBranch();
    if (!pNode)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // This will ensure that the filter string is available
    pNode->GetFancyFormatIndex();

    // Make sure that all the pending filters re created
    Doc()->ExecuteFilterTasks(&fAdded);

    hr = THR(EnsureFilterBehavior(FALSE, &pFilterSite));
    if(FAILED(hr))
        goto Cleanup;

    Assert(pFilterSite);

    hr = THR(pFilterSite->GetIHTMLFiltersCollection(ppFilters));

    if(fAdded)
    {
        // make sure GetSize is being called on filters
        hr = THR(EnsureRecalcNotify());
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};

HRESULT
CElement::setCapture(VARIANT_BOOL containerCapture)
{
    HRESULT hr = S_OK;
    CDoc * pDoc = Doc();

    if (!pDoc || (pDoc->State() < OS_INPLACE) || pDoc->_fOnLoseCapture)
        goto Cleanup;

    pDoc->SetMouseCapture(
            MOUSECAPTURE_METHOD(CElement, HandleCaptureMessage, handlecapturemessage),
            this,
            containerCapture == VB_TRUE);
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::releaseCapture()
{
    TakeCapture(FALSE);
    RRETURN(SetErrorInfo(S_OK));
}

BOOL
CElement::HasCapture()
{
    return Doc()->HasCapture(this);
}

BOOL
CElement::WantTextChangeNotifications()
{
    if( !CurrentlyHasAnyLayout() )
        return FALSE;

    // TODO (KTam): Rewrite this to be cleaner.
    // Basically we're trying to do an IsListening call, which
    // tells us whether a flow layout has been calc'ed or not.
    // Think about implementing a virtual IsListening on CLayoutInfo
    // and keeping current CFlowLayout::IsListening as a non-virtual
    // helper (for perf, since IsListening is called heavily inside
    // CFlowLayout).
    CFlowLayout * pFlowLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->IsFlowLayout();
    if( pFlowLayout && pFlowLayout->IsListening() )
        return TRUE;

    return FALSE;
}

void
CElement::Notify(CNotification * pnf)
{
    CFilterBehaviorSite *  pFilterSite;
    IStream *              pStream = NULL;

    Assert(pnf);

    if (HasPeerHolder())
    {
        GetPeerHolder()->OnElementNotification(pnf);
    }

    switch (pnf->Type())
    {
    
    case NTYPE_MARKUP_RENDER_STYLE:
    {
        if ( HasSlavePtr() &&
             GetSlavePtr()->GetMarkup()->GetElementClient() )
        {
            CNotification nf;
            CTreePos* ptpFirst;
            CTreePos* ptpEnd;
            CMarkup* pMarkup = GetSlavePtr()->GetMarkup();
            
            pMarkup->GetElementClient()->GetTreeExtent( & ptpFirst, & ptpEnd );    
            nf.MarkupRenderStyle( ptpFirst->GetCp(), ptpEnd->GetCp() - ptpFirst->GetCp(), pnf->DataAsPtr() );
            
            pMarkup->Notify( & nf );
        }
    }
    break;
    
    case NTYPE_AMBIENT_PROP_CHANGE:
        pFilterSite = GetFilterSitePtr();
        if (pFilterSite)
        {
            DISPID  dispid;
            ICSSFilter   * pICSSFilter = NULL;

            pnf->Data(&dispid);
            if(!pFilterSite->GetICSSFilter(&pICSSFilter))
            {
                pICSSFilter->OnAmbientPropertyChange(dispid);
                pICSSFilter->Release();
            }
        }
        Invalidate();
        break;

    case NTYPE_COMMAND:
        pFilterSite = GetFilterSitePtr();
        if (pFilterSite)
        {
            COnCommandExecParams *  pParams;

            pnf->Data((void **)&pParams);
            pFilterSite->OnCommand(pParams);
        }
        break;

    case NTYPE_FAVORITES_LOAD:
    case NTYPE_XTAG_HISTORY_LOAD:
    case NTYPE_SNAP_SHOT_SAVE:
        {
            IHTMLPersistData *  pPersist = GetPeerPersist();

            if (pPersist)
            {
                CPtrAry<CElement *> *   pary;

                pnf->Data((void **)&pary);
                pary->Append(this);
                pPersist->Release();
            }
        }
        break;

    case NTYPE_ACTIVE_MOVIE:
        if (Tag() != ETAG_INPUT && HasSlavePtr())
        {
            CElement *      pElemSlave  = GetSlavePtr();
            CNotification   nf;
            void * pv;

            Assert(pElemSlave && pElemSlave->Tag() == ETAG_ROOT);

            pnf->Data(&pv);

            nf.ActiveMovie(pElemSlave, pv);
            pElemSlave->SendNotification(&nf);
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CElement *  pElemSlave = GetSlavePtr();
        
            if (pElemSlave->IsInMarkup())
            {
                pnf->SetSecondChanceRequested();
            }
        }
        break;

    case NTYPE_XTAG_HISTORY_SAVE:
        {
            void * pv;

            pnf->Data(&pv);
            IGNORE_HR(TryPeerPersist(XTAG_HISTORY_SAVE, pv));
        }
        // Follow through in the normal SAVE_HISTORY notification since we need to
        // bubble the notification to any viewlinked elements.

    case NTYPE_SAVE_HISTORY_2:
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CElement *  pElemSlave = GetSlavePtr();
        
            if (pElemSlave->IsInMarkup())
            {
                HRESULT             hr = S_OK;
                CHistorySaveCtx *   phsc;

                pnf->Data((void **)&phsc);

                hr = THR(phsc->BeginSaveStream((0xF000000 | GetSourceIndex()), HistoryCode(), &pStream));
                if (hr)
                    goto Cleanup;

                pElemSlave->GetMarkup()->SaveHistoryInternal(pStream, phsc->_dwOptions);

                hr = THR(phsc->EndSaveStream());
                if (hr)
                    goto Cleanup;
            }
        }
        break;

    case NTYPE_FAVORITES_SAVE:
        {
            void * pv;

            pnf->Data(&pv);
            IGNORE_HR(TryPeerPersist(FAVORITES_SAVE, pv));
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        {
            CMarkup * pMarkup = GetMarkup();
            CDoc *  pDoc = pMarkup->Doc();
            CMarkupTransNavContext * ptnc = pMarkup->GetTransNavContext();

            if (ptnc && ptnc->_historyCurElem.lIndex >= 0 &&
                HistoryCode() == ptnc->_historyCurElem.dwCode)
            {
                long   lSrcIndex  = GetSourceIndex();

                Assert(lSrcIndex >= 0);

                if (   !pMarkup->_fUserInteracted 
                    &&  lSrcIndex == ptnc->_historyCurElem.lIndex)
                {
                    if (IsEnabled())
                    {
                        pDoc->_fFirstTimeTab = FALSE;
                        BecomeCurrent(ptnc->_historyCurElem.lSubDivision);
                    }
                    
                    // found the current element
                    ptnc->_historyCurElem.lIndex = -1;
                    pMarkup->EnsureDeleteTransNavContext(ptnc);
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITVIEW_1:
        // If we have expressions on this elements remove them from the recalc engine 
        // they will be re-added when the element comes back into view
        SuspendExpressionRecalc();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if( HasPeerHolder() || HasAccObjPtr() )
        {
            pnf->SetData( pnf->DataAsDWORD() | EXITTREE_DELAYRELEASENEEDED );
        }

#ifndef NO_DATABINDING
        if (GetDataMemberManager())
        {
            GetDataMemberManager()->Notify(pnf);
        }
#endif

        // Remove this element's expressions (if any) from the recalc engine
        SuspendExpressionRecalc();

        ExitTree( pnf->DataAsDWORD() );

        // Notify slave tree (however, INPUT slave tree is not interesting
        // and doesn't need to hear this).
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            Assert(_fExittreePending);
            if (IsConnectedToPrimaryWindow())
            {
                // Requrest second-chance since olesites may inplace-deactivate
                // on exitview.
                if (GetSlavePtr()->GetMarkup()->GetObjectRefs() > 1)
                {
                    pnf->SetSecondChanceRequested();
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        // Notify slave tree (however, INPUT slave tree is not interesting
        // and doesn't need to hear this).
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CNotification   nf;
            CElement *      pElemSlave = GetSlavePtr();

            Assert(pElemSlave->Tag() == ETAG_ROOT);

            // Send ExitView notify to the slave tree since it is
            // getting diconnected from the primary markup.
            // For perf reasons we do that only if there is more than 
            // one reference to the master

            nf.ElementExitview1(pElemSlave);

            // TODO (greglett)
            // ExitView does not notify self - so we need to manually notify the ROOT element.
            // Right now, self and second-chance are mutually exclusive.  We need to fix this.
            pElemSlave->Notify(&nf);

            pElemSlave->SendNotification(&nf);
        }
        break;

    case NTYPE_RELEASE_EXTERNAL_OBJECTS:
        // NOTE in most cases we don't receive the notification
        if (HasPeerHolder())
        {
            // delete peer holder ptr and release the peer holder
            DelPeerHolder()->PrivateRelease();
        }
        break;

    case NTYPE_RECOMPUTE_BEHAVIOR:
        IGNORE_HR(ProcessPeerTask(PEERTASK_RECOMPUTEBEHAVIORS));
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_ELEMENT_ENTERVIEW_1:
        EnterView();
        break;

    case NTYPE_VISIBILITY_CHANGE:
// TODO:   Sanitize this by making official throughout the code that layout-like notifications
//         targeted at positioned elements without layouts are re-directed to the nearest layout.
//         This redirection should be done in CMarkup::NotifyElement rather than ad hoc. (brendand)
//        Assert(GetFirstBranch()->GetCascadedposition() == stylePositionrelative);
        Assert(!ShouldHaveLayout());
        {
            CLayout *   pLayout = GetUpdatedNearestLayout();

            if (pLayout)
            {
                WHEN_DBG(pnf->ResetSN());
                pLayout->Notify(pnf);
            }
        }
        break;

    case NTYPE_MARKUP_UNLOAD_2:
        if (HasSlavePtr())
        {
            CElement *  pElemSlave = GetSlavePtr();
            
            if (pElemSlave && 
                pElemSlave->IsInMarkup() &&
                pElemSlave->GetMarkup()->HasWindow())
            {
                pElemSlave->GetMarkup()->TearDownMarkup();
            }
        }
        
        break;

    case NTYPE_MARKUP_UNLOAD_1:
        if (HasSlavePtr())
        {
            pnf->SetSecondChanceRequested();
        }

        // Fall thru
    case NTYPE_STOP_1:
        if (pnf->Type() != NTYPE_MARKUP_UNLOAD_1)
        {
            if (HasSlavePtr())
            {
                CElement *  pElemSlave = GetSlavePtr();
            
                if (pElemSlave && pElemSlave->IsInMarkup())
                {
                    pElemSlave->GetMarkup()->ExecStop();
                }
            }
        }
        // Fall thru
        
    case NTYPE_STOP_2:
    case NTYPE_BEFORE_UNLOAD:
        if (HasPeerMgr())
        {
            CPeerMgr * pPeerMgr = GetPeerMgr();
            pPeerMgr->DelDownloadProgress();
        }
#ifndef NO_DATABINDING
        if (GetDataMemberManager())
        {
            GetDataMemberManager()->Notify(pnf);
        }
#endif
        break;


    case NTYPE_ELEMENT_INVAL_Z_DESCENDANTS:
        {
            // TODO (carled) this notification should really be unnecessary. what it
            // (and the one above) are crying for is a Notifcation for OnPropertyChange
            // so that descendants can take specific action.  More generally, there are
            // other OPP things like VoidCachedInfo that are duplicating the Notification
            // logic (walking the subtree) which could get rolled into this.  unifiying 
            // these things could go a long way to streamlining the code, and preventing
            // inconsistencies and lots of workarounds. (like this notification)
            //
            // This notification is targeted at positioned elements which are children of 
            // the element that sent it. We do not want to delegate to the nearest Layout
            // since if they are positioned, they have thier own. Since the source element2
            // may not have a layout we have to use the element tree for the routing.

            CLayoutInfo *   pLayoutInfo = GetUpdatedLayoutInfo();

            if (IsPositioned())
            {
                if (pLayoutInfo)
                {
                    WHEN_DBG(pnf->ResetSN());
                    pLayoutInfo->Notify(pnf);
                }
                else
                {
                    Invalidate();
                }
            }
        }
        break;
    case NTYPE_SHOW_WAIT_CURSOR:
        if (HasSlavePtr())
        {
            CElement *pElemSlave = GetSlavePtr();

            if (pElemSlave && pElemSlave->IsInMarkup())
            {
                Assert(pnf->IsDataValid());
                pElemSlave->GetMarkup()->_fShowWaitCursor = pnf->DataAsDWORD() ? TRUE : FALSE;
            }
        }
        break;
    case NTYPE_CHANGE_ACCELERATOR:
        {
            for (CTreeNode *pNode = GetFirstBranch();
                 pNode != NULL;
                 pNode = pNode->NextBranch()
                )
            {
                if (pNode->GetCharFormat()->_fAccelerator)
                {
                    pNode->VoidCachedInfo();
                    Assert(pnf->IsDataValid());
                    // Indicate that there are still accelerators around
                    pnf->SetData((DWORD)1);
                }
            }
        }
        break;
    } // switch
    
Cleanup:
    ClearInterface(&pStream);
    return;
}

HRESULT
CElement::EnterTree()
{
    HRESULT         hr;
    CDoc *          pDoc = Doc();
    CMarkup *       pMarkup;
    InlineEvts *    pInlineEvts;
    BOOL            fInView = IsConnectedToPrimaryWindow();

    Assert( IsInMarkup() );

    pMarkup = GetMarkup();

    // hook up any script for\event handlers attached to this id'd element
    if (pMarkup->_fHasScriptForEvent && !pMarkup->_fMarkupServicesParsing && IsNamed() && (Tag() != ETAG_SCRIPT))
    {
        IGNORE_HR(pDoc->CommitScripts(pMarkup, this));
    }

    // Connect up event handlers...
    if (!pMarkup->_fMarkupServicesParsing || (Tag() == ETAG_OBJECT))
    {
        pInlineEvts = GetEventsToHook();
        if (pInlineEvts)
        {
            BOOL fConnect = TRUE;
            if (pMarkup->HasBehaviorContext())
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                fConnect = pComponent ? !pComponent->_fFactoryComponent : TRUE;
            }

            if (fConnect)
                pInlineEvts->Connect(pDoc, this);

            delete pInlineEvts;
            StoreEventsToHook(NULL);
        }
    }

    // While we're in a markup, we'll use its WMC ptr
    if ( HasWindowedMarkupContextPtr() )
        DelWindowedMarkupContextPtr()->SubRelease();

    // behaviors
    hr = THR(ProcessPeerTask(PEERTASK_ENTERTREE_UNSTABLE));
    if (hr)
        goto Cleanup;

    // other
    if (fInView)
    {
        EnterView();
    }
    
    //  Init is currently called in the procedure that actually creates the layout.
    //  It does not need to be called here.
    //if (ShouldHaveLayout())
    //{
    //    GetUpdatedLayout()->Init();
    //}
 
    if (pMarkup->CollectionCache())
    {
        OnEnterExitInvalidateCollections(FALSE);
    }

    if (HasSlavePtr() && HasDefaults())
    {
        CDefaults * pDefaults = GetDefaults();

        // Make sure that a cycle is not being created
        Assert(GetSlavePtr()->GetMarkup());

        if (IsCircularViewLink(GetSlavePtr()->GetMarkup()))
        {
            // Found a cycle! Break the viewLink
            hr = THR(pDefaults->put_viewLink(NULL));
            if (hr)
                goto Cleanup;

            Assert(!HasSlavePtr());
#if DBG == 1
            {
                IHTMLDocument * pISlave = NULL;
                Assert(S_OK == pDefaults->get_viewLink(&pISlave) && !pISlave);
            }
#endif
        }
    }

    if (fInView && HasSlavePtr())
    {
        // broadcast an ENTERVIEW notification to the slave content
        CElement *      pElemSlave  = GetSlavePtr();
        CNotification   nf;

        Assert(pElemSlave && pElemSlave->Tag() == ETAG_ROOT);
        nf.ElementEnterview1(pElemSlave);

        // TODO (greglett)
        // EnterView does not notify self - so we need to manually notify the ROOT element.
        // Right now, self and second-chance are mutually exclusive.  We need to fix this.
        pElemSlave->Notify(&nf);

        // INPUTs never have an interesting markup.  Their tree doesn't need to hear this.
        if (Tag() != ETAG_INPUT)
            pElemSlave->SendNotification(&nf);
    }

Cleanup:
    
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::EnterView
//
//  Synopsis:   Update the focus collection, initiate data binding, etc.
//
//-------------------------------------------------------------------------

void
CElement::EnterView()
{
    CDoc * pDoc = Doc();

    AttachDataBindings();
    if (_fSurface)
    {
        ++ pDoc->_cSurface;
    }
    if (_f3DSurface)
    {
        ++ pDoc->_c3DSurface;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::ExitTree
//
//  Synopsis:   Remove the element from the tree, cleanup
//
//-------------------------------------------------------------------------

void
CElement::ExitTree( DWORD dwExitFlags )
{
    CMarkup         * pMarkup = GetMarkup();
    CDoc            * pDoc  = pMarkup->Doc();
    CLayout         * pLayout;   

    Assert(IsInMarkup());
    
    pDoc->OnElementExit(this, dwExitFlags);
    
    if (!pMarkup->_fInnerHTMLMarkup)
    {
        if( !(dwExitFlags & EXITTREE_DESTROY))
        {
            pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
    
            if (!IsParentFrozen() &&
                ((pLayout &&  pLayout->IsAdorned()) ||
                ShouldHaveLayout()))
            {
                Assert( pLayout && "Should always have a layout due to, thought we might not need it" );
                //
                // We now send the notification for adorned elements - or 
                // any LayoutElement leaving the tree.
                //
                //
                // TODO marka - make this work via the adorner telling the selection manager
                // to change state. Also make sure _fAdorned is cleared on removal of the Adorner
                //
                IUnknown* pUnknown = NULL;
                IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
                IGNORE_HR( pDoc->NotifySelection( EDITOR_NOTIFY_EXIT_TREE , pUnknown ));
                ReleaseInterface( pUnknown );
            }
            pLayout = NULL;
        }
    
        if (pDoc->GetView()->HasAdorners())
        {
            Verify(pDoc->GetView()->OpenView());
            pDoc->GetView()->RemoveAdorners(this);
        }
    
    }
    if (pMarkup->HasCollectionCache())
    {
        OnEnterExitInvalidateCollections(FALSE);
    }

    //
    // Filters do not survive tree changes
    //
    if (_fHasPendingFilterTask)
    {
        pDoc->RemoveFilterTask(this);
        Assert(!_fHasPendingFilterTask);
    }

    // If we don't have any lookasides we don't have to do *any* of the following tests!
    if (_fHasLookasidePtr)
    {
        if (HasPeerHolder() && !(dwExitFlags & EXITTREE_PASSIVATEPENDING))
        {
            IGNORE_HR(ProcessPeerTask(PEERTASK_EXITTREE_UNSTABLE));
        }

#ifndef NO_DATABINDING
        if (HasDataBindPtr())
        {
            DetachDataBindings();
        }
#endif

        if (HasPeerMgr())
        {
            CPeerMgr * pPeerMgr = GetPeerMgr();
            pPeerMgr->OnExitTree();
        }

        //  According to an old, ex-comment: This must happen after the filter has been detached.
        if ( (_fSurface || _f3DSurface) &&
             ( (dwExitFlags & EXITTREE_DOSURFACECOUNT) ||
               (!(dwExitFlags & EXITTREE_DESTROY) && IsConnectedToPrimaryMarkup())
             ))
        {
            if (_fSurface)
            {
                Assert(Doc()->_cSurface > 0);
                Doc()->_cSurface--;
            }
            if (_f3DSurface)
            {
                Assert(Doc()->_c3DSurface > 0);
                Doc()->_c3DSurface--;
            }
        }

        // If we've queued layout requests on other layouts, we need to
        // mark the request as dead, since we're leaving the tree and don't
        // need to be serviced.  Refs on the CRequest obj are held by the
        // corresponding layouts, so we don't need to release here -- instead
        // we'll let the layout's ProcessRequests take care of it.
        if (HasRequestPtr())
        {
            GetRequestPtr()->RemoveFromLayouts();
            AssertSz( !HasRequestPtr(), "Removing from layouts should have caused request to go away!" );
        }
    }

    // Remember our WMC before we go back to the ether
    Assert( !HasWindowedMarkupContextPtr() );

    // TODO (JHarding) - If we can't set this pointer, this element is in bad shape.
    if( !SetWindowedMarkupContextPtr( GetWindowedMarkupContext() ) )
        GetWindowedMarkupContextPtr()->SubAddRef();

    if (HasLayoutPtr())
    {
        CLayout *   pLayout;

        GetUpdatedLayout()->OnExitTree();

        if (!_fLayoutAlwaysValid)
        {
            pLayout = DelLayoutPtr();

            pLayout->Detach();
            pLayout->Release();
        }
    }
    // We may have multiple layouts!
    else if ( HasLayoutAry() )
    {
        CLayoutAry *pLA;

        pLA = GetLayoutAry();
        pLA->OnExitTree();

        if ( !_fLayoutAlwaysValid )
        {
            DelLayoutAry(); // will take care of detaching/releasing its layouts
        }            
    }
}

//+------------------------------------------------------------------------
//  Member:     CElement::SuspendExpressionRecalc
//
//  Synopsis:   If we have expressions on this element remove them from the 
//              recalc engine - they will be re-added to the recalc engine 
//              when the element comes back into view
//-------------------------------------------------------------------------

void
CElement::SuspendExpressionRecalc()
{
    CDoc    * pDoc =  Doc();

    if (_fHasPendingRecalcTask)
        pDoc->RemoveExpressionTask(this);

    if (_fHasExpressions)
        pDoc->_recalcHost.removeAllExpressions(this);
}

//+---------------------------------------------------------------------------------
//
//  Member :    CElement::IsEqualObject()
//
//  Synopsis :  IObjectIdentity method implementation. it direct comparison of two
//              pUnks fails, then the script engines will QI for IObjectIdentity and
//              call IsEqualObject one one, passing in the other pointer.
//
//   Returns : S_OK if the Objects are the same
//             E_FAIL if the objects are different
//
//----------------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::IsEqualObject(IUnknown * pUnk)
{
    HRESULT      hr = E_POINTER;
    IServiceProvider * pISP = NULL;
    IUnknown   * pUnkTarget = NULL;
    IUnknown   * pUnkThis = NULL;

    if (!pUnk)
        goto Cleanup;

    hr = THR_NOTRACE(QueryInterface(IID_IUnknown, (void **)&pUnkThis));
    if (hr)
        goto Cleanup;

    if (pUnk == pUnkThis)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IServiceProvider, (void**)&pISP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pISP->QueryService(SID_ELEMENT_SCOPE_OBJECT,
                                        IID_IUnknown,
                                        (void**)&pUnkTarget));
    if (hr)
        goto Cleanup;

    hr = (pUnkThis == pUnkTarget) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pUnkThis);
    ReleaseInterface(pUnkTarget);
    ReleaseInterface(pISP);
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method : CElement :: QueryService
//
//  Synopsis : IServiceProvider methoid Implementaion.
//
//-----------------------------------------------------------------------------
HRESULT
CElement::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    if (IsEqualGUID(guidService, SID_ELEMENT_SCOPE_OBJECT))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvObject));
    }
    else if (IsEqualGUID(guidService, CLSID_HTMLWindow2))
    {
        CMarkup * pMarkup = GetNearestMarkupForScriptCollection();

        Assert(pMarkup);
        Assert(pMarkup->HasWindow());

        *ppvObject = pMarkup->Window()->Window();

        hr = S_OK;
    }
    else if (IsEqualGUID(guidService, IID_IAccessible))
    {
        CAccBase * pAccObj = GetAccObjOfElement(this);

        // The pointer we receive is not addref'd QI for IAccessible and return that.
        // To make sure, we expect that the riid == IID_IAccessible

        // It is possible to receive a NULL pointer from the function call in case
        // the element is not accessible.
        if (pAccObj)
        {
            hr = THR(pAccObj->QueryInterface( riid, ppvObject));
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        hr = THR_NOTRACE(super::QueryService(guidService, riid, ppvObject));
        if (hr == E_NOINTERFACE)
        {
            if (IsInMarkup())
            {
                CDocument * pDocument = GetMarkup()->Document();
                
                if (pDocument)
                {
                    hr = THR_NOTRACE(pDocument->QueryService(guidService, riid, ppvObject));
                }
            }
            else
            {
                hr = THR_NOTRACE(Doc()->QueryService(guidService, riid, ppvObject));
            }
        }
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextThunk_Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CElement::ContextThunk_Invoke(
        DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pdispparams,
        VARIANT * pvarResult,
        EXCEPINFO * pexcepinfo,
        UINT *)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT         hr;
    IDispatchEx    *pDispEx;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    if (!pUnkContext)
        pUnkContext = (IUnknown*)this;

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->InvokeExMulti(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL));
        if (DISP_E_MEMBERNOTFOUND != hr) // if succeced or failed with error other then DISP_E_MEMBERNOTFOUND
            goto Cleanup;
    }

    hr = THR(pUnkContext->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));
    if (hr)
    {
        // Object doesn't support IDispatchEx use CBase::InvokeEx
        hr = ContextInvokeEx(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL,
            pUnkContext ? pUnkContext : (IUnknown*)this);
    }
    else
    {
        // Object supports IDispatchEx call InvokeEx thru it's v-table.
        hr = pDispEx->InvokeEx(dispidMember, lcid, wFlags, pdispparams,pvarResult, pexcepinfo, NULL);
        ReleaseInterface(pDispEx);
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif


//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextThunk_InvokeEx, IDispatchEx
//
//  Synopsis:   Gets node context from eax and passes it to ContextInvokeEx
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP CElement::ContextThunk_InvokeEx(DISPID dispidMember,
                                             LCID lcid,
                                             WORD wFlags,
                                             DISPPARAMS * pdispparams,
                                             VARIANT * pvarResult,
                                             EXCEPINFO * pexcepinfo,
                                             IServiceProvider *pSrvProvider)
{
    HRESULT     hr;
    IUnknown *  pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    hr = THR_NOTRACE(CElement::ContextInvokeEx(dispidMember,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  pSrvProvider,
                                  pUnkContext ? pUnkContext : (IUnknown*)this));

    RRETURN (hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextInvokeEx, IDispatchEx
//
//  Synopsis:   Real implementation of InvokeEx.  Uses context passed
//              in for actual calls
//
//--------------------------------------------------------------------------

STDMETHODIMP CElement::ContextInvokeEx(DISPID dispidMember,
                                    LCID lcid,
                                    WORD wFlags,
                                    DISPPARAMS * pdispparams,
                                    VARIANT * pvarResult,
                                    EXCEPINFO * pexcepinfo,
                                    IServiceProvider *pSrvProvider,
                                    IUnknown *pUnkContext)
{
    HRESULT     hr;

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->InvokeExMulti(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            pSrvProvider));
        if (DISP_E_MEMBERNOTFOUND != hr) // if succeced or failed with error other then DISP_E_MEMBERNOTFOUND
            goto Cleanup;
    }

    hr = THR_NOTRACE(CBase::ContextInvokeEx(dispidMember,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  pSrvProvider,
                                  pUnkContext ? pUnkContext : (IUnknown*)this));

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pid)
{
    HRESULT         hr;

    if (GetFrameOrPrimaryMarkup())
    {
        GetFrameOrPrimaryMarkup()->ProcessPeerTasks(0);
    }

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->GetDispIDMulti(bstrName, grfdex, pid));
        if (DISP_E_UNKNOWNNAME != hr) // if succeeded or failed with error other then DISP_E_UNKNOWNNAME
            goto Cleanup;
    }

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetExpandoDispID, helper
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetExpandoDispID(BSTR bstrName, DISPID * pid, DWORD grfdex)
{
    return GetExpandoDISPID(bstrName, pid, grfdex);
}

HRESULT
CElement::GetExpandoDISPID(LPTSTR pchName, DISPID *pid, DWORD grfdex)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetExpandoDispID(pchName, pid, grfdex));
    if (hr)
        goto Cleanup;

    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        DYNCAST(COleSite, this)->RemapActivexExpandoDispid(pid);
    }

Cleanup:

    RRETURN (hr);
}


//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetNextDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetNextDispID(DWORD grfdex, DISPID dispid, DISPID * pdispid)
{
    HRESULT         hr = S_FALSE;
    CPeerHolder *   pPeerHolder;

    if (!IsPeerDispid(dispid))
    {
        hr = THR_NOTRACE(super::GetNextDispID(grfdex, dispid, pdispid));
        if (S_FALSE != hr)  // if (S_OK == hr || FAILED(hr))
            goto Cleanup;
    }

    pPeerHolder = GetPeerHolder();

    if (pPeerHolder)
    {
        hr = THR_NOTRACE(pPeerHolder->GetNextDispIDMulti(grfdex, dispid, pdispid));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetMemberName, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetMemberName(DISPID dispid, BSTR * pbstrName)
{
    HRESULT         hr;

    if (IsPeerDispid(dispid))
    {
        CPeerHolder *   pPeerHolder = GetPeerHolder();

        if (pPeerHolder)
        {
            hr = THR_NOTRACE(pPeerHolder->GetMemberNameMulti(dispid, pbstrName));
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        goto Cleanup;   // done
    }

    hr = THR_NOTRACE(super::GetMemberName(dispid, pbstrName));

Cleanup:
    RRETURN2(hr, DISP_E_MEMBERNOTFOUND, DISP_E_UNKNOWNNAME);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetMultiTypeInfoCount, per IProvideMultipleClassInfo
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetMultiTypeInfoCount(ULONG * pCount)
{
    HRESULT     hr;

    if (GetReadyState() < READYSTATE_COMPLETE)
        RRETURN (E_UNEXPECTED);

    Assert (pCount);
    if (!pCount)
        RRETURN (E_POINTER);

    hr = THR(super::GetMultiTypeInfoCount(pCount));
    if (hr)
        goto Cleanup;

    if (HasPeerHolder())
    {
        hr = THR(GetPeerHolder()->GetCustomEventsTypeInfoCount(pCount));
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetInfoOfIndex, per IProvideMultipleClassInfo
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID *       piidPrimary,
    IID *       piidSource)
{
    HRESULT         hr;

    if (GetReadyState() < READYSTATE_COMPLETE)
        RRETURN (E_UNEXPECTED);

    if (HasPeerHolder())
    {
        hr = THR(GetPeerHolder()->CreateCustomEventsTypeInfo(iTI, ppTICoClass));
        if (S_FALSE != hr)  // if (S_OK == hr || FAILED(hr))
            goto Cleanup;   // nothing more to do
        // S_FALSE indicated that this belongs to super
    }

    hr = THR(super::GetInfoOfIndex(
        iTI, dwFlags, ppTICoClass, pdwTIFlags, pcdispidReserved, piidPrimary, piidSource));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::CreateTearOffThunk
//
//----------------------------------------------------------------------------

HRESULT
CElement::CreateTearOffThunk(
    void *      pvObject1,
    const void * apfn1,
    IUnknown *  pUnkOuter,
    void **     ppvThunk,
    void *      appropdescsInVtblOrder)
{
    CPeerHolder *   pPeerHolderInQI = GetPeerHolderInQI();
    if (pPeerHolderInQI)
    {
        return ::CreateTearOffThunk(
            pvObject1,
            apfn1,
            pUnkOuter,
            ppvThunk,
            pPeerHolderInQI,
            *(void **)(IUnknown *)pPeerHolderInQI,
            QI_MASK | ADDREF_MASK | RELEASE_MASK,
            NULL,
            appropdescsInVtblOrder);
    }
    else
    {
        return ::CreateTearOffThunk(
            pvObject1,
            apfn1,
            pUnkOuter,
            ppvThunk,
            appropdescsInVtblOrder);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::CreateTearOffThunk
//
//----------------------------------------------------------------------------

HRESULT
CElement::CreateTearOffThunk(
    void*       pvObject1,
    const void * apfn1,
    IUnknown *  pUnkOuter,
    void **     ppvThunk,
    void *      pvObject2,
    void *      apfn2,
    DWORD       dwMask,
    const IID * const * apIID,
    void *      appropdescsInVtblOrder)
{
    CPeerHolder *   pPeerHolderInQI = GetPeerHolderInQI();
    if (pPeerHolderInQI && !pvObject2)
    {
        pvObject2 = pPeerHolderInQI;
        apfn2 = *(void **)(IUnknown *)pPeerHolderInQI;
        dwMask |= QI_MASK | ADDREF_MASK | RELEASE_MASK;
    }

    return ::CreateTearOffThunk(
        pvObject1,
        apfn1,
        pUnkOuter,
        ppvThunk,
        pvObject2,
        apfn2,
        dwMask,
        apIID,
        appropdescsInVtblOrder);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::get_dir
//
//  Synopsis: Object model entry point to get the dir property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element supports this property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dir(BSTR * p)
{
    HRESULT hr;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if ( p )
        *p = NULL;

    hr = s_propdescCElementdir.b.GetEnumStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::put_dir
//
//  Synopsis: Object model entry point to put the dir property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value (ltr or rtl)
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_INVALIDARG          - the argument is not one of the enum string
//                                    values (ltr or rtl)
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dir(BSTR v)
{
    HRESULT hr;

    hr = s_propdescCElementdir.b.SetEnumStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Lookaside storage
//
//----------------------------------------------------------------------------

void *
CElement::GetLookasidePtr(int iPtr) const
{
#if DBG == 1
    if(HasLookasidePtr(iPtr))
    {
        void * pLookasidePtr =  Doc()->GetLookasidePtr((DWORD *)this + iPtr);

        Assert(pLookasidePtr == _apLookAside[iPtr]);

        return pLookasidePtr;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr(iPtr) ? Doc()->GetLookasidePtr((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CElement::SetLookasidePtr(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr |= 1 << iPtr;

#if DBG == 1
        _apLookAside[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CElement::DelLookasidePtr(int iPtr)
{
    if (HasLookasidePtr(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr((DWORD *)this + iPtr);
        _fHasLookasidePtr &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

void *
CElement::GetLookasidePtr2(int iPtr) const
{
#if DBG == 1
    if(HasLookasidePtr2(iPtr))
    {
        void * pLookasidePtr2 =  Doc()->GetLookasidePtr2((DWORD *)this + iPtr);

        Assert(pLookasidePtr2 == _apLookAside2[iPtr]);

        return pLookasidePtr2;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr2(iPtr) ? Doc()->GetLookasidePtr2((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CElement::SetLookasidePtr2(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr2(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr2((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr2 |= 1 << iPtr;

#if DBG == 1
        _apLookAside2[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CElement::DelLookasidePtr2(int iPtr)
{
    if (HasLookasidePtr2(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr2((DWORD *)this + iPtr);
        _fHasLookasidePtr2 &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside2[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Native accessibility support
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//  Member  :   AccObjForTag
//
//  Synopsis:   Creates and returns a CAccBase derived instance, 
//              depending on the tag of the element. If the tag is not supported
//              the tabindex is checked if the flag is set. 
//----------------------------------------------------------------------------
CAccElement * 
CElement::AccObjForTag()
{
    switch (Tag())
    {
        case ETAG_BODY:
        case ETAG_FRAMESET:
            return new CAccBody( this );
            break;

        case ETAG_A:
          return new CAccAnchor( this );
          break;

        case ETAG_AREA:
            return new CAccArea( this );
            break;

        case ETAG_BUTTON:
            return new CAccButton( this );
            break;

        case ETAG_IMG:
            return new CAccImage( this );
            break;

        case ETAG_MARQUEE:
            return new CAccMarquee( this );
            break;

        case ETAG_TEXTAREA:
            return new CAccEdit( this, FALSE);
            break;

        case ETAG_INPUT:
            {
                htmlInput type = DYNCAST(CInput, this)->GetAAtype();
                switch(type)
                {
                case htmlInputCheckbox:
                    return new CAccCheckbox( this );

                case htmlInputRadio:
                   return new CAccRadio( this );

                case htmlInputImage:
                    return new CAccInputImg( this );

                case htmlInputButton:
                case htmlInputReset:
                case htmlInputSubmit:
                    return new CAccButton( this );

                case htmlInputPassword:
                    return new CAccEdit( this, TRUE );

                case htmlInputText:
                case htmlInputHidden:
                    return new CAccEdit( this, FALSE );

                case htmlInputFile:
                    return new CAccInputFile( this );
                }
            }
            break;

        case ETAG_LABEL:
            return new CAccLabel(this);
            break;

        case ETAG_OBJECT:
        case ETAG_EMBED:
        case ETAG_APPLET:
            return new CAccObject( this );
            break;

        case ETAG_TABLE:
            return new CAccTable( this );
            break;

        case ETAG_TH:
        case ETAG_TD:
            return new CAccTableCell( this );
            break;

        case ETAG_SELECT:
            return new CAccSelect( this );
            break;

        default:
            // but wait there is one more check, if this element is normally
            // unsupported (not in the about cases) then we still want to
            // create an accObject if this element has an explicit tabstop set.
            if (GetAAtabIndex() != htmlTabIndexNotSet)
            {
                return new CAccTabStopped( this );
            }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//  Member  :   AccObjForBehavior
//  
//  Synopsis:   Get the accessible object for a behavior implementation.
//
//    1. A behavior that implements IAccessible:                        We want to create an AccBehavior that delegates
//    2. A behavior that does not implement IAccessible                 Return NULL and let CreatAccObj handle it
//    3. A view link without an attached that implements IAccessible    We want to create an AccBehavior that does not delegate
//
//----------------------------------------------------------------------------

CAccElement * 
CElement::AccObjForBehavior()
{
    CAccBehavior *  pAccBehavior = NULL;

    if (IsIAccessiblePeer(this))
    {
        pAccBehavior = new CAccBehavior(this, TRUE);      
    }                                                
    else if (HasSlavePtr() && Tag() != ETAG_INPUT)
    {
        pAccBehavior = new CAccBehavior(this, FALSE); 

        Assert(pAccBehavior);

        if (pAccBehavior)
        {
            IGNORE_HR(pAccBehavior->EnsureSubElement());
        }
    }

    return pAccBehavior;
}

//----------------------------------------------------------------------------
//  Member:   CElement::CreateAccObj
//
//  Synopsis: Creates and returns the proper accessibility object for this element
//
//    1. A behavior that implements IAccessible:                        We want to create an AccBehavior that delegates
//    2. A behavior that does not implement IAccessible                 If the tag is supported or there is a tabindex we want to create the appropriate AccObj
//    3. A view link without an attached that implements IAccessible    We want to create an AccBehavior that does not delegate
//    4. A normal tag without an attached that implements IAccessible   If the tag is supported or there is a tabindex we want to create the appropriate AccObj
//
//----------------------------------------------------------------------------

CAccElement *
CElement::CreateAccObj()
{
    CAccElement * pAcc = NULL;

    if (HasPeerHolder())
    {
        pAcc = AccObjForBehavior(); // Cases 1 and 3 (If 2 AccObjForBehavior will return NULL)
    }
    
    if (pAcc == NULL)
    {
        pAcc = AccObjForTag();      // Case  2 and 4
    }

    return pAcc;
}

CElement *
CElement::GetParentAncestorSafe(ELEMENT_TAG etag) const
{
    CTreeNode *pNode = GetFirstBranch();
    CElement  *p = NULL;
    if (pNode)
    {
        pNode = pNode->Parent();
        if (pNode)
        {
            pNode = pNode->Ancestor(etag);
            if (pNode)
                p = pNode->Element();
        }
    }
    return p;
}

CElement *
CElement::GetParentAncestorSafe(const ELEMENT_TAG *arytag) const
{
    CTreeNode *pNode = GetFirstBranch();
    CElement  *p = NULL;
    if (pNode)
    {
        pNode = pNode->Parent();
        if (pNode)
        {
            pNode = pNode->Ancestor(arytag);
            if (pNode)
                p = pNode->Element();
        }
    }
    return p;
}

//
// CElement Collection Helpers - manage the WINDOW_COLLECTION
//
HRESULT
CElement::GetIDHelper ( CStr *pf )
{
    LPCTSTR lpszID = NULL;
    HRESULT hr;

    if (_pAA && _pAA->HasAnyAttribute())
        _pAA->FindString(DISPID_CElement_id, &lpszID);

    hr = THR(pf->Set ( lpszID ));

    return hr;
}

HRESULT 
CElement::SetIdentifierHelper ( LPCTSTR lpszValue, DISPID dspIDThis, DISPID dspOther1, DISPID dspOther2 )
{
    HRESULT     hr;
    BOOL        fNamed;
    CDoc *      pDoc = Doc();
    CMarkup *   pMarkup = GetMarkup();

    // unhook any old script attached to this element.
    if (pMarkup && (Tag() != ETAG_SCRIPT) && IsNamed())
    {
        pDoc->CommitScripts(pMarkup, this, FALSE);
    }
    
    hr = AddString (dspIDThis, lpszValue, CAttrValue::AA_Attribute );
    if ( !hr )
    {
        // Remember if we're named, so that if this element moves into a different tree
        // we can inval the appropriate collections
        fNamed = lpszValue && lpszValue [ 0 ];
 
        // We're named if NAME= or ID= something or we have a unique name
        if ( !fNamed )
        {
            LPCTSTR lpsz = NULL;
            if (_pAA && _pAA->HasAnyAttribute())
            {
                _pAA->FindString(dspOther1, &lpsz);
                if ( !(lpsz && *lpsz ) )
                    _pAA->FindString(dspOther2, &lpsz);
            }
            fNamed = lpsz && *lpsz;
        }
        
        _fIsNamed = fNamed;
        // Inval all collections affected by a name change
        DoElementNameChangeCollections();

        // hook up any script for\event handlerw attached to this element thru new id
        if (pMarkup && (Tag() != ETAG_SCRIPT) && _fIsNamed)
        {
            pDoc->CommitScripts(pMarkup, this);
        }

    }

    RRETURN(hr);
}

HRESULT
CElement::SetIDHelper ( CStr *pf )
{
    RRETURN(SetIdentifierHelper((LPCTSTR)(*pf),
        DISPID_CElement_id,
        STDPROPID_XOBJ_NAME,
        DISPID_CElement_uniqueName));   
}

HRESULT
CElement::GetnameHelper ( CStr *pf )
{
    LPCTSTR lpszID = NULL;
    HRESULT hr;

    if (_pAA && _pAA->HasAnyAttribute())
        _pAA->FindString(STDPROPID_XOBJ_NAME, &lpszID);

    hr = THR(pf->Set ( lpszID ));

    return hr;
}

HRESULT
CElement::SetnameHelper ( CStr *pf )
{
    RRETURN(SetIdentifierHelper((LPCTSTR)(*pf),
        STDPROPID_XOBJ_NAME,
        DISPID_CElement_id,
        DISPID_CElement_uniqueName));   
}

HRESULT
CElement::SetUniqueNameHelper ( LPCTSTR szUniqueName )
{
    RRETURN(SetIdentifierHelper( szUniqueName,
        DISPID_CElement_uniqueName,
        DISPID_CElement_id,
        STDPROPID_XOBJ_NAME));   
}

void
CElement::InvalidateCollection ( long lIndex )
{
    CMarkup *pMarkup;
    CCollectionCache *pCollCache;

    pMarkup = GetMarkup();
    if ( pMarkup )
    {
        pCollCache = pMarkup->CollectionCache();
        if ( pCollCache )
        {
            pCollCache->InvalidateItem ( lIndex );
        }
    }
}

//
// Replace CBase::removeAttribute, need to special case some DISPID's
//

HRESULT 
CElement::removeAttribute(BSTR strPropertyName, LONG lFlags, VARIANT_BOOL *pfSuccess)
{
    DISPID dispID;
    IDispatchEx *pDEX = NULL;

    if (pfSuccess)
        *pfSuccess = VB_FALSE;

    // TODO rgardner should move the STDPROPID_XOBJ_STYLE
    // code from CBase::removeAttribute to here

    if (THR_NOTRACE(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX )))
        goto Cleanup;

    if (THR_NOTRACE(pDEX->GetDispID(strPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                                    fdexNameCaseSensitive : 0, &dispID)))
        goto Cleanup;

    if (!removeAttributeDispid(dispID))
        goto Cleanup;


    // If we remove name or ID, update the WINDOW_COLLECTION if needed
    // Don't need to deal with uniqueName here - it's not exposed externaly

    if ( dispID == DISPID_CElement_id || dispID == STDPROPID_XOBJ_NAME )
    {
        LPCTSTR lpszNameID = NULL;
        BOOL fNamed;

        // Named if ID or name is present
        if (_pAA && _pAA->HasAnyAttribute())
        {
            _pAA->FindString( dispID == DISPID_CElement_id ?
                    STDPROPID_XOBJ_NAME : 
                    DISPID_CElement_id, 
                &lpszNameID);
            if ( !(lpszNameID && *lpszNameID ) )
                _pAA->FindString(DISPID_CElement_uniqueName, &lpszNameID);
        }

        fNamed = lpszNameID && *lpszNameID;

        if ( fNamed != !!_fIsNamed )
        {
            // Inval all collections affected by a name change
            DoElementNameChangeCollections();
            _fIsNamed = fNamed;
        }
    }

    if (pfSuccess)
        *pfSuccess = VB_TRUE;

Cleanup:
    ReleaseInterface ( pDEX );

    RRETURN ( SetErrorInfo ( S_OK ) );
}


//----------------------------------------------------------------------------
//  Member:   CElement::Primitive(Get/Set)Expando
//
//  Synopsis: Gets or sets the given variant as an expando into the AA.
//            This does not fire any events, support undo, &c...
//
//----------------------------------------------------------------------------
HRESULT
CElement::PrimitiveSetExpando(BSTR bstrPropertyName, VARIANT varPropertyValue)
{
    HRESULT hr;
    DISPID  dispID;
    AAINDEX aaIdx;

    hr = THR(CBase::GetExpandoDispID(bstrPropertyName, &dispID, fdexNameEnsure));
    if (hr)
        goto Cleanup;

    aaIdx = FindAAIndex(dispID, CAttrValue::AA_Expando);

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        hr = AddVariant(dispID,
                        &varPropertyValue,
                        CAttrValue::AA_Expando);
    }
    else
    {
        hr = ChangeVariantAt(aaIdx, &varPropertyValue);
    }

Cleanup:
    return hr;
}

HRESULT
CElement::PrimitiveGetExpando(BSTR bstrPropertyName, VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DISPID  dispID;

    hr = CBase::GetExpandoDispID(bstrPropertyName, &dispID, 0);
    if (hr)
        goto Cleanup;

    hr = GetVariantAt(FindAAIndex(dispID, CAttrValue::AA_Expando),
                      pvarPropertyValue, /* fAllowNullVariant = */FALSE);

Cleanup:
    return hr;
}


HRESULT
CElement::PrimitiveRemoveExpando(BSTR bstrPropertyName)
{
    HRESULT hr;
    DISPID  dispID;

    hr = THR ( CBase::GetExpandoDispID(bstrPropertyName, &dispID, 0) );
    if (hr)
        goto Cleanup;

    DeleteAt(FindAAIndex(dispID, CAttrValue::AA_Expando));

Cleanup:
    return hr;
}

HRESULT
CElement::OnTabIndexChange()
{
    long                i;
    HRESULT             hr = S_OK;
    CMarkup           * pMarkup = GetMarkup();
    CAryFocusItem     * paryFocusItem;
    
    Assert (pMarkup);
    paryFocusItem = pMarkup->GetFocusItems(TRUE);
    Assert (paryFocusItem);

    for (i = 0; i < paryFocusItem->Size(); i++)
    {
        if ((*paryFocusItem)[i].pElement == this)
        {
            paryFocusItem->Delete(i);
        }
    }
    
    hr = THR(pMarkup->InsertFocusArrayItem(this));
    if (hr) 
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


void
CElement::OnEnterExitInvalidateCollections(BOOL fForceNamedBuild)
{
    //
    // Optimized collections
    // If a named (name= or ID=) element enters the tree, inval the collections
    //
    
    //
    // DEVNOTE rgardner
    // This code is tighly couples with CMarkup::AddToCollections and needs
    // to be kept in sync with any changes in that function
    //

    if (IsNamed() || fForceNamedBuild)
    {
        InvalidateCollection ( CMarkup::WINDOW_COLLECTION );
    }

    // Inval collections based on specific element types
    switch ( _etag )
    {
    case ETAG_LABEL:
        InvalidateCollection ( CMarkup::LABEL_COLLECTION );
        break;

    case ETAG_FRAME:
    case ETAG_IFRAME:
        InvalidateCollection ( CMarkup::FRAMES_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_IMG:
        InvalidateCollection ( CMarkup::IMAGES_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_OBJECT:
    case ETAG_APPLET:
        InvalidateCollection ( CMarkup::APPLETS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_SCRIPT:
        InvalidateCollection ( CMarkup::SCRIPTS_COLLECTION );
        break;

    case ETAG_MAP:
        InvalidateCollection ( CMarkup::MAPS_COLLECTION );
        break;

    case ETAG_AREA:
        InvalidateCollection ( CMarkup::LINKS_COLLECTION );
        break;

    case ETAG_EMBED:
        InvalidateCollection ( CMarkup::EMBEDS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_FORM:
        InvalidateCollection ( CMarkup::FORMS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_A:
        InvalidateCollection ( CMarkup::LINKS_COLLECTION );
        if (IsNamed() || fForceNamedBuild)
            InvalidateCollection ( CMarkup::ANCHORS_COLLECTION );
        break;
    }
}

void
CElement::DoElementNameChangeCollections(void)
{
    CMarkup *pMarkup;
    // Inval all the base collections, based on TAGNAme.
    // Force the WINDOW_COLLECTION to be built
    OnEnterExitInvalidateCollections ( TRUE );

    // Artificialy update the _lTreeVersion so any named collection derived from 
    // the ELEMENT_COLLECTION are inval'ed

    // This function is also called by the tree code when the page contains a 
    // <FORM> tag.  If we update the tree version here, CHtmRootParseCtx::FlushNotifications
    // will assume some thing is wrong and attempt to reload the page.
    // Assume the parser will update the version its self when needed.
        
    pMarkup = GetMarkup();
    if (pMarkup && !pMarkup->GetRootParseCtx())  // Parsing if GetRootParseCtx returns something.
        pMarkup->UpdateMarkupTreeVersion();    
}

HRESULT
InlineEvts::Connect(CDoc *pDoc, CElement *pElement)
{
    HRESULT     hr = S_OK;

    Assert(pDoc && pElement);

    //
    // Look over all scriptlets and hook them up
    //
    if (cScriptlets)
    {
        CMarkup *pMarkup = pElement->GetMarkup();
        if (pMarkup->GetScriptCollection())
        {
            BOOL        fRunScript;
            LPCTSTR     pchLanguage = NULL;
            hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
            if (hr || !fRunScript)
                goto Cleanup;

            for (int i = 0; i < cScriptlets; i++)
            {
                IGNORE_HR(pElement->ConnectInlineEventHandler(
                    adispidScriptlets[i],   // dispid
                    adispidScriptlets[i],   // dispidCode - in this case it is the same
                    aOffsetScriptlets[i],
                    aLineScriptlets[i],
                    TRUE,                   // fStandard
                    &pchLanguage));
            }
        }
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     IsConnectedToPrimaryWindow
//
//  Synopsis:   Chescks if the element is in amrkup connected (possibly through
//              pending markups) to the primary window. 
//
//-----------------------------------------------------------------------------
// TODO (jbeda) Handle HTCs?
BOOL
CElement::IsConnectedToPrimaryWindow()
{
    CMarkup * pMarkup           = GetMarkup();
    CMarkup * pMarkupPrimary    = Doc()->PrimaryMarkup();

    while (pMarkup)
    {
        if (pMarkup == pMarkupPrimary)
            return TRUE;

        if (pMarkup->Root()->HasMasterPtr())
        {
            pMarkup = pMarkup->Root()->GetMasterPtr()->GetMarkup();
        }
        else if (pMarkup->_fWindowPending)
        {
            Assert(!pMarkup->_fWindow);
            Assert(pMarkup != pMarkup->GetWindowPending()->Window()->Markup());
            pMarkup = pMarkup->GetWindowPending()->Window()->Markup();
        }
        else
            pMarkup = NULL;
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     SetViewSlave
//
//  Synopsis:   Sets up the slave/master ptrs, invalidates the layout, etc.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::SetViewSlave(CElement * pSlaveNew)
{
    HRESULT     hr          = S_OK;
    CElement*   pSlaveOld   = NULL;

    if (HasSlavePtr())
    {
        pSlaveOld = GetSlavePtr();
    }

    if (pSlaveOld == pSlaveNew)
        goto Cleanup;

    // A slave usually implies a flow layout, so we need to destroy the old layout if it is inappropriate.
    // TODO (greglett)
    // The slave may imply a CContainerLayout, in which case we want to destroy the old CContainerLayout
    // if it is not already the head of a chain.  Since this is optimization rather than critical logic,
    // we can revisit.
    if (HasLayoutPtr())
    {
        CLayout * pLayoutOld = GetLayoutPtr();

        BOOL fFlowLayout = !!pLayoutOld->IsFlowLayout();

        if (    !fFlowLayout
            || (    pSlaveOld
                &&  !pSlaveNew) )
        {
           Verify(pLayoutOld == DelLayoutPtr());
           pLayoutOld->Detach();
           pLayoutOld->Release();
        }
    }
    else if ( HasLayoutAry() )
    {
        BOOL fFlowLayout = GetLayoutAry()->IsFlowLayout();
        
        if (    !fFlowLayout
            || (    pSlaveOld
                &&  !pSlaveNew) )
        {
            DelLayoutAry(); // will take care of detaching/releasing its layouts
        }
    }


    // Detach old slave
    if (pSlaveOld)
    {
        if (Tag() != ETAG_INPUT && IsConnectedToPrimaryWindow())
        {
            CMarkup *       pMarkupOld = pSlaveOld->GetMarkup();
            CNotification   nf;

            Assert(pSlaveOld->Tag() == ETAG_ROOT);
            Assert(pMarkupOld);

            // TODO (MohanB) Hack for windowed slave markups not in frames (#106433)
            // These markups do not passivate due to a ref count loop. Should fix in v6.
            if (Tag() == ETAG_GENERIC && pMarkupOld->HasWindow())
            {
                pMarkupOld->TearDownMarkup(TRUE, TRUE);
            }

            // Send ExitView notify to the slave tree since it is
            // getting diconnected from the primary markup.
            // For perf reasons we do that only if there is more than 
            // one reference to the master

            if (pMarkupOld->GetObjectRefs() > 1)
            {
                pMarkupOld->_fSlaveInExitView = 1;
                nf.ElementExitview1(pSlaveOld);
                pSlaveOld->SendNotification(&nf);
                pMarkupOld->_fSlaveInExitView = 0;
            }
        }

        DelSlavePtr();
        pSlaveOld->DelMasterPtr();
        pSlaveOld->Release();
    }
    else
    {
        CNotification   nf;

        // no previous slave, but we still need to send exitview 
        // notifications to all the children of the generic element
        nf.ElementExitview1(this);
        SendNotification(&nf);
    }

    // validate & attach new slave
    if (pSlaveNew)
    {
        // Make sure that the slave and the master are in the same CDoc
        Assert(Doc() == pSlaveNew->Doc());

        // TODO (MohanB)
        // Move all this validation /cycle-detection code into another function
        // and call it lazily in EnsureView()
#if 0

        if (!IsInMarkup())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        if (!pSlaveNew->IsInMarkup())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        // check for potential cycles

        // 1. check that the slave is not on master's parent/master chain
        {
            CElement * pMaster = this;

            do
            {
                if (pSlaveNew == pMaster)
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                if (pMaster->HasMasterPtr())
                {
                    pMaster = pMaster->GetMasterPtr();
                }
                else
                {
                    // TODO (MohanB) What about overlapping?
                    CTreeNode * pNode = pMaster->GetFirstBranch();

                    if (pNode)
                    {
                        pNode = pNode->Parent();
                    }
                    pMaster = pNode ? pNode->Element() : NULL;
                }
            }
            while (pMaster);
        }

        // 2. check that the slave is not already in someone else's layout
        {
            CTreeNode * pNodeTest = pSlaveNew->GetFirstBranch();

            Assert(pNodeTest);

            pNodeTest = pNodeTest->Parent();
            while (pNodeTest)
            {
                if (pNodeTest->Element()->HasMasterPtr())
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                if (pNodeTest->Element()->HasSlavePtr())
                {
                    // The parent has a slave, which implies that this
                    // element's content isn't being rendered in that.
                    break;
                }
                else if (pNodeTest->Element()->ShouldHaveLayout())
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                pNodeTest = pNodeTest->Parent();

            }
        }
#endif // End of validation code       
               
        // we're not actually exiting the tree, just trying to get the 
        // editor to reposition the caret in a valid position    

        // TODO For some reason, this repositioning crashes the VID test, 
        // perhaps due to the input tag's use of viewlinking. So for now
        // we only reposition on generic tags. (peterlee)        
        if (Tag() == ETAG_GENERIC)
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            IGNORE_HR( Doc()->NotifySelection( EDITOR_NOTIFY_SETTING_VIEW_LINK , pUnknown ));
            ReleaseInterface( pUnknown );      
        }
        
        // attach
        SetSlavePtr(pSlaveNew);
        pSlaveNew->SetMasterPtr(this);
        pSlaveNew->AddRef();

        Doc()->_fHasViewSlave = TRUE;
    }

    // clear formats and force a lazy remeasure
    {
        DWORD dwFlags = ELEMCHNG_CLEARCACHES;
        
        if (Tag() != ETAG_INPUT && IsConnectedToPrimaryWindow())
        {
            dwFlags |= ELEMCHNG_SETTINGVIEWLINK;
        }

        EnsureFormatCacheChange(dwFlags);
    }

    //ResizeElement();
    RemeasureElement(NFLAGS_FORCE);

    if( pSlaveNew )
    {
        hr = THR(pSlaveNew->GetMarkup()->LoadSlaveMarkupHistory());
        pSlaveNew->GetMarkup()->_fLoadHistoryReady = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CElement::IsCircularViewLink(CMarkup * pMarkupSlave)
{
    CMarkup * pMarkupPrimary    = Doc()->PrimaryMarkup();
    CMarkup * pMarkupThis       = GetMarkup();

    Assert(pMarkupSlave);

    // Primary markup can never have a master
    Assert(pMarkupPrimary && !pMarkupPrimary->Root()->HasMasterPtr());

    while (pMarkupThis)
    {
        if (pMarkupThis == pMarkupSlave)
        {
            return TRUE;
        }
        if (pMarkupThis == pMarkupPrimary)
            break;
        pMarkupThis = pMarkupThis->Root()->HasMasterPtr()
                        ? pMarkupThis->Root()->GetMasterPtr()->GetMarkup()
                        : NULL;
    }
    return FALSE;
}


// KTam: If fTreatPrintingAsViewLink is true, elements inside a layoutrect will
// return true.
BOOL
CElement::IsInViewLinkBehavior( BOOL fTreatPrintingAsViewLink )
{
    AssertSz(IsInMarkup(), "Must be in a markup to answer this question");
    CElement * pRoot = GetMarkup()->Root();
    if (pRoot->HasMasterPtr())
    {
        CElement *pMaster = pRoot->GetMasterPtr();
        if ( pMaster->TagType() == ETAG_GENERIC )
        {
            if (   fTreatPrintingAsViewLink
                || !pMaster->IsLinkedContentElement() )
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
CElement::IsPrintMedia()
{
    return IsInMarkup() ? GetMarkup()->IsPrintMedia() : FALSE;
}

HTHEME
CElement::GetTheme(THEMECLASSID themeId)
{
    if (GetFirstBranch()->GetFancyFormat()->IsThemeDisabled())
    {
        return NULL;
    }
    else
    {
        CMarkup * pMarkup = GetMarkup();
        if (pMarkup)
        {
            return pMarkup->GetTheme(themeId);
        }
        else
        {
            return NULL;
        }
    }
}

#ifdef NEVER

BOOL
CElement::CanHaveViewSlave()
{
    // You cannot set a viewSlave for non-renderable tags (e.g. SCRIPT). I am doing
    // this just to play safe.
    // Also, you cannot set viewSlave for certain renderable elements (e.g. TABLE),
    // because they make specific assumptions about their layout/content. To support
    // arbitrary view on any element, we need to fix this.

    switch (Tag())
    {
        // Non-renderable tags (picked from GetDefaultFocussability with FOCUSSABILITY_NEVER)
    case ETAG_AREA:
    case ETAG_BASE:
    case ETAG_BASEFONT:
    case ETAG_BGSOUND:
    case ETAG_BR:
    case ETAG_CODE:
    case ETAG_COL:
    case ETAG_COLGROUP:
    case ETAG_COMMENT:
    case ETAG_HEAD:
    case ETAG_HTML:
    case ETAG_LINK:
    case ETAG_MAP:
    case ETAG_META:
    case ETAG_NEXTID:
    case ETAG_NOBR:
    case ETAG_NOEMBED:
    case ETAG_NOFRAMES:
    case ETAG_NOSCRIPT:
    case ETAG_OPTION:
    case ETAG_PARAM:
    case ETAG_RAW_BEGINFRAG:
    case ETAG_RAW_BEGINSEL:
    case ETAG_RAW_CODEPAGE:
    case ETAG_RAW_COMMENT:
    case ETAG_RAW_DOCSIZE:
    case ETAG_RAW_ENDFRAG:
    case ETAG_RAW_ENDSEL:
    case ETAG_RAW_EOF:
    case ETAG_RAW_SOURCE:
    case ETAG_RAW_TEXT:
    case ETAG_RAW_TEXTFRAG:
    case ETAG_SCRIPT:
    case ETAG_STYLE:
    case ETAG_TITLE_ELEMENT:
    case ETAG_TITLE_TAG:
    case ETAG_WBR:
    case ETAG_UNKNOWN:
        return FALSE;

        // Tags which make specific assumptions about their layout
    case ETAG_APPLET:
    case ETAG_EMBED:
    case ETAG_FRAMESET:
    case ETAG_HR:
    case ETAG_OBJECT:
    case ETAG_SELECT:
    case ETAG_TABLE:
    case ETAG_TR:
        return FALSE;

        // Certain types of INPUTs which make specific assumptions about their slave
    case ETAG_INPUT:
        switch (DYNCAST(CInput, this)->GetType())
        {
        case htmlInputButton:
        case htmlInputReset:
        case htmlInputSubmit:
        case htmlInputFile:
        case htmlInputText:
        case htmlInputPassword:
        case htmlInputHidden:
            return FALSE;
        }
        break;
    }
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// viewLink OM
//
#define DISPID_INTERNAL_PUBLIC_VIEWLINK   (DISPID_ELEMENT+??) // from element.pdl

//+----------------------------------------------------------------------------
//
//  Member:     PutViewLinkHelper
//
//  Synopsis:   Sets the slave element.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::PutViewLinkHelper(IHTMLElement * pISlave)
{
    HRESULT     hr          = S_OK;
    CElement*   pElemSlave  = NULL;

    if (!CanHaveViewSlave())
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    if (pISlave)
    {
        hr = THR(pISlave->QueryInterface(CLSID_CElement, (void**) &pElemSlave));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        Assert(pElemSlave);
    }

    hr = THR(SetViewSlave(pElemSlave));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     put_viewLink
//
//  Synopsis:   IHTMLElement3 method. Sets the slave element.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_viewLink(IHTMLElement * pISlave)
{
    HRESULT hr;
    AAINDEX aaIdx   = FindAAIndex(DISPID_INTERNAL_PUBLIC_VIEWLINK, CAttrValue::AA_Internal);

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        hr = AddUnknownObject(DISPID_INTERNAL_PUBLIC_VIEWLINK, pISlave, CAttrValue::AA_Internal);
    }
    else
    {
        hr = ChangeUnknownObjectAt(aaIdx, pISlave);
    }
    if (hr)
        goto Cleanup;

    hr = PutViewLinkHelper(pISlave);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_viewLink
//
//  Synopsis:   IHTMLElement3 method. Returns the slave element.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_viewLink(IHTMLElement ** ppISlave)
{
    if (!ppISlave)
        return E_INVALIDARG;
#ifdef MULTI_LAYOUT
    if (HasSlavePtr()) {
        CElement * pSlave = GetSlavePtr();
        return pSlave->QueryInterface(IID_IHTMLElement, (void**)ppISlave);
    }
    else
    {
        CViewChain * pChain = GetUpdatedLayout()->ViewChain();
        if (pChain)
        {
            CElement * pSlave = GetUpdatedLayout()->ViewChain()->GetLayoutOwner()->ElementOwner()->GetSlavePtr();
            return pSlave->QueryInterface(IID_IHTMLElement, (void**)ppISlave);
        }
    }
#endif

    RRETURN(SetErrorInfo(GetUnknownObjectAt(
                            FindAAIndex(DISPID_INTERNAL_PUBLIC_VIEWLINK, CAttrValue::AA_Internal),
                            (IUnknown**)ppISlave)));
}
#endif // NEVER

BOOL
CElement::ShouldHaveLayout(CTreeNode *pBranchNode FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (Tag() == ETAG_OBJECT && IsInMarkup())
    {
        if (!GetMarkup() || GetMarkup()->SearchBranchForTagInStory(GetFirstBranch(), ETAG_HEAD))
            return FALSE;
    }

    //hack. (dmitryt) We calculate layoutness bit for HTML element when we calc its formats.
    //Unfortunately, to see if HTML has layout, we not only check 'Strict CSS' bit
    //on Markup but also _fDesignMode and IsPrintPreview (see IsHtmlLayout() implementation).
    //But because _fDesignMode on markup is playing funny games when markup gets loaded,
    //we can calculate and cache wrong FancyFormat bit for HTML layout.
    //To 'fix' this temporarily, I'm putting this hack for HTML element in hope 
    //it will help. The right solution would be to only check for CSS1 bit. Unfortunately,
    //it's too late in IE6 cycle.

    if(Tag() == ETAG_HTML)
        return (GetMarkup() && GetMarkup()->IsHtmlLayout());

    if (_fLayoutAlwaysValid)
        return (!TestClassFlag(ELEMENTDESC_NOLAYOUT));

    CTreeNode * pNode = ( pBranchNode ? pBranchNode : GetFirstBranch() );

    // If formats have been computed, then we know whether we should have layout (and that knowledge
    // is cached on the tree node).  Else we need to compute formats to figure it out.
    // COMPUTEFORMATS NO LONGER CREATES LAYOUTS, it only updates the _fShouldHaveLayout bits.
    
    // If we don't have a node, it means we're not in the tree.  In that case, we can't answer the
    // question "should this element have layout", so we'd like to make sure no one asks it.
    // Currently CElement::FireEvent calls GetUpdatedNearestLayout(), which causes us to come in here
    // with a null branch; this happens in the DRT's xtags tests.  Talk to them to figure out the
    // right fix, then enable this assert.
    // Assert( pNode );
    
    if ( pNode )
    {

#ifdef MULTI_FORMAT
        if ( IS_FC(FCPARAM) )
        {
            return pNode->GetFancyFormat(FCPARAM)->_fShouldHaveLayout;
        }
        else
#endif //MULTI_FORMAT
        {        
            return (pNode->_iFF != -1)
                    ? pNode->_fShouldHaveLayout
                    : pNode->GetFancyFormat()->_fShouldHaveLayout;                   
        }
    }

    return FALSE;
}

CBase *
CElement::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup /* = NULL */)
{
    return this;
}

CControlledFormatter::CControlledFormatter(CElement *pElement, DISPID dispid, DWORD dwFlags)
{
    _pElement = pElement;
    _pNode = _pElement->GetFirstBranch();
    _dispid = dispid;
    _dwFlags = dwFlags;
    WHEN_DBG(_fInited = FALSE;)
}

CControlledFormatter::~CControlledFormatter()
{
    AssertSz(   _fShouldComputeFormatsForDISPID
             || _pElement->AreAllMyFormatsAreDirty(_dwFlags),
             "Compute formats was called erroneously! Perf problem!"
            );
}

BOOL
CControlledFormatter::Init(HRESULT *phr)
{
    BOOL fRet = FALSE;

    AssertSz(!_fInited, "Do not init me twice!");
    _fHadLayoutBeforeFormatsChange = _pElement->CurrentlyHasAnyLayout();
    _fShouldComputeFormatsForDISPID = ShouldComputeFormatsForDISPID();
    if (_fShouldComputeFormatsForDISPID)
    {
        *phr = THR(_pElement->EnsureFormatCacheChange(_dwFlags));
        if (*phr != S_OK)
            goto Cleanup;

       //
       // In the case of an activex control, we may be in the process of computing formats  Sujalp owns
       // adding a better assert.
       //
       // AssertSz(_pElement->AreAllMyFormatsAreDirty(_dwFlags), "Ensure format cache change failed!");
        
        _fHasLayoutAfterFormatsChange = _pElement->ShouldHaveLayout();
        _pNearestLayoutInfo = _pElement->GetUpdatedNearestLayoutInfo();
        _pNearestLayout = _pElement->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        if (   !_pNearestLayoutInfo
            || !_pNearestLayoutInfo->ElementOwner()->IsInMarkup()
            || !_pNearestLayout
            || !_pNearestLayout->ElementOwner()->IsInMarkup()
           )
        {
            goto Cleanup;
        }
        SendZNotification();
    }
    else
    {
        SendZNotification();
        *phr = THR(_pElement->EnsureFormatCacheChange(_dwFlags));
        if (*phr != S_OK)
            goto Cleanup;
    }
    fRet = TRUE;
    
Cleanup:
    WHEN_DBG(_fInited = TRUE;)
    return fRet;
}

BOOL
CControlledFormatter::SendZNotification()
{
    // Invalidation on z-index changes will be handled by FixZOrder in CSite
    // unless the change is on a non-site
    if (    _pElement->Doc()->_state >= OS_INPLACE
        &&  !(_dispid == DISPID_A_ZINDEX && _pElement->CurrentlyHasAnyLayout()))
    {
        if (    (_dwFlags & (ELEMCHNG_SITEREDRAW | ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF))
             && !(_dwFlags & ELEMCHNG_SITEPOSITION && _pElement->CurrentlyHasAnyLayout()))
        {
            // NOTE: CLayout will get called *twice* on _pElement because of this code.
            // Once for the first invalidate and once for the INVAL_Z_DESCENDANTS
            // call.

            _pElement->Invalidate();

            // Invalidate() sends a notification ot the parent, however in OPC
            // descendant elemetns may inherit what has just changed, so we need
            // a notification that goes down to the positioned children
            // so that they know to invalidate.  This is necessary since
            // when a property is changed they may have a change in an 
            // inherited value that they need to display
            //
            //  if we wind up needing this notification fired from other 
            // places, consider moving it into InvalidateElement()
            _pElement->SendNotification(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS);
        }
    }
    return TRUE;
}

BOOL
CControlledFormatter::ShouldComputeFormatsForDISPID()
{
    return TRUE;
}

#ifdef NOT_NOW
BOOL
CControlledFormatter::ShouldComputeFormatsForDISPID()
{
    BOOL fRet;
    
#define D(Y)  case DISPID_A_##Y:
#define DE(Y) case DISPID_##Y:
#define S(Y)  case STDPROPID_XOBJ_##Y:
    switch(_dispid)
    {
    // These dispids could potentially change the layoutness of an element, in which case we are interested
    D(RECTANGULAR) S(WIDTH) S(HEIGHT) D(POSITION)
    D(FLOAT) D(ZOOM) D(ROTATE) D(LAYOUTFLOW) D(WRITINGMODE)
    DE(CElement_id) D(EDITABLE) D(STYLETEXT)
    
    // These dispids need to look at formats to do their OPC work
    S(LEFT) S(RIGHT) S(TOP) S(BOTTOM)
    D(ZINDEX) D(VISIBILITY) D(DISPLAY) D(CLIP) D(CLIPRECTTOP)
    D(CLIPRECTRIGHT) D(CLIPRECTBOTTOM) D(CLIPRECTLEFT)

    // These dispids need to look at the new layout to do their OPC work
    D(OVERFLOWY) DE(CElement_className) D(BACKGROUNDIMAGE)
    DE(UNKNOWN) DE(BACKCOLOR)
#undef D
#undef DE
#undef S
    {
        fRet = TRUE;
        break;
    }
    default:
    {
        fRet = FALSE;
        break;
    }
    }

    if (   !fRet
        && (_dwFlags & (ELEMCHNG_RESIZENONSITESONLY | ELEMCHNG_SITEPOSITION))
       )
    {
        fRet = TRUE;
    }
    return fRet;
}
#endif

#if DBG==1
BOOL
CElement::AreAllMyFormatsAreDirty(DWORD dwFlags)
{
    BOOL fAll = dwFlags & ELEMCHNG_CLEARCACHES;
    BOOL fFFOnly = dwFlags & ELEMCHNG_CLEARFF;
    
    CTreeNode *pNode = GetFirstBranch();

    while(pNode)
    {
        if (fAll && pNode->_iCF != -1)
            return FALSE;
        if (fFFOnly && pNode->_iFF != -1)
            return FALSE;
        pNode = pNode->NextBranch();
    }
    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\elemdb.cxx ===
//+---------------------------------------------------------------------
//
//   File:      elemdb.cxx
//
//  Contents:   Element's databinding methods
//
//  Classes:    CElement
//
//------------------------------------------------------------------------


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include <dbtask.hxx>
#endif

MtDefine(DBMEMBERS, DataBind, "DBMEMBERS")
MtDefine(DBMEMBERS_arydsb_pv, DBMEMBERS, "DBMEMBERS::_arydsb::_pv")
MtDefine(CDataBindingEvents, DataBind, "CDataBindingEvents")
MtDefine(CDataBindingEvents_aryXfer_pv, CDataBindingEvents, "CDataBindingEvents::_aryXfer::_pv")

#ifndef NO_DATABINDING
// binding method tables shared by multiple element types
const CDBindMethodsText DBindMethodsTextRichRO(DBIND_ONEWAY|DBIND_HTMLOK);
#endif

static inline LONG
StringLen(LPCTSTR str)
{
    return str ? _tcslen(str) : 0;
}


//+----------------------------------------------------------------------------
//
//  Function: (static helper)
//
//  Synopsis:   str1 and str2 are both strings of field names separated by dots.
//              Find the longest prefix of str2 that's also a suffix of str1.
//              Return a pointer to the "tail" - the part of str2 that sticks
//              out past the end of str1;  this must be non-trivial (at least
//              one field name).

static LPCTSTR
FindOverlapAndTail(LPCTSTR str1, LPCTSTR str2, TCHAR tchDelim=_T('.'))
{
    LONG lLength1 = StringLen(str1);
    LPCTSTR strTail = str2 + StringLen(str2);
    LONG lPrefixLength;

    if (strTail == NULL)
        return NULL;
    
    for (;;)
    {
        // find the next delimiter in str2 (right-to-left)
        while (--strTail >= str2)
        {
            if (*strTail == tchDelim)
                break;
        }

        if (strTail < str2)
            break;

        // compare suffix of str1 with prefix of str2
        lPrefixLength = (strTail - str2);
        if (lLength1 >= lPrefixLength &&
            0 == FormsStringNCmp(str1 + lLength1 - lPrefixLength, lPrefixLength,
                                 str2, lPrefixLength))
        {
            break;
        }
    }

    return strTail + 1;
}


//+----------------------------------------------------------------------------
//
//  Function: get_datafld
//
//  Synopsis: Object model entry point to fetch the datafld property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element support such a property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dataFld(BSTR * p)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    if ( p )
        *p = NULL;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFldValid(this))
    {
        hr = s_propdescCElementdataFld.b.GetStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );
    }
    else
    {
        // To allow for..in to work we need to return S_OK, but an empty BSTR
        hr = SetErrorInfoPGet(S_OK, DISPID_CElement_dataFld);
    }

        RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: put_datafld
//
//  Synopsis: Object model entry point to put the datafld property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//
//  Notes:    TODO: to support dynamic changes to binding properties,
//            additional code should be place here or in OnPropertyChange()
//            to rebind.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dataFld(BSTR v)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFldValid(this))
    {
        DetachDataBinding(ID_DBIND_DEFAULT);

        hr = s_propdescCElementdataFld.b.SetStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

        AttachDataBindings();   // TODO: better to specify ID_DBIND_DEFAULT
        if (IsInMarkup())
        {
            GetMarkup()->TickleDataBinding();
        }
    }
    else
    {
        hr = SetErrorInfoPSet(DISP_E_MEMBERNOTFOUND, DISPID_CElement_dataFld);
    }
    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: get_dataformatas
//
//  Synopsis: Object model entry point to fetch the dataformatas property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element support such a property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dataFormatAs(BSTR * p)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    if ( p )
        *p = NULL;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFormatAsValid(this))
    {
        hr = s_propdescCElementdataFormatAs.b.GetStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );
    }
    else
    {
        // To allow for..in to work we need to return S_OK, but an empty BSTR
        hr = SetErrorInfoPGet(S_OK, DISPID_CElement_dataFormatAs);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: put_dataformatas
//
//  Synopsis: Object model entry point to put the dataformatas property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//
//  Notes:    TODO: to support dynamic changes to binding properties,
//            additional code should be place here or in OnPropertyChange()
//            to rebind.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dataFormatAs(BSTR v)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFormatAsValid(this))
    {
        DetachDataBinding(ID_DBIND_DEFAULT);

        hr = s_propdescCElementdataFormatAs.b.SetStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

        AttachDataBindings();   // TODO: better to specify ID_DBIND_DEFAULT
        if (IsInMarkup())
        {
            GetMarkup()->TickleDataBinding();
        }
    }
    else
    {
        hr = SetErrorInfoPSet(DISP_E_MEMBERNOTFOUND, DISPID_CElement_dataFormatAs);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: get_datasrc
//
//  Synopsis: Object model entry point to fetch the datasrc property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element support such a property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dataSrc(BSTR * p)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    if ( p )
        *p = NULL;

    // note that set-consumers and single-value consumers both support datasrc
    if (CDBindMethods::FDataSrcValid(this))
    {
        hr = s_propdescCElementdataSrc.b.GetStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );
    }
    else
    {
        // To allow for..in to work we need to return S_OK, but an empty BSTR
        hr = SetErrorInfoPGet(S_OK, DISPID_CElement_dataSrc);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: put_datasrc
//
//  Synopsis: Object model entry point to put the datasrc property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//
//  Notes:    TODO: to support dynamic changes to binding properties,
//            additional code should be place here or in OnPropertyChange()
//            to rebind.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dataSrc(BSTR v)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    // note that set-consumers and single-value consumers both support datasrc
    if (CDBindMethods::FDataSrcValid(this))
    {
        DetachDataBinding(ID_DBIND_DEFAULT);

        hr = s_propdescCElementdataSrc.b.SetStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

        AttachDataBindings();   // TODO: better to specify ID_DBIND_DEFAULT
        if (IsInMarkup())
        {
            GetMarkup()->TickleDataBinding();
        }
    }
    else
    {
        hr = SetErrorInfoPSet(DISP_E_MEMBERNOTFOUND, DISPID_CElement_dataSrc);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: FFilter
//
//  Synopsis: Determine if a given DBSPEC binding specification is consistent
//            with the rules for describing given type or types of bindings.
//
//  Arguments:
//            [dwFilter] - Some combination of at least one of
//                          DBIND_SETFILTER
//                          DBIND_CURRENTFILTER
//                          DBIND_TABLEFILTER
//            fHackyHierarchicalTableFlag - set to TRUE in calls on behalf of
//                          a TABLE.  To support hierarchy, TABLEs match
//                          dataSrc + dataFld to SETFILTER, not to CURRENTFILTER.
//
//  Returns:  TRUE - DBSPEC matches desired pattern
//            FALSE - DBSPEC doesn't match pattern
//
//-----------------------------------------------------------------------------
BOOL
DBSPEC::FFilter(DWORD dwFilter, BOOL fHackyHierarchicalTableFlag)
{
    BOOL fRet = FALSE;

    Assert(dwFilter & DBIND_ALLFILTER); // should specify at least one bit

    if (FormsIsEmptyString(_pStrDataFld))
    {
        if (!FormsIsEmptyString(_pStrDataSrc) && (dwFilter & DBIND_SETFILTER))
        {
            fRet = TRUE;
        }
    }
    else if (!FormsIsEmptyString(_pStrDataSrc))
    {
        if ((fHackyHierarchicalTableFlag && dwFilter & DBIND_SETFILTER) ||
            (!fHackyHierarchicalTableFlag && dwFilter & DBIND_CURRENTFILTER))
        {
            fRet = TRUE;
        }
    }
    else if (dwFilter & DBIND_TABLEFILTER)
    {
        fRet = TRUE;
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Function: FHTML
//
//  Synopsis: Determine if a given DBSPEC binding specifies HTML-based
//            Transfer.  Note that this method does NOT consider whether
//            or the bound element actually supports such transfer..
//
//  Returns:  TRUE - HTML binding specified
//            FALSE - HTML binding not specified
//
//-----------------------------------------------------------------------------
BOOL
DBSPEC::FHTML()
{
    return (!FormsIsEmptyString(_pStrDataFormatAs) && StrCmpIC(_pStrDataFormatAs, _T("html")) == 0);
}

//+----------------------------------------------------------------------------
//
//  Function: FLocalized
//
//  Synopsis: Determine if a given DBSPEC binding specifies localized-text
//            transfer.  Note that this method does NOT consider whether
//            or the bound element actually supports such transfer..
//
//  Returns:  TRUE - localized binding specified
//            FALSE - localized binding not specified
//
//-----------------------------------------------------------------------------
BOOL
DBSPEC::FLocalized()
{
    return (!FormsIsEmptyString(_pStrDataFormatAs) && StrCmpIC(_pStrDataFormatAs, _T("localized-text")) == 0);
}


//+----------------------------------------------------------------------------
//
//  Function: GetNextDBSpec, static
//
//  Synopsis: Enumerate next specified binding on a given element, whether or
//            not it is sensible.
//
//  Arguments:
//            [pElement] - element which is subject of this inquiry
//            [pid]      - in/out parameter; on input, contains last enumerated
//                         id, or id after which to start earch
//            [pdbs]     - output: where to put the specification
//            [dwFilter] - restrictions on search.  Some combination of at
//                         least one of
//                             DBIND_SETFILTER
//                             DBIND_CURRENTFILTER
//                             DBIND_TABLEFILTER
//                         optionally plus
//                             DBIND_ONEIDFILTER.
//                         This last flag indicates where only interested in
//                         id which is the input *pid+1.  This flag is a hack
//                         to allow trivial implementation of GetDBSpec.
//
//  Returns:  S_OK    - binding spec found matching input restrictions; *pid
//                      filled in with binding id, *pdbs filled in with binding
//                      spec.
//            S_FALSE - no matching binding spec found.  *pid undisturbed.
//                      *pdbs may have been trashed.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethods::GetNextDBSpec(CElement *pElem,
                            LONG *pid,
                            DBSPEC *pdbs,
                            DWORD dwFilter)
{
    HRESULT hr = S_FALSE;
#ifndef NO_DATABINDING
    LONG id = *pid;
    const CDBindMethods *pDBindMethods;

    Assert(dwFilter & DBIND_ALLFILTER); // at least one bit set?

    if (id == ID_DBIND_STARTLOOP)
    {
        id = ID_DBIND_DEFAULT;

        pdbs->_pStrDataFld = pElem->GetAAdataFld();
        pdbs->_pStrDataSrc = pElem->GetAAdataSrc();
        pdbs->_pStrDataFormatAs = pElem->GetAAdataFormatAs();

        if (pdbs->FFilter(dwFilter, pElem->Tag()==ETAG_TABLE))
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (dwFilter & DBIND_ONEIDFILTER)
            goto Cleanup;
    }

    pDBindMethods = pElem->GetDBindMethods();

    if (pDBindMethods)
    {
        for (;;)
        {
            BOOL fFilter;

            if (pDBindMethods->GetNextDBSpecCustom(pElem, &id, pdbs))
                goto Cleanup;

            fFilter = pdbs->FFilter(dwFilter, pElem->Tag()==ETAG_TABLE);

            if (dwFilter & DBIND_ONEIDFILTER)   // only one value acceptable
            {
                if (fFilter && id == *pid + 1)
                {
                    hr = S_OK;
                }

                goto Cleanup;
            }

            if (fFilter)
            {
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

Cleanup:
    if (!hr)
    {
        *pid = id;
    }
#endif // ndef NO_DATABINDING

    RRETURN1(hr, S_FALSE);
}



#ifndef NO_DATABINDING
//+-------------------------------------------------------------------------
// Member:      Get Binder (public)
//
// Returns:     my DataSourceBinder (or NULL, if none)

CDataSourceBinder *
DBMEMBERS::GetBinder(LONG id)
{
    CDataSourceBinder * pdsb = NULL;
    CDataSourceBinder ** ppdsb;
    int    i;

    Assert(id != ID_DBIND_ALL);

    for (i = _arydsb.Size(), ppdsb = _arydsb;
         i > 0;
         i--, ppdsb++)
    {
        if ((*ppdsb)->IdConsumer() == id)
        {
            pdsb = *ppdsb;
            break;
        }
    }

    return pdsb;
}


//+-------------------------------------------------------------------------
// Member:      MarkReadyToBind (public)
//
// Synopsis:    Mark all my binders "ready to bind"

void
DBMEMBERS::MarkReadyToBind()
{
    CDataSourceBinder **ppdsb;
    int i;

    for (i = _arydsb.Size(), ppdsb = _arydsb;
         i > 0;
         --i, ++ppdsb)
    {
        (*ppdsb)->SetReady(TRUE);
    }
}


//+-------------------------------------------------------------------------
// Member:      Ensure DataMemberManager (public)
//
// Synopsis:    Allocate a CDataMemberMgr, if not done already
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
DBMEMBERS::EnsureDataMemberManager(CElement *pElement)
{
    HRESULT hr = S_OK;

    if (!_pDMembMgr)
    {
        hr = CDataMemberMgr::Create(pElement, &_pDMembMgr);

        pElement->Doc()->_fBroadcastStop = TRUE;
    }

    return(hr);
}


//+-------------------------------------------------------------------------
// Member:      Release DataMemberManager (public)
//
// Synopsis:    Deallocate the CDataMemberMgr, if not done already

void
DBMEMBERS::ReleaseDataMemberManager(CElement *pElement)
{
    if (_pDMembMgr)
    {
        // remove any pending requests attached to a data source object.
        // Note - don't call CDoc::GetDataBindTask(), because that creates
        // the dbtask if it doesn't exist.
        CDataBindTask *pDBTask = _pDMembMgr->GetOwner()->IsInMarkup()
                                    ? _pDMembMgr->GetOwner()->GetMarkup()->GetDBTask()
                                    : NULL;
        if (pDBTask)
        {
            pDBTask->RemoveDataEventRequestsFor(pElement);
        }

        _pDMembMgr->Detach();
        _pDMembMgr->Release();
        _pDMembMgr = NULL;
    }
}


//+-------------------------------------------------------------------------
// Member:      Ensure DBMembers (private)
//
// Synopsis:    Allocate a DBMEMBERS struct, if not done already
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CElement::EnsureDBMembers()
{
    if (HasDataBindPtr())
    {
        return(S_OK);
    }

    DBMEMBERS * pdbm = new DBMEMBERS;

    if (!pdbm)
    {
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = SetDataBindPtr(pdbm);

    if (hr)
    {
        delete pdbm;
    }

    return(hr);
}


//+-------------------------------------------------------------------------
// Member:      Ensure DataMemberManager (public)
//
// Synopsis:    Allocate a CDataMemberMgr, if not done already
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CElement::EnsureDataMemberManager()
{
    HRESULT hr = EnsureDBMembers();

    if (!hr)
    {
        hr = GetDBMembers()->EnsureDataMemberManager(this);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
// Member:      Get DataMemberManager (public)
//
// Synopsis:    Return my datamember manager
//
// Arguments:   none
//
// Returns:     HRESULT

CDataMemberMgr *
CElement::GetDataMemberManager()
{
    CDataMemberMgr *pdmm;

    if (HasDataBindPtr())
    {
        pdmm = GetDBMembers()->GetDataMemberManager();
    }
    else
    {
        pdmm = NULL;
    }
    
    return pdmm;
}


//+-------------------------------------------------------------------------
// Member:      IsDataProvider (public)
//
// Synopsis:    Decide whether I'm a data provider

BOOL
CElement::IsDataProvider()
{
    CDataMemberMgr *pdmm;
    
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();

    return pdmm && pdmm->IsDataProvider();
}


//+-------------------------------------------------------------------------
// Member:      CreateDatabindRequest (public)
//
// Synopsis:    Create a request to hookup my databinding, and register it
//              with the databinding task
//
// Arguments:   id      id of the binding
//              pdbs    DBSPEC for the binding
//
// Returns:     HRESULT

HRESULT
CElement::CreateDatabindRequest(LONG id, DBSPEC *pdbs /* NULL */)
{
    HRESULT hr = S_OK;
    DBMEMBERS *pdbm;
    DBSPEC dbs;

    // get the DBSPEC, if not already provided
    if (pdbs == NULL)
    {
        pdbs = &dbs;
        hr = CDBindMethods::GetDBSpec(this, id, pdbs);
        if (hr)
            goto Cleanup;
    }
    
    // we need DBMEMBERS allocated, so that we can hook things up.
    hr = EnsureDBMembers();
    if (hr)
        goto Cleanup;

    pdbm = GetDBMembers();

    if (!pdbm->GetBinder(id))
    {
        CDataSourceBinder *pdsbBinder;

        // get a binder object
        pdsbBinder = new CDataSourceBinder(this, id);
        if (!pdsbBinder)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // save it in my DBMEMBERS
        hr = pdbm->SetBinder(pdsbBinder);
        if (hr)
        {
            pdsbBinder->Passivate();
            goto Cleanup;
        }

        // tell binder to register itself with the databinding task
        pdsbBinder->SetReady(CDBindMethods::IsReadyToBind(this));
        hr = pdsbBinder->Register(pdbs);
        if (hr)
        {
            DetachDataBinding(id);
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AttachDataBindings, public
//
//  Synopsis:   Make sure that all binders needed are present for the given
//              element.  (Note this doesn't actually handle state of
//              the CDataBindingEvents; other calls must be made to get
//              this set up.)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CElement::AttachDataBindings()
{
    HRESULT hrRet = S_OK;
    HRESULT hr = S_OK;
    LONG id;
    DBSPEC dbs;
    CElement *pElementOuter, *pElementRepeat;
    LPCTSTR strTail;   

    // don't databind in design mode or outside the main tree
    if (    Tag() == ETAG_ROOT // Input optimization
        ||  IsDesignMode()
        || !IsConnectedToPrimaryWindow() 
        || !CDBindMethods::IsReadyToBind(this))
        goto Cleanup;

    // note post-operation of for-loop; hrRet is set to first error
    for (id = ID_DBIND_STARTLOOP;
         !CDBindMethods::GetNextDBSpec(this, &id, &dbs, DBIND_ALLFILTER);
         !hrRet && (hrRet = hr) != 0)
    {
        // see if I'm current-record or table-bound
        hr = FindDatabindContext(dbs._pStrDataSrc, dbs._pStrDataFld,
                                &pElementOuter, &pElementRepeat, &strTail);

        // I'm table-bound, but table isn't expanding yet (I'm in a template).
        // Ignore for now.  Wait until table expands
        if (hr == S_FALSE)
        {
            hr = S_OK;
            continue;
        }

        // something bad happened.  Punt.
        if (hr)
            continue;
        
        // table-bound - ask the table to hook me up
        if (pElementOuter)
        {
            CTable *pTable = DYNCAST(CTable, pElementOuter);
            CTableRow *pRow = DYNCAST(CTableRow, pElementRepeat);

            hr = pTable->AddDataboundElement(this, id, pRow, strTail);
        }

        // current-record-bound - ask the databind task to hook me up
        else
        {
            hr = CreateDatabindRequest(id, &dbs);
        }
    }

Cleanup:
    RRETURN(hrRet);
}

//+---------------------------------------------------------------------------
//
//  Member:     DetachDataBindings, public
//
//  Synopsis:   Let go of all of my databinding data, if any
//
//  Returns:    nothing
//
//----------------------------------------------------------------------------

void
CElement::DetachDataBindings()
{
    DBMEMBERS *pdbm = GetDataBindPtr();

    if (pdbm != NULL)
    {
        int i;

        pdbm->DetachBinding(this, ID_DBIND_ALL);

        // this loop is a little different from the standard FormsAry loop.
        //  It keeps i and ppsdb consistent in the body of the loop.
        //  It also keeps deletions at the end of the array, minimizing
        //  useless copying, and keeping the deletions from interfering with
        //  the loop.
        for (i = pdbm->_arydsb.Size(); i-- > 0; )
        {
            if (pdbm->_arydsb[i])
            {
                (pdbm->_arydsb[i])->Passivate();
            }
            pdbm->_arydsb.Delete(i);
        }

        pdbm->ReleaseDataMemberManager(this);

        delete pdbm;

        // Can't use this call above because the detach code expects to
        // be able to call GetDataBindPtr() and find it.

        DelDataBindPtr();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     DetachDataBinding, public
//
//  Synopsis:   Let go of all databinding state, if any, for one binding id
//
//  Returns:    nothing
//
//----------------------------------------------------------------------------

void
CElement::DetachDataBinding(LONG id)
{
    DBMEMBERS *pdbm = GetDBMembers();

    Assert(id != ID_DBIND_ALL);

    if (pdbm != NULL)
    {
        CDataSourceBinder *pdsb = pdbm->GetBinder(id);

        // Call DetachBinding before pdsb->Passivate, so that the
        // element's bound value is replaced with a null-equivalent
        pdbm->DetachBinding(this, id);

        if (pdsb)
        {
            pdsb->Passivate();
            pdbm->_arydsb.DeleteByValue(pdsb);
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     FindDatabindContext, public
//
//  Synopsis:   find the enclosing repeated element with matching dataSrc
//              and dataFld attributes
//
//  Arguments:  strDataSrc  look for an element with this dataSrc attribute
//              strDataFld     ... and this dataFld attribute
//              ppElementOuter   container element (NULL, if I'm current-row bound)
//              ppElementRepeat  instance of repeating that contains me
//              pstrTail    tail of strDataFld, after stripping away prefix
//                          that matches the container [return]
//
//  Returns:    S_OK        found it, or I'm bound to current record
//              S_FALSE     found a syntactically enclosing element, but it's not
//                          repeating, *ppInstance will be NULL

HRESULT
CElement::FindDatabindContext(LPCTSTR strDataSrc, LPCTSTR strDataFld,
                            CElement **ppElementOuter, CElement **ppElementRepeat,
                            LPCTSTR *pstrTail)
{
    HRESULT hr = S_OK;
    CTreeNode *pNodeRow;
    CTreeNode *pNodeOuter = NULL;
    CTable *pTableOuter = NULL;
    DBSPEC dbsOuter;
    LPCTSTR strTail = NULL;

    *ppElementOuter = NULL;
    *ppElementRepeat = NULL;
    
    // search up the tree for a row in a table with the right spec
    for (   pNodeRow = GetFirstBranch()->Ancestor(ETAG_TR);
            pNodeRow;
            pNodeRow = pNodeOuter->Ancestor(ETAG_TR) )
    {
        pNodeOuter = pNodeRow->Ancestor(ETAG_TABLE);
        Assert(pNodeOuter && "TableRow not enclosed in Table");

        pTableOuter = DYNCAST(CTable, pNodeOuter->Element());

        // if outer table isn't bound, keep looking
        if (S_OK != CDBindMethods::GetDBSpec(pTableOuter, ID_DBIND_DEFAULT, &dbsOuter))
            continue;

        // if datasource attributes don't match, keep looking
        if (!FormsIsEmptyString(strDataSrc) &&
            FormsStringCmp(strDataSrc, pTableOuter->GetDataSrc()) != 0)
            continue;

        // if I'm not in the repeating part of the table, keep looking
        if (pNodeRow->Parent()->Tag() != ETAG_TBODY)
            continue;

        // if it's not repeating yet, I'm in a template - there's no instance
        if (!pTableOuter->IsRepeating())
        {
            *ppElementOuter = pTableOuter;
            hr = S_FALSE;
            goto Cleanup;
        }

        // if datafield attributes don't match, keep looking
        strTail = FindOverlapAndTail(pTableOuter->GetDataFld(), strDataFld);
        if (!pTableOuter->IsFieldKnown(strTail))
            continue;

        // I'm a table-bound element
        *ppElementOuter = pTableOuter;
        *ppElementRepeat = DYNCAST(CTableRow, pNodeRow->Element());
        goto Cleanup;
    }

    // if we fall out of the loop, I must be a current-row bound element
    strTail = strDataFld;
    
Cleanup:
    if (pstrTail)
        *pstrTail = strTail;
    RRETURN1(hr, S_FALSE);
}
#endif // ndef NO_DATABINDING


//+---------------------------------------------------------------------------
//
//  Member:     CElement::getRecordNumber
//
//  Synopsis:   returns the record number of this element if it's in a
//              databound table; otherwise returns -1
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::get_recordNumber(VARIANT *retval)
{
    V_VT(retval) = VT_NULL;

    CTreeNode * pNode = GetFirstBranch();
    while (pNode)
    {
        CTreeNode * pNodeRow = NULL;

        while (!pNodeRow && pNode)
        {
            if (pNode->Tag() == ETAG_TR)
                pNodeRow = pNode;
            else
                pNode = pNode->Parent();
        }

        if (pNodeRow)
        {
            CTableLayout *pTableLayout = NULL;

            do
            {
                pNode = pNode->Parent();
                if (pNode && (pNode->Tag() == ETAG_TABLE))
                    pTableLayout = DYNCAST(CTable, pNode->Element())->TableLayoutCache();
            }
            while (!pTableLayout && pNode);

            if (!pTableLayout)
                goto Cleanup;       // TODO: Handle this better.  This case is valid through the DOM

            Assert(pTableLayout);

#ifndef NO_DATABINDING
            if (pTableLayout->IsRepeating())
            {
                int iRow = DYNCAST(CTableRowLayout, pNodeRow->GetUpdatedLayout())->RowPosition();
                if (pTableLayout->IsGenerated(iRow))
                {
                    V_VT(retval) = VT_I4;
                    V_I4(retval) = pTableLayout->RowIndex2RecordNumber(iRow);
                    break;
                }
            }
#endif
        }
    }
Cleanup:
    RRETURN(SetErrorInfo(S_OK));
}

#ifndef NO_DATABINDING
//+----------------------------------------------------------------------------
//
//  Class CDBindMethods
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
//  Function: FDataSrcValid, static
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datasrc as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataSrcValid(CElement *pElem)
{
    const CDBindMethods *pDBindMethods = pElem->GetDBindMethods();

    return (pDBindMethods && pDBindMethods->FDataSrcValidImpl(pElem));
}

//+----------------------------------------------------------------------------
//
//  Function: FDataSrcValidImpl, virtual (default implementation)
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datasrc as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataSrcValidImpl(CElement *pElem) const
{
    return (DBindKind(pElem, ID_DBIND_DEFAULT) != DBIND_NONE);
}

//+----------------------------------------------------------------------------
//
//  Function: FDataFldValid, static
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datafld as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataFldValid(CElement *pElem)
{
    const CDBindMethods *pDBindMethods = pElem->GetDBindMethods();

    return (pDBindMethods && pDBindMethods->FDataFldValidImpl(pElem));
}

//+----------------------------------------------------------------------------
//
//  Function: FDataFldValidImpl, virtual (default implementation)
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datasrc as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataFldValidImpl(CElement *pElem) const
{
    DBIND_KIND dbk = DBindKind(pElem, ID_DBIND_DEFAULT);
    return (dbk == DBIND_SINGLEVALUE) || (dbk == DBIND_TABLE);
}

//+----------------------------------------------------------------------------
//
//  Function: FDataFormatAsValid, static
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should dataformatas as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataFormatAsValid(CElement *pElem)
{
    const CDBindMethods *pDBindMethods = pElem->GetDBindMethods();

    return (pDBindMethods && pDBindMethods->FDataFormatAsImpl());
}

//+----------------------------------------------------------------------------
//
//  Function: DBindKind, static
//
//  Synopsis: Indicate whether or not <element, id> can be databound, and
//            optionally return additional info about binding.
//
//            Wraps calls to CDBindMethods::DBindKindImpl, and handles
//            initialization of any non-NULL pdbi passed in.
//
//  Arguments:
//            [pElem] - element whose binding status/ability is being queried
//            [id]    - id of binding specification for which info is desired
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL
//
//  Returns:  Binding status: one of
//              DBIND_NONE
//              DBIND_SINGLEVALUE
//              DBIND_ICURSOR
//              DBIND_IROWSET
//              DBIND_TABLE
//              DBIND_IDATASOURCE
//            For base CElement, always returns DBIND_NONE
//
//-----------------------------------------------------------------------------
DBIND_KIND
CDBindMethods::DBindKind(CElement *pElem, LONG id, DBINFO *pdbi)
{
    DBIND_KIND dbk = DBIND_NONE;
    const CDBindMethods *pDBindMethods;

    if (pdbi)
    {
        pdbi->_vt = VT_EMPTY;
        pdbi->_dwTransfer = DBIND_ONEWAY; // one-way, no HTML
    }

    pDBindMethods = pElem->GetDBindMethods();

    if (pDBindMethods)
    {
        dbk = pDBindMethods->DBindKindImpl(pElem, id, pdbi);
    }

    return dbk;
}

//+----------------------------------------------------------------------------
//
//  Function: IsReadyToBind, static
//
//  Synopsis: Indicate whether the element is ready to be bound.  Most elements
//              are, except for OBJECT/APPLET (depends on readystate) and TABLE
//              (have to see the </TABLE>, so we have all the template rows).
//
//            Wraps calls to CDBindMethods::IsReadyImpl.
//
//  Arguments:
//            [pElem] - element whose binding readiness is being queried
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::IsReadyToBind(CElement *pElem)
{
    BOOL fIsReady = FALSE;
    const CDBindMethods *pDBindMethods;

    pDBindMethods = pElem->GetDBindMethods();

    if (pDBindMethods)
    {
        fIsReady = pDBindMethods->IsReadyImpl(pElem);
    }

    return fIsReady;
}

//+----------------------------------------------------------------------------
//
//  Class CDBindMethodsSimple:  support for simple controls with single binding
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
//  Function: DBindKindImpl, CDBindMethodsSimple
//
//  Synopsis: Simple elements with only a single binding respond to DBindKind in
//              more or less the same way.  Handled here.
//  Arguments:
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL.  If not NULL, has already been pre-
//                      initialized to state appropriate for DBIND_NONE.
//
//
//  Returns:  as in DBindKind
//
//-----------------------------------------------------------------------------
DBIND_KIND
CDBindMethodsSimple::DBindKindImpl(CElement *pElem,
                                   LONG id,
                                   DBINFO *pdbi) const
{
    DBIND_KIND dbk = DBIND_NONE;

    if (id == ID_DBIND_DEFAULT)
    {
        dbk = DBIND_SINGLEVALUE;

        if (pdbi)
        {
            pdbi->_vt = _vt;
            pdbi->_dwTransfer = _dwTransfer;
        }
    }

    return dbk;
}


//+----------------------------------------------------------------------------
//
//  Function: BoundValueFromElement, CDBindMethods
//
//  Synopsis: For the convenience of classes which support only 1-way bindings,
//            we provide a base implementation of BoundValueFromElement, which
//            satisfies compiler but should never be called.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsSimple::BoundValueFromElement(CElement *,
                                         LONG,
                                         BOOL,
                                         LPVOID) const
{
    Assert(FALSE);
    return E_UNEXPECTED;
}

//+----------------------------------------------------------------------------
//
//  Class CDBindMethodsText: for elements which use the text code to get and
//  set strings.
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Default implemenation for transferring bound data to element.
//            Note that this won't be called unless some implementation of
//            BindStatus indicated a binding was present.  Assumes that we
//            are working with a textual element.
//
//  Arguments:
//            [pElem]   - destination element of transfer
//            [id]      - ID of binding point.  For the text-based
//                        must be ID_DBIND_DEFAULT.
//            [fHTML]   - whether text should be interpret as HTML
//            [pvData]  - pointer to data to transfer, in the expected data
//                        type.  For text-based transfers, must be BSTR.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsText::BoundValueToElement ( CElement *pElem,
                                         LONG id,
                                         BOOL fHTML,
                                         LPVOID pvData ) const
{
    BSTR *  pBstr = (BSTR *) pvData;

    Assert( pBstr );

#if DBG==1
    {
        DBINFO dbi;

        Assert( id == ID_DBIND_DEFAULT );
        Assert( DBindKind( pElem, id, & dbi ) > DBIND_NONE );
        Assert( dbi._vt == VT_BSTR );
    }
#endif // DBG == 1

    RRETURN(
        THR(
            pElem->Inject(
                CElement::Inside, fHTML,
                *pBstr, FormsStringLen( * pBstr ) ) ) );
}



HRESULT
CDBindMethodsText::BoundValueFromElement(CElement *pElem,
                                         LONG id,
                                         BOOL fHTML,
                                         LPVOID pvData) const
{
    BSTR       *pBstr = (BSTR *) pvData;

    Assert(pBstr);
    // shouldn't be called for one-way bindings
    Assert((_dwTransfer & DBIND_ONEWAY) == 0);

#if DBG==1
    {
        DBINFO dbi;

        Assert(id == ID_DBIND_DEFAULT);
        Assert(DBindKind(pElem, id, &dbi) > DBIND_NONE);
        Assert(dbi._vt == VT_BSTR);
    }
#endif // DBG == 1

    RRETURN(pElem->GetBstrFromElement(fHTML, pBstr));
}

#endif // ndef NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\folectrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olectrl.cxx
//
//  Contents:   Implementation of IOleControl methods
//
//  Classes:    CDoc (partial)
//
//  History:    05-Feb-94     LyleC    Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

extern BOOL g_fInPhotoSuiteIII;
extern BOOL g_fInIexplorer;
extern BOOL g_fDisableUnTrustedProtocol;

void
CDoc::GetLoadFlag(DISPID dispidProp)
{

    BOOL fVal = FALSE;
    DWORD dwCurrFlag = (dispidProp == DISPID_AMBIENT_SILENT) ? DLCTL_SILENT : DLCTL_OFFLINEIFNOTCONNECTED;
    fVal = GetAmbientBool(dispidProp, FALSE);
    if(fVal)
        _dwLoadf |= dwCurrFlag;
    else
        _dwLoadf &= (~dwCurrFlag);

    return;
}

HRESULT
CDoc::UpdateDocHostUI(BOOL fCalledFromSwitchMarkup /* = FALSE */)
{
    HRESULT hr = S_OK;

    DOCHOSTUIINFO   docHostUIInfo;
    CBodyElement *  pBody;
    DWORD           dwFlagsHostInfoOld = _dwFlagsHostInfo;
    
    if (!_pHostUIHandler)
    {
        goto Cleanup;
    }    

    // Initialize
    memset(&docHostUIInfo, 0, sizeof(DOCHOSTUIINFO));
    docHostUIInfo.cbSize = sizeof(DOCHOSTUIINFO);
    if (OK(_pHostUIHandler->GetHostInfo(&docHostUIInfo)))
    {
        if (g_fInIexplorer)
        {
            docHostUIInfo.dwFlags |= DOCHOSTUIFLAG_DISABLE_UNTRUSTEDPROTOCOL;
            g_fDisableUnTrustedProtocol = TRUE;
        }
        else if (docHostUIInfo.dwFlags & DOCHOSTUIFLAG_DISABLE_UNTRUSTEDPROTOCOL)
        {
            g_fDisableUnTrustedProtocol = TRUE;
        }

        if (docHostUIInfo.pchHostNS)
        {
            hr = THR(_cstrHostNS.Set(docHostUIInfo.pchHostNS));
            if (hr)
                goto Cleanup;
            
            hr = THR(EnsureExtendedTagTableHost());
            if (hr)
                goto Cleanup;
            
            hr = THR(_pExtendedTagTableHost->EnsureHostNamespaces());
            if (hr)
                goto Cleanup;
        }
        
        if (docHostUIInfo.pchHostCss)
        {
            hr = THR(_cstrHostCss.Set(docHostUIInfo.pchHostCss));
            if (hr)
                goto Cleanup;
            
            hr = THR(EnsureHostStyleSheets());
            if (hr)
                goto Cleanup;
            
            SetCssPeersPossible();
        }

        //
        // HACKALERT (jeffwall) PhotoSuite III wrongly changes the host flags when called from switchmarkup.  Bug 109411
        //
        if (!fCalledFromSwitchMarkup || ( fCalledFromSwitchMarkup && !g_fInPhotoSuiteIII ))
        {
            _dwFlagsHostInfo = docHostUIInfo.dwFlags;
        }

        // What we use for a default block tag.
        if (_dwFlagsHostInfo & DOCHOSTUIFLAG_DIV_BLOCKDEFAULT)
            SetDefaultBlockTag(ETAG_DIV);
        else
            SetDefaultBlockTag(ETAG_P);
        
        CoTaskMemFree(docHostUIInfo.pchHostCss);
        CoTaskMemFree(docHostUIInfo.pchHostNS);
    }
    
    IGNORE_HR(PrimaryMarkup()->GetBodyElement(&pBody));

    if (    pBody
        &&  dwFlagsHostInfoOld != _dwFlagsHostInfo
        &&  GetView()->IsActive())
    {
        pBody->ResizeElement();
    }
                
Cleanup:
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnAmbientPropertyChange, public
//
//  Synopsis:   Captures ambient property changes and takes appropriate action.
//
//  Arguments:  [dispidProp] -- Property which changed.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::OnAmbientPropertyChange(DISPID dispidProp)
{
    HRESULT         hr = S_OK;
    BOOL            fAll = (dispidProp == DISPID_UNKNOWN);
    BOOL            fMode;
    CNotification   nf;  

    // Update dochostui flags - helps us read DOCHOSTUIFLAG_FLAT_SCROILLBAR
    // correctly when we switch to/from full screen mode
    if (fAll && _pHostUIHandler)
    {
        hr = UpdateDocHostUI();
        if (hr)
            goto Cleanup;
    }

    if (fAll)
    {
        // Update the scrollbar info
        IGNORE_HR(OnFrameOptionScrollChange());
    }

    // Check to see if DesignMode should be set. If the ambient is
    // not supported by the client site then set DesignMode.

    if ((fAll || dispidProp == DISPID_AMBIENT_USERMODE) &&
            PrimaryMarkup()->_fInheritDesignMode)
    {
        BOOL fDesignMode = PrimaryMarkup()->_fDesignMode;
        if (!PrimaryMarkup()->_fFrameSet)
        {
            fMode = !GetAmbientBool(DISPID_AMBIENT_USERMODE, !fDesignMode);
        }
        else
        {
            // Can't go into edit (design) mode if our top-level site is a
            // frameset.
            fMode = FALSE;
        }

        if (fMode != fDesignMode)
        {
            IGNORE_HR(UpdateDesignMode(PrimaryMarkup()->Document(), fMode));
        }

    }

    if (fAll ||
        dispidProp == DISPID_AMBIENT_DLCONTROL ||
        dispidProp == DISPID_AMBIENT_SILENT ||
        dispidProp == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED)
    {
        CVariant var;

        if (!GetAmbientVariant(DISPID_AMBIENT_DLCONTROL, &var) &&
            V_VT(&var) == VT_I4)
        {
            _dwLoadf = (DWORD) V_I4(&var);
            _fGotAmbientDlcontrol = TRUE;
        }
        else
        {
            _fGotAmbientDlcontrol = FALSE;
            if (fAll)
            {
                GetLoadFlag(DISPID_AMBIENT_SILENT);
                GetLoadFlag(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);
            }
            else
            {
                Assert(dispidProp == DISPID_AMBIENT_SILENT ||
                       dispidProp == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);
                GetLoadFlag(dispidProp);
            }
        }
    }

    if (fAll || dispidProp == DISPID_AMBIENT_USERAGENT)
    {
        FormsFreeString(_bstrUserAgent);
        GetAmbientBstr(DISPID_AMBIENT_USERAGENT, &_bstrUserAgent);
    }

    if (fAll || dispidProp == DISPID_AMBIENT_PALETTE)
    {
        HPALETTE hpalAmbient = GetAmbientPalette();

        if (hpalAmbient != _hpalAmbient)
        {
            _hpalAmbient = hpalAmbient;
            _fHtAmbientPalette = IsHalftonePalette(hpalAmbient);
            
            Invalidate();
            if (_hpalDocument)
            {
                DeleteObject(_hpalDocument);
                _hpalDocument = 0;
                _fHtDocumentPalette = FALSE;
            }
        }
    }

    //
    // Forward to all the sites.
    //

    if (CMarkup::GetElementClientHelper(PrimaryMarkup()))
    {
        nf.AmbientPropChange(PrimaryRoot(), (void *)(DWORD_PTR)dispidProp);
        BroadcastNotify(&nf);
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnControlInfoChanged, public
//
//  Synopsis:   To be called when our control info has changed.  This normally
//              happens when a site gets an OnControlInfoChanged call from
//              its control.  Calls OnControlInfoChanged on our site.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------
void
CDoc::OnControlInfoChanged(DWORD_PTR dwContext)
{
    IOleControlSite * pCtrlSite;

    if (_pClientSite &&
        OK(_pClientSite->QueryInterface(IID_IOleControlSite, (void **) &pCtrlSite)))
    {
        IGNORE_HR(pCtrlSite->OnControlInfoChanged());
        pCtrlSite->Release();
    }

    _fOnControlInfoChangedPosted = FALSE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetControlInfo, public
//
//  Synopsis:   Returns a filled-in CONTROLINFO.
//
//  Arguments:  [pCI] -- CONTROLINFO to fill in
//
//  Returns:    HRESULT
//
//  Notes:      Note that the hAccel we hand out is not valid past our own
//              lifetime, because we call DestroyAcceleratorTable in our
//              destructor.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::GetControlInfo(CONTROLINFO *pCI)
{
#ifdef WIN16
    MessageBox(NULL, "CDoc::GetControlInfo:: need CreateAcceleratorTable.", "BUGWIN16", MB_OK);
    return E_FAIL;
#else
    ACCEL       aaccel[2];

    if (!pCI)
        RRETURN(E_POINTER);

    // TODO -- is this desired behavior?
    if (pCI->cb != sizeof(CONTROLINFO))
        RRETURN(E_INVALIDARG);

    pCI->cAccel = 0;

    aaccel[0].fVirt = FVIRTKEY | FALT | FCONTROL | FSHIFT;
    aaccel[0].key   = 0;    // any key
    aaccel[0].cmd   = 0;    // Not used.

    aaccel[1].fVirt = FALT | FCONTROL | FSHIFT;
    aaccel[1].key   = 0;    // any key
    aaccel[1].cmd   = 0;    // Not used.

    pCI->hAccel = CreateAcceleratorTable(aaccel, 2);
    if (pCI->hAccel == NULL)
        return E_OUTOFMEMORY;

    pCI->cAccel = 2;

    //
    // We don't eat return or escape because we always delegate those keys
    // to our parent before we take action on them.
    //
    pCI->dwFlags = 0;

    //  CONSIDER don't we eat return or escape if the active control in
    //    the form eats it?


    return S_OK;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnMnemonic, public
//
//  Synopsis:   Indicates one of our mnemonics has been pressed by the user
//              and we need to take the appropriate action.
//
//  Arguments:  [pMsg] -- Message which corresponds to a mnemonic.
//
//  Returns:    S_OK
//
//  History:    02-Feb-94     LyleC    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::OnMnemonic(LPMSG lpmsg)
{
    HRESULT hr;
    CMessage Message(lpmsg);

    hr = TransitionTo(OS_UIACTIVE);
    if (!hr)
    {
        hr = PumpMessage(&Message, PrimaryRoot()->GetFirstBranch());
    }

    RRETURN1(hr, S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CDoc::FreezeEvents
//
//  Synopsis:   Broadcast the freeze events notification to all of our
//              controls
//
//  Arguments:  [fFreeze]   TRUE if events are being frozen by the
//                          development environment, FALSE if not.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDoc::FreezeEvents(BOOL fFreeze)
{
    //
    // Assert that the freeze count is not going below zero.
    //
    //AssertSz(fFreeze || _cFreeze, "Too many FreezeEvents(FALSE) calls received by the document");

    _cFreeze = fFreeze ? _cFreeze + 1 : _cFreeze - 1;



    //
    // Notify sites if there was a change in freeze status
    //

    if (    _fHasOleSite
        &&  CMarkup::GetElementClientHelper(PrimaryMarkup())
        &&  (!_cFreeze || (fFreeze && (_cFreeze == 1))))
    {
        CNotification   nf;
        nf.FreezeEvents(PrimaryRoot(), (void *)(DWORD_PTR)fFreeze);
        BroadcastNotify(&nf);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\elementp.cxx ===
//+---------------------------------------------------------------------
//
//  File:       elementp.cxx
//
//  Classes:    CDefaults, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#define _cxx_
#include "elementp.hdl"


///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CDefaults,     ObjectModel,        "CDefaults");

BEGIN_TEAROFF_TABLE(CDefaults, IOleCommandTarget)
    TEAROFF_METHOD(CDefaults, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CDefault, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

const CBase::CLASSDESC CDefaults::s_classdesc =
{
    &CLSID_HTMLDefaults,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLElementDefaults,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

#define DISPID_INTERNAL_VIEWLINK (DISPID_DEFAULTS+50)

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CDefaults
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::CDefaults
//
//-------------------------------------------------------------------------

CDefaults::CDefaults(CElement * pElement)
{
    _pElement = pElement;
    _pElement->SubAddRef(); // balanced in Passivate
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::Passivate
//
//-------------------------------------------------------------------------

void
CDefaults::Passivate()
{
    Assert (_pElement);

    CPeerMgr::OnDefaultsPassivate(_pElement);

    _pElement->SubRelease();
    _pElement = NULL;

    if (_pStyle)
    {
        delete _pStyle;
        _pStyle = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::PrivateQueryInterface, per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF (this, IOleCommandTarget, NULL)
    QI_HTML_TEAROFF(this, IHTMLElementDefaults, NULL)

    default:

        if (IsEqualGUID(CLSID_HTMLDefaults, iid))
        {
            *ppv = this;
            return S_OK;
        }

        break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::OnPropertyChange
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    dwFlags |= ELEMCHNG_DONTFIREEVENTS;
    hr = _pElement->OnPropertyChange(dispid, dwFlags);
    if ( FAILED(hr) )
        goto Cleanup;

    hr = super::OnPropertyChange(dispid, dwFlags);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::EnsureStyle
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::EnsureStyle(CStyle ** ppStyle)
{
    HRESULT     hr = S_OK;

    Assert (ppStyle);

    *ppStyle = NULL;

    if (!_pStyle)
    {
        _pStyle = new CStyle(_pElement, DISPID_UNKNOWN, CStyle::STYLE_SEPARATEFROMELEM | CStyle::STYLE_DEFSTYLE);
        if (!_pStyle)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppStyle = _pStyle;

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::GetStyleAttrArray
//
//-------------------------------------------------------------------------

CAttrArray *
CDefaults::GetStyleAttrArray()
{
    if (_pStyle)
    {
        CAttrArray **ppAA = _pStyle->GetAttrArray();
        return ppAA ? *ppAA : NULL;
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::get_style
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::get_style(IHTMLStyle ** ppStyle)
{
    HRESULT     hr = S_OK;
    CStyle *    pStyle = NULL;

    *ppStyle = NULL;

    hr = THR(EnsureStyle(&pStyle));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pStyle->QueryInterface(IID_IHTMLStyle, (void**)ppStyle));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::GetAAcanHaveHTML
//
//-------------------------------------------------------------------------

BOOL
CDefaults::GetAAcanHaveHTML(VARIANT_BOOL *pfValue) const 
{
    DWORD v;
    BOOL retVal = CAttrArray::FindSimple(*GetAttrArray(), &s_propdescCDefaultscanHaveHTML.a, &v);
    if (pfValue)
        *pfValue = *(VARIANT_BOOL*)&v;
    return retVal;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefaults::Exec
//
//--------------------------------------------------------------------------

HRESULT
CDefaults::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    if (*pguidCmdGroup == CGID_ProtectedElementPrivate)
    {
        // Reference Media for layout
        if (nCmdID == IDM_ELEMENTP_SETREFERENCEMEDIA)
        {
            hr = SetReferenceMediaForLayout((mediaType) nCmdexecopt);
        }
    }
    
    RRETURN_NOTRACE(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDefaults::put_viewLink
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDefaults::put_viewLink(IHTMLDocument * pISlave)
{
    HRESULT             hr = 0;
    AAINDEX             aaIdx           = FindAAIndex(DISPID_INTERNAL_VIEWLINK, CAttrValue::AA_Internal);
    IMarkupContainer *  pIMarkupSlave   = NULL;
    CMarkup *           pMarkupSlave    = NULL;
    CElement *          pElemSlave      = NULL;

    // Validation

    // 1. For now, allow viewLinking only for generic tags
    Assert(_pElement->TagType() == ETAG_GENERIC);

    if (pISlave)
    {
        hr = THR(pISlave->QueryInterface(IID_IMarkupContainer, (void**) &pIMarkupSlave));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        hr = THR(pIMarkupSlave->QueryInterface(CLSID_CMarkup, (void**) &pMarkupSlave));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        Assert(pMarkupSlave);

        // Make sure that the slave and the master are in the same CDoc
        if (_pElement->Doc() != pMarkupSlave->Doc())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        pElemSlave = pMarkupSlave->Root();

        
        // 2. Make sure that pMarkupSlave does not already have a master
        if ( pElemSlave )
        {
            if (pElemSlave->HasMasterPtr())
            {
                hr = (pElemSlave->GetMasterPtr() == _pElement) ? S_OK : E_INVALIDARG;
                goto Cleanup;
            }
        }

        // 3. Make sure that a cylce is not being created
        if (_pElement->IsCircularViewLink(pMarkupSlave))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

    }

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        if (pISlave)
        {
            hr = AddUnknownObject(DISPID_INTERNAL_VIEWLINK, pISlave, CAttrValue::AA_Internal);
        }
    }
    else
    {
        if ( pISlave )
        {
            hr = ChangeUnknownObjectAt(aaIdx, pISlave);
        }
        else
        {
            DeleteAt(aaIdx);
        }
    }
    if (hr)
        goto Cleanup;

    hr = THR(_pElement->SetViewSlave(pElemSlave));

Cleanup:
    ReleaseInterface(pIMarkupSlave);
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CDefaults::get_viewLink
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDefaults::get_viewLink(IHTMLDocument ** ppISlave)
{
    HRESULT     hr;
    CDefaults * pHead = this;
    IUnknown  * pIUnk = NULL;
    
    if (!ppISlave)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppISlave = NULL;

    if (   _pElement->ShouldHaveLayout()
        && _pElement->GetUpdatedLayout()->ViewChain()
        && _pElement->GetUpdatedLayout()->ViewChain()->GetLayoutOwner()) 
    {
        pHead = _pElement->GetUpdatedLayout()->ViewChain()->GetLayoutOwner()->ElementOwner()->GetDefaults();
    }

    hr = THR(pHead->GetUnknownObjectAt(
            pHead->FindAAIndex(DISPID_INTERNAL_VIEWLINK, CAttrValue::AA_Internal),
            &pIUnk));
    if (FAILED(hr))
        goto Cleanup;

    hr = pIUnk->QueryInterface(IID_IHTMLDocument, (void **)ppISlave);        

Cleanup:
    ReleaseInterface(pIUnk);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDefaults::SetReferenceMediaForMeasurement
//
//  Synopsis:   Enables layout for a reference media
//
//-----------------------------------------------------------------------------

HRESULT
CDefaults::SetReferenceMediaForLayout(mediaType media)
{
    Assert(_pElement);
    
    HRESULT hr = S_OK;

    // Store the media in ELEMENT's attr array. 
    // It will be set in CFancyFormat by ApplyFormatInfoProperty.
    {
        AAINDEX aaIdx = _pElement->FindAAIndex(DISPID_INTERNAL_MEDIA_REFERENCE, CAttrValue::AA_StyleAttribute);
        if (aaIdx == AA_IDX_UNKNOWN)
        {
            // media is not set yet. Only set if this is a non-default value
            if (mediaTypeNotSet == media)
                goto Cleanup;
                
            hr = _pElement->AddSimple(DISPID_INTERNAL_MEDIA_REFERENCE, media, CAttrValue::AA_StyleAttribute);
        }
        else
        {
            // this attribute has been set. do nothing if it is not changing
            DWORD dwOldValue = 0; // keep compiler happy
            if (S_OK != (hr = _pElement->GetSimpleAt(aaIdx, &dwOldValue)) || dwOldValue == (DWORD) media)
                goto Cleanup;

            hr = _pElement->ChangeSimpleAt(aaIdx, media);
        }
    }
    if (hr)
        goto Cleanup;

    // This is positively a different media. Destroy all layouts if any exist
    // NOTE: this is because we can't dynamically change context on a layout tree.
    //       If we could, it would work much faster.
    if (_pElement->CurrentlyHasAnyLayout())
    {
        _pElement->DestroyLayout();
        _pElement->GetFirstBranch()->VoidFancyFormat();    // must recalc fancy format before we re-create layout
  
        // this will invalidate the layout.
        // we don't need to call this if the layout doesn't exist yet (it will force layout creation).
        hr = _pElement->OnPropertyChange(DISPID_INTERNAL_MEDIA_REFERENCE, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\formats.cxx ===
//+ ---------------------------------------------------------------------------
//
//  File:       formats.cxx
//
//  Contents:   ComputeFormats and associated utilities
//
//  Classes:
//
// ----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FCACHE_HXX_
#define X_FCACHE_HXX_
#include "fcache.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_CURSTYLE_HXX_
#define X_CURSTYLE_HXX_
#include "curstyle.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_RECALC_H_
#define X_RECALC_H_
#include "recalc.h"
#endif

#ifndef X_RECALC_HXX_
#define X_RECALC_HXX_
#include "recalc.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_CUSTCUR_HXX_
#define X_CUSTCUR_HXX_
#include "custcur.hxx"
#endif

#ifndef X_LOI_HXX_
#define X_LOI_HXX_
#include <loi.hxx>
#endif

#ifndef X_WSMGR_HXX_
#define X_WSMGR_HXX_
#include "wsmgr.hxx"
#endif


// Debugging ------------------------------------------------------------------

DeclareTag(tagMetrics, "Metrics", "Metrics");
DeclareTag(tagFormatCaches, "FormatCaches", "Trace format caching");
DeclareTag(tagNoPrintFilters, "Filter", "Don't print filters");
ExternTag(tagRecalcStyle);
ExternTag(tagLayoutTasks);
MtExtern( CCustomCursor)

PerfDbgExtern(tagDataCacheDisable);
MtDefine(THREADSTATE_pCharFormatCache, THREADSTATE, "THREADSTATE::_pCharFormatCache")
MtDefine(THREADSTATE_pParaFormatCache, THREADSTATE, "THREADSTATE::_pParaFormatCache")
MtDefine(THREADSTATE_pFancyFormatCache, THREADSTATE, "THREADSTATE::_pFancyFormatCache")
MtDefine(THREADSTATE_pStyleExpandoCache, THREADSTATE, "THREADSTATE::_pStyleExpandoCache")
MtDefine(THREADSTATE_pLineInfoCache, THREADSTATE, "THREADSTATE::_pLineInfoCache")
MtDefine(THREADSTATE_pPseudoElementInfoCache, THREADSTATE, "THREADSTATE::_pPseudoElementInfoCache")
MtDefine(THREADSTATE_pCustomCursorCache, THREADSTATE, "THREADSTATE::_pCustomCursorCache")
MtDefine(CStyleSheetHref, CStyleSheet, "CStyleSheet::GetAbsoluteHref")
MtDefine(ComputeFormats, Metrics, "ComputeFormats")
MtDefine(CharFormatAddRef, ComputeFormats, "CharFormat simple AddRef")
MtDefine(CharFormatTouched, ComputeFormats, "CharFormat touched needlessly")
MtDefine(CharFormatCached, ComputeFormats, "CharFormat cached")
MtDefine(ParaFormatAddRef, ComputeFormats, "ParaFormat simple AddRef")
MtDefine(ParaFormatTouched, ComputeFormats, "ParaFormat touched needlessly")
MtDefine(ParaFormatCached, ComputeFormats, "ParaFormat cached")
MtDefine(FancyFormatAddRef, ComputeFormats, "FancyFormat simple AddRef")
MtDefine(FancyFormatTouched, ComputeFormats, "FancyFormat touched needlessly")
MtDefine(FancyFormatCached, ComputeFormats, "FancyFormat cached")
MtDefine(CharParaFormatVoided, ComputeFormats, "Char/ParaFormat voided");
MtDefine(FancyFormatVoided, ComputeFormats, "FancyFormat voided");
MtDefine(StyleExpandoCached, ComputeFormats, "StyleExpando cached")
MtDefine(StyleExpandoAddRef, ComputeFormats, "StyleExpando simple AddRef")
MtDefine(PseudoElementInfoCached, ComputeFormats, "Pseudo element info cached")
MtDefine(PseudoElementInfoAddRef, ComputeFormats, "Pseudo element info simple AddRef")

#ifdef MULTI_FORMAT
MtDefine(CFormatTable_aryFC_pv, ComputeFormats, "CFormatTable::_aryFC::_pv")
#endif //MULTI_FORMAT

// Globals --------------------------------------------------------------------

CCharFormat     g_cfStock;
CParaFormat     g_pfStock;
CFancyFormat    g_ffStock;
CLineOtherInfo  g_loiStock;
BOOL            g_fStockFormatsInitialized = FALSE;

#define MAX_FORMAT_INDEX 0x7FFF

// Thread Init + Deinit -------------------------------------------------------

void
DeinitFormatCache (THREADSTATE * pts)
{
#if DBG == 1
    if(pts->_pCharFormatCache)
    {
        TraceTag((tagMetrics, "Format Metrics:"));

        TraceTag((tagMetrics, "\tSize of formats char:%ld para:%ld fancy: %ld",
                                sizeof (CCharFormat),
                                sizeof (CParaFormat),
                                sizeof (CFancyFormat)));

        TraceTag((tagMetrics, "\tMax char format cache entries: %ld",
                                pts->_pCharFormatCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax para format cache entries: %ld",
                                pts->_pParaFormatCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax fancy format cache entries: %ld",
                                pts->_pFancyFormatCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax currentStyle expando cache entries: %ld",
                                pts->_pStyleExpandoCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax CustomCursor cache entries: %ld",
                                pts->_pCustomCursorCache->_cMaxEls));                                
    }
#endif

    if (pts->_pParaFormatCache)
    {
        if (pts->_ipfDefault >= 0)
            pts->_pParaFormatCache->ReleaseData(pts->_ipfDefault);
        delete pts->_pParaFormatCache;
        pts->_pParaFormatCache = NULL;
    }

    if (pts->_pFancyFormatCache)
    {
        if (pts->_iffDefault >= 0)
            pts->_pFancyFormatCache->ReleaseData(pts->_iffDefault);
        delete pts->_pFancyFormatCache;
        pts->_pFancyFormatCache = NULL;
    }

    
    delete pts->_pCharFormatCache;
    pts->_pCharFormatCache = NULL;
    
    delete pts->_pStyleExpandoCache;
    pts->_pStyleExpandoCache = NULL;
    
    delete pts->_pLineInfoCache;
    pts->_pLineInfoCache = NULL;

    delete pts->_pCustomCursorCache;
    pts->_pCustomCursorCache = NULL;

    if (pts->_pPseudoElementInfoCache)
    {
        if (pts->_iPEIDefault >= 0)
            pts->_pPseudoElementInfoCache->ReleaseData(pts->_iPEIDefault);
        delete pts->_pPseudoElementInfoCache;
        pts->_pPseudoElementInfoCache = NULL;
    }
}

HRESULT InitFormatCache(THREADSTATE * pts)                     // Called by CDoc::Init()
{
    CParaFormat pf;
    CFancyFormat ff;
    CPseudoElementInfo pei;
    HRESULT hr = S_OK;

#ifdef GENERALISED_STEALING
    void InitETagsTable();
    
    InitETagsTable();
#endif
    
    if (!g_fStockFormatsInitialized)
    {
        g_cfStock._ccvTextColor = RGB(0,0,0);
        g_ffStock._ccvBackColor = RGB(0xff, 0xff, 0xff);
        g_pfStock._lFontHeightTwips = 240;
        g_loiStock.InitDefault();

        //we only set this bit in Stock object. This prevents
        //successful comparisions with Stock object and therefore,
        //it prevents -1 from being a valid index in the LOI cache.
        //So we can Assert(iLOI == -1) in suspicious places.
        g_loiStock._fIsStockObject = 1;

        g_fStockFormatsInitialized = TRUE;
    }

    pts->_pCharFormatCache = new(Mt(THREADSTATE_pCharFormatCache)) CCharFormatCache;
    if(!pts->_pCharFormatCache)
        goto MemoryError;

    pts->_pParaFormatCache = new(Mt(THREADSTATE_pParaFormatCache)) CParaFormatCache;
    if(!pts->_pParaFormatCache)
        goto MemoryError;

    pts->_ipfDefault = -1;
    pf.InitDefault();
    pf._fHasDirtyInnerFormats = pf.AreInnerFormatsDirty();
    hr = THR(pts->_pParaFormatCache->CacheData(&pf, &pts->_ipfDefault));
    if (hr)
        goto Cleanup;

    pts->_ppfDefault = &(*pts->_pParaFormatCache)[pts->_ipfDefault];

    pts->_pFancyFormatCache = new(Mt(THREADSTATE_pFancyFormatCache)) CFancyFormatCache;
    if(!pts->_pFancyFormatCache)
        goto MemoryError;

    pts->_iffDefault = -1;
    ff.InitDefault();
    hr = THR(pts->_pFancyFormatCache->CacheData(&ff, &pts->_iffDefault));
    if (hr)
        goto Cleanup;

    pts->_pffDefault = &(*pts->_pFancyFormatCache)[pts->_iffDefault];

    pts->_pStyleExpandoCache = new(Mt(THREADSTATE_pStyleExpandoCache)) CStyleExpandoCache;
    if(!pts->_pStyleExpandoCache)
        goto MemoryError;

    pts->_pLineInfoCache = new(Mt(THREADSTATE_pLineInfoCache)) CLineInfoCache;
    if(!pts->_pLineInfoCache)
        goto MemoryError;
    pts->_iloiCache = -1;

    pts->_iPEIDefault = -1;
    pts->_pPseudoElementInfoCache = new(Mt(THREADSTATE_pPseudoElementInfoCache)) CPseudoElementInfoCache;
    if (!pts->_pPseudoElementInfoCache)
        goto MemoryError;
    pei.InitDefault();
    hr = THR(pts->_pPseudoElementInfoCache->CacheData(&pei, &pts->_iPEIDefault));
    if (hr)
        goto MemoryError;
    pts->_pPEIDefault = &(*pts->_pPseudoElementInfoCache)[pts->_iPEIDefault];

    pts->_pCustomCursorCache = new(Mt(THREADSTATE_pCustomCursorCache)) CCustomCursorCache;
    if(!pts->_pCustomCursorCache)
        goto MemoryError;

    
Cleanup:
    RRETURN(hr);

MemoryError:
    DeinitFormatCache(pts);
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureUserStyleSheets
//
//  Synopsis:   Ensure the user stylesheets collection exists if specified by
//              user in option setting, creates it if not..
//
//----------------------------------------------------------------------------

HRESULT EnsureUserStyleSheets(LPTSTR pchUserStylesheet)
{
    CCSSParser       *pcssp;
    HRESULT          hr = S_OK;
    CStyleSheetArray *pUSSA = TLS(pUserStyleSheets);
    CStyleSheet      *pUserStyleSheet = NULL;  // The stylesheet built from user specified file in Option settings
    const TCHAR      achFileProtocol[8] = _T("file://");

    if (pUSSA)
    {
        if (!_tcsicmp(pchUserStylesheet, pUSSA->_cstrUserStylesheet))
            goto Cleanup;
        else
        {
            // Force the user stylesheets collection to release its refs on stylesheets/rules.
            // No need to rel as no owner,
            pUSSA->Free( );

            // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
            // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
            pUSSA->CBase::PrivateRelease();
            pUSSA = TLS(pUserStyleSheets) = NULL;
        }
    }

    // bail out if user SS file is not specified, but "Use My Stylesheet" is checked in options
    if (!*pchUserStylesheet)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pUSSA = new CStyleSheetArray(NULL, NULL, 0);
    if (!pUSSA || pUSSA->_fInvalid)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pUSSA->CreateNewStyleSheet(NULL, &pUserStyleSheet));
    if (!SUCCEEDED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE);  // need download...
    hr = S_OK;

    pcssp = new CCSSParser(pUserStyleSheet, NULL);
    if (!pcssp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(!pUserStyleSheet->GetAbsoluteHref() && "absoluteHref already computed.");

    pUserStyleSheet->SetAbsoluteHref((TCHAR *)MemAlloc(Mt(CStyleSheetHref), (_tcslen(pchUserStylesheet) + ARRAY_SIZE(achFileProtocol)) * sizeof(TCHAR)));
    if (! pUserStyleSheet->GetAbsoluteHref())
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy(pUserStyleSheet->GetAbsoluteHref(), achFileProtocol);
    _tcscat(pUserStyleSheet->GetAbsoluteHref(), pchUserStylesheet);

    hr = THR(pcssp->LoadFromFile(pchUserStylesheet, g_cpDefault));
    delete pcssp;
    if (hr)
        goto Cleanup;

    TLS(pUserStyleSheets) = pUSSA;
    pUSSA->_cstrUserStylesheet.Set(pchUserStylesheet);

Cleanup:
    if (hr && pUSSA)
    {
        // Force the user stylesheets collection to release its refs on stylesheets/rules.
        // No need to rel as no owner,
        pUSSA->Free( );

        // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
        // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
        pUSSA->CBase::PrivateRelease();
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureUserStyleSheets
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureUserStyleSheets()
{
    HRESULT     hr = S_OK;
    CStyleSheetArray *pUSSA = TLS(pUserStyleSheets);

    if (   _pOptionSettings 
        && _pOptionSettings->fUseMyStylesheet 
        && !_pOptionSettings->cstrUserStylesheet.IsNull())
    {
        hr = THR(::EnsureUserStyleSheets(_pOptionSettings->cstrUserStylesheet));
    }
    else if (pUSSA)
    {
        // Force the user stylesheets collection to release its refs on stylesheets/rules.
        // No need to rel as no owner,
        pUSSA->Free( );

        // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
        // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
        pUSSA->CBase::PrivateRelease();
        TLS(pUserStyleSheets) = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   DeinitUserStyleSheets
//
//  Synopsis:   Deallocates thread local memory for User supplied Style
//              sheets if allocated. Called from DllThreadDetach.
//
//-------------------------------------------------------------------------

void DeinitUserStyleSheets(THREADSTATE *pts)
{
    if (pts->pUserStyleSheets)
    {
        // Force the user stylesheets collection to release its refs on stylesheets/rules.
        // No need to rel as no owner,
        pts->pUserStyleSheets->Free( );

        // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
        // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
        pts->pUserStyleSheets->CBase::PrivateRelease();
        pts->pUserStyleSheets = NULL;
    }
}

// Default CharFormat ---------------------------------------------------------

HRESULT
CMarkup::CacheDefaultCharFormat()
{
    CDoc * pDoc = Doc();

    Assert(!_fDefaultCharFormatCached);
    Assert(pDoc->_pOptionSettings);
    Assert(pDoc->_icfDefault == -1 || !_fHasDefaultCharFormat);

    THREADSTATE * pts = GetThreadState();
    CCharFormat cf;
    HRESULT hr = S_OK;

    cf.InitDefault(pDoc->_pOptionSettings, GetCodepageSettings());
    cf._bCrcFont = cf.ComputeFontCrc();
    cf._fHasDirtyInnerFormats = !!cf.AreInnerFormatsDirty();

    if (pDoc->_icfDefault < 0)
    {
        hr = THR(pts->_pCharFormatCache->CacheData(&cf, &pDoc->_icfDefault));
        if (hr == S_OK)
            pDoc->_pcfDefault = &(*pts->_pCharFormatCache)[pDoc->_icfDefault];
        else
            pDoc->_icfDefault = -1;
    }
    else if (memcmp(&cf, pDoc->_pcfDefault, sizeof(CCharFormat)))
    {
        long icfDefault;

        hr = THR(pts->_pCharFormatCache->CacheData(&cf, &icfDefault));
        if (S_OK == hr)
        {
            hr = SetDefaultCharFormatIndex(icfDefault);
            if (S_OK == hr)
                _fHasDefaultCharFormat = TRUE;
        }
    }

    _fDefaultCharFormatCached = TRUE;

    RRETURN(hr);
}

void
CMarkup::ClearDefaultCharFormat()
{
    if (_fHasDefaultCharFormat)
    {
        TLS(_pCharFormatCache)->ReleaseData(GetDefaultCharFormatIndex());
        _fHasDefaultCharFormat = FALSE;
    }
    _fDefaultCharFormatCached = FALSE;
}

void
CDoc::ClearDefaultCharFormat()
{
    if (_icfDefault >= 0)
    {
        TLS(_pCharFormatCache)->ReleaseData(_icfDefault);
        _icfDefault = -1;
        _pcfDefault = NULL;
    }
}

// CFormatInfo ----------------------------------------------------------------

#if DBG==1

void
CFormatInfo::UnprepareForDebug()
{
    _fPreparedCharFormatDebug = FALSE;
    _fPreparedParaFormatDebug = FALSE;
    _fPreparedFancyFormatDebug = FALSE;
    _fPreparedPEIDebug = FALSE;
}

void
CFormatInfo::PrepareCharFormat()
{
    if (!_fPreparedCharFormat)
        PrepareCharFormatHelper();
    _fPreparedCharFormatDebug = TRUE;
}

void
CFormatInfo::PrepareParaFormat()
{
    if (!_fPreparedParaFormat)
        PrepareParaFormatHelper();
    _fPreparedParaFormatDebug = TRUE;
}

void
CFormatInfo::PrepareFancyFormat()
{
    if (!_fPreparedFancyFormat)
        PrepareFancyFormatHelper();
    _fPreparedFancyFormatDebug = TRUE;
}

void
CFormatInfo::PreparePEI()
{
    if (!_fPreparedPEI)
        PreparePEIHelper();
    _fPreparedPEIDebug = TRUE;
}

CCharFormat &
CFormatInfo::_cf()
{
    AssertSz(_fPreparedCharFormatDebug, "Attempt to access _cf without calling PrepareCharFormat");
    return(_cfDst);
}

CParaFormat &
CFormatInfo::_pf()
{
    AssertSz(_fPreparedParaFormatDebug, "Attempt to access _pf without calling PrepareParaFormat");
    return(_pfDst);
}

CFancyFormat &
CFormatInfo::_ff()
{
    AssertSz(_fPreparedFancyFormatDebug, "Attempt to access _ff without calling PrepareFancyFormat");
    return(_ffDst);
}

CPseudoElementInfo &
CFormatInfo::_pei()
{
    AssertSz(_fPreparedPEIDebug, "Attempt to access _PEI without calling PreparePEI");
    return(_PEI);
}

#endif

void
CFormatInfo::Cleanup()
{
    if (_pAAExpando)
    {
        _pAAExpando->Free();
        _pAAExpando = NULL;
    }

    if ( _pCustomCursor )
    {
        delete _pCustomCursor;
        _pCustomCursor = NULL;
    }
    _cstrBgImgUrl.Free();
    _cstrLiImgUrl.Free();
    _cstrFilters.Free();
    _cstrPseudoBgImgUrl.Free();
}


CAttrArray *
CFormatInfo::GetAAExpando()
{
    if (_pAAExpando == NULL)
    {
        memset(&_AAExpando, 0, sizeof(_AAExpando));
        _pAAExpando = &_AAExpando;

        if (_pff->_iExpandos >= 0)
        {
            IGNORE_HR(_pAAExpando->CopyExpandos(GetExpandosAttrArrayFromCacheEx(_pff->_iExpandos)));
        }

        _fHasExpandos = TRUE;
    }

    return(_pAAExpando);
}


CCustomCursor*
CFormatInfo::GetCustomCursor()
{
    if (_pCustomCursor == NULL)
    {
        _pCustomCursor = new CCustomCursor();        
    }

    return(_pCustomCursor);
}

void
CFormatInfo::PrepareCharFormatHelper()
{
    Assert(_pcfSrc != NULL && _pcf == _pcfSrc);
    _pcf = &_cfDst;
    memcpy(&_cfDst, _pcfSrc, sizeof(CCharFormat));
    _fPreparedCharFormat = TRUE;
}

void
CFormatInfo::PrepareParaFormatHelper()
{
    Assert(_ppfSrc != NULL && _ppf == _ppfSrc);
    _ppf = &_pfDst;
    memcpy(&_pfDst, _ppfSrc, sizeof(CParaFormat));
    _fPreparedParaFormat = TRUE;
}

void
CFormatInfo::PrepareFancyFormatHelper()
{
    Assert(_pffSrc != NULL && _pff == _pffSrc);
    _pff = &_ffDst;
    memcpy(&_ffDst, _pffSrc, sizeof(CFancyFormat));
    _fPreparedFancyFormat = TRUE;
}

void
CFormatInfo::PreparePEIHelper()
{
    _PEI.InitDefault();
    _fPreparedPEI = TRUE;
}

HRESULT
CFormatInfo::ProcessImgUrl(CElement * pElem, LPCTSTR lpszUrl, DISPID dispID,
    LONG * plCookie, BOOL fHasLayout)
{
    HRESULT hr = S_OK;
    BOOL fForPseudo =    dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE
                      || dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER

                      // These two take care to not reload bg images for
                      // for element backgrounds if the element has any
                      // pseudo-element on it.
                      || _ppf->_fHasPseudoElement           // Normal compute formats
                      || pElem->GetMarkup()->HasCFState();  // Pseudoelement compute formats

        
    if (lpszUrl && *lpszUrl)
    {
        NoStealing();
        hr = THR(pElem->GetImageUrlCookie(lpszUrl, plCookie, !fForPseudo));
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // Return a null cookie.
        //
        *plCookie = 0;
    }

    hr = THR(pElem->AddImgCtx(dispID, *plCookie));
    if (hr)
    {
        pElem->Doc()->ReleaseUrlImgCtx(*plCookie, pElem);
        goto Cleanup;
    }


    if (dispID == DISPID_A_LIURLIMGCTXCACHEINDEX)
    {
        // url images require a request resize when modified
        pElem->_fResizeOnImageChange = *plCookie != 0;
    }
    else if (   dispID == DISPID_A_BGURLIMGCTXCACHEINDEX
             || dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE
             || dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER
            )
    {
        // sites draw their own background, so we don't have to inherit
        // their background info
        if (!fHasLayout)
        {
            PrepareCharFormat();
            _cf()._fHasBgImage = (*plCookie != 0);
            UnprepareForDebug();
        }
    }

Cleanup:
    RRETURN(hr);
}

// ComputeFormats Helpers -----------------------------------------------------

const CCharFormat *
CTreeNode::GetCharFormatHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context (except in a few cases)
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM))) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM);
#ifdef MULTI_FORMAT
    long iCF = GetICF(FCPARAM);        
    return(iCF >= 0 ? GetCharFormatEx(iCF) : &g_cfStock);
#else
    return(_iCF >= 0 ? GetCharFormatEx(_iCF) : &g_cfStock);
#endif //MULTI_FORMAT
}

const CParaFormat *
CTreeNode::GetParaFormatHelper( FORMAT_CONTEXT FCPARAM)
{
    // If we shold have context, we should be called with context 
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM))) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM);
#ifdef MULTI_FORMAT
    long iPF = GetIPF(FCPARAM);        
    return(iPF >= 0 ? GetParaFormatEx(iPF) : &g_pfStock);
#else
    return(_iPF >= 0 ? GetParaFormatEx(_iPF) : &g_pfStock);
#endif //MULTI_FORMAT
}

const CFancyFormat *
CTreeNode::GetFancyFormatHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context 
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM))) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM);
#ifdef MULTI_FORMAT
    long iFF = GetIFF(FCPARAM);        
    return(iFF >= 0 ? GetFancyFormatEx(iFF) : &g_ffStock);
#else
    return(_iFF >= 0 ? GetFancyFormatEx(_iFF) : &g_ffStock);
#endif //MULTI_FORMAT
}

long
CTreeNode::GetCharFormatIndexHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM)) ) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM );
    
    return(GetICF(FCPARAM));
}

long
CTreeNode::GetParaFormatIndexHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM)) ) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM );
    
    return(GetIPF(FCPARAM));
}

long
CTreeNode::GetFancyFormatIndexHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM)) ) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM );
    
    return(GetIFF(FCPARAM));
}

//+----------------------------------------------------------------------------
//
//  Member:     CNode::CacheNewFormats
//
//  Synopsis:   This function is called on conclusion on ComputeFormats
//              It caches the XFormat's we have just computed.
//              This exists so we can share more code between
//              CElement::ComputeFormats and CTable::ComputeFormats
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
CTreeNode::CacheNewFormats(CFormatInfo * pCFI FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    THREADSTATE * pts = GetThreadState();
    LONG lIndex, iExpando = -1, iPEI = -1, iCustomCursor = -1 ;
    HRESULT hr = S_OK;
    
#ifdef MULTI_FORMAT
    if (!EnsureFormatAry()) 
    {
        goto Error;
    }
#endif

    Assert(   (   GetICF(FCPARAM) == -1 
               && GetIPF(FCPARAM) == -1
              )
           || (   GetICF(FCPARAM) != -1 
               && GetIPF(FCPARAM) != -1
              )
          );
    Assert(GetIFF(FCPARAM) == -1);
   
#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDataCacheDisable))
    {
        pCFI->PrepareCharFormat();
        pCFI->PrepareParaFormat();
        pCFI->PrepareFancyFormat();
    }
#endif

    if ( GetICF(FCPARAM) == -1 )
    {
        //
        // CCharFormat
        //

        if (!pCFI->_fPreparedCharFormat)
        {
            MtAdd(Mt(CharFormatAddRef), 1, 0);
            SetICF(pCFI->_icfSrc FCCOMMA FCPARAM);
            pts->_pCharFormatCache->AddRefData(pCFI->_icfSrc);
        }
        else
        {
            WHEN_DBG(pCFI->_fPreparedCharFormatDebug = TRUE;)

            pCFI->_cf()._bCrcFont = pCFI->_cf().ComputeFontCrc();
            pCFI->_cf()._fHasDirtyInnerFormats = !!pCFI->_cf().AreInnerFormatsDirty();

            MtAdd(pCFI->_pcfSrc->Compare(&pCFI->_cf()) ? Mt(CharFormatTouched) : Mt(CharFormatCached), 1, 0);

            hr = THR(pts->_pCharFormatCache->CacheData(&pCFI->_cf(), &lIndex));
            if (hr)
                goto Error;

            //protection from overflowing 15-bit _iCF... Use stock, don't crash (IE6 26698)
            if(lIndex >= MAX_FORMAT_INDEX)
            {
                CMarkup *pMarkup = GetMarkup();
                if(pMarkup && pMarkup->_fDefaultCharFormatCached)
                {
                    pts->_pCharFormatCache->ReleaseData(lIndex);

                    Assert(Doc()->_icfDefault != -1 || pMarkup->_fHasDefaultCharFormat);

                    if (pMarkup->_fHasDefaultCharFormat)
                    {
                        lIndex = pMarkup->GetDefaultCharFormatIndex(); 
                    }
                    else
                    {
                        lIndex = Doc()->_icfDefault;
                    }

                    pts->_pCharFormatCache->AddRefData(lIndex);
                }
            }

            Assert(lIndex < MAX_FORMAT_INDEX && lIndex >= 0);
            SetICF(lIndex FCCOMMA FCPARAM);
        }

        //
        // ParaFormat
        //

        if (!pCFI->_fPreparedParaFormat)
        {
            MtAdd(Mt(ParaFormatAddRef), 1, 0);
            SetIPF(pCFI->_ipfSrc FCCOMMA FCPARAM);
            pts->_pParaFormatCache->AddRefData(pCFI->_ipfSrc);
        }
        else
        {
            WHEN_DBG(pCFI->_fPreparedParaFormatDebug = TRUE;)

            pCFI->_pf()._fHasDirtyInnerFormats = pCFI->_pf().AreInnerFormatsDirty();

            MtAdd(pCFI->_ppfSrc->Compare(&pCFI->_pf()) ? Mt(ParaFormatTouched) : Mt(ParaFormatCached), 1, 0);

            hr = THR(pts->_pParaFormatCache->CacheData(&pCFI->_pf(), &lIndex));
            if (hr)
                goto Error;

            //protection from overflowing 15-bit _iPF... Use stock, don't crash (IE6 26698)
            if(lIndex >= MAX_FORMAT_INDEX)
            {
                pts->_pParaFormatCache->ReleaseData(lIndex);
                lIndex = pts->_ipfDefault; 
                pts->_pParaFormatCache->AddRefData(lIndex);
            }

            Assert( lIndex < MAX_FORMAT_INDEX && lIndex >= 0 );
            SetIPF(lIndex FCCOMMA FCPARAM);
           
        }

        TraceTag((
            tagFormatCaches,
            "Caching char & para format for "
            "element (tag: %ls, SN: E%d N%d) in %d, %d",
            Element()->TagName(), Element()->SN(), SN(), _iCF, _iPF ));
    }

    //
    // CFancyFormat
    //

    if (pCFI->_pAAExpando)
    {
        MtAdd(Mt(StyleExpandoCached), 1, 0);

        hr = THR(pts->_pStyleExpandoCache->CacheData(pCFI->_pAAExpando, &iExpando));
        if (hr)
            goto Error;

        if (pCFI->_pff->_iExpandos != iExpando)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._iExpandos = iExpando;
            pCFI->UnprepareForDebug();
        }

        pCFI->_pAAExpando->Free();
        pCFI->_pAAExpando = NULL;
    }
    else
    {
        #ifdef PERFMETER
        if (pCFI->_pff->_iExpandos >= 0)
            MtAdd(Mt(StyleExpandoAddRef), 1, 0);
        #endif
    }


    if (pCFI->_pCustomCursor)
    {
        hr = THR(pts->_pCustomCursorCache->CacheData(pCFI->_pCustomCursor, &iCustomCursor));
        if (hr)
            goto Error;

        if (pCFI->_pff->_iCustomCursor != iCustomCursor)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._iCustomCursor = iCustomCursor;
            pCFI->UnprepareForDebug();
        }

        //
        // Begin download 
        //
        CCustomCursor* pCursor = GetCustomCursorFromCacheEx( iCustomCursor );
        pCursor->StartDownload();
        
        delete( pCFI->_pCustomCursor ) ;
        pCFI->_pCustomCursor = NULL;
    }

    if (pCFI->_fPreparedPEI)
    {
        MtAdd(Mt(PseudoElementInfoCached), 1, 0);

        hr = THR(pts->_pPseudoElementInfoCache->CacheData(&pCFI->_PEI, &iPEI));
        if (hr)
            goto Error;

        if (pCFI->_pff->_iPEI != iPEI)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._iPEI = iPEI;
            pCFI->UnprepareForDebug();
        }
    }
    else
    {
#ifdef PERFMETER
        if (pCFI->_pff->_iPEI >= 0)
            MtAdd(Mt(PseudoElementInfoAddRef), 1, 0);
#endif
    }

    if (!pCFI->_fPreparedFancyFormat)
    {
        MtAdd(Mt(FancyFormatAddRef), 1, 0);
        SetIFF(pCFI->_iffSrc FCCOMMA FCPARAM);
        pts->_pFancyFormatCache->AddRefData(pCFI->_iffSrc);
    }
    else
    {
        WHEN_DBG(pCFI->_fPreparedFancyFormatDebug = TRUE;)

        MtAdd(pCFI->_pffSrc->Compare(&pCFI->_ff()) ? Mt(FancyFormatTouched) : Mt(FancyFormatCached), 1, 0);

        hr = THR(pts->_pFancyFormatCache->CacheData(&pCFI->_ff(), &lIndex));
        if (hr)
            goto Error;

        //protection from overflowing 15-bit _iFF... Use stock, don't crash (IE6 26698)
        if(lIndex >= MAX_FORMAT_INDEX)
        {
            pts->_pFancyFormatCache->ReleaseData(lIndex);
            lIndex = pts->_iffDefault; 
            pts->_pFancyFormatCache->AddRefData(lIndex);
        }

        Assert(lIndex < MAX_FORMAT_INDEX && lIndex >= 0);
        SetIFF(lIndex FCCOMMA FCPARAM);
 
        if (iExpando >= 0)
        {
            pts->_pStyleExpandoCache->ReleaseData(iExpando);
        }

        if (iCustomCursor >= 0)
        {
            pts->_pCustomCursorCache->ReleaseData(iCustomCursor);
        }
        
        if (iPEI >= 0)
        {
            pts->_pPseudoElementInfoCache->ReleaseData(iPEI);
        }
    }

    TraceTag((
        tagFormatCaches,
        "Caching fancy format for "
        "node (tag: %ls, SN: E%d N%d) in %d",
        Element()->TagName(), Element()->SN(), SN(), _iFF ));

    Assert(  GetICF(FCPARAM) >= 0           
          && GetIPF(FCPARAM) >= 0 
          && GetIFF(FCPARAM) >= 0);
 
    pCFI->UnprepareForDebug();

    Assert(!pCFI->_pAAExpando);
    Assert(!pCFI->_cstrBgImgUrl);
    Assert(!pCFI->_cstrLiImgUrl);
    Assert(!pCFI->_cstrPseudoBgImgUrl);
    Assert(!pCFI->_pCustomCursor );
    
    return S_OK;

Error:
    if (_iCF >= 0) pts->_pCharFormatCache->ReleaseData(_iCF);
    if (_iPF >= 0) pts->_pParaFormatCache->ReleaseData(_iPF);
    if (_iFF >= 0) pts->_pFancyFormatCache->ReleaseData(_iFF);
    if (iExpando >= 0) pts->_pStyleExpandoCache->ReleaseData(iExpando);
    if (iCustomCursor >= 0) pts->_pCustomCursorCache->ReleaseData(iCustomCursor);
    
    if (iPEI >= 0) pts->_pPseudoElementInfoCache->ReleaseData(iPEI);

    pCFI->Cleanup();

    _iCF = _iPF = _iFF = -1;

    RRETURN(hr);
}

#ifdef MULTI_FORMAT

// These functions need to be updated as the FC/LC conversion process changes.
// They're helpers to ComputeFormats to ease use of different algorithms in finding
// the parent of a node for formatting purposes.
// Right now they do a redundant check, so they need to be kept in sync. Later they will likely be
// combined into one function.

CTreeNode *
CElement::GetParentFormatNode(CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if ( IS_FC(FCPARAM) )
    {
        if (this == FC_TO_LC(FCPARAM)->GetLayoutOwner()->ElementContent())
        {
            return FC_TO_LC(FCPARAM)->GetLayoutOwner()->ElementOwner()->GetFirstBranch();
        }
    }
    return pNodeTarget->Parent();
}

FORMAT_CONTEXT 
CElement::GetParentFormatContext(CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if ( IS_FC(FCPARAM))
    {
        if (this == FC_TO_LC(FCPARAM)->GetLayoutOwner()->ElementContent())
        {
            return LC_TO_FC((FC_TO_LC(FCPARAM)->GetLayoutOwner()->LayoutContext()));
        }

        return FCPARAM;
    }
    return 0;
}

#endif

// ComputeFormats -------------------------------------------------------------

void
CElement::FixupEditable(CFormatInfo *pCFI)
{
    Assert(ETAG_INPUT == _etag || ETAG_TEXTAREA == _etag);
    
    // for input and textarea if contentEditable is not explicity set, then set default as TRUE
    // if not readOnly OR its parent is editable.
    if (!pCFI->_fEditableExplicitlySet)
    {
        BOOL fReadOnly;

        if (ETAG_INPUT == _etag)
        {
            CInput *pInput = DYNCAST(CInput, this);
            htmlInput type = pInput->GetType();
            fReadOnly = (type == htmlInputText || type == htmlInputPassword || type == htmlInputFile) ? pInput->_fReadOnly : TRUE;
        }
        else
            fReadOnly = DYNCAST(CTextArea, this)->_fReadOnly;

        if (!fReadOnly || pCFI->_fParentEditable)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fEditable = TRUE;
            pCFI->UnprepareForDebug();

            _fEditable = TRUE;
        }
        else
            _fEditable = FALSE;
    }
}

MtDefine(IterativeComputeFormats_aryAncestors_pv, Locals, "IterativeComputeFormats::_aryAncestors::CTreeNode*")

#define MAX_CF_DEPTH 100
#define STRIDE_SIZE  (MAX_CF_DEPTH - 5)

HRESULT
CElement::IterativeComputeFormats(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    CTreeNode *pNode;
    CPtrAry<CTreeNode *> aryAncestors(Mt(IterativeComputeFormats_aryAncestors_pv));
    LONG lCount = STRIDE_SIZE;
    COMPUTEFORMATSTYPE      eExtraValues = pCFI->_eExtraValues;
    LONG i;
    
    for(pNode = pNodeTarget; pNode != NULL; pNode = pNode->Parent())
    {
#ifdef MULTI_FORMAT
        if (   (   !pNode->HasFormatAry() 
                && IS_FC(pFCParent)
                )
             || pNode->GetICF(pFCParent) == -1
             || pNode->GetIFF(pFCParent) == -1
             || eExtraValues == ComputeFormatsType_GetInheritedValue 
            )
#else
        if (    pNode->GetICF() == -1
            ||  pNode->GetIFF() == -1
            ||  eExtraValues == ComputeFormatsType_GetInheritedValue 
           )
#endif //MULTI_FORMAT
        {
            lCount--;
            if (lCount == 0)
            {
                aryAncestors.Append(pNode);
                lCount = STRIDE_SIZE;
            }
        }
        else
        {
            // Found a parent which has computed formats. Break and compute the
            // formats for all the ones we have collected in the array
            break;
        }
    }
    
    LONG lDepth = pCFI->_lRecursionDepth;
    pCFI->_lRecursionDepth = 0;
    for (i = aryAncestors.Size() - 1; i >= 0; i--)
    {
        Assert(aryAncestors[i]->Element() != this);
        aryAncestors[i]->Element()->ComputeFormats(pCFI, aryAncestors[i] FCCOMMA FCPARAM);
        Assert(pCFI->_lRecursionDepth == 0);
    }
    pCFI->_lRecursionDepth = lDepth;
    
    return S_OK;
}

#ifdef GENERALISED_STEALING
BYTE g_EtagCache[ETAG_LAST];
void InitETagsTable()
{
#define X(Y) g_EtagCache[ETAG_##Y] = TRUE;
    X(A) X(B) X(FONT) X(I) X(P) X(UL) X(LI) X(CENTER) X(H1) X(H2) X(H3) X(H4)
    X(H5) X(H6) X(HR) X(BR) X(INPUT)
#undef X
}
#endif

HRESULT
CElement::ComputeFormats(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{

    HRESULT hr = S_OK;

    pCFI->_lRecursionDepth++;
    if (pCFI->_lRecursionDepth > MAX_CF_DEPTH)
    {
        CTreeNode *pNodeParent = pNodeTarget->Parent();
        if (pNodeParent)
        {
            hr = THR(IterativeComputeFormats(pCFI, pNodeTarget FCCOMMA FCPARAM));
        }
    }
    hr = THR(ComputeFormatsVirtual(pCFI, pNodeTarget FCCOMMA FCPARAM));
    if (   SUCCEEDED(hr)
        && pNodeTarget->IsInMarkup()
        && pCFI->CanWeSteal()
        && pNodeTarget->IsFirstBranch()
       )
    {
        _fStealingAllowed = TRUE;
        
#ifdef GENERALISED_STEALING
        if (g_EtagCache[pNodeTarget->Tag()])
            TLS(_pNodeLast[pNodeTarget->Tag()]) = pNodeTarget;
#else
        if (pNodeTarget->Tag() == ETAG_A)
            TLS(_pNodeLast) = pNodeTarget;
#endif
    }
    else
    {
        _fStealingAllowed = FALSE;
#ifdef GENERALISED_STEALING
        if (    g_EtagCache[pNodeTarget->Tag()]
            &&  SameScope(TLS(_pNodeLast[pNodeTarget->Tag()]), pNodeTarget)
           )
        {
            TLS(_pNodeLast[pNodeTarget->Tag()]) = NULL;
        }
#else
        if (   pNodeTarget->Tag() == ETAG_A
            && SameScope(TLS(_pNodeLast), pNodeTarget)
           )
        {
            TLS(_pNodeLast) = NULL;
        }
#endif
    }

    // See if we need to register a whitespace change

    if (SUCCEEDED(hr)
        && (!!pNodeTarget->GetParaFormat()->_fPreInner != pNodeTarget->IsPre()))
    {
        CMarkup *pMarkup = pNodeTarget->GetMarkup();

        Assert( pMarkup );
        if (pMarkup->SupportsCollapsedWhitespace())
        {
            hr = THR(Doc()->GetWhitespaceManager()->RegisterWhitespaceChange(pNodeTarget));
        }
    }
    
    pCFI->_lRecursionDepth--;    
    
    RRETURN(hr);
}

BOOL CElement::CanStealFormats(CTreeNode *pNodeVictim)
{
#ifdef GENERALISED_STEALING
    CAttrArray **ppAA1 = GetAttrArray();
    CAttrArray **ppAA2 = pNodeVictim->Element()->GetAttrArray();
    
    return (   (*ppAA1 == NULL && *ppAA2 == NULL)
            || (*ppAA1 != NULL && *ppAA2 != NULL && (*ppAA1)->Compare(*ppAA2))
           );
#else
    Assert("Should never be called for non-A elements without generalised stealing.");
    return FALSE;
#endif
}

#if DBG==1
int g_CFTotalCalls = 0;
int g_CFAttemptedSteals = 0;
int g_CFSuccessfulSteals = 0;
#endif

HRESULT
CElement::AttemptToStealFormats(CFormatInfo * pCFI)
{
    HRESULT hr = S_FALSE;
    CTreeNode * pNodeTarget = pCFI->_pNodeContext;
    THREADSTATE * pts = GetThreadState();
#ifdef GENERALISED_STEALING
    CTreeNode *pNodeOther = pts->_pNodeLast[pNodeTarget->Tag()];
#else
    CTreeNode *pNodeOther = pts->_pNodeLast;
#endif
    
    WHEN_DBG(g_CFTotalCalls++);
    if (pNodeOther && pNodeTarget != pNodeOther)
    {
        CTreeNode *pNodeOtherParent = pNodeOther->Parent();
        CTreeNode *pNodeTargetParent = pNodeTarget->Parent();
        CMarkup *pMarkup = GetMarkup();
        CMarkup *pMarkupOther = pNodeOther->GetMarkup();
        CStyleSheetArray *pssa = pMarkup->GetStyleSheetArray();

        WHEN_DBG(g_CFAttemptedSteals++;)

        if (   pNodeOther->_iCF != -1
            && pNodeOther->_iPF != -1
            && pNodeOther->_iFF != -1
            && pNodeOtherParent
            && pNodeTargetParent
            && (   pNodeOtherParent == pNodeTargetParent
                || (   (pNodeOtherParent->_iCF == pNodeTargetParent->_iCF)
                    && (pNodeOtherParent->_iPF == pNodeTargetParent->_iPF)
                    && (pNodeOtherParent->_iFF == pNodeTargetParent->_iFF)
                    && (  !pssa
                        || pssa->OnlySimpleRulesApplied(pCFI)
                       )
                    && !pts->pUserStyleSheets
                    && !Doc()->_pHostStyleSheets
                   )
               )
            && !pMarkup->HasCFState()
            && !(HasPeerHolder() && GetPeerHolder()->TestFlagMulti(CPeerHolder::NEEDAPPLYSTYLE))
            && pCFI->_eExtraValues == ComputeFormatsType_Normal
            && pMarkup == pMarkupOther
           )
        {
            BOOL fSteal = CanStealFormats(pNodeOther);

            if (fSteal)
            {
                WHEN_DBG(g_CFSuccessfulSteals++;)

                Assert(pNodeOther->Element()->_fStealingAllowed);

                pNodeTarget->SetICF(pNodeOther->_iCF FCCOMMA FCPARAM);
                pts->_pCharFormatCache->AddRefData(pNodeOther->_iCF);

                pNodeTarget->SetIPF(pNodeOther->_iPF FCCOMMA FCPARAM);
                pts->_pParaFormatCache->AddRefData(pNodeOther->_iPF);

                pNodeTarget->SetIFF(pNodeOther->_iFF FCCOMMA FCPARAM);
                pts->_pFancyFormatCache->AddRefData(pNodeOther->_iFF);

                pNodeTarget->_fBlockNess = pNodeOther->_fBlockNess;
                pNodeTarget->_fShouldHaveLayout = pNodeOther->_fShouldHaveLayout;
                _fEditable = pNodeOther->Element()->_fEditable;

                DoLayoutRelatedWork(pNodeTarget->_fShouldHaveLayout);
                
                pCFI->_ProbRules.Invalidate(pssa);

                hr = S_OK;
            }
        }
    }
    
    RRETURN1(hr, S_FALSE);
}


HRESULT
CElement::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    CDoc *                  pDoc = Doc();
    THREADSTATE *           pts  = GetThreadState();
    CTreeNode *             pNodeParent;
    CElement *              pElemParent;
    CDefaults *             pDefaults;   
    BOOL                    fResetPosition = FALSE;
    BOOL                    fComputeFFOnly; // = pNodeTarget->_iCF != -1;
    BOOL                    fInheritEditableFalse;
    BOOL                    fEditable;
    HRESULT                 hr = S_OK;
    COMPUTEFORMATSTYPE      eExtraValues = pCFI->_eExtraValues;

    BOOL                    fRootVisibilityHidden = FALSE;
    CMarkup *               pMarkup = GetMarkup();
    
#ifdef MULTI_FORMAT
    FORMAT_CONTEXT pFCParent = NULL;
#endif //MULTI_FORMAT
    
    fComputeFFOnly = pNodeTarget->GetICF(FCPARAM) != -1;

    Assert(pCFI);
    Assert(SameScope(this, pNodeTarget));
#ifdef MULTI_FORMAT
    Assert(   eExtraValues != ComputeFormatsType_Normal 
           || (    !pNodeTarget->HasFormatAry()
                && IS_FC(FCPARAM) 
              )
           || (    (    pNodeTarget->GetICF(FCPARAM) == -1 
                     && pNodeTarget->GetIPF(FCPARAM) == -1
                   ) 
                ||  pNodeTarget->GetIFF(FCPARAM) == -1 
              )
          );
#else
    Assert(   eExtraValues != ComputeFormatsType_Normal 
           || (    (    pNodeTarget->GetICF(FCPARAM) == -1 
                     && pNodeTarget->GetIPF(FCPARAM) == -1
                   ) 
                ||  pNodeTarget->GetIFF(FCPARAM) == -1 
              )
          );
#endif //MULTI_FORMAT
              
    AssertSz(!TLS(fInInitAttrBag), "Trying to compute formats during InitAttrBag! This is bogus and must be corrected!");

    TraceTag((tagRecalcStyle, "ComputeFormats"));

    //
    // Get the format of our parent before applying our own format.
    //

    pNodeParent = pNodeTarget->Parent();

    // If this is the root and has a master, inherit from master
    if (!pNodeParent && HasMasterPtr())
    {
        CElement *pElemMaster = GetMasterPtr();

        CDefaults *pDefaults = pElemMaster->GetDefaults();                
    
        ELEMENT_TAG etag = pElemMaster->TagType();
        fInheritEditableFalse = (etag==ETAG_GENERIC) || (etag==ETAG_FRAME) || (etag==ETAG_IFRAME);

        if (    (!pDefaults && etag == ETAG_GENERIC)
            ||  (pDefaults && pDefaults->GetAAviewInheritStyle())
            ||  pElemMaster->Tag() == ETAG_INPUT)
        {
            pNodeParent = pElemMaster->GetFirstBranch();
        }
    }
    else
    {
        fInheritEditableFalse = FALSE;
    }
    
#ifdef MULTI_FORMAT

    if ( IS_FC(FCPARAM) )
    {
        // TODO (t-michda) These functions don't work with tables, and the value
        // of pNodeParent gets overwritten below. This is not a problem UNLESS you can
        // flow any of the below elements through a container, in which case these 
        // functions need to be updated to do the right thing.
        pNodeParent = pNodeTarget->Element()->GetParentFormatNode(pNodeTarget, FCPARAM );
        pFCParent = pNodeTarget->Element()->GetParentFormatContext(pNodeTarget, FCPARAM );
                
    }
    
#endif

    switch (_etag)
    {
        case ETAG_TR:
            {
                CTableSection *pSection = DYNCAST(CTableRow, this)->Section();
                if (pSection)
                    pNodeParent = pSection->GetFirstBranch();
            }
            break;
        case ETAG_TBODY:
        case ETAG_THEAD:
        case ETAG_TFOOT:
            {
                CTable *pTable = DYNCAST(CTableSection, this)->Table();
                if (pTable)
                    pNodeParent = pTable->GetFirstBranch();
                fResetPosition = TRUE;
            }
            break;
    }

    if (pNodeParent == NULL)
    {
        //(dmitryt) this can happen if we just processed OnClick event in which we removed the
        //element from the tree and, as a second step, we are trying to bubble the event up.
        //So we are looking at formats to detect if element has a layout and element is still alive but no parent!
        //I've removed assert from here because it's a valid situation. And I've checked that we process 
        //error code correctly in a caller.
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // If the parent node has not computed formats yet, recursively compute them
    //

    pElemParent = pNodeParent->Element();

#ifdef MULTI_FORMAT
    if (       (    !pNodeParent->HasFormatAry() 
                 && IS_FC(pFCParent)
               )
            || pNodeParent->GetICF(pFCParent) == -1
            || pNodeParent->GetIFF(pFCParent) == -1
            || eExtraValues == ComputeFormatsType_GetInheritedValue 
            || eExtraValues == ComputeFormatsType_GetInheritedIntoTableValue
       )
#else
    if (    pNodeParent->GetICF() == -1
        ||  pNodeParent->GetIFF() == -1
        ||  eExtraValues == ComputeFormatsType_GetInheritedValue 
        ||  eExtraValues == ComputeFormatsType_GetInheritedIntoTableValue
       )
#endif //MULTI_FORMAT
    {
        SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

#ifdef MULTI_FORMAT
        hr = THR(pElemParent->ComputeFormats(pCFI, pNodeParent, pFCParent));
#else
        hr = THR(pElemParent->ComputeFormats(pCFI, pNodeParent));
#endif //MULTI_FORMAT

        SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

        if (hr)
            goto Cleanup;
    }

#ifdef MULTI_FORMAT
    Assert(pNodeParent->GetICF(pFCParent) >= 0);
    Assert(pNodeParent->GetIPF(pFCParent) >= 0);
    Assert(pNodeParent->GetIFF(pFCParent) >= 0);
#else
    Assert(pNodeParent->GetICF() >= 0);
    Assert(pNodeParent->GetIPF() >= 0);
    Assert(pNodeParent->GetIFF() >= 0);
#endif
    //
    // NOTE: From this point forward any errors must goto Error instead of Cleanup!
    //

    // At this point, even if the parent ComputeFormat did build a list of probable rules
    // it should have freed it up, else we will leak memory.
    pCFI->Reset();
    pCFI->_pNodeContext = pNodeTarget;

#ifndef GENERALISED_STEALING
    if (pNodeTarget->Tag() == ETAG_A)
#endif
    {
        hr = THR(AttemptToStealFormats(pCFI));
        if (hr == S_OK)
            goto Cleanup; // successful stealing!
    }
    
    if (   eExtraValues != ComputeFormatsType_Normal
        || HasPeerHolder()
        || pMarkup->HasCFState()
       )
    {
        pCFI->NoStealing();
    }
    
    //
    // Setup Fancy Format
    //
    if (_fInheritFF) 
    {
#ifdef MULTI_FORMAT    
        if (IS_FC(pFCParent))  
        {                                 
            pCFI->_iffSrc = pNodeParent->GetIFF(pFCParent);
        } 
        else 
#endif //MULTI_FORMAT        
        {
            pCFI->_iffSrc = pNodeParent->_iFF;
        }
        
        pCFI->_pffSrc = pCFI->_pff = &(*pts->_pFancyFormatCache)[pCFI->_iffSrc];
        pCFI->_fHasExpandos = FALSE;

        if (    pCFI->_pff->_bPositionType != stylePositionNotSet
            ||  pCFI->_pff->_bDisplay != styleDisplayNotSet
            ||  pCFI->_pff->_bVisibility != styleVisibilityNotSet
            ||  pCFI->_pff->GetOverflowX() != styleOverflowNotSet
            ||  pCFI->_pff->GetOverflowY() != styleOverflowNotSet
            ||  pCFI->_pff->_bPageBreaks != 0
            ||  pCFI->_pff->_fPositioned
            ||  pCFI->_pff->_fAutoPositioned
            ||  pCFI->_pff->_fScrollingParent
            ||  pCFI->_pff->_fZParent
            ||  pCFI->_pff->_ccvBackColor.IsDefined()
            ||  pCFI->_pff->_lImgCtxCookie != 0
            ||  pCFI->_pff->_iExpandos != -1
            ||  pCFI->_pff->_iCustomCursor != -1 
            ||  pCFI->_pff->_iPEI != -1
            ||  pCFI->_pff->_fHasExpressions != 0
            ||  pCFI->_pff->_pszFilters
            ||  pCFI->_pff->_fHasNoWrap
            ||  pCFI->_pff->_fLayoutFlowChanged
            ||  pCFI->_pff->_lRotationAngle
            ||  pCFI->_pff->_flZoomFactor)
        {
            CUnitValue uvNull(0, CUnitValue::UNIT_NULLVALUE);

            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bPositionType = stylePositionNotSet;
            pCFI->_ff().SetPosition(SIDE_TOP, uvNull);
            pCFI->_ff().SetPosition(SIDE_LEFT, uvNull);
            pCFI->_ff()._bDisplay = styleDisplayNotSet;
            pCFI->_ff()._bVisibility = styleVisibilityNotSet;
            pCFI->_ff().SetOverflowX(styleOverflowNotSet);
            pCFI->_ff().SetOverflowY(styleOverflowNotSet);
            pCFI->_ff()._bPageBreaks = 0;
            pCFI->_ff()._pszFilters = NULL;
            pCFI->_ff()._fPositioned = FALSE;
            pCFI->_ff()._fAutoPositioned = FALSE;
            pCFI->_ff()._fScrollingParent = FALSE;
            pCFI->_ff()._fZParent = FALSE;
            pCFI->_ff()._fHasNoWrap = FALSE;
            pCFI->_ff()._fLayoutFlowChanged = FALSE;
            
            // We never ever inherit expandos or expressions
            pCFI->_ff()._iExpandos = -1;
            pCFI->_ff()._iCustomCursor = -1;
            pCFI->_ff()._fHasExpressions = FALSE;
            pCFI->_ff()._iPEI = -1;
            
            if(Tag() != ETAG_TR)
            {
                //
                // do not inherit background from the table.
                //
                pCFI->_ff()._ccvBackColor.Undefine();
                pCFI->_ff()._lImgCtxCookie = 0;

                // TRs inherit transformations from TBODY because TBODY can't have a layout.
                // Everyone else must not inherit transformations.
                pCFI->_ff()._lRotationAngle = 0;
                pCFI->_ff()._flZoomFactor = 0.0;
            }
            pCFI->UnprepareForDebug();
        }

        // 'text-overflow' is not inherited down
        if (pCFI->_pff->GetTextOverflow() != styleTextOverflowClip)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetTextOverflow(styleTextOverflowClip);
            pCFI->UnprepareForDebug();
        }
    }
    else
    {
        pCFI->_iffSrc = pts->_iffDefault;
        pCFI->_pffSrc = pCFI->_pff = pts->_pffDefault;

        Assert(pCFI->_pffSrc->_pszFilters == NULL);
    }

    if (!fComputeFFOnly)
    {
        //
        // Setup Char and Para formats
        //

        if (TestClassFlag(ELEMENTDESC_DONTINHERITSTYLE))
        {
            // The CharFormat inherits a couple of attributes from the parent, the rest from defaults.

            const CCharFormat * pcfParent;
            const CParaFormat * ppfParent;

#ifdef MULTI_FORMAT
            if (IS_FC(pFCParent))
            {
                pcfParent = &(*pts->_pCharFormatCache)[pNodeParent->GetICF(pFCParent)];
                ppfParent = &(*pts->_pParaFormatCache)[pNodeParent->GetIPF(pFCParent)];
            } 
            else
#endif //MULTI_FORMAT            
            {            
                pcfParent = &(*pts->_pCharFormatCache)[pNodeParent->_iCF];
                ppfParent = &(*pts->_pParaFormatCache)[pNodeParent->_iPF];
            }

            pCFI->_fDisplayNone      = pcfParent->_fDisplayNone ;
            pCFI->_fVisibilityHidden = pcfParent->_fVisibilityHidden ;

            {                
                if (!pMarkup->_fDefaultCharFormatCached)
                {
                    hr = THR(pMarkup->CacheDefaultCharFormat());
                    if (hr)
                        goto Error;
                }

                Assert(pMarkup->_fDefaultCharFormatCached);

                if (pMarkup->_fHasDefaultCharFormat)
                {
                    pCFI->_icfSrc = pMarkup->GetDefaultCharFormatIndex();
                    pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
                }
                else
                {
                    pCFI->_icfSrc = pDoc->_icfDefault;
                    pCFI->_pcfSrc = pCFI->_pcf = pDoc->_pcfDefault;
                }
            }

            pCFI->_fParentEditable = pcfParent->_fEditable;                       

            // Some properties are ALWAYS inherited, regardless of ELEMENTDESC_DONTINHERITSTYLE.
            // Do that here:
            if (    pCFI->_fDisplayNone
                ||  pCFI->_fVisibilityHidden
                ||  pcfParent->_fHasBgColor
                ||  pcfParent->_fHasBgImage
                ||  pcfParent->_fRelative
                ||  pcfParent->_fNoBreakInner
                ||  pcfParent->_fRTL
                ||  pCFI->_pcf->_bCursorIdx != pcfParent->_bCursorIdx
                ||  pCFI->_pcf->_wLayoutFlow != pcfParent->_wLayoutFlow
                ||  pcfParent->_fDisabled
                ||  pcfParent->_fWritingModeUsed
               )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fDisplayNone       = pCFI->_fDisplayNone;
                pCFI->_cf()._fVisibilityHidden  = pCFI->_fVisibilityHidden;
                pCFI->_cf()._fHasBgColor        = pcfParent->_fHasBgColor;
                pCFI->_cf()._fHasBgImage        = pcfParent->_fHasBgImage;
                pCFI->_cf()._fRelative          = pNodeParent->ShouldHaveLayout()
                                                    ? FALSE
                                                    : pcfParent->_fRelative;
                pCFI->_cf()._fNoBreak           = pcfParent->_fNoBreakInner;
                pCFI->_cf()._fRTL               = pcfParent->_fRTL;
                pCFI->_cf()._bCursorIdx         = pcfParent->_bCursorIdx;
                pCFI->_cf()._fDisabled          = pcfParent->_fDisabled;
                pCFI->_cf()._wLayoutFlow        = pcfParent->_wLayoutFlow;
                pCFI->_cf()._fWritingModeUsed   = pcfParent->_fWritingModeUsed;
                pCFI->UnprepareForDebug();
            }

#ifdef MULTI_FORMAT
            if (IS_FC(pFCParent) )
            {
                pCFI->_ipfSrc = pNodeParent->GetIPF(pFCParent);
            }
            else
#endif //MULTI_FORMAT            
            {
                pCFI->_ipfSrc = pNodeParent->_iPF;                
            }

            pCFI->_ppfSrc = pCFI->_ppf = ppfParent;

            if (    pCFI->_ppf->_fPreInner
                ||  pCFI->_ppf->_fInclEOLWhiteInner
                ||  pCFI->_ppf->_bBlockAlignInner != htmlBlockAlignNotSet)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fPreInner              = FALSE;
                // TODO: (KTam) shouldn't this be _fInclEOLWhiteInner? fix in IE6
                pCFI->_pf()._fInclEOLWhite          = FALSE;
                pCFI->_pf()._bBlockAlignInner       = htmlBlockAlignNotSet;
                pCFI->UnprepareForDebug();
            }

            // outer block alignment should still be inherited from
            // parent, but reset the inner block alignment
            pCFI->_bCtrlBlockAlign  = ppfParent->_bBlockAlignInner;
            pCFI->_bBlockAlign      = htmlBlockAlignNotSet;


            // outer direction should still be inherited from parent
            if(pCFI->_ppf->_fRTL != pCFI->_ppf->_fRTLInner)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTL = pCFI->_ppf->_fRTLInner;
                pCFI->UnprepareForDebug();
            }

            // layout-grid should still be inherited from parent
            if (pcfParent->HasLayoutGrid(TRUE))
            {
                pCFI->PrepareCharFormat();
                pCFI->PrepareParaFormat();

                pCFI->_cf()._uLayoutGridMode = pcfParent->_uLayoutGridModeInner;
                pCFI->_pf()._uLayoutGridType = ppfParent->_uLayoutGridTypeInner;
                pCFI->_pf()._cuvCharGridSize = ppfParent->_cuvCharGridSizeInner;
                pCFI->_pf()._cuvLineGridSize = ppfParent->_cuvLineGridSizeInner;

                // TODO (srinib) - if inner values need to be inherited too for elements like
                // input, select,textarea then copy the inner values from parent here
                // pCFI->_cf()._uLayoutGridModeInner = pcfParent->_uLayoutGridModeInner;
                // pCFI->_pf()._uLayoutGridTypeInner = ppfParent->_uLayoutGridTypeInner;
                // pCFI->_pf()._cuvCharGridSizeInner = ppfParent->_cuvCharGridSizeInner;
                // pCFI->_pf()._cuvLineGridSizeInner = ppfParent->_cuvLineGridSizeInner;

                pCFI->UnprepareForDebug();
            }
        }
        else
        {
            // Inherit the Char and Para formats from the parent node
#ifdef MULTI_FORMAT
            if (IS_FC(pFCParent) ) 
            {
                pCFI->_icfSrc = pNodeParent->GetICF(pFCParent);
                pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
                pCFI->_ipfSrc = pNodeParent->GetIPF(pFCParent);
                pCFI->_ppfSrc = pCFI->_ppf = &(*pts->_pParaFormatCache)[pCFI->_ipfSrc];
            }
            else 
#endif //MULTI_FORMAT            
            {
                pCFI->_icfSrc = pNodeParent->_iCF;
                pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
                pCFI->_ipfSrc = pNodeParent->_iPF;
                pCFI->_ppfSrc = pCFI->_ppf = &(*pts->_pParaFormatCache)[pCFI->_ipfSrc];
            }

            pCFI->_fDisplayNone      = pCFI->_pcf->_fDisplayNone ;
            pCFI->_fVisibilityHidden = pCFI->_pcf->_fVisibilityHidden ;

            // If the parent had layoutness, clear the inner formats
            // NOTE figure out how multilayouts should work with this (t-michda)
#ifdef MULTI_FORMAT            
            if (pNodeParent->ShouldHaveLayout(pFCParent))
#else
            if (pNodeParent->ShouldHaveLayout())
#endif            
            {
                if (pCFI->_pcf->_fHasDirtyInnerFormats)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf().ClearInnerFormats();
                    pCFI->UnprepareForDebug();
                }

                if (pCFI->_ppf->_fHasDirtyInnerFormats)
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf().ClearInnerFormats();
                    pCFI->UnprepareForDebug();
                }

                // copy parent's inner formats to current elements outer
                if (    pCFI->_ppf->_fPre != pCFI->_ppf->_fPreInner
                    ||  pCFI->_ppf->_fInclEOLWhite != pCFI->_ppf->_fInclEOLWhiteInner
                    ||  pCFI->_ppf->_bBlockAlign != pCFI->_ppf->_bBlockAlignInner)
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._fPre = pCFI->_pf()._fPreInner;
                    pCFI->_pf()._fInclEOLWhite = pCFI->_pf()._fInclEOLWhiteInner;
                    pCFI->_pf()._bBlockAlign = pCFI->_pf()._bBlockAlignInner;
                    pCFI->UnprepareForDebug();
                }

                if (pCFI->_pcf->_fNoBreak != pCFI->_pcf->_fNoBreakInner)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fNoBreak = pCFI->_pcf->_fNoBreakInner;
                    pCFI->UnprepareForDebug();
                }

                if (pCFI->_pcf->_uLayoutGridMode != pCFI->_pcf->_uLayoutGridModeInner)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._uLayoutGridMode = pCFI->_pcf->_uLayoutGridModeInner;
                    pCFI->UnprepareForDebug();
                }
                if (    pCFI->_ppf->_uLayoutGridType != pCFI->_ppf->_uLayoutGridTypeInner
                    ||  pCFI->_ppf->_cuvCharGridSize.GetRawValue() != pCFI->_ppf->_cuvCharGridSizeInner.GetRawValue()
                    ||  pCFI->_ppf->_cuvLineGridSize.GetRawValue() != pCFI->_ppf->_cuvLineGridSizeInner.GetRawValue())
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._uLayoutGridType = pCFI->_ppf->_uLayoutGridTypeInner;
                    pCFI->_pf()._cuvCharGridSize = pCFI->_ppf->_cuvCharGridSizeInner;
                    pCFI->_pf()._cuvLineGridSize = pCFI->_ppf->_cuvLineGridSizeInner;
                    pCFI->UnprepareForDebug();
                }
            }

            // outer block alignment should still be inherited from
            // parent
            pCFI->_bCtrlBlockAlign  = pCFI->_ppf->_bBlockAlign;
            pCFI->_bBlockAlign      = pCFI->_ppf->_bBlockAlign;

            // outer direction should still be inherited from parent
            if(pCFI->_ppf->_fRTL != pCFI->_ppf->_fRTLInner)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTL = pCFI->_ppf->_fRTLInner;
                pCFI->UnprepareForDebug();
            }
        }

        pCFI->_bControlAlign = htmlControlAlignNotSet;
    }
    else
    {
        if (pMarkup->_fHasDefaultCharFormat)
        {
            pCFI->_icfSrc = pMarkup->GetDefaultCharFormatIndex();
            pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
        }
        else
        {
            pCFI->_icfSrc = pDoc->_icfDefault;
            pCFI->_pcfSrc = pCFI->_pcf = pDoc->_pcfDefault;
        }

        pCFI->_ipfSrc = pts->_ipfDefault;
        pCFI->_ppfSrc = pCFI->_ppf = pts->_ppfDefault;
    }

    Assert(pCFI->_fEditableExplicitlySet == FALSE);

    fEditable = fInheritEditableFalse ? FALSE : pCFI->_pcf->_fEditable;    

    // see if behaviour set default contentEditable    
    pDefaults = GetDefaults();    
    if (pDefaults || fInheritEditableFalse)
    {
        if (pDefaults)
        {
            htmlEditable enumEditable = pDefaults->GetAAcontentEditable();
            if (htmlEditableInherit != enumEditable)
            {
                fEditable = (htmlEditableTrue == enumEditable);            
            }
            pCFI->NoStealing();
        }         
    
        // change only if different.
        if (pCFI->_pcf->_fEditable != fEditable)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fEditable = fEditable;
            pCFI->UnprepareForDebug();
        }
        _fEditable = fEditable;
    }
                
    Assert(pElemParent);
    pCFI->_fParentFrozen = pElemParent->IsFrozen() 
            // Can not do this here. It is incorrectly accessing FirstBranch..
            // || pElemParent->IsParentFrozen(); 
            || pNodeParent->GetCharFormat()->_fParentFrozen;

    // change only if different
    if (pCFI->_pcf->_fParentFrozen != pCFI->_fParentFrozen)
    {        
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fParentFrozen = pCFI->_fParentFrozen;
        pCFI->UnprepareForDebug();     
    }

    hr = THR(ApplyDefaultFormat(pCFI));
    if (hr)
        goto Error;

    if (IsGenericListItem(pCFI->_pNodeContext, pCFI->_pff))
    {
        ApplyListItemFormats(pCFI);
    }

    // Fix 96067
    // The root is hidden only if it inherited it from the master element, implying we
    // are inside a hidden frame/iframe/viewlink. Hence, we want the root's hiddenness
    // to take precedence.     
    if (!IsRoot())
    {
        CRootElement *pRootElem = pMarkup->Root();
        if (pRootElem)
        {
            fRootVisibilityHidden = pRootElem->IsVisibilityHidden();
            if (    fRootVisibilityHidden               
                &&  fRootVisibilityHidden != !!pCFI->_fVisibilityHidden)
            {
                pCFI->PrepareCharFormat();
                pCFI->_fVisibilityHidden = TRUE;
                pCFI->UnprepareForDebug();                   
            }
        }
    }


    //
    // TODO:   ApplyFormatInfoProperty overwrite pCFI->_fVisibilityHidden without looking at if
    //         the current element has the parent format
    //
    if (    !fRootVisibilityHidden
        &&  pCFI->_pff->_bVisibility == styleVisibilityInherit
        &&  TestClassFlag(ELEMENTDESC_DONTINHERITSTYLE))
    {
        pCFI->PrepareCharFormat();
        pCFI->_fVisibilityHidden = pCFI->_cf()._fVisibilityHidden;
        pCFI->UnprepareForDebug();     
    }   

    hr = THR(ApplyInnerOuterFormats(pCFI FCCOMMA FCPARAM) );
    if (hr)
        goto Error;

    if (eExtraValues == ComputeFormatsType_Normal || 
        eExtraValues == ComputeFormatsType_ForceDefaultValue)
    {
        if (fResetPosition)
        {
            if (pCFI->_pff->_bPositionType != stylePositionstatic)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bPositionType = stylePositionstatic;
                pCFI->UnprepareForDebug();
            }
        }

        if (   _fHasFilterSitePtr 
            || pCFI->_fHasFilters)
        {

#if DBG == 1

            // If only used in debug.  If they have set debug not to print
            // filters don't computer the filter format if we're printing.

            if (!IsTagEnabled(tagNoPrintFilters) || !pMarkup->IsPrintMedia())
            {
                ComputeFilterFormat(pCFI);
            }

#else  // DBG != 1

            ComputeFilterFormat(pCFI);

#endif // DBG != 1

        }
        
        hr = THR(pNodeTarget->CacheNewFormats(pCFI FCCOMMA FCPARAM ));
        pCFI->_cstrFilters.Free();  // Arrggh!!! TODO (michaelw)  This should really happen 
                                                                        // somewhere else (when you know where, put it there)
                                                                        // Fix CTableCell::ComputeFormats also
        if (hr)
            goto Error;

        // Cache whether an element is a block element or not for fast retrieval.
#ifdef MULTI_FORMAT        
        if (! (FCPARAM) )
        {
            pNodeTarget->_fBlockNess = pCFI->_pff->_fBlockNess;
            pNodeTarget->_fShouldHaveLayout = pCFI->_pff->_fShouldHaveLayout;           
        }
#else
        pNodeTarget->_fBlockNess = pCFI->_pff->_fBlockNess;
        pNodeTarget->_fShouldHaveLayout = pCFI->_pff->_fShouldHaveLayout;
#endif        

        DoLayoutRelatedWork(pCFI->_pff->_fShouldHaveLayout);

        // Update expressions in the recalc engine
        //
        // If we had expressions or have expressions then we need to tell the recalc engine
        // 
        if (pCFI->_pff->_fHasExpressions)
        {
            Doc()->AddExpressionTask(this);
            pCFI->NoStealing();
        }
    }

Cleanup:

    // Do not leak memory due to pre caching of rules which could probably apply.
    Assert(!pCFI->_ProbRules.IsItValid(NULL));

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);

Error:
    pCFI->Cleanup();
    goto Cleanup;
}

void
CElement::DoLayoutRelatedWork(BOOL fShouldHaveLayout)
{
    if ( HasLayoutPtr() || HasLayoutAry() )
    {
        // Irrespective of the newly computed value of _fShouldHaveLayout, we may currently really have a layout.
        // If this is the case, mark its _fEditableDirtyFlag.

        // PERF: MULTI_LAYOUT case is going to be slower.  work on this?
        LayoutSetEditableDirty( TRUE );
    
        // If the current element has a layout attached to but does not
        // need one, post a layout request to lazily destroy it.
        // TODO (KTam): MULTI_LAYOUT make sure we do lazy deletion in multilayout world
        if (!fShouldHaveLayout)
        {
            if ( HasLayoutPtr() )
            {
                TraceTagEx((tagLayoutTasks, TAG_NONAME,
                            "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CElement::ComputeFormats() [lazy layout del]",
                            GetLayoutPtr(),
                            GetLayoutPtr()->_pElementOwner,
                            GetLayoutPtr()->_pElementOwner->TagName(),
                            GetLayoutPtr()->_pElementOwner->_nSerialNumber));
                GetLayoutPtr()->PostLayoutRequest(LAYOUT_MEASURE|LAYOUT_POSITION);
            }           
        }
    }
}

//---------------------------------------------------------------------------
//
// Member:              CElement::ComputeFilterFormat
//
// Description: A helper function to do whatever work is needed
//                              for filters.  This can be scheduling a filter
//                              task (when the filters will be actually instantiated)
//                              or filtering the visibility
//
//---------------------------------------------------------------------------
void
CElement::ComputeFilterFormat(CFormatInfo *pCFI)
{
    //
    // Filters can be tricky.  We used to instantiate them
    // right here while in ComputeFormats.  As ComputeFormats
    // can now be deferred to paint time, this is no longer practical
    //
    // Filters can also mess with visibility.  Fortunately, they never
    // do so when they are instantiated.  Typically they defer changes
    // the visibility property and then make them happen later on.
    //
    // In the (rare) event that the filter chain's opinion of visibility
    // changes and the filter string itself is changed before ComputeFormats
    // is called, we really don't care about the old filter chain's opinion
    // and will start everything afresh.  For this reason we are either
    // filtering the visibility bit (when the filter string is unchanged)
    // or scheduling a filter task to create or destroy the filter chain.
    // We never do both.
    //

    // Filters don't print, even if we bypass them for painting
    // because due to their abilities to manipulate the object model
    // they are able to move objects to unprintable positions
    // so in that case bail out for printing
    // We are aware that this may cause scripterrors against the filter
    // which we would ignore anyway in printing (Frankman)
    //
    // Although Frank's concerns about OM changes during print are
    // no longer a real issue, now is not the time to change this (michaelw)
    //
    // TODO: Look at issues above and remove this whole code block.  Commenting
    //       out assert to support filter printing.
    //
    // Assert(!GetMarkupPtr()->IsPrintMedia() && (_fHasFilterSitePtr || pCFI->_fHasFilters));

    LPOLESTR pszFilterNew = pCFI->_pff->_pszFilters;
    CFilterBehaviorSite *pFS = GetFilterSitePtr();

    LPCTSTR pszFilterOld = pFS ? pFS->GetFullText() : NULL;

    pCFI->NoStealing();
    
    if ((!pszFilterOld && !pszFilterNew)
    ||  (pszFilterOld && pszFilterNew && !StrCmpC(pszFilterOld, pszFilterNew)))
    {
        // Nothing has changed, just update the visibility bit as appropriate
                // It is possible for us to get here having successfully called AddFilterTask
                // and still have no filters (the filter couldn't be found or failed to hookup)

        CPeerHolder *pPeerHolder = GetFilterPeerHolder();
        if (pPeerHolder)
        {
            BOOL fHiddenNew;
            int iCF = pCFI->_pNodeContext->GetICF(FCPARAM);
            if (iCF != -1)
            {   // computing fancy format only:

                // get visibility from previously
                // calculated char format
                fHiddenNew = GetCharFormatEx(iCF)->_fVisibilityHidden;
            }
            else
            {   // computing all formats

                BOOL fHiddenOld = pCFI->_pcf->_fVisibilityHidden;
                fHiddenNew = !pPeerHolder->SetFilteredElementVisibility(!fHiddenOld);

                if (fHiddenOld != fHiddenNew)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fVisibilityHidden = fHiddenNew ;
                    pCFI->UnprepareForDebug();
                }
            }

            if (pPeerHolder->GetFilteredElementVisibilityForced())
            {
                unsigned sv = fHiddenNew ? styleVisibilityHidden : styleVisibilityVisible;
                if (pCFI->_pff->_bVisibility != sv)
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bVisibility = sv;
                    pCFI->UnprepareForDebug();
                }
            }
        }
    }
    else
    {
        // The filter string has changed, schedule a task to destroy/create filters

        Verify(Doc()->AddFilterTask(this));
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::ShouldHaveLayout, public
//
//  Synopsis:   Determines, based on attributes, whether this element needs
//              layout and if so what type.
//
//  Arguments:  [pCFI]  -- Pointer to FormatInfo with applied properties
//              [pNode] -- Context Node for this element
//              [plt]   -- Returns the type of layout we need.
//
//  Returns:    TRUE if this element needs a layout, FALSE if not.
//
//----------------------------------------------------------------------------

BOOL
CElement::ElementShouldHaveLayout(CFormatInfo *pCFI)
{
    Assert(!pCFI->_fEditableExplicitlySet || pCFI->_pcf->_fEditable == _fEditable);

    if (    (   !TestClassFlag(ELEMENTDESC_NOLAYOUT)
            && (   _fLayoutAlwaysValid
                ||  ElementNeedsFlowLayout(pCFI)
                ||  HasSlavePtr()
                ||  _fEditable 
                ||  pCFI->_fEditableExplicitlySet
                ||  IsFrozen() )))
    {
            return TRUE;
    }
    
    return FALSE;
}

BOOL
CElement::ElementNeedsFlowLayout(CFormatInfo *pCFI)
{
    const CFancyFormat *pff = pCFI->_pff;
    BOOL fNeedsFL =      pff->_fRectangular
                    ||   pff->_bPositionType == stylePositionabsolute
                    ||   pff->_bStyleFloat == styleStyleFloatLeft
                    ||   pff->_bStyleFloat == styleStyleFloatRight
                    ||   pff->_flZoomFactor
                    ||   pff->_lRotationAngle
                    ||   pff->_fLayoutFlowChanged;

    if (   !fNeedsFL
        && (   !pff->GetWidth().IsNullOrEnum()
            || !pff->GetHeight().IsNullOrEnum()
           )
       )
    {
        // In strict mode, only block elements can have layout for height and width
        // property. Inline elements do not honor height and width properties.
        fNeedsFL =    !GetMarkup()->IsStrictCSS1Document()
                   ||  DetermineBlockness(pCFI->_pff);
    }
    return fNeedsFL;
}

static BOOL ElementHIV(ELEMENT_TAG eTag)
{
    BOOL fRet;

#define X(Y) case ETAG_##Y:
    switch(eTag)
    {
        X(APPLET)   X(AREA)     X(BASE)     X(BASEFONT) X(BGSOUND)  X(BODY)     X(BUTTON)
        X(CAPTION)  X(COL)      X(COLGROUP) X(FRAME)    X(FRAMESET) X(HEAD)     X(HTML) 
        X(IFRAME)   X(IMG)      X(INPUT)    X(ISINDEX)  X(LINK)     X(MAP)      X(META) 
        X(NOFRAMES) X(NOSCRIPT) X(OBJECT)   X(OPTION)   X(PARAM)    X(SCRIPT)   X(SELECT) 
        X(STYLE)    X(TABLE)    X(TBODY)    X(TD)       X(TEXTAREA) X(TFOOT)    X(TH) 
        X(THEAD)    X(TR)       X(GENERIC)  X(OPTGROUP)
            fRet = TRUE;
            break;
        default:
            fRet = FALSE;
            break;
    }
#undef X
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DetermineBlockness, public
//
//  Synopsis:   Determines if this element is a block element based on
//              inherent characteristics of the tag or current properties.
//
//  Arguments:  [pFF] -- Pointer to current FancyFormat with applied properties
//
//  Returns:    TRUE if this element has blockness.
//
//----------------------------------------------------------------------------
BOOL
CElement::DetermineBlockness(const CFancyFormat *pFF)
{
    BOOL            fIsBlock    = HasFlag(TAGDESC_BLOCKELEMENT); 
    styleDisplay    disp        = (styleDisplay)(pFF->_bDisplay);

    /// Ignore block flag for BODY inside viewLink
    if (fIsBlock && Tag() == ETAG_BODY && IsInViewLinkBehavior( FALSE ))
    {
        fIsBlock = FALSE;
    }
    //
    // TODO -- Are there any elements for which we don't want to override
    // blockness? (lylec)
    //
    if (disp == styleDisplayBlock || disp == styleDisplayListItem)
    {
        fIsBlock = TRUE;
    }
    else if (disp == styleDisplayInline)
    {
        fIsBlock = FALSE;
    }

    return fIsBlock;
}

void
CElement::ApplyListFormats(CFormatInfo * pCFI, int defPoints FCCOMMA FORMAT_CONTEXT FCPARAM FCDEFAULT)
{
    //
    // Apply default before/after space.
    // NOTE: Before/after space are outside our box (== margins), 
    //       so they are relative to the parent's text flow.
    //
    BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

    pCFI->PrepareFancyFormat();
    ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff(), defPoints);
    pCFI->UnprepareForDebug();
}

void
CElement::ApplyListItemFormats(CFormatInfo * pCFI FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    pCFI->PrepareParaFormat();

    styleListStyleType listType = pCFI->_ppf->GetListStyleType();

    // If list type is not explicitly set, retrieve it from the
    // nearest ancestor list element.
    if (listType == styleListStyleTypeNotSet)
    {
        CTreeNode * pNodeList = NULL;

        // Find the list element
        if (GetMarkup())
        {
            pNodeList = GetMarkup()->SearchBranchForCriteria(
                pCFI->_pNodeContext->Parent(), IsBlockListElement, NULL);
        }

        if (pNodeList)
        {
            listType = pCFI->_ppf->_cListing.GetStyle();
        }
    }

    // Set listing properties for the list item
    pCFI->_pf()._cListing.SetStyle(listType);
    pCFI->_pf()._cListing.SetStyleValid();
    pCFI->_pf()._cListing.SetType(NumberOrBulletFromStyle(listType));

    if (!pCFI->_ppf->_lNumberingStart)
    {
        pCFI->_pf()._lNumberingStart = 1;
    }

    // For lists inside of blockquotes, start the bullets AFTER
    // indenting for the blockquote.
    pCFI->_pf()._cuvNonBulletIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);

    // set up for potential EMs, Ens, and ES Conversions
    pCFI->_pf()._lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(Doc());
    if (pCFI->_pf()._lFontHeightTwips <= 0)
        pCFI->_pf()._lFontHeightTwips = 1;

    pCFI->UnprepareForDebug();

    // Apply the pre-space to the first item, after space to last item
    ApplyListFormats(pCFI, 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::ApplyInnerOuterFormats, public
//
//  Synopsis:   Takes the current FormatInfo and creates the correct
//              inner and (if appropriate) outer formats.
//
//  Arguments:  [pCFI]     -- FormatInfo with applied properties
//              [pCFOuter] -- Place to store Outer format properties
//              [pPFOuter] -- Place to store Outer format properties
//
//  Returns:    HRESULT
//
//  Notes:      Inner/Outer sensitive formats are put in the _fXXXXInner
//              for inner and outer are held in _fXXXXXX
//
//----------------------------------------------------------------------------

HRESULT
CElement::ApplyInnerOuterFormats(CFormatInfo * pCFI FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    HRESULT     hr = S_OK;
    CDoc * pDoc          = Doc();
    CMarkup *pMarkup     = GetMarkup(); 
    Assert(pDoc && pMarkup);

    BOOL fHTMLLayout     = pMarkup->IsHtmlLayout();

    BOOL fShouldHaveLayout    = 
        ( Tag() == ETAG_HTML ? fHTMLLayout : ElementShouldHaveLayout(pCFI) );
    
    BOOL fNeedsOuter     =      fShouldHaveLayout
                            &&  (   !_fLayoutAlwaysValid
                                || (    TestClassFlag(ELEMENTDESC_TEXTSITE)
                                    &&  !TestClassFlag(ELEMENTDESC_TABLECELL) ));
    BOOL fHasLeftIndent  = FALSE;
    BOOL fHasRightIndent = FALSE;
    BOOL fIsBlockElement = DetermineBlockness(pCFI->_pff);
    LONG lFontHeight     = 1;
    BOOL fComputeFFOnly;   
    BOOL fMainBody       =      (fHTMLLayout ? (Tag() == ETAG_HTML) : (Tag() == ETAG_BODY))
                            &&  (!IsInViewLinkBehavior( FALSE ));
    BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();
    BOOL fWritingMode    = pCFI->_pcf->_fWritingModeUsed;
    
    fComputeFFOnly = pCFI->_pNodeContext->GetICF(FCPARAM) != -1;
   
    Assert(pCFI->_pNodeContext->Element() == this);

    if (    !!pCFI->_pff->_fShouldHaveLayout != !!fShouldHaveLayout
        ||  !!pCFI->_pff->_fBlockNess != !!fIsBlockElement)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fShouldHaveLayout = fShouldHaveLayout;
        pCFI->_ff()._fBlockNess = fIsBlockElement;
        pCFI->UnprepareForDebug();
    }

    if (   !fIsBlockElement
        && HasFlag(TAGDESC_LIST)
       )
    {
        //
        // If the current list is not a block element, and it is not parented by
        // any block-list elements, then we want the LI's inside to be treated
        // like naked LI's. To do this we have to set cuvOffsetPoints to 0.
        //
        CTreeNode *pNodeList = pMarkup->SearchBranchForCriteria(
            pCFI->_pNodeContext->Parent(), IsBlockListElement, NULL );
        if (!pNodeList)
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvOffsetPoints.SetValue( 0, CUnitValue::UNIT_POINT );
            pCFI->_pf()._cListing.SetNotInList();
            pCFI->_pf()._cListing.SetStyle(styleListStyleTypeDisc);
            pCFI->UnprepareForDebug();
        }
        else
        {
            styleListStyleType listType = pNodeList->GetParaFormat()->GetListStyleType();
            WORD               wLevel   = (WORD)pNodeList->GetParaFormat()->_cListing.GetLevel();

            pCFI->PrepareParaFormat();
            pCFI->_pf()._cListing.SetStyle(DYNCAST(CListElement, pNodeList->Element())->
                                           FilterHtmlListType(listType, wLevel));
            pCFI->UnprepareForDebug();
        }
    }
    
    if (!fComputeFFOnly)
    {
        if (pCFI->_fDisplayNone && !pCFI->_pcf->_fDisplayNone)
        {
            BOOL fIgnoreVisibilityInDesign = (IsDesignMode() || pCFI->_pNodeContext->IsParentEditable()) && 
                                              ! pMarkup->IsRespectVisibilityInDesign() ;

            if (!fIgnoreVisibilityInDesign)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fDisplayNone = TRUE ;
                pCFI->UnprepareForDebug();
            }
        }

        if (pCFI->_fVisibilityHidden != unsigned(pCFI->_pcf->_fVisibilityHidden))
        {
            BOOL fIgnoreVisibilityInDesign = (IsDesignMode() || pCFI->_pNodeContext->IsParentEditable()) && 
                                              !pMarkup->IsRespectVisibilityInDesign() ;

            if (!fIgnoreVisibilityInDesign)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fVisibilityHidden = pCFI->_fVisibilityHidden ; 
                pCFI->UnprepareForDebug();
            }
        }

        if (fNeedsOuter)
        {
            if (pCFI->_fPre != pCFI->_ppf->_fPreInner)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fPreInner = pCFI->_fPre;
                pCFI->UnprepareForDebug();
            }

            if (!!pCFI->_ppf->_fInclEOLWhiteInner != (pCFI->_fInclEOLWhite || TestClassFlag(ELEMENTDESC_SHOWTWS)))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fInclEOLWhiteInner = !pCFI->_pf()._fInclEOLWhiteInner;
                pCFI->UnprepareForDebug();
            }

            // NO WRAP
            if (pCFI->_fNoBreak)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fNoBreakInner = TRUE; //pCFI->_fNoBreak;
                pCFI->UnprepareForDebug();
            }

        }
        else
        {
            if (pCFI->_fPre && (!pCFI->_ppf->_fPre || !pCFI->_ppf->_fPreInner))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fPre = pCFI->_pf()._fPreInner = TRUE;
                pCFI->UnprepareForDebug();
            }

            if (pCFI->_fInclEOLWhite && (!pCFI->_ppf->_fInclEOLWhite || !pCFI->_ppf->_fInclEOLWhiteInner))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fInclEOLWhite = pCFI->_pf()._fInclEOLWhiteInner = TRUE;
                pCFI->UnprepareForDebug();
            }

            if (pCFI->_fNoBreak && (!pCFI->_pcf->_fNoBreak || !pCFI->_pcf->_fNoBreakInner))
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fNoBreak = pCFI->_cf()._fNoBreakInner = TRUE;
                pCFI->UnprepareForDebug();
            }
        }

        if (pCFI->_fRelative)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fRelative = TRUE;
            pCFI->UnprepareForDebug();
        }
        
        if (!fShouldHaveLayout)
        {
            // PADDING / BORDERS
            //
            // For padding, set _fPadBord flag if CFI _fPadBord is set. Values have
            // already been copied. It always goes on inner.
            //
            if (pCFI->_fPadBord && !pCFI->_pcf->_fPadBord)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fPadBord = TRUE;
                pCFI->UnprepareForDebug();
            }

            // BACKGROUND
            //
            // Sites draw their own background, so we don't have to inherit their
            // background info. Always goes on inner.
            //
            if (pCFI->_fHasBgColor && !pCFI->_pcf->_fHasBgColor)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fHasBgColor = TRUE;
                pCFI->UnprepareForDebug();
            }

            if (pCFI->_fHasBgImage)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fHasBgImage = TRUE;
                pCFI->UnprepareForDebug();
            }

        }

        // INLINE BACKGROUNDS
        if (pCFI->_fMayHaveInlineBg)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fHasInlineBg = TRUE;
            pCFI->UnprepareForDebug();
        }

        // TEXT TRANSFORMS
        BOOL fHasTextTransform =    pCFI->_pcf->_fSmallCaps 
                                 || (   pCFI->_pcf->_bTextTransform != styleTextTransformNotSet
                                     && pCFI->_pcf->_bTextTransform != styleTextTransformNone);
        if (fHasTextTransform != pCFI->_pcf->_fHasTextTransform)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fHasTextTransform = fHasTextTransform;
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Note: (srinib) Currently table cell's do not support margins,
    // based on the implementation, this may change.
    //
    if (pCFI->_pff->_fHasMargins && Tag() != ETAG_BODY)
    {
        if (fIsBlockElement)
        {
            pCFI->PrepareFancyFormat();
            
            // MARGIN-TOP - on block elements margin top is treated as before space
            const CUnitValue & cuvMarginTop = pCFI->_pff->GetLogicalMargin(SIDE_TOP, fParentVertical, fWritingMode);
            if (!cuvMarginTop.IsNullOrEnum())
            {
                pCFI->_ff()._cuvSpaceBefore = cuvMarginTop;
            }

            // MARGIN-BOTTOM - on block elements margin top is treated as after space
            const CUnitValue & cuvMarginBottom = pCFI->_pff->GetLogicalMargin(SIDE_BOTTOM, fParentVertical, fWritingMode);
            if (!cuvMarginBottom.IsNullOrEnum())
            {
                pCFI->_ff()._cuvSpaceAfter = cuvMarginBottom;
            }

            // MARGIN-LEFT - on block elements margin left is treated as left indent
            if (!pCFI->_pff->GetLogicalMargin(SIDE_LEFT, fParentVertical, fWritingMode).IsNullOrEnum())
            {
                // We handle the various data types below when we accumulate values.
                fHasLeftIndent = TRUE;
            }

            // MARGIN-RIGHT - on block elements margin right is treated as right indent
            if (!pCFI->_pff->GetLogicalMargin(SIDE_RIGHT, fParentVertical, fWritingMode).IsNullOrEnum())
            {
                // We handle the various data types below when we accumulate values.
                fHasRightIndent = TRUE;
            }

            pCFI->UnprepareForDebug();
        }
        else
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fHasInlineMargins = TRUE;
            pCFI->UnprepareForDebug();
        }
    }

    //
    // FLOAT
    //
    // TODO -- This code needs to move back to ApplyFormatInfoProperty to ensure
    // that the alignment follows the correct ordering. (lylec)
    //

    if (fShouldHaveLayout && pCFI->_pff->_bStyleFloat != styleStyleFloatNotSet)
    {
        htmlControlAlign hca   = htmlControlAlignNotSet;
        BOOL             fDoIt = TRUE;

        switch (pCFI->_pff->_bStyleFloat)
        {
        case styleStyleFloatLeft:
            hca = htmlControlAlignLeft;
            if (fIsBlockElement)
            {
                pCFI->_bCtrlBlockAlign = htmlBlockAlignLeft;
            }
            break;

        case styleStyleFloatRight:
            hca = htmlControlAlignRight;
            if (fIsBlockElement)
            {
                pCFI->_bCtrlBlockAlign = htmlBlockAlignRight;
            }
            break;

        case styleStyleFloatNone:
            hca = htmlControlAlignNotSet;
            break;

        default:
            fDoIt = FALSE;
        }

        if (fDoIt)
        {
            ApplySiteAlignment(pCFI, hca, this);
            pCFI->_fCtrlAlignLast = TRUE;

            // Autoclear works for float from CSS.  Navigator doesn't
            // autoclear for HTML floating.  Another annoying Nav compat hack.

            if (!pCFI->_pff->_fCtrlAlignFromCSS)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._fCtrlAlignFromCSS = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
    }

    //
    // ALIGNMENT
    //
    // Alignment is tricky because DISPID_CONTROLALIGN should only set the
    // control align if it has layout, but sets the block alignment if it's
    // not.  Also, if the element has TAGDESC_OWNLINE then DISPID_CONTROLALIGN
    // sets _both_ the control alignment and block alignment.  However, you
    // can still have inline sites (that are not block elements) that have the
    // OWNLINE flag set.  Also, if both CONTROLALIGN and BLOCKALIGN are set,
    // we must remember the order they were applied.  The last kink is that
    // HR's break the pattern because they're not block elements but
    // DISPID_BLOCKALIGN does set the block align for them.
    //

    if (fShouldHaveLayout)
    {
        if (pCFI->_pff->_bControlAlign != pCFI->_bControlAlign)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bControlAlign = pCFI->_bControlAlign;
            pCFI->UnprepareForDebug();
        }

        // If a site is positioned explicitly (absolute) it
        // overrides control alignment. We do that by simply turning off
        // control alignment.
        //
        if (    pCFI->_pff->_bControlAlign != htmlControlAlignNotSet
            &&  (   pCFI->_pff->_bControlAlign == htmlControlAlignRight
                ||  pCFI->_pff->_bControlAlign == htmlControlAlignLeft))
        {
            pCFI->PrepareFancyFormat();

            if (    pCFI->_pff->_bPositionType == stylePositionabsolute
                &&  (   fHTMLLayout
                     || Tag() != ETAG_BODY ))
            {
                pCFI->_ff()._bControlAlign = htmlControlAlignNotSet;
                pCFI->_ff()._fAlignedLayout = FALSE;
            }
            else
            {
                pCFI->_ff()._fAlignedLayout = Tag() != ETAG_HR && Tag() != ETAG_LEGEND;
            }

            pCFI->UnprepareForDebug();

        }
    }

    if (!fComputeFFOnly)
    {   
        BOOL fOwnLine = fShouldHaveLayout && HasFlag(TAGDESC_OWNLINE);

        if (    fShouldHaveLayout
            && (    fNeedsOuter
                ||  IsRunOwner() ))
        {
            if (    pCFI->_ppf->_bBlockAlign != pCFI->_bCtrlBlockAlign
                ||  pCFI->_ppf->_bBlockAlignInner != pCFI->_bBlockAlign)
            {
                pCFI->PrepareParaFormat();
                if (!pCFI->_pff->_fAlignedLayout)
                    pCFI->_pf()._bBlockAlign = pCFI->_bCtrlBlockAlign;
                pCFI->_pf()._bBlockAlignInner = pCFI->_bBlockAlign;
                pCFI->UnprepareForDebug();
            }
        }
        else if (fIsBlockElement || fOwnLine)
        {
            BYTE bAlign = pCFI->_bBlockAlign;

            if ((  (   !fIsBlockElement
                    && Tag() != ETAG_HR)
                 || pCFI->_fCtrlAlignLast)
                && (fOwnLine || !fShouldHaveLayout))
            {
                bAlign = pCFI->_bCtrlBlockAlign;
            }

            if (    pCFI->_ppf->_bBlockAlign != bAlign
                ||  pCFI->_ppf->_bBlockAlignInner != bAlign)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bBlockAlign = bAlign;
                pCFI->_pf()._bBlockAlignInner = bAlign;
                pCFI->UnprepareForDebug();
            }
        }

        //
        // DIRECTION
        //
        if (    fShouldHaveLayout
            && (    fNeedsOuter
                ||  IsRunOwner()
                ||  (   Tag() == ETAG_HTML
                    &&  fHTMLLayout     )))
        {
            if(     (fIsBlockElement && pCFI->_ppf->_fRTL != pCFI->_pcf->_fRTL)
                ||  (pCFI->_ppf->_fRTLInner != pCFI->_pcf->_fRTL))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTLInner = pCFI->_pcf->_fRTL;
                // paulnel - we only set the inner for these guys because the
                //           positioning of the layout is determined by the
                //           parent and not by the outter _fRTL
                pCFI->UnprepareForDebug();
            }
        }
        else if (fIsBlockElement || fOwnLine)
        {
            if (pCFI->_ppf->_fRTLInner != pCFI->_pcf->_fRTL ||
                pCFI->_ppf->_fRTL != pCFI->_pcf->_fRTL)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTLInner = pCFI->_pcf->_fRTL;
                pCFI->_pf()._fRTL = pCFI->_pcf->_fRTL;
                pCFI->UnprepareForDebug();
            }
        }
        if (pCFI->_fBidiEmbed != pCFI->_pcf->_fBidiEmbed ||
            pCFI->_fBidiOverride != pCFI->_pcf->_fBidiOverride)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fBidiEmbed = pCFI->_fBidiEmbed;
            pCFI->_cf()._fBidiOverride = pCFI->_fBidiOverride;
            pCFI->UnprepareForDebug();
        }

        //
        // TEXTINDENT
        //

        // We used to apply text-indent only to block elems; now we apply regardless because text-indent
        // is always inherited, meaning inline elems can end up having text-indent in their PF 
        // (via format inheritance and not Apply).  If we don't allow Apply() to set it on inlines,
        // there's no way to change what's inherited.  This provides a workaround for bug #67276.

        if (!pCFI->_cuvTextIndent.IsNull())
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvTextIndent = pCFI->_cuvTextIndent;
            pCFI->UnprepareForDebug();
        }

        if (fIsBlockElement)
        {

            //
            // TEXTJUSTIFY
            //

            if (pCFI->_uTextJustify)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._uTextJustify = pCFI->_uTextJustify;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTALIGNLAST
            //

            if (pCFI->_uTextAlignLast)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._uTextAlignLast = pCFI->_uTextAlignLast;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTJUSTIFYTRIM
            //

            if (pCFI->_uTextJustifyTrim)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._uTextJustifyTrim = pCFI->_uTextJustifyTrim;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTKASHIDA
            //

            if (!pCFI->_cuvTextKashida.IsNull())
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._cuvTextKashida = pCFI->_cuvTextKashida;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTKASHIDASPACE
            //

            if (!pCFI->_cuvTextKashidaSpace.IsNull())
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._cuvTextKashidaSpace = pCFI->_cuvTextKashidaSpace;
                pCFI->UnprepareForDebug();
            }
        }

        //
        // LAYOUT-GRID
        //

        if (pCFI->_pcf->HasLayoutGrid(TRUE))
        {
            if (!fIsBlockElement)
            {
                //
                // ApplyDefaultFormat() can set 'layout-grid-type', 'layout-grid-line' and 
                // 'layout-grid-char' to non-block elements. In this case we need to keep old
                // values (stored in outer format).
                //
                if (    pCFI->_ppf != pCFI->_ppfSrc
                    &&  (   pCFI->_ppf->_cuvCharGridSizeInner.GetRawValue() != pCFI->_ppf->_cuvCharGridSize.GetRawValue()
                        ||  pCFI->_ppf->_cuvLineGridSizeInner.GetRawValue() != pCFI->_ppf->_cuvLineGridSize.GetRawValue()
                        ||  pCFI->_ppf->_uLayoutGridTypeInner != pCFI->_ppf->_uLayoutGridType))
                {
                    pCFI->PrepareParaFormat();

                    pCFI->_pf()._cuvCharGridSizeInner = pCFI->_ppf->_cuvCharGridSize;
                    pCFI->_pf()._cuvLineGridSizeInner = pCFI->_ppf->_cuvLineGridSize;
                    pCFI->_pf()._uLayoutGridTypeInner = pCFI->_ppf->_uLayoutGridType;

                    // In case of change of layout-grid-char or layout-grid-line, 
                    // layout-grid-mode must be updated if its value is not set.
                    if (    pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNotSet
                        ||  (   pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeNone
                            &&  pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeBoth))
                    {
                        pCFI->PrepareCharFormat();

                        // Now _uLayoutGridModeInner can be one of { 000, 101, 110, 111 }
                        // it means that layout-grid-mode is not set

                        if (pCFI->_ppf->_cuvCharGridSizeInner.IsNull())
                        {   // clear deduced char mode
                            pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeLine);
                            if (pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNone)
                                pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
                        }
                        else
                        {   // set deduced char mode
                            pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeChar);
                        }

                        if (pCFI->_ppf->_cuvLineGridSizeInner.IsNull())
                        {   // clear deduced line mode
                            pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeChar);
                            if (pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNone)
                                pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
                        }
                        else
                        {   // set deduced line mode
                            pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeLine);
                        }
                    }
                    pCFI->UnprepareForDebug();
                }
            }
            if (!fShouldHaveLayout)
            {
                // Set outer format to inner
                if (pCFI->_pcf->_uLayoutGridMode != pCFI->_pcf->_uLayoutGridModeInner)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._uLayoutGridMode = pCFI->_pcf->_uLayoutGridModeInner;
                    pCFI->UnprepareForDebug();
                }
                if (    pCFI->_ppf->_uLayoutGridType != pCFI->_ppf->_uLayoutGridTypeInner
                    ||  pCFI->_ppf->_cuvCharGridSize.GetRawValue() != pCFI->_ppf->_cuvCharGridSizeInner.GetRawValue()
                    ||  pCFI->_ppf->_cuvLineGridSize.GetRawValue() != pCFI->_ppf->_cuvLineGridSizeInner.GetRawValue())
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._uLayoutGridType = pCFI->_ppf->_uLayoutGridTypeInner;
                    pCFI->_pf()._cuvCharGridSize = pCFI->_ppf->_cuvCharGridSizeInner;
                    pCFI->_pf()._cuvLineGridSize = pCFI->_ppf->_cuvLineGridSizeInner;
                    pCFI->UnprepareForDebug();
                }
            }
        }

        if (   pCFI->_pff->_fHasAlignedFL
            && (   pCFI->_pff->GetVerticalAlign() != styleVerticalAlignNotSet
                || pCFI->_pff->HasCSSVerticalAlign()
               )
           )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetVerticalAlign(styleVerticalAlignNotSet);
            pCFI->_ff().SetCSSVerticalAlign(FALSE);
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Process any image urls (for background images, li's, etc).
    //
    if (pCFI->_fHasSomeBgImage)
    {
        if (!pCFI->_cstrBgImgUrl.IsNull())
        {
            pCFI->PrepareFancyFormat();
            pCFI->ProcessImgUrl(this, pCFI->_cstrBgImgUrl,
                DISPID_A_BGURLIMGCTXCACHEINDEX, &pCFI->_ff()._lImgCtxCookie, fShouldHaveLayout);
            pCFI->UnprepareForDebug();
            pCFI->_cstrBgImgUrl.Free();
        }

        if (    pCFI->_fBgColorInFLetter
            && !pCFI->_fBgImageInFLetter
            &&  pCFI->_fBgImageInFLine
           )
        {
            pCFI->_cstrPseudoBgImgUrl.Free();
        }

        if (!pCFI->_cstrPseudoBgImgUrl.IsNull())
        {
            pCFI->PreparePEI();
            pCFI->ProcessImgUrl(this, pCFI->_cstrPseudoBgImgUrl,
                (pCFI->_pff->_fHasFirstLetter
                                ? DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER
                                : DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE
                ),
                &pCFI->_pei()._lImgCtxCookie, fShouldHaveLayout);
            pCFI->UnprepareForDebug();
            pCFI->_cstrPseudoBgImgUrl.Free();
        }

        if (!pCFI->_cstrLiImgUrl.IsNull())
        {
            pCFI->PrepareParaFormat();
            pCFI->ProcessImgUrl(this, pCFI->_cstrLiImgUrl,
                DISPID_A_LIURLIMGCTXCACHEINDEX, &pCFI->_pf()._lImgCookie, fShouldHaveLayout);
            pCFI->UnprepareForDebug();
            pCFI->_cstrLiImgUrl.Free();
        }
    }
    
    //
    // ******** ACCUMULATE VALUES **********
    //

    if (!fComputeFFOnly)
    {
        //
        // LEFT/RIGHT indents
        //

        if (fHasLeftIndent)
        {
            const CUnitValue & cuvMarginLeft = pCFI->_pff->GetLogicalMargin(SIDE_LEFT, fParentVertical, fWritingMode);

            pCFI->PrepareParaFormat();

            Assert (!cuvMarginLeft.IsNullOrEnum());

            //
            // LEFT INDENT
            //
            switch (cuvMarginLeft.GetUnitType())
            {
            case CUnitValue::UNIT_PERCENT:
                pCFI->_pf()._cuvLeftIndentPercent.SetValue(
                    pCFI->_pf()._cuvLeftIndentPercent.GetUnitValue() +
                    cuvMarginLeft.GetUnitValue(),
                    CUnitValue::UNIT_PERCENT);
                break;

            case CUnitValue::UNIT_EM:
            case CUnitValue::UNIT_EX:
                if ( lFontHeight == 1 )
                    lFontHeight = pCFI->_pcf->GetHeightInTwips(pDoc);
                // Intentional fall-through...
            default:
                {
                    CUnitValue uvMarginLeft = cuvMarginLeft;
                    hr = uvMarginLeft.ConvertToUnitType(CUnitValue::UNIT_POINT, 0,
                                               CUnitValue::DIRECTION_CX, lFontHeight);
                    if (hr)
                        goto Cleanup;

                    pCFI->_pf()._cuvLeftIndentPoints.SetValue(
                        pCFI->_pf()._cuvLeftIndentPoints.GetUnitValue() +
                        uvMarginLeft.GetUnitValue(),
                        CUnitValue::UNIT_POINT);
                }
            }
            pCFI->UnprepareForDebug();
        }

            //
            // RIGHT INDENT
            //
        if (fHasRightIndent)
        {
            const CUnitValue & cuvMarginRight = pCFI->_pff->GetLogicalMargin(SIDE_RIGHT, fParentVertical, fWritingMode);

            pCFI->PrepareParaFormat();

            Assert (!cuvMarginRight.IsNullOrEnum());

            switch(cuvMarginRight.GetUnitType() )
            {
            case CUnitValue::UNIT_PERCENT:
                pCFI->_pf()._cuvRightIndentPercent.SetValue(
                    pCFI->_pf()._cuvRightIndentPercent.GetUnitValue() +
                    cuvMarginRight.GetUnitValue(),
                    CUnitValue::UNIT_PERCENT);
                break;

            case CUnitValue::UNIT_EM:
            case CUnitValue::UNIT_EX:
                if ( lFontHeight == 1 )
                    lFontHeight = pCFI->_pcf->GetHeightInTwips(pDoc);
                // Intentional fall-through...
            default:
                {
                    CUnitValue uvMarginRight = cuvMarginRight;
                    hr = uvMarginRight.ConvertToUnitType(CUnitValue::UNIT_POINT, 0,
                                               CUnitValue::DIRECTION_CX, lFontHeight);
                    if (hr)
                        goto Cleanup;

                    pCFI->_pf()._cuvRightIndentPoints.SetValue(
                        pCFI->_pf()._cuvRightIndentPoints.GetUnitValue()  +
                        uvMarginRight.GetUnitValue(),
                        CUnitValue::UNIT_POINT);
                }
            }

            pCFI->UnprepareForDebug();
        }

        if (IsListItem(pCFI->_pNodeContext, pCFI->_pff))
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvNonBulletIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
            pCFI->UnprepareForDebug();
        }

        //
        // LINE HEIGHT
        //
        switch ( pCFI->_pcf->_cuvLineHeight.GetUnitType() )
        {
        case CUnitValue::UNIT_EM:
        case CUnitValue::UNIT_EX:
            pCFI->PrepareCharFormat();
            if ( lFontHeight == 1 )
                lFontHeight = pCFI->_cf().GetHeightInTwips(pDoc);
            hr = pCFI->_cf()._cuvLineHeight.ConvertToUnitType( CUnitValue::UNIT_POINT, 1,
                CUnitValue::DIRECTION_CX, lFontHeight );
            pCFI->UnprepareForDebug();
            break;

        case CUnitValue::UNIT_PERCENT:
        {
            pCFI->PrepareCharFormat();
            if ( lFontHeight == 1 )
                lFontHeight = pCFI->_cf().GetHeightInTwips(pDoc);

            //
            // The following line of code does multiple things:
            //
            // 1) Takes the height in twips and applies the percentage scaling to it
            // 2) However, the percentages are scaled so we divide by the unit_percent
            //    scale multiplier
            // 3) Remember that its percent, so we need to divide by 100. Doing this
            //    gives us the desired value in twips.
            // 4) Dividing that by 20 and we get points.
            // 5) This value is passed down to SetPoints which will then scale it by the
            //    multiplier for points.
            //
            // (whew!)
            //
            pCFI->_cf()._cuvLineHeight.SetPoints(MulDivQuick(lFontHeight,
                        pCFI->_cf()._cuvLineHeight.GetUnitValue(),
                        20 * 100 * LONG(CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult)));

            pCFI->UnprepareForDebug();
        }
        break;
        }
    }

    if (    pCFI->_pff->_bPositionType == stylePositionrelative
        ||  pCFI->_pff->_bPositionType == stylePositionabsolute
        ||  fMainBody
        ||  Tag() == ETAG_ROOT)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fPositioned = TRUE;
        pCFI->UnprepareForDebug();
    }
    // cache important values
    if (pCFI->_pff->_fShouldHaveLayout)
    {
        if (    !TestClassFlag(ELEMENTDESC_NEVERSCROLL)
            &&  (   pCFI->_pff->GetOverflowX() == styleOverflowAuto
                ||  pCFI->_pff->GetOverflowX() == styleOverflowScroll
                ||  pCFI->_pff->GetOverflowY() == styleOverflowAuto
                ||  pCFI->_pff->GetOverflowY() == styleOverflowScroll
                ||  (pCFI->_pff->GetOverflowX() == styleOverflowHidden && !pDoc->_fInHomePublisherDoc && !g_fInHomePublisher98)
                ||  (pCFI->_pff->GetOverflowY() == styleOverflowHidden && !pDoc->_fInHomePublisherDoc && !g_fInHomePublisher98)
                ||  TestClassFlag(ELEMENTDESC_CANSCROLL)
                ||  (   !fHTMLLayout
                     && Tag() == ETAG_BODY )
                ||  (   fHTMLLayout
                     && Tag() == ETAG_HTML )))
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fScrollingParent = TRUE;
            pCFI->UnprepareForDebug();
        }
    }

    if (    (fHTMLLayout ? 
                Tag() == ETAG_HTML 
              : pCFI->_pff->_fScrollingParent)
        ||  pCFI->_pff->_fPositioned

            // IE:DEVICERECT is a z-parent too
        ||  pCFI->_pff->GetMediaReference() != mediaTypeNotSet
        
            // Make the master ZParent for content in viewLink
            // Do this only for ident. behaviors for now - play safe for (I)FRAME, INPUT, etc.
        ||  HasSlavePtr() && TagType() == ETAG_GENERIC )
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fZParent = TRUE;
        pCFI->UnprepareForDebug();
    }

    if (    pCFI->_pff->_fPositioned
        &&  (   pCFI->_pff->_bPositionType != stylePositionabsolute
            ||  (  pCFI->_pff->GetLogicalPosition(SIDE_TOP, fParentVertical, fWritingMode).IsNullOrEnum() 
                && pCFI->_pff->GetLogicalPosition(SIDE_BOTTOM, fParentVertical, fWritingMode).IsNullOrEnum())
            ||  (  pCFI->_pff->GetLogicalPosition(SIDE_LEFT, fParentVertical, fWritingMode).IsNullOrEnum() 
                && pCFI->_pff->GetLogicalPosition(SIDE_RIGHT, fParentVertical, fWritingMode).IsNullOrEnum())))
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fAutoPositioned = TRUE;
        pCFI->UnprepareForDebug();
    }

    // 
    // USER HEIGHT 
    // 
    if (    pMarkup->IsStrictCSS1Document() 
        &&  fShouldHaveLayout   )
    {
        BOOL fHasHeight     = FALSE;
        BOOL fPercentHeight = FALSE;
        BOOL fUseUserHeightParent = pCFI->_pcfSrc->_fUseUserHeight; 
        BOOL fUseUserHeightThis;

        if (fMainBody)
        {
            // If this is a main body (e.g. (ETAG_BODY && !HTMLLayout) || (ETAG_HTML && HTMLLayout))
            // its parent (which is viewport) always has a height.
            fUseUserHeightParent = TRUE;
            fHasHeight = TRUE;
        }
        else if (Tag() == ETAG_TD || Tag() == ETAG_TH)
        {
            // For table cells we need to go up to table element and pick up its flag 
            CElement *pElementTable = GetParentAncestorSafe(ETAG_TABLE); 
            if (pElementTable) 
                fUseUserHeightParent = pElementTable->GetFirstBranch()->GetCharFormat()->_fUseUserHeight;
        }

        if (!pCFI->_pff->GetHeight().IsNullOrEnum())
        {
            // 
            // NOTE (table specific) : For NS/IE compatibility, treat negative values as not present
            // 
            if (    Tag() != ETAG_TABLE
                ||  pCFI->_pff->GetHeight().GetUnitValue() > 0  )
            {
                fHasHeight     = TRUE;
                fPercentHeight = pCFI->_pff->GetHeight().IsPercent();
            }
        }

        Check(!fPercentHeight || fHasHeight);
        fUseUserHeightThis = fPercentHeight ? fUseUserHeightParent : fHasHeight;

        if (fUseUserHeightThis != pCFI->_pcf->_fUseUserHeight)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fUseUserHeight = fUseUserHeightThis;
            pCFI->UnprepareForDebug();
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::ApplyDefaultFormat(CFormatInfo * pCFI)
{
    HRESULT             hr = S_OK;
    CMarkup *           pMarkup = GetMarkup();
    CDoc *              pDoc;
    OPTIONSETTINGS *    pos;
    BOOL                fUseStyleSheets;

    // tree-stress crash
    if (!pMarkup)
        goto Cleanup;

    pDoc = pMarkup->Doc();
    if (!pDoc)
        goto Cleanup;
    
    pos = pDoc->_pOptionSettings;
    fUseStyleSheets = !pos || pos->fUseStylesheets;
    
    if (    _pAA
        ||  ( fUseStyleSheets && (pDoc->HasHostStyleSheets() || pMarkup->HasStyleSheets()) )
        ||  ( pos && pos->fUseMyStylesheet)
        ||  (HasSlavePtr() && TagType() == ETAG_GENERIC)
        ||  (HasPeerHolder()) )
    {
        CAttrArray *        pInLineStyleAA;
        CAttrArray *        pDefaultStyleAA;
        CAttrArray *        pRuntimeStyleAA;
        CStyle *            pRuntimeStyle;
        CDefaults *         pDefaults;
        BOOL                fUserImportant = FALSE;
        BOOL                fDocumentImportant = FALSE;
        BOOL                fDefaultImportant = FALSE;
        BOOL                fInlineImportant = FALSE;
        BOOL                fRuntimeImportant = FALSE;
        BOOL                fPeerImportant;

        // TODO (ktam) elements created via CreateElement will be in a markup that doesn't have a window;
        // we have no way of getting media information at that point, so we'll just default to screen media.
        // Hopefully formats get recomputed when the element gets attached elsewhere.
        EMediaType          eMediaType = pMarkup->IsPrintMedia() ? MEDIA_Print : MEDIA_Screen;

        Assert(pCFI && pCFI->_pNodeContext && SameScope(this, pCFI->_pNodeContext));

        if (HasSlavePtr() && TagType() == ETAG_GENERIC)
        {
            pCFI->PrepareFancyFormat();
            
            pCFI->_ff().SetOverflowX(styleOverflowAuto);
            pCFI->_ff().SetOverflowY(styleOverflowAuto);

            // set default size for viewlinked frameset to be the same as IFRAME
            if (GetSlavePtr()->GetMarkup()->_fFrameSet)
            {
                pCFI->_ff().SetWidth(CUnitValue(300, CUnitValue::UNIT_PIXELS));
                pCFI->_ff().SetHeight(CUnitValue(150, CUnitValue::UNIT_PIXELS));
            }

            pCFI->UnprepareForDebug();                      
        }

        // Ignore user's stylesheet and accessability settings if we're in a trusted dialog
        // ...unless we're in a content document for printing.
        if (    !pDoc->_fInTrustedHTMLDlg
            ||  IsPrintMedia() )
        {
            pDoc->EnsureUserStyleSheets();

            if (TLS(pUserStyleSheets))
            {
                hr = THR(TLS(pUserStyleSheets)->Apply(pCFI, APPLY_NoImportant, eMediaType, &fUserImportant));
                if (hr)
                    goto Cleanup;
            }

            pCFI->_fAlwaysUseMyColors   = g_fHighContrastMode ? TRUE : pos->fAlwaysUseMyColors;
            pCFI->_fAlwaysUseMyFontFace = pos->fAlwaysUseMyFontFace;
            pCFI->_fAlwaysUseMyFontSize = pos->fAlwaysUseMyFontSize;
        }

        // Apply any HTML formatting properties
        if (_pAA)
        {
            // Note: ApplyAttrArrayValues checks to see if _pAA is NULL, but we do not want
            // to even call it if _pAA is NULL.
            hr = THR(ApplyAttrArrayValues(pCFI, &_pAA, NULL, APPLY_All, NULL, FALSE));
            if (hr)
                goto Cleanup;
        }

        // Apply defaults
        pDefaults = GetDefaults();
        if (pDefaults)
        {
            pDefaultStyleAA = pDefaults->GetStyleAttrArray();
            if (pDefaultStyleAA)
            {
                hr = THR(ApplyAttrArrayValues(pCFI, &pDefaultStyleAA, NULL, 
                        APPLY_NoImportant, &fDefaultImportant, TRUE, 
                        Doc()->_recalcHost.GetSetValueDispid(this)));
                if (hr)
                    goto Cleanup;
            }
        }

        // Skip author stylesheet properties if they're turned off.
        if (fUseStyleSheets)
        {
            TraceTag((tagRecalcStyle, "Applying author style sheets"));

            hr = THR(pMarkup->ApplyStyleSheets(pCFI, APPLY_NoImportant, eMediaType, &fDocumentImportant));
            if (hr)
                goto Cleanup;

            if (_pAA)
            {
                // Apply any inline STYLE rules

                pInLineStyleAA = GetInLineStyleAttrArray();

                if (pInLineStyleAA)
                {
                    TraceTag((tagRecalcStyle, "Applying inline style attr array"));

                    //
                    // The last parameter to ApplyAttrArrayValues is used to prevent the expression of that dispid from being
                    // overwritten.
                    //
                    // TODO (michaelw) this hackyness should go away when we store both the expression and the value in a single CAttrValue
                    //

                    hr = THR(ApplyAttrArrayValues(pCFI, &pInLineStyleAA, NULL, APPLY_NoImportant, &fInlineImportant, TRUE, Doc()->_recalcHost.GetSetValueDispid(this)));
                    if (hr)
                        goto Cleanup;
                }

                pRuntimeStyle = GetRuntimeStylePtr();
                if (pRuntimeStyle)
                {
                    CAttrArray **ppRuntimeStyleAA = pRuntimeStyle->GetAttrArray();
                    pRuntimeStyleAA = ppRuntimeStyleAA ? *ppRuntimeStyleAA : NULL;
                    if (pRuntimeStyleAA)
                    {
                        TraceTag((tagRecalcStyle, "Applying runtime style attr array"));

                        //
                        // The last parameter to ApplyAttrArrayValues is used to 
                        // prevent the expression of that dispid from being
                        // overwritten.
                        //
                        // TODO (michaelw) this hackyness should go away when 
                        // we store both the expression and the value in a single CAttrValue
                        //

                        hr = THR(ApplyAttrArrayValues(pCFI, &pRuntimeStyleAA, NULL, 
                                APPLY_NoImportant, &fRuntimeImportant, TRUE, 
                                Doc()->_recalcHost.GetSetValueDispid(this)));
                        if (hr)
                            goto Cleanup;
                    }
                }
            }

            if (pMarkup->HasCFState())
            {
                CTreeNode *pNode = pCFI->_pNodeContext;
                CComputeFormatState* pcfState = pMarkup->GetCFState();

                //
                // When we have both tag level rules and wildcard rules, we need
                // to reapply all the first-letter rules. Consider the case where we have
                // p:first-line and .classp both specifying the color. We will first
                // apply the color from p:first-line which will be overidden by the
                // .classp rule. To overcome this problem we reapply *only* the first
                // line rules here. We do this only for the block element which has
                // the pseudo element specified, since the other ones will inherit the
                // correct color.
                //
                if (pcfState->GetComputingFirstLine(pNode))
                {
                    CTreeNode *pNodeBlock = pcfState->GetBlockNodeLine();

                    // Apply only for the element intiating the pseudo element
                    if (SameScope(pNodeBlock, pNode))
                    {
                        // Apply on first line properties...
                        pCFI->_fFirstLineOnly = TRUE;
                        hr = THR(pMarkup->ApplyStyleSheets(pCFI, APPLY_NoImportant, eMediaType, &fDocumentImportant));

                        // Resotre state before checking if Apply* succeeded.
                        pCFI->_fFirstLineOnly = FALSE;

                        if (hr)
                            goto Cleanup;
                    }
                }

                //
                // If we are computing the first letter then we need to apply all the
                // first-letter pseudo element rules for the containing block element
                // after we have applied all the inline formats because first-letter
                // overrides the inline attrs/styles.
                //
                // So if there were a B inside a P which had first-letter, then when
                // applying the properties for B we would call to apply the properties
                // for P -- but only the first-letter properties.
                //
                // Remember that this is the only time, where we look *up* in the tree
                // when we are computing formats for a node.
                //
                if (pcfState->GetComputingFirstLetter(pNode))
                {
                    CTreeNode *pNodeBlock = pcfState->GetBlockNodeLetter();

                    // Apply only the first letter properties...
                    pCFI->_fFirstLetterOnly = TRUE;

                    // To calculate relative font-size always use the parent size
                    // to avoid applying relative value more than once.
                    pCFI->_fUseParentSizeForPseudo = !SameScope(pNode, pNodeBlock);

                    // for the parent block element only
                    pCFI->_pNodeContext = pNodeBlock;
                    hr = THR(pMarkup->ApplyStyleSheets(pCFI, APPLY_NoImportant, eMediaType, &fDocumentImportant));

                    // restore before checking if Apply* succeeded.
                    pCFI->_pNodeContext = pNode;
                    pCFI->_fFirstLetterOnly = FALSE;

                    if (hr)
                        goto Cleanup;
                }
            }
        }

        fPeerImportant = HasPeerHolder() && (pCFI->_eExtraValues == ComputeFormatsType_Normal);
        
        if (fDefaultImportant | fDocumentImportant | fInlineImportant | fRuntimeImportant | fPeerImportant | fUserImportant)
        {
            // Now handle any "!important" properties.
            // Order: default, document !important, inline, runtime, user !important.

            // Apply any default STYLE !important rules
            if (fDefaultImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important default styles"));

                hr = THR(ApplyAttrArrayValues(pCFI, &pDefaultStyleAA, NULL, APPLY_ImportantOnly));
                if (hr)
                    goto Cleanup;
            }

            // Apply any document !important rules
            if (fDocumentImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important doc styles"));

                hr = THR(pMarkup->GetStyleSheetArray()->Apply(pCFI, APPLY_ImportantOnly, eMediaType));
                if (hr)
                    goto Cleanup;
            }

            // Apply any inline STYLE rules
            if (fInlineImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important inline styles"));

                hr = THR(ApplyAttrArrayValues(pCFI, &pInLineStyleAA, NULL, APPLY_ImportantOnly));
                if (hr)
                    goto Cleanup;
            }

            // Apply any runtime important STYLE rules
            if (fRuntimeImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important runtimestyles"));

                hr = THR(ApplyAttrArrayValues(pCFI, &pRuntimeStyleAA, NULL, APPLY_ImportantOnly));
                if (hr)
                    goto Cleanup;
            }
        
            if (fPeerImportant)
            {
                CPeerHolder *   pPeerHolder = GetPeerHolder();

                if (pPeerHolder->TestFlagMulti(CPeerHolder::NEEDAPPLYSTYLE) &&
                    !pPeerHolder->TestFlagMulti(CPeerHolder::LOCKAPPLYSTYLE))
                {
                    //
                    // This needs to be deferred so that arbitrary script code
                    // does not run inside of the Compute pass.
                    //

                    AssertSz( FALSE, "This has been disabled and shouldn't happen - talk to JHarding" );
                    hr = THR(ProcessPeerTask(PEERTASK_APPLYSTYLE_UNSTABLE));
                    if (hr)
                        goto Cleanup;
                }
            }

            // Apply user !important rules last for accessibility
            if (fUserImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important user styles"));

                hr = THR(TLS(pUserStyleSheets)->Apply(pCFI, APPLY_ImportantOnly, eMediaType));
                if (hr)
                    goto Cleanup;
            }
        }
    }
    
    if (ComputeFormatsType_ForceDefaultValue == pCFI->_eExtraValues)
    {
        Assert(pCFI->_pStyleForce);
        CAttrArray **ppAA = pCFI->_pStyleForce->GetAttrArray();
        if (ppAA)
        {
            hr = THR(ApplyAttrArrayValues(pCFI, ppAA, NULL, APPLY_All));
        }
        goto Cleanup;
    }

    //
    // Setup layoutflow of nested layouts. We may have a differing default layout flow 
    // than our parent only if:
    //
    //  1) There are vertical layouts in this document
    //  1.1) We are computing CF and PF and not just FF
    //  2) The layout flow has not been set explicitly on this element
    //  3) This element is in a vertical flow layout
    //  4) and finally, this element if in a vertical layout, will still be horizontal
    //
    if (   GetMarkup()->_fHaveDifferingLayoutFlows
        && (pCFI->_pNodeContext->GetICF(FCPARAM) == -1) // !fComputeFFOnly
       )
    {
        if (   !pCFI->_pff->_fLayoutFlowSet
            && pCFI->_pcf->HasVerticalLayoutFlow()
            && ElementHIV(Tag())
           )
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._wLayoutFlow = styleLayoutFlowHorizontal;
            if (!pCFI->_cf()._fExplicitAtFont)
            {
                if (pCFI->_cf().NeedAtFont())
                {
                    ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
                }
                else
                {
                    RemoveAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
                }
            }

            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fLayoutFlowChanged = TRUE;

            pCFI->UnprepareForDebug();
        }

        if (pCFI->_pcf->HasVerticalLayoutFlow())
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
            pCFI->UnprepareForDebug();
        }
    }

Cleanup:
    RRETURN(hr);
}

//--------------------------------------------------------------
//
// Method:      CElement::AddFilters
//
// Description: Called async from EnsureView, this method looks at
//              the filter string and destroys and/or creates the
//              filter collection (and each filter).  If this method
//              is called we assume that we are replacing the 
//              old filter collection with a new one.
//
//--------------------------------------------------------------

HRESULT
CElement::AddFilters()
{
    CFilterBehaviorSite  *pFS;;

    HRESULT hr;

    hr = THR(EnsureFilterBehavior(TRUE, &pFS));
    if(hr)
        goto Cleanup;
       
    // Build the add the fiters
    hr = THR(pFS->ParseAndAddFilters());

Cleanup:

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Method: CElement::EnsureFilterBehavior
//
//  Overview: 
//      Creates the CFilterBehaviorSite and the behavior itself.  If 
//      fForceRemoveAll is FALSE and a filter behavior is already attatched to
//      the element the funtion just retuns S_FALSE.
//
//------------------------------------------------------------------------------
HRESULT
CElement::EnsureFilterBehavior(BOOL fForceReplaceOld, CFilterBehaviorSite **ppSite /* =  NULL */)
{
    HRESULT                hr;
    CFilterBehaviorSite  * pFS      = NULL;
    CTreeNode            * pNode    = GetFirstBranch();

    if (!pNode)
    {
        hr = E_PENDING;

        goto Cleanup;
    }

    hr = THR(Doc()->EnsureFilterBehaviorFactory());

    if (hr)
    {
        goto Cleanup;
    }

    pFS = GetFilterSitePtr();

    // If it was requested that this function NOT replace the old filter 
    // behavior entirely, but we already have one then return S_FALSE.
    //
    // ##ISSUE: (mcalkins) We now never replace the filter behavior entirely so
    //          we may want to rethink this.  Maybe they have a good case for 
    //          really forcing the behavior replacement, but if there are
    //          private filters on the behavior, this will be very bad since
    //          external code will have pointers to filters that they need to
    //          remain valid.

    if (   !fForceReplaceOld 
        && pFS 
        && pFS->HasBehaviorPtr())
    {
        if (ppSite)
        {
            *ppSite = pFS;
        }

        hr = S_FALSE;

        goto Cleanup;
    }

    // if we're in the middle of attaching a peer to the element already,
    // we'll have to try again later (bug 105894)

    if (TestLock(ELEMENTLOCK_ATTACHPEER))
    {
        hr = E_PENDING; 

        goto Cleanup;
    }

    if (!pFS)
    {
        // Create a filter site and filter behavior for this element.

        pFS = new CFilterBehaviorSite(this);

        if (!pFS)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        SetFilterSitePtr(pFS);
    }

    // Even if we don't successfully create the filter behavior, I think we
    // can return a pointer to the filter site we've successfully created and
    // set the CSS filter string.

    if (ppSite)
    {
        *ppSite = pFS;
    }

    pFS->SetFullText(pNode->GetFancyFormat()->_pszFilters);

    // Do whatever is needed to have a filter behavior with no CSS filters
    // attached to the element.  

    if (pFS->HasBehaviorPtr())
    {
       // Remove all of the current CSS filters from the filter behavior.

       hr = THR(pFS->RemoveAllCSSFilters());

       if (hr)
       {
           goto Cleanup;
       }
    }
    else
    {
        // Create the actual filter behavior.  Obviously, it will start off with
        // no CSS filters attatched.

        hr = THR(pFS->CreateFilterBehavior(this));

        if (hr)
        {
            goto Cleanup;
        }
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}
//  Method: CElement::EnsureFilterBehavior


// VoidCachedInfo -------------------------------------------------------------

void
CTreeNode::VoidCachedNodeInfo ()
{
    THREADSTATE * pts = GetThreadState();

    // Only CharFormat and ParaFormat are in sync.
    Assert( (_iCF == -1 && _iPF == -1) || (_iCF >= 0  && _iPF >= 0) );

    if(_iCF != -1)
    {
        TraceTag((tagFormatCaches, "Releasing format cache entries "
                                "(iFF: %d, iPF: %d, iCF:%d )  for "
                                "node (SN: N%d)",
                                _iFF, _iPF, _iCF,  SN()));

        MtAdd( Mt(CharParaFormatVoided), +1, 0 );

        (pts->_pCharFormatCache)->ReleaseData( _iCF );
        _iCF = -1;

        (pts->_pParaFormatCache)->ReleaseData( _iPF );
        _iPF = -1;
           
    }

    if(_iFF != -1)
    {
        MtAdd( Mt(FancyFormatVoided), +1, 0 );

        (pts->_pFancyFormatCache)->ReleaseData( _iFF );
        _iFF = -1;
    }

#ifdef MULTI_FORMAT
    if (_pFormatTable)
    {
        //right now, we invalidate everything
        _pFormatTable->VoidCachedInfo(pts);
        delete _pFormatTable;
        _pFormatTable = NULL;
        
    }
#endif//MULTI_FORMAT

    // NOTE this assert is meaningless with context (t-michda)
    Assert(_iCF == -1 && _iPF == -1 && _iFF == -1);

#ifndef GENERALISED_STEALING
    if (SameScope(TLS(_pNodeLast), this))
    {
        TLS(_pNodeLast) = NULL;
    }
#else
    if (   g_EtagCache[Tag()]
        && SameScope(TLS(_pNodeLast[Tag()]), this)
       )
    {
        TLS(_pNodeLast[Tag()]) = NULL;
    }
#endif
    
}

#ifdef MULTI_FORMAT

void
CFormatTable::VoidCachedInfo( THREADSTATE * pts)
{
    int nEntries = _aryFC.Size();
    
    for (int i = 0 ; i < nEntries; i++)
    {
        if(_aryFC[i]._iCF != -1)
        {
            TraceTag((tagFormatCaches, "Releasing format cache entries "
                                    "(iFF: %d, iPF: %d, iCF:%d )  for "
                                    "a format table for above node",
                                    _aryFC[i]._iFF, _aryFC[i]._iPF, _aryFC[i]._iCF));

            (pts->_pCharFormatCache)->ReleaseData( _aryFC[i]._iCF );
            _aryFC[i]._iCF = -1;

            (pts->_pParaFormatCache)->ReleaseData( _aryFC[i]._iPF );
            _aryFC[i]._iPF = -1;
           
        }

        if(_aryFC[i]._iFF != -1)
        {
            (pts->_pFancyFormatCache)->ReleaseData( _aryFC[i]._iFF );
            _aryFC[i]._iFF = -1;
        }
    }
}

#endif //MULTI_FORMAT

void
CTreeNode::VoidCachedInfo ()
{
    Assert( Element() );
    Element()->_fDefinitelyNoBorders = FALSE;

    if(Element()->GetLayoutPtr())
        Element()->GetLayoutPtr()->InvalidateFilterPeer(NULL, NULL, FALSE);

    VoidCachedNodeInfo();
}

void
CTreeNode::VoidFancyFormat()
{
    THREADSTATE * pts = GetThreadState();

    if(_iFF != -1)
    {
        MtAdd( Mt(FancyFormatVoided), +1, 0 );

        TraceTag((tagFormatCaches, "Releasing fancy format cache entry "
                                "(iFF: %d)  for "
                                "node (SN: N%d)",
                                _iFF,  SN()));

        (pts->_pFancyFormatCache)->ReleaseData( _iFF );
        _iFF = -1;

    }

#ifdef MULTI_FORMAT
    if (_pFormatTable)
    {
        _pFormatTable->VoidFancyFormat(pts);
    }
#endif //MULTI_FORMAT    

}

#ifdef MULTI_FORMAT

void
CFormatTable::VoidFancyFormat(THREADSTATE * pts)
{

    int nEntries = _aryFC.Size();
    
    for (int i = 0; i < nEntries; i++)
    {
        TraceTag((tagFormatCaches, "Releasing fancy format cache entry "
                                "(iFF: %d)  for "
                                "a format table for above node",
                                _aryFC[i]._iFF));
         (pts->_pFancyFormatCache)->ReleaseData(_aryFC[i]._iFF);
         _aryFC[i]._iFF = -1;
    }

}

#endif

void
CFormatInfo::SetMatchedBy(EPseudoElement pelemType)
{
    _ePseudoElement = pelemType;
}

EPseudoElement
CFormatInfo::GetMatchedBy()
{
    Assert(_ePseudoElement != pelemUnknown);
    return _ePseudoElement;
}

#ifdef MULTI_FORMAT

const CFormatTableEntry *
CFormatTable::FindEntry(void * pContextId)
{
    static const CFormatTableEntry defaultTableEntry = {NULL, -1, -1, -1};

    int nEntries = _aryFC.Size();
    for (int i=0; i<nEntries; i++)
    {
        if (_aryFC[i]._pContextId == pContextId)
        {
            return &_aryFC[i];
        }
    }

    return &defaultTableEntry;
}

CFormatTableEntry * 
CFormatTable::FindAndAddEntry(void * pContextId)
{
    CFormatTableEntry * pEntry = const_cast<CFormatTableEntry*>(FindEntry(pContextId));

    if (pEntry->_pContextId != NULL) // if FindEntry didn't return the default
    {
        return pEntry;
    }

    pEntry = _aryFC.Append();
    
    pEntry->_pContextId = pContextId;
    pEntry->_iCF = -1;
    pEntry->_iPF = -1;
    pEntry->_iFF = -1;

    return pEntry;
}

#endif //MULTI_FORMAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\elemlyt.cxx ===
//==================================================================
//
//  File : ElemLyt.cxx
//
//  Contents : The CElement functions related to handling their layouts
//
//==================================================================
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_CKBOXLYT_HXX_
#define X_CKBOXLYT_HXX_
#include "ckboxlyt.hxx"
#endif

#ifndef X_FSLYT_HXX_
#define X_FSLYT_HXX_
#include "fslyt.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_BTNLYT_HXX_
#define X_BTNLYT_HXX_
#include "btnlyt.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_HRLYT_HXX_
#define X_HRLYT_HXX_
#include "hrlyt.hxx"
#endif

#ifndef X_HTMLLYT_HXX_
#define X_HTMLLYT_HXX_
#include "htmllyt.hxx"
#endif

#ifndef X_MARQLYT_HXX_
#define X_MARQLYT_HXX_
#include "marqlyt.hxx"
#endif

#ifndef X_CONTLYT_HXX_
#define X_CONTLYT_HXX_
#include "contlyt.hxx"
#endif

#ifndef X_IEXTAG_HXX_
#define X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

ExternTag(tagNotifyPath);

DeclareTag(tagLayoutAry, "Layout: Layout Ary", "Trace CLayoutAry fns");

//+--------------------------------------------------------------------------------------
//+--------------------------------------------------------------------------------------
//
//  General CElement Layout related functions
//
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     GetLayoutFromFactory
//
//  Synopsis:   Creates the layout object to be associated with the current element
//
//--------------------------------------------------------------------------
HRESULT GetLayoutFromFactory(CElement * pElement, CLayoutContext *pLayoutContext, DWORD dwFlags, CLayout ** ppLayout)
{
    CLayout *   pLayout                 = NULL;
    HRESULT     hr                      = S_OK;
    BOOL        fCreateGenericLayout;

    if (!ppLayout)
        return E_POINTER;

    *ppLayout = NULL;

#if DBG
    if ( pLayoutContext )
    {
        AssertSz( pLayoutContext->IsValid(), "Context should have an owner at this point.  Unowned contexts shouldn't be used to create layouts." );
        // Contexts must be defined by either LAYOUTRECTs or DEVICERECTs.  In the former case,
        // the element that wants a layout in the context must be in a difference markup,
        // in the latter, it must be in the same markup (the template).
        Assert(   (   pLayoutContext->GetLayoutOwner()->ElementOwner()->IsLinkedContentElement()
                     && pLayoutContext->GetLayoutOwner()->GetOwnerMarkup() != pElement->GetMarkup() )
                 || (   !FormsStringICmp(pLayoutContext->GetLayoutOwner()->ElementOwner()->TagName(), _T("DEVICERECT") )
                     && pLayoutContext->GetLayoutOwner()->GetOwnerMarkup() == pElement->GetMarkup() ) );
    }
#endif

    if (!pElement || pElement->HasMasterPtr())
        return E_INVALIDARG;

#ifdef TEMP_UNASSERT  // temporarily removing this to help test. we should fix this situation in V4
    Assert(!pElement->IsPassivating());
#endif

    Assert(!pElement->IsPassivated());
    Assert(!pElement->IsDestructing());

    fCreateGenericLayout = pElement->HasSlavePtr();

    // this is our basic LayoutFactory.  It will match the appropriate default
    // layout with the tag. the generic C1DLayout is used for tags which do not
    // have their own specific layout.
    switch (pElement->TagType())
    {
    case ETAG_INPUT:
        {
            switch (DYNCAST(CInput, pElement)->GetType())
            {
            case htmlInputButton:
            case htmlInputReset:
            case htmlInputSubmit:
                Assert(fCreateGenericLayout);
                fCreateGenericLayout = FALSE;
                pLayout = new CInputButtonLayout(pElement, pLayoutContext);
                break;
            case htmlInputFile:
                Assert(fCreateGenericLayout);
                fCreateGenericLayout = FALSE;
                pLayout = new CInputFileLayout(pElement, pLayoutContext);
                break;
            case htmlInputText:
            case htmlInputPassword:
            case htmlInputHidden:
                Assert(fCreateGenericLayout);
                fCreateGenericLayout = FALSE;
                pLayout = new CInputTextLayout(pElement, pLayoutContext);
                break;
            case htmlInputCheckbox:
            case htmlInputRadio:
                if (!fCreateGenericLayout)
                {
                    pLayout = new CCheckboxLayout(pElement, pLayoutContext);
                }
                break;
            case htmlInputImage:
                if (!fCreateGenericLayout)
                {
                    pLayout = new CInputImageLayout(pElement, pLayoutContext);
                }
                break;
            default:
                AssertSz(FALSE, "Illegal Input Type");
            }
        }
        break;

    case ETAG_IMG:
        if (!fCreateGenericLayout)
        {
            pLayout = new CImgElementLayout(pElement, pLayoutContext);
        }
        break;

    case ETAG_HTML:
        fCreateGenericLayout = FALSE;
        pLayout = new CHtmlLayout(pElement, pLayoutContext);
        break;

    case ETAG_BODY:
        fCreateGenericLayout = FALSE;
        pLayout = new CBodyLayout(pElement, pLayoutContext);
        break;

    case ETAG_BUTTON:
        fCreateGenericLayout = FALSE;
        pLayout = new CButtonLayout(pElement, pLayoutContext);
        break;

    case ETAG_MARQUEE:
        fCreateGenericLayout = FALSE;
        pLayout = new CMarqueeLayout(pElement, pLayoutContext);
        break;

    case ETAG_TABLE:
        if (pElement->HasLayoutAry())
        {
            // If this is a view chain case create block layout 
            pLayout = new CTableLayoutBlock(pElement, pLayoutContext);
        }
        else
        {
            pLayout = new CTableLayout(pElement, pLayoutContext);
        }
        break;

    case ETAG_TD:
    case ETAG_TC:
    case ETAG_TH:
    case ETAG_CAPTION:
        fCreateGenericLayout = FALSE;
        pLayout = new CTableCellLayout(pElement, pLayoutContext);
        break;

    case ETAG_TEXTAREA:
        fCreateGenericLayout = FALSE;
        pLayout = new CTextAreaLayout(pElement, pLayoutContext);
        break;

    case ETAG_TR:
        if (pElement->HasLayoutAry())
        {
            pLayout = new CTableRowLayoutBlock(pElement, pLayoutContext);
        }
        else
        {
            pLayout = new CTableRowLayout(pElement, pLayoutContext);
        }
        break;

    case ETAG_LEGEND:
        fCreateGenericLayout = FALSE;
        pLayout = new CLegendLayout(pElement, pLayoutContext);
        break;

    case ETAG_FIELDSET:
        fCreateGenericLayout = FALSE;
        pLayout = new CFieldSetLayout(pElement, pLayoutContext);
        break;

    case ETAG_SELECT:
        pLayout = new CSelectLayout(pElement, pLayoutContext);
        break;

    case ETAG_HR:
        pLayout = new CHRLayout(pElement, pLayoutContext);
        break;

    case ETAG_FRAMESET:
        pLayout = new CFrameSetLayout(pElement, pLayoutContext);
        break;

    case ETAG_IFRAME:
    case ETAG_FRAME:
        fCreateGenericLayout = TRUE;
        break;

    case ETAG_OBJECT:
    case ETAG_EMBED:
    case ETAG_APPLET:
        pLayout = new COleLayout(pElement, pLayoutContext);
        break;

    case ETAG_GENERIC:
        if (pElement->IsLinkedContentElement())
        {
            fCreateGenericLayout = FALSE;
            pLayout = new CContainerLayout(pElement, pLayoutContext);
        }
        else
        {
            fCreateGenericLayout = TRUE;
        }
        break;

    default:
        fCreateGenericLayout = TRUE;
        break;
    }


    if (fCreateGenericLayout)
    {
        Assert(!pLayout);
        pLayout = new C1DLayout(pElement, pLayoutContext);
        if (pLayout)
        {
            pElement->_fOwnsRuns = TRUE;
        }
    }

    if (!pLayout)
        hr = E_OUTOFMEMORY;
    else
    {
        pLayout->Init();        //  For now, this can be called at creation time.
    }
    
    *ppLayout = pLayout;

    RRETURN(hr);
}


CLayout *
CElement::CreateLayout( CLayoutContext * pLayoutContext )
{
    CLayout *   pLayout = NULL;
    HRESULT     hr;

    Assert(   ( pLayoutContext && !CurrentlyHasLayoutInContext( pLayoutContext ) )
           || ( !HasLayoutPtr() && !HasLayoutAry() ) );

    // GetLayoutFromFactory is a static function in this file.
    hr = THR(GetLayoutFromFactory(this, pLayoutContext, 0, &pLayout));
    if( SUCCEEDED( hr ) )
    {
        Assert( pLayout );
        if ( pLayoutContext )
        {
            CLayoutAry *pLA = EnsureLayoutAry();
            Assert( pLA && pLA == _pLayoutAryDbg );
            if ( !pLA )
            {
                return NULL;
            }
            
            Assert( pLayout->LayoutContext() == pLayoutContext );
            pLA->AddLayoutWithContext( pLayout );
        }
        else
        {
            SetLayoutPtr(pLayout);
        }

        CPeerHolder *   pPeerHolder = GetRenderPeerHolder();

        if (pPeerHolder)
        {
            hr = THR(pPeerHolder->OnLayoutAvailable(pLayout));
        }
    }

    return pLayout;
}

CFlowLayout *
CTreeNode::GetFlowLayout( CLayoutContext * pLayoutContext )
{
    CTreeNode   * pNode = this;
    CFlowLayout * pFL;

    while(pNode)
    {
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
            if (!pNode)
                break;
        }
        pFL = pNode->HasFlowLayout( pLayoutContext );
        if (pFL)
            return pFL;
        pNode = pNode->Parent();
    }

    return NULL;
}


CTreeNode *
CTreeNode::GetFlowLayoutNode( CLayoutContext * pLayoutContext )
{
    CTreeNode   * pNode = this;

    while(pNode)
    {
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
            if (!pNode)
                break;
        }
        if(pNode->HasFlowLayout( pLayoutContext ))
            return pNode;
        pNode = pNode->Parent();
    }

    return NULL;
}

// TODO (MohanB, KTam): why weren't the rest of the GetUpdated*Layout* fns changed to also
// climb out of the slave tree?
CTreeNode *
CTreeNode::GetUpdatedParentLayoutNode()
{
    CTreeNode   * pNode = this;
    /*
                            Element()->HasMasterPtr() ?
                            Element()->GetMasterPtr()->GetFirstBranch() :
                            this;
*/
    for(;;)
    {
        Assert(pNode);
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
        }
        else
        {
            pNode = pNode->Parent();
        }
        if (!pNode)
            break;
        if (pNode->ShouldHaveLayout())
            return pNode;
    }
    return NULL;
}


//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------
//              
//  CLayoutAry implementation
//              
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

CLayoutAry::CLayoutAry( CElement *pElementOwner ) :
    CLayoutInfo( pElementOwner )
{
     _fHasMarkupPtr = FALSE;
    // $$ktam: CLayoutAry doesn't have lookasides right now; if it ever does, we
    // should assert a _pDocDbg->AreLookasidesClear() check here.
}

CLayoutAry::~CLayoutAry()
{
    // Clean up all the CLayout's we're holding onto
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    for ( i=0 ; i < nLayouts ; ++i)
    {
        pLayout = _aryLE[i];
        Assert( pLayout && "Layout array shouldn't have NULL entries!" );
        pLayout->Detach();
        pLayout->Release();
    }

    if (nLayouts)
    {
        _aryLE.DeleteMultiple(0, nLayouts-1);
    }

    __pvChain = NULL;
    _fHasMarkupPtr = FALSE;
    
#if DBG == 1
    _snLast = 0;
    _pDocDbg = NULL;
    _pMarkupDbg = NULL;
#endif
}

void
CLayoutAry::DelMarkupPtr()
{
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;
    for ( i = nLayouts-1 ; i >= 0 ; --i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        pLayout->DelMarkupPtr();
    }

    Assert(_fHasMarkupPtr);
    Assert( _pMarkup == _pMarkupDbg);
    WHEN_DBG(_pMarkupDbg = NULL );

    // Delete out CMarkup *
    _pDoc = _pMarkup->Doc();
    _fHasMarkupPtr = FALSE;
}

void
CLayoutAry::SetMarkupPtr(CMarkup *pMarkup)
{
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;
    for ( i = nLayouts-1 ; i >= 0 ; --i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        pLayout->SetMarkupPtr(pMarkup);
    }

    Assert( !_fHasMarkupPtr );
    Assert( pMarkup );
    Assert( pMarkup->Doc() == _pDocDbg );

     _pMarkup = pMarkup;
     WHEN_DBG( _pMarkupDbg = pMarkup );
     _fHasMarkupPtr = TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     AddLayoutWithContext
//
//--------------------------------------------------------------------------
void
CLayoutAry::AddLayoutWithContext( CLayout *pLayout )
{
    TraceTagEx((tagLayoutAry, TAG_NONAME,
                "CLytAry::AddLayoutWithContext lyt=0x%x, lc=0x%x, e=[0x%x,%d] (%S)",
                pLayout,
                pLayout->LayoutContext(), 
                pLayout->ElementOwner(), 
                pLayout->ElementOwner()->SN(), 
                pLayout->ElementOwner()->TagName()));

    AssertSz( pLayout->LayoutContext() && pLayout->LayoutContext()->IsValid(),
              "Illegal to add a layout w/o valid context to a layout array!" );
    
#if DBG == 1
    // Assert that a layout with the same context doesn't already exist in the array.
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayoutIter;

    for ( i=0 ; i < nLayouts ; ++i)
    {
        pLayoutIter = _aryLE[i];
        Assert( !(pLayoutIter->LayoutContext()->IsEqual( pLayout->LayoutContext() )) );
    }
#endif

    _aryLE.AppendIndirect( &pLayout );

    // NOTE (KTam): There's general concern here that layouts should
    // probably be ref-counted.  Think about doing this.. they aren't
    // CBase derived right now, so we have no current support for it.

    Assert( ! pLayout->_fHasMarkupPtr );    // new layout shouldn't already have a markup

    // Layouts within an array share the same _pvChain info
    pLayout->__pvChain = __pvChain; 
    pLayout->_fHasMarkupPtr = _fHasMarkupPtr;

#if DBG ==1
    if ( _fHasMarkupPtr )
    {
        Assert( _pMarkupDbg );
        pLayout->_pMarkupDbg = _pMarkupDbg;
    }

#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     GetLayoutWithContext
//
//--------------------------------------------------------------------------
CLayout *
CLayoutAry::GetLayoutWithContext( CLayoutContext *pLayoutContext )
{
    int i;
    int nLayouts = Size();
    CLayout *pLayout;

    // TODO (KTam): Remove this when we no longer support "allowing GUL bugs".
    if ( !pLayoutContext )
    {
        Assert( Size() );
        pLayout = _aryLE[0];
        Assert( pLayout && "Layout array shouldn't have NULL entries!" );
        return pLayout;
    }

    AssertSz( pLayoutContext->IsValid(), "Should not be asking for a layout using an invalid context!" );

    // Linear seach array to see if there's a layout associated with this
    // context.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        Assert( pLayout->LayoutContext() && "Layouts in array must have context!" );
        if ( pLayout->LayoutContext()->IsEqual( pLayoutContext ) )
            return pLayout;
    }

    // No layout corresponding to this context
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     RemoveLayoutWithContext
//
//  Synopsis:   Searches for a layout that is associated with pLayoutContext,
//              removing it from the array and returning it if found.
//
//              NOTE: The test for association is currently layout context
//              pointer equality: this means 2 contexts w/ the same layout
//              owner are not equal, and thus compatible contexts need to be
//              treated separately.
//
//--------------------------------------------------------------------------
CLayout *
CLayoutAry::RemoveLayoutWithContext( CLayoutContext *pLayoutContext )
{
    int i;
    int nLayouts = Size();
    CLayout *pLayout = NULL;

    Assert( pLayoutContext );
    // Depending on how we use this function, this assert may not be true.
    // We may for example choose to use this fn to remove layouts that have
    // invalid contexts!
    Assert( pLayoutContext->IsValid() );

    // Linear seach array to see if there's a layout associated with this
    // context.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        CLayout *pL = _aryLE[i];
        Assert( pL->LayoutContext() && "Layouts in array must have context!" );
        if ( pL->LayoutContext()->IsEqual( pLayoutContext ) )
        {
            // Remove the layout from the array, and return it
            Verify(_aryLE.DeleteByValueIndirect( &pL ));
            pLayout = pL;
            goto Cleanup;
        }
    }

Cleanup:
    TraceTagEx((tagLayoutAry, TAG_NONAME,
                "CLytAry::RemoveLayoutWithContext lyt=0x%x, lc=0x%x, e=[0x%x,%d] (%S)",
                pLayout,
                pLayout ? pLayout->LayoutContext() : NULL, 
                pLayout ? pLayout->ElementOwner() : NULL, 
                pLayout ? pLayout->ElementOwner()->SN() : -1, 
                pLayout ? pLayout->ElementOwner()->TagName() : TEXT("")));

    return pLayout;
}

//+----------------------------------------------------------------------------
//  Helpers delegated from CElement
//-----------------------------------------------------------------------------
BOOL
CLayoutAry::ContainsRelative()
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array to see if there's a layout that contains relative stuff.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            if ( pLayout->_fContainsRelative )
                return TRUE;
        }
    }

    return FALSE;
}

BOOL
CLayoutAry::GetEditableDirty()
{
    Assert( _aryLE.Size() );

    BOOL fEditableDirty = (_aryLE[GetFirstValidLayoutIndex()])->_fEditableDirty;

#if DBG
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // All layouts in collection should have same value for fEditableDirty
    // Linear seach array to assert this is true.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            Assert( !!pLayout->_fEditableDirty == !!fEditableDirty );
        }
    }
#endif

    return fEditableDirty;
}

void
CLayoutAry::SetEditableDirty( BOOL fEditableDirty )
{
    Assert( _aryLE.Size() );
    
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array to set flag on each of them.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            pLayout->_fEditableDirty = fEditableDirty;
        }
    }
}

CLayoutAry::WantsMinMaxNotification()
{
    Assert( _aryLE.Size() );
    
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            // If any layout wants minmax notifications, then the array wants to be notified.
            // Make sure "if" condition stays in sync with what's in CElement::MinMaxElement
            if ( pLayout->_fMinMaxValid )
            {
                return TRUE;
            }
        }
    }

    // No layouts in the array wants a resize notification
    return FALSE;
}


BOOL
CLayoutAry::WantsResizeNotification()
{
    Assert( _aryLE.Size() );
    
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            // If any layout wants resize notifications, then the array wants to be notified.
            // Make sure "if" condition stays in sync with what's in CElement::ResizeElement
            // TODO (KTam): THIS CONDITION IS NO LONGER IN SYNC, but that's OK for IE5.5.
            // NOTE (KTam): consider unifying condition in a CLayout::WantsResizeNotification() fn
            if ( !pLayout->IsSizeThis() && !pLayout->IsCalcingSize() )
            {
                return TRUE;
            }
        }
    }

    // No layouts in the array wants a resize notification
    return FALSE;
}

void
CLayoutAry::Notify(
    CNotification * pnf)
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Most notifications that come to the layout array should be passed on to each layout.
    // However, some are actually mean for the array.
    switch ( pnf->Type() )
    {    
        case NTYPE_MULTILAYOUT_CLEANUP:
        {
            // Iterate over array deleting layouts with invalid contexts.  Do it in
            // reverse to simplify iteration during deletion.
            for ( i = nLayouts-1 ; i >= 0 ; --i )
            {
                pLayout = _aryLE[i];
                AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
                if ( !pLayout->LayoutContext()->IsValid() )
                {
                    // Remove the layout from the array
                    _aryLE.Delete(i);
                    // Get rid of the layout
                    pLayout->Detach();
                    pLayout->Release();
                }
            }
            break;
        }

        case NTYPE_ELEMENT_ZCHANGE:
        case NTYPE_ELEMENT_REPOSITION:
            if (pnf->LayoutContext())
            {
                // Iterate over array finding specified layout.  Do it in
                // reverse because in most cases this is a last layout added.
                for ( i = nLayouts-1 ; i >= 0 ; --i )
                {
                    pLayout = _aryLE[i];
                    AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
                    if (   pLayout->LayoutContext()->IsValid() 
                        && pLayout->LayoutContext() == pnf->LayoutContext() )
                    {
                        TraceTagEx((tagNotifyPath, TAG_NONAME,
                                   "NotifyPath: (%d) sent to pLayout(0x%x, %S) via layout array",
                                   pnf->_sn,
                                   pLayout,
                                   pLayout->ElementOwner()->TagName()));

                        pLayout->Notify( pnf );
                        break;
                    }
                }

                //
                // Getting here means that this elementOwner has no layout in the context of the
                // notification.  If the ElemetnOwner is a LayoutRect then that means the notification
                // has come from somewhere inside us and we do not want this to continue to bubble 
                // up through the view link to the outside document
                //
                if (ElementOwner()->IsLinkedContentElement())
                {
                    pnf->SetHandler(ElementOwner());
                }
                break;
            }
        // do not insert other cases here !!! previous case is sensitive to position of default case !!!
        default:
        // Notification meant for individual layouts: tell each layout in the array about it
        {
            for ( i=0 ; i < nLayouts ; ++i )
            {
                pLayout = _aryLE[i];
                AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
                if ( pLayout->LayoutContext()->IsValid() )
                {
                    TraceTagEx((tagNotifyPath, TAG_NONAME,
                               "NotifyPath: (%d) sent to pLayout(0x%x, %S) via layout array",
                               pnf->_sn,
                               pLayout,
                               pLayout->ElementOwner()->TagName()));

                    pLayout->Notify( pnf );
                }
            }
            break;
        }
    }
}

//////////////////////////////////////////////////////
//
// CLayoutInfo overrides
//
//////////////////////////////////////////////////////

// $$ktam: It might be a good idea to implement some kind of CLayoutAry iterator class.
// Most of these overrides iterate the array..

HRESULT
CLayoutAry::OnPropertyChange( DISPID dispid, DWORD dwFlags )
{
    Assert( _aryLE.Size() );

    HRESULT hr = S_OK;
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Tell each layout in the array about the property change  
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            hr = pLayout->OnPropertyChange(dispid, dwFlags);
            Assert( SUCCEEDED(hr) );
        }
    }

    return hr;
}

HRESULT
CLayoutAry::OnExitTree()
{
    Assert( _aryLE.Size() );

    HRESULT hr = S_OK;
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Tell each layout in the array that it's exiting the tree
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        // We deliberately ignore the valid state on the layout's context; since we're
        // exiting the tree, it's OK to let invalid layouts know.
        // TODO (KTam): it shouldn't make a difference either way, maybe be consistent?
        hr = pLayout->OnExitTree();
        Assert( SUCCEEDED(hr) );
    }

    return hr;
}

// Currently all implementations of OnFormatsChange actually only do work
// on their element (not on the layout).  This means that even in a multi-
// layout world, we only want to call on one of the layouts.  It also suggests
// that OnFormatsChange ought to be on CElement rather than CLayout.
HRESULT
CLayoutAry::OnFormatsChange(DWORD dwFlags)
{
    int i = GetFirstValidLayoutIndex();
    if ( _aryLE.Size() )
        return _aryLE[i]->OnFormatsChange(dwFlags);

    return E_FAIL;
}

void
CLayoutAry::Dirty( DWORD grfLayout )
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Tell each layout in the array that it's dirty
    
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            pLayout->Dirty( grfLayout );
        }
    }
}

BOOL
CLayoutAry::IsFlowLayout()
{
    // CLayoutAry's are homogenous - delegate to the first layout in the array
    int i = GetFirstValidLayoutIndex();
    return (   _aryLE.Size()
            && _aryLE[i]->IsFlowLayout() );
}
BOOL
CLayoutAry::IsFlowOrSelectLayout()
{
    // CLayoutAry's are homogenous - delegate to the first layout in the array
    int i = GetFirstValidLayoutIndex();
    return (   _aryLE.Size()
            && _aryLE[i]->IsFlowOrSelectLayout() );
}

// You should set the var pointed by *pnLayoutCookie to 0 to start the iterations
// It will be set to -1 if there are no more layouts or an error occured
CLayout *
CLayoutAry::GetNextLayout(int *pnLayoutCookie)
{
    CLayout * pLayout;

    Assert(pnLayoutCookie);
    int nArySize = Size();

    Assert(*pnLayoutCookie >= 0);
 
    if(*pnLayoutCookie < 0 || *pnLayoutCookie >= nArySize)
    {
        *pnLayoutCookie = -1;
        return NULL;
    }

    do
    {
        pLayout = _aryLE[*pnLayoutCookie];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );

        (*pnLayoutCookie)++;

        if ( pLayout->LayoutContext()->IsValid() )
            return pLayout;
    }
    while(*pnLayoutCookie < nArySize);

    *pnLayoutCookie = -1;

    return NULL;
}


#if DBG
void
CLayoutAry::DumpLayoutInfo( BOOL fDumpLines )
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    WriteHelp(g_f, _T("CLayoutAry: 0x<0x> - <1d> layouts\r\n"), this, (long)nLayouts );

    // Dump each layout
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        pLayout->DumpLayoutInfo( fDumpLines );
    }
}
#endif

int
CLayoutAry::GetFirstValidLayoutIndex()
{
    Assert( _aryLE.Size() );

    int i = 0;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    while ( i < nLayouts )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
            return i;
        ++i;
    }

    AssertSz( FALSE, "Shouldn't have an array that doesn't have a valid layout" );
    return 0;
}


//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsLinkedContentElement
//
//  Synopsis:   Returns true if this is a linkable-content element false otherwise.
//      in IE6M1, only the Layout:rect identity behavior will utilize this 
//      functionality.
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsLinkedContentElement()
{
    // TODO (alexz) this heavily hits perf - up to 2% across the board.
    // This is a tag name comparison performed very often. Even though it is
    // unsuccessfull in most cases and the string comparison itself is fast,
    // it still requires an attr array search to get the tagname.
    // Instead, workout issues why the peer is not there when layout rolls.
    // TODO (ktam) the Tag() check should make us a lot more efficient; 
    // we'll do what Alex suggests if it's still necessary.
#ifdef MULTI_LAYOUT
    // We no longer rely on QI'ing the peer holder for ILayoutRect,
    // because a) the peer holder isn't instantiated quickly enough
    // (ie it doesn't exist at parse time), and b) this is more
    // efficient and just as functional since we don't plan to expose
    // ILayoutRect as a 3rd party interface.

    if (Tag() != ETAG_GENERIC )
        return FALSE;

    return !FormsStringICmp(TagName(), _T("LAYOUTRECT"));
#else
    return FALSE;
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::GetLinkedContentAttr
//
//  Synopsis:  Gets attributes from layout rects.  Assumes that the
//     attribute named by pszAttr is a string; returns S_OK if the
//     attribute exists and its value is a non-empty string, S_FALSE
//     if it exists but its value is an empty string, E_* if any other
//     failure occurs.
//
//-----------------------------------------------------------------------------
HRESULT
CElement::GetLinkedContentAttr( LPCTSTR pszAttr, CVariant *pVarRet /*[out]*/ )
{
    BSTR    bstrAttribute = NULL;
    HRESULT hr = E_FAIL;

    Assert( pszAttr && pVarRet );

    pVarRet->ZeroVariant(); // always zero "out" param.

    // Bail immediately if this isn't a linked content element.
    if (!IsLinkedContentElement())
        goto Cleanup;

    bstrAttribute = SysAllocString( pszAttr );
    if ( !bstrAttribute )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = getAttribute( bstrAttribute, 0, pVarRet );
    // Fail if couldn't get attribute, or if attribute type isn't BSTR.
    if ( FAILED(hr) )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (V_VT(pVarRet) == VT_BSTR)
    {
        // Return S_FALSE if attribute exists but is empty string.
        hr = V_BSTR(pVarRet) ? S_OK : S_FALSE;        
    }
    else if (   V_VT(pVarRet) == VT_DISPATCH
             || V_VT(pVarRet) == VT_UNKNOWN)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

Cleanup:
    if ( bstrAttribute )
    {
        SysFreeString( bstrAttribute );
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::GetNextLinkedContentElem
//
//  Synopsis:   returns the element that this element overflows to, but only if
//      this is a valid linkable element.
//
//-----------------------------------------------------------------------------
CElement *
CElement::GetNextLinkedContentElem()
{
    BSTR          bstrLinkName = NULL;
    CElement    * pElement     = NULL;
    CMarkup     * pMarkup      = NULL;
    CVariant      cvarName;

    if ( GetLinkedContentAttr( _T("nextRect"), &cvarName ) != S_OK )
        goto Cleanup;

    pMarkup = GetMarkup();
    if (!pMarkup)
        goto Cleanup;

    if (FAILED(pMarkup->GetElementByNameOrID((LPTSTR)(V_BSTR(&cvarName)), 
                                                      &pElement)))
    {
        // before we bail it it possible that the "nextRectElement" attribute
        // may have our element.
        cvarName.Clear();
        SysFreeString(bstrLinkName);

        bstrLinkName = SysAllocString(_T("nextRectElement"));
        if (!bstrLinkName)
            goto Cleanup;

        Assert(pElement == NULL);

        if (FAILED(getAttribute(bstrLinkName, 0, &cvarName)))
            goto Cleanup;

        if (V_VT(&cvarName) != VT_DISPATCH)
            goto Cleanup;

        // To get a CElement we need to either QI for the clsid, 
        // this doesn't Addref, so just clear the variant to transfer
        // ownership of the dispatch pointer.
        if (pElement)
            IGNORE_HR(pElement->QueryInterface(CLSID_CElement, (void**) &pElement));
    }

    if (!pElement)
        goto Cleanup;

    // now that we have the element, lets verify that it is indeed linkable
    //---------------------------------------------------------------------
    if (!pElement->IsLinkedContentElement())
    {
        // ERROR, we linked to something that isn't linkable
        pElement = NULL;
    }

Cleanup:
    if (bstrLinkName)
        SysFreeString(bstrLinkName);

    return (pElement);
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::ConnectLinkedContentElems
//
//  Synopsis:   Connects a "new" layout rect element (that doesn't belong to a
//      viewchain) to an existing layout rect (the "src" elem), hooking the
//      new element up to the viewchain of the src elem.
//
//-----------------------------------------------------------------------------
HRESULT
CElement::ConnectLinkedContentElems( CElement *pSrcElem, CElement *pNewElem )
{
    Assert( pSrcElem && pNewElem );
    Assert( pSrcElem->IsLinkedContentElement() && pNewElem->IsLinkedContentElement() );

    // NOTE (KTam): Layout iterators here, to handle layout rect elements having
    // multiple layouts?
    CLayout  * pSrcLayout = pSrcElem->EnsureLayoutInDefaultContext();
    CLayout  * pNewLayout = pNewElem->EnsureLayoutInDefaultContext();
    AssertSz( pSrcLayout, "Source element for linking must have layout" );
    AssertSz( pSrcLayout->ViewChain(), "Source element for linking must have view chain" );
    AssertSz( pNewLayout, "New element for linking must have layout" );
    AssertSz( (!pNewLayout->ViewChain() || (pNewLayout->ViewChain() == pSrcLayout->ViewChain()) ),
              "New elem should either not already have a view chain, or its viewchain should match what we're about to give it" );

    pNewLayout->SetViewChain(pSrcLayout->ViewChain(),
                             pSrcLayout->DefinedLayoutContext());

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::UpdateLinkedContentChain()
//
//  Synopsis:   Called when a link chain is invalid this function makes sure that
//      all of the slave markup pointers for the genericElements and viewChains 
//      for the associated CContainerLayouts are upto date.
//
//   Note : for future usage, this function assumes that when a chain is invalidated,
//      (e.g. the contentSrc property of the head container is changed), then the
//      viewChain pointers for the whole list will have been cleared.  If they are
//      marked invalid instead then this function will need to be updated.
//  
// TODO (KTam): Need to find/notify other chains (redundant displays).  So far
// we still only have one master, so notifications from the content tree will be
// directed to the single master element -- perhaps it needs to be able to know
// about all chains?
//
//-----------------------------------------------------------------------------

HRESULT
CElement::UpdateLinkedContentChain()
{
    CElement *  pNextElem;
    CElement *  pPrevElem;
    // Assert that this fn is only called on heads of chains
    WHEN_DBG( CVariant cvarAttr );
    AssertSz( GetLinkedContentAttr( _T("contentSrc"), &cvarAttr ) == S_OK, "UpdateLinkedContentChain() called for elem w/o contentSrc" );
    AssertSz( HasSlavePtr(), "Head of chain must have slave by now" );

    // Remeasure the head
    RemeasureElement(NFLAGS_FORCE);

    // Iterate through the chain, hooking up elements to the chain/setting slave
    // ptrs as needed, and then ask each element of the chain to remeasure.
    pPrevElem = this;
    pNextElem = GetNextLinkedContentElem();

    while ( pNextElem )
    {
        ConnectLinkedContentElems( pPrevElem, pNextElem );

        // Remeasure this link in the chain by forcing container to recalculate its size.
        pNextElem->RemeasureElement(NFLAGS_FORCE);

        pPrevElem = pNextElem;
        pNextElem = pNextElem->GetNextLinkedContentElem();
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member : Fire_onlayoutcomplete
//
// Synopsis : event firing helper, this is called asynch from the layout 
//      process.  it is responsible for creating the eventparam object, and
//      setting up the properties on it.
//
//--------------------------------------------------------------------
void
CElement::Fire_onlayoutcomplete(BOOL fMoreContent, DWORD dwExtra)
{
    Assert(dwExtra == 0 || fMoreContent);

    EVENTPARAM param(Doc(), this, NULL, FALSE, TRUE);

    param._pNode = GetFirstBranch();
    param._fOverflow = fMoreContent;
    param._overflowType = (OVERFLOWTYPE)dwExtra;
    param.SetType(_T("layoutcomplete"));

    FireEvent( &s_propdescCElementonlayoutcomplete, FALSE );
}

#if DBG==1
void
CElement::DumpLayouts()
{
    CLayoutInfo *pLI = NULL;

    if ( CurrentlyHasAnyLayout() )
        pLI = GetLayoutInfo();

    if ( pLI )
        pLI->DumpLayoutInfo( TRUE );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\fframe.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  Contents:   Fake frame implementation.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

inline CFormInPlace * CFakeUIWindow::InPlace()
{ 
    return Doc()->InPlace(); 
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::AddRef
//
//  Synopsis:   Per IUnknown
//
//-------------------------------------------------------------------------

ULONG CFakeUIWindow::AddRef()
{
    return Doc()->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::Release
//
//  Synopsis:   Per IUnknown
//
//-------------------------------------------------------------------------

ULONG CFakeUIWindow::Release()
{
    return Doc()->SubRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow)
    {
        *ppv = (IOleInPlaceUIWindow *)this;
    }
    else if (this == &Doc()->_FakeInPlaceFrame &&
        iid == IID_IOleInPlaceFrame)
    {
        *ppv = (IOleInPlaceFrame *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::GetWindow, IOleWindow
//
//  Synopsis:   Get HWND
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::GetWindow(HWND *phwnd)
{
    RRETURN(THR(RealInPlaceUIWindow()->GetWindow(phwnd)));
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::ContextSensitiveHelp, IOleWindow
//
//  Synopsis:   Controls enabling of context sensitive help.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(THR(RealInPlaceUIWindow()->ContextSensitiveHelp(fEnterMode)));
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::GetBorderSpace, IOleInplaceUIWindow
//
//  Synopsis:   Get frame size.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::GetBorder(LPOLERECT lprectBorder)
{
    RRETURN(THR(RealInPlaceUIWindow()->GetBorder(lprectBorder)));
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::RequestBorderSpace, IOleInplaceUIWindow
//
//  Synopsis:   Get border space for tools.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    RRETURN(THR(RealInPlaceUIWindow()->RequestBorderSpace(pborderwidths)));
}


//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetBorderSpace, IOleInplaceUIWindow
//
//  Synopsis:   Get border space for tools.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    HRESULT hr = S_OK;

#ifndef NO_OLEUI
    if (pborderwidths)
    {
        Doc()->InPlace()->_fForwardSetBorderSpace = TRUE;
        Doc()->RemoveUI();
        hr = THR(RealInPlaceUIWindow()->SetBorderSpace(pborderwidths));
    }
    else
    {
        if (Doc()->InPlace()->_fForwardSetBorderSpace)
        {
            hr = THR(RealInPlaceUIWindow()->SetBorderSpace(pborderwidths));
            if (hr)
                RRETURN(hr);
            Doc()->InPlace()->_fForwardSetBorderSpace = FALSE;
        }
        
        if (Doc()->InPlace()->_fUIDown &&
            !Doc()->InPlace()->_fChildActivating &&
            !Doc()->InPlace()->_fDeactivating &&
            Doc()->State() >= OS_UIACTIVE)
        {
            hr = THR(Doc()->InstallUI(FALSE));
        }
    }
#endif // NO_OLEUI

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetActiveObject, IOleInplaceUIWindow
//
//  Synopsis:   Notify currently active object.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    IOleInPlaceUIWindow *   p = RealInPlaceUIWindow();
    HRESULT                 hr = S_OK;

    //
    // If an ocx is not going active and another ocx calls SetActiveObject
    // with NULL and we happen to be UI-Active, tell frame that we're the
    // active object instead.
    //
    
    if (p)
    {
        if (!pActiveObject && 
            !Doc()->InPlace()->_fChildActivating &&
            !Doc()->InPlace()->_fDeactivating &&
            Doc()->State() >= OS_UIACTIVE)
        {
            hr = THR(Doc()->SetActiveObject());
        }
        else
        {
            hr = THR(p->SetActiveObject(pActiveObject, pszObjName));
        }
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::InsertMenus, IOleInPlaceFrame
//
//  Synopsis:   Allow container to insert menus.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
#ifdef NO_OLEUI
	RRETURN(S_OK);
#else
    Doc()->RemoveUI();
    RRETURN(THR(InPlace()->_pFrame->InsertMenus(hmenuShared, lpMenuWidths)));
#endif // NO_OLEUI
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetMenu, IOleInPlaceFrame
//
//  Synopsis:   Add composite menu to window frame.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    HRESULT             hr = S_OK;

#ifndef NO_OLEUI
    if (InPlace() && InPlace()->_pFrame)
    {
        if (hmenuShared && holemenu)
        {
            Doc()->InPlace()->_fForwardSetMenu = TRUE;
            Doc()->RemoveUI();
            hr = THR(InPlace()->_pFrame->SetMenu(hmenuShared, holemenu, hwndActiveObject));
        }
        else
        {
            if (Doc()->InPlace()->_fForwardSetMenu)
            {
                hr = THR(InPlace()->_pFrame->SetMenu(
                        NULL, 
                        NULL, 
                        hwndActiveObject));
                if (hr)
                    RRETURN(hr);
                Doc()->InPlace()->_fForwardSetMenu = FALSE;
            }
            
            if (Doc()->InPlace()->_fUIDown &&
                !Doc()->InPlace()->_fChildActivating &&
                !Doc()->InPlace()->_fDeactivating &&
                Doc()->State() >= OS_UIACTIVE)
            {
                hr = THR(Doc()->InstallUI(FALSE));
            }
        }
    }
#endif // NO_OLEUI
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetMenu, IOleInPlaceFrame
//
//  Synopsis:   Remove container's menus.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::RemoveMenus(HMENU hmenuShared)
{
    HRESULT hr;

    if (hmenuShared && InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->RemoveMenus(hmenuShared));
    }
    else
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetStatusText, IOleInPlaceFrame
//
//  Synopsis:   Set and display status text.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetStatusText(LPCOLESTR pszStatusText)
{
    HRESULT hr;
    
    if (InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->SetStatusText(pszStatusText));
    }
    else
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::EnableModeless, IOleInPlaceFrame
//
//  Synopsis:   Enable / Disable modeless dialogs.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::EnableModeless(BOOL fEnable)
{
    HRESULT hr;
    
    if (InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->EnableModeless(fEnable));
    }
    else
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::TranslateAccelerator, IOleInPlaceFrame
//
//  Synopsis:   Translate keystrokes.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    HRESULT hr;

    if (InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->TranslateAccelerator(lpmsg, wID));
    }
    else
    {
        hr = S_FALSE;
    }
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CFakeInPlaceFrame::RealInPlaceUIWindow, CFakeUIWindow
//
//  Synopsis:   Return the true frame.
//
//-------------------------------------------------------------------------

IOleInPlaceUIWindow *
CFakeInPlaceFrame::RealInPlaceUIWindow()
{
    CDoc *pDoc = Doc();
    return pDoc->InPlace() ? pDoc->InPlace()->_pFrame : NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeDocUIWindow::RealInPlaceUIWindow, CFakeUIWindow
//
//  Synopsis:   Return the true document window.
//
//-------------------------------------------------------------------------

IOleInPlaceUIWindow *
CFakeDocUIWindow::RealInPlaceUIWindow()
{
    return Doc()->InPlace()->_pDoc;
}

CDoc * CFakeDocUIWindow::Doc()
{
    return CONTAINING_RECORD(this, CDoc, _FakeDocUIWindow);
}   

CDoc * CFakeInPlaceFrame::Doc()
{
    return CONTAINING_RECORD(this, CDoc, _FakeInPlaceFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\formcoll.cxx ===
//+------------------------------------------------------------------------
//
//  File:       FORMCOLL.CXX
//
//  Contents:   Implementation of collection for CDoc
//
//  Classes:    (part of) CDoc
//              (part of) CMarkup for the Collection Cache (tomfakes)
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HEADELEMS_HXX_
#define X_HEADELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

DeclareTag(tagCollectionsAddToCollections, "Collections", "trace CMarkup::AddToCollections")

#define USE_TREE_FOR_ALL_COLLECTION 1

MtDefine(CDocRecomputeTreeCache_arySitesOriginal_pv, Locals, "CDoc::RecomputeTreeCache arySitesOriginal::_pv")
MtDefine(CDocRecomputeTreeCache_arySitesDetach_pv, Locals, "CDoc::RecomputeTreeCache arySitesDetach::_pv")
MtDefine(CDocRecomputeTreeCache_arySitesDormancy_pv, Locals, "CDoc::RecomputeTreeCAche arySitesDormancy::_pv")
MtDefine(CDocOnElementEnter_pTabs, Locals, "CDoc::OnElementEnter::_pTabs")
MtDefine(BldElementCol, PerfPigs, "Build CDoc::ELEMENT_COLLECTION")
MtDefine(BldFormsCol, PerfPigs, "Build CDoc::FORMS_COLLECTION")
MtDefine(BldAnchorsCol, PerfPigs, "Build CDoc::ANCHORS_COLLECTION")
MtDefine(BldLinksCol, PerfPigs, "Build CDoc::LINKS_COLLECTION")
MtDefine(BldImagesCol, PerfPigs, "Build CDoc::IMAGES_COLLECTION")
MtDefine(BldAppletsCol, PerfPigs, "Build CDoc::APPLETS_COLLECTION")
MtDefine(BldScriptsCol, PerfPigs, "Build CDoc::SCRIPTS_COLLECTION")
MtDefine(BldMapsCol, PerfPigs, "Build CDoc::MAPS_COLLECTION")
MtDefine(BldWindowCol, PerfPigs, "Build CDoc::WINDOW_COLLECTION")
MtDefine(BldEmbedsCol, PerfPigs, "Build CDoc::EMBEDS_COLLECTION")
MtDefine(BldRegionCol, PerfPigs, "Build CDoc::REGION_COLLECTION")
MtDefine(BldLabelCol, PerfPigs, "Build CDoc::LABEL_COLLECTION")
MtDefine(BldNavDocCol, PerfPigs, "Build CDoc::NAVDOCUMENT_COLLECTION")
MtDefine(BldFramesCol, PerfPigs, "Build CDoc::FRAMES_COLLECTION")
MtDefine(BldOtherCol, PerfPigs, "Build CDoc::OTHER_COLLECTION (Unknown)")
MtDefine(CAllCollectionCacheItem, CDoc, "CDoc::CAllCollectionCacheItem")

//+----------------------------------------------------------------------------
//
// Member:      RecomputeTreeCache
//
// Synopsis:    This member invalidates any cached information in the Doc and
//              causes a monster walk to take place to recalculate the cached
//              information.
//
//+----------------------------------------------------------------------------

class CTable;
class CTableRow;


class CCollectionBuildContext
{
public:
    CDoc *_pDoc;
    // Collection State
    long _lCollection;
    BOOL _fNeedNameID;
    BOOL _fNeedForm;

    CCollectionBuildContext (CDoc *pDoc)
    {
        _pDoc = pDoc;
        _lCollection = 0;
        _fNeedNameID = FALSE;
        _fNeedForm = FALSE;
    };
};

//+----------------------------------------------------------------------------
//
// Member:      EnsureCollectionCache
//
// Synopsis:    Ensures that the collection cache is built
//              NOTE: Ensures the _cache_, not the _collections_.
//
//+----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureCollectionCache ( long lCollectionIndex )
{
    HRESULT hr;

    hr = THR(InitCollections());
    if (hr)
        goto Cleanup;

    hr = THR( CollectionCache()->EnsureAry( lCollectionIndex ) );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   rebuild the collections based on the current state of the tree
//
//-----------------------------------------------------------------------------



HRESULT
CMarkup::EnsureCollections( long lIndex, long * plCollectionVersion )
{
    HRESULT hr = S_OK;
    CCollectionBuildContext collectionWalker ( _pDoc );
    long l,lSize;
    CElement *pElemCurrent;
    CCollectionCache *pCollectionCache;

#ifdef PERFMETER
    static PERFMETERTAG s_mpColMtr[] = { Mt(BldElementCol), Mt(BldFormsCol), Mt(BldAnchorsCol), Mt(BldLinksCol), Mt(BldImagesCol),
        Mt(BldAppletsCol), Mt(BldScriptsCol), Mt(BldMapsCol), Mt(BldWindowCol), Mt(BldEmbedsCol), Mt(BldRegionCol),
        Mt(BldLabelCol), Mt(BldNavDocCol), Mt(BldFramesCol) };
#endif

    pCollectionCache = CollectionCache();
    if ( !pCollectionCache )
        goto Cleanup;

    // Optimize the use of the region collection. The doc flag is set by
    // the CSS code whenever theres a position: attribute on an element in the doc
    // This is a temporary Beta1 Hack to avoid building the regions collection
    if(lIndex == REGION_COLLECTION && !_pDoc->_fRegionCollection)  //$$tomfakes - move this flag to CMarkup?
    {
        pCollectionCache->ResetAry( REGION_COLLECTION ); // To be safe
        goto Cleanup;
    }


    if(lIndex == ELEMENT_COLLECTION)
    {
        goto Update; // All collection is always up to date, update the version no & bail out
    }
	else if ( lIndex == REGION_COLLECTION )
    {
        // We ignore the collection _fIsValid flag for the REGION_COLLECTION
		// because it is unaffected by element name changes
        if (*plCollectionVersion == GetMarkupTreeVersion())
            goto Cleanup;
    }
    else
    {
        // Collections that are specificaly invalidated
        if (pCollectionCache->IsValidItem(lIndex))
		{
			// Doesn't change collection version, collections based on this one don't get rebuilt
            goto Cleanup; 
		}
    }

    MtAdd(lIndex < ARRAY_SIZE(s_mpColMtr) ? s_mpColMtr[lIndex] : Mt(BldOtherCol), +1, 0);

    collectionWalker._lCollection = lIndex;

    // Set flag to indicate whether or not we need to go get the name/ID of
    // elements during the walk
    if ( lIndex == NAVDOCUMENT_COLLECTION ||
        lIndex == ANCHORS_COLLECTION ||
		lIndex == WINDOW_COLLECTION )
    {
        collectionWalker._fNeedNameID = TRUE;
    }
    // Set flag to indicate whether or not we need to go get the containing form of
    // elements during the walk
    if ( lIndex == WINDOW_COLLECTION || lIndex == NAVDOCUMENT_COLLECTION ||
        lIndex == FORMS_COLLECTION || lIndex == FRAMES_COLLECTION )
    {
        collectionWalker._fNeedForm = TRUE;
    }

    //
    // Here we blow away any cached information which is stored in the doc.
    // Usually elements, themselves, will blow away their own cached info
    // when they are first visited, but because the doc is not an element,
    // it will not be visited, and must blow away the cached info before we
    // start the walk.
    //


    // every fixed collection is based on the all collection
    if ( lIndex != ELEMENT_COLLECTION )
    {
        pCollectionCache->ResetAry( lIndex );
    }

    // Otherwise all collection is up to date, so use it because its faster
    lSize = pCollectionCache->SizeAry ( ELEMENT_COLLECTION );
    for ( l = 0 ; l < lSize ; l++ )
    {
       hr = THR(pCollectionCache->GetIntoAry(
                ELEMENT_COLLECTION,
                l,
                &pElemCurrent));
        if ( hr )
            goto Cleanup;
        hr = THR (AddToCollections ( pElemCurrent, &collectionWalker ));
        if ( hr )
            goto Cleanup;
    }

Update:
    // Update the version on the collection
    if ( lIndex == REGION_COLLECTION || lIndex == ELEMENT_COLLECTION)
    {
        // Collection derived from tree
        *plCollectionVersion = GetMarkupTreeVersion();
    }
	else
	{
		(*plCollectionVersion)++;
	}

	pCollectionCache->ValidateItem ( lIndex );

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  member : InFormCollection
//
//  Synopsis : helper function for determining if an element will appear in a
//     form element's collecion of if it should be scoped to the document's all
//     collection. this is also used by buildTypeInfo for hooking up VBSCRIPT
//
//----------------------------------------------------------------------------

CTreeNode *
CMarkup::InFormCollection(CTreeNode * pNode)
{
    CTreeNode * pNodeParentForm = NULL;

    if (!pNode)
        goto Cleanup;

    // NOTE: Forms are now promoted to the window, this is because the AddNamedItem
    //       no longer adds the form and we need to have access to the form for
    //       <SCRIPT FOR EVENT>
    switch (pNode->TagType())
    {
    case ETAG_INPUT:
    case ETAG_FIELDSET:
    case ETAG_SELECT:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_TEXTAREA:
    case ETAG_IMG:
    case ETAG_BUTTON:
    case ETAG_OBJECT:
    case ETAG_EMBED:
        // COMMENT rgardner - A good optimization here would be to have the tree walker
        // retain the last scoping form element & pass in the pointer
        pNodeParentForm = pNode->SearchBranchToRootForTag( ETAG_FORM );
        break;
    }

Cleanup:
    return pNodeParentForm;
}

//+------------------------------------------------------------------------
//
//  Member:     AddToCollections
//
//  Synopsis:   add this element to the collection cache
//
//  lNumNestedTables The number of TABLE tags we're nested underneath - speeds
//                  up IMG tag handling
//-------------------------------------------------------------------------

//
// DEVNOTE rgardner
// This code is tighly couples with CElement::OnEnterExitInvalidateCollections and needs
// to be kept in sync with any changes in that function
//

HRESULT
CMarkup::AddToCollections ( CElement *pElement, CCollectionBuildContext *pMonsterWalk )
{
    int         i;
    HRESULT     hr = S_OK;
    CTreeNode * pNodeForm = NULL;
    LPCTSTR pszName = NULL;
    LPCTSTR pszID = NULL;
    CCollectionCache *pCollectionCache;

#if DBG == 1
    TraceTag((
        tagCollectionsAddToCollections,
        "CMarkup::AddToCollections, tag: %ls, tag id: %ls, collection: %X",
        pElement->TagName(), STRVAL(pElement->GetAAid()),
        pMonsterWalk->_lCollection));
#endif


    // Note here that the outer code has mapped the FRAMES_COLLECTION onto the same Index as
    // the WINDOW_COLLECTION, so both collections get built
    if (!pElement)
        goto Cleanup;

    // Names & ID's are needed by :
    // NAVDOCUMENT_COLLECTION | ANCHORS_COLLECTION
    // This flag is initialized in EnsureCollections()

    // _fIsNamed is always up to date
    if ( pMonsterWalk->_fNeedNameID && pElement->IsNamed() )
    {
        pElement->FindString ( STDPROPID_XOBJ_NAME, &pszName );
        pElement->FindString ( DISPID_CElement_id, &pszID );
    }

    //
    // Retrieve the Collection Cache
    //
    pCollectionCache = CollectionCache();

    //
    // Next check to see if element belongs in the window collection
    // Only elements which don't lie inside of forms (and are not forms) belong in here.
    // Things which are not inserted into the form's element collection
    // are also put into the window collection.  E.g. anchors.
    //
    if ( pMonsterWalk->_fNeedForm )
    {
        pNodeForm = InFormCollection(pElement->GetFirstBranch());
    }

    if (pMonsterWalk->_lCollection == WINDOW_COLLECTION  && !pNodeForm && pElement->IsNamed())
    {
        LPCTSTR pszUniqueName = NULL;

        if ( !pszName && !pszID )
            pElement->FindString ( DISPID_CElement_uniqueName, &pszUniqueName );

        if ( pszName || pszID || pszUniqueName )
        {
            if (!pElement->IsOverflowFrame())
            {
                hr = THR(pCollectionCache->SetIntoAry(WINDOW_COLLECTION, pElement));
                if (hr)
                    goto Cleanup;
            }
        }
    }

    // See if its a FORM within a FORM, Nav doesn't promote names of nested forms to the doc
    if ( pMonsterWalk->_fNeedForm && ETAG_FORM == pElement->Tag()  )
    {
        pNodeForm = pElement->GetFirstBranch()->SearchBranchToRootForTag( ETAG_FORM );
        if ( SameScope(pNodeForm, pElement->GetFirstBranch()) )
            pNodeForm = NULL;
    }

    // We use the NAVDOCUMENT_COLLECTION to resolve names on the document object
    // If you have a name you get promoted ala Netscape
    // If you have an ID you get promoted, regardless
    // If you have both, you get netscapes rules
    switch (pElement->TagType())
    {
    case ETAG_FORM:
        if (pNodeForm) // only count images, forms not in a form
            break;
        // fallthrough


    case ETAG_IMG:
    case ETAG_EMBED:
    case ETAG_IFRAME:
    case ETAG_APPLET:
    case ETAG_OBJECT:
        if ( pMonsterWalk->_lCollection == NAVDOCUMENT_COLLECTION )
        {
            if ( pszName )
            {
                hr = THR(pCollectionCache->SetIntoAry(NAVDOCUMENT_COLLECTION, pElement));
                if (hr)
                    goto Cleanup;
            }
            // IE30 compatability OBJECTs/APPLETs with IDs are prmoted to the document
            else if ( ( pElement->Tag() == ETAG_APPLET ||
                pElement->Tag() == ETAG_OBJECT ) && pszID )
            {
                hr = THR(pCollectionCache->SetIntoAry(NAVDOCUMENT_COLLECTION, pElement));
                if (hr)
                    goto Cleanup;
            }
        }
        break;
    }

    //
    // See if this element is a region, which means its "container" attribute
    // is "moveable", "in-flow", or "positioned". If so then put it in the
    // region collection, which is used to ensure proper rendering. The BODY
    // should not be added to the region collection.
    //
    if (pMonsterWalk->_lCollection == REGION_COLLECTION &&
        pElement->Tag() != ETAG_BODY &&
        !pElement->IsPositionStatic())
    {
        hr = THR(pCollectionCache->SetIntoAry(REGION_COLLECTION, pElement));
        if (hr)
            goto Cleanup;
    }

    switch(pElement->TagType())
    {
    case ETAG_LABEL:
        i = LABEL_COLLECTION;
        break;

    case ETAG_FRAME:
    case ETAG_IFRAME:
        if (pElement->_fSynthesized)
            goto Cleanup;

        if ( pMonsterWalk->_lCollection == FRAMES_COLLECTION &&
             !pElement->IsOverflowFrame())
        {
            hr = THR(pCollectionCache->SetIntoAry(FRAMES_COLLECTION, pElement));
        }
        goto Cleanup;

    case ETAG_FORM:
        if ( pNodeForm )
        {
            // nested forms don't go into the forms collection
            goto Cleanup;
        }
        i = FORMS_COLLECTION;
        break;

    case ETAG_AREA:
        if ( pMonsterWalk->_lCollection == LINKS_COLLECTION )
        {
            LPCTSTR lpHRef = DYNCAST(CAreaElement, pElement)->GetAAhref();

            // If the AREA element has an href attribute even HREF="", add it to the
            // links' collection
            if( !lpHRef )
            {
                goto Cleanup;
            }
        }
        i = LINKS_COLLECTION;
        break;

    case ETAG_A:
        // If the A element has an non empty name/id attribute, add it to
        // the anchors' collection
        if ( pMonsterWalk->_lCollection == ANCHORS_COLLECTION )
        {
            LPCTSTR lpAnchorName = pszName;
            if (!lpAnchorName)
            {
                lpAnchorName = pszID;
            }
            if ( lpAnchorName && lpAnchorName[0] )
            {
                hr = THR(pCollectionCache->SetIntoAry(ANCHORS_COLLECTION, pElement));
                if ( hr )
                    goto Cleanup;
            }
        }

        if ( pMonsterWalk->_lCollection == LINKS_COLLECTION )
        {
            LPCTSTR lpHRef = DYNCAST(CAnchorElement, pElement)->GetAAhref();

            // If the A element has an href attribute even HREF="", add it to the
            // links' collection
            if( lpHRef )
            {
                hr = THR(pCollectionCache->SetIntoAry(LINKS_COLLECTION, pElement));
            }
        }
        goto Cleanup;

    case ETAG_IMG:
        // The document.images collection in Nav has a quirky bug, for every TABLE
        // above one Nav adds 2^n IMG elements.
        i = IMAGES_COLLECTION;
        break;

    case ETAG_EMBED:
        i = EMBEDS_COLLECTION;
        break;

    case ETAG_OBJECT:
    case ETAG_APPLET:
        i = APPLETS_COLLECTION;
        break;

    case ETAG_SCRIPT:
        i = SCRIPTS_COLLECTION;
        break;

    case ETAG_MAP:
        i = MAPS_COLLECTION;
        break;

    default:
        goto Cleanup;
    }

    if ( i == pMonsterWalk->_lCollection )
    {
        hr = THR(pCollectionCache->SetIntoAry(i, pElement));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     GetCollection
//
//  Synopsis:   return collection based on index in the collection cache
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetCollection(int iIndex, IHTMLElementCollection ** ppdisp)
{
    Assert((iIndex >= 0) && (iIndex < NUM_DOCUMENT_COLLECTIONS));

    HRESULT hr;

    if (!ppdisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppdisp = NULL;

    hr = EnsureCollectionCache(iIndex);
    if ( hr )
        goto Cleanup;

    hr = THR(CollectionCache()->GetDisp(iIndex, (IDispatch **)ppdisp));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     GetElementByNameOrID
//
//  Synopsis:   look up an Element by its Name or ID
//
//  Returns:    S_OK, if it found the element.  *ppElement is set
//              S_FALSE, if multiple elements w/ name were found.
//                  *ppElement is set to the first element in list.
//              Other errors.
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetElementByNameOrID(LPCTSTR szName, CElement **ppElement)
{
    HRESULT hr;
    CElement * pElemTemp;

    hr = THR(EnsureCollectionCache(ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(CollectionCache()->GetIntoAry(
        ELEMENT_COLLECTION,
        szName,
        FALSE,
        &pElemTemp));
    *ppElement = pElemTemp;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     GetDispByNameOrID
//
//  Synopsis:   Retrieve an IDispatch by its Name or ID
//
//  Returns:    An IDispatch* to an element or a collection of elements.
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetDispByNameOrID(LPTSTR szName, IDispatch **ppDisp, BOOL fAlwaysCollection)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache(ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(CollectionCache()->GetDisp(
        ELEMENT_COLLECTION,
        szName,
        CacheType_Named,
        ppDisp,
        FALSE,  // Case Insensitive
        NULL,
        fAlwaysCollection)); // Always return a collection (even if empty, or has 1 elem)

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::OnElementExit
//
//  Synopsis:   Remove all references the doc may have to an element
//              that is exiting the tree
//
//-------------------------------------------------------------------------

HRESULT
CDoc::OnElementExit(CElement *pElement, DWORD dwExitFlags )
{  
    CAryFocusItem   * paryFocusItem;      
    CElement        * pMasterFocusElem = _pElemCurrent;
    long              i;

    if (_fVID && !_fOnControlInfoChangedPosted)
    {
        _fOnControlInfoChangedPosted = TRUE;
        IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CDoc, OnControlInfoChanged, oncontrolinfochanged), 0, FALSE, "CDoc::OnControlInfoChanged"));
    }

    if (_pMenuObject == pElement)
    {
        _pMenuObject = NULL;
    }

    //
    // marka - find the Element that will be current next - via adjusting the edit context
    // fire on Before Active Elemnet Change. If it's ok - do a SetEditContext on that elemnet,
    // and set _pElemCurrent to it. 
    //
    // Otherwise if FireOnBeforeActiveElement fails - 
    // we make the Body the current element, and call SetEditCOntext on that.
    //

    // mihaii - If pElement is the master for a slave markup that contains _pElemCurrent 
    // we also need to adjust the currency - pMasterFocusNode is the master parent for _pElemCurrent

    if (_pElemCurrent)
    {
        CMarkup   * pMarkup          =  pElement->GetMarkup();
        CTreeNode * pMasterFocusNode = _pElemCurrent->GetFirstBranch();  

        pMasterFocusNode = pMasterFocusNode->GetNodeInMarkup(pMarkup);
        if (pMasterFocusNode)    
            pMasterFocusElem = pMasterFocusNode->Element();
    }

    if (pElement == pMasterFocusElem)
    {
        if( dwExitFlags & EXITTREE_DESTROY )
        {
            // TODO: (jbeda) is this right?  What else do we have to do on markup destroy?
            _pElemCurrent = _pElementDefault;

            if (_pWindowPrimary)
                _pElemCurrent = PrimaryRoot();
        }
        else
        {        
            CTreeNode * pNodeSiteParent = pElement->GetFirstBranch()->GetUpdatedParentLayoutNode();
            if ( pNodeSiteParent )
            {
                _pElemCurrent = pNodeSiteParent->Element();
            }
            else
            {
                _pElemCurrent = pElement->GetMarkup()->Root();
                   
                // if it's the top element, don't defer to itself
            
                if (_pElemCurrent == pElement)
                {
                    if (_pWindowPrimary)
                        _pElemCurrent = PrimaryRoot();
                    else                    
                        _pElemCurrent = _pElementDefault;
                }
            }            

            if ( _pElemCurrent->IsEditable( FALSE ) && _pElemCurrent->_etag != ETAG_ROOT )
            {
                //
                // An editable element has just become current.
                // We tell the mshtmled.dll about this change in editing "context"
                //

                if (_pCaret)
                {
                    _pCaret->Show( FALSE );
                }
            }
            
            GWKillMethodCall(pElement->GetMarkup()->Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);
        }
    }
    else
    {
        Assert(pElement != _pElemCurrent);
    }

    // Make sure pElement site pointer is not cached by the document, which
    // can happen if we are in the middle of a drag-drop operation
    if (_pDragDropTargetInfo)
    {
        if (pElement == _pDragDropTargetInfo->_pElementTarget)
        {
            _pDragDropTargetInfo->_pElementTarget = NULL;
            _pDragDropTargetInfo->_pElementHit = NULL;
            _pDragDropTargetInfo->_pDispScroller = NULL;
        }
    }

    // Release capture if it owns it
    pElement->TakeCapture(FALSE);

    if (_pNodeLastMouseOver)
    {
        ClearCachedNodeOnElementExit(&_pNodeLastMouseOver, pElement);
    }
    if (_pNodeGotButtonDown)
    {
        ClearCachedNodeOnElementExit(&_pNodeGotButtonDown, pElement);
    }

    // Reset _pElemUIActive if necessary
    if (_pElemUIActive == pElement)
    {
        // TODO (MohanB) Need to call _pElemUIActive->YieldUI() here ?

        _pElemUIActive = NULL;
        if (_pInPlace && !_pInPlace->_fDeactivating && _pElemUIActive != pElement->GetMarkup()->Root())
        {
            IGNORE_HR(pElement->GetMarkup()->Root()->BecomeUIActive());
        }
    }

    //
    // Remove all traces of pElement from the focus item array
    // and accessKey array.    
    //
    
    // NOTE: this could be N^2 on shutdown
    paryFocusItem = pElement->GetMarkup()->GetFocusItems(FALSE);
    if (paryFocusItem) 
    {
        for (i = 0; i < paryFocusItem->Size(); )
        {
            if ((*paryFocusItem)[i].pElement == pElement)
            {
                paryFocusItem->Delete(i);
            }
            else
            {
                i++;
            }
        }
    }
    
    return S_OK;
}

BOOL IsAncestorMaster(CElement * pElem1, CTreeNode * pNode2);

void
CDoc::ClearCachedNodeOnElementExit(CTreeNode ** ppNodeToTest, CElement * pElement)
{
    Assert(pElement && ppNodeToTest && *ppNodeToTest);

    CTreeNode * pNode = *ppNodeToTest;

    if (SameScope(pNode, pElement) || IsAncestorMaster(pElement, pNode))
    {
        *ppNodeToTest = NULL;
        pNode->NodeRelease();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CMarkup::InsertFocusArrayItem
//
//  Synopsis:   Insert CElement with tabindex defined into the focusItems array
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::InsertFocusArrayItem(CElement * pElement)
{
    HRESULT             hr = S_OK;
    long                lTabIndex  = pElement->GetAAtabIndex();
    long                c;
    long *              pTabs = NULL;
    long *              pTabsSet;
    FOCUS_ITEM          focusitem;
    long                i;
    long                j;
    CAryFocusItem     * paryFocusItem = GetFocusItems(TRUE);
    
    Assert (paryFocusItem);

    //
    // The tabIndex attribute can have three values:
    //
    //      < 0     Does not participate in focus
    //     == 0     Tabindex as per source order
    //      > 0     Tabindex is the set tabindex
    //
    // Precedence is that given tab indices go first, then the elements
    // which don't have one assigned.  If not given a tab index, treat the
    // element same as tabIndex < 0 for those elements which don't have a
    // layout associated with them (e.g. <P>, <SPAN>).  Those that do
    // have a layout (e.g. <INPUT>, <BUTTON>) will be treated as tabindex == 0
    //

    //
    // Figure out if this element has subdivisions.  If so, then we need
    // multiple entries for this guy.
    //

    //
    // Areas and maps don't belong in here.
    //

    if (pElement->Tag() == ETAG_AREA || pElement->Tag() == ETAG_MAP)
        goto Cleanup;

    hr = THR(pElement->GetSubDivisionCount(&c));
    if (hr)
        goto Cleanup;

    // Subdivisions can have their own tabIndices. Therefore, if an element
    // has any subdivisions, the element's own tabIndex is ignored.
    if ( !c && lTabIndex <= 0 )
        goto Cleanup;

    //
    // Find the location in the focus item array to insert this element.
    //

    focusitem.pElement = pElement;
    if (c)
    {
        pTabs = new long[c];
        if (!pTabs)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pElement->GetSubDivisionTabs(pTabs, c));
        if (hr)
            goto Cleanup;

        pTabsSet = pTabs;
    }
    else
    {
        Assert(lTabIndex > 0);
        pTabsSet = &lTabIndex;
        c = 1;
    }

    hr = THR(paryFocusItem->EnsureSize(paryFocusItem->Size() + c));
    if (hr)
        goto Cleanup;

    for (i = 0; i < c; i++)
    {
        //
        // This is here because subdivisions can also be set to have
        // either a negative tabindex or zero, which means they're in source
        // order.
        //

        if (pTabsSet[i] <= 0)
            continue;

        focusitem.lSubDivision = i;
        focusitem.lTabIndex = pTabsSet[i];

        //
        // Find correct location in focusItems array to insert.
        //

        for (j = 0; j < paryFocusItem->Size(); j++)
        {
            if ((*paryFocusItem)[j].lTabIndex > focusitem.lTabIndex ||
                (*paryFocusItem)[j].pElement->GetSourceIndex() >
                    focusitem.pElement->GetSourceIndex())
                break;
        }

        Verify(!paryFocusItem->InsertIndirect(j, &focusitem));
    }

Cleanup:
    delete [] pTabs;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SearchFocusArray
//
//  Synopsis:   Search the focus array for the next focussable item
//
//  Returns:    FALSE if pElemFirst was not found in the focus arrya
//              TRUE and ppElemNext/plSubNext set to NULL if pElemFirst
//                  was found, but the next item was not present.
//              TRUE and ppElemNext/plSubNext set to valid values if
//                  pElemFirst was found and the next item is also present.
//
//-------------------------------------------------------------------------

BOOL
CMarkup::SearchFocusArray(
    FOCUS_DIRECTION dir,
    CElement *pElemFirst,
    long lSubFirst,
    CElement **ppElemNext,
    long *plSubNext)
{
    int               i;
    BOOL              fFound = FALSE;
    CAryFocusItem   * paryFocusItem = GetFocusItems(TRUE);

    Assert (paryFocusItem);    
    *ppElemNext = NULL;
    *plSubNext = 0;

    if (!pElemFirst)
    {
        if (DIRECTION_FORWARD == dir && paryFocusItem->Size() > 0)
        {
            i = 0;
        }
        else if (DIRECTION_BACKWARD == dir && paryFocusItem->Size() > 0)
        {
            i = paryFocusItem->Size() - 1;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        //
        // Search for pElemFirst and lSubFirst in the array.
        //

        for (i = 0; i < paryFocusItem->Size(); i++)
        {
            if (pElemFirst == (*paryFocusItem)[i].pElement &&
                lSubFirst == (*paryFocusItem)[i].lSubDivision)
            {
                fFound = TRUE;
                break;
            }
        }

        //
        // If pElemFirst is not in the array, just return FALSE.  This
        // will cause SearchFocusTree to get called.
        //

        if (!fFound)
            return FALSE;

        //
        // If pElemFirst is the first/last element in the array
        // return TRUE.  Otherwise return the next tabbable element.
        //

        if (DIRECTION_FORWARD == dir)
        {
            if (i == paryFocusItem->Size() - 1)
                return TRUE;

            i++;    // Make i point to the item to return
        }
        else
        {
            if (i == 0)
                return TRUE;

            i--;
        }
    }

    *ppElemNext = (*paryFocusItem)[i].pElement;
    *plSubNext = (*paryFocusItem)[i].lSubDivision;
    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SearchFocusTree
//
//  Synopsis:   Update the focus collection upon an element exiting the tree
//
//  Returns:    See SearchFocusArray
//
//-------------------------------------------------------------------------

BOOL
CMarkup::SearchFocusTree(
    FOCUS_DIRECTION dir,
    BOOL            fAccessKey,
    CMessage *      pmsg,
    CElement *pElemFirst,
    long lSubFirst,
    CElement **ppElemNext,
    long *plSubNext)
{
    //
    // Use the all collection for now.  TODO: (anandra) Fix ASAP.
    //

    HRESULT             hr = S_OK;
    long                i;
    long                cElems;
    CElement *          pElement;
    BOOL                fStopOnNextTab = FALSE;
    long                lSubNext;
    int                 iStep;
    BOOL                fFound = FALSE;
    CCollectionCache *  pCollectionCache;
    WCHAR               chKey;
    BOOL                fKeyConverted = FALSE;
    
    *ppElemNext = NULL;
    *plSubNext = 0;       

    hr = THR(EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = CollectionCache();

    cElems = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);
    if (!cElems)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Search for pElemFirst
    //

    iStep = (DIRECTION_FORWARD == dir) ? 1 : -1;

    for (i = (DIRECTION_FORWARD == dir) ? 0 : cElems - 1;
         (DIRECTION_FORWARD == dir) ? (i < cElems) : (i >= 0);
         i += iStep)
    {
        hr = THR(pCollectionCache->GetIntoAry(
                CMarkup::ELEMENT_COLLECTION,
                i,
                &pElement));
        if (hr)
            goto Cleanup;

        Assert(pElement);

        //
        // If HasTabIndex() is true, this element has already
        // been looked at in SearchFocusArray.
        //

        if (!fAccessKey && pElement->HasTabIndex())
            continue;

        if (pElemFirst)
        {
            if (pElemFirst == pElement)
            {
                //
                // Found the element.  Now check if there are any further
                // subdivisions.  If so, then we need to return the next
                // subdivision.  If we're on the last subdivision already
                // or if there are no subdivisions, then we need to return
                // the next tabbable object.
                //

                fFound = TRUE;
                lSubNext = lSubFirst;

                for(;;)
                {
                    hr = THR(pElement->GetNextSubdivision(dir, lSubNext, &lSubNext));
                    if (hr)
                        goto Cleanup;

                    if (lSubNext == -1)
                        break;

                    if (!fAccessKey)
                    {
                        if (pElement->IsTabbable(lSubNext))
                        {
                            *ppElemNext = pElement;
                            *plSubNext = lSubNext;
                            goto Cleanup;
                        }
                    }
                    else
                    {
                        if (! fKeyConverted )
                        {
                            fKeyConverted = TRUE;
                            ConvertMessageToUnicode( pmsg, & chKey );                            
                        }

                        if (pElement->MatchAccessKey(pmsg, lSubNext, & chKey ))
                        {
                            FOCUS_ITEM fi = pElement->GetMnemonicTarget(lSubNext);

                            if (fi.pElement && fi.pElement->IsFocussable(fi.lSubDivision)) 
                            {
                                *ppElemNext = pElement;
                                *plSubNext = lSubNext;
                                goto Cleanup;
                            }
                        }

                        // Drill in if there is slave
                        if (pElement->HasSlavePtr() && pElement->Tag() != ETAG_INPUT)
                        {
                            *ppElemNext = pElement;
                            *plSubNext = -2; // THis will cause the caller to drill in
                            goto Cleanup;
                        }
                    }
                }

                fStopOnNextTab = TRUE;
                continue;
            }
        }
        else
        {
            fStopOnNextTab = TRUE;
        }

        if (fStopOnNextTab)
        {
            hr = THR(pElement->GetNextSubdivision(dir, -1, &lSubNext));
            if (hr)
                goto Cleanup;
            while (lSubNext != -1)
            {
                if (!fAccessKey)
                {
                    if (pElement->IsTabbable(lSubNext))
                    {
                        fFound = TRUE;
                        *ppElemNext = pElement;
                        *plSubNext = lSubNext;
                        goto Cleanup;
                    }
                }
                else
                {
                    if (! fKeyConverted )
                    {
                        fKeyConverted = TRUE;
                        ConvertMessageToUnicode( pmsg, & chKey );                            
                    }

                    if (pElement->MatchAccessKey(pmsg, lSubNext, & chKey ))
                    {
                        FOCUS_ITEM fi = pElement->GetMnemonicTarget(lSubNext);

                        if (fi.pElement && fi.pElement->IsFocussable(fi.lSubDivision)) 
                        {
                            fFound = TRUE;
                            *ppElemNext = pElement;
                            *plSubNext = lSubNext;
                            goto Cleanup;
                        }
                    }
                    // Drill in if there is slave
                    if (    pElement->HasSlavePtr()
                        &&  pElement->Tag() != ETAG_INPUT
                        &&  !pElement->GetSlavePtr()->GetMarkup()->IsPrintMedia())
                    {
                        fFound = TRUE;
                        *ppElemNext = pElement;
                        *plSubNext = -2; // THis will cause the caller to drill in
                        goto Cleanup;
                    }
                }
                hr = THR(pElement->GetNextSubdivision(dir, lSubNext, &lSubNext));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
#if DBG == 1
    if (*ppElemNext)
    {
        Assert(fFound);
    }

    if (hr)
    {
        Assert(!fFound && !*ppElemNext);
    }
#endif
    return fFound;
}

HRESULT CMarkup::InitCollections ( void )
{
    HRESULT hr = S_OK;
    CAllCollectionCacheItem *pAllCollection = NULL;
    CCollectionCache *pCollectionCache;

    // InitCollections should not be called more than once successfully.
    if (HasCollectionCache())
        goto Cleanup;

    pCollectionCache =
        new CCollectionCache(
            this,
            GetWindowedMarkupContext(),
            ENSURE_METHOD(CMarkup, EnsureCollections, ensurecollections ) );

    if (!pCollectionCache)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Initialize from the FORM_COLLECTION onwards,. leaving out the ELEMENT_COLLECTION
    hr = THR(pCollectionCache->InitReservedCacheItems( NUM_DOCUMENT_COLLECTIONS, FORMS_COLLECTION ));
    if (hr)
        goto Cleanup;

    pAllCollection = new CAllCollectionCacheItem();
    if ( !pAllCollection )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pAllCollection->SetMarkup(this);

    pAllCollection->Init();

    hr = THR(pCollectionCache->InitCacheItem ( ELEMENT_COLLECTION, pAllCollection ));
    if (hr)
        goto Cleanup;

    //
    // Collection cache now owns this item & is responsible for freeing it
    //

    // Turn off the default name promotion behaviour on collections
    // that don't support it in Nav.
    pCollectionCache->DontPromoteNames(ANCHORS_COLLECTION);
    pCollectionCache->DontPromoteNames(LINKS_COLLECTION);

    // The frames collection resolves ordinal access on the window object
    // so turn off the WINDOW_COLLECTIOn resultion of ordinals
    pCollectionCache->DontPromoteOrdinals(WINDOW_COLLECTION);


    // Because of VBScript compatability issues we create a dynamic type library
    // (See CDoc::BuildObjectTypeInfo()). The dynamic typeinfo contains
    // DISPIDs starting from DISPID_COLLECTION_MIN, & occupying half the DISPID space.


    // We either get Invokes from these DISPIDs or from the WINDOW_COLLECTION GIN/GINEX name resolution
    // OR from the FRAMES_COLLECTION. So we divide the avaliable DISPID range up among these
    // Three 'collections' - 2 real collections & one hand-cooked collection.

    // Divide up the WINDOW_COLLECTION DISPID's so we can tell where the Invoke came from

    // Give the lowest third to the dynamic type library
    // DISPID_COLLECTION_MIN .. (DISPID_COLLECTION_MIN+DISPID_COLLECTION_MAX)/3

    // Give the next third to names resolved on the WINDOW_COLLECTION
    pCollectionCache->SetDISPIDRange ( WINDOW_COLLECTION,
            (DISPID_COLLECTION_MIN+DISPID_COLLECTION_MAX)/3+1,
            ((DISPID_COLLECTION_MIN+DISPID_COLLECTION_MAX)*2)/3 );

    // In COmWindowProxy::Invoke the security code allows DISPIDs from the frames collection
    // through with no security check. Check that the DISPIDs reserved for this range match up
    Assert ( FRAME_COLLECTION_MIN_DISPID == pCollectionCache->GetMaxDISPID(WINDOW_COLLECTION)+1 );
    Assert ( FRAME_COLLECTION_MAX_DISPID == DISPID_COLLECTION_MAX );

    // Give the final third to the FRAMES_COLLECTION
    pCollectionCache->SetDISPIDRange ( FRAMES_COLLECTION,
            pCollectionCache->GetMaxDISPID(WINDOW_COLLECTION)+1,
            DISPID_COLLECTION_MAX );

    // Like NAV, we want to return the last frame that matches the name asked for,
    // rather than returning a collection.
    pCollectionCache->AlwaysGetLastMatchingCollectionItem ( FRAMES_COLLECTION );

    // Like NAV, the images doesn't return sub-collections. Note that we might put multiple
    // entries in the IMG collection for the same IMG if the IMG is nested in a table - so
    // this also prevents us from retunring a sub-collection in this situation.
    pCollectionCache->AlwaysGetLastMatchingCollectionItem ( IMAGES_COLLECTION );

    // Setup the lookaside variable
    hr = THR(SetLookasidePtr(LOOKASIDE_COLLECTIONCACHE, pCollectionCache));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


void CAllCollectionCacheItem::Init()
{
    CMarkup *pMarkup = GetMarkup();

    Assert(pMarkup);

    _pTreePos = pMarkup->FirstTreePos();

    Assert(     _pTreePos 
            &&  _pTreePos->IsNode() 
            &&  _pTreePos->Branch()->Tag() == ETAG_ROOT);

    // Skip past the root
    _pTreePos = _pTreePos->NextTreePos();

    // Find the first begin edge
    while(      _pTreePos != NULL
            &&  !_pTreePos->IsBeginElementScope())
    {
        _pTreePos = _pTreePos->NextTreePos();
    }
}

CElement *CAllCollectionCacheItem::GetNext ( void )
{
    CElement *pElement = NULL;

    if(_pTreePos && GetMarkup())
    {
        Assert( _pTreePos->IsBeginElementScope() );
        pElement = _pTreePos->Branch()->Element();

        // Skip over any nonelement nodes
        do
        {
            _pTreePos = _pTreePos->NextTreePos();
        } while(_pTreePos && !_pTreePos->IsBeginElementScope());
    }

    return pElement;
}

CElement *CAllCollectionCacheItem::MoveTo ( long lIndex )
{
    if (!GetMarkup())
        return NULL;

    if(lIndex == 0)
        Init();
    else
        return GetAt(lIndex, &_pTreePos);

    return NULL;
}

CElement *CAllCollectionCacheItem::GetAt ( long lIndex, CTreePos **ppTreePos )
{
    CMarkup * pMarkup = GetMarkup();
    CTreePos *ptpBegin;

    if (!pMarkup)
        return NULL;

    Assert ( lIndex >= 0 );

    // Skip ETAG_ROOT which is always the zero'th element
    lIndex++;

    if ( lIndex >= pMarkup->NumElems() )
        return NULL;

    ptpBegin = pMarkup->TreePosAtSourceIndex ( lIndex );

    Assert (ptpBegin && ptpBegin->IsBeginElementScope() );

    // Update the GetNext Walker
    if(ppTreePos)
        *ppTreePos = ptpBegin;

    return ptpBegin->Branch()->Element();
}

long CAllCollectionCacheItem::Length ( void )
{
    CMarkup *pMarkup = GetMarkup();

    if ( pMarkup && pMarkup->NumElems() >= 1 )
        return pMarkup->NumElems()-1;
    else
        return 0;
}

extern CDummySecurityDispatchEx g_DummySecurityDispatchEx;

CMarkup *CAllCollectionCacheItem::GetMarkup(void)
{
    if (!_pMarkup && _pDispDocument)
    {
        CDocument *pDocument = NULL;

        if (((TEAROFF_THUNK *)_pDispDocument)->pvObject1 != (IDispatchEx*)&g_DummySecurityDispatchEx)
        {
            pDocument = (CDocument *)(((TEAROFF_THUNK *)_pDispDocument)->pvObject1);
            Assert(pDocument->Markup());
            return pDocument->Markup();
        }

        ClearInterface(&_pDispDocument);
    }

    return _pMarkup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\formmso.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       src\core\formkrnl\formmso.cxx
//
//  Contents:   Implementation of IOleCommandTarget
//
//  Classes:    CDoc
//
//  Functions:
//
//  History:    04-May-95   RodC    Created
//
//----------------------------------------------------------------------------
#ifdef UNIX
#include <inetreg.h>
#endif

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecute
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"   // for _pimganim
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_UPDSINK_HXX_
#define X_UPDSINK_HXX_
#include "updsink.hxx"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_FRAME_HXX
#define X_FRAME_HXX
#include "frame.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"
#endif

#ifndef _X_WEBOCUTIL_H_
#define _X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

PerfDbgExtern(tagPerfWatch);

#ifdef UNIX
// A hack to compile:
EXTERN_C const GUID CGID_DocHostCommandHandler = {0xf38bc242,0xb950,0x11d1, {0x89,0x18,0x00,0xc0,0x4f,0xc2,0xc8,0x36}};
#endif // UNIX
EXTERN_C const GUID CGID_DocHostCommandHandler;

extern TCHAR g_achDLLCore[];
ExternTag(tagMsoCommandTarget);
extern void DumpFormatCaches();

#ifdef UNIX
extern int g_SelectedFontSize;
#endif

#ifndef NO_SCRIPT_DEBUGGER
extern interface IDebugApplication *g_pDebugApp;
#endif

EXTERN_C const GUID IID_ITriEditDocument = {0x438DA5DF, 0xF171, 0x11D0, {0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8}};

extern BOOL g_fInHtmlHelp;

HRESULT CreateResourceMoniker(HINSTANCE hInst, TCHAR *pchRID, IMoniker **ppmk);

ULONG ConvertSBCMDID(ULONG localIDM)
{
    struct SBIDMConvert {
        ULONG localIDM;
        ULONG SBCMDID;
    };
    static const SBIDMConvert SBIDMConvertTable[] =
    {
        { IDM_TOOLBARS,       SBCMDID_SHOWCONTROL },
        { IDM_STATUSBAR,      SBCMDID_SHOWCONTROL },
        { IDM_OPTIONS,        SBCMDID_OPTIONS },
        { IDM_ADDFAVORITES,   SBCMDID_ADDTOFAVORITES },
        { IDM_CREATESHORTCUT, SBCMDID_CREATESHORTCUT },
        { 0, 0 }
    };

    ULONG SBCmdID = IDM_UNKNOWN;
    int   i;

    for (i = 0; SBIDMConvertTable[i].localIDM; i ++)
    {
        if (SBIDMConvertTable[i].localIDM == localIDM)
        {
            SBCmdID = SBIDMConvertTable[i].SBCMDID;
            break;
        }
    }

    return SBCmdID;
}

//////////////
//  Globals // moved from rootlyt.cxx
//////////////

BSTR                g_bstrFindText = NULL;

HRESULT
GetFindText(BSTR *pbstr)
{
    LOCK_GLOBALS;

    RRETURN(FormsAllocString(g_bstrFindText, pbstr));
}


BOOL
CDoc::HostedInTriEdit()
{
    HRESULT     hr = S_OK;
    IUnknown    *pITriEditDocument = NULL;
    BOOL        fHostedInTriEdit = FALSE;
    
    hr = THR( QueryInterface(IID_ITriEditDocument, (void **)&pITriEditDocument) );
    if (hr == S_OK && pITriEditDocument != NULL)
    {
        fHostedInTriEdit = TRUE;
    }
    
    ReleaseInterface(pITriEditDocument);
    return fHostedInTriEdit;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDoc::RouteCTElement
//
//  Synopsis:   Route a command target call, either QueryStatus or Exec
//              to an element
//
//--------------------------------------------------------------------------

HRESULT
CDoc::RouteCTElement(CElement *pElement, CTArg *parg, CDocument *pContextDoc)
{
    HRESULT     hr = OLECMDERR_E_NOTSUPPORTED;
    CTreeNode * pNodeParent;
    AAINDEX     aaindex;
    IUnknown *  pUnk = NULL;

    _cInRouteCT++;

    if (TestLock(FORMLOCK_QSEXECCMD) && pContextDoc)
    {
        aaindex = pContextDoc->FindAAIndex(
            DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        if (aaindex != AA_IDX_UNKNOWN)
        {
            // Note: Command routing can fail here if we return an error because
            // command execution halts unless we return OLECMDERR_E_NOTSUPPORTED.
            if (FAILED(pContextDoc->GetUnknownObjectAt(aaindex, &pUnk)))
                goto Cleanup;
        }
    }

    while (pElement)
    {
        // TODO (lmollico): traverse the master if the element wants to
        Assert(pElement->Tag() != ETAG_ROOT ||
               !pElement->IsInMarkup() || pElement == pElement->GetMarkup()->Root());

        if (!pElement->IsInMarkup() || pElement == pElement->GetMarkup()->Root())
            break;

        if (pUnk)
        {
            pElement->AddUnknownObject(
                DISPID_INTERNAL_INVOKECONTEXT, pUnk, CAttrValue::AA_Internal);
        }

        if (parg->fQueryStatus)
        {
            Assert(parg->pqsArg->cCmds == 1);

            // Note: Command routing can fail here if we return an error because
            // command execution halts unless we return OLECMDERR_E_NOTSUPPORTED.
            hr = THR_NOTRACE(pElement->QueryStatus(
                    parg->pguidCmdGroup,
                    parg->pqsArg->cCmds,
                    parg->pqsArg->rgCmds,
                    parg->pqsArg->pcmdtext));
            if (parg->pqsArg->rgCmds[0].cmdf)
                break;  // Element handled it.
        }
        else
        {
            // Note: Command routing can fail here if we return an error because
            // command execution halts unless we return OLECMDERR_E_NOTSUPPORTED.
            hr = THR_NOTRACE(pElement->Exec(
                    parg->pguidCmdGroup,
                    parg->pexecArg->nCmdID,
                    parg->pexecArg->nCmdexecopt,
                    parg->pexecArg->pvarargIn,
                    parg->pexecArg->pvarargOut));
            if (hr != OLECMDERR_E_NOTSUPPORTED)
                break;
        }

        if (pUnk)
        {
            pElement->FindAAIndexAndDelete(
                DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        }

        if (!pElement->IsInMarkup())
            break;

        if (pElement == pElement->GetMarkup()->GetElementClient())
            break;

        pNodeParent = pElement->GetFirstBranch()->Parent();
        pElement = pNodeParent ? pNodeParent->Element() : NULL;
    }

Cleanup:
    if (pUnk && pElement)
    {
        pElement->FindAAIndexAndDelete(
            DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
    }
    ReleaseInterface(pUnk);
    _cInRouteCT--;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CDoc::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    HRESULT hr;

    hr = THR(QueryStatusHelper(NULL, pguidCmdGroup, cCmds, rgCmds, pcmdtext));

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetExecDocument
//
//  Synopsis:   Helper called to get a CDocument* based on two choices
//
//--------------------------------------------------------------------------
HRESULT
GetExecDocument(CDocument ** ppDocument, CElement * pMenuObject, CDocument * pContextDoc)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = NULL;

    Assert(ppDocument);

    // Determine the markup to execute the command on
    if (pMenuObject)
    {
        pMarkup = pMenuObject->GetMarkup();
    }
    else if (pContextDoc)
    {
        pMarkup = pContextDoc->Markup();
    }

    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);

    Assert(pMarkup);

    *ppDocument = pMarkup->Document();

    Assert(NULL != *ppDocument);

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryStatusHelper
//
//  Synopsis:   Helper called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CDoc::QueryStatusHelper(
        CDocument *pContextDoc,
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagMsoCommandTarget, "CDoc::QueryStatus"));

    // Check to see if the command is in our command set.
    if (!IsCmdGroupSupported(pguidCmdGroup))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);

    MSOCMD *    pCmd;
    INT         c;
    UINT        idm;
    HRESULT     hr = S_OK;
    MSOCMD      msocmd;
    CTArg       ctarg;
    CTQueryStatusArg    qsarg;
    BOOL                fDesignMode;
    CMarkup     *pEditMarkup = NULL;

    if (!pContextDoc)
    {
        Assert(_pWindowPrimary);
        pContextDoc = _pWindowPrimary->Document();
    }
    else
    {
        pEditMarkup = pContextDoc->Markup();
    }

    Assert (pContextDoc);
    Assert (pContextDoc->Markup());
    fDesignMode = pContextDoc->Markup()->_fDesignMode;

    // Loop through each command in the ary, setting the status of each.
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        idm = IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
        if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_STATUS)
        {
            pcmdtext[c].cwActual = LoadString(
                    GetResourceHInst(),
                    IDS_MENUHELP(idm),
                    pcmdtext[c].rgwz,
                    pcmdtext[c].cwBuf);
        }

        if (    !fDesignMode
            &&  idm >= IDM_MENUEXT_FIRST__
            &&  idm <= IDM_MENUEXT_LAST__
            &&  _pOptionSettings)
        {
            CONTEXTMENUEXT *    pCME;
            int                 nExts, nExtCur;

            // not supported unless the next test succeeds
            pCmd->cmdf = 0;

            nExts = _pOptionSettings->aryContextMenuExts.Size();
            nExtCur = idm - IDM_MENUEXT_FIRST__;

            if(nExtCur < nExts)
            {
                // if we have it, it is enabled
                pCmd->cmdf = MSOCMDSTATE_UP;

                // the menu name is the text returned
                pCME = _pOptionSettings->
                            aryContextMenuExts[idm - IDM_MENUEXT_FIRST__];
                pCmd->cmdf = MSOCMDSTATE_UP;

                Assert(pCME);

                if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_NAME)
                {
                    hr = Format(
                            0,
                            pcmdtext->rgwz,
                            pcmdtext->cwBuf,
                            pCME->cstrMenuValue);
                    if (!hr)
                        pcmdtext->cwActual = _tcslen(pcmdtext->rgwz);

                    // ignore the hr
                    hr = S_OK;
                }
            }
        }

        switch (idm)
        {
        case IDM_REPLACE:
        case IDM_FONT:
        case IDM_GOTO:
        case IDM_HYPERLINK:
        case IDM_BOOKMARK:
        case IDM_IMAGE:
            if(_fInHTMLDlg)
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

        case IDM_FIND:
            if (_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else
                pCmd->cmdf = _fInHTMLDlg ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_PROPERTIES:
            pCmd->cmdf = MSOCMDSTATE_UP;
            hr = S_OK;
            break;

        case IDM_MENUEXT_COUNT:
            pCmd->cmdf = _pOptionSettings ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
            break;

        case IDM_REDO:
        case IDM_UNDO:
            QueryStatusUndoRedo((IDM_UNDO == idm), pCmd, pcmdtext);
            break;

        case IDM_SAVE:
            if (!fDesignMode)
            {
                // Disable Save Command if in BROWSE mode.
                //
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
                break;
            }
            // fall through to QueryStatus the DocFrame if in EDIT mode.

        case IDM_NEW:
        case IDM_OPEN:
            //  Bubble it out to the DocFrame

            msocmd.cmdf  = 0;
            msocmd.cmdID = (idm == IDM_NEW) ? (OLECMDID_NEW) :
                   ((idm == IDM_OPEN) ? (OLECMDID_OPEN) : (OLECMDID_SAVE));
            hr = THR(CTQueryStatus(_pInPlace->_pInPlaceSite, NULL, 1, &msocmd, NULL));
            if (!hr)
                pCmd->cmdf = msocmd.cmdf;

            break;

        case IDM_SAVEAS:
            pCmd->cmdf = _fFullWindowEmbed ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_ISTRUSTEDDLG:
            if(_fInTrustedHTMLDlg)
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            else
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

#if !defined(WIN16) && !defined(WINCE)
#if !defined(NO_SCRIPT_DEBUGGER)
        case IDM_TOOLBARS:
        case IDM_STATUSBAR:
            ULONG        SBCmdId;
            VARIANTARG   varIn, varOut;

            pCmd->cmdf = MSOCMDSTATE_DISABLED;

            SBCmdId = ConvertSBCMDID(idm);
            varIn.vt   = VT_I4;
            varIn.lVal = MAKELONG(
                    (idm == IDM_TOOLBARS) ? (FCW_INTERNETBAR) : (FCW_STATUS),
                    SBSC_QUERY);

            hr = THR(CTExec(
                    _pInPlace->_pInPlaceSite,
                    &CGID_Explorer,
                    SBCmdId,
                    0,
                    &varIn,
                    &varOut));
            if (!hr && varOut.vt == VT_I4)
            {
                switch (varOut.lVal)
                {
                case SBSC_HIDE:
                    pCmd->cmdf = MSOCMDSTATE_UP;
                    break;

                case SBSC_SHOW:
                    pCmd->cmdf = MSOCMDSTATE_DOWN;
                    break;
                }
            }

            break;

#endif // NO_SCRIPT_DEBUGGER

        case IDM_OPTIONS:
        case IDM_ADDFAVORITES:
        case IDM_CREATESHORTCUT:
            msocmd.cmdf  = 0;
            msocmd.cmdID = ConvertSBCMDID(idm);
            hr = THR(CTQueryStatus(
                    _pInPlace->_pInPlaceSite,
                    &CGID_Explorer,
                    1,
                    &msocmd,
                    NULL));
            if (!hr)
            {
                pCmd->cmdf = (msocmd.cmdf & MSOCMDF_ENABLED) ?
                        (MSOCMDSTATE_UP) : (MSOCMDSTATE_DISABLED);
            }
            break;
#endif // !WIN16 && !WINCE

        case IDM_PAGESETUP:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_PRINT:
            pCmd->cmdf = (IsPrintDialog()) ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_PRINTPREVIEW:
            pCmd->cmdf =    (   IsPrintDialog()
                             || GetPlugInSiteForPrinting(pContextDoc) == S_OK )
                                ? MSOCMDSTATE_DISABLED
                                : MSOCMDSTATE_UP;
            break;

        case IDM_PRINTQUERYJOBSPENDING:
            pCmd->cmdf = (PrintJobsPending() ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED);
            break;

        case IDM_HELP_CONTENT:
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

        case IDM_HELP_README:
        case IDM_HELP_ABOUT:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_BROWSEMODE:
            if (fDesignMode)
                pCmd->cmdf = MSOCMDSTATE_UP;
            else
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            break;

        case IDM_EDITMODE:
            if (pContextDoc->Markup()->IsImageFile()) // Cannot edit image files
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else if (fDesignMode)
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_VIEWSOURCE:
            if (pContextDoc->Markup()->IsImageFile() || _fFullWindowEmbed) // No source for non-HTML files
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

#ifndef NO_SCRIPT_DEBUGGER
        case IDM_SCRIPTDEBUGGER:
            if (PrimaryMarkup()->HasScriptContext() &&
                PrimaryMarkup()->ScriptContext()->_pScriptDebugDocument)
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_BREAKATNEXT:
        case IDM_LAUNCHDEBUGGER:
            pCmd->cmdf = (PrimaryMarkup()->HasScriptContext() &&
                          PrimaryMarkup()->ScriptContext()->_pScriptDebugDocument) ?
                            MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
            break;
#endif // ndef NO_SCRIPT_DEBUGGER

        case IDM_STOP:
            pCmd->cmdf = fDesignMode ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_STOPDOWNLOAD:
            pCmd->cmdf = _fSpin ? MSOCMDF_ENABLED : 0;
            break;

        case IDM_REFRESH_TOP:
        case IDM_REFRESH_TOP_FULL:
            _pWindowPrimary->QueryRefresh(&pCmd->cmdf);
            break;

        case IDM_REFRESH:
        case IDM_REFRESH_THIS:
        case IDM_REFRESH_THIS_FULL:
            {
                COmWindowProxy * pOmWindowProxy = NULL;

                // Get the markup of the nearest frame, if any. Otherwise use the primary markup.

                Assert(pContextDoc);

                CMarkup * pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();

                if (pMarkup)
                {
                    pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);
                }
                if (pMarkup)
                {
                    pOmWindowProxy = pMarkup->Window();
                }
                if (!pOmWindowProxy)
                {
                    pOmWindowProxy = _pWindowPrimary;
                }
                Assert(pOmWindowProxy);
                pOmWindowProxy->QueryRefresh(&pCmd->cmdf);
            }
            break;

        case IDM_CONTEXTMENU:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_GOBACKWARD:
        case IDM_GOFORWARD:
            {
                // default this to disabled since we're not
                // hosted in shdocvw when we're on the desktop
                pCmd->cmdf = MSOCMDSTATE_DISABLED;

                MSOCMD            rgCmds1[1];
                LPOLECLIENTSITE   lpClientSite     = NULL;
                IBrowserService * pTopFrameBrowser = NULL;

                rgCmds1[0].cmdf  = 0;
                rgCmds1[0].cmdID = (idm == IDM_GOBACKWARD)
                                 ? SHDVID_CANGOBACK
                                 : SHDVID_CANGOFORWARD;

                if (_fViewLinkedInWebOC && _pBrowserSvc)
                {
                    hr = IUnknown_QueryService(_pBrowserSvc, SID_STopFrameBrowser,
                                               IID_IBrowserService, (void**)&pTopFrameBrowser);
                    if (hr)
                        goto Cleanup;

                    hr = IUnknown_QueryStatus(pTopFrameBrowser, &CGID_ShellDocView,
                                              1, rgCmds1, NULL);
                }
                else
                {
                    hr = GetClientSite(&lpClientSite);

                    if (hr || !lpClientSite)
                    {
                        goto Cleanup;
                    }

                    hr = IUnknown_QueryStatus(lpClientSite, &CGID_ShellDocView,
                                              1, rgCmds1, NULL);
                }

                if (hr)
                    goto Cleanup;

                pCmd->cmdf = rgCmds1[0].cmdf ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;

            Cleanup:
                ReleaseInterface(lpClientSite);
                ReleaseInterface(pTopFrameBrowser);
            }

           break;

        case IDM_BASELINEFONT1:
        case IDM_BASELINEFONT2:
        case IDM_BASELINEFONT3:
        case IDM_BASELINEFONT4:
        case IDM_BASELINEFONT5:
            //
            // depend on that IDM_BASELINEFONT1, IDM_BASELINEFONT2,
            // IDM_BASELINEFONT3, IDM_BASELINEFONT4, IDM_BASELINEFONT5 to be
            // consecutive integers.
            //
            {
                if (GetBaselineFont() ==
                    (short)(idm - IDM_BASELINEFONT1 + BASELINEFONTMIN))
                {
                    pCmd->cmdf = MSOCMDSTATE_DOWN;
                }
                else
                {
                    pCmd->cmdf = MSOCMDSTATE_UP;
                }
            }
            break;

        case IDM_SHDV_MIMECSETMENUOPEN:
        case IDM_SHDV_FONTMENUOPEN:
        case IDM_SHDV_GETMIMECSETMENU:
        case IDM_SHDV_GETFONTMENU:
        case IDM_LANGUAGE:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_DIRLTR:
        case IDM_DIRRTL:
            {
                BOOL fDocRTL = FALSE;   // keep compiler happy

                CDocument * pDocument;

                hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
                if (SUCCEEDED(hr))
                {
                    hr = THR(pDocument->GetDocDirection(&fDocRTL));
                }
                if (hr == S_OK && ((!fDocRTL) ^ (idm == IDM_DIRRTL)))
                {
                    pCmd->cmdf = MSOCMDSTATE_DOWN;
                }
                else
                {
                    pCmd->cmdf = MSOCMDSTATE_UP;
                }
            }
            break;

        case IDM_SHDV_DEACTIVATEMENOW:
        case IDM_SHDV_NODEACTIVATENOW:
            //  This is Exec only in the upward direction.
            //  we shouldn't get here.
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

        case IDM_SHDV_CANDEACTIVATENOW:
            //  We return ENABLED unless we or one of our OCs [eg a frame]
            //  are in a script or otherwise not able to be deactivated.  if this is
            //  disabled, SHDOCVW will defer the activation until signaled by
            //  a SHDVID_DEACTIVATEMENOW on script exit [at which time, it
            //  will redo the SHDVID_CANDEACTIVATENOW querystatus]
            Assert(pContextDoc->GetWindowedMarkupContext()->GetWindowPending());
            if (pContextDoc->GetWindowedMarkupContext()->GetWindowPending()->Window()->IsInScript())
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_SHDV_PAGEFROMPOSTDATA:
            if (PrimaryMarkup()->GetDwnPost())
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

#ifdef IDM_SHDV_ONCOLORSCHANGE
                        // Let the shell know we support the new palette notification
                case IDM_SHDV_ONCOLORSCHANGE:
                        pCmd->cmdf = MSOCMDF_SUPPORTED;
                        break;
#endif
        case IDM_RESPECTVISIBILITY_INDESIGN:
            pCmd->cmdf = pContextDoc->Markup()->IsRespectVisibilityInDesign() ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
            break;

        case IDM_HTMLEDITMODE:
            pCmd->cmdf = _fInHTMLEditMode ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
            break;

        case IDM_SHOWALLTAGS:
        case IDM_SHOWALIGNEDSITETAGS:
        case IDM_SHOWSCRIPTTAGS:
        case IDM_SHOWSTYLETAGS:
        case IDM_SHOWCOMMENTTAGS:
        case IDM_SHOWAREATAGS:
        case IDM_SHOWUNKNOWNTAGS:
        case IDM_SHOWMISCTAGS:
        {
            Assert(pContextDoc->Markup());
            CGlyph *pTable = pContextDoc->Markup()->GetGlyphTable();

            if( pTable )
            {
                switch( idm )
                {
                    case IDM_SHOWALLTAGS:
                        pCmd->cmdf = pTable->_fShowAlignedSiteTags &&
                                     pTable->_fShowMiscTags &&
                                     pTable->_fShowScriptTags &&
                                     pTable->_fShowStyleTags &&
                                     pTable->_fShowCommentTags &&
                                     pTable->_fShowAreaTags &&
                                     pTable->_fShowUnknownTags &&
                                     pTable->_fShowMiscTags ?
                                     MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWALIGNEDSITETAGS:
                        pCmd->cmdf = pTable->_fShowAlignedSiteTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWSCRIPTTAGS:
                        pCmd->cmdf = pTable->_fShowScriptTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWSTYLETAGS:
                        pCmd->cmdf = pTable->_fShowStyleTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWCOMMENTTAGS:
                        pCmd->cmdf = pTable->_fShowCommentTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWAREATAGS:
                        pCmd->cmdf = pTable->_fShowAreaTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWUNKNOWNTAGS:
                        pCmd->cmdf = pTable->_fShowUnknownTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWMISCTAGS:
                        pCmd->cmdf = pTable->_fShowMiscTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;
                }
            }
            else
            {
                pCmd->cmdf = MSOCMDSTATE_UP;
            }

            break;
        }


        case IDM_SHOWZEROBORDERATDESIGNTIME:
            pCmd->cmdf = CHECK_EDIT_BIT( pContextDoc->Markup(),_fShowZeroBorderAtDesignTime ) ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

        case IDM_NOACTIVATENORMALOLECONTROLS:
            pCmd->cmdf = _fNoActivateNormalOleControls ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

        case IDM_NOACTIVATEDESIGNTIMECONTROLS:
            pCmd->cmdf = _fNoActivateDesignTimeControls ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

        case IDM_NOACTIVATEJAVAAPPLETS:
            pCmd->cmdf = _fNoActivateJavaApplets ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

#if DBG==1
        case IDM_DEBUG_TRACETAGS:
        case IDM_DEBUG_DUMPOTRACK:
        case IDM_DEBUG_RESFAIL:
        case IDM_DEBUG_BREAK:
        case IDM_DEBUG_VIEW:
        case IDM_DEBUG_DUMPTREE:
        case IDM_DEBUG_DUMPFORMATCACHES:
        case IDM_DEBUG_DUMPLINES:
        case IDM_DEBUG_DUMPLAYOUTRECTS:
        case IDM_DEBUG_MEMMON:
        case IDM_DEBUG_METERS:
        case IDM_DEBUG_DUMPDISPLAYTREE:
        case IDM_DEBUG_DUMPRECALC:
        case IDM_DEBUG_SAVEHTML:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;
#endif // DBG == 1

        }

//#ifndef NO_IME
        // Enables the languages in the browse context menu
        if( !fDesignMode && idm >= IDM_MIMECSET__FIRST__ &&
                             idm <= IDM_MIMECSET__LAST__)
        {
            CODEPAGE cp = GetCodePageFromMenuID(idm);

            if (cp == PrimaryMarkup()->GetCodePage() || cp == CP_UNDEFINED)
            {
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            }
            else
            {
                pCmd->cmdf = MSOCMDSTATE_UP;
            }
        }
//#endif // !NO_IME

        //
        // If still not handled then try menu object.
        //

        ctarg.pguidCmdGroup = pguidCmdGroup;
        ctarg.fQueryStatus = TRUE;
        ctarg.pqsArg = &qsarg;
        qsarg.cCmds = 1;
        qsarg.rgCmds = pCmd;
        qsarg.pcmdtext = pcmdtext;

        if (!pCmd->cmdf && _pMenuObject)
        {
            hr = THR_NOTRACE(RouteCTElement(_pMenuObject, &ctarg, pContextDoc));
        }

        //
        // Next try the current element;
        //
        if (!pCmd->cmdf && _pElemCurrent)
        {
            CElement *pelTarget;
            CTreeNode *pNode = _pElemCurrent->GetFirstBranch();
            Assert(pNode);
            Assert(pContextDoc);

            // Get the node in the markup of the context CDocument that contains the current element
            pNode = pNode->GetNodeInMarkup(pContextDoc->Markup());

            if (pNode)
            {
                pelTarget = pNode->Element();
            }
            else
            {
                pelTarget = pContextDoc->Markup()->GetElementClient();
            }
            if (pelTarget)
                hr = THR_NOTRACE(RouteCTElement(pelTarget, &ctarg, pContextDoc));
        }

        //
        // Finally try edit router
        //

        if( !pCmd->cmdf )
        {
            CEditRouter *pRouter;
            HRESULT     hrEdit = S_OK;

            // Retrieve the edit markup if no context has been passed into this helper function.
            // This occurs when pContextDoc is NULL on input.  pEditMarkup will be NULL in this
            // case, and we use the selection's current markup in order to determine where
            // the edit command should be routed to

            if( !pEditMarkup )
            {
                hrEdit = THR( GetSelectionMarkup( &pEditMarkup ) );

                if( pEditMarkup == NULL && _pElemCurrent )
                {
                    pEditMarkup = _pElemCurrent->GetMarkupPtr();
                }

            }

            if( !FAILED(hrEdit) && pEditMarkup )
            {
                hr = THR( pEditMarkup->EnsureEditRouter(&pRouter) );

                if( !FAILED(hr) )
                {
                    hr = THR_NOTRACE( pRouter->QueryStatusEditCommand(
                            pguidCmdGroup,
                            1,
                            pCmd,
                            pcmdtext,
                            (IUnknown *)(IPrivateUnknown *)pEditMarkup,
                            pEditMarkup,
                            this ));
                }
            }
        }

        // Prevent any command but the first from setting this.
        pcmdtext = NULL;
    }

    SRETURN(hr);
}

#if !defined(UNIX)

extern HRESULT DisplaySource(LPCTSTR tszSourceName);

HRESULT CDoc::InvokeEditor( LPCTSTR tszSourceName )
{
    return DisplaySource(tszSourceName);
}

#else // !UNIX

HRESULT CDoc::InvokeEditor( LPCTSTR lptszPath )
{
    HRESULT         hr = S_OK;

    TCHAR           tszCommand[pdlUrlLen];
    TCHAR           tszExpandedCommand[pdlUrlLen];
    UINT            nCommandSize;
    int             i;
    HKEY    hkey;
    DWORD   dw;
    TCHAR *pchPos;
    BOOL bMailed;
    STARTUPINFO stInfo;

    hr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_VSOURCECLIENTS,
                        0, NULL, 0, KEY_READ, NULL, &hkey, &dw);
    if (hr != ERROR_SUCCESS)
        goto Cleanup;

    dw = pdlUrlLen;
    hr = RegQueryValueEx(hkey, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCommand, &dw);
    if (hr != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        goto Cleanup;
    }

    dw = ExpandEnvironmentStrings(tszCommand, tszExpandedCommand, pdlUrlLen);
    if (!dw)
    {
        _tcscpy(tszExpandedCommand, tszCommand);
    }
    _tcscat(tszCommand, tszExpandedCommand);

    for (i = _tcslen(tszCommand); i > 0; i--)
    {
        if (tszCommand[i] == '/')
        {
            tszCommand[i] = '\0';
            break;
        }
    }

    _tcscat(tszCommand, TEXT(" "));
    _tcscat(tszCommand, lptszPath);

    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    stInfo.wShowWindow= SW_SHOWNORMAL;
    bMailed = CreateProcess(tszExpandedCommand,
                            tszCommand,
                            NULL, NULL, TRUE,
                            CREATE_NEW_CONSOLE,
                            NULL, NULL, &stInfo, NULL);

Cleanup:

    return hr;
}

#endif

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Exec
//
//  Synopsis:   Called to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT hr;

    hr = THR(ExecHelper(NULL, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

    SRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ExecHelper
//
//  Synopsis:   helper to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------
#define IPRINT_DOCUMENT     0
#define IPRINT_ACTIVEFRAME  1
#define IPRINT_ALLFRAMES    2

HRESULT
CDoc::ExecHelper(
        CDocument *pContextDoc,
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CDoc::Exec"));

    if (!IsCmdGroupSupported(pguidCmdGroup))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);


#ifndef NO_HTML_DIALOG
    struct DialogInfo
    {
        UINT    idm;
        UINT    idsUndoText;
        TCHAR * szidr;
    };

    // TODO (cthrash) We should define and use better undo text.  Furthermore,
    // we should pick an appropriate one depending (for image, link, etc.)
    // on whether we're creating anew or editting an existing object.
    //
    // Fix for bug# 9136. (a-pauln)
    // Watch order of this array. Find dialogs need to be at the bottom,
    // and in the order listed (IDR_FINDDIALOG, IDR_BIDIFINDDIALOG).
    //
    // Find resources have been relocated to shdocvw (peterlee)
    static DialogInfo   dlgInfo[] =
    {
        {IDM_FIND,          0,                     NULL}, //IDR_FINDDIALOG,
        {IDM_FIND,          0,                     NULL}, //IDR_BIDIFINDDIALOG,
        {IDM_REPLACE,       IDS_UNDOGENERICTEXT,   IDR_REPLACEDIALOG},
        {IDM_PARAGRAPH,     IDS_UNDOGENERICTEXT,   IDR_FORPARDIALOG},
        {IDM_FONT,          IDS_UNDOGENERICTEXT,   IDR_FORCHARDIALOG},
        {IDM_GOTO,          0,                     IDR_GOBOOKDIALOG},
        {IDM_IMAGE,         IDS_UNDONEWCTRL,       IDR_INSIMAGEDIALOG},
        {IDM_HYPERLINK,     IDS_UNDOGENERICTEXT,   IDR_EDLINKDIALOG},
        {IDM_BOOKMARK,      IDS_UNDOGENERICTEXT,   IDR_EDBOOKDIALOG},
    };
#endif // NO_HTML_DIALOG

    CDoc::CLock         Lock(this);
    UINT                idm;
    HRESULT             hr = OLECMDERR_E_NOTSUPPORTED;
    DWORD               nCommandID;
    CTArg               ctarg;
    CTExecArg           execarg;
    BOOL                fRouteToEditor = FALSE;
    CMarkup             *pEditMarkup = NULL;
    CDocument           *pContextDocOrig = pContextDoc;

    //  artakka showhelp is not implemented (v2?)
    if(nCmdexecopt == MSOCMDEXECOPT_SHOWHELP)
    {
        return E_NOTIMPL;
    }


    if (!pContextDoc)
    {
        Assert(_pWindowPrimary);
        pContextDoc = _pWindowPrimary->Document();
    }
    else
    {
        pEditMarkup = pContextDoc->Markup();
    }

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    // Handle context menu extensions - always eat the command here
    if( idm >= IDM_MENUEXT_FIRST__ && idm <= IDM_MENUEXT_LAST__)
    {
        CMarkup * pMarkupExt = NULL;
        if (_pMenuObject)
            pMarkupExt = _pMenuObject->GetMarkup();
        if (!pMarkupExt)
            pMarkupExt = pContextDoc->Markup();

        if (pMarkupExt)
        {
            hr = OnContextMenuExt(pMarkupExt, idm, pvarargIn);
        }
        goto Cleanup;
    }

    switch (idm)
    {
        int             result;

#if DBG==1
    case IDM_DEBUG_MEMMON:
        DbgExOpenMemoryMonitor();
        hr = S_OK;
        break;

    case IDM_DEBUG_METERS:
        DbgExMtOpenMonitor();
        hr = S_OK;
        break;

    case IDM_DEBUG_TRACETAGS:
        DbgExDoTracePointsDialog(FALSE);
        hr = S_OK;
        break;

    case IDM_DEBUG_RESFAIL:
        DbgExShowSimFailDlg();
        hr = S_OK;
        break;

    case IDM_DEBUG_DUMPOTRACK:
        DbgExTraceMemoryLeaks();
        hr = S_OK;
        break;

    case IDM_DEBUG_BREAK:
        DebugBreak();
        hr = S_OK;
        break;

    case IDM_DEBUG_VIEW:
        DbgExOpenViewObjectMonitor(_pInPlace->_hwnd, (IUnknown *)(IViewObject *) this, TRUE);
        hr = S_OK;
        break;

    case IDM_DEBUG_DUMPTREE:
        {
            if(_pElemCurrent->GetMarkup())
                _pElemCurrent->GetMarkup()->DumpTree();
            break;
        }
    case IDM_DEBUG_DUMPLINES:
        {
            CFlowLayout * pFlowLayout = _pElemCurrent->GetFirstBranch()->GetFlowLayout();
            if(pFlowLayout)
                pFlowLayout->DumpLines();
            break;
        }
    case IDM_DEBUG_DUMPDISPLAYTREE:
        GetView()->DumpDisplayTree();
        break;

    case IDM_DEBUG_DUMPFORMATCACHES:
        DumpFormatCaches();
        break;
    case IDM_DEBUG_DUMPLAYOUTRECTS:
        DumpLayoutRects();
        break;
    case IDM_DEBUG_DUMPRECALC:
        _recalcHost.Dump(0);
        break;
#endif

    case IDM_ADDFAVORITES:
        {
            CMarkup * pMarkup = NULL;

            if(pContextDocOrig)
            {
                pMarkup = pContextDocOrig->Markup();
            }
            else if(_pMenuObject)
            {
                hr = THR_NOTRACE(_pMenuObject->Exec(
                    pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                if(hr == S_OK)
                    break;

                pMarkup = _pMenuObject->GetMarkup();
            }
            else if(_pElemCurrent) //context was not directly specified and have currency
            {
                hr = THR_NOTRACE(_pElemCurrent->Exec(
                    pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                if(hr == S_OK)
                    break;

                pMarkup = _pElemCurrent->GetMarkup();
            }

            {
                // Add the current document to the favorite folder ...
                //
                TCHAR * pszURL;
                TCHAR * pszTitle;

                if(!pMarkup) pMarkup = pContextDoc->Markup();
                pszURL   = (TCHAR *) CMarkup::GetUrl(pMarkup);

                pszTitle = (pMarkup->GetTitleElement() && pMarkup->GetTitleElement()->Length())
                         ? (pMarkup->GetTitleElement()->GetTitle())
                         : (NULL);
                hr = AddToFavorites(pszURL, pszTitle);
            }
        }
        break;

#ifndef NO_HTML_DIALOG
    // provide the options object to the dialog code
    case IDM_FIND:
    case IDM_REPLACE:
        // we should not invoke the dialogs out of the dialog...
        if (!_fInHTMLDlg && nCmdexecopt != MSOCMDEXECOPT_DONTPROMPTUSER)
        {
            CVariant            cVarNull(VT_NULL);
            IDispatch      *    pDispOptions = NULL;
            CParentUndoUnit*    pCPUU = NULL;
            BSTR                bstrText = NULL;
            COptionsHolder *    pcoh = NULL;
            CDoc *              pDoc = this;
            int                 i;
            CMarkup *           pWindowedMarkupContext;

            CMarkup *           pMarkup =
            (pContextDocOrig ?
                pContextDocOrig->Markup() :
                ( _pMenuObject ?
                    _pMenuObject->GetMarkup() :
                    ( _pElemCurrent ?
                        _pElemCurrent->GetMarkup() :
                        pContextDoc->Markup())));

            pWindowedMarkupContext = pMarkup->GetWindowedMarkupContext();

            if (!pWindowedMarkupContext->HasWindow())
            {
                hr = S_OK;
                goto Cleanup_FindReplace;
            }

            pcoh = new COptionsHolder(pWindowedMarkupContext->Window()->Window());

            if (pcoh == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup_FindReplace;
            }

            // find RID string
            for (i = 0; i < ARRAY_SIZE(dlgInfo); ++i)
            {
                if (idm == dlgInfo[i].idm)
                    break;
            }
            Assert(i < ARRAY_SIZE(dlgInfo));

            if (dlgInfo[i].idsUndoText)
            {
                pCPUU = OpenParentUnit(this, dlgInfo[i].idsUndoText);
            }

            // get dispatch from stack variable
            hr = THR_NOTRACE(pcoh->QueryInterface(IID_IHTMLOptionsHolder,
                                     (void**)&pDispOptions));
            if (hr)
                goto Cleanup_FindReplace;

            // Save the execCommand argument so that the dialog can have acces
            // to them
            //
#ifdef _MAC     // casting so bad I left in the #ifdef
            pcoh->put_execArg(pvarargIn ? (VARIANT) * pvarargIn
                                        : *((VARIANT *) ((void *)&cVarNull)));
#else
            pcoh->put_execArg(pvarargIn ? (VARIANT) * pvarargIn
                                        : (VARIANT)   cVarNull);

#endif

            hr = THR(GetFindText(&bstrText));
            if (hr)
                goto Cleanup_FindReplace;

            // Set the findText argument for the dialog
            THR_NOTRACE(pcoh->put_findText(bstrText));
            FormsFreeString(bstrText);
            bstrText = NULL;

            if (idm == IDM_REPLACE)
            {
// TODO (dmitryt) at the moment (5.5 RTM) we don't have replace.dlg template in shdocvw.
//      IE5.0 didn't have either. This seems no to work at all. But if it does or will be,
//      _pElemCurrent should probably be replaced with pContextDoc...
                hr = THR(ShowModalDialogHelper(
                        _pElemCurrent->GetMarkup(),
                        dlgInfo[i].szidr,
                        pDispOptions,
                        pcoh));
                goto UIHandled;
            }

            // Fix for bug# 9136. (a-pauln)
            // make an adjustment for the bidi find dialog
            // if we are on a machine that supports bidi
            BOOL fbidi;
            fbidi = (idm == IDM_FIND && g_fBidiSupport);

            // Let host show find dialog
            VARIANT varIn;
            VARIANT varOut;

            V_VT(&varIn) = VT_DISPATCH;
            V_DISPATCH(&varIn) = pDispOptions;

            // The HTMLView object in Outlook 98 returns S_OK for all exec
            // calls, even those for which it should return OLECMD_E_NOTSUPPORTED.
            if (pDoc->_pHostUICommandHandler && !pDoc->_fOutlook98)
            {
                hr = pDoc->_pHostUICommandHandler->Exec(
                    &CGID_DocHostCommandHandler,
                    OLECMDID_SHOWFIND,
                    fbidi,
                    &varIn,
                    &varOut);

                if (!hr)
                    goto UIHandled;
            }

            // Let backup show find dialog
            pDoc->EnsureBackupUIHandler();
            if (pDoc->_pBackupHostUIHandler)
            {
                IOleCommandTarget * pBackupHostUICommandHandler;
                hr = pDoc->_pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                    (void **) &pBackupHostUICommandHandler);
                if (hr)
                    goto Cleanup_FindReplace;

                hr = THR(pBackupHostUICommandHandler->Exec(
                    &CGID_DocHostCommandHandler,
                    OLECMDID_SHOWFIND,
                    fbidi,
                    &varIn,
                    &varOut));
                ReleaseInterface(pBackupHostUICommandHandler);
            }

UIHandled:
Cleanup_FindReplace:
            // release dispatch, et al.
            ReleaseInterface(pcoh);
            ReleaseInterface(pDispOptions);

            if ( pCPUU )
            {
                IGNORE_HR(CloseParentUnit( pCPUU, hr ) );
            }
        }

        break;


    case IDM_PROPERTIES:
        {

            CDocument * pDocument = _pMenuObject ? _pMenuObject->GetMarkup()->Document() : pContextDoc;

            if (_pMenuObject && _pMenuObject->HasPages())
            {
                THR(ShowPropertyDialog(pDocument, 1, &_pMenuObject));
            }
            else if (!_pMenuObject && _pElemCurrent && _pElemCurrent->HasPages())
            {
                THR(ShowPropertyDialog(pDocument, 1, &_pElemCurrent));
            }
            else
            {
                THR(ShowPropertyDialog(pDocument, 0, NULL));
            }
            hr = S_OK;

        }

        break;
#endif // NO_HTML_DIALOG

    case IDM_MENUEXT_COUNT:
        if(!pvarargOut)
        {
            hr = E_INVALIDARG;
        }
        else if(!_pOptionSettings)
        {
            hr = OLECMDERR_E_DISABLED;
        }
        else
        {
            hr = S_OK;
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = _pOptionSettings->aryContextMenuExts.Size();
        }
        break;

    case IDM_RESPECTVISIBILITY_INDESIGN:
        {
            CMarkup* pMarkup = pContextDoc->Markup() ;
            Assert (pMarkup);

            if ( pvarargIn && pvarargIn->vt == VT_BOOL )
            {
                pMarkup->SetRespectVisibilityInDesign( ENSURE_BOOL(pvarargIn->bVal));
            }
            else
            {
                pMarkup->SetRespectVisibilityInDesign( ! pMarkup->IsRespectVisibilityInDesign());
            }

            if (pMarkup != PrimaryMarkup())
            {
                pMarkup->ForceRelayout();
            }
            else
            {
                ForceRelayout();
            }
        }
        break;

    case IDM_UNDO:
        hr = THR(EditUndo());
        break;

    case IDM_REDO:
        hr = THR(EditRedo());
        break;

    case IDM_SHDV_CANDOCOLORSCHANGE:
        {
            hr = S_OK;
            break;
        }

    case IDM_SHDV_CANSUPPORTPICS:
        if (!pvarargIn || (pvarargIn->vt != VT_UNKNOWN))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            SetPicsCommandTarget((IOleCommandTarget *)pvarargIn->punkVal);
            hr = S_OK;
        }
        break;

    case IDM_SHDV_ISDRAGSOURCE:
        if (!pvarargOut)
        {
            Assert(pvarargOut);
            hr = E_INVALIDARG;
        }
        else
        {
            pvarargOut->vt = VT_I4;
            V_I4(pvarargOut) = _fIsDragDropSrc;
            hr = S_OK;
        }
        break;

    case IDM_SHDV_WINDOWOPEN:
        _fNewWindowInit = TRUE;
        break;

#if !defined(WIN16) && !defined(WINCE) && !defined(NO_SCRIPT_DEBUGGER)
    case IDM_TOOLBARS:
    case IDM_STATUSBAR:
    case IDM_OPTIONS:
    case IDM_CREATESHORTCUT:
        {
        DWORD        CmdOptions;
        VARIANTARG * pVarIn;
        VARIANTARG   var;

        VariantInit(&var);                  // keep compiler happy

        nCommandID = ConvertSBCMDID(idm);
        CmdOptions = 0;
        if (idm == IDM_OPTIONS)
        {
            V_VT(&var) = VT_I4;
            V_I4(&var) = SBO_NOBROWSERPAGES;
            pVarIn   = &var;
        }
        else if (idm == IDM_CREATESHORTCUT)
        {
            CDocument *pDocument;
            GetExecDocument(&pDocument, _pMenuObject, pContextDoc);
            if (pDocument->Markup()->IsPrimaryMarkup())
            {
                pVarIn = NULL;
            }
            else
            {
                V_VT(&var) = VT_UNKNOWN;
                hr = pDocument->QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&var));
                if (hr)
                    goto Cleanup;
                pVarIn = &var;
            }
            CmdOptions = MSOCMDEXECOPT_PROMPTUSER;
        }
        else // IDM_TOOLBARS and IDM_STATUSBAR
        {
            V_VT(&var) = VT_I4;
            V_I4(&var) = MAKELONG(
                    (idm == IDM_TOOLBARS) ? (FCW_INTERNETBAR) : (FCW_STATUS),
                    SBSC_TOGGLE);
            pVarIn   = &var;
        }
        hr = THR(CTExec(
                _pInPlace->_pInPlaceSite,
                &CGID_Explorer,
                nCommandID,
                CmdOptions,
                pVarIn,
                0));
        if (V_VT(&var) == VT_UNKNOWN)
            ReleaseInterface(V_UNKNOWN(&var));
        }
        break;
#endif // !WIN16 && !WINCE

    case IDM_NEW:
    case IDM_OPEN:
    case IDM_SAVE:
        //  Bubble it out to the DocFrame

        switch(idm)
        {
        case IDM_NEW:
            nCommandID = OLECMDID_NEW;
            break;
        case IDM_OPEN:
            nCommandID = OLECMDID_OPEN;
            break;
        default:
            nCommandID = OLECMDID_SAVE;
            break;
        }
        hr = THR(CTExec(
            (IUnknown *)(_pInPlace ?
                (IUnknown *) _pInPlace->_pInPlaceSite : (IUnknown *) _pClientSite),
            NULL, nCommandID, 0, 0, 0));
        break;

#if DBG==1
    case IDM_DEBUG_SAVEHTML:
        idm = IDM_SAVEAS;
    // FALL THROUGH
#endif
    case IDM_SAVEAS:
        {
            // if _pElemCurrent is IFrame or Frame or Viewlinked weboc, Send saveas command it,
            if ( _pElemCurrent->Tag() == ETAG_IFRAME ||
                 _pElemCurrent->Tag() == ETAG_FRAME  ||
                 (   _pElemCurrent->Tag() == ETAG_OBJECT 
                  && (DYNCAST(CObjectElement,_pElemCurrent)->_fViewLinkedWebOC)) )
            {
                hr = THR_NOTRACE(_pElemCurrent->Exec(
                        pguidCmdGroup,
                        nCmdID,
                        nCmdexecopt,
                        pvarargIn,
                        pvarargOut));
            }

            // If frame does not handle the command or _pElemCurrent is not a frame
            // Save current document
            if (hr == OLECMDERR_E_NOTSUPPORTED)
            {
                // Pass it up to the host
                // If we don't have a _pHostUICommandHandler, then hr will remain OLECMDERR_E_NOTSUPPORTED
                if (    _pHostUICommandHandler
                && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
                )
                {
                    hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                }

                // Only do it ourselves if the host doesn't understand the CGID or the CMDid
                //
                if (FAILED(hr))
                {
                    TCHAR * pchPathName = NULL;
                    BOOL fShowUI = TRUE;

                    if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
                    {
                        pchPathName = V_BSTR(pvarargIn);
                    }

                    if (nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
                    {
                        MSOCMD msocmd;

                        msocmd.cmdf  = 0;
                        msocmd.cmdID = OLECMDID_ALLOWUILESSSAVEAS;
                        if (!THR(CTQueryStatus(_pInPlace->_pInPlaceSite, NULL, 1, &msocmd, NULL)))
                            fShowUI = !(msocmd.cmdf == MSOCMDSTATE_UP);
                    }

                    if (!fShowUI && !pchPathName)
                        hr = E_INVALIDARG;
                    else
                        hr = PromptSave(pContextDoc->Markup(), TRUE, fShowUI, pchPathName);
                }
            }

            if ( hr == S_FALSE )
            {
                hr = OLECMDERR_E_CANCELED;
            }
        }
        break;

    case IDM_SAVEASTHICKET:
        {
            if (!pvarargIn)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                CVariant cvarDocument;

                hr = THR(cvarDocument.CoerceVariantArg(pvarargIn, VT_UNKNOWN));
                if (SUCCEEDED(hr))
                {
                    hr = THR(SaveSnapshotHelper( V_UNKNOWN(&cvarDocument), true ));
                }
            }
        }
        break;

#ifndef NO_PRINT
    case IDM_PAGESETUP:

        // If we have a HostUICommandHandler, and the caller did NOT request no-UI, pass it up to the host
        // If we don't have a _pHostUICommandHandler, then hr will remain OLECMDERR_E_NOTSUPPORTED
        if (_pHostUICommandHandler
            && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
            && !_fOutlook98
            )
        {
            hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
        }

        // Only do it ourselves if the host doesn't understand the CGID or the CMDid
        //
        if (FAILED(hr))
        {
            // if they didn't handle it, use our backup (default)
            EnsureBackupUIHandler();
            if (_pBackupHostUIHandler)
            {
                IOleCommandTarget * pBackupHostUICommandHandler;
                VARIANT             varArgIn;
                CVariant            cvarEmpty;

                hr = _pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                                           (void **) &pBackupHostUICommandHandler);
                if (hr)
                    goto Cleanup;

                V_VT(&varArgIn) = VT_UNKNOWN;
                V_UNKNOWN(&varArgIn) = SetPrintCommandParameters(
                                GetHWND(),              // parentHWND
                                NULL, NULL, NULL, 0, 0, NULL, NULL, NULL,
                                this,
                                &cvarEmpty, _hDevNames, _hDevMode,
                                NULL, NULL, NULL,
                                PRINTTYPE_PAGESETUP);

                hr = pBackupHostUICommandHandler->Exec(
                            &CGID_DocHostCommandHandler,
                            IDM_TEMPLATE_PAGESETUP,
                            nCmdexecopt,
                            &varArgIn,
                            pvarargOut);

                VariantClear(&varArgIn);
                ReleaseInterface(pBackupHostUICommandHandler);

            }
            if ( hr == S_FALSE )
            {
                hr = OLECMDERR_E_CANCELED;
            }
        }
        break;

    case IDM_PRINTPREVIEW:
        // don't allow a recursive mess...
        if (!IsPrintDialog())
        {
            // Now set all the data for the delegation call
            //      if the varargin is a bstr, interpret it as a template name
            //      if the varargin is an array, use back-compat logic
            //----------------------------------------------------------------
            hr = PrintHandler(pContextDoc,
                              ((pvarargIn && V_VT(pvarargIn)==VT_BSTR) ?
                                (LPCTSTR)V_BSTR(pvarargIn) : NULL),
                               NULL,
                               0,
                               NULL,
                               nCmdexecopt,
                               pvarargIn,
                               pvarargOut,
                               TRUE);   //preview
            if (hr)
                goto Cleanup;

        }
        break;

    case IDM_SHOWPAGESETUP:
        hr = DelegateShowPrintingDialog(pvarargIn, FALSE);
        goto Cleanup;   // Preserve the hr... may be E_NOTIMPL, S_FALSE, &c...
        break;

    case IDM_SHOWPRINT:
        hr = DelegateShowPrintingDialog(pvarargIn, TRUE);
        goto Cleanup;   // Preserve the hr... may be E_NOTIMPL, S_FALSE, &c...
        break;

    case IDM_GETPRINTTEMPLATE:
        hr = S_OK;

        if (pvarargOut)
        {
            Assert(pContextDoc->Markup());
            V_VT(pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = pContextDoc->Markup()->IsPrintTemplate() ? VB_TRUE : VB_FALSE;
        }
        else
        {
            hr = E_POINTER;
        }
        break;

    case IDM_SETPRINTTEMPLATE:
        if (!pvarargIn || pvarargIn->vt != VT_BOOL)
        {
            hr = E_INVALIDARG;
            break;
        }

        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);

            pMarkup->SetPrintTemplate(ENSURE_BOOL(pvarargIn->bVal));
            pMarkup->SetPrintTemplateExplicit(TRUE);
        }

        hr = S_OK;
        break;

    case IDM_FIRE_PRINTTEMPLATEDOWN:
        // AppHack (greglett) (108234)
        // NT5 HtmlHelp does something in the onafterprint event which results in a ProgressChange.
        // They then use this ProgressChange to do something that may result in a print.
        // Thus, multiple print dialogs appear until they crash.
        // This hack delays the onafterprint event for HtmlHelp until the template is closing.
        if (g_fInHtmlHelp)
        {
            // This really should do *all* nested markups, but this is a hack, right?
            _fPrintEvent = TRUE;
            PrimaryMarkup()->Window()->Fire_onafterprint();
            _fPrintEvent = FALSE;
        }

    case IDM_FIRE_PRINTTEMPLATEUP:
        if (_pTridentSvc && pvarargIn && V_VT(pvarargIn) == VT_UNKNOWN && V_UNKNOWN(pvarargIn))
        {
            IHTMLWindow2 * pHtmlWindow = NULL;
            hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLWindow2, (void**)&pHtmlWindow);
            if (hr == S_OK)
            {
                ITridentService2 * pTridentSvc2 = NULL;

                hr = _pTridentSvc->QueryInterface(IID_ITridentService2, (void**)&pTridentSvc2);
                if (hr == S_OK)
                {

                    pTridentSvc2->FirePrintTemplateEvent(pHtmlWindow,
                                                         idm == IDM_FIRE_PRINTTEMPLATEUP
                                                            ?  DISPID_PRINTTEMPLATEINSTANTIATION
                                                            :  DISPID_PRINTTEMPLATETEARDOWN);
                    pTridentSvc2->Release();
                }
                pHtmlWindow->Release();
            }

            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;

    case IDM_SETPRINTHANDLES:
        // Safety check SAFEARRAY arguments...
        if (    pvarargIn
            &&  (V_VT(pvarargIn) == (VT_ARRAY | VT_HANDLE))
            &&  V_ARRAY(pvarargIn) )
        {
#if DBG==1
            Assert( SafeArrayGetDim(V_ARRAY(pvarargIn)) == 1
                &&  V_ARRAY(pvarargIn)->rgsabound[0].cElements == 2
                &&  V_ARRAY(pvarargIn)->rgsabound[0].lLbound == 0  );
#endif
            long lArg = 0;
            HGLOBAL hDN = NULL;
            HGLOBAL hDM = NULL;

            if (    SafeArrayGetElement(V_ARRAY(pvarargIn), &lArg, &hDN) == S_OK
                &&  SafeArrayGetElement(V_ARRAY(pvarargIn), &(++lArg), &hDM) == S_OK)
            {
                ReplacePrintHandles(hDN,hDM);
            }

            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;

    case IDM_EXECPRINT :  // comes from script ExecCommand
    case IDM_PRINT:       // comes from IOleCommandTarget
        if (!IsPrintDialog())
        {
            DWORD dwPrintFlags = 0;
            BOOL  fOutlook98 = _fOutlook98;

            //
            // if no-UI is requested from execCommand, then we better be a trusted Dialog, or an
            // HTA (which also use this bit); default handling of print templates uses trusted dialogs
            // window.print doesn't make this request
            //
            if (nCmdID == IDM_EXECPRINT && !_fInTrustedHTMLDlg)
            {
                nCmdexecopt &= ~OLECMDEXECOPT_DONTPROMPTUSER;

                if (pvarargIn && (V_VT(pvarargIn) == VT_I2))
                    V_I2(pvarargIn) &= ~PRINT_DONTBOTHERUSER;
            }
           
            //
            // Set up the printing flags
            //
            if (pvarargIn && V_VT(pvarargIn) == VT_I2)
                dwPrintFlags |= V_I2(pvarargIn);            
            if (nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
                dwPrintFlags |= PRINT_DONTBOTHERUSER;

            // NB: 68038 - _fOutlook98 is not set when we are printing the Outlook98 Today page.
            // So we use the "outday://" url to identify that we are in Outlook.  Even if somebody
            // else invents an "outday" protocol, they would still not run into this since no address
            // is specified after "outday://".
            if (!_fOutlook98)
            {
                const TCHAR * pchUrl = GetPrimaryUrl();

                if (pchUrl && *pchUrl && !_tcscmp(pchUrl, _T("outday://")))
                    _fOutlook98 = TRUE;
            }

            // Now set all the data for the delegation call
            //      if the varargin is a bstr, interpret it as a template name
            //      if the varargin is an I2, treat as flags (above)
            //      if the varargin is an array, use back-compat logic
            // Note that a BSTR and/or an array can contain a custom print template,
            // and should *NOT* be accessible from script.
            //----------------------------------------------------------------
            hr = PrintHandler( pContextDoc,
                               (idm == IDM_PRINT && pvarargIn && V_VT(pvarargIn)==VT_BSTR)                               
                                ? (LPCTSTR)V_BSTR(pvarargIn)
                                : NULL,
                               NULL,
                               dwPrintFlags,
                               (idm == IDM_PRINT && pvarargIn && V_ISARRAY(pvarargIn) && V_ISBYREF(pvarargIn))
                                     ? V_ARRAY(pvarargIn)
                                     : NULL,
                               nCmdexecopt, pvarargIn, pvarargOut,
                                FALSE
                               );
            if (hr)
                goto Cleanup;

            _fOutlook98 = fOutlook98;

            if ( hr == S_FALSE )
                hr = OLECMDERR_E_CANCELED;
        }

        break;

    case IDM_GETIPRINT:
        if (!pvarargOut || !pvarargIn)
            hr = E_POINTER;
        else if (V_VT(pvarargIn) != VT_I4)
            hr = E_INVALIDARG;
        else
        {
            CIPrintCollection * pipcData = NULL;
            long                nLen;

            hr = E_FAIL;
            V_VT(pvarargOut) = VT_NULL;
            Assert(pContextDoc);

            pipcData = new CIPrintCollection;
            if (!pipcData)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            switch (V_I4(pvarargIn))
            {
            case IPRINT_DOCUMENT:
                {
                    CWindow *pWindow = pContextDoc->Window();
                    if (    pWindow
                        &&  pWindow->_punkViewLinkedWebOC)
                    {
                        IDispatch   *pIDispDoc  = NULL;
                        IPrint      *pIPrint    = NULL;

                        if (GetWebOCDocument(pWindow->_punkViewLinkedWebOC, &pIDispDoc) == S_OK)
                        {
                            Assert(pIDispDoc);
                            pIDispDoc->QueryInterface(IID_IPrint, (void **) &pIPrint);
                        }

                        if (pIPrint)
                        {
                            pipcData->AddIPrint(pIPrint);
                        }

                        ReleaseInterface(pIDispDoc);
                        ReleaseInterface(pIPrint);
                    }
                }
                break;
            case IPRINT_ACTIVEFRAME:
                if (_pElemCurrent)
                {
                    CElement *pElemRoot = _pElemCurrent->GetMarkup()->Root();
                    if (pElemRoot->HasMasterPtr())
                    {
                        CElement *pFrame;

                        pFrame = pElemRoot->GetMasterPtr();
                        if (    pFrame->Tag() == ETAG_FRAME
                            ||  pFrame->Tag() == ETAG_IFRAME )
                        {
                            IPrint *pIPrint = NULL;
                            if (!DYNCAST(CFrameSite, pFrame)->GetIPrintObject(&pIPrint))
                            {
                                pipcData->AddIPrint(pIPrint);
                            }
                            ReleaseInterface(pIPrint);
                        }
                    }
                }
                break;
            case IPRINT_ALLFRAMES:
                {
                    CElement    *pElement   = NULL;
                    CMarkup     *pMarkup    = pContextDoc->Markup();

                    Assert(pMarkup);
                    if (pMarkup)
                    {
                        pElement = pMarkup->GetElementClient();
                        Assert(pElement);
                        if (pElement)
                        {
                            // NB: (greglett) Since this notification only collects CFrameElements and not IFrames, we only need
                            // to fire the notification if we have a frameset.
                            if (pElement->Tag() == ETAG_FRAMESET)
                            {
                                CNotification nf;
                                Assert(pElement->GetFirstBranch());

                                // Collect all IPrint objects from frames that consist of only IPrint objects.
                                nf.Initialize(NTYPE_COLLECT_IPRINT, pElement, pElement->GetFirstBranch(), pipcData, 0);

                                pMarkup->Notify(&nf);
                            }
                        }
                    }
                }
                break;
            }

            if (    !pipcData->get_length(&nLen)
                &&  nLen > 0)
            {
                pipcData->AddRef();
                V_VT(pvarargOut) = VT_UNKNOWN;
                V_UNKNOWN(pvarargOut) = pipcData;
            }

            pipcData->Release();

            hr = S_OK;
        }
        break;

    case IDM_UPDATEPAGESTATUS:
        if (    !pvarargIn
            ||  V_VT(pvarargIn) != VT_I4)
            hr = E_INVALIDARG;
        else
        {          
            if (_pClientSite)
            {
                IOleCommandTarget *pCommandTarget = NULL;

                hr = _pClientSite->QueryInterface(IID_IOleCommandTarget, (void**)&pCommandTarget);
                if  (!hr &&  pCommandTarget)
                {
                    // Pass it on to the host.
                    hr = pCommandTarget->Exec(&CGID_DocHostCommandHandler,
                                               OLECMDID_UPDATEPAGESTATUS,
                                               0,
                                               pvarargIn,
                                               0);
                }
                ReleaseInterface(pCommandTarget);
            }
            else
                hr = S_OK;

            // pagestatus indicates that we have finished and that the template is about to be closed
            if (V_I4(pvarargIn) == 0)
            {
                _cSpoolingPrintJobs--;

                if (   !_cSpoolingPrintJobs
                    && _fCloseOnPrintCompletion
                    && pContextDoc
                    && pContextDoc->Window())
                {
                    _fCloseOnPrintCompletion = FALSE;
                    pContextDoc->Window()->close();
                }
            }
        }
        break;

#endif // NO_PRINT


    case IDM_HELP_CONTENT:
        break;

#ifndef WIN16
    case IDM_HELP_ABOUT:

        ShowMessage(
                &result,
                MB_APPLMODAL | MB_OK,
                0,
                IDS_HELPABOUT_STRING,
                VER_PRODUCTVERSION,
#if DBG==1
                _T("\r\n"), g_achDLLCore
#else
                _T(""), _T("")
#endif
                );

        hr = S_OK;
        break;
#endif // !WIN16

#ifndef NO_EDIT
    case IDM_BROWSEMODE:
        hr = THR_NOTRACE(SetDesignMode(pContextDoc, htmlDesignModeOff));
        break;

    case IDM_EDITMODE:
        hr = THR_NOTRACE(SetDesignMode(pContextDoc, htmlDesignModeOn));
        break;
#endif // NO_EDIT

#ifndef NO_SCRIPT_DEBUGGER
    case IDM_BREAKATNEXT:
        if (g_pDebugApp)
            hr = THR(g_pDebugApp->CauseBreak());
        else
            hr = E_UNEXPECTED;
        break;

    case IDM_LAUNCHDEBUGGER:
        {
            CScriptCollection * pScriptCollection = PrimaryMarkup()->GetScriptCollection();

            if (pScriptCollection)
            {
                hr = THR(pScriptCollection->ViewSourceInDebugger());
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        break;
#endif // NO_SCRIPT_DEBUGGER

#ifndef WINCE

    case IDM_VIEWSOURCE:
    case IDM_VIEWPRETRANSFORMSOURCE:
        {
            CMarkup * pMarkup = NULL;

            // Determine the markup to execute the command on
            pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();
            if (pMarkup)
            {
                pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);
            }

            // Do nothing for non-HTML files
            if (!pMarkup || pMarkup->IsImageFile())
            {
                hr = S_OK;
                break;
            }

            // this is all because the @#$&*% shell team refuses to fix the fact that IDM_VIEWSOURCE
            // is not overridable by the aggregator via IOleCommandTarget. So the XML Mime viewer has to
            // go inside out and send VIEWPRETRANSFORMSOURCE.
            if (    idm == IDM_VIEWSOURCE
                &&  pMarkup->IsPrimaryMarkup()
                &&  IsAggregatedByXMLMime()
               )
            {
                IOleCommandTarget *pIOCT = NULL;
                HRESULT hr = THR(PunkOuter()->QueryInterface(IID_IOleCommandTarget, (void **)&pIOCT));
                if (hr)
                    break;
                if (!pIOCT) {
                    hr = E_POINTER;
                    break;
                }
                hr = THR(pIOCT->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                ReleaseInterface(pIOCT);
                break;
            }


#ifndef UNIX
            // TODO (MohanB) Do we still need this. Noone sets _fFramesetInBody!

            // If there's a frameset in the body, launch the
            // analyzer dialog.
            if (pMarkup->IsPrimaryMarkup() && _fFramesetInBody)
            {
                COptionsHolder *    pcoh            = NULL;
                IDispatch      *    pDispOptions    = NULL;
                TCHAR               achAnalyzeDlg[] = _T("analyze.dlg");

                pcoh = new COptionsHolder(_pWindowPrimary->Window());
                if (!pcoh)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup_ViewSource;
                }

                // get dispatch from stack variable
                hr = THR_NOTRACE(pcoh->QueryInterface(IID_IHTMLOptionsHolder,
                                     (void**)&pDispOptions));
                if (hr)
                    goto Cleanup_ViewSource;

                hr = THR(ShowModalDialogHelper(
                    PrimaryMarkup(),
                    achAnalyzeDlg,
                    pDispOptions, pcoh));
                if (hr)
                    goto Cleanup_ViewSource;

Cleanup_ViewSource:
                // release dispatch, et al.
                ReleaseInterface(pcoh);
                ReleaseInterface(pDispOptions);

            }
#endif

            {
                TCHAR   tszPath[MAX_PATH] = _T("\"");

                hr = THR(GetViewSourceFileName(&tszPath[1], pMarkup));

                if (hr)
                    break;

                StrCat(tszPath, _T("\""));

                InvokeEditor(tszPath);
            }
        }
        break;
#endif // WINCE

#ifndef WIN16
    case IDM_HELP_README:
        HKEY  hkey;
        LONG  lr, lLength;

        lr = RegOpenKey(
                HKEY_CLASSES_ROOT,
                TEXT("CLSID\\{25336920-03F9-11CF-8FD0-00AA00686F13}"),
                &hkey);

        if (lr == ERROR_SUCCESS)
        {
            TCHAR   szPathW[MAX_PATH];

            lLength = sizeof(szPathW);
            lr = RegQueryValue(
                    hkey,
                    TEXT("InprocServer32"),
                    szPathW,
                    &lLength);
            RegCloseKey(hkey);
            if (lr == ERROR_SUCCESS)
            {
                // Right now szPath contains the full path of fm30pad.exe
                // need to replace fm30pad.exe with m3readme.htm
                //
                TCHAR *pch;

                pch = _tcsrchr(szPathW, _T('\\'));
                if (pch)
                    *pch = 0;
                // TODO hardcoded filename string?  -Tomsn
                _tcscat(szPathW, _T("\\readme.htm"));

                // test whether m3readme.htm exists.
                //
                HANDLE hFileReadme;

                hFileReadme = CreateFile(
                        szPathW,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
                if (hFileReadme != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hFileReadme);
                    hr = THR(FollowHyperlink(szPathW));
                    if (!hr)
                        break;
                }
            }
        }
        break;
#endif // ndef WIN16

    case IDM_STOP:
        {
            CMarkup * pMarkup = pContextDoc->Markup();

            if (    pMarkup->HasWindow()
                &&  pMarkup->Window()->Window()->_pMarkupPending)
            {
                pMarkup->Window()->Window()->ReleaseMarkupPending(pMarkup->Window()->Window()->_pMarkupPending);
                hr = S_OK;
            }
            else if (   pvarargIn
                    &&  (VT_BOOL      == V_VT(pvarargIn))
                    &&  (VARIANT_TRUE == V_BOOL(pvarargIn)))
            {
                // Hard Stop
                //
                hr = THR(pMarkup->ExecStop(TRUE, FALSE));
            }
            else
            {
                // Soft Stop
                //
                hr = THR(pMarkup->ExecStop());
            }
        }
        break;

    case IDM_ENABLE_INTERACTION:
        if (!pvarargIn || (pvarargIn->vt != VT_I4))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            BOOL fEnableInteraction = pvarargIn->lVal;

            if (!!_fEnableInteraction != !!fEnableInteraction)
            {
                CNotification   nf;

                _fEnableInteraction = fEnableInteraction;
                if ( _pUpdateIntSink )
                    // don't bother drawing accumulated inval rgn if minimized
                    _pUpdateIntSink->_pTimer->Freeze( !fEnableInteraction );

                if (_fBroadcastInteraction)
                {
                    BOOL dirtyBefore = !!_lDirtyVersion;
                    nf.EnableInteraction1(PrimaryRoot());
                    BroadcastNotify(&nf);
                    //
                    // TODO ( marka ) - reset erroneous dirtying the document.
                    //
                    if ( ( ! dirtyBefore ) && ( _lDirtyVersion ) )
                        _lDirtyVersion = 0;
                }

                if (TLS(pImgAnim))
                    TLS(pImgAnim)->SetAnimState(
                        (DWORD_PTR) this,
                        fEnableInteraction ? ANIMSTATE_PLAY : ANIMSTATE_PAUSE);
            }
            hr = S_OK;
        }
        break;

    case IDM_ONPERSISTSHORTCUT:
        {
            INamedPropertyBag  *    pINPB = NULL;
            FAVORITES_NOTIFY_INFO   sni;
            CNotification           nf;

            // first put my information into the defualt structure
            // if this is the first call (top level document) then we want to
            // set the base url. for normal pages we are nearly done.  For
            // frameset pages, we need to compare domains for security purposes
            // and establish subdomains if necessary
            if (!pvarargIn ||
                (pvarargIn->vt != VT_UNKNOWN) ||
                !V_UNKNOWN(pvarargIn) )
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = THR_NOTRACE(V_UNKNOWN(pvarargIn)->QueryInterface(IID_INamedPropertyBag,
                                                                  (void **)&pINPB));
            if (hr)
                break;

            hr = THR(PersistFavoritesData(pContextDoc->Markup(), pINPB, (LPCWSTR)_T("DEFAULT")));
            if (hr)
            {
                ReleaseInterface((IUnknown*) pINPB);
                break;
            }

            // initialize the info strucuture
            sni.pINPB = pINPB;
            sni.bstrNameDomain = SysAllocString(_T("DOC"));
            if (sni.bstrNameDomain == NULL)
            {
                ReleaseInterface((IUnknown*) pINPB);
                hr = E_OUTOFMEMORY;
                break;
            }

            // then propogate the event to my children
            nf.FavoritesSave(pContextDoc->Markup()->Root(), &sni);
            BroadcastNotify(&nf);

            ClearInterface(&sni.pINPB);
            SysFreeString(sni.bstrNameDomain);
        }
        break;

    case IDM_REFRESH:
    case IDM_REFRESH_TOP:
    case IDM_REFRESH_TOP_FULL:
    case IDM_REFRESH_THIS:
    case IDM_REFRESH_THIS_FULL:
    {
        LONG lOleCmdidf;

        //
        // Give the container a chance to handle the refresh.
        //

        if (_pHostUICommandHandler)
        {
            hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler, idm, nCmdexecopt, pvarargIn, pvarargOut));
        }

        if (FAILED(hr))
        {
            COmWindowProxy * pOmWindowProxy = NULL;

            if (idm != IDM_REFRESH_TOP && idm != IDM_REFRESH_TOP_FULL)
            {
                // Get the markup of the nearest frame, if any. Otherwise use the primary markup.

                Assert(pContextDoc);

                CMarkup * pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();

                if (pMarkup)
                {
                    pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);
                }
                if (pMarkup)
                {
                    pOmWindowProxy = pMarkup->Window();
                }
            }
            if (!pOmWindowProxy)
            {
                pOmWindowProxy = _pWindowPrimary;
            }

            if (idm == IDM_REFRESH)
            {
                if (pvarargIn && pvarargIn->vt == VT_I4)
                    lOleCmdidf = pvarargIn->lVal;
                else
                    lOleCmdidf = OLECMDIDF_REFRESH_NORMAL;
            }
            else if (idm == IDM_REFRESH_TOP_FULL || idm == IDM_REFRESH_THIS_FULL)
            {
                lOleCmdidf = OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
            }
            else
            {
                lOleCmdidf = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
            }

            hr = GWPostMethodCall(pOmWindowProxy,
                                  ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                  lOleCmdidf, FALSE, "COmWindowProxy::ExecRefreshCallback");
        }

        break;
    }

    case IDM_CONTEXTMENU:
        {
            CMessage Message(
                    InPlace()->_hwnd,
                    WM_CONTEXTMENU,
                    (WPARAM) InPlace()->_hwnd,
                    MAKELPARAM(0xFFFF, 0xFFFF));
            hr = THR( Message.SetNodeHit(_pElemCurrent->GetFirstBranch()) );
            if( hr )
                goto Cleanup;
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
        }
        break;

    case IDM_GOBACKWARD:
    case IDM_GOFORWARD:
        if (_fDefView)
        {
            // 92970 -- Let ShDocVw handle web view navigations
            hr = FollowHistory(idm==IDM_GOFORWARD);
        }
        else
        {
            hr = Travel((idm == IDM_GOBACKWARD) ? -1 : 1);
        }
        break;

    case IDM_SHDV_SETPENDINGURL:
        if (!pvarargIn || (pvarargIn->vt != VT_BSTR) || (pvarargIn->bstrVal == NULL))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            hr = SetUrl(pContextDoc->Markup(), pvarargIn->bstrVal);
        }
        break;

#ifdef DEADCODE // The command makes sense, but this is a wrong way to apply zoom to a document
                // We don't support body zoom in IE 5.5, so let's disable it until it is used.
    case IDM_ZOOMPERCENT:
        if (pvarargIn && (VT_I4 == V_VT(pvarargIn)))
        {
            int iZoomPercent = V_I4(pvarargIn);

            GetView()->SetZoomPercent(iZoomPercent);

            hr = S_OK;
        }
        break;
#endif

    // JuliaC -- This is hack for InfoViewer's "Font Size" toolbar button
    // For details, please see bug 45627
    case IDM_INFOVIEW_ZOOM:

        if (pvarargIn && (VT_I4 == V_VT(pvarargIn)))
        {
            int iZoom;

            iZoom = V_I4(pvarargIn);

            if (iZoom < (long) BASELINEFONTMIN || iZoom > (long) BASELINEFONTMAX)
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = ExecHelper(pContextDoc,
                    (GUID *)&CGID_MSHTML,
                    iZoom + IDM_BASELINEFONT1,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    NULL);
            if (hr)
                break;
        }

        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = (long) _sBaselineFont;
        }

        hr = S_OK;
        break;

    case IDM_INFOVIEW_GETZOOMRANGE:

        V_VT(pvarargOut) = VT_I4;
        V_I4(pvarargOut) = MAKELONG((SHORT)BASELINEFONTMIN, (SHORT)BASELINEFONTMAX);

        hr = S_OK;
        break;
    // End of hack for InfoViewer's "Font Size" toolbar button

    case IDM_BASELINEFONT1:
    case IDM_BASELINEFONT2:
    case IDM_BASELINEFONT3:
    case IDM_BASELINEFONT4:
    case IDM_BASELINEFONT5:
    {
        CODEPAGESETTINGS * pCodepageSettings = _pElemCurrent->GetWindowedMarkupContext()->GetCodepageSettings();
#if 0
        BOOL f12   = !!(GetKeyState(VK_F12)     & 0x8000);
        BOOL fCtrl = !!(GetKeyState(VK_CONTROL) & 0x8000);
        extern BOOL g_fUseHR;
        
        if (!(f12 && fCtrl && g_fUseHR && g_fInExplorer))
#endif
        {
            //
            // depend on that IDM_BASELINEFONT1, IDM_BASELINEFONT2,
            // IDM_BASELINEFONT3, IDM_BASELINEFONT4, IDM_BASELINEFONT5 to be
            // consecutive integers.
            //
            if (_sBaselineFont != (short)(idm - IDM_BASELINEFONT1 + BASELINEFONTMIN))
            {
                // {keyroot}\International\Scripts\{script-id}\IEFontSize

                static TCHAR * s_szScripts = TEXT("\\Scripts");
                const TCHAR * szSubKey = _pOptionSettings->fUseCodePageBasedFontLinking
                                         ? L""
                                         : s_szScripts;

                DWORD dwFontSize = (idm - IDM_BASELINEFONT1 + BASELINEFONTMIN);
                TCHAR *pchPath, *pch;
                int cch0 = _tcslen(_pOptionSettings->achKeyPath);
                int cch1 = _tcslen(s_szPathInternational);
                int cch2 = _tcslen(szSubKey);

                pchPath = pch = new TCHAR[cch0 + cch1 + cch2 + 1 + 10 + 1];

                if (pchPath)
                {
                    ULONG ulArg = _pOptionSettings->fUseCodePageBasedFontLinking
                                  ? ULONG(pCodepageSettings->uiFamilyCodePage)
                                  : ULONG(RegistryAppropriateSidFromSid(DefaultSidForCodePage(pCodepageSettings->uiFamilyCodePage)));

                    StrCpy( pch, _pOptionSettings->achKeyPath );
                    pch += cch0;
                    StrCpy( pch, s_szPathInternational );
                    pch += cch1;
                    StrCpy( pch, szSubKey );
                    pch += cch2;
                    *pch++ = _T('\\');
                    _ultot(ulArg, pch, 10);

                    IGNORE_HR( SHSetValue(HKEY_CURRENT_USER, pchPath, TEXT("IEFontSize"),
                                          REG_BINARY, (void *)&dwFontSize, sizeof(dwFontSize)) );

                    delete [] pchPath;
                }
            }

            _sBaselineFont = pCodepageSettings->sBaselineFontDefault =
                        (short)(idm - IDM_BASELINEFONT1 + BASELINEFONTMIN);

#ifdef UNIX
            g_SelectedFontSize = _sBaselineFont; // save the selected font size for new CDoc.
#endif
        }
#if 0
        {
            static LONG g_res[] = {65, 72, 96, 133, 150};
            g_uiDisplay.SetResolution(g_res[idm - IDM_BASELINEFONT1], g_res[idm - IDM_BASELINEFONT1]);
            
            _sBaselineFont = pCodepageSettings->sBaselineFontDefault =
                (short)(IDM_BASELINEFONT3 - IDM_BASELINEFONT1 + BASELINEFONTMIN);
        }
#endif        

        _pElemCurrent->GetMarkup()->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
        ForceRelayout();

        {   // update font history version number
            THREADSTATE * pts = GetThreadState();
            pts->_iFontHistoryVersion++;
        }

        // Send this command to our children
        {
            COnCommandExecParams cmdExecParams;
            cmdExecParams.pguidCmdGroup = pguidCmdGroup;
            cmdExecParams.nCmdID        = nCmdID;
            CNotification   nf;

            nf.Command(PrimaryRoot(), &cmdExecParams);
            BroadcastNotify(&nf);
        }

        //
        // tell shell to apply this exec to applicable explorer bars
        //
        IGNORE_HR(CTExec(
                _pInPlace ?
                (IUnknown *) _pInPlace->_pInPlaceSite : (IUnknown *) _pClientSite,
                &CGID_ExplorerBarDoc, nCmdID, 0, 0, 0));

        hr             = S_OK;
        break;
    }
    
    // Complex Text for setting default document reading order
    case IDM_DIRLTR:
    case IDM_DIRRTL:
    {
        //
        // TODO: In the future, we should move these two commands
        // into editor code. [zhenbinx]
        //
        CDocument * pDocument;
        CParentUndoUnit *pCPUU = NULL;

        pCPUU = OpenParentUnit(this, IDS_UNDOGENERICTEXT);
        hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
        if (SUCCEEDED(hr))
        {
            hr = pDocument->SetDocDirection((IDM_DIRLTR == idm) ? htmlDirLeftToRight : htmlDirRightToLeft);
        }
        IGNORE_HR( CloseParentUnit(pCPUU, hr) );
        break;
    }

    case IDM_SHDV_MIMECSETMENUOPEN:
    // this case is probably dead code -- jeffwall 04/05/00
        if (pvarargIn)
        {
            int nIdm;
            CODEPAGE cp = PrimaryMarkup()->GetCodePage();
            BOOL fDocRTL = FALSE;           // keep compiler happy
            Assert(pvarargIn->vt == VT_I4);

            CDocument * pDocument;

            hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
            if (SUCCEEDED(hr))
            {
                hr = THR(pDocument->GetDocDirection(&fDocRTL));
            }
            if (hr == S_OK)
            {
                hr = THR(ShowMimeCSetMenu(_pOptionSettings, &nIdm, cp,
                                           pvarargIn->lVal,
                                           fDocRTL, IsCpAutoDetect()));

                if (hr == S_OK)
                {
                    if (nIdm >= IDM_MIMECSET__FIRST__ && nIdm <= IDM_MIMECSET__LAST__)
                    {
                        idm = nIdm;     // handled below
                    }
                    else if (nIdm == IDM_DIRLTR || nIdm == IDM_DIRRTL)
                    {
                        ExecHelper(pContextDoc, (GUID *)&CGID_MSHTML, nIdm, 0, NULL, NULL);
                    }

                }
            }
        }
        break;

    case IDM_SHDV_FONTMENUOPEN:
        if (pvarargIn)
        {
            int nIdm;
            Assert(pvarargIn->vt == VT_I4);

            hr = THR(ShowFontSizeMenu(&nIdm, _sBaselineFont,
                                       pvarargIn->lVal));

            if (hr == S_OK)
            {
                if ( (nIdm >= IDM_BASELINEFONT1 && nIdm <= IDM_BASELINEFONT5) )
                {
                    ExecHelper(pContextDoc, (GUID *)&CGID_MSHTML, nIdm, 0, NULL, NULL);
                }
            }
        }
        break;

    case IDM_SHDV_GETMIMECSETMENU:
        if (pvarargOut)
        {
            BOOL fDocRTL = FALSE;           // keep compiler happy

            V_VT(pvarargOut) = VT_INT_PTR;

            CDocument * pDocument;

            hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
            if (SUCCEEDED(hr))
            {
                hr = THR(pDocument->GetDocDirection(&fDocRTL));
            }
            if (hr == S_OK)
            {
                CMarkup * pMarkup = pDocument->Markup();
                V_BYREF(pvarargOut) = GetEncodingMenu(_pOptionSettings, pMarkup->GetCodePage(), fDocRTL, IsCpAutoDetect());

                hr = V_BYREF(pvarargOut) ? S_OK: S_FALSE;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_SHDV_GETFONTMENU:
        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = HandleToLong(GetFontSizeMenu(_sBaselineFont));

            hr = V_I4(pvarargOut)? S_OK: S_FALSE;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_SHDV_GETDOCDIRMENU:
        if (pvarargOut)
        {
            BOOL fDocRTL = FALSE;               // keep compiler happy
            CDocument * pDocument;

            hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
            if (SUCCEEDED(hr))
            {
                hr = THR(pDocument->GetDocDirection(&fDocRTL));
            }

            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = HandleToLong(GetOrAppendDocDirMenu(PrimaryMarkup()->GetCodePage(), fDocRTL));
            hr = V_I4(pvarargOut)? S_OK: OLECMDERR_E_DISABLED;
        }
        else
        {
            hr = E_INVALIDARG;
        }
         break;

    case IDM_SHDV_DOCCHARSET:
    case IDM_SHDV_DOCFAMILYCHARSET:
        // Return the family or actual charset for the doc
        if (pvarargOut)
        {
            UINT uiCodePage = idm == IDM_SHDV_DOCFAMILYCHARSET ?
                              WindowsCodePageFromCodePage(PrimaryMarkup()->GetCodePage()) :
                              PrimaryMarkup()->GetCodePage();

            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = uiCodePage;

            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
        break;

    case IDM_GETFRAMEZONE:
        if (!pvarargOut)
        {
            hr = E_POINTER;
        }
        else
        {
            if (_pWindowPrimary)
            {
                hr = THR(_pWindowPrimary->Markup()->GetFrameZone(pvarargOut));
            }

            if (hr || !_pWindowPrimary)
            {
                V_VT(pvarargOut) = VT_EMPTY;
            }
        }
        break;
        // Support for Context Menu Extensions
    case IDM_SHDV_ADDMENUEXTENSIONS:
        {
            if (   !pvarargIn  || (pvarargIn->vt  != VT_INT_PTR)
                || !pvarargOut || (pvarargOut->vt != VT_I4)
                )
            {
                Assert(pvarargIn);
                hr = E_INVALIDARG;
            }
            else
            {
                HMENU hmenu = (HMENU) V_BYREF(pvarargIn);
                int   id    = V_I4(pvarargOut);
                hr = THR(InsertMenuExt(hmenu, id));
            }
        }
        break;

    case IDM_RUNURLSCRIPT:
        // This enables us to run scripts inside urls on the
        // current document. The Variant In parameter is an URL.
        if (!pvarargIn || pvarargIn->vt != VT_BSTR)
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);

            // get dispatch for the markup's window
            //
            IDispatch * pDispWindow = (IHTMLWindow2*)(pMarkup->Window()->Window());
            Assert(pDispWindow);

            // bring up the dialog
            //
            hr = THR(ShowModalDialogHelper(
                    pMarkup,
                    pvarargIn->bstrVal,
                    pDispWindow,
                    NULL,
                    NULL,
                    HTMLDLG_NOUI | HTMLDLG_AUTOEXIT));
        }
        break;

    case IDM_HTMLEDITMODE:
        if (!pvarargIn || (pvarargIn->vt != VT_BOOL))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            GUID guidCmdGroup = CGID_MSHTML;
            _fInHTMLEditMode = !!V_BOOL(pvarargIn);

            IGNORE_HR(Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, pvarargIn, NULL));
            hr = S_OK;
        }
        break;

    case IDM_REGISTRYREFRESH:
        IGNORE_HR(OnSettingsChange());
        break;

    case IDM_DEFAULTBLOCK:
        if (pvarargIn)
        {
            hr = THR(SetupDefaultBlockTag(pvarargIn));
            if (S_OK == hr)
            {
                CNotification   nf;

                nf.EditModeChange(CMarkup::GetElementTopHelper(PrimaryMarkup()));
                BroadcastNotify(&nf);
            }
        }
        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_BSTR;
            if (GetDefaultBlockTag() == ETAG_DIV)
                V_BSTR(pvarargOut) = SysAllocString(_T("DIV"));
            else
                V_BSTR(pvarargOut) = SysAllocString(_T("P"));
            hr = S_OK;
        }

        break;

    case OLECMDID_ONUNLOAD:
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);
            Assert(pMarkup->Window());

            BOOL fRetval = pMarkup->Window()->Fire_onbeforeunload();

            hr = S_OK;
            if (pvarargOut)
            {
               V_VT  (pvarargOut) = VT_BOOL;
               V_BOOL(pvarargOut) = VARIANT_BOOL_FROM_BOOL(fRetval);
            }
        }
        break;

    case OLECMDID_DONTDOWNLOADCSS:
        {
            if (DesignMode())
                _fDontDownloadCSS = TRUE;
            hr = S_OK;
        }
        break;

    case IDM_GETBYTESDOWNLOADED:
        if (!pvarargOut)
        {
            hr = E_POINTER;
        }
        else
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);

            CDwnDoc * pDwnDoc = pMarkup->GetDwnDoc();

            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = pDwnDoc ? pDwnDoc->GetBytesRead() : 0;
        }
        break;

    case IDM_PERSISTSTREAMSYNC:
        _fPersistStreamSync = TRUE;
        hr = S_OK;
        break;

    case IDM_OVERRIDE_CURSOR:
        {
            CMarkup* pMarkup = pContextDoc->Markup() ;
            Assert (pMarkup);
            BOOL fSet;
            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
            {
                fSet = !( CHECK_EDIT_BIT( pMarkup, _fOverrideCursor));      // If the argument value is not bool, just toggle the flag
            }
            else
            {
                fSet = ENSURE_BOOL(pvarargIn->bVal);
            }
            SET_EDIT_BIT( pMarkup,_fOverrideCursor , fSet );

            hr = S_OK;
        }
        break;

    case IDM_PEERHITTESTSAMEINEDIT:
        _fPeerHitTestSameInEdit = !_fPeerHitTestSameInEdit;
        hr = S_OK;
        break;

    case IDM_SHOWZEROBORDERATDESIGNTIME:
    case IDM_NOFIXUPURLSONPASTE:
        {
            BOOL fSet = FALSE;
            CMarkup* pMarkup = pContextDoc->Markup();
            Assert (pMarkup);

            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
            {
                fSet = !(pMarkup->IsShowZeroBorderAtDesignTime());      // If the argument value is not bool, just toggle the flag
            }
            else
            {
                fSet = ENSURE_BOOL(pvarargIn->bVal);
            }


            if (idm == IDM_SHOWZEROBORDERATDESIGNTIME)
            {
                pMarkup->SetShowZeroBorderAtDesignTime(fSet);
                CNotification nf;
                nf.ZeroGrayChange(CMarkup::GetElementTopHelper(pMarkup));
                BroadcastNotify( & nf );
                Invalidate();
            }
            else
            {
                _fNoFixupURLsOnPaste = fSet;
            }

            hr = S_OK;
            _pOptionSettings->dwMiscFlags = _dwMiscFlags();

            CElement *pElement = CMarkup::GetElementClientHelper(pMarkup);
            //
            // TODO marka - is this supposed to be doing an invalidate ?
            //
            if (pElement)
                pElement->ResizeElement(NFLAGS_FORCE);

            // Send this command to our children
            {
                COnCommandExecParams cmdExecParams;
                cmdExecParams.pguidCmdGroup = pguidCmdGroup;
                cmdExecParams.nCmdID        = nCmdID;
                CNotification   nf;

                if (idm == IDM_SHOWZEROBORDERATDESIGNTIME)
                    nf.Command(pMarkup->Root(), &cmdExecParams);
                else
                    nf.Command(PrimaryRoot(), &cmdExecParams);
                BroadcastNotify(&nf);
            }
            break;
        }

    case IDM_SHOWALLTAGS:
    case IDM_SHOWALIGNEDSITETAGS:
    case IDM_SHOWSCRIPTTAGS:
    case IDM_SHOWSTYLETAGS:
    case IDM_SHOWCOMMENTTAGS:
    case IDM_SHOWAREATAGS:
    case IDM_SHOWUNKNOWNTAGS:
    case IDM_SHOWMISCTAGS:
    case IDM_SHOWWBRTAGS:
       {
            //
            //  TODO: cleanup these flags [ashrafm]
            //
            CVariant    var;
            BOOL        fSet = FALSE;
            CGlyph      *pTable = pContextDoc->Markup()->GetGlyphTable();

            if (pvarargIn)
            {
                if(pvarargIn->vt != VT_BOOL)
                    break;
                fSet = ENSURE_BOOL(V_BOOL(pvarargIn));
            }
            else
            {
                if( pTable )
                {
                    switch(idm)
                    {
                        case IDM_SHOWALIGNEDSITETAGS:
                            fSet = !pTable->_fShowAlignedSiteTags; break;
                        case IDM_SHOWSCRIPTTAGS:
                            fSet = !pTable->_fShowScriptTags; break;
                        case IDM_SHOWSTYLETAGS:
                            fSet = !pTable->_fShowStyleTags; break;
                        case IDM_SHOWCOMMENTTAGS:
                            fSet = !pTable->_fShowCommentTags; break;
                        case IDM_SHOWAREATAGS:
                            fSet = !pTable->_fShowAreaTags; break;
                        case IDM_SHOWMISCTAGS:
                            fSet = !pTable->_fShowMiscTags; break;
                        case IDM_SHOWUNKNOWNTAGS:
                            fSet = !pTable->_fShowUnknownTags; break;
                        case IDM_SHOWWBRTAGS:
                            fSet = !pTable->_fShowWbrTags; break;
                        case IDM_SHOWALLTAGS:
                            fSet = !( pTable->_fShowWbrTags     && pTable->_fShowUnknownTags    &&
                                      pTable->_fShowMiscTags    && pTable->_fShowAreaTags       &&
                                      pTable->_fShowCommentTags && pTable->_fShowStyleTags      &&
                                      pTable->_fShowScriptTags  && pTable->_fShowAlignedSiteTags );
                            break;
                        default:Assert(0);
                    }
                }
                else
                {
                    // No glyph table yet... so turn on the option (this will create the
                    // glyph table )
                    fSet = TRUE;
                }
                V_VT(&var) = VT_BOOL;
                V_BOOL(&var) = VARIANT_BOOL_FROM_BOOL(fSet);

                pvarargIn = &var;
            }

            //
            // HACKHACK: EnsureGlyphTableExistsAndExecute should be able to delete from the table
            //
            if (!fSet && (idm == IDM_SHOWALLTAGS || idm == IDM_SHOWMISCTAGS))
            {
                // Empty the glyph table
                idm = IDM_EMPTYGLYPHTABLE;
            }

            hr = pContextDoc->Markup()->EnsureGlyphTableExistsAndExecute(
                                                    pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);
            if (hr)
                break;

            if( idm != IDM_EMPTYGLYPHTABLE )
            {
                //
                // If we empty'd the table, then of course won't need to reset
                // any of the flags.
                //
                pTable = pContextDoc->Markup()->GetGlyphTable();
                Assert( pTable );

                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWALIGNEDSITETAGS)
                    pTable->_fShowAlignedSiteTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWSCRIPTTAGS)
                    pTable->_fShowScriptTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWSTYLETAGS)
                    pTable->_fShowStyleTags =  fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWCOMMENTTAGS)
                    pTable->_fShowCommentTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWAREATAGS)
                    pTable->_fShowAreaTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWMISCTAGS)
                    pTable->_fShowMiscTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWUNKNOWNTAGS)
                    pTable->_fShowUnknownTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWWBRTAGS)
                    pTable->_fShowWbrTags = fSet;
            }

            break;
        }

    case IDM_ADDTOGLYPHTABLE:
    case IDM_REMOVEFROMGLYPHTABLE:
    case IDM_REPLACEGLYPHCONTENTS:
        {
            if (!pvarargIn->bstrVal)
                break;

            hr = pContextDoc->Markup()->EnsureGlyphTableExistsAndExecute(
                                                    pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);
            break;
        }
    case IDM_EMPTYGLYPHTABLE:
        {
            hr = pContextDoc->Markup()->EnsureGlyphTableExistsAndExecute(
                                                    pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);
            break;
        }
    case IDM_NOACTIVATENORMALOLECONTROLS:
    case IDM_NOACTIVATEDESIGNTIMECONTROLS:
    case IDM_NOACTIVATEJAVAAPPLETS:
        {
            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
                break;

            BOOL fSet = ENSURE_BOOL(pvarargIn->bVal);

            if (idm == IDM_NOACTIVATENORMALOLECONTROLS)
                _fNoActivateNormalOleControls = fSet;
            else if (idm == IDM_NOACTIVATEDESIGNTIMECONTROLS)
                _fNoActivateDesignTimeControls = fSet;
            else
                _fNoActivateJavaApplets = fSet;

            _pOptionSettings->dwMiscFlags = _dwMiscFlags();

            hr = S_OK;
            fRouteToEditor = TRUE;
            break;
        }

    case IDM_SETDIRTY:
        if (!pvarargIn || pvarargIn->vt != VT_BOOL)
        {
            hr = E_INVALIDARG;
            break;
        }

        hr = THR(SetDirtyFlag(ENSURE_BOOL(pvarargIn->bVal)));
        break;

    case IDM_PRESERVEUNDOALWAYS:
        if (pvarargIn && pvarargIn->vt == VT_BOOL)
        {
            TLS( fAllowParentLessPropChanges ) = pvarargIn->boolVal;

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_PERSISTDEFAULTVALUES:
        if(pvarargIn && pvarargIn->vt == VT_BOOL)
        {
            TLS( fPersistDefaultValues ) = pvarargIn->boolVal;

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_PROTECTMETATAGS:
        if(pvarargIn && pvarargIn->vt == VT_BOOL)
        {
            _fDontWhackGeneratorOrCharset = pvarargIn->boolVal;

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_WAITFORRECALC:
    {
        // This private command is issued by MSHTMPAD to force background recalc to
        // finish so that accurate timings can be measured.

        WaitForRecalc(pContextDoc->Markup());
        hr = S_OK;
        break;
    }

    case IDM_GETSWITCHTIMERS:
    {
#ifdef SWITCHTIMERS_ENABLED
        // This private command is issued by MSHTMPAD to collect detailed timing information.
        void AnsiToWideTrivial(const CHAR * pchA, WCHAR * pchW, LONG cch);
        char ach[256];
        SwitchesGetTimers(ach);
        AnsiToWideTrivial(ach, pvarargOut->bstrVal, lstrlenA(ach));
#endif
        hr = S_OK;
        break;
    }

    case IDM_DWNH_SETDOWNLOAD:
        if (pvarargIn && pvarargIn->vt == VT_UNKNOWN)
        {
            hr = THR(SetDownloadNotify(pvarargIn->punkVal));
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_SAVEPICTURE:
        if (!_pMenuObject)
        {
            //
            // only do work here if there is no menu object, and there an
            // image on this document.  This is here to handle saveAs on a
            // file://c:/temp/foo.gif type document url.  If for some reason
            // this IDM comes through on a non-image document, we will try to
            // save the first image in the images collection instead.  If there
            // isn't one, then we fail,
            //
            CElement          * pImg = NULL;
            CCollectionCache  * pCollectionCache = NULL;
            CMarkup           * pMarkup = _pElemCurrent->GetMarkup();

            hr = THR(pMarkup->EnsureCollectionCache(CMarkup::IMAGES_COLLECTION));
            if (!hr)
            {
                pCollectionCache = pMarkup->CollectionCache();

                hr = THR(pCollectionCache->GetIntoAry(CMarkup::IMAGES_COLLECTION, 0, &pImg));
                if (!hr)
                {
                    Assert(pImg);

                    hr = THR_NOTRACE(pImg->Exec(pguidCmdGroup,
                                        nCmdID,
                                        nCmdexecopt,
                                        pvarargIn,
                                        pvarargOut));
                }
            }
            if (hr)
                hr = OLECMDERR_E_NOTSUPPORTED;
        }
        break;

    case IDM_SAVEPRETRANSFORMSOURCE:
        Assert(pContextDoc->Markup());
        if (!pvarargIn || (pvarargIn->vt != VT_BSTR) || !V_BSTR(pvarargIn) )
            hr = E_INVALIDARG;
        else
        {
            hr = SavePretransformedSource(pContextDoc->Markup(), V_BSTR(pvarargIn));
        }
        break;
    case IDM_UNLOADDOCUMENT:
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert( pMarkup );
            if( pMarkup->IsConnectedToPrimaryMarkup() )
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                Assert( !pMarkup->IsConnectedToPrimaryWorld() );
                pMarkup->TearDownMarkup();
                hr = S_OK;
            }
        }
        break;

    case IDM_TRUSTAPPCACHE:
        {
            BOOL fSet;
            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
            {
                fSet = !( _fTrustAPPCache );      // If the argument value is not bool, just toggle the flag
            }
            else
            {
                fSet = ENSURE_BOOL(pvarargIn->bVal);
            }

            _fTrustAPPCache = fSet;

            hr = S_OK;
        }
        break;

    case IDM_BACKGROUNDIMAGECACHE:
        if (!pvarargIn || pvarargIn->vt != VT_BOOL)
        {
            hr = E_INVALIDARG;
        } 
        else
        {
            _fBackgroundImageCache = ENSURE_BOOL(pvarargIn->bVal);
            hr = S_OK;
        }
        break;

	case IDM_CLEARAUTHENTICATIONCACHE:
        hr = InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0) ? 
            S_OK : E_FAIL;
        break;

#if DBG==1
    case IDM_DEBUG_GETTREETEXT:
        {
            IStream * pStream = NULL;

            if (!pvarargIn ||
                (pvarargIn->vt != VT_UNKNOWN) ||
                !V_UNKNOWN(pvarargIn) )
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = THR_NOTRACE(V_UNKNOWN(pvarargIn)->QueryInterface(IID_IStream,
                                                                  (void **)&pStream));
            if (hr)
                break;

            hr = THR_NOTRACE(SaveToStream( pStream, 0, CP_1252 ));

            ReleaseInterface((IUnknown*) pStream);
        }
        break;
#endif
    }

    if(FAILED(hr) && hr != OLECMDERR_E_NOTSUPPORTED)
        goto Cleanup;

#ifndef NO_MULTILANG
    if( idm >= IDM_MIMECSET__FIRST__ && idm <= IDM_MIMECSET__LAST__)
    {
        CODEPAGE cp = GetCodePageFromMenuID(idm);
        THREADSTATE * pts = GetThreadState();

        // assigning IDM_MIMECSET__LAST__ to CpAutoDetect mode
        if ( cp == CP_UNDEFINED && idm == IDM_MIMECSET__LAST__ )
        {
            SetCpAutoDetect(!IsCpAutoDetect());

            if (IsCpAutoDetect() && mlang().IsMLangAvailable())
            {
                // we need the same refreshing effect as the regular cp
                cp = CP_AUTO;
            }
        }

        // NB (cthrash) ValidateCodePage allows us to JIT download a language pack.
        // If we don't have IMultiLanguage2, JIT downloadable codepages will not
        // appear in the language menu (ie only codepages currently available on
        // the system will be provided as options) and thus ValidateCodePage
        // is not required.

        if (   CP_UNDEFINED != cp
#ifndef UNIX
            && S_OK == mlang().ValidateCodePage(g_cpDefault, cp, _pInPlace->_hwnd, TRUE, _dwLoadf & DLCTL_SILENT)
#endif
            )
        {
            CMarkup * pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();

            pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);

            if (pMarkup)
            {
                CRootElement * pRoot = pMarkup->Root();

                CNotification nf;
                nf.Initialize(NTYPE_SET_CODEPAGE, pRoot, pRoot->GetFirstBranch(), (void *)(UINT_PTR)cp, 0);

                // if AutoDetect mode is on, we don't make a change
                // to the default codepage for the document
                if (!IsCpAutoDetect() && !pMarkup->HaveCodePageMetaTag())
                {
                    // [review]
                    // here we save the current setting to the registry
                    // we should find better timing to do it
                    SaveDefaultCodepage(cp);
                }

                BroadcastNotify(&nf);

                // Bubble down code page to nested documents
                pMarkup->BubbleDownCodePage(cp);

                IGNORE_HR(pMarkup->Window()->ExecRefresh());
            }
        }
        pts->_iFontHistoryVersion++;
        hr = S_OK;
    }
#endif // !NO_MULTLANG

    if (hr == OLECMDERR_E_NOTSUPPORTED)
    {
        ctarg.pguidCmdGroup = pguidCmdGroup;
        ctarg.fQueryStatus = FALSE;
        ctarg.pexecArg = &execarg;
        execarg.nCmdID = nCmdID;
        execarg.nCmdexecopt = nCmdexecopt;
        execarg.pvarargIn = pvarargIn;
        execarg.pvarargOut = pvarargOut;

        if (_pMenuObject)
        {
            hr = THR_NOTRACE(RouteCTElement(_pMenuObject, &ctarg, pContextDoc));
        }

        if (hr == OLECMDERR_E_NOTSUPPORTED && _pElemCurrent)
        {
            CElement *pelTarget;
            CTreeNode *pNode = _pElemCurrent->GetFirstBranch();
            Assert(pNode);
            Assert(pContextDoc);
            // Get the node in the markup of the context CDocument that contains the current element
            pNode = pNode->GetNodeInMarkup(pContextDoc->Markup());

            if (pNode)
            {
                pelTarget = pNode->Element();
            }
            else
            {
                pelTarget = pContextDoc->Markup()->GetElementClient();
            }
            if (pelTarget)
                hr = THR_NOTRACE(RouteCTElement(pelTarget, &ctarg, pContextDoc));
        }
    }


    //
    // IEV6 #2555
    // We only route command to editor if we are at least
    // OS_INPLACE. This is to make sure that we have a
    // window -- otherwise caret code will crash.
    //
    if( (hr == OLECMDERR_E_NOTSUPPORTED || fRouteToEditor)
        && ((!_pOptionSettings || !(_pOptionSettings->fRouteEditorOnce)) || (_cInRouteCT == 0)) // only call editor once
        && (State() >= OS_INPLACE) 
        )
    {
        CEditRouter *pRouter;
        HRESULT     hrEdit = S_OK;

        // Retrieve the edit markup if no context has been passed into this helper function.
        // This occurs when pContextDoc is NULL on input.  pEditMarkup will be NULL in this
        // case, and we use the selection's current markup in order to determine where
        // the edit command should be routed to

        if( !pEditMarkup )
        {
            hrEdit = THR( GetSelectionMarkup( &pEditMarkup ) );

            if( pEditMarkup == NULL && _pElemCurrent )
            {
                pEditMarkup = _pElemCurrent->GetMarkupPtr();
            }
        }

        if( !FAILED(hrEdit ) && pEditMarkup )
        {
            hr = THR( pEditMarkup->EnsureEditRouter(&pRouter) );

            if( !FAILED(hr) )
            {
                hr = THR_NOTRACE( pRouter->ExecEditCommand( pguidCmdGroup,
                                                            nCmdID, nCmdexecopt,
                                                            pvarargIn, pvarargOut,
                                                            (IUnknown *)(IPrivateUnknown *)pEditMarkup,
                                                            this ) );
            }
        }
    }

    Assert(TestLock(SERVERLOCK_STABILIZED));

    if (!hr && (!pvarargOut || pvarargIn))
        DeferUpdateUI();

Cleanup:
    SRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CDoc::OnContextMenuExt
//
//  Synopsis:   Handle launching the dialog when a ContextMenuExt
//              command is received
//
//--------------------------------------------------------------------
HRESULT
CDoc::OnContextMenuExt(CMarkup * pMarkupContext, UINT idm, VARIANTARG * pvarargIn)
{
    HRESULT          hr = E_FAIL;
    IDispatch      * pDispWindow=NULL;
    CParentUndoUnit* pCPUU = NULL;
    unsigned int     nExts;
    CONTEXTMENUEXT * pCME;

    Assert(idm >= IDM_MENUEXT_FIRST__ && idm <= IDM_MENUEXT_LAST__);

    // find the html to run
    //
    nExts = _pOptionSettings->aryContextMenuExts.Size();
    Assert((idm - IDM_MENUEXT_FIRST__) < nExts);
    pCME = _pOptionSettings->
                aryContextMenuExts[idm - IDM_MENUEXT_FIRST__];
    Assert(pCME);

    // Undo stuff
    //
    pCPUU = OpenParentUnit(this, IDS_CANTUNDO);

    // get dispatch for the main window
    //

    pMarkupContext = pMarkupContext->GetFrameOrPrimaryMarkup();

    if (!pMarkupContext || !pMarkupContext->Window())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pDispWindow = (IHTMLWindow2*)(pMarkupContext->Window()->Window());

    // bring up the dialog
    //
    hr = THR(ShowModalDialogHelper(
            pMarkupContext,
            pCME->cstrActionUrl,
            pDispWindow,
            NULL,
            NULL,
            (pCME->dwFlags & MENUEXT_SHOWDIALOG)
                            ? 0 : (HTMLDLG_NOUI | HTMLDLG_AUTOEXIT)));

    if (pCPUU)
    {
        IGNORE_HR(CloseParentUnit(pCPUU, hr));
    }

Cleanup:
    RRETURN(hr);
}


void
CDoc::WaitForRecalc(CMarkup * pMarkup)
{
    PerfDbgLog(tagPerfWatch, this, "+CDoc::WaitForRecalc");

    //  Even for StrictCSS1 documents, this is currently enough.
    //  All that this function would do for an HTML layout is to delegate it to the
    //  element client... so we simply use the element client here.
    CElement *  pElement = CMarkup::GetElementClientHelper(pMarkup);

    if (_view.HasLayoutTask())
    {
        PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (EnsureView)");
        _view.EnsureView(LAYOUT_DEFERPAINT);
    }

    if (pElement)
    {
        PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (Body/Frame WaitForRecalc)");
        if (pElement->Tag() == ETAG_BODY)
            ((CBodyElement *)pElement)->WaitForRecalc();
        else if (pElement->Tag() == ETAG_FRAMESET)
            ((CFrameSetSite *)pElement)->WaitForRecalc();
    }

    if (_view.HasLayoutTask())
    {
        PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (EnsureView)");
        _view.EnsureView(LAYOUT_DEFERPAINT);
    }

    PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (UpdateForm)");
    UpdateForm();

    PerfDbgLog(tagPerfWatch, this, "-CDoc::WaitForRecalc");
}

//+---------------------------------------------------------------------------
//
// Member: AddToFavorites
//
//----------------------------------------------------------------------------
HRESULT
CDoc::AddToFavorites(TCHAR * pszURL, TCHAR * pszTitle)
{
#if defined(WIN16) || defined(WINCE)
    return S_FALSE;
#else
    VARIANTARG varURL;
    VARIANTARG varTitle;
    IUnknown * pUnk;
    HRESULT    hr;

    varURL.vt        = VT_BSTR;
    varURL.bstrVal   = pszURL;
    varTitle.vt      = VT_BSTR;
    varTitle.bstrVal = pszTitle;

    if (_pInPlace && _pInPlace->_pInPlaceSite)
    {
        pUnk = _pInPlace->_pInPlaceSite;
    }
    else
    {
        pUnk = _pClientSite;
    }

    hr = THR(CTExec(
            pUnk,
            &CGID_Explorer,
            SBCMDID_ADDTOFAVORITES,
            MSOCMDEXECOPT_PROMPTUSER,
            &varURL,
            &varTitle));

    RRETURN(hr);
#endif
}

//+----------------------------------------------------------------------------
//
// Member: AddPages (IShellPropSheetExt interface)
//
// Add Internet Property Sheets
//
//-----------------------------------------------------------------------------
typedef struct tagIEPROPPAGEINFO
{
    UINT  cbSize;
    DWORD dwFlags;
    LPSTR pszCurrentURL;
    DWORD dwRestrictMask;
    DWORD dwRestrictFlags;
} IEPROPPAGEINFO, *LPIEPROPPAGEINFO;

DYNLIB  g_dynlibINETCPL = { NULL, NULL, "inetcpl.cpl" };

DYNPROC g_dynprocAddInternetPropertySheets =
        { NULL, & g_dynlibINETCPL, "AddInternetPropertySheetsEx" };

#ifndef WIN16
HRESULT
CDoc::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    TCHAR  achFile[MAX_PATH];
    ULONG  cchFile = ARRAY_SIZE(achFile);
    LPTSTR pszURLW = (TCHAR *) GetPrimaryUrl();
    char   szURL[1024];
    LPSTR  pszURL = NULL;

    HRESULT hr;

    if (pszURLW && GetUrlScheme(pszURLW) == URL_SCHEME_FILE)
    {
        hr = THR(PathCreateFromUrl(pszURLW, achFile, &cchFile, 0));
        if (hr)
            goto Cleanup;

        pszURLW = achFile;
    }

    if (pszURLW)
    {
        pszURL = szURL;
        WideCharToMultiByte(CP_ACP, 0, pszURLW, -1, pszURL, sizeof(szURL), NULL, NULL);
    }

    hr = THR(LoadProcedure(& g_dynprocAddInternetPropertySheets));
    if (hr)
        goto Cleanup;

    IEPROPPAGEINFO iepi;

    iepi.cbSize = sizeof(iepi);
    iepi.dwFlags = (DWORD)-1;
    iepi.pszCurrentURL = pszURL;
    iepi.dwRestrictMask = 0;    // turn off all mask bits

    hr = THR((*(HRESULT (WINAPI *)
                    (LPFNADDPROPSHEETPAGE,
                     LPARAM,
                     PUINT,
                     LPFNPSPCALLBACK,
                     LPIEPROPPAGEINFO))
             g_dynprocAddInternetPropertySheets.pfn)
                     (lpfnAddPage, lParam, NULL, NULL, &iepi));

Cleanup:
    if (hr)
        hr = E_FAIL;
    RRETURN (hr);
}
#endif // !WIN16

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetupDefaultBlockTag(VARIANTARG pvarargIn)
//
//  Synopsis:   This function parses the string coming in and sets up the
//              default composition font.
//
//  Params:     [vargIn]: A BSTR, either "P" or "DIV"
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CDoc::SetupDefaultBlockTag(VARIANTARG *pvarargIn)
{
    HRESULT hr = E_INVALIDARG;
    BSTR pstr;

    //
    // If its not a BSTR, do nothing.
    //
    if (V_VT(pvarargIn) != VT_BSTR)
        goto Cleanup;

    // Get the string
    pstr = V_BSTR(pvarargIn);

    if (!StrCmpC (pstr, _T("DIV")))
    {
        SetDefaultBlockTag(ETAG_DIV);
    }
    else if (!StrCmpC (pstr, _T("P")))
    {
        SetDefaultBlockTag(ETAG_P);
    }
    else
    {
        SetDefaultBlockTag(ETAG_P);
        AssertSz(0, "Unexpected type");
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\formkrnl.cxx ===
//+------------------------------------------------------------------------
//
//  File:       FORMKRNL.CXX
//
//  Contents:   Root object of the standard forms kernel
//
//  Classes:    (part of) CDoc
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_SITECNST_HXX_
#define X_SITECNST_HXX_
#include "sitecnst.hxx"
#endif

#ifndef X_TIMER_HXX_
#define X_TIMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_RENDSTYL_HXX_
#define X_RENDSTYL_HXX_
#include "rendstyl.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DWNNOT_H_
#define X_DWNNOT_H_
#include <dwnnot.h>
#endif

#ifndef X_SAFEOCX_H_
#define X_SAFEOCX_H_
#include <safeocx.h>
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include <htiface.h>
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include <perhist.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include <mshtmcid.h>
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include <urlhist.h>
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include <hlink.h>
#endif

#ifndef X_MARQINFO_H_
#define X_MARQINFO_H_
#include <marqinfo.h>
#endif

#ifndef X_HTMVER_HXX_
#define X_HTMVER_HXX_
#include "htmver.hxx"
#endif

#ifndef X_VERVEC_H_
#define X_VERVEC_H_
#include "vervec.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_EXTDL_HXX_
#define X_EXTDL_HXX_
#include "extdl.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_LSCACHE_HXX_
#define X_LSCACHE_HXX_
#include "lscache.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X_TPOINTER_H_
#define X_TPOINTER_H_
#include "tpointer.hxx"
#endif

#ifndef X_DXTRANSP_H_
#define X_DXTRANSP_H_
#include "dxtransp.h"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef _X_DISPSERV_H_
#define _X_DISPSERV_H_
#include "dispserv.hxx"
#endif

#ifndef _X_GENERIC_H_
#define _X_GENERIC_H_
#include "generic.hxx"
#endif

#ifndef _X_WEBOCUTIL_H_
#define _X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_TEMPFILE_HXX_
#define X_TEMPFILE_HXX_
#include "tempfile.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_WSMGR_HXX_
#define X_WSMGR_HXX_
#include "wsmgr.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

extern BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols

#ifdef V4FRAMEWORK

#include "complus.h"

#define _hxx_
#include "complus.hdl"

#undef _hxx_
#define _cxx_
#include "complus.hdl"


EXTERN_C const GUID CLSID_ExternalFrameworkSite;

const CBase::CLASSDESC CExternalFrameworkSite::s_classdesc =
{
    &CLSID_ExternalFrameworkSite,    // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IExternalDocumentSite,    // _piidDispinterface
    &s_apHdlDescs,                           // _apHdlDesc
};

#endif V4FRAMEWORK

#ifndef NO_SCRIPT_DEBUGGER
extern void    DeinitScriptDebugging();
#endif // NO_SCRIPT_DEBUGGER

#ifndef NODD
extern void         ClearSurfaceCache();        // out of offscreen.cxx to clear allocated DD surfaces
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

extern "C" const IID IID_IObjectSafety;
extern "C" const IID IID_IThumbnailView;
extern "C" const IID IID_IRenMailEditor;
extern "C" const IID IID_IRenVersionCheck;
extern "C" const IID IID_IHTMLEditorViewManager;
extern "C" const IID SID_SHTMLEditorViewManager;
extern "C" const CLSID  CLSID_HTMLEditor;
extern "C" const CLSID CLSID_HTMLPluginDocument;
extern "C" const IID IID_IHTMLDialog;
extern "C" const IID IID_IHTMLViewServices;
#define SID_SElementBehaviorFactory IID_IElementBehaviorFactory
extern "C" const CLSID CLSID_HTMLPluginDocument;
extern "C" const CLSID CLSID_HTMLDialog;
extern "C" const IID IID_IHTMLDialog;
#define SID_SElementBehaviorFactory IID_IElementBehaviorFactory
extern "C" const GUID SID_SSelectionManager;
extern "C" const IID SID_DefView;
extern "C" const IID SID_SHTMEDDesignerHost;
extern "C" const IID SID_SMarsPanel;

#define ABOUT_HOME  _T("about:home")

extern "C" const IID IID_IXMLGenericParse;

DeclareTag(tagCDoc, "Form", "Form base class methods")
DeclareTag(tagUpdateUI, "Form", "Form UpdateUI calls")
DeclareTag(tagUrlImgCtx, "UrlImgCtx", "Trace UrlImgCtx methods")
DeclareTag(tagAssertParentDocChangeToDebugIsPrintDocCache, "Print", "Assert parent doc change")
DeclareTag(tagCompatMsMoney, "Compat", "Microsoft Money")
DeclareTag(tagEdSelMan, "Edit", "Handle Selection Message - Routing")
DeclareTag(tagDocHitTest, "Doc", "Hit testing")
DeclareTag(tagFilter, "Filter", "Trace filter behaviour")
ExternTag(tagDisableLockAR);
ExternTag(tagPrivacySwitchList);
ExternTag(tagPrivacyAddToList);


PerfTag(tagGasGauge, "GasGauge", "MSHTML Info")
PerfDbgExtern(tagPerfWatch)

MtDefine(CDefaultElement, Elements, "CDefaultElement")
MtDefine(OptionSettings, CDoc, "CDoc::_pOptionSettings")
MtDefine(OSCodePageAry_pv, OptionSettings, "CDoc::_pOptionSettings::aryCodePageSettings::_pv")
MtDefine(OSContextMenuAry_pv, OptionSettings, "CDoc::_pOptionSettings::aryContextMenuExts::_pv")
MtDefine(CPendingEvents, CDoc, "CDoc::_pPendingEvents")
MtDefine(CPendingEvents_aryPendingEvents_pv, CPendingEvents, "CDoc::_pPendingEvents::_aryPendingEvents::_pv")
MtDefine(CPendingEvents_aryEventType_pv, CPendingEvents, "CDoc::_pPendingEvents::_aryEventType::_pv")
MtDefine(CDoc, Mem, "CDoc")
MtDefine(CDoc_arySitesUnDetached_pv, CDoc, "CDoc::_arySitesUnDetached::_pv")
MtDefine(CDoc_aryElementDeferredScripts_pv, CDoc, "CDoc::_aryElementDeferredScripts::_pv")
MtDefine(CMarkup_aryElementReleaseNotify, CMarkup, "CMarkup::_aryElementReleaseNotify::_pv")
MtDefine(CMarkup_aryElementReleaseNotify_pv, CMarkup_aryElementReleaseNotify, "CMarkup::_aryElementReleaseNotify::_pv")
MtDefine(CDoc_aryDefunctObjects_pv, CDoc, "CDoc::_aryDefunctObjects::_pv")
MtDefine(CDoc_aryChildDownloads_pv, CDoc, "CDoc::_aryChildDownloads::_pv")
MtDefine(CDoc_aryUndoData_pv, CDoc, "CDoc::_aryUndoData::_pv")
MtDefine(CDoc_aryUrlImgCtx_aryElems_pv, CDoc, "CDoc::_aryUrlImgCtx_aryElems::_pv")
MtDefine(CDoc_aryUrlImgCtx_pv, CDoc, "CDoc::_aryUrlImgCtx::_pv")
MtDefine(CDocEnumObjects_paryUnk, Locals, "CDoc::EnumObjects paryUnk")
MtDefine(CDocEnumObjects_paryUnk_pv, CDocEnumObjects_paryUnk, "CDoc::EnumObjects paryUnk::_pv")
MtDefine(CDragDropSrcInfo, ObjectModel, "CDragDropSrcInfo")
MtDefine(CDragDropTargetInfo, ObjectModel, "CDragDropTargetInfo")
MtDefine(CDocUpdateIntSink, CDoc, "CDoc::_pUpdateIntSink")
MtDefine(CDragStartInfo, ObjectModel, "CDragStartInfo")
MtDefine(LoadMSHTMLEd, PerfPigs, "Loading MSHTMLEd")
MtDefine(CDoc_aryDelayReleaseItems_pv, CDoc, "CDoc::_aryDelayReleaseItems::_pv")
MtDefine(CDoc_CLock, CDoc, "CDoc::CLock")
MtDefine(CDoc_aryMarkupNotifyInPlace, CDoc, "CDoc::_aryMarkupNotifyInPlace")
MtDefine(CDoc_aryMarkupNotifyEnableModeless_pv, CDoc, "CDoc::_aryMarkupNotifyEnableModeless::_pv")

MtDefine(CDoc_aryPendingExpressionElements_pv, CDoc, "CDoc::_aryPendingExpressionElements::_pv")
MtDefine(CDoc_aryStackCapture_pv, CDoc, "CDoc::_aryStackCapture::_pv")
MtDefine(CDoc_aryAccEvtRefs_pv, CDoc, "CDoc::_aryAccEvents::_pv")
MtDefine(Filters, CDoc, "Filters")

MtExtern(CPrivacyList)

//
//  Globals
//

// When we have more time I need to change pdlparser to generate externs
EXTERN_C const PROPERTYDESC_METHOD s_methdescCBasesetMember;
EXTERN_C const PROPERTYDESC_METHOD s_methdescCBasegetMember;
EXTERN_C const PROPERTYDESC_METHOD s_methdescCBaseremoveMember;

extern HRESULT  InitFormatCache(THREADSTATE *);

BOOL        g_fInIexplorer = FALSE;
BOOL        g_fInExplorer  = FALSE;
BOOL        g_fDisableUnTrustedProtocol = FALSE;
BOOL        g_fDocClassInitialized = FALSE;
BOOL        g_fHiResAware;
BOOL        g_fInMoney98;
BOOL        g_fInMoney99;
BOOL        g_fInHomePublisher98;
BOOL        g_fInWin98Discover;
BOOL        g_fInVizAct2000;
BOOL        g_fInMSWorksCalender;
BOOL        g_fInPhotoSuiteIII;
BOOL        g_fInAccess9;
BOOL        g_fInAccess;
BOOL        g_fInExcelXP;
BOOL        g_fInHtmlHelp = FALSE;
BOOL        g_fPrintToGenericTextOnly;
BOOL        g_fInPip;
BOOL        g_fInIBMSoftwareSelection = FALSE;
BOOL        g_fInMoney2001 = FALSE;
BOOL        g_fInInstallShield = FALSE;
BOOL        g_fInAutoCad = FALSE;
BOOL        g_fInLotusNotes = FALSE;
BOOL        g_fInMshtmpad = FALSE;
BOOL        g_fInVisualStudio = FALSE;
int         g_iDragScrollDelay;
SIZE        g_sizeDragScrollInset;
int         g_iDragDelay;
int         g_iDragScrollInterval;
static char s_achWindows[] = "windows"; //  Localization: Do not localize
CGlobalCriticalSection g_csJitting;
BYTE g_bUSPJitState = JIT_OK;    //  For UniScribe JIT (USP10.DLL)
BYTE g_bJGJitState = JIT_OK;     //  JG ART library for AOL (JG*.DLL)
BOOL        g_fNoFileMenu = FALSE;      //  IEAK Restrictions

const OLEMENUGROUPWIDTHS CDoc::s_amgw[] =
{
    { 0, 1, 0, 3, 0, 0 },   //  Design mode info
    { 0, 1, 0, 1, 0, 0 },   //  Run mode info
};


BEGIN_TEAROFF_TABLE(CDoc, IMarqueeInfo)
    TEAROFF_METHOD(CDoc, GetDocCoords, getdoccoords, (LPRECT pViewRect, BOOL bGetOnlyIfFullyLoaded, BOOL *pfFullyLoaded, int WidthToFormatPageTo))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IServiceProvider)
    TEAROFF_METHOD(CDoc, QueryService, queryservice, (REFGUID rsid, REFIID iid, void ** ppvObj))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPersistFile)
    // IPersist methods
    TEAROFF_METHOD(CDoc, GetClassID, getclassid, (CLSID *))
    // IPersistFile methods
    TEAROFF_METHOD(CDoc, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDoc, Load, load, (LPCOLESTR pszFileName, DWORD dwMode))
    TEAROFF_METHOD(CDoc, Save, save, (LPCOLESTR pszFileName, BOOL fRemember))
    TEAROFF_METHOD(CDoc, SaveCompleted, savecompleted, (LPCOLESTR pszFileName))
    TEAROFF_METHOD(CDoc, GetCurFile, getcurfile, (LPOLESTR *ppszFileName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPersistMoniker)
    // IPersist methods
    TEAROFF_METHOD(CDoc, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistMoniker methods
    TEAROFF_METHOD(CDoc, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDoc, Load, load, (BOOL fFullyAvailable, IMoniker *pmkName, LPBC pbc, DWORD grfMode))
    TEAROFF_METHOD(CDoc, Save, save, (IMoniker *pmkName, LPBC pbc, BOOL fRemember))
    TEAROFF_METHOD(CDoc, SaveCompleted, savecompleted, (IMoniker *pmkName, LPBC pibc))
    TEAROFF_METHOD(CDoc, GetCurMoniker, getcurmoniker, (IMoniker  **ppimkName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IMonikerProp)
    // IMonikerProp methods
    TEAROFF_METHOD(CDoc, PutProperty, putproperty, (MONIKERPROPERTY mkp, LPCWSTR wzValue))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CDoc, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CDoc, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CDoc, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CDoc, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CDoc, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IHlinkTarget)
    TEAROFF_METHOD(CDoc, SetBrowseContext, setbrowsecontext, (IHlinkBrowseContext *pihlbc))
    TEAROFF_METHOD(CDoc, GetBrowseContext, getbrowsecontext, (IHlinkBrowseContext **ppihlbc))
    TEAROFF_METHOD(CDoc, Navigate, navigate, (DWORD grfHLNF, LPCWSTR wzJumpLocation))
    // NOTE: the following is renamed in tearoff to avoid multiple inheritance problem with IOleObject::GetMoniker
    TEAROFF_METHOD(CDoc, GetMonikerHlink, getmonikerhlink, (LPCWSTR wzLocation, DWORD dwAssign, IMoniker **ppimkLocation))
    TEAROFF_METHOD(CDoc, GetFriendlyName, getfriendlyname, (LPCWSTR wzLocation, LPWSTR *pwzFriendlyName))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CDoc, ITargetContainer)
    TEAROFF_METHOD(CDoc, GetFrameUrl, getframeurl, (LPWSTR *ppszFrameSrc))
    TEAROFF_METHOD(CDoc, GetFramesContainer, getframescontainer, (IOleContainer **ppContainer))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IShellPropSheetExt)
    TEAROFF_METHOD(CDoc, AddPages, addpages, (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam))
    TEAROFF_METHOD(CDoc, ReplacePage, replacepage, (UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IObjectSafety)
    TEAROFF_METHOD(CDoc, GetInterfaceSafetyOptions, getinterfacesafetyoptions, (REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions))
    TEAROFF_METHOD(CDoc, SetInterfaceSafetyOptions, setinterfacesafetyoptions, (REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, ICustomDoc)
    TEAROFF_METHOD(CDoc, SetUIHandler, setuihandler, (IDocHostUIHandler * pUIHandler))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IAuthenticate)
    TEAROFF_METHOD(CDoc, Authenticate, authenticate, (HWND * phwnd, LPWSTR * pszUsername, LPWSTR * pszPassword))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IWindowForBindingUI)
    TEAROFF_METHOD(CDoc, GetWindowBindingUI, getwindowbindingui, (REFGUID rguidReason, HWND * phwnd))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IMarkupServices2)
    TEAROFF_METHOD(CDoc, CreateMarkupPointer, createmakruppointer, (IMarkupPointer **ppPointer))
    TEAROFF_METHOD(CDoc, CreateMarkupContainer, createmarkupcontainer, (IMarkupContainer **ppMarkupContainer))
    TEAROFF_METHOD(CDoc, CreateElement, createelement, (ELEMENT_TAG_ID, OLECHAR *, IHTMLElement **))
    TEAROFF_METHOD(CDoc, CloneElement, cloneelement, (IHTMLElement *, IHTMLElement * *))
    TEAROFF_METHOD(CDoc, InsertElement, insertelement, (IHTMLElement *pElementInsert, IMarkupPointer *pPointerStart, IMarkupPointer *pPointerFinish))
    TEAROFF_METHOD(CDoc, RemoveElement, removeelement, (IHTMLElement *pElementRemove))
    TEAROFF_METHOD(CDoc, Remove, remove, (IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, Copy, copy, (IMarkupPointer *, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, Move, move, (IMarkupPointer *, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, InsertText, inserttext, (OLECHAR *, long, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, ParseString, parsestring, (OLECHAR *, DWORD, IMarkupContainer **, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, ParseGlobal, parseglobal, (HGLOBAL, DWORD, IMarkupContainer **, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, IsScopedElement, isscopedelement, (IHTMLElement *, BOOL *))
    TEAROFF_METHOD(CDoc, GetElementTagId, getelementtagid, (IHTMLElement *, ELEMENT_TAG_ID *))
    TEAROFF_METHOD(CDoc, GetTagIDForName, gettagidforname, (BSTR, ELEMENT_TAG_ID *))
    TEAROFF_METHOD(CDoc, GetNameForTagID, getnamefortagid, (ELEMENT_TAG_ID, BSTR *))
    TEAROFF_METHOD(CDoc, MovePointersToRange, movepointerstorange, (IHTMLTxtRange *, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, MoveRangeToPointers, moverangetopointers, (IMarkupPointer *, IMarkupPointer *, IHTMLTxtRange *))
    TEAROFF_METHOD(CDoc, BeginUndoUnit, beginundounit, (OLECHAR *))
    TEAROFF_METHOD(CDoc, EndUndoUnit, beginundounit, ())
    TEAROFF_METHOD(CDoc, ParseGlobalEx, parseglobalex, (HGLOBAL hGlobal, DWORD dwFlags, IMarkupContainer *pContext,IMarkupContainer **pContainerResult, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, ValidateElements, validateelements, (IMarkupPointer *pPointerStart, IMarkupPointer *pPointerFinish, IMarkupPointer *pPointerTarget, IMarkupPointer *pPointerStatus, IHTMLElement **ppElemFailBottom, IHTMLElement **ppElemFailTop))
#ifndef UNIX
    TEAROFF_METHOD(CDoc, SaveSegmentsToClipboard , savesegmentstoclipboard , ( ISegmentList * pSegmentList, DWORD dwFlags ))
#else
    TEAROFF_METHOD(CDoc, SaveSegmentsToClipboard , savesegmentstoclipboard , ( ISegmentList * pSegmentList, DWORD dwFlags, VARIANTARG * pvarargOut ))
#endif
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IHighlightRenderingServices)
    TEAROFF_METHOD(CDoc, AddSegment, addsegment, (  IDisplayPointer     *pIDispStart,
                                                    IDisplayPointer     *pIDispEnd,
                                                    IHTMLRenderStyle    *pIRenderStyle,
                                                    IHighlightSegment   **ppISegment ) )
    TEAROFF_METHOD(CDoc, MoveSegmentToPointers, movesegmenttopointers, (IHighlightSegment   *pISegment,
                                                                        IDisplayPointer     *pIDispStart,
                                                                        IDisplayPointer     *pIDispEnd) )
    TEAROFF_METHOD(CDoc, RemoveSegment, removesegment, (IHighlightSegment *pISegment) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IDisplayServices)
    TEAROFF_METHOD(CDoc, CreateDisplayPointer, createdisplaypointer, (IDisplayPointer **ppDispPointer))
    TEAROFF_METHOD(CDoc, TransformRect, transformrect, ( RECT           * pRect, 
                                                           COORD_SYSTEM eSource, 
                                                           COORD_SYSTEM eDestination, 
                                                           IHTMLElement * pIElement ))

    TEAROFF_METHOD(CDoc, TransformPoint, transformpoint, ( POINT        * pPoint, 
                                                           COORD_SYSTEM eSource, 
                                                           COORD_SYSTEM eDestination, 
                                                           IHTMLElement * pIElement ))
    TEAROFF_METHOD(CDoc, GetCaret, getcaret, (IHTMLCaret ** ppCaret))
    TEAROFF_METHOD(CDoc, GetComputedStyle, getcomputedstyle, (IMarkupPointer* pPointer, IHTMLComputedStyle** ppComputedStyle))
    TEAROFF_METHOD(CDoc, ScrollRectIntoView, scrollrectintoview, ( IHTMLElement* pIElement , RECT rect ))
    TEAROFF_METHOD(CDoc, HasFlowLayout, hasflowlayout, (IHTMLElement *pIElement, BOOL *pfHasFlowLayout))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CDoc, IXMLGenericParse)
    TEAROFF_METHOD(CDoc, SetGenericParse, setgenericparse, (VARIANT_BOOL fDoGeneric))
END_TEAROFF_TABLE()

#if DBG == 1
    //
    // IEditDebugServices Methods
    //
BEGIN_TEAROFF_TABLE( CDoc, IEditDebugServices)
    TEAROFF_METHOD( CDoc, GetCp, getcp , ( IMarkupPointer* pIPointer, long* pcp))                                                
    TEAROFF_METHOD( CDoc, SetDebugName, setdebugname, ( IMarkupPointer* pIPointer, LPCTSTR strDebugName ))
    TEAROFF_METHOD( CDoc, SetDisplayPointerDebugName, setdebugname, ( IDisplayPointer* pDispPointer, LPCTSTR strDebugName ))
    TEAROFF_METHOD( CDoc, DumpTree , dumptree, ( IMarkupPointer* pIPointer))
    TEAROFF_METHOD( CDoc, LinesInElement, linesinelement, (IHTMLElement *pIHTMLElement, long *piLines))
    TEAROFF_METHOD( CDoc, FontsOnLine, fontsonline, (IHTMLElement *pIHTMLElement, long iLine, BSTR *pbstrFonts))
    TEAROFF_METHOD( CDoc, GetPixel, getpixel, (long X, long Y, long *piColor))
    TEAROFF_METHOD( CDoc, IsUsingBckgrnRecalc, isusingbckgrnrecalc, (BOOL *pfUsingBckgrnRecalc))
    TEAROFF_METHOD( CDoc, IsEncodingAutoSelect, isencodingautoselect, (BOOL *pfEncodingAutoSelect))
    TEAROFF_METHOD( CDoc, EnableEncodingAutoSelect, enableencodingautoselect, (BOOL fEnable))
    TEAROFF_METHOD( CDoc, IsUsingTableIncRecalc, isusingtableincrecalc, (BOOL *pfUsingTableIncRecalc))
END_TEAROFF_TABLE()   
#endif // IEditDebugServices

BEGIN_TEAROFF_TABLE(CDoc, IIMEServices)
    TEAROFF_METHOD(CDoc, GetActiveIMM, getactiveimm, ( IActiveIMMApp **ppActiveIMM ))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPrivacyServices)
    TEAROFF_METHOD(CDoc, AddPrivacyInfoToList, addprivacyinfotolist, ( 
                                    LPOLESTR    pstrUrl,
                                    LPOLESTR    pstrPolicyRef,
                                    LPOLESTR    pstrP3PHeader,
                                    LONG        dwReserved,
                                    DWORD       privacyFlags))
END_TEAROFF_TABLE()

// GetData format information
// note: the LINKSRCDESCRIPTOR and OBJECTDESCRIPTOR are identical structures
//       so we use the OBJECTDESCRIPTOR get/set fns for both.

// Note: can't be const because SetCommonClipFormats() converts private CF_COMMON(...)
//       into registered format handles (from RegisterClipFormats())
FORMATETC CDoc::s_GetFormatEtc[] =
{
    STANDARD_FMTETCGET
//  { cfFormat,                         ptd,  dwAspect,   lindex,  tymed },
    { CF_COMMON(ICF_LINKSRCDESCRIPTOR), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_COMMON(ICF_LINKSRCDESCRIPTOR), NULL, DVASPECT_ICON, -1L, TYMED_HGLOBAL },
    { CF_COMMON(ICF_LINKSOURCE),        NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { CF_COMMON(ICF_LINKSOURCE),        NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
    { CF_TEXT,                          NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { CF_TEXT,                          NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
    { CF_UNICODETEXT,                   NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { CF_UNICODETEXT,                   NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
#ifndef NO_RTF
    { (WORD)RegisterClipboardFormat(_T("CF_RTF")),    NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { (WORD)RegisterClipboardFormat(_T("CF_RTF")),    NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
#endif // ndef NO_RTF
};

const CServer::LPFNGETDATA CDoc::s_GetFormatFuncs[] =
{
    STANDARD_PFNGETDATA
    &CServer::GetOBJECTDESCRIPTOR,  //  Actually LINKSRCDESCRIPTOR
    &CServer::GetOBJECTDESCRIPTOR,  //  Actually LINKSRCDESCRIPTOR
    &CServer::GetLINKSOURCE,
    &CServer::GetLINKSOURCE,
    &CDoc::GetTEXT,
    &CDoc::GetTEXT,
#ifdef UNICODE
    &CDoc::GetUNICODETEXT,
    &CDoc::GetUNICODETEXT,
#endif // UNICODE
#ifndef NO_RTF
    &CDoc::GetRTF,
    &CDoc::GetRTF,
#endif // !NO_RTF
};

#ifndef NO_PROPERTY_PAGE
const CLSID * const CDoc::s_apClsidPages[] =
{
    // Browse-time Pages
    &CLSID_CDocBrowsePropertyPage,
    NULL,
    // Edit-time Pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CServer::CLASSDESC CDoc::s_classdesc =
{
    {                                            // _classdescBase
        &CLSID_HTMLDocument,                     // _pclsid
        IDR_BASE_HTMLFORM,                       // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apClsidPages,                          // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                    // _pcpi
        SERVERDESC_CREATE_UNDOMGR |              // _dwFlags
        SERVERDESC_ACTIVATEONDRAG |
        SERVERDESC_SUPPORT_DRAG_DROP |
        SERVERDESC_HAS_MENU |
        SERVERDESC_HAS_TOOLBAR,
        NULL,                                    // _piidDispinterface
        &s_apHdlDescs,                           // _apHdlDesc
    },
    MISC_STATUS_FORM,                            // _dwMiscStatus
    0,                                           // _dwViewStatus
    ARRAY_SIZE(g_aOleVerbStandard),              // _cOleVerbTable
    g_aOleVerbStandard,                          // _pOleVerbTable
    g_apfnDoVerbStandard,                        // _pfnDoVerb
    ARRAY_SIZE(s_GetFormatFuncs),                // _cGetFmtTable
    s_GetFormatEtc,                              // _pGetFmtTable
    s_GetFormatFuncs,                            // _pGetFuncs
    0,                                           // _cSetFmtTable
    NULL,                                        // _pSetFmtTable
    NULL,                                        // _pSetFuncs
    0,                                           // _ibItfPrimary
    DISPID_UNKNOWN,                              // _dispidRowset
    0,                                           // _wVFFlags  (match Value property typelib)
    DISPID_UNKNOWN,                              // _dispIDBind
    ~0UL,                                        // _uGetBindIndex
    ~0UL,                                        // _uPutBindIndex
    VT_EMPTY,                                    // _vtBindType
    ~0UL,                                        // _uGetValueIndex
    ~0UL,                                        // _uPutValueIndex
    VT_EMPTY,                                    // _vtValueType
    ~0UL,                                        // _uSetRowset
    0,                                           // _sef
};


#if DBG == 1
void TestStringTable();

void DebugDocStartupCheck()
{
    TestStringTable();

    // verify CLIENTLAYERS and BEHAVIORRENDERINFO constants are in sync
    Assert(CLIENTLAYERS_BEFOREBACKGROUND    == BEHAVIORRENDERINFO_BEFOREBACKGROUND);
    Assert(CLIENTLAYERS_AFTERBACKGROUND     == BEHAVIORRENDERINFO_AFTERBACKGROUND);
    Assert(CLIENTLAYERS_BEFORECONTENT       == BEHAVIORRENDERINFO_BEFORECONTENT);
    Assert(CLIENTLAYERS_AFTERCONTENT        == BEHAVIORRENDERINFO_AFTERCONTENT);
    Assert(CLIENTLAYERS_AFTERFOREGROUND     == BEHAVIORRENDERINFO_AFTERFOREGROUND);

    Assert(CLIENTLAYERS_DISABLEBACKGROUND   == BEHAVIORRENDERINFO_DISABLEBACKGROUND);
    Assert(CLIENTLAYERS_DISABLENEGATIVEZ    == BEHAVIORRENDERINFO_DISABLENEGATIVEZ);
    Assert(CLIENTLAYERS_DISABLECONTENT      == BEHAVIORRENDERINFO_DISABLECONTENT);
    Assert(CLIENTLAYERS_DISABLEPOSITIVEZ    == BEHAVIORRENDERINFO_DISABLEPOSITIVEZ);
}

#endif

BOOL
CompareProductVersion(LPTSTR lpModule, LPTSTR lpVersionStr)
{
    BOOL        fIsEqual = FALSE;
    DWORD       cchVersionStrSize;
    DWORD       cbVersionInfoSize;
    DWORD       dwHandle = 0;
    VOID        *pData = NULL;

    Assert(lpModule != NULL);
    Assert(lpVersionStr != NULL);

    cchVersionStrSize = wcslen(lpVersionStr);

    if (cchVersionStrSize > 0)
    {
        //  Find the version info size.
        cbVersionInfoSize = GetFileVersionInfoSize(lpModule, &dwHandle);

        if (cbVersionInfoSize > 0)
        {
            pData = new BYTE[cbVersionInfoSize];

            if (pData)
            {
                //  Get the version info.
                if (GetFileVersionInfo(lpModule, dwHandle, cbVersionInfoSize, pData))
                {
                    struct LANGANDCODEPAGE {
                      WORD wLanguage;
                      WORD wCodePage;
                    } *lpTranslate;

                    LPTSTR              lpBuffer = NULL;
                    TCHAR               strSubBlock[40];
                    UINT                cbTranslate;
                    UINT                cchQueryValue = 0;
                    UINT                i;
                    BOOL                fFound = FALSE;

                    //  We'll find the supported language and code page.  We'll use these
                    //  to query for the product version.

                    if (VerQueryValue(pData, TEXT("\\VarFileInfo\\Translation"), (LPVOID*)&lpTranslate, &cbTranslate))
                    {
                        for( i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++ )
                        {
                            wsprintf( strSubBlock, 
                                    TEXT("\\StringFileInfo\\%04x%04x\\ProductVersion"),
                                    lpTranslate[i].wLanguage,
                                    lpTranslate[i].wCodePage);

                            //  Query for the product version.
                            fFound = VerQueryValue(pData, strSubBlock, (LPVOID*)&lpBuffer, &cchQueryValue);

                            //  Compare the version strings.
                            if ( fFound && lpBuffer && cchQueryValue >= cchVersionStrSize &&
                                _tcsnicmp(lpBuffer, cchVersionStrSize, lpVersionStr, cchVersionStrSize) == 0)
                            {
                                fIsEqual = TRUE;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (pData)
        delete pData;

    return fIsEqual;
}


//+---------------------------------------------------------------
//
//  Member:     InitDocClass
//
//  Synopsis:   Initializes the CDoc class
//
//  Returns:    TRUE iff the class could be initialized successfully
//
//  Notes:      This method initializes the verb tables in the
//              class descriptor.  Called by the LibMain
//              of the DLL.
//
//---------------------------------------------------------------

HRESULT
InitDocClass()
{
    if (!g_fDocClassInitialized)
    {
        LOCK_GLOBALS;

        // If another thread completed initialization while this thread waited
        // for the global lock, immediately return
        //
        if (g_fDocClassInitialized)
            return(S_OK);

        int     i;

        // Fetch parameters from the registry.  Use GetProfileIntA because
        // its faster on Win95 and the strings are smaller.
        //
        // CONSIDER: centralize this stuff and update on profile change.
        //
        // TODO: Confirm that GetProfileInt calls are actually fetching
        // profile data. (Are these the APIs to use? Are the key names correct?)
        //
        //  Localization: Do not localize the profile strings below.
        //

        i = GetProfileIntA(s_achWindows, "DragScrollInset", DD_DEFSCROLLINSET);
        g_sizeDragScrollInset.cx = i;
        g_sizeDragScrollInset.cy = i;
        g_iDragScrollDelay = GetProfileIntA(
                s_achWindows,
                "DragScrollDelay",
                DD_DEFSCROLLDELAY);

#ifndef _MAC
        g_iDragDelay = GetProfileIntA(
                s_achWindows,
                "DragDelay",
                DD_DEFDRAGDELAY),
#else
        g_iDragDelay = GetProfileIntA(s_achWindows, "DragDelay", 20),
#endif

        g_iDragScrollInterval = GetProfileIntA(
                s_achWindows,
                "DragScrollInterval",
                DD_DEFSCROLLINTERVAL);

        SetCommonClipFormats(
                CDoc::s_GetFormatEtc,
                ARRAY_SIZE(CDoc::s_GetFormatEtc));

        char szModule[MAX_PATH];

        if (!GetModuleFileNameA(NULL, szModule, MAX_PATH))
        {
            Assert(FALSE);
            return (E_FAIL);
        }

        // This code is somewhat redundant.  This is part of bug fix for 21939.
        // Mixing chars and tchars in CompareProductVersion is causing it to
        // fail on Windows98.  This is the easiest way to fix it.
        TCHAR tszModule[MAX_PATH];
        if (!GetModuleFileName(NULL, tszModule, MAX_PATH))
        {
            Assert(FALSE);
            return (E_FAIL);
        }

        if ( NULL != StrStrIA(szModule, "explorer.exe"))
        {
            g_fInExplorer = TRUE;
            goto QuickDone;
        }

        //
        // If we're the browser bypass all other app string compares...
        //
        if ( NULL != StrStrIA(szModule, "iexplore.exe"))
        {
            g_fHiResAware  = TRUE;
            g_fInIexplorer = TRUE;
            goto QuickDone;
        }
        g_fHiResAware  = ( NULL != ::FindAtom(DOCHOSTUIATOM_ENABLE_HIRES) );
        

        g_fInMoney98         =  NULL != StrStrIA(szModule, "msmoney.exe")
                            ||  IsTagEnabled(tagCompatMsMoney);

        g_fInMoney99         =  (NULL != StrStrIA(szModule, "msmoney.exe")) &&
                                CompareProductVersion(tszModule, TEXT("7."));

        g_fInMoney2001       =  (NULL != StrStrIA(szModule, "msmoney.exe")) && 
                                CompareProductVersion(tszModule, TEXT("9."));
                            
        g_fInVizAct2000      =  NULL != StrStrIA(szModule, "vizact.exe");
                            
        g_fInPhotoSuiteIII   =  NULL != StrStrIA(szModule, "PhotoSuite.exe");

        g_fInHomePublisher98 =  NULL != StrStrIA(szModule, "homepub.exe")
#if DBG==1
                            ||  NULL != StrStrIA(szModule, "homepubd.exe")
#endif
        ;

        g_fInPip           = NULL != StrStrIA(szModule,"pip.exe");

        g_fInLotusNotes    = NULL != StrStrIA(szModule,"nlnotes.exe");

        g_fInMshtmpad      = NULL != StrStrIA(szModule, "mshtmpad.exe");

        
        g_fInMSWorksCalender = (   NULL !=  StrStrIA(szModule, "wkscal.exe")     // works2000, works 2001
                                || NULL !=  StrStrIA(szModule, "mswkscal.exe")); // works 98
        //  If we are hosted by Access, we need to determine what version of Access is
        //  hosting us.  We only really care if we are hosted by Access 9.  We'll try
        //  to pull the version out of the version info for the file and see if it
        //  starts with "9.".
        g_fInAccess9 = (NULL != StrStrIA(szModule, "msaccess.exe")) &&
                       CompareProductVersion(tszModule, TEXT("9."));

        g_fInAccess   = NULL != StrStrIA(szModule, "msaccess.exe") ;

        g_fInExcelXP = (NULL != StrStrIA(szModule, "excel.exe")) &&
                       CompareProductVersion(tszModule, TEXT("10."));

        g_fInVisualStudio = NULL != StrStrIA(szModule, "devenv.exe") ;
        // IBM Recovery CDs containt a program ssstart.exe which hosts us to show some html pages.
        // The content is not standard compliant, but contains a standard compliant doctype switch.
        // So, the documents are totally screwed up. g_fInIBMSoftwareSelection forces trident to be
        // in legacy mode.
        g_fInIBMSoftwareSelection = NULL != StrStrIA(szModule, "ssstart.exe");        

        // discover.exe is too common. We wanted to use the version resource to
        // figure out that this was from win98, but it turns out that not only
        // does every different language have a different version number,
        // every one stores the resource in a different character set.
        // We hack and just look for "tour\discover.exe".
        if (NULL != StrStrIA(szModule, "discover.exe"))
        {
            HINSTANCE hInst;
            hInst = GetModuleHandle(NULL);
            if (hInst)
            {
                char achPath[MAX_PATH];
                char *sz;

                if (GetModuleFileNameA( hInst, achPath, sizeof(achPath) ))
                {
                    // Compare the last part of the full path.
                    sz = achPath + strlen(achPath) - strlen("\\tour\\discover.exe");
                    g_fInWin98Discover = NULL != StrStrIA(achPath, "\\tour\\discover.exe");
                }
            }
        }

        g_fInInstallShield = NULL != StrStrIA(szModule,"iside.exe");

        g_fInAutoCad       = NULL != (StrStrIA(szModule,"acad.exe") || StrStrIA(szModule,"aclt.exe"));

QuickDone: 
        // Read restrictions from registry
        DWORD dwSize, dwType, dw;
        dwSize = sizeof(dw);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, EXPLORER_REG_KEY, NO_FILE_MENU_RESTR,
                                        &dwType, &dw, &dwSize))
        {
            g_fNoFileMenu = dw;
        }

        g_fDocClassInitialized = TRUE;
    }

    return(S_OK);
}

//+---------------------------------------------------------------
//
//  Member:     CDefaultElement
//
//---------------------------------------------------------------

const CElement::CLASSDESC CDefaultElement::s_classdesc =
{
    {
        NULL,                   // _pclsid
        0,                      // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                   // _pcpi
        0,                      // _dwFlags
        NULL,                   // _piidDispinterface
        NULL
    },
    NULL,
    NULL                        // _paccelsRun
};

CDefaultElement::CDefaultElement ( CDoc * pDoc )
  : CElement ( ETAG_DEFAULT, pDoc )
{
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::CDoc, protected
//
//  Synopsis:   Constructor for the CDoc class
//
//  Arguments:  [pUnkOuter] -- the controlling unknown or NULL if we are
//                             not being created as part of an aggregate
//
//  Notes:      This is the first part of a two-stage construction process.
//              The second part is in the Init method.  Use the static
//              Create method to properly instantiate an CDoc object
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // 'this' argument to base-member init list

CDoc::CDoc(LPUNKNOWN pUnkOuter, DOCTYPE doctype)
  : CServer(pUnkOuter)
{
    Assert( g_fDocClassInitialized );
    Assert( _pUrlHistoryStg == NULL );
    Assert( ! _hwndCached );
    Assert( ! _fDeferredScripts );
    Assert( !_fUIHandlerSet );
    
    _dwTID = GetCurrentThreadId();
    _pts = GetThreadState();

    TraceTag((tagCDoc, "%lx constructing CDoc SSN=0x%x TID=0x%x", this, _ulSSN, _dwTID));

    //
    // Initialize the document to a default size
    //

    {
        SIZE sizeDefault;
        g_uiDisplay.HimetricFromDevice(sizeDefault, 100, 100);

        _dciRender.SetUnitInfo(&g_uiDisplay);
        _dciRender._pDoc = this;

        _view.Initialize(this, sizeDefault);        //  The view contains a measuring device.
    }

    Assert( ! _pElemCurrent );
    Assert( ! _pElemUIActive );

    _fShownSpin = TRUE;
    _fIsUpToDate = TRUE;
    _fUseSrcURL  = FALSE;
    _iStatusTop = STL_LAYERS;
    _fShouldEnableAutoImageResize = FALSE;
   
    _sizelGrid.cx = GRIDX_DEFAULTVALUE;
    _sizelGrid.cy = GRIDY_DEFAULTVALUE;

    // Support for document-level object safety settings.

    _fFullWindowEmbed = doctype == DOCTYPE_FULLWINDOWEMBED;
    _fHostedInHTA = doctype == DOCTYPE_HTA;
    _fHostNavigates    = TRUE;  
    _fStartup          = TRUE;
    _fPopupDoc = doctype == DOCTYPE_POPUP;
    _fMhtmlDoc = doctype == DOCTYPE_MHTML;
    
    Assert(!_fMhtmlDocOriginal);  // Initially false. This line does not do anything since _fMhtmlDocOriginal
                                  // is automatically initialized to FALSE. However, it is a reminder that on the 
                                  // navigation to a MIME file _fMhtmlDoc is FALSE, then TRUE _fMhtmlDoc on the handling, 
                                  // but is flipped to FALSE immediately. _fMhtmlDocOriginal will be come TRUE on that load.

    _fEnableInteraction = TRUE;
    
    _sBaselineFont = BASELINEFONTDEFAULT;

    _triOMOffscreenOK = -1; // set offscreen to auto

    SetPrimaryUrl(_T("about:blank"));

    // Append to thread doc array
    TLS(_paryDoc).Append(this);

    MemSetName((this, "CDoc SSN=%d", _ulSSN));

    // Register the window message (if not registered)
    if(_g_msgHtmlGetobject == 0)
    {
        _g_msgHtmlGetobject = RegisterWindowMessage(MSGNAME_WM_HTML_GETOBJECT);
        Assert(_g_msgHtmlGetobject != 0);
    }

#if !defined(NO_IME)
    if (   g_dwPlatformVersion < 0x4000a
        && _g_msgImeReconvert == 0)
    {
        _g_msgImeReconvert  = RegisterWindowMessage(RWM_RECONVERT);
        Assert(_g_msgImeReconvert != 0);
    }
#endif // !NO_IME

    _fNeedTabOut = FALSE;

    _fRegionCollection = FALSE; // default no need to build region collection
    _fDisableReaderMode = FALSE;

    _fPlaintextSave = FALSE;

    _pCaret = NULL;
    _pSharedStyleSheets = NULL;
    
    // reset the accessibility object, we don't need it until we're asked
    _pAccTypeInfo = NULL;

#ifdef TEST_LAYOUT
    _hExternalLayoutDLL = (HMODULE) INVALID_HANDLE_VALUE;
#endif

#if DBG == 1
    DebugDocStartupCheck();
#endif

    _aryAccEvents.SetCDoc(this);

    _pdomImplementation = NULL;

    _hDevNames =
    _hDevMode  = NULL;

    _pDT = NULL;
}

#pragma warning(default:4355)

//+---------------------------------------------------------------
//
//  Member:     CDoc::~CDoc
//
//  Synopsis:   Destructor for the CDoc class
//
//---------------------------------------------------------------

CDoc::~CDoc ( )
{

    TraceTag((tagCDoc, "%lx CDoc::~CDoc", this));

    Assert(!_pNodeGotButtonDown);

    ClearInterface(&_pUrlHistoryStg);

    //
    // Destroy host stylesheets collection subobject (if anyone held refs on it, we
    // should never have gotten here since the doc should then have subrefs
    // keeping it alive).  This is the only place where we directly access the
    // CBase impl. of IUnk. for the CStyleSheetArray -- we do this instead of
    // just calling delete in order to assure that the CBase part of the CSSA
    // is properly destroyed (CBase::Passivate gets called etc.)
    //
    // StyleSheets moved to CMarkup

    if (_pHostStyleSheets)  // TODO (alexz) investigate why is refcounting so complicated
    {
        _pHostStyleSheets->Free ( );
        _pHostStyleSheets->CBase::PrivateRelease();
        _pHostStyleSheets = NULL;
    }

    // Remove Doc from Thread state array
    TLS(_paryDoc).DeleteByValue(this);

    TraceTag((tagCDoc, "%lx destructed CDoc", this));

    // CVersions object
    if (_pVersions)
    {
        _pVersions->Release();
        _pVersions = NULL;
    }


    delete _pSharedStyleSheets;
    _pSharedStyleSheets = NULL;
    

    // In case any extra expandos were added after CDoc::Passivate (see bug 55425)
    _AtomTable.Free();

#if DBG == 1
    // Make sure there is nothing in the image context cache

    {
        URLIMGCTX * purlimgctx = _aryUrlImgCtx;
        LONG        curlimgctx = _aryUrlImgCtx.Size();
        LONG        iurlimgctx;

        for (iurlimgctx = 0; iurlimgctx < curlimgctx;
             ++iurlimgctx, ++purlimgctx)
        {
            if (purlimgctx->ulRefs > 0)
                break;
        }

        AssertSz(iurlimgctx == curlimgctx, "Image context cache leak");
    }
#endif

    // If we had to get type information for IAccessible, release type info
    if ( _pAccTypeInfo )
        _pAccTypeInfo->Release();

    Assert(!_aryANotification.Size());    
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Init
//
//  Synopsis:    Second phase of construction
//
//--------------------------------------------------------------------------

HRESULT
CDoc::Init()
{
    HRESULT hr;
    THREADSTATE * pts = GetThreadState();
    CMarkup * pMarkup = NULL;

    hr = THR( super::Init() );

    if (hr)
        goto Cleanup;

    //
    // Create the default site (not to be confused with a root site)
    //

    Assert(!_pElementDefault);
    _pElementDefault = new CDefaultElement ( this );
    if (!_pElementDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( CSharedStyleSheetsManager::Create(&_pSharedStyleSheets, this) );
    if (hr)
        goto Cleanup;

    _icfDefault = -1;

    //
    // Create the primary window with an empty markup
    //

    hr = THR(CreateMarkup(&pMarkup, NULL, FALSE, TRUE));
    if (hr)
        goto Cleanup;

    _pElemCurrent = pMarkup->Root();

    _aryAccEvents.Init();

    //
    // Initialize format caches
    //

    if (!TLS(_pCharFormatCache))
    {
        hr = THR(InitFormatCache( pts ));
        if (hr)
            goto Cleanup;
    }
    
    _dwStylesheetDownloadingCookie = 1;

    _pWhitespaceManager = new CWhitespaceManager();
    if (!_pWhitespaceManager)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the default block tag to P.
    SetDefaultBlockTag(ETAG_P);

    // Create the cookie privacy list
    _pPrivacyLi