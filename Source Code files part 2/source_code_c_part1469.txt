iginal header
	//
	xstr_t OrgHeader = FindHttpHeader(pOrgHeaderStart, OrgMessageSize);
	CreateSFDHeader(OrgHeader);
	ASSERT(m_buffers.size() == 1);


	//
	// Set the rest of original message(everything that comes after the http header)
	// on the send buffer
	//
	WSABUF buffer;
	buffer.buf =  const_cast<char*>(OrgHeader.Buffer()) + OrgHeader.Length();
	buffer.len =  OrgMessageSize -  OrgHeader.Length();
	m_buffers.push_back(buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\test\mptest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MpTest.cpp

Abstract:
    SRMP Serialization and Deserialization library test

Author:
    Uri Habusha (urih) 28-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <Mp.h>
#include <xml.h>
#include <mqexception.h>
#include <utf8.h>
#include <cm.h>
#include "mqwin64a.h"
#include "acdef.h"
#include "qmpkt.h"

#include "MpTest.tmh"

using namespace std;


const TraceIdEntry MpTest = L"Mp Test";

extern CBaseHeader* CreatePacket();


void GetDnsNameOfLocalMachine(WCHAR ** ppwcsDnsName)
{
    const WCHAR xLoclMachineDnsName[] = L"www.foo.com";
    *ppwcsDnsName = newwcs(xLoclMachineDnsName);
}


static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};
const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}



CQmPacket::CQmPacket(CBaseHeader *pPkt, CPacket *pDriverPkt):
                m_pDriverPacket(pDriverPkt)
{
    PCHAR pSection;

    m_pBasicHeader = pPkt;

    ASSERT(m_pBasicHeader->VersionIsValid());

    pSection = m_pBasicHeader->GetNextSection();

    if (m_pBasicHeader->GetType() == FALCON_USER_PACKET)
    {
        //
        // User Packet
        //
        m_pcUserMsg = (CUserHeader*) pSection;
        pSection = m_pcUserMsg->GetNextSection();
        //
        // Xact Section
        //
        if (m_pcUserMsg->IsOrdered())
        {
            m_pXactSection = (CXactHeader *)pSection ;
            pSection = m_pXactSection->GetNextSection();
        }
        else
        {
            m_pXactSection = NULL;
        }

        //
        // Security Section
        //
        if (m_pcUserMsg->SecurityIsIncluded())
        {
            m_pSecuritySection = (CSecurityHeader *)pSection ;
            pSection = m_pSecuritySection->GetNextSection();
        }
        else
        {
            m_pSecuritySection = NULL;
        }

        //
        // Message propery section
        //
        if (m_pcUserMsg->PropertyIsIncluded())
        {
            m_pcMsgProperty = (CPropertyHeader*) pSection;
            pSection = m_pcMsgProperty->GetNextSection();
        }
        else
        {
            m_pcMsgProperty = NULL;
        }

        //
        // Debug Section
        //
        if (m_pBasicHeader->DebugIsIncluded())
        {
            m_pDbgPkt = (CDebugSection *)pSection;
            pSection = m_pDbgPkt->GetNextSection();
        }
        else
        {
            m_pDbgPkt = NULL;
        }

        //
        // MQF sections: Destination, Admin, Response
        // When MQF is included, the Debug section must be included too,
        // to prevent reporting QMs 1.0/2.0 to append their Debug section.
        //
        if (m_pcUserMsg->MqfIsIncluded())
        {
            ASSERT(m_pBasicHeader->DebugIsIncluded());

            m_pDestinationMqfHeader = reinterpret_cast<CBaseMqfHeader*>(pSection);
            pSection = m_pDestinationMqfHeader->GetNextSection();

            m_pAdminMqfHeader = reinterpret_cast<CBaseMqfHeader*>(pSection);
            pSection = m_pAdminMqfHeader->GetNextSection();
            
            m_pResponseMqfHeader = reinterpret_cast<CBaseMqfHeader*>(pSection);
            pSection = m_pResponseMqfHeader->GetNextSection();

			m_pMqfSignatureHeader =  reinterpret_cast<CMqfSignatureHeader* >(pSection);
			pSection= m_pMqfSignatureHeader->GetNextSection();			
        }
        else
        {
            m_pDestinationMqfHeader = m_pAdminMqfHeader = m_pResponseMqfHeader = NULL;
			m_pMqfSignatureHeader  = NULL;
        }

        //
        // SRMP sections: envelope and compound message
        //
        if (m_pcUserMsg->SrmpIsIncluded())
        {
            m_pSrmpEnvelopeHeader = reinterpret_cast<CSrmpEnvelopeHeader*>(pSection);
            pSection = m_pSrmpEnvelopeHeader->GetNextSection();

            m_pCompoundMessageHeader = reinterpret_cast<CCompoundMessageHeader*>(pSection);
            pSection = m_pCompoundMessageHeader->GetNextSection();
        }
        else
        {
            m_pSrmpEnvelopeHeader = NULL;
            m_pCompoundMessageHeader = NULL;
        }

        //
        // EOD section
        //
        if (m_pcUserMsg->EodIsIncluded())
        {
            m_pEodHeader = reinterpret_cast<CEodHeader*>(pSection);
            pSection = m_pEodHeader->GetNextSection();
        }
        else
        {
            m_pEodHeader = NULL;
        }

		//
        // EOD ack section
        //
        if (m_pcUserMsg->EodAckIsIncluded())
        {
            m_pEodAckHeader = reinterpret_cast<CEodAckHeader*>(pSection);
            pSection = m_pEodAckHeader->GetNextSection();
        }
        else
        {
            m_pEodAckHeader = NULL;
        }




        //
        // Session Section
        //
        if (m_pBasicHeader->SessionIsIncluded())
        {
            m_pSessPkt = (CSessionSection *)pSection;
        }
        else
        {
            m_pSessPkt = NULL;
        }
    }
}


static void Usage()
{
    printf("Usage: MpTest [-n x]\n");
    printf("\t*-n*\t*Number of messages*\n");
    printf("\n");
    printf("Example, MppTest -n 3\n");
    exit(-1);

} // Usage



static 
bool
CompareQueue(
    const QUEUE_FORMAT& origQueue, 
    const QUEUE_FORMAT& newQueue
    )
{
    if (origQueue.GetType() != newQueue.GetType())
    {
        printf("Queue type mismatch. Expected: %d, Actual: %d", origQueue.GetType(), newQueue.GetType());
        return false;
    }

    if (origQueue.Suffix() != newQueue.Suffix())
    {
        printf("Queue Suffix mismatch. Expected: %d, Actual: %d", origQueue.Suffix(), newQueue.Suffix());
        return false;
    }

    if (origQueue.GetType() ==  QUEUE_FORMAT_TYPE_UNKNOWN)
        return true;

    if (origQueue.GetType() == QUEUE_FORMAT_TYPE_PUBLIC)
    {
        if (memcmp(&origQueue.PublicID(), &newQueue.PublicID(), sizeof(GUID)) == 0)
            return true;

        printf("Queue public ID mismatch.");
        return false;
    }

    if (origQueue.GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
    {
        if (memcmp(&origQueue.PrivateID(), &newQueue.PrivateID(), sizeof(OBJECTID)) == 0)
            return true;

        printf("Queue private ID mismatch.");
        return false;
    }

    if (origQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        if (wcscmp(origQueue.DirectID(), newQueue.DirectID()) == 0)
            return true;

        printf("Queue direct ID mismatch. Expected: %ls, Actual: %ls", origQueue.DirectID(), newQueue.DirectID());
        return false;
    }

    return false;
}


static
bool
Compare(
    CQmPacket& origPkt,
    CQmPacket& newPkt,
	DWORD srmpSectionSize
    )
{
    if (origPkt.GetType() != newPkt.GetType())
    {
        printf("packet type mismatch. Expected: %d, Actual: %d", origPkt.GetType(), newPkt.GetType());
        return false;
    }

    if (origPkt.GetPriority() != newPkt.GetPriority())
    {
        printf( "packet priority mismatch. Expected: %d, Actual: %d", origPkt.GetPriority(), newPkt.GetPriority());
        return false;
    }

    if (origPkt.GetTrace() != newPkt.GetTrace())
    {
        printf( "packet tracing mismatch. Expected: %d, Actual: %d", origPkt.GetTrace(), newPkt.GetTrace());
        return false;
    }

    if (memcmp(origPkt.GetSrcQMGuid(), newPkt.GetSrcQMGuid(), sizeof(GUID)) != 0)
    {
        printf( "Source Id mismatch. ");
        return false;
    }

    OBJECTID origMsgId;
    origPkt.GetMessageId(&origMsgId);

    OBJECTID newMsgId;
    newPkt.GetMessageId(&newMsgId);
    
    if (origMsgId.Uniquifier != newMsgId.Uniquifier)
    {
        printf( "Message Id mismatch. ");
        return false;
    }

    if (memcmp(&origMsgId.Lineage, &newMsgId.Lineage, sizeof(GUID)) != 0)
    {
        printf( "Message Id mismatch. ");
        return false;
    }

    if (origPkt.GetDeliveryMode() != newPkt.GetDeliveryMode())
    {
        printf( "Delivery mode mismatch. Expected: %d, Actual: %d", origPkt.GetDeliveryMode(), newPkt.GetDeliveryMode());
        return false;
    }

    if (origPkt.GetAuditingMode() != newPkt.GetAuditingMode())
    {
        printf( "auditing mismatch. Expected: %d, Actual: %d", origPkt.GetAuditingMode(), newPkt.GetAuditingMode());
        return false;
    }

    if (origPkt.IsPropertyInc() != newPkt.IsPropertyInc())
    {
        printf( "Property section included mismatch. Expected: %d, Actual: %d", origPkt.IsPropertyInc(), newPkt.IsPropertyInc());
        return false;
    }

    if (origPkt.IsSecurInc() != newPkt.IsSecurInc())
    {
        printf( "Security section include mismatch. Expected: %d, Actual: %d", origPkt.IsSecurInc(), newPkt.IsSecurInc());
        return false;
    }
    
    if (origPkt.IsOrdered() != newPkt.IsOrdered())
    {
        printf( "Transaction section include mismatch. Expected: %d, Actual: %d", origPkt.IsOrdered(), newPkt.IsOrdered());
        return false;
    }
	

	if (origPkt.IsFirstInXact() != newPkt.IsFirstInXact())
    {
        printf( "First XACT  mismatch. Expected: %d, Actual: %d", origPkt.IsFirstInXact(), newPkt.IsFirstInXact());
        return false;
    }

    if (origPkt.IsLastInXact() != newPkt.IsLastInXact())
    {
        printf( "Last in XACT mismatch. Expected: %d, Actual: %d", origPkt.IsLastInXact(), newPkt.IsLastInXact());
        return false;
    }

//
// BUGBUG - currently we don't support eod so many validation is not applicable - 13-sep-2000
//

    if (origPkt.GetSeqID() != newPkt.GetSeqID())
    {
        printf( "XACT Sequnce ID mismatch. Expected: %I64d, Actual: %I64d", origPkt.GetSeqID(), newPkt.GetSeqID());
        return false;
    }


    if (origPkt.GetSeqN() != newPkt.GetSeqN())
    {
        printf( "XACT Sequnce number mismatch. Expected: %d, Actual: %d", origPkt.GetSeqN(), newPkt.GetSeqN());
        return false;
    }

    if (origPkt.GetPrevSeqN() != newPkt.GetPrevSeqN())
    {
        printf( "XACT Prev-Sequnce number mismatch. Expected: %d, Actual: %d", origPkt.GetPrevSeqN(), newPkt.GetPrevSeqN());
        return false;
    }

	

	if ((origPkt.GetConnectorQM() != NULL) && (newPkt.GetConnectorQM() != NULL))
    {
        if (memcmp(origPkt.GetConnectorQM(), newPkt.GetConnectorQM(), sizeof(GUID)) != 0)
        {
            printf( "Connector ID mismatch");
            return false;
        }
    }
    else
    {
        if ((origPkt.GetConnectorQM() != NULL) || (newPkt.GetConnectorQM() != NULL))
        {
            printf( "Connector ID mismatch");
            return false;
        }
    }

   

    QUEUE_FORMAT origQueue;
    QUEUE_FORMAT newQueue;

    origPkt.GetDestinationQueue(&origQueue);
    newPkt.GetDestinationQueue(&newQueue);

    if (! CompareQueue(origQueue, newQueue))
    {
        printf( "Destination queue mismatch.");
        return false;
    }

    origPkt.GetAdminQueue(&origQueue);
    newPkt.GetAdminQueue(&newQueue);

    if (! CompareQueue(origQueue, newQueue))
    {
        printf( "Admin queue mismatch.");
        return false;
    }
    bool fAdminQueue = (origQueue.GetType() !=  QUEUE_FORMAT_TYPE_UNKNOWN);

    origPkt.GetResponseQueue(&origQueue);
    newPkt.GetResponseQueue(&newQueue);

    if (! CompareQueue(origQueue, newQueue))
    {
        printf( "Response queue mismatch.");
        return false;
    }


    if (origPkt.GetSentTime() != newPkt.GetSentTime())
    {
		printf( "SentTime mismatch.");
        return false;
	}


    if (origPkt.GetClass() != newPkt.GetClass())
    {
        printf( "Class mismatch. Expected: %d, Actual: %d", origPkt.GetClass(), newPkt.GetClass());
        return false;
    }
	


    if (fAdminQueue && (origPkt.GetAckType() != newPkt.GetAckType()))
    {
        printf("Ack type mismatch. Expected: %d, Actual: %d", origPkt.GetAckType(), newPkt.GetAckType());
        return false;
    }

    if (memcmp(origPkt.GetCorrelation(), newPkt.GetCorrelation(), PROPID_M_CORRELATIONID_SIZE) != 0)
    {
        printf( "Correlation mismatch");
        return false;
    }

    if (origPkt.GetApplicationTag() != newPkt.GetApplicationTag())
    {
        printf( "Application tag mismatch. Expected: %d, Actual: %d", origPkt.GetApplicationTag(), newPkt.GetApplicationTag());
        return false;
    }

    if (origPkt.GetBodyType() != newPkt.GetBodyType())
    {
        printf( "Body type mismatch. Expected: %d, Actual: %d", origPkt.GetBodyType(), newPkt.GetBodyType());
        return false;
    }

    if (origPkt.GetTitleLength() != newPkt.GetTitleLength())
    {
        printf( "Title length mismatch. Expected: %d, Actual: %d", origPkt.GetTitleLength(), newPkt.GetTitleLength());
        return false;
    }

    if (origPkt.GetTitleLength())
    {
        if (memcmp(origPkt.GetTitlePtr(), newPkt.GetTitlePtr(), (origPkt.GetTitleLength()*sizeof(WCHAR)) ) != 0)
        {
            printf( "Title mismatch: \n\tExpected: %.*ls., \n\tActual: %.*ls.\n", origPkt.GetTitleLength(), origPkt.GetTitlePtr(), newPkt.GetTitleLength(), newPkt.GetTitlePtr());
            return false;
        }
    }

    if (origPkt.GetMsgExtensionSize() != newPkt.GetMsgExtensionSize())
    {
        printf( "Extension size mismatch. Expected: %d, Actual: %d", origPkt.GetMsgExtensionSize(), newPkt.GetMsgExtensionSize());
        return false;
    }

    if (origPkt.GetMsgExtensionSize())
    {
        if (memcmp(origPkt.GetMsgExtensionPtr(), newPkt.GetMsgExtensionPtr(), origPkt.GetMsgExtensionSize()) != 0)
        {
            printf( "Extension mismatch.");
            return false;
        }
    }


    DWORD origBodySize;
    DWORD newBodySize;

    const UCHAR* pOrigBody = newPkt.GetPacketBody(&origBodySize);
    const UCHAR* pNewBody = origPkt.GetPacketBody(&newBodySize);

    if (origBodySize != newBodySize)
    {
        printf( "Body size mismatch. Expected: %d, Actual: %d", origBodySize, newBodySize);
        return false;
    }

    if (memcmp(pOrigBody,  pNewBody, origBodySize) != 0)
    {
        printf( "Body  mismatch.");
        return false;
    }

	DWORD OldPacketSize = origPkt.GetSize();
	DWORD NewPacketSize = newPkt.GetSize();
	DWORD NewPacketSizeReduced =   NewPacketSize - srmpSectionSize + ALIGNUP4_ULONG(origBodySize);
	if (OldPacketSize != NewPacketSizeReduced )
    {
        printf( "packet size mismatch. Expected: %d, Actual: %d",OldPacketSize, NewPacketSizeReduced);
        return false;
    }


   
    return true;
}


void
AppAllocatePacket(
             const QUEUE_FORMAT& ,
             UCHAR,
             DWORD pktSize,
             CACPacketPtrs& pktPtrs
             )
{
    pktPtrs.pPacket = reinterpret_cast<CBaseHeader*>(new UCHAR[pktSize]);
    pktPtrs.pDriverPacket = NULL;
}


PSID
AppGetCertSid(
	const BYTE*  /* pCertBlob */,
	ULONG        /* ulCertSize */,
	bool		 /* fDefaultProvider */,
	LPCWSTR      /* pwszProvName */,
	DWORD        /* dwProvType */
	)
{
	return NULL;
}


void
AppFreePacket(
    CACPacketPtrs& pktPtrs
    )
{
    delete [] pktPtrs.pPacket;
}


static DWORD GetSrmpSectionSize(size_t envsize, size_t HttpHeaderSize, size_t HttpBodySize )
{
	//
    // SRMP envelope
    //
    DWORD Size = CSrmpEnvelopeHeader::CalcSectionSize(numeric_cast<DWORD>(envsize));

    //
    // CompoundMessage
    //
    Size += CCompoundMessageHeader::CalcSectionSize(
                numeric_cast<DWORD>(HttpHeaderSize),
                numeric_cast<DWORD>(HttpBodySize)
                );

	return  Size;
}

static DWORD GetEodSectionSize(const CQmPacket& newPkt)
{
	if(!newPkt.IsEodIncluded())
		return 0;

 	DWORD EodStreamIdLen = newPkt.GetEodStreamIdSizeInBytes();
	DWORD OrderAckAddressLen = 	newPkt.GetEodOrderQueueSizeInBytes();

	
	return CEodHeader::CalcSectionSize(EodStreamIdLen, OrderAckAddressLen);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Convertors to and from SRMP library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{	
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    TrInitialize();
	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ");
    TrRegisterComponent(&MpTest, 1);

    if (argc != 1)
        Usage();

    XmlInitialize();
    MpInitialize(); 

    for(DWORD n = 100; n > 0; --n)
    {
        TrTRACE(MpTest, "Packet No %d", n);

	    //
        // Create MSMQ Packet
        //
        CBaseHeader* pkt = CreatePacket();
        
        AP<UCHAR> orgrel = reinterpret_cast<UCHAR*>(pkt);
        CQmPacket origPkt(pkt, NULL);
  
        //
        // SRMP Serialization
        //
        R<CSrmpRequestBuffers> SrmpRequestBuffers =  MpSerialize(
											origPkt,
											L"localhost",
											L"//myqueue"
											);

		wstring envstr = SrmpRequestBuffers->GetEnvelop();

	
        printf("SRMP - %ls", envstr.c_str());
        
        //
        // SRMP deserialization
        //
		AP<BYTE> HttpBody =  SrmpRequestBuffers->SerializeHttpBody();
		DWORD HttpBodySize = numeric_cast<DWORD>(SrmpRequestBuffers->GetHttpBodyLength());
		const char * HttpHeader = SrmpRequestBuffers->GetHttpHeader();
       	P<CQmPacket> newPkt = MpDeserialize(HttpHeader, HttpBodySize, HttpBody, NULL);

        
		//
		// We should adjust the packet size not to include the envelop && eod  section - because
		// it was not created by the test. It was created by the parser (receiver).
		//
		DWORD srmpSectionSize =  GetSrmpSectionSize(envstr.size(), strlen(HttpHeader), HttpBodySize );
	    DWORD EodSectionSize = GetEodSectionSize(*newPkt);
	   
        if (! Compare(origPkt, *newPkt, srmpSectionSize + EodSectionSize))
		{
			printf("test failed \n");
            return -1;
		}
    }
        
    TrTRACE(MpTest, "Complete successfully");

    WPP_CLEANUP();
    return 0;

} // _tmain


//
// Nedded for linking with fn.lib
//
LPCWSTR
McComputerName(
	void
	)
{
	return NULL;
}

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
	void
	)
{
	return 0;
}

//
// Nedded for linking with qal.lib
//
void AppNotifyQalWin32FileError(LPCWSTR , DWORD )throw()
{

}

void AppNotifyQalDirectoryMonitoringWin32Error(LPCWSTR , DWORD )throw()
{

}

void AppNotifyQalDuplicateMappingError(LPCWSTR, LPCWSTR )throw()
{

}


void AppNotifyQalInvalidMappingFileError(LPCWSTR )throw()
{

}


void AppNotifyQalXmlParserError(LPCWSTR )throw()
{

}

bool AppNotifyQalMappingFound(LPWSTR, LPWSTR)throw()
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmlisten.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmListen.h

Abstract:
    Multicast Listener declaration

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_MsmListen_H_
#define _MSMQ_MsmListen_H_

#include <mqwin64a.h>
#include <qformat.h>
#include <Ex.h>
#include "MsmReceive.h"


class CMulticastListener : public CReference
{
public:
    typedef std::list< R<CMulticastReceiver> > ReceiversList;

public:

    //
    // Constructor. Create the object and bind to the multicast group.
    //
    CMulticastListener(MULTICAST_ID id);

    //
    // Close the listener
    //
    void Close(void) throw();

    //
    // Return the multicast address and port
    //
    const MULTICAST_ID& MulticastId(void) const throw() 
    { 
        return m_MulticastId; 
    }

    //
    // Async accept completion handlers, class scope.
    //
    static void WINAPI AcceptSucceeded(EXOVERLAPPED* pov);
    static void WINAPI AcceptFailed(EXOVERLAPPED* pov);

    static void WINAPI TimeToRetryAccept(CTimer* pTimer);
    static void WINAPI TimeToCleanupUnusedReceiever(CTimer* pTimer);

private:

    //
    // Async accept completion handlers
    //
    void AcceptSucceeded(void);
    void AcceptFailed(void);
    void RetryAccept(void);

    //
    // Issue async accept request
    //
    void IssueAccept(void);

    //
    // Create a new receiver object and start receiving
    //
    void CreateReceiver(CSocketHandle& socket, LPCWSTR remoteAddr);

	void CleanupUnusedReceiver(void);

private:
    CCriticalSection m_cs;

    //
    // The multicast address and port
    //
    MULTICAST_ID m_MulticastId;

    //
    // This socket listens to the multicast address
    //
    CSocketHandle m_ListenSocket;

    //
    // This socket is used for receive. It is asynchronous variable that store 
    // in the object untill the asynchronous accept is completed
    //
    CSocketHandle m_ReceiveSocket;

    //
    // Async accept overlapped
    //
    EXOVERLAPPED m_ov;

    //
    // The connections to the multicast group
    //
    ReceiversList m_Receivers;

    CTimer m_retryAcceptTimer;

	LONG m_fCleanupScheduled;
	CTimer m_cleanupTimer;
	BYTE  m_AcceptExBuffer[100];

}; 

#endif // _MSMQ_MsmListen_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Msmp.h

Abstract:
    Multicast Session Manager private functions.

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_Msmp_H_
#define _MSMQ_Msmp_H_

#include <rwlock.h>
#include <mqexception.h>


const TraceIdEntry Msm = L"Multicast Session Manager";

#ifdef _DEBUG

void MsmpAssertValid(void);
void MsmpSetInitialized(void);
BOOL MsmpIsInitialized(void);
void MsmpRegisterComponent(void);

#else // _DEBUG

#define MsmpAssertValid() ((void)0)
#define MsmpSetInitialized() ((void)0)
#define MsmpIsInitialized() TRUE
#define MsmpRegisterComponent() ((void)0)

#endif // _DEBUG

void MsmpInitConfiguration(void);


#endif // _MSMQ_Msmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmreceive.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmReceive.h

Abstract:
    Multicast Receiver declaration

Author:
    Shai Kariv (shaik) 12-Sep-00

--*/

#pragma once

#ifndef _MSMQ_MsmReceive_H_
#define _MSMQ_MsmReceive_H_

#include <ex.h>
#include <rwlock.h>
#include <spi.h>


class CMulticastReceiver : public CReference
{
private:
    enum {
        xHeaderChunkSize = 256,
        xBodyChunkSize = 256,
    };

public:
    CMulticastReceiver(
        CSocketHandle& socket, 
        const MULTICAST_ID& MulticastId,
		LPCWSTR remoteAddr
        );

    void Shutdown(void) throw();


	bool IsUsed(void)
	{
		return (m_fUsed == TRUE);
	}


	void SetIsUsed(bool fUsed)
	{
		InterlockedExchange(&m_fUsed, static_cast<LONG>(fUsed));
	}

public:
    static VOID WINAPI ReceiveFailed(EXOVERLAPPED* pov);
    static VOID WINAPI ReceiveHeaderSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI ReceiveBodySucceeded(EXOVERLAPPED* pov);

private:
    static DWORD FindEndOfResponseHeader(LPCSTR buf, DWORD length);
    static DWORD GetContentLength(LPCSTR p, DWORD length);


private:
    void ReceiveHeaderChunk(void);
    void ReceiveHeaderSucceeded(void);

    void ReceiveBodyChunk(void);
    void ReceiveBodySucceeded(void);

    void ReceiveBody(void);
    void ReceivePacket(void);
    
    DWORD HandleMoreDataExistInHeaderBuffer(void);
    void ProcessPacket(void);

    void ReallocateHeaderBuffer(DWORD Size);

	R<ISessionPerfmon> CreatePerfmonInstance(LPCWSTR remoteAddr);

private:
    mutable CReadWriteLock m_pendingShutdown;
    
    MULTICAST_ID m_MulticastId;

    AP<char> m_pHeader;
    DWORD m_HeaderAllocatedSize;

    DWORD m_HeaderValidBytes;
    DWORD m_ProcessedSize;

    AP<BYTE> m_pBody;
    DWORD m_readSize;
    DWORD m_bodyLength;

    //
    // This socket is used for receive
    //
    CSocketHandle m_socket;

    //
    // Async receive overlapped
    //
    EXOVERLAPPED m_ov;

	long m_fUsed;

	R<ISessionPerfmon> m_pPerfmon;
};

#endif // _MSMQ_MsmReceive_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmmap.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmMap.cpp

Abstract:
    Multicast Session to queue mapping implementation.

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <qformat.h>
#include <Fn.h>
#include <Msm.h>
#include <rwlock.h>
#include <doublekeymap.h>
#include "Msmp.h"
#include "msmmap.h"
#include "MsmListen.h"

#include "msmmap.tmh"

using namespace std;

static CReadWriteLock s_rwlock;

typedef CDoubleKeyMap<QUEUE_FORMAT, MULTICAST_ID, CFunc_QueueFormatCompare, CFunc_MulticastIdCompare > MAP_QF_2_MC;
typedef map<MULTICAST_ID, R<CMulticastListener>, CFunc_MulticastIdCompare> MAP_MC_2_LISTENER;

static MAP_MC_2_LISTENER s_MulticastId2Listner;
static MAP_QF_2_MC s_Queueformat2MulticastId;


MULTICASTID_VALUES
MsmpMapGetBoundMulticastId(
    const QUEUE_FORMAT& QueueFormat
    )
    throw()
{
    CSR lock (s_rwlock);
    return s_Queueformat2MulticastId.get_key2set(QueueFormat);
}


QUEUEFORMAT_VALUES
MsmpMapGetQueues(
    const MULTICAST_ID& multicastId
    )
    throw()
{
    CSR lock (s_rwlock);
    return s_Queueformat2MulticastId.get_key1set(multicastId);
}


R<CMulticastListener>
MsmpMapGetListener(
    const MULTICAST_ID& multicastId
    )
    throw()
{
    CSR lock (s_rwlock);

    MAP_MC_2_LISTENER::iterator it = s_MulticastId2Listner.find(multicastId);
    if (it == s_MulticastId2Listner.end())
        return NULL;

    return it->second;
}


void MsmpMapRemove(const QUEUE_FORMAT& QueueFormat) throw()
{
    CSW lock (s_rwlock);

    //
    // Get a list of Multicast addresses that the Queue is bind too
    //
    MAP_QF_2_MC::KEY2SET multicastIds = s_Queueformat2MulticastId.get_key2set(QueueFormat);

    //
    // The Queue isn't bind to any multicast address
    //
    if (multicastIds.empty())
        return;

    //
    // Remove the mapping between the queue and the multicast address
    //
    s_Queueformat2MulticastId.erase_key1(QueueFormat);

    for (MAP_QF_2_MC::KEY2SET::iterator it = multicastIds.begin(); it != multicastIds.end(); ++it)
    {
        
        //
        // There is at least one more queue that binds to the multicast address. Don't
        // close the listener
        //
        if (! s_Queueformat2MulticastId.key2_empty(*it))
            continue;

        //
        // It is the last queue that is bind to the multicast address. Close
        // the listener and remove it from the map
        //
        MAP_MC_2_LISTENER::iterator itmc = s_MulticastId2Listner.find(*it);
        ASSERT(("Expected listner not found", itmc != s_MulticastId2Listner.end()));

        R<CMulticastListener> pListener = itmc->second;
        pListener->Close();

        s_MulticastId2Listner.erase(itmc);
    }
}


void
MsmpMapAdd(
    const QUEUE_FORMAT& QueueFormat,
    const MULTICAST_ID& multicastId,
    R<CMulticastListener>& pListener
    )
{
    CSW lock (s_rwlock);
    s_Queueformat2MulticastId.insert(QueueFormat, multicastId);

    try
    {
        s_MulticastId2Listner[multicastId] = pListener;   
    }
    catch(const exception&)
    {
        s_Queueformat2MulticastId.erase(QueueFormat, multicastId);

        TrERROR(Msm, "Failed to Add a listener to MSM DataBase");
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmreceive.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmReceive.cpp

Abstract:
    Multicast Receiver implementation

Author:
    Shai Kariv (shaik) 12-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <msi.h>
#include <mqwin64a.h>
#include <qformat.h>
#include <qmpkt.h>
#include <No.h>
#include "MsmListen.h"
#include "MsmReceive.h"
#include "MsmMap.h"
#include "Msm.h"
#include "Msmp.h"
#include "msi.h"
#include <mqsymbls.h>
#include <mqformat.h>

#include "msmreceive.tmh"

using namespace std;

//
// ISSUE-2000/10/17-urih must move DataTransferLength, FindEndOfResponseHeader and
// GetContentLength to global library (http library).
//


inline DWORD DataTransferLength(EXOVERLAPPED& ov)
{
    //
    // In win64, InternalHigh is 64 bits. Since the max chunk of data
    // we transfer in one operation is always less than MAX_UNIT we can cast
    // it to DWORD safetly
    //
    ASSERT(0xFFFFFFFF >= ov.InternalHigh);
	return static_cast<DWORD>(ov.InternalHigh);
}


DWORD CMulticastReceiver::FindEndOfResponseHeader(LPCSTR buf, DWORD length)
{
    if (4 > length)
        return 0;

    for(DWORD i = 0; i < length - 3; ++i)
    {
        if (buf[i] != '\r')
            continue;

        if ((buf[i+1] == '\n') && (buf[i+2] == '\r') && (buf[i+3] == '\n'))
        {
            return (i + 4);
        }
    }

    return 0;
}


const char xContentlength[] = "Content-Length:";

DWORD CMulticastReceiver::GetContentLength(LPCSTR p, DWORD length)
{
    const LPCSTR pEnd = p + length - 4;

    //
    // HTTP header must terminate with '\r\n\r\n'. We already parse
    // the header and find it as a legal HTTP header.
    //
    ASSERT(length >= 4);
    ASSERT(strncmp(pEnd, "\r\n\r\n", 4) == 0);


    while (p < pEnd)
    {
        if (_strnicmp(p, xContentlength , STRLEN(xContentlength)) == 0)
            return atoi(p + STRLEN(xContentlength));

        for(;;)
        {
            if ((p[0] == '\r') && (p[1] == '\n'))
            {
                p += 2;
                break;
            }

            ++p;
        }
    }

    //
    // Response header doesn't contain 'Content-Length' field. 
    //
    TrERROR(Msm, "Illegal HTTP header. Content-Length field wasn't found");
    throw exception();
}


void WINAPI CMulticastReceiver::ReceiveFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    Callback routine. The routine is called when receive of respond failed
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));


    //
    // get the message transport object
    //
    R<CMulticastReceiver> pmt = CONTAINING_RECORD(pov, CMulticastReceiver, m_ov);

    TrERROR(Msm, "Failed to receive data on multicast socket, shutting down. pmt=0x%p Status=0x%x", pmt.get(), pov->GetStatus());
    pmt->Shutdown();
}


void CMulticastReceiver::ReceiveHeaderSucceeded(void)
/*++

Routine Description:
    The routine is called when receive response completes succesfully.
  
Arguments:
    None
  
Returned Value:
    None.

--*/
{
    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
	DWORD cbTransfered = DataTransferLength(m_ov);
    if (cbTransfered == 0)
    {
        TrERROR(Msm, "Failed to receive response, connection was closed. pmt=0x%p", this);
        throw exception();
    }

    TrTRACE(Msm, "Received header. chunk bytes=%d, total bytes=%d", cbTransfered, m_HeaderValidBytes);

	//
	// Mark the receiver as used, so it will not be close in next cleanup phase
	//
    SetIsUsed(true);

    //
    // Find out if the entire header was received
    //
    m_HeaderValidBytes += cbTransfered;

    m_ProcessedSize = FindEndOfResponseHeader(m_pHeader, m_HeaderValidBytes);
    if (m_ProcessedSize != 0)
    {
		//
		// Update performance counters. Don't use the number of bytes that received since it contains
		// an extra data that recalculates later on ReceiveBodySucceeded function.
		//
		if (m_pPerfmon.get() != NULL)
		{
			m_pPerfmon->UpdateBytesReceived(m_ProcessedSize);
		}

        //
        // The enire header was received. Go and read the attached message
        //
        ReceiveBody();
        return;
    }


    if(m_HeaderAllocatedSize == m_HeaderValidBytes)
    {
        //
        // Header buffer is too small. Reallocate header buffer
        //
        ReallocateHeaderBuffer(m_HeaderAllocatedSize + xHeaderChunkSize);
    }

    //
    // Validate that we didn't read past the buffer
    //
    ASSERT(m_HeaderAllocatedSize > m_HeaderValidBytes);

    //
    // Receive next chunk of response header
    //
    ReceiveHeaderChunk();
}


void WINAPI CMulticastReceiver::ReceiveHeaderSucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when receive completes succesfully.
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));


    //
    // get the receiver object
    //
    R<CMulticastReceiver> pmt = CONTAINING_RECORD(pov, CMulticastReceiver, m_ov);

    try
    {
        pmt->ReceiveHeaderSucceeded();
    }
    catch(const exception&)
    {
        TrERROR(Msm, "Failed to process received response header, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }

}


void CMulticastReceiver::ReceiveBodySucceeded(void)
{
	DWORD cbTransfered = DataTransferLength(m_ov);

    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
    if (cbTransfered == 0)
    {
        TrERROR(Msm, "Failed to receive body, connection was closed. pmt=0x%p", this);
        throw exception();
    }

    ASSERT(cbTransfered <= (m_bodyLength - m_readSize));

	//
	// Mark the receiver as used, so it will not be close in next cleanup phase
	//
    SetIsUsed(true);

    m_readSize += cbTransfered;

	//
	// Update performance counters
	//
	if (m_pPerfmon.get() != NULL)
	{
		m_pPerfmon->UpdateBytesReceived(cbTransfered);
	}

    TrTRACE(Msm, "Received body. chunk bytes=%d, bytes remaining=%d", cbTransfered, (m_bodyLength - m_readSize));

    if (m_readSize == m_bodyLength)
    {
		//
		// Pad last four bytes of the buffer with zero. It is needed
		// for the QM parsing not to fail. four bytes padding and not two
		// are needed because we don't have currently solution to the problem
		// that the end of the buffer might be not alligned on WCHAR bouderies.
		//
		memset(&m_pBody[m_bodyLength], 0, 2 * sizeof(WCHAR));

        //
        // The entire body was read successfully, go process this packet.
        //
        ProcessPacket();

        //
        // begin the receive of next packet
        //
        ReceivePacket();
        return;
    }

    //
    // Receive next chunk of entity body
    //
    ReceiveBodyChunk();
}


void WINAPI CMulticastReceiver::ReceiveBodySucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when receive completes succesfully.
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));


    //
    // get the receiver object
    //
    R<CMulticastReceiver> pmt = CONTAINING_RECORD(pov, CMulticastReceiver, m_ov);

    try
    {
        pmt->ReceiveBodySucceeded();
    }
    catch(const exception&)
    {
        TrERROR(Msm, "Failed to process received body, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }
}


R<ISessionPerfmon> 
CMulticastReceiver::CreatePerfmonInstance(
	LPCWSTR remoteAddr
	)
{
	try
	{
		WCHAR strMulticastId[MAX_PATH];
		MQpMulticastIdToString(m_MulticastId, strMulticastId);

		return AppGetIncomingPgmSessionPerfmonCounters(strMulticastId, remoteAddr);
	}
	catch(const bad_alloc&)
	{
		return NULL;
	}
}


CMulticastReceiver::CMulticastReceiver(
    CSocketHandle& socket,
    const MULTICAST_ID& MulticastId,
	LPCWSTR remoteAddr
    ):
    m_socket(socket.detach()),
    m_MulticastId(MulticastId),
    m_pHeader(new char[xHeaderChunkSize]),
    m_HeaderAllocatedSize(xHeaderChunkSize),
    m_HeaderValidBytes(0),
    m_ProcessedSize(0),
    m_bodyLength(0),
    m_readSize(0),
    m_ov(ReceiveHeaderSucceeded, ReceiveFailed),
    m_fUsed(TRUE),
    m_pPerfmon(CreatePerfmonInstance(remoteAddr))
{
    ASSERT(("Must have a valid socket to receive", m_socket != INVALID_SOCKET));
    ExAttachHandle(reinterpret_cast<HANDLE>(*&m_socket));

    ReceivePacket();
}


void CMulticastReceiver::ReallocateHeaderBuffer(DWORD Size)
{
    ASSERT(Size > m_HeaderAllocatedSize);
    char* p = new char[Size];
    memcpy(p, m_pHeader, m_HeaderAllocatedSize);
    m_pHeader.free();
    m_pHeader = p;
    m_HeaderAllocatedSize = Size;
}


void CMulticastReceiver::ReceiveHeaderChunk(void)
{
    ASSERT(("Can't read 0 bytes from the network", ((m_HeaderAllocatedSize - m_HeaderValidBytes) > 0)));

    //
    // Increment refernce count for asynchronous context
    //
    R<CMulticastReceiver> ar = SafeAddRef(this);

    //
    // Protect m_socket from shutdown
    //
    CSR readLock(m_pendingShutdown);

    //
    // Receive next response header chunk
    //
    NoReceivePartialBuffer(
        m_socket, 
        m_pHeader + m_HeaderValidBytes, 
        m_HeaderAllocatedSize - m_HeaderValidBytes, 
        &m_ov
        ); 
    
    ar.detach();
}


DWORD CMulticastReceiver::HandleMoreDataExistInHeaderBuffer(void)
{
    ASSERT(("Body should be exist", (m_pBody.get() != NULL)));

    if (m_HeaderValidBytes == m_ProcessedSize) 
    {
        //
        // All the data already proccessed
        //
        return 0;
    }

    DWORD copySize = min(m_bodyLength,  (m_HeaderValidBytes - m_ProcessedSize));
    memcpy(m_pBody, (m_pHeader + m_ProcessedSize), copySize);
    m_ProcessedSize += copySize;
    
    return copySize;
}


void CMulticastReceiver::ReceiveBodyChunk(void)
{
    ASSERT(("Can't read 0 bytes from the network", ((m_bodyLength - m_readSize) > 0)));

    //
    // Increment refernce count for asynchronous context
    //
    R<CMulticastReceiver> ar = SafeAddRef(this);

    //
    // Protect m_socket
    //
    CSR readLock(m_pendingShutdown);


    //
    // Receive the entity body chunck to the same buffer, as it is ignored
    //
    NoReceivePartialBuffer(
        m_socket, 
        m_pBody + m_readSize, 
        m_bodyLength - m_readSize,
        &m_ov
        ); 

    ar.detach();
}


void CMulticastReceiver::ReceiveBody(void)
{
    //
    // Get the packet size
    //
    m_bodyLength = GetContentLength(m_pHeader, m_ProcessedSize);
    
    ASSERT(("Invalid body length", m_bodyLength != 0));
    ASSERT(("Previous body shouldn't be exist", (m_pBody.get() == NULL)));

    //
    // Allocate buffer for the packet. Allocate more 4 bytes to add null termination.
	// Allocates 4 bytes and not 2 to solve alligned on WCHAR bouderies	problem
    //
    m_pBody = new BYTE[m_bodyLength + 2* sizeof(WCHAR)];
    m_readSize = 0;

    #pragma PUSH_NEW
    #undef new

            new (&m_ov) EXOVERLAPPED(ReceiveBodySucceeded, ReceiveFailed);

    #pragma POP_NEW

    //
    // In previous phase we read more than we needed. Copy the spare data to the header 
    // update the counter and behave like next read is completed
    //
    DWORD extraDataSize = HandleMoreDataExistInHeaderBuffer();

    if (extraDataSize == 0)
    {
        ReceiveBodyChunk();
        return;
    }

    //
    // The body contains data, go and process it before calling reading next chunk
    //
    m_ov.InternalHigh = extraDataSize;
    R<CMulticastReceiver> ar = SafeAddRef(this);

    m_ov.SetStatus(STATUS_SUCCESS);
    ExPostRequest(&m_ov);

    ar.detach();
}


void CMulticastReceiver::ReceivePacket(void)
{
    if (m_HeaderValidBytes > m_ProcessedSize) 
    {
        memcpy(m_pHeader, (m_pHeader + m_ProcessedSize), (m_HeaderValidBytes - m_ProcessedSize));
        m_HeaderValidBytes = (m_HeaderValidBytes - m_ProcessedSize);
    }
    else
    {
        m_HeaderValidBytes = 0;
    }

    m_ProcessedSize = 0;


    //
    // Initialize the Overlapped with receive response call back routines
    //
    #pragma PUSH_NEW
    #undef new

        new (&m_ov) EXOVERLAPPED(
                                ReceiveHeaderSucceeded, 
                                ReceiveFailed
                                );

    #pragma POP_NEW

    //
    // Receive first chunk of response header
    //
    ReceiveHeaderChunk();
}


void CMulticastReceiver::ProcessPacket(void)
{
    try
    {
        TrTRACE(Msm, "Receive multicast packet on id %d:%d", m_MulticastId.m_address, m_MulticastId.m_port);

        QUEUEFORMAT_VALUES qf = MsmpMapGetQueues(m_MulticastId);

        //
        // NULL terminate the http header: \r\n\r\n ==> \r\n00
        //
        DWORD end = FindEndOfResponseHeader(m_pHeader, m_HeaderValidBytes);
        ASSERT(end >= 4);
        m_pHeader[end - 2] = 0;
        m_pHeader[end - 1] = 0;

        for(QUEUEFORMAT_VALUES::iterator it = qf.begin(); it != qf.end(); ++it)
        {
            AppAcceptMulticastPacket(m_pHeader.get(), m_bodyLength, m_pBody.get(), *it);
        }

		//
		// Update performance number of the number the response messages
		//
		if (m_pPerfmon.get() != NULL)
		{
			m_pPerfmon->UpdateMessagesReceived();	
		}
    }
    catch(const exception&)
    {
        TrERROR(
            Msm, 
            "Reject multicast packet on %d:%d due to processing failure (queue already unbind or illegal SRM packet", 
            m_MulticastId.m_address, 
            m_MulticastId.m_port
            );
    }

    m_pBody.free();
    m_readSize = 0;
    m_bodyLength = 0;
}


void CMulticastReceiver::Shutdown(void) throw()
{
    //
    // Protect m_socket, m_state 
    //
    CSW writeLock(m_pendingShutdown);

    if (m_socket == INVALID_SOCKET) 
    {
          return;
    }

    closesocket(m_socket.detach());

    //
    // Set the receiver as unused
    //
    SetIsUsed(false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\test\msmtestp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmTestp.h

Abstract:
    Multicast session manager test, private header.

Author:
    Uri Habusha (urih) 31-Oct-99

--*/

#pragma once

const TraceIdEntry MsmTest = L"Multicast Session Manager Test";

bool IsFailed(void);
void UpdateNoOfsentMessages(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmmap.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmMap.h

Abstract:
    Multicast Session to queue mapping declaration.

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_MsmMap_H_
#define _MSMQ_MsmMap_H_


class CMulticastListener;

inline bool operator < (const GUID& k1, const GUID& k2)
{
    return (memcmp(&k1, &k2, sizeof(GUID)) < 0);
}

//
// less function, using to compare QUEUE_FORMAT in STL data structure
//
struct CFunc_QueueFormatCompare : public std::binary_function<const QUEUE_FORMAT&, const QUEUE_FORMAT&, bool>
{
    bool operator() (const QUEUE_FORMAT& qf1, const QUEUE_FORMAT& qf2) const
    {
        if (qf1.GetType() != qf2.GetType())
        {
            return (qf1.GetType() < qf2.GetType());
        }

        if (qf1.GetType() == QUEUE_FORMAT_TYPE_PUBLIC)
        {
            return (qf1.PublicID() < qf2.PublicID());
        }

        ASSERT(("Must be private format name here!", qf1.GetType() == QUEUE_FORMAT_TYPE_PRIVATE));

        if (qf1.PrivateID().Uniquifier != qf2.PrivateID().Uniquifier)
        {
            return (qf1.PrivateID().Uniquifier < qf2.PrivateID().Uniquifier);
        }

        return (qf1.PrivateID().Lineage < qf2.PrivateID().Lineage);
    }
};


struct CFunc_MulticastIdCompare : public std::binary_function<const MULTICAST_ID&, const MULTICAST_ID&, bool>
{
    bool operator() (const MULTICAST_ID& k1, const MULTICAST_ID& k2) const
    {
        return ((k1.m_address < k2.m_address) ||
                ((k1.m_address == k2.m_address) && (k1.m_port < k2.m_port)));
    }
};


typedef std::set<MULTICAST_ID, CFunc_MulticastIdCompare> MULTICASTID_VALUES;
typedef std::set<QUEUE_FORMAT, CFunc_QueueFormatCompare> QUEUEFORMAT_VALUES;


void
MsmpMapAdd(
    const QUEUE_FORMAT& QueueFormat,
    const MULTICAST_ID& multicastId,
    R<CMulticastListener>& pListener
    );


void 
MsmpMapRemove(
    const QUEUE_FORMAT& QueueFormat
    ) 
    throw();


MULTICASTID_VALUES
MsmpMapGetBoundMulticastId(
    const QUEUE_FORMAT& QueueFormat
    )
    throw();


QUEUEFORMAT_VALUES
MsmpMapGetQueues(
    const MULTICAST_ID& multicastId
    )
    throw();


R<CMulticastListener>
MsmpMapGetListener(
    const MULTICAST_ID& multicastId
    )
    throw();


#endif // _MSMQ_MsmMap_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\test\msmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmTest.cpp

Abstract:
    Multicast Session Manager library test

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <msi.h>
#include <Ex.h>
#include <No.h>
#include <Cm.h>
#include <Msm.h>
#include <spi.h>

#include "MsmTest.tmh"

static DWORD s_FailedRate = 0;
static DWORD s_NoOfMessages = 1000;
static HANDLE s_hEvent;

const TraceIdEntry MsmTest = L"Multicast Session Manager Test";

//
// The guid of a public queue
//
const GUID xQueueId = { /* c4f259a1-9c90-42a8-8e83-10e65d084719 */
    0xc4f259a1,
    0x9c90,
    0x42a8,
    {0x8e, 0x83, 0x10, 0xe6, 0x5d, 0x08, 0x47, 0x19}
};

const MULTICAST_ID xMulticastId = { 1234, 5678 };

extern "C"
BOOL
APIENTRY
AcceptEx (
    IN SOCKET,
    IN SOCKET,
    IN PVOID,
    IN DWORD,
    IN DWORD,
    IN DWORD,
    OUT LPDWORD,
    IN LPOVERLAPPED lpOverlapped
    )
{
    ASSERT(lpOverlapped != NULL);

    EXOVERLAPPED* pov = static_cast<EXOVERLAPPED*>(lpOverlapped);

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);

    return TRUE;
}


extern "C"
void
APIENTRY
GetAcceptExSockaddrs( 
  PVOID ,       
  DWORD ,  
  DWORD ,  
  DWORD ,  
  LPSOCKADDR *,  
  LPINT ,  
  LPSOCKADDR *,  
  LPINT   
)
{
}


void CmQueryValue(const RegEntry&, CTimeDuration* pValue)
{
    *pValue = CTimeDuration(rand());
}


bool IsFailed(void)
{
    if (s_FailedRate == 0)
        return FALSE;

    return ((DWORD)(rand() % 100) < s_FailedRate);
}


void
AppAcceptMulticastPacket(
    const char* ,
    DWORD ,
    const BYTE* ,
    const QUEUE_FORMAT& 
    )
{
}


class CSessionPerfmon : public ISessionPerfmon
{
public:
    CSessionPerfmon() : m_fInstanceCreated(false) 
    {
    }

    ~CSessionPerfmon()
    {
    }
    
	void CreateInstance(LPCWSTR)
	{
		m_fInstanceCreated = true;
	}

	void UpdateBytesSent(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesSent(void)
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateBytesReceived(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesReceived(void)
    {
		ASSERT(m_fInstanceCreated);
    }

private:
	bool m_fInstanceCreated;
};


R<ISessionPerfmon>
AppGetIncomingPgmSessionPerfmonCounters(
	LPCWSTR strMulticastId,
	LPCWSTR 
	)
{
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;
	pPerfmon->CreateInstance(strMulticastId);

	return pPerfmon;
}


void Usage(void)
{
	printf("Usage: msmtest -n <no of messages> [-f xxx] [-h]\n");
    printf("\tn - Number of messages\n");
	printf("\tf - Fail rate\n");
	printf("\th - Print this message\n");
	exit(-1);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Message Transport library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&MsmTest, 1);

    --argc;
    ++argv;

    s_FailedRate = 0;
    
    while (argc > 0)
	{
		if (argv[0][0] != L'-') 
			Usage();

		switch(argv[0][1])
		{
            case L'n':
            case L'N':
                s_NoOfMessages = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
                break;

            case L'f':
			case L'F':
		        s_FailedRate = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
				break;


            default:
				Usage();
		}
    }

    ExInitialize(5);
    NoInitialize();
    MsmInitialize();

    s_hEvent = CreateEvent(NULL, FALSE, FALSE, L"");

    bool fFailed = false;

    do
    {
        try
        {
            QUEUE_FORMAT q1(xQueueId);

            MsmBind(q1, xMulticastId);
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
    
    WaitForSingleObject(s_hEvent, INFINITE);

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mt.cpp

Abstract:
    Message Transport implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <st.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"

#include "mt.tmh"

R<CTransport>
MtCreateTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT targetPort,
	USHORT nextHopPort,
	LPCWSTR queueUrl,
	IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	const CTimeDuration& responseTimeout,
    const CTimeDuration& cleanupTimeout,
	bool  fSecure,
    DWORD SendWindowinBytes,
    DWORD SendWindowinPackets
    )
{
    MtpAssertValid();

    ASSERT((targetHost.Length() != 0) && (targetHost.Buffer() != NULL));
    ASSERT((nextHop.Length() != 0) && (nextHop.Buffer() != NULL));
    ASSERT((nextUri.Length() != 0) && (nextUri.Buffer() != NULL));
    ASSERT(queueUrl != NULL);
    ASSERT(pMessageSource != NULL);

	ISocketTransport* pWinsock; 
	if(!fSecure)
	{
		pWinsock = StCreateSimpleWinsockTransport();
	}
	else
	{
		bool fUseProxy = (nextHop 	!= 	targetHost);
		pWinsock = StCreateSslWinsockTransport(targetHost, targetPort, fUseProxy);
	}
	P<ISocketTransport> Winsock(pWinsock);

    TrTRACE(
		Mt, 
		"Create new message transport.  SendWindowinBytes = %d, SendWindowinPackets = %d", 
        SendWindowinBytes,
        SendWindowinPackets
		);


	CMessageTransport* p = new CMessageTransport(
										targetHost,
										nextHop,
										nextUri,
										nextHopPort,
										queueUrl, 
										pMessageSource,
										pPerfmon,
										responseTimeout, 
										cleanupTimeout,
										Winsock,
                                        SendWindowinBytes,
                                        SendWindowinPackets
										);
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\test\no.cpp ===
#include <libpch.h>
#include "No.h"
#include "Ex.h"
#include "MsmTestp.h"

#include "no.tmh"

using namespace std;

const char xShortOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xShortFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xLongOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xLongFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xOkResponseNoContentLength[] =
                            		"HTTP/1.1 200 OK\r\n"
									"\r\n"
                                    ;

const char xInformativeResponseNoContentLength[] =
                            		"HTTP/1.1 100 Continue\r\n"
									"\r\n"
									;

const char xFailResponseNoContentLength[] =
                            		"HTTP/1.1 500 Internal Server Error\r\n"
									"\r\n"
									;

const LPCSTR xResponses[] = {
	xShortOkResponse,
	xShortFailResponse,
	xLongOkResponse,
	xLongFailResponse,
    xOkResponseNoContentLength,
    xInformativeResponseNoContentLength,
    xFailResponseNoContentLength,
  
  };

struct SockInfo
{
    SockInfo(void) : 
        pBuffer(NULL),
        nBytesToRead(0),
        ByteReads(0),
        pov(NULL)
    {
    }

    CCriticalSection m_csResponse;
    list<LPCSTR> response;
    DWORD ByteReads;

    VOID* pBuffer;                                     
    DWORD nBytesToRead; 
    EXOVERLAPPED* pov;
};

typedef map<SOCKET, SockInfo*> SOCKET2INFO;
SOCKET2INFO s_mapSockInfo;


//
VOID
NoInitialize(
    VOID
    )
{
}


static SOCKET s_socket = 0;

SOCKET 
NoCreateStreamConnection(
    VOID
    )
{
    if (IsFailed())
    {
        throw exception();
    }

    s_mapSockInfo[++s_socket] = new SockInfo;

    TrTRACE(MsmTest, "Create Socket 0x%I64x", s_socket);

    return s_socket;
}


VOID 
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN&,
    EXOVERLAPPED* pov
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


VOID
NoCloseConnection(
    SOCKET Socket
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    TrTRACE(MsmTest, "Close Socket 0x%I64x", Socket);

    if (it != s_mapSockInfo.end())
    {
        SockInfo* p = it->second;
        
        if (p->pov != NULL)
        {
            EXOVERLAPPED* pov = p->pov;

            p->pBuffer = NULL;
            p->pov = NULL;
            p->nBytesToRead = 0;

            pov->SetStatus(STATUS_UNSUCCESSFUL);
            ExPostRequest(pov);
        }

        s_mapSockInfo.erase(it);
        delete p;
    }
}


VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF*,
    DWORD, 
    EXOVERLAPPED* pov
    )
{ 
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }


    SockInfo* p = it->second;               
    {
        CS lock(p->m_csResponse);
        p->response.push_back(xResponses[rand() % TABLE_SIZE(xResponses)]);
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);

    if (p->pov != NULL)
    {
        //
        // pending reponse receive
        //
        EXOVERLAPPED* pov = p->pov;
        PVOID pBuffer = p->pBuffer;
        DWORD nBytesToRead = p->nBytesToRead;
        p->pBuffer = NULL;
        p->pov = NULL;
        p->nBytesToRead = 0;

        NoReceivePartialBuffer(Socket, pBuffer, nBytesToRead, pov);
    }
}


VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD nBytesToRead, 
    EXOVERLAPPED* pov
    )
{
    TrTRACE(MsmTest, "NoReceivePartialBuffer: Socket=0x%I64x Buffer=0x%p BytesToRead=%d ov=0x%p", Socket, pBuffer, nBytesToRead, pov);
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        pov->InternalHigh = 0;

        if (rand()%4 == 0)
            throw exception();

        if (rand()%4 == 1)
        {
            pov->SetStatus(STATUS_SUCCESS);
        }
        else
        {
            pov->SetStatus(STATUS_UNSUCCESSFUL);
        }

        ExPostRequest(pov);
        
        return;
    }

    SockInfo* p = it->second;               

    {
        CS lock(p->m_csResponse);
        if (p->response.empty())
        {
            p->pBuffer = pBuffer;                                   
            p->nBytesToRead = nBytesToRead;
            p->pov = pov;
            return;
        }
    }

    p->pBuffer = NULL;                                   
    p->nBytesToRead = 0;
    p->pov = NULL;

    LPCSTR response;
    {
        CS lock(p->m_csResponse);
        response = p->response.front();
    }

    DWORD length = min(nBytesToRead, (strlen(response) - p->ByteReads));

    memcpy(pBuffer, (response + p->ByteReads), length);
    p->ByteReads += length;

    pov->InternalHigh = length;
    
    bool fReadAllResponse = false;
    if (p->ByteReads == strlen(response))
    {
        CS lock(p->m_csResponse);
        p->response.pop_front();
        p->ByteReads = 0;
        fReadAllResponse = true;
    }
     
    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtget.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - Connect implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"

#include "mtget.tmh"

void CMessageTransport::GetNextEntry(void)
{
    try
    { 
        AddRef();
        m_pMessageSource->GetFirstEntry(&m_requestEntry, m_requestEntry.GetAcPacketPtrs());
    }
    catch (const exception&)
    {    
        Release();
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtInit.cpp

Abstract:
    Message Transport initialization

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtMessageTrace.h"

#include "mtinit.tmh"

VOID
MtInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Message Transport library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Message Transport library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MtpIsInitialized());
    MtpRegisterComponent();

#ifdef _DEBUG
	CMtMessageTrace::Initialize();
#endif

    MtpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtDebug.cpp

Abstract:
    Message Transport debugging

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"

#include "mtdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Message Transport state
//
void MtpAssertValid(void)
{
    //
    // MtInitalize() has *not* been called. You should initialize the
    // Message Transport library before using any of its funcionality.
    //
    ASSERT(MtpIsInitialized());

    //
    // TODO:Add more Message Transport validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void MtpSetInitialized(void)
{
    LONG fMtAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Message Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fMtAlreadyInitialized);
}


BOOL MtpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Mt,

    //
    // TODO: Add Message Transport sub-component trace ID's to be used with TrXXXX.
    // For example, MtInit, as used in:
    // TrERROR(MtInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "MtDumpState(queue path name)",
        "Dump Message Transport State to debugger",
        DumpState
    ),

    //
    // TODO: Add Message Transport debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void MtpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtmessagetrace.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtMessageTrace.h

Abstract:
    Message Trace class - designed to log message in befor sent to network

Author:
   Gil Shafriri (gilsh) 12-Feb-2001

--*/  
#ifndef MtMessageTrace_H
#define MtMessageTrace_H


#ifdef _DEBUG

class CMtMessageTrace
{
public:
	static void Initialize();
	static void LogSendData(const WSABUF* buffers, size_t size);

private:
	static CCriticalSection m_cs;
	static AP<WCHAR> m_LogFileLocaPath;
	static CHandle m_hFile;
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtconnect.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - Connect implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Tm.h"
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"

#include "mtconnect.tmh"

void CMessageTransport::RequeuePacket(void)
/*++

Routine Description:
    The routine returns entry to the queue
  
Arguments:
    None.
  
Returned Value:
    None.

--*/
{
    CACPacketPtrs& acPtrs = m_requestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);

    CQmPacket Entry(acPtrs.pPacket, acPtrs.pDriverPacket);
    m_pMessageSource->Requeue(&Entry);

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;
}


void WINAPI CMessageTransport::GetPacketForConnectingSucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine calls when a new packet is received for sending on non
    connecting message transport. Getting the message uses as a trigger 
    for creating a connection
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pRequest, CMessageTransport, m_requestEntry);

    TrTRACE(Mt, "Connected to %ls:%d. pmt = 0x%p", pmt->m_host, pmt->m_port, pmt.get());

 
    //
    // Return the message to the queue before create the connection.
    //
    pmt->RequeuePacket();
    try
    {
        if (! pmt->TryToCancelCleanupTimer())
            return;

        pmt->Connect();
    }
    catch(const exception&)
    {
        TrERROR(Mt, "Failed to create connection to '%ls:%d'. pmt = 0x%p", pmt->m_host, pmt->m_port, pmt.get());
        pmt->Shutdown();
        throw;
    }

}


void WINAPI CMessageTransport::GetPacketForConnectingFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine calls when UMS fails to get a a new packet from the queue.
    The message transport is in non connecting state, so we try to get the 
    message sometime latter
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    //
    // Retrieve message transport
    //
	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pRequest, CMessageTransport, m_requestEntry);

    TrERROR(Mt, "Failed to get a new entry for connecting. pmt = 0x%p", pmt.get());
    
    pmt->Shutdown();
}





void CMessageTransport::InitPerfmonCounters(void)
{
	m_pPerfmon->CreateInstance(QueueUrl());
}


void CMessageTransport::ConnectionSucceeded(void)
/*++

Routine Description:
    The routine is called when create a connection completes successfully
  
Arguments:
    None.
  
Returned Value:
    None.

--*/
{
    m_pConnection = m_SocketTransport->GetConnection();
	ASSERT(m_pConnection.get()  != NULL);

    
    TrTRACE(Mt, "Connected to '%ls'",  m_host);

    //
    // Create Session permormance counter structure
    //
	InitPerfmonCounters();

    //
    // Initialize the EXOVERLAPPED with send callback routines
    m_requestEntry = CRequestOv(GetPacketForSendingSucceeded, GetPacketForSendingFailed);

    

    StartCleanupTimer();

    //
    // Now, connection was established. The message Transport is ready to 
    // get a message for sending
    //
    GetNextEntry();

    //
    // Allow receive on the socket. 
    // 
    ReceiveResponse();
}


void WINAPI CMessageTransport::ConnectionSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    R<CMessageTransport> pmt = CONTAINING_RECORD(pov, CMessageTransport, m_connectOv);

    //
    // Connect has completed successfully, go and start delivering the messages.
    // If delivery failes here, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //
    // Do not schedule a retry here if this failes as this is the first send,
    // and any failure indicates a fatal error. (unlike after first delivery).
    //
    pmt->ConnectionSucceeded();
}


void WINAPI CMessageTransport::ConnectionFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when create a connection failed
  
Arguments:
    None.
    
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    R<CMessageTransport> pmt = CONTAINING_RECORD(pov, CMessageTransport, m_connectOv);
     	
    TrERROR(Mt, "Failed to connect to '%ls'. pmt=0x%p", pmt->m_host, pmt.get());
    pmt->Shutdown();
}


void CMessageTransport::Connect(void)
/*++

Routine Description:
    The routine creates a winsock connection with the destination. The operation
    is a synchronous and on completion a call back routine is called
  
Arguments:
    None.
  
Returned Value:
    None.

Note:
    No Timers are running concurrently, so this function can not be interrupted
    by Shutdown. No need to protect m_socket etc.

--*/
{
	std::vector<SOCKADDR_IN> Address;
    bool fRet = m_SocketTransport->GetHostByName(m_host, &Address); 
    if(!fRet)
    {
		//
		// For those who debug  address resolution faliure :
		// If proxy is required check if the  proxy is defined for MSMQ by proxycfg.exe tool.
		//
        TrERROR(Mt, "Failed to resolve address for '%ls'", m_host);
        throw exception();
    }
	ASSERT(Address.size() > 0);

    Address[0].sin_port = htons(m_port);

    TrTRACE(Mt, "Resolved address for '%ls'. Address=" LOG_INADDR_FMT,  m_host, LOG_INADDR(Address[0]));

    //
    // Create a socket for the connection (no need to protect m_socket)
    //
    TrTRACE(Mt, "Got socket for connection. socket=0x%p, pmt=0x%p", socket, this);

 
    //
    // Start asynchronous connection
    //
    try
    {
        AddRef();
        m_SocketTransport->CreateConnection(Address[0], &m_connectOv);
    }
    catch(const exception&)
    {
		TrERROR(Mt, "Failed to connect to '%ls'", m_host);
        Release();
        throw;
    }
}


void CMessageTransport::Shutdown(Shutdowntype Shutdowntype) throw()
{
    //
    // Now Shutdown is in progress, cancel all timers
    //
    TryToCancelCleanupTimer();
    CancelResponseTimer();

	//
    // Protect m_socket, m_state 
    //
    CS cs(m_pendingShutdown);
	
	if (State() == csShutdownCompleted) 
    {
          return;
    }
	
	//
	// If shut down was called because an error - reprot it.
	//
	if(Shutdowntype == ERROR_SHUTDOWN)
	{
		if(m_DeliveryErrorClass == MQMSG_CLASS_NORMAL)
		{
			m_pMessageSource->OnRetryableDeliveryError();
		}
		else
		{
			m_pMessageSource->OnAbortiveDeliveryError(m_DeliveryErrorClass);
		}
	}


	if (m_pConnection.get() != NULL)
    {
        m_pConnection->Close();
    }


    //
    // Cancle peding request from the queue
    //
    m_pMessageSource->CancelRequest();


	 //
    // Removes the message transport from transport manager data structure, and creates
    // a new transport to the target
    //
    AppNotifyTransportClosed(QueueUrl());
   
    State(csShutdownCompleted);
	TrTRACE(Mt,"Shutdown completed (Refcount = %d)",GetRef());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtmessagetrace.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtMessageTrace.cpp

Abstract:
    Implementing Message Trace class (MtMessageTrace.h)

Author:
   Gil Shafriri (gilsh) 12-Feb-2001

--*/  


#include <libpch.h>

#ifdef _DEBUG

#include <cm.h>
#include <tr.h>
#include "mtp.h"
#include "MtMessageTrace.h"

#include "MtMessageTrace.tmh"

AP<WCHAR> CMtMessageTrace::m_LogFileLocaPath = NULL;
CCriticalSection CMtMessageTrace::m_cs;
CHandle CMtMessageTrace::m_hFile;


void CMtMessageTrace::Initialize()
{
	CmQueryValue(
        RegEntry(NULL, L"HttpMessageTraceFilePath"),
        &m_LogFileLocaPath
        );
			  
	
	if(m_LogFileLocaPath.get() == NULL)
		return;


	CHandle hFile = CreateFile(
				m_LogFileLocaPath,
				GENERIC_WRITE,
				FILE_SHARE_READ,
				NULL,
				CREATE_ALWAYS,
			  	FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
				NULL
				);

	
	if(hFile == INVALID_HANDLE_VALUE )
	{
		TrERROR(Mt,"could not create logfile %ls error %x ",m_LogFileLocaPath.get(), GetLastError());
		m_LogFileLocaPath.free();
		return;
	}

	*(&m_hFile) = hFile.detach();
}



void CMtMessageTrace::LogSendData(const WSABUF* buffers, size_t size)
{
	if(m_LogFileLocaPath.get() == NULL)
		return;

	CS cs(m_cs);
  
	const char StartLogStr[]= "\r\n **** Start http Message data **** \r\n";
	DWORD Written; 
 	WriteFile(m_hFile, StartLogStr, STRLEN(StartLogStr) , &Written, NULL);

	for(size_t i =0; i< size; ++i)
	{
		WriteFile(m_hFile, buffers[i].buf, buffers[i].len, &Written, NULL);
	}

	const char EndLogStr[]= "\r\n **** End http Message data **** \r\n";
	WriteFile(m_hFile, EndLogStr, STRLEN(EndLogStr) , &Written, NULL);
}






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtobj.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mt.cpp

Abstract:
    Message Transport class - implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"
#include "MtSendMng.h"

#include "mtobj.tmh"

bool CMessageTransport::TryToCancelCleanupTimer(void)
{
    if (!ExCancelTimer(&m_cleanupTimer))
        return false;

    Release();
    return true;
}

void CMessageTransport::StartCleanupTimer(void)
{
    ASSERT(!m_cleanupTimer.InUse());

    m_fUsed = false;
    
    AddRef();
    ExSetTimer(&m_cleanupTimer, m_cleanupTimeout);
}


void WINAPI CMessageTransport::TimeToCleanup(CTimer* pTimer)
{
    R<CMessageTransport> pmt = CONTAINING_RECORD(pTimer, CMessageTransport, m_cleanupTimer);

    if (pmt->m_fUsed)
    {
        pmt->StartCleanupTimer();
        return;
    }

    TrERROR(Mt, "Transport is idle, shutting down. pmt=0x%p", pmt.get());
    pmt->Shutdown(IDLE_SHUTDOWN);
}

static WCHAR* ConvertTargetUriToString(const xwcs_t& Uri)
{
/*++

Routine Description:
    Conver uri buffer to string - converting the first L'\' to L'/'
	because proxy look for L'/' caracter as termination of the host name in the uri.
  
Arguments:
    Uri - Uri buffer
  
Returned Value:
    converted Uri string (caller should delete[])

--*/
	WCHAR* strUri =  Uri.ToStr();
	ASSERT(wcslen(strUri) ==  static_cast<const size_t&>(Uri.Length()));
	WCHAR* find = std::find(strUri, strUri+Uri.Length(), L'\\');
	if(find != strUri+Uri.Length())
	{
		*find =  L'/';
	}
	return strUri;
}


CMessageTransport::CMessageTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT port,
    LPCWSTR queueUrl,
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	const CTimeDuration& responseTimeout,
    const CTimeDuration& cleanupTimeout,
	P<ISocketTransport>& SocketTransport,
    DWORD SendWindowinBytes,
    DWORD SendWindowinPackets
    ) :
    CTransport(queueUrl),
    m_targetHost(targetHost.ToStr()),
    m_host(nextHop.ToStr()),
    m_uri(ConvertTargetUriToString(nextUri)),
    m_port(port),
    m_pMessageSource(SafeAddRef(pMessageSource)),
    m_requestEntry(GetPacketForConnectingSucceeded, GetPacketForConnectingFailed),
    m_connectOv(ConnectionSucceeded, ConnectionFailed),
    m_responseOv(ReceiveResponseHeaderSucceeded, ReceiveResponseFailed), 
    m_responseTimer(TimeToResponseTimeout),
	m_responseTimeout(responseTimeout),
    m_fResponseTimeoutScheduled(false),
    m_fUsed(false),
    m_cleanupTimer(TimeToCleanup),
    m_cleanupTimeout(cleanupTimeout),
	m_SocketTransport(SocketTransport.detach()),
	m_pPerfmon(SafeAddRef(pPerfmon)),
    m_SendManager(SendWindowinBytes, SendWindowinPackets),
	m_DeliveryErrorClass(MQMSG_CLASS_NORMAL)
{
	ASSERT(("Invalid parameter", pMessageSource != NULL));
	ASSERT(("Invalid parameter", pPerfmon != NULL));
 
	    TrTRACE(
		Mt, 
		"Create new message transport. pmt = 0x%p, host = %ls, port = %d, uri = %ls, response timeout = %d ms", 
		this, 
		m_host,
        m_port,
        m_uri,
		responseTimeout.InMilliSeconds()
		);
 
    Connect();
}


CMessageTransport::~CMessageTransport()
{
	TrTRACE(Mt,"CMessageTransport Destructor called");

	//
    // Requeue all the messages that had been sent and were not responsed
    //
  	RequeueUnresponsedPackets();


    ASSERT(State() == csShutdownCompleted);
    ASSERT(m_response.empty());
    ASSERT(!m_responseTimer.InUse());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mtp.h

Abstract:
    Message Transport private functions.

Author:
    Uri Habusha (urih) 11-Aug-99

--*/

#pragma once

#include <ex.h>

const TraceIdEntry Mt = L"Message Transport";


inline DWORD DataTransferLength(EXOVERLAPPED& ov)
{
    //
    // In win64, InternalHigh is 64 bits. Since the max chunk of data
    // we transfer in one operation is always less than MAX_UNIT we can cast
    // it to DWORD safetly
    //
    ASSERT(0xFFFFFFFF >= ov.InternalHigh);
	return static_cast<DWORD>(ov.InternalHigh);
}




#ifdef _DEBUG

void MtpAssertValid(void);
void MtpSetInitialized(void);
BOOL MtpIsInitialized(void);
void MtpRegisterComponent(void);

#else // _DEBUG

#define MtpAssertValid() ((void)0)
#define MtpSetInitialized() ((void)0)
#define MtpIsInitialized() TRUE
#define MtpRegisterComponent() ((void)0)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtobj.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mtp.h

Abstract:
    Message Transport class.

Author:
    Uri Habusha (urih) 11-Aug-99

--*/

#pragma once

#ifndef __MTOBJ_H__
#define __MTOBJ_H__

#include "msi.h"
#include "spi.h"

#include <mqwin64a.h>
#include "acdef.h"
#include "List.h"
#include "qmpkt.h"

#include <ex.h>
#include <rwlock.h>
#include <st.h>
#include <buffer.h>
#include "Mp.h"
#include "MtSendMng.h"


typedef std::basic_string<unsigned char> utf8_str;


class CMessageTransport : public CTransport
{
public:
	enum Shutdowntype{IDLE_SHUTDOWN, ERROR_SHUTDOWN};

public:

    CMessageTransport(
        const xwcs_t& targetHost,
        const xwcs_t& nextHop,
        const xwcs_t& nextUri,
        USHORT port,
        LPCWSTR queueUrl,
        IMessagePool* pMessageSource,
		ISessionPerfmon* pPerfmon,
        const CTimeDuration& responseTimeout,
        const CTimeDuration& cleanupTimeout,
		P<ISocketTransport>& SocketTransport,
        DWORD SendWindowinBytes,
        DWORD SendWindowinPackets
        );

    virtual ~CMessageTransport();

    
    LPCWSTR ConnectedHost(void) const
    {
        return m_host;
    }


    LPCWSTR ConnectedUri(void) const
    {
        return m_uri;
    }


    USHORT ConnectedPort(void) const
    {
        return m_port;
    }


private:
    class CRequestOv : public EXOVERLAPPED
    {
    public:
        CRequestOv(        
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
            EXOVERLAPPED(pSuccess, pFailure)
        {
            m_pMsg.pPacket = NULL;
            m_pMsg.pDriverPacket = NULL;
        }


        CACPacketPtrs& GetAcPacketPtrs(void)
        {
            return m_pMsg;
        }


    private:
        CACPacketPtrs m_pMsg;
    };


    class CSendOv: public EXOVERLAPPED
    {
    public:
        CSendOv( COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure, 
            CMessageTransport* pmt,
            const R<CSrmpRequestBuffers>& pSrmpRequestBuffers                 
        ):
            EXOVERLAPPED(pSuccess, pFailure),
            m_pSrmpRequestBuffers(pSrmpRequestBuffers),
            m_pmt(SafeAddRef(pmt))
        {
        };

    public:
        DWORD GetSendDataLength() const
        {
            return numeric_cast<DWORD>(m_pSrmpRequestBuffers->GetSendDataLength());
        }
        R<CMessageTransport> MessageTransport() const
        {
            return m_pmt;
        }
    private:
        R<CMessageTransport> m_pmt;
        R<CSrmpRequestBuffers> m_pSrmpRequestBuffers;
    };



    class CResponseOv : public EXOVERLAPPED
    {
    public:
        enum {
            xHeaderChunkSize = 256,
            xBodyChunkSize = 256,
        };

    public:
        CResponseOv(        
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
            EXOVERLAPPED(pSuccess, pFailure),
            m_pHeader(new char[xHeaderChunkSize]),
            m_HeaderAllocatedSize(xHeaderChunkSize),
            m_HeaderValidBytes(0),
            m_BodyToRead(0),
            m_ProcessedSize(0)
        {
        };

		void operator=(const EXOVERLAPPED& ov) 
		{
			EXOVERLAPPED::operator=(ov);
		}

        char* Header() const
        {
            return m_pHeader;
        }


        DWORD HeaderAllocatedSize() const
        {
            return m_HeaderAllocatedSize;
        }


        DWORD BodyChunkSize() const
        {
            return (DWORD)min(TABLE_SIZE(m_Body), m_BodyToRead);
        }


        void ReallocateHeaderBuffer(DWORD Size)
        {
            ASSERT(Size > m_HeaderAllocatedSize);
            char* p = new char[Size];
            memcpy(p, m_pHeader, m_HeaderAllocatedSize);
            m_pHeader.free();
            m_pHeader = p;
            m_HeaderAllocatedSize = Size;
        }

        bool IsMoreResponsesExistInBuffer(void) const
        {
            return (m_HeaderValidBytes > m_ProcessedSize);
        }

		

    private:
        AP<char> m_pHeader;
        DWORD m_HeaderAllocatedSize;

    public:
        DWORD m_HeaderValidBytes;
        DWORD m_ProcessedSize;

        char m_Body[xBodyChunkSize];
        DWORD m_BodyToRead;
    };


    class CConnectOv : public EXOVERLAPPED
    {
    public:
        CConnectOv(        
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
        EXOVERLAPPED(pSuccess, pFailure)
		{
		}
	};

private:
    static void WINAPI ConnectionSucceeded(EXOVERLAPPED* pov);
    static void WINAPI ConnectionFailed(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForConnectingSucceeded(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForConnectingFailed(EXOVERLAPPED* pov);


    static void WINAPI SendSucceeded(EXOVERLAPPED* pov);
    static void WINAPI SendFailed(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForSendingSucceeded(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForSendingFailed(EXOVERLAPPED* pov);
   

    //
    // Receive functions
    //
    static void WINAPI ReceiveResponseHeaderSucceeded(EXOVERLAPPED* pov);
    static void WINAPI ReceiveResponseBodySucceeded(EXOVERLAPPED* pov);
    static void WINAPI ReceiveResponseFailed(EXOVERLAPPED* pov);

    static DWORD FindEndOfResponseHeader(LPCSTR buf, DWORD length);
    static DWORD GetContentLength(LPCSTR buf, DWORD headerLength);
	
    static void WINAPI TimeToResponseTimeout(CTimer* pTimer);

    //
    // General functions
    //
    static void WINAPI TimeToCleanup(CTimer* pTimer);

private:
	friend class CHttpStatusCodeMapper;

    //
    // Get packet for sending
    //
    void GetNextEntry(void);
    void RequeuePacket(void);

	//
	// Functions to handle http status code
	//
	void OnAbortiveHttpError(USHORT HttpStatusCode);
	void OnRetryableHttpError(USHORT HttpStatusCode);
	void OnHttpDeliverySuccess(USHORT HttpStatusCode);
	void OnHttpDeliveryContinute(USHORT HttpStatusCode);

    
    //
    // Create connection
    //
    void ConnectionSucceeded(void);
    void Connect(void);
	void InitPerfmonCounters(void);

   

    //
    // Send packet
    //
    void SendSucceeded(DWORD cbSendSize);
    void DeliverPacket(CQmPacket* pPacket);
    CQmPacket* CreateDeliveryPacket(void);
	void InsertPacketToResponseList(CQmPacket* pPacket);
	void SafePutPacketOnHold(CQmPacket* pPacket);

    //
    // Receive response
    //
    void ReceiveResponseHeaderSucceeded(void);
    void ReceiveResponseBodySucceeded(void);
    void ReceiveResponse(void);
    void ReceiveResponseHeaderChunk(void);
    void ReceiveResponseBodyChunk(void);
    void ProcessResponse(LPCSTR ResponseBuf);
    void ProcessPositiveResponse();
    void ReceiveResponseBody(void);
    void StartResponseTimeout(void);
    void CancelResponseTimer(void);

   
    void HandleExtraResponse(void);

    //
    // Shut-Down
    //
    void RequeueUnresponsedPackets(void);
    void Shutdown(Shutdowntype Shutdowntype = ERROR_SHUTDOWN) throw();

    //
    // Cleanup
    //
    void StartCleanupTimer(void);
    bool TryToCancelCleanupTimer(void);

    void MarkTransportAsUsed(void)
    {
        m_fUsed = true;
    }


private:
    mutable CCriticalSection m_pendingShutdown;

    R<IConnection> m_pConnection;
    R<IMessagePool> m_pMessageSource;

    mutable CCriticalSection m_csResponse;

    List<CQmPacket> m_response;
    CResponseOv m_responseOv;
    bool m_fResponseTimeoutScheduled;   

  
    CRequestOv m_requestEntry;
    CConnectOv m_connectOv;
    
  
    CTimer m_responseTimer;
    CTimeDuration m_responseTimeout;

    bool m_fUsed;
    CTimer m_cleanupTimer;
    CTimeDuration m_cleanupTimeout;
 
    AP<WCHAR> m_targetHost;
    AP<WCHAR> m_host;
    AP<WCHAR> m_uri;
    USHORT m_port;
	

	P<ISocketTransport> m_SocketTransport; 
	R<ISessionPerfmon> m_pPerfmon;

    CMtSendManager m_SendManager;
	USHORT m_DeliveryErrorClass;
};

#endif // __MTOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtsend.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - Send implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Mt.h>
#include <mp.h>
#include <strutl.h>
#include <utf8.h>
#include "Mtp.h"
#include "MtObj.h"
#include "MtMessageTrace.h"

#include "mtsend.tmh"

using namespace std;

void WINAPI CMessageTransport::GetPacketForSendingSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pRequest, CMessageTransport, m_requestEntry);
    
    TrTRACE(Mt, "Got a message to deliver. pmt = 0x%p", pmt.get());

    try
    {
       
		CQmPacket* pPkt = pmt->CreateDeliveryPacket();

		//
		// test if we should send the packet now (ordered packet send policy)
		//
		if(!AppCanDeliverPacket(pPkt))
		{
			pmt->SafePutPacketOnHold(pPkt);
			pmt->GetNextEntry();
			return;
		}
		else
		{
			pmt->InsertPacketToResponseList(pPkt);
			pmt->DeliverPacket(pPkt);
		}
    }
    catch(const exception&)
    {
		TrERROR(Mt, "Failed to deliver message, shutting down. pmt=0x%p", pmt.get());
	    pmt->Shutdown();
        throw;
    }
}


void WINAPI CMessageTransport::GetPacketForSendingFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when getting entry request from a queue failed.
  
Arguments:
    None.
  
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pRequest, CMessageTransport, m_requestEntry);

    TrERROR(Mt, "Failed to get a new entry from queue %ls/%ls. Shutting down. pmt = 0x%p", pmt->m_host, pmt->m_uri, pmt.get());
    pmt->Shutdown();
}


void WINAPI CMessageTransport::SendFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when send a message failed
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));


    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);
    R<CMessageTransport> pmt = pSendOv->MessageTransport();
    TrERROR(Mt, "Failed to send message to '%ls', shutting down. pmt=0x%p", pmt->m_host, pmt.get());
    pmt->Shutdown();
    
}


void CMessageTransport::SendSucceeded(DWORD cbSendSize)
/*++

Routine Description:
    Callback routine. The routine is called when send a message succeeded
  
Arguments:
    pov - Pointer to EXOVERLAPPED
  
Returned Value:
    None.
					    
--*/
{
    TrTRACE(
		Mt, 
		"Send message to '%ls via %ls uri=%ls' succeeded. pmt=0x%p", 
		m_targetHost,
		m_host, 
		m_uri, 
		this
		);

	StartResponseTimeout();

   
    MarkTransportAsUsed();

	//
	// Update performance counters
	//
	m_pPerfmon->UpdateBytesSent(cbSendSize);
	m_pPerfmon->UpdateMessagesSent();

	//
	// If the socket transport support pipelining - ask the driver to bring
	// next packet for delivery. If pipelining not supported we will do it only 
	// when all response is read for the current request.
	//

    if(m_SocketTransport->IsPipelineSupported())
	{
        //ask the driver to bring next packet now only if sends were suspended due to exceeding send windows 
        //and can be resumed now , otherwise it is done in CMessageTransport::DeliverPacket
        if (m_SendManager.ReportPacketSendCompleted(cbSendSize) == CMtSendManager::eSendEnabled)
        { 
		    GetNextEntry();
        }
	}
}


void WINAPI CMessageTransport::SendSucceeded(EXOVERLAPPED* pov)
{
  
    ASSERT(SUCCEEDED(pov->GetStatus()));
  
    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);
    DWORD SendDataLength = pSendOv->GetSendDataLength();
    R<CMessageTransport> pmt = pSendOv->MessageTransport();
   
    //
    // Send has completed successfully, go and request the next message for delivery.
    // If the request failes, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //    
 
	
    pmt->SendSucceeded(SendDataLength);
  
}



void CMessageTransport::InsertPacketToResponseList(CQmPacket* pPacket)
{
	CS lock(m_csResponse);
	m_response.push_back(*pPacket);
}

void CMessageTransport::SafePutPacketOnHold(CQmPacket* pPacket)
/*++

Routine Description:
    Delay packet delivery by inserting it to on hold list.
	If insertion failed (exception) - we insert it to response list for cleanup
	and rethrow the exception.
  
Arguments:
    CQmPacket* pPacket - packet to put on hold
  
Returned Value:
    None.

--*/
{

	TrTRACE(
		Mt,
		"Http Packet delivery delayed : SeqID=%x / %x , SeqN=%d ,Prev=%d",
		HIGH_DWORD(pPacket->GetSeqID()),
		LOW_DWORD(pPacket->GetSeqID()),
		pPacket->GetSeqN(),
		pPacket->GetPrevSeqN()
		);

	try
	{
		AppPutPacketOnHold(pPacket);
	}
	catch(const exception&)
	{
		InsertPacketToResponseList(pPacket);
		throw;
	}
}



CQmPacket* CMessageTransport::CreateDeliveryPacket(void)
{
    //
    // Get the entry from the request overlapped. 
    //
    CACPacketPtrs& acPkts = m_requestEntry.GetAcPacketPtrs();
    CQmPacket* pEntry;

    try
    {
        pEntry = new CQmPacket(acPkts.pPacket, acPkts.pDriverPacket);

        acPkts.pDriverPacket = NULL;
        acPkts.pPacket = NULL;
    }
    catch(const exception&)
    {
        TrERROR(Mt, "Failed to store the packet in UnAcked list");
        RequeuePacket();
        throw;
    }
    return pEntry;
}




void CMessageTransport::DeliverPacket(CQmPacket* pEntry)
/*++

Routine Description:
    The routine delivers an entry to the destination. The deliver is asynchornous.
    On completion a call back routine is called.
  
Arguments:
    None.
  
Returned Value:
    None.

--*/
{
    
    //
    // Mark the transport as used
    //
    MarkTransportAsUsed();


	R<CSrmpRequestBuffers> pSrmpRequestBuffers = MpSerialize(
									                        *pEntry,
									                        m_targetHost,
									                        m_uri
									                        );

    ASSERT(pSrmpRequestBuffers->GetNumberOfBuffers() != 0);
    //
    // Increment object refernce count, to insure that the object will
    // not be destroyed before asynchronous send operation is completed
    //
    
    P<CSendOv> pSendOv = new CSendOv(SendSucceeded, SendFailed, this, pSrmpRequestBuffers);
   

#ifdef _DEBUG
	CMtMessageTrace::LogSendData(
		pSrmpRequestBuffers->GetSendBuffers(), 
		pSrmpRequestBuffers->GetNumberOfBuffers()
		);
	
#endif
	
    m_pConnection->Send(
					pSrmpRequestBuffers->GetSendBuffers(), 
					numeric_cast<DWORD>(pSrmpRequestBuffers->GetNumberOfBuffers()), 
					pSendOv
					);

	pSendOv.detach();
    
    //
	// If the socket transport support pipelining - ask the driver to bring
	// next packet for delivery. If pipelining not supported we will do it only 
	// when all response is read for the current request.
	//

    if(m_SocketTransport->IsPipelineSupported())
	{
        DWORD cbSendSize = numeric_cast<DWORD>(pSrmpRequestBuffers->GetSendDataLength());

        //check if next packet can be sent 
        if (m_SendManager.ReportPacketSend(cbSendSize) == CMtSendManager::eSendEnabled ) 
        {
            //next packet can be sent. go and request the next message for delivery.  
		    GetNextEntry();
        }
	}

    TrTRACE(Mt, "Send message to '%ls' via %ls. pmt=0x%p ",m_targetHost, m_host, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtsendmng.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtSendMng.h

Abstract:
    Implementation of Message Transport Send Manager Class.

Author:
    Milena Salman (msalman) 11-Feb-01

--*/

#include <libpch.h>
#include "Mtp.h"
#include "MtSendMng.h"

#include "MtSendMng.tmh"

CMtSendManager::CMtSendManager(DWORD SendWindowinBytes, DWORD SendWindowinPackets):
m_Suspended(false),
m_SendWindowinBytes(SendWindowinBytes),
m_SendWindowinPackets(SendWindowinPackets),
m_SentBytes(0),
m_SentPackets(0)
{
  	TrTRACE(
		Mt, 
		"Message Transport Manager Parameters: SendWindowinBytes = %d, SendWindowinPackets = %d \n", 
        m_SendWindowinBytes,
        m_SendWindowinPackets
	);
}

CMtSendManager::MtSendState CMtSendManager::ReportPacketSend(DWORD cbSendSize)
{

/*++

Routine Description:
    CMtSendManager::ReportPacketSend called after sending packet 
    Updates "number of sent packets" and "size of sent packets" counters,
    Check if total number of uncompleted sends and total size of sent packets 
    do not exceed predefined window sizes

Arguments:
    size of sent packet

Returned Value:
   CMtSendManager::eSendEnabled if next packet should be sent (updated counters do not exceed window sizes)
    CMtSendManager::eSendDisabled if next packet should not be sent (updated counters exceed window sizes)

--*/
    CS lock(m_cs);
    m_SentBytes += cbSendSize;
    m_SentPackets+=1;
    if (m_SentBytes <= m_SendWindowinBytes && m_SentPackets <= m_SendWindowinPackets)
    {
	    return eSendEnabled;
    }
    else
    {
         m_Suspended = true;
         TrTRACE(Mt, "Send suspended: SentPackets=%d/%d, SentBytes=%d/%d", m_SentPackets, m_SendWindowinPackets, m_SentBytes, m_SendWindowinBytes); 
         return eSendDisabled;
    }
}


CMtSendManager::MtSendState CMtSendManager::ReportPacketSendCompleted(DWORD cbSendSize)
{
/*++

Routine Description:
    CMtSendManager::ReportPacketSendCompleted called on successful send completion 
    Updates "number of sent packets" and "size of sent packets" counters
    If sends were suspended, checks if total number of uncompleted sends and total size of sent packets 
    do not exceed predefined window sizes

Arguments:
    size of sent packet  

Returned Value:
    CMtSendManager::eSendEnabled if next packet should be sent (sends were suspeneded and updated counters do not exceed window sizes)
    CMtSendManager::eSendDisabled if next packet should not be sent (sends were not suspened or updated counters exceed window sizes)

--*/
        CS lock(m_cs);
        m_SentBytes -= cbSendSize;
        m_SentPackets-=1;
        if (m_Suspended && m_SentBytes <= m_SendWindowinBytes && m_SentPackets <= m_SendWindowinPackets)
        {
            m_Suspended = false;
            TrTRACE(Mt, "Send resumed: SentPackets=%d/%d, SentBytes=%d/%d",  m_SentPackets, m_SendWindowinPackets, m_SentBytes, m_SendWindowinBytes); 
            return eSendEnabled;
        }
        return eSendDisabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtsendmng.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtSendMng.h

Abstract:
    Message Transport Send Manager Class - designed to control sends in pipeline mode 

Author:
    Milena Salman (msalman) 11-Feb-01

--*/

#pragma once

#ifndef __MTSENDMNG_H__
#define __MTSENDMNG_H__

class CMtSendManager
{
public:
    enum MtSendState{
        eSendEnabled=0,
        eSendDisabled
    };
    CMtSendManager(DWORD m_SendWindowinBytes, DWORD m_SendWindowinPackets);
    MtSendState ReportPacketSend(DWORD cbSendSize);
    MtSendState ReportPacketSendCompleted(DWORD cbSendSize);
private:
    mutable CCriticalSection m_cs;
    bool m_Suspended;
    DWORD m_SendWindowinBytes;  // total size of packets that can be sent without waiting for completion
    DWORD m_SendWindowinPackets; // total number of packets that can be sent without waiting for completion
    DWORD m_SentBytes;  // size of sent packets
    DWORD m_SentPackets; // number of sent packets
};


#endif // __MTSENDMNG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\lib\mtresponse.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - receive respond implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <singelton.h>
#include <cm.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"


#include "mtresponse.tmh"

const char xHttpScheme[] = "http://";
const char xHttpHeaderTerminater[] = "\r\n\r\n";

//
// Class that holds mapping from http error code to 
// handler function
//
class CHttpStatusCodeMapper
{
public:
	CHttpStatusCodeMapper()
	{
		m_StatusMapping[100] = &CMessageTransport::OnHttpDeliveryContinute;


		m_StatusMapping[200] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[201] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[202] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[203] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[204] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[205] = &CMessageTransport::OnHttpDeliverySuccess;

		m_StatusMapping[408] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[400] = &CMessageTransport::OnRetryableHttpError;


		m_StatusMapping[500] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[502] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[503] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[504] = &CMessageTransport::OnRetryableHttpError;


		//
		// error code 403 has special setting in regsitry for configure it behaviour
		//
		DWORD HttpRetryOnError403 = 0;
		CmQueryValue(
				RegEntry(NULL, L"HttpRetryOnError403"),
				&HttpRetryOnError403
				);


		if(HttpRetryOnError403 != 0)
		{
			m_StatusMapping[403] = &CMessageTransport::OnRetryableHttpError;									
		}


	}

public:
	typedef void (CMessageTransport::* StatusCodeHandler) (USHORT StatusCode);
	StatusCodeHandler operator[](USHORT StatusCode)  const
	{
		std::map<int, StatusCodeHandler>::const_iterator it =  m_StatusMapping.find(StatusCode);
		if(it ==  m_StatusMapping.end()	 )
			return &CMessageTransport::OnAbortiveHttpError;

		return it->second;
	}
	
private:
	std::map<int, StatusCodeHandler> m_StatusMapping; 
};


void CMessageTransport::HandleExtraResponse(void)
{
    ASSERT(m_responseOv.IsMoreResponsesExistInBuffer());
    //
    // Initialize the Overlapped with receive response call back routines
    //
    m_responseOv =  EXOVERLAPPED(
                                ReceiveResponseHeaderSucceeded, 
                                ReceiveResponseFailed
                                );

 
    //
    // In previous phase we read more than we needed. Copy the spare data to the head of 
    // the buffer, update the counter and behave like next read is completed
    //
    memcpy(
        m_responseOv.Header(), 
        m_responseOv.Header() + m_responseOv.m_ProcessedSize, 
        m_responseOv.m_HeaderValidBytes - m_responseOv.m_ProcessedSize
        );


    m_responseOv.InternalHigh = m_responseOv.m_HeaderValidBytes - m_responseOv.m_ProcessedSize;
    m_responseOv.m_HeaderValidBytes = 0;
  
    R<CMessageTransport> ar = SafeAddRef(this);

    m_responseOv.SetStatus(STATUS_SUCCESS);
    ExPostRequest(&m_responseOv);

    ar.detach();
}


DWORD CMessageTransport::FindEndOfResponseHeader(LPCSTR buf, DWORD length)
{
    if (4 > length)
        return 0;

    for(DWORD i = 0; i < length - 3; ++i)
    {
        if (buf[i] != '\r')
            continue;

        if ((buf[i+1] == '\n') && (buf[i+2] == '\r') && (buf[i+3] == '\n'))
        {
            return (i + 4);
        }
    }

    return 0;
}


const char xContentlength[] = "Content-Length:";

DWORD CMessageTransport::GetContentLength(LPCSTR p, DWORD length)
{
	//
	// BUGBUG:workaround, since IIS send 100 response without Content-Length field
	//												Uri Habusha, 16-May-200
	//
    USHORT status = static_cast<USHORT>(atoi(p + STRLEN("HTTP/1.1")));

    const LPCSTR pEnd = p + length - 4;

    //
    // HTTP header must terminate with '\r\n\r\n'. We already parse
    // the header and find it as a legal HTTP header.
    //
    ASSERT(length >= 4);
    ASSERT(strncmp(pEnd, xHttpHeaderTerminater, 4) == 0);


    while (p < pEnd)
    {
        if (_strnicmp(p, xContentlength , STRLEN(xContentlength)) == 0)
            return atoi(p + STRLEN(xContentlength));

        for(;;)
        {
            if ((p[0] == '\r') && (p[1] == '\n'))
            {
                p += 2;
                break;
            }

            ++p;
        }
    }

    if (status == 100)
        return 0;

    //
    // Response header doesn't contain 'Content-Length' field. 
    //
    throw exception();
}


void WINAPI CMessageTransport::TimeToResponseTimeout(CTimer* pTimer)
{
    R<CMessageTransport> pmt = CONTAINING_RECORD(pTimer, CMessageTransport, m_responseTimer);

    TrERROR(Mt, "Failed to receive response in time, shutting down.pmt=0x%p", pmt.get());
    pmt->Shutdown();
}


void CMessageTransport::StartResponseTimeout(void)
{
    CS lock(m_csResponse);

    //
    // Check that the waiting list isn't empty and there is a pending message that 
    // waiting for response.
    // The list can be empty although only now the sending is completed and handling. 
    // The scenario is: UMS adds the message to waiting for response list before the 
    // sending is started; However the timer is armed only after the sending is completed.
    // In the meantime, the response has been received, and the message removed from the list.
    //
    if (m_response.empty() || m_fResponseTimeoutScheduled)
        return;

    m_fResponseTimeoutScheduled = true;

    AddRef();
    ExSetTimer(&m_responseTimer, m_responseTimeout);
}


    
void CMessageTransport::CancelResponseTimer(void)
{
    //
    // Canceling the timer and setting of the flag should be atomic operation. Otherwise,
    // there is a scenario in which the timer is not setting although there is a pending 
    // message that waiting for response.
    // This can be occurred if before setting the flag to false, there is a thread 
    // switch and StartResponseTimeout routine is activated. Although the timer isn't 
    // setting the flag is true, as a result the routine doesn't set the timer and UMS doen't
    // identifies connection problem
    //
    CS lock(m_csResponse);

    if (!ExCancelTimer(&m_responseTimer))
        return;
    
    ASSERT(m_fResponseTimeoutScheduled);
    m_fResponseTimeoutScheduled = false;

    //
    // Decrement refernce count taken for the timer
    //
    Release();
}


void CMessageTransport::ProcessPositiveResponse()
{
    //
    // Protect waiting for response list
    //
    CS lock (m_csResponse);

	CancelResponseTimer();

    if (m_response.empty())
    {
        ASSERT((State() == csShutdownCompleted) );
        return;
    }


    P<CQmPacket> pPkt = &m_response.front();
    m_response.pop_front();

    
	//
	// Test if gave ownership to the qm (case of order packet) 
	//
	if(AppPostSend(pPkt))
	{
		
		pPkt.detach();
	}
	else
	{
		m_pMessageSource->EndProcessing(pPkt);
	}

	//
	// If we are not in pipeline mode (https) we should ask the driver
	// to bring us next packet for delivery, because only now we finished
	// reading response for the current request.
	//
	if(!m_SocketTransport->IsPipelineSupported())
	{
		ASSERT(m_response.empty());
		GetNextEntry();
	}
}


void CMessageTransport::ReceiveResponseHeaderChunk(void)
{
    //
    // Increment refernce count for asynchronous context
    //
    R<CMessageTransport> ar = SafeAddRef(this);


    //
    // Receive next response header chunk
    //
    m_pConnection->ReceivePartialBuffer(
        m_responseOv.Header() + m_responseOv.m_HeaderValidBytes, 
        m_responseOv.HeaderAllocatedSize() - m_responseOv.m_HeaderValidBytes, 
        &m_responseOv
        ); 

    
    ar.detach();
}



void CMessageTransport::ReceiveResponse(void)
{
    if (m_responseOv.IsMoreResponsesExistInBuffer())
    {
        HandleExtraResponse();
        return;
    }

    //
    // Initialize the Overlapped with receive response call back routines
    //
    m_responseOv = EXOVERLAPPED(ReceiveResponseHeaderSucceeded, ReceiveResponseFailed);
    m_responseOv.m_HeaderValidBytes = 0;
    

    //
    // Receive first chunk of response header
    //
    ReceiveResponseHeaderChunk();
}


void CMessageTransport::ProcessResponse(LPCSTR buf)
{
    USHORT responseStatus = static_cast<USHORT>(atoi(buf + STRLEN("HTTP/1.1")));

    TrTRACE(Mt, "Received HTTP response, Http Status=%d. pmt=0x%p", responseStatus, this);


    // Response was received. Cancel the response timer
    //
    CancelResponseTimer();

	CHttpStatusCodeMapper::StatusCodeHandler Handler = CSingelton<CHttpStatusCodeMapper>::get()[responseStatus];
	(this->*Handler)(responseStatus);
}


void CMessageTransport::ReceiveResponseHeaderSucceeded(void)
/*++

Routine Description:
    The routine is called when receive response completes succesfully.
  
Arguments:
    None
  
Returned Value:
    None.

--*/
{
    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
	DWORD bytesTransfered = DataTransferLength(m_responseOv);
    if (bytesTransfered == 0)
    {
        TrERROR(Mt, "Failed to receive response, connection was closed. pmt=0x%p", this);
        throw exception();
    }



    TrTRACE(Mt, "Received response header. chunk bytes=%d, total bytes=%d", bytesTransfered, m_responseOv.m_HeaderValidBytes);

    
    //
    // Signal idle timer that this transport is active
    //
    MarkTransportAsUsed();

    //
    // Find out if the entire header was received
    //
    m_responseOv.m_HeaderValidBytes += bytesTransfered;

    m_responseOv.m_ProcessedSize = FindEndOfResponseHeader(
                                        m_responseOv.Header(), 
                                        m_responseOv.m_HeaderValidBytes
                                        );
    if (m_responseOv.m_ProcessedSize != 0)
    {
       //
        // The enire header was received. Process the response.
        // Go and read the attached message (if one exist).
        //
        ProcessResponse(m_responseOv.Header());
        ReceiveResponseBody();
        return;
    }


    if(m_responseOv.HeaderAllocatedSize() == m_responseOv.m_HeaderValidBytes)
    {
        //
        // Header buffer is too small. Reallocate header buffer
        //
        m_responseOv.ReallocateHeaderBuffer(m_responseOv.HeaderAllocatedSize() + CResponseOv::xHeaderChunkSize);
    }

    //
    // Validate that we didn't read past the buffer
    //
    ASSERT(m_responseOv.HeaderAllocatedSize() > m_responseOv.m_HeaderValidBytes);

    //
    // Receive next chunk of response header
    //
    ReceiveResponseHeaderChunk();
}


void WINAPI CMessageTransport::ReceiveResponseHeaderSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    CResponseOv* pResponse = static_cast<CResponseOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pResponse, CMessageTransport, m_responseOv);

    try
    {
        pmt->ReceiveResponseHeaderSucceeded();
    }
    catch(const exception&)
    {
        TrERROR(Mt, "Failed to process received response header, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }
}


void WINAPI CMessageTransport::ReceiveResponseFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    Callback routine. The routine is called when receive of respond failed
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    //
    // get the message transport object
    //
    CResponseOv* pResponse = static_cast<CResponseOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pResponse, CMessageTransport, m_responseOv);

    TrERROR(Mt, "Failed to receive respond, shutting down. pmt=0x%p Status=0x%x", pmt.get(), pmt->m_responseOv.GetStatus());

    pmt->Shutdown();
}


void CMessageTransport::ReceiveResponseBodyChunk()
{
    //
    // Increment refernce count for asynchronous context
    //
    R<CMessageTransport> ar = SafeAddRef(this);

    //
    // Receive the entity body chunck to the same buffer, as it is ignored
    //
    m_pConnection->ReceivePartialBuffer(
        m_responseOv.m_Body, 
        m_responseOv.BodyChunkSize(),
        &m_responseOv
        ); 

    ar.detach();
}


void CMessageTransport::ReceiveResponseBody()
{
    try
    {
        m_responseOv.m_ProcessedSize += GetContentLength(
                                            m_responseOv.Header(),
                                            m_responseOv.m_ProcessedSize
                                            );
    }
    catch(const exception&)
    {
        //
        // Response doesn't contains 'Content-Length' Header. Close the connection.
        //
        throw;
    }

    if (m_responseOv.m_HeaderValidBytes >= m_responseOv.m_ProcessedSize) 
    {
	    ReceiveResponse();
		StartResponseTimeout();
        return;
    }
      

    m_responseOv =  EXOVERLAPPED(ReceiveResponseBodySucceeded, ReceiveResponseFailed);
    m_responseOv.m_BodyToRead = m_responseOv.m_ProcessedSize - m_responseOv.m_HeaderValidBytes;


    //
    // Receive first chunk of entity body
    //
    ReceiveResponseBodyChunk();
}


void CMessageTransport::ReceiveResponseBodySucceeded(void)
{
    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
	DWORD bytesTransfered = DataTransferLength(m_responseOv);
    if (bytesTransfered == 0)
    {
        TrERROR(Mt, "Failed to receive response body, connection was closed. pmt=0x%p", this);
        throw exception();
    }

    ASSERT(bytesTransfered <= m_responseOv.m_BodyToRead);

    TrTRACE(Mt, "Received response body. chunk bytes=%d, bytes remaining=%d", bytesTransfered, m_responseOv.m_BodyToRead);

    //
    // Mark the transport as used
    //
    MarkTransportAsUsed();

    m_responseOv.m_BodyToRead -= bytesTransfered;

    if (m_responseOv.m_BodyToRead == 0)
    {
        //
        // The entire body was read successfully.
        //
	    ReceiveResponse();
		StartResponseTimeout();
	    return;
    }

    //
    // Receive next chunk of entity body
    //
    ReceiveResponseBodyChunk();
}


void WINAPI CMessageTransport::ReceiveResponseBodySucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    CResponseOv* pResponse = static_cast<CResponseOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pResponse, CMessageTransport, m_responseOv);

    try
    {
        pmt->ReceiveResponseBodySucceeded();
    }
    catch(const exception&)
    {
        TrERROR(Mt, "Failed to process received response body, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }
}


void CMessageTransport::RequeueUnresponsedPackets(void)
{
    CS lock(m_csResponse);

    //
    // return all unresponse packets to the queue
    //
    while (!m_response.empty())
    {
        P<CQmPacket> pEntry = &m_response.front();
        m_response.pop_front();

        m_pMessageSource->Requeue(pEntry);
    }
}


void CMessageTransport::OnAbortiveHttpError(USHORT  HttpStatusCode )
{
	m_DeliveryErrorClass = CREATE_MQHTTP_CODE(HttpStatusCode);
	TrERROR(Mt, "Received HTTP abortive error response '%d'. pmt=0x%p", HttpStatusCode, this);
    throw exception();
}


void CMessageTransport::OnRetryableHttpError(USHORT HttpStatusCode )
{
    TrERROR(Mt, "Received HTTP retryable error response '%d'. pmt=0x%p", HttpStatusCode, this);
    throw exception();
}

  

void CMessageTransport::OnHttpDeliverySuccess(USHORT  /* HttpStatusCode */)
{
	ProcessPositiveResponse();
}

void CMessageTransport::OnHttpDeliveryContinute(USHORT /* HttpStatusCode */)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\test\group.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    group.cpp

Abstract:
    group stub for MT test

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "MtTestp.h"
#include "group.h" 
#include "phbase.h"
#include "phuser.h"
#include "phprop.h"

#include "group.tmh"

WCHAR directHttpFormatName[] = L"http://foo\\msmq\\q1";
const QUEUE_FORMAT destQueue(directHttpFormatName);
const GUID sourceQm = { 0 };
const GUID destQm = { 0 };

static ULONG s_msgId = 0;

//---------------------------------------------------------
//
//  class CACPacketPtrs
//
//---------------------------------------------------------
class CACPacketPtrs {
public:
   CBaseHeader * pPacket;
   CPacket *  pDriverPacket;
};



ULONG CGroup::CalcPacketSize(void)
{
    ULONG ulPacketSize;

    ulPacketSize  = CBaseHeader::CalcSectionSize();

    ulPacketSize += CUserHeader::CalcSectionSize(&sourceQm, &destQm, NULL, &destQueue, NULL, NULL);

    ulPacketSize += CPropertyHeader::CalcSectionSize(0, 0, 0);

    return ulPacketSize;
}


char* CGroup::CreatePacket(void)
{
    ULONG ulPacketSize = CalcPacketSize();

    char* pPacket = new char[ulPacketSize];
    char* pSection = pPacket;

    // Initialize the EXOVERLAPPED with send callback routines
    //
    #pragma PUSH_NEW
    #undef new

        CBaseHeader* pBase = new(pSection) CBaseHeader(ulPacketSize);
        pSection = pBase->GetNextSection();

        CUserHeader* pUser = new(pSection) CUserHeader(
                                                &sourceQm, 
                                                &destQm,
                                                &destQueue,
                                                NULL,
                                                NULL,
                                                ++s_msgId
                                                );
        pSection = pUser->GetNextSection();

        new(pSection) CPropertyHeader();

    #pragma POP_NEW

    return pPacket;
}


void WINAPI CGroup::TimeToReturnPacket(CTimer* pTimer)
{
    R<CGroup> pGroup = CONTAINING_RECORD(pTimer, CGroup, m_getSleep);
    pGroup->TimeToReturnPacket();
}

void CGroup::TimeToReturnPacket(void)
{
    CS lock(m_cs);

    ASSERT(m_fGetScheduled);
    if(! m_request.empty())
    {
        CGroup::CRequest& request = m_request.front();
    
        EXOVERLAPPED* pov = request.m_pov;
        CACPacketPtrs* pAcPackts = request.m_pAcPackts;

        m_request.pop_front();

    
        char* pPkt = CreatePacket();

        pAcPackts->pPacket = reinterpret_cast<CBaseHeader*>(pPkt);
        pAcPackts->pDriverPacket = reinterpret_cast<CPacket*>(pPkt);

    
        pov->SetStatus(STATUS_SUCCESS);
        ExPostRequest(pov);
    }

    if (m_request.empty())
    {
        m_fGetScheduled = false;
        return;
    }

    R<CGroup> ref = SafeAddRef(this);
    CTimeDuration sleepInterval(rand()/1000);
    ExSetTimer(&m_getSleep, sleepInterval);
    ref.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\test\st.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.cpp

Abstract:
    Simulation of St library

Author:
    Gil Shafriri (gilsh) 11-June-2000

--*/

#include <libpch.h>
#include <st.h>
#include <no.h>
#include <xstr.h>


#include "MtTestp.h"
#include "st.tmh"

class CWinsockConnection : public IConnection	
{					 
public:
	CWinsockConnection(
			):
			m_socket(NoCreateStreamConnection())
	{
		
	}			

	void Init(const SOCKADDR_IN& Addr, EXOVERLAPPED* pOverlapped)
	{
		NoConnect(m_socket, Addr, pOverlapped);
	}


	virtual 
	void 
	ReceivePartialBuffer(
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					)
	{
		printf("send called on ovl=%p \n", pov);
		NoReceivePartialBuffer(m_socket, pBuffer, Size, pov);
	}


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		)
	{
		printf("send called on ovl=%p \n", pov);
		NoSend(m_socket, Buffers, nBuffers,  pov);
	}


	virtual void Close()
	{
		printf("closed called \n");
		NoCloseConnection(m_socket);
		m_socket.free();
	}


private:
	CSocketHandle m_socket;
};



class CSimpleWinsock :public ISocketTransport
{

public:
	virtual void CreateConnection(
			const SOCKADDR_IN& Addr, 
			EXOVERLAPPED* pOverlapped
			)
	{
		m_pConnection = new  CWinsockConnection();
		m_pConnection->Init(Addr, pOverlapped); 
	}


	virtual R<IConnection> GetConnection()
	{
		return m_pConnection; 
	}


	bool IsPipelineSupported(void)
	{
		return true;
	}

	
	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache = true
    )
	{
		return NoGetHostByName(host, pAddr, fUseCache);		
	}

private:
	R<CWinsockConnection> m_pConnection;
};


ISocketTransport* StCreateSslWinsockTransport(
	const xwcs_t& /*ServerName*/,
	USHORT /*port*/,
	bool /*Proxy*/
	)
{
	return new CSimpleWinsock();
}


ISocketTransport* StCreateSimpleWinsockTransport(void)
{
	return new 	CSimpleWinsock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\test\mttestp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtTestp.h

Abstract:
    Message Transport test, private header.

Author:
    Uri Habusha (urih) 31-Oct-99

--*/

#pragma once

const TraceIdEntry MtTest = L"Message Transport Test";

bool IsFailed(void);
void UpdateNoOfsentMessages(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mtm\lib\mtm.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mtm.cpp

Abstract:

    Multicast Transport Manager general functions

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <mqformat.h>
#include "Mtm.h"
#include "Mtmp.h"

#include "mtm.tmh"

VOID 
MtmCreateTransport(
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	MULTICAST_ID id
    ) 
/*++

Routine Description:

    Handle new queue notification. Create a new message transport.

Arguments:

    pMessageSource  - Pointer to message source interface.

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    MtmpAssertValid();

    ASSERT(pMessageSource != NULL);

	MtmpCreateNewTransport(
			pMessageSource, 
			pPerfmon,
            id
			);
} // MtmCreateTransport


VOID
MtmTransportClosed(
    MULTICAST_ID id
    )
/*++

Routine Description:

    Notification for closing connection. Removes the transport from the
    internal database and checkes if a new transport should be created (the associated 
    queue is in idle state or not)

Arguments:

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    MtmpAssertValid();

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer);
    TrTRACE(Mtm, "MtmTransportClosed. transport to: %ls", buffer);

    MtmpRemoveTransport(id);

} // MtmTransportClosed
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\test\no.cpp ===
#include <libpch.h>
#include "No.h"
#include "Ex.h"
#include "MtTestp.h"

#include "no.tmh"

using namespace std;

const char xShortOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xShortFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xLongOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xLongFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xOkResponseNoContentLength[] =
                            		"HTTP/1.1 200 OK\r\n"
									"\r\n"
                                    ;

const char xInformativeResponseNoContentLength[] =
                            		"HTTP/1.1 100 Continue\r\n"
									"\r\n"
									;

const char xFailResponseNoContentLength[] =
                            		"HTTP/1.1 500 Internal Server Error\r\n"
									"\r\n"
									;

const LPCSTR xResponses[] = {
	xShortOkResponse,
	xShortFailResponse,
	xLongOkResponse,
	xLongFailResponse,
    xOkResponseNoContentLength,
    xInformativeResponseNoContentLength,
    xFailResponseNoContentLength,
  
  };

struct SockInfo
{
    SockInfo(void) : 
        pBuffer(NULL),
        nBytesToRead(0),
        ByteReads(0),
        pov(NULL)
    {
    }

    CCriticalSection m_csResponse;
    list<LPCSTR> response;
    DWORD ByteReads;

    VOID* pBuffer;                                     
    DWORD nBytesToRead; 
    EXOVERLAPPED* pov;
};

typedef map<SOCKET, SockInfo*> SOCKET2INFO;
SOCKET2INFO s_mapSockInfo;


//
VOID
NoInitialize(
    VOID
    )
{
}


static SOCKET s_socket = 0;

SOCKET 
NoCreateStreamConnection(
    VOID
    )
{
    if (IsFailed())
    {
        throw exception();
    }

    s_mapSockInfo[++s_socket] = new SockInfo;

    TrTRACE(MtTest, "Create Socket 0x%I64x", s_socket);

    return s_socket;
}


VOID 
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN&,
    EXOVERLAPPED* pov
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


VOID
NoCloseConnection(
    SOCKET Socket
    )
{
	SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    TrTRACE(MtTest, "Close Socket 0x%I64x", Socket);

    if (it != s_mapSockInfo.end())
    {
        SockInfo* p = it->second;
        
        if (p->pov != NULL)
        {
            EXOVERLAPPED* pov = p->pov;

            p->pBuffer = NULL;
            p->pov = NULL;
            p->nBytesToRead = 0;

            pov->SetStatus(STATUS_UNSUCCESSFUL);
            ExPostRequest(pov);
        }

        s_mapSockInfo.erase(it);
        delete p;
    }
}





VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF*,
    DWORD, 
    EXOVERLAPPED* pov
    )
{ 
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }


    SockInfo* p = it->second;               
    {
        CS lock(p->m_csResponse);
        p->response.push_back(xResponses[rand() % TABLE_SIZE(xResponses)]);
    }

    pov->SetStatus(STATUS_SUCCESS);
    

	if (p->pov != NULL)
    {
        //
        // pending reponse receive
        //
        EXOVERLAPPED* pov = p->pov;
        PVOID pBuffer = p->pBuffer;
        DWORD nBytesToRead = p->nBytesToRead;
        p->pBuffer = NULL;
        p->pov = NULL;
        p->nBytesToRead = 0;

        NoReceivePartialBuffer(Socket, pBuffer, nBytesToRead, pov);
    }
	else
	{
		ExPostRequest(pov);
	}

}


VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD nBytesToRead, 
    EXOVERLAPPED* pov
    )
{
    TrTRACE(MtTest, "NoReceivePartialBuffer: Socket=0x%I64x Buffer=0x%p BytesToRead=%d ov=0x%p", Socket, pBuffer, nBytesToRead, pov);
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        pov->InternalHigh = 0;

        if (rand()%4 == 0)
		{
			printf("NoReceivePartialBuffer throw on pov=%p \n", pov);
            throw exception();
		}

        if (rand()%4 == 1)
        {
            pov->SetStatus(STATUS_SUCCESS);
        }
        else
        {
            pov->SetStatus(STATUS_UNSUCCESSFUL);
        }

        ExPostRequest(pov);
        
        return;
    }

    SockInfo* p = it->second;               

    {
        CS lock(p->m_csResponse);
        if (p->response.empty())
        {
            p->pBuffer = pBuffer;                                   
            p->nBytesToRead = nBytesToRead;
            p->pov = pov;
            return;
        }
    }

    p->pBuffer = NULL;                                   
    p->nBytesToRead = 0;
    p->pov = NULL;

    LPCSTR response;
    {
        CS lock(p->m_csResponse);
        response = p->response.front();
    }

    DWORD length = min(nBytesToRead, (strlen(response) - p->ByteReads));

    memcpy(pBuffer, (response + p->ByteReads), length);
    p->ByteReads += length;

    pov->InternalHigh = length;
    
    bool fReadAllResponse = false;
    if (p->ByteReads == strlen(response))
    {
        CS lock(p->m_csResponse);
        p->response.pop_front();
        p->ByteReads = 0;
        fReadAllResponse = true;
    }
     
    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}



bool
NoGetHostByName(
	LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache
    )
{
	UNREFERENCED_PARAMETER(host);
	UNREFERENCED_PARAMETER(fUseCache);

	SOCKADDR_IN Addr;

	Addr.sin_family = AF_INET;
    Addr.sin_addr.S_un.S_addr = rand();
	pAddr->push_back(Addr);

	return true;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\test\group.h ===
#include "msi.h"

#include "mqwin64a.h"
#include "qmpkt.h"
#include "MtTestp.h"


class CGroup: public IMessagePool
{
private:
    class CRequest
    {
    public:
        CRequest(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs) :
            m_pov(pov),
            m_pAcPackts(&acPacketPtrs)
            {
            }
    public:
        EXOVERLAPPED* m_pov;
        CACPacketPtrs* m_pAcPackts;
    };

public:
    CGroup() :
        m_getSleep(TimeToReturnPacket),
        m_fGetScheduled(false)
    {
    }

    virtual ~CGroup()
    {
        ExCancelTimer(&m_getSleep);
    }




    void Requeue(CQmPacket* p)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());
    }
    

    void EndProcessing(CQmPacket* p)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());

        UpdateNoOfsentMessages();
    }


    void LockMemoryAndDeleteStorage(CQmPacket*)
    {
        ASSERT(("CGroup::LockMemoryAndDeleteStorage should not be called!", 0));

        throw exception();
    }


    void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs)
    {
        CS lock(m_cs);

        m_request.push_back(CRequest(pov, acPacketPtrs));
        if (!m_fGetScheduled)
        {
            SafeAddRef(this);

            CTimeDuration sleepInterval(rand()/1000);
            ExSetTimer(&m_getSleep, sleepInterval);
            m_fGetScheduled = true;
        }
    }

    void CancelRequest(void)
    {
        CS lock(m_cs);

        for(std::list<CRequest>::iterator it = m_request.begin(); it != m_request.end(); )
        {
            EXOVERLAPPED* pov = (*it).m_pov;
            pov->SetStatus(STATUS_CANCELLED);
            ExPostRequest(pov);
            
            it = m_request.erase(it);
        }
    }

private:
    static void WINAPI TimeToReturnPacket(CTimer* pTimer);
    
    static ULONG CalcPacketSize(void);
    static char* CreatePacket();

private:
    void TimeToReturnPacket();

private:
    CCriticalSection    m_cs;                   // Critical section

    std::list<CRequest> m_request;

    bool m_fGetScheduled;
    CTimer m_getSleep;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mtm\lib\mtmconfig.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmConfig.cpp

Abstract:

    Multicast Transport Manager configuration.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <timetypes.h>
#include <Cm.h>
#include "Mtmp.h"

#include "mtmconfig.tmh"

static CTimeDuration s_remoteRetryTimeout;
static CTimeDuration s_remoteCleanupTimeout;


VOID
MtmpGetTransportTimes(
    CTimeDuration& RetryTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    RetryTimeout = s_remoteRetryTimeout;
    CleanupTimeout = s_remoteCleanupTimeout;
}

    
static 
VOID
InitTransportTimeouts(
    VOID
    )
{
    CmQueryValue(
        RegEntry(NULL, L"MulticastConnectionRetryTimeout", 10 * 1000),  // 10 seconds 
        &s_remoteRetryTimeout
        );

    CmQueryValue(
        RegEntry(NULL, L"MulticastCleanupInterval", 5 * 60 * 1000),  // 5 minutes
        &s_remoteCleanupTimeout
        );
}


VOID MtmpInitConfiguration(VOID)
{
    InitTransportTimeouts();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mt\test\mttest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtTest.cpp

Abstract:
    Message Transport library test

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Ex.h>
#include <No.h>
#include <Mt.h>
#include <Mp.h>
#include <spi.h>
#include <cm.h>
#include <utf8.h>
#include "MtTestp.h"
#include "group.h"

#include "MtTest.tmh"

const WCHAR queueUrl[] = L"http://foo\\msmq\\q1";

const WCHAR host[] = L"foo";

const WCHAR uri[] = L"msmq\\q1";
const xwcs_t nextUri(uri, STRLEN(uri));

static DWORD s_FailedRate = 0;
static DWORD s_NoOfMessages = 1000;
static HANDLE s_hEvent;


class CSessionPerfmon : public ISessionPerfmon
{
public:
    CSessionPerfmon() : m_fInstanceCreated(false) 
    {
    }

    ~CSessionPerfmon()
    {
    }
    
	void CreateInstance(LPCWSTR)
	{
		m_fInstanceCreated = true;
	}

	void UpdateBytesSent(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesSent(void)
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateBytesReceived(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesReceived(void)
    {
		ASSERT(m_fInstanceCreated);
    }

private:
	bool m_fInstanceCreated;
};


static R<CTransport> s_pTrans(NULL);

void UpdateNoOfsentMessages(void)
{
    if (--s_NoOfMessages == 0)
        SetEvent(s_hEvent);
}


bool IsFailed(void)
{
    if (s_FailedRate == 0)
        return FALSE;

    return ((DWORD)(rand() % 100) < s_FailedRate);
}

   
static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};

const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}





VOID
AppNotifyTransportClosed(
    LPCWSTR queuePath
    )
{
    ASSERT(wcscmp(queuePath, queueUrl) ==0);
	DBG_USED(queuePath);

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;


    bool fFailed;

    do
    {
        fFailed = false;
        try
        {
            s_pTrans = MtCreateTransport(
                                xwcs_t(host, STRLEN(host)),
                                xwcs_t(uri, STRLEN(uri)),
                                xwcs_t(uri, STRLEN(uri)),
                                80,
								80,
                                queueUrl,
                                pGroup.get(),
								pPerfmon.get(),
                                CTimeDuration (100 * CTimeDuration::OneMilliSecond().Ticks()),
                                CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks()),
								false,
                                200000,
                                64
                                );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
                    
    pGroup.free();
}




R<CSrmpRequestBuffers>
MpSerialize(
    const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	)
{
	return new CSrmpRequestBuffers(pkt, targethost, uri);	
}


CSrmpRequestBuffers::CSrmpRequestBuffers(
							const  CQmPacket& pkt,
							LPCWSTR host, 
							LPCWSTR 
							):
							m_pkt(pkt),
							m_HttpRequestData(512),
							m_envelope('a' ,200)
{

	size_t targethostLen;
	AP<utf8_char>  targethost = UtlWcsToUtf8(host, &targethostLen);

	m_targethost.append(targethost, targethostLen);
	m_targethost.append('\0');



	WSABUF buffer;
	buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = numeric_cast<DWORD>(m_envelope.size());
    m_buffers.push_back(buffer);
}



size_t CSrmpRequestBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


const WSABUF* CSrmpRequestBuffers::GetSendBuffers() const
{
	return m_buffers.begin();
}

size_t CSrmpRequestBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;
}


BYTE*  CSrmpRequestBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<BYTE>  SendData = new BYTE[SendDataLength];
	BYTE* ptr = SendData.get(); 
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);
	return 	SendData.detach();
}




CQmPacket::CQmPacket(
    CBaseHeader *pPkt, 
    CPacket *pDriverPkt):
        m_pDriverPacket(pDriverPkt)
{
    PCHAR pSection;

    m_pBasicHeader = pPkt;

    pSection = m_pBasicHeader->GetNextSection();
    m_pcUserMsg = (CUserHeader*) pSection;

    ASSERT(m_pcUserMsg->PropertyIsIncluded());

    pSection = m_pcUserMsg->GetNextSection();
    m_pcMsgProperty = (CPropertyHeader*) pSection;

    m_pXactSection = NULL;
    m_pSecuritySection = NULL;
}


void Usage(void)
{
	printf("Usage: mttest -n <no of messages> [-f xxx] [-h]\n");
    printf("\tn - Number of messages\n");
	printf("\tf - Fail rate\n");
	printf("\th - Print this message\n");
	exit(-1);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Message Transport library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
	TrInitialize();
	TrRegisterComponent(&MtTest, 1);
	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft");


    --argc;
    ++argv;

    s_FailedRate = 0;
    
    while (argc > 0)
	{
		if (argv[0][0] != L'-') 
			Usage();

		switch(argv[0][1])
		{
            case L'n':
            case L'N':
                s_NoOfMessages = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
                break;

            case L'f':
			case L'F':
		        s_FailedRate = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
				break;


            default:
				Usage();
		}
    }

    ExInitialize(5);
    NoInitialize();
    MtInitialize();

    s_hEvent = CreateEvent(NULL, FALSE, FALSE, L"");

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;

    bool fFailed = false;

    do
    {
        try
        {
            s_pTrans = MtCreateTransport(
                                    xwcs_t(host, STRLEN(host)),
                                    xwcs_t(uri, STRLEN(uri)),
                                    xwcs_t(uri, STRLEN(uri)),
                                    80,
									80,
                                    queueUrl,
                                    pGroup.get(),
									pPerfmon.get(),
                                    CTimeDuration (100 * CTimeDuration::OneMilliSecond().Ticks()),
                                    CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks()),
									false,
                                    200000,
                                    64
                                    );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
    
    pGroup.free();

    WaitForSingleObject(s_hEvent, INFINITE);

    return 0;
}





bool AppCanDeliverPacket(CQmPacket*)
{
	int static count =0;
	if(count++ == 10)
		return false;

	return true;
}


void AppPutPacketOnHold(CQmPacket* )
{
			
}

bool AppPostSend(CQmPacket* )
{
	 return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mtm\lib\mtminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmInit.cpp

Abstract:

    Multicast Transport Manager initialization

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include "Mtm.h"
#include "Mtmp.h"

#include "mtminit.tmh"

VOID
MtmInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes Multicast Transport Manager library

Arguments:

    None.

Returned Value:

    None.

--*/
{
    //
    // Validate that the Multicast Transport Manager library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MtmpIsInitialized());
    MtmpRegisterComponent();

    MtmpInitConfiguration();

    MtmpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mtm\lib\mtmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmDebug.cpp

Abstract:

    Multicast Transport Manager debugging

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mtm.h"
#include "Mtmp.h"

#include "mtmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Multicast Transport Manager state
//
VOID MtmpAssertValid(VOID)
{
    //
    // MtmInitalize() has *not* been called. You should initialize the
    // Multicast Transport Manager library before using any of its funcionality.
    //
    ASSERT(MtmpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

VOID MtmpSetInitialized(VOID)
{
    LONG fAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Multicast Transport Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fAlreadyInitialized);
}


BOOL MtmpIsInitialized(VOID)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Mtm,

    //
    // Add MULTICAST transport manager sub-component trace ID's to be used with TrXXXX.
    // For example, MtmInit, as used in:
    // TrERROR(MtmInit, "Error description", parameters)
    //
};


VOID MtmpRegisterComponent(VOID)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mtm\lib\mtmmap.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmMap.cpp

Abstract:

    Queue name to Transport mapping

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mtm.h"
#include "Mmt.h"
#include "rwlock.h"
#include "stlcmp.h"
#include "timetypes.h"
#include "Mtmp.h"

#include "mtmmap.tmh"

using namespace std;

//
// less function, using to compare MULTICAST_ID in STL data structure
//
struct CFunc_MulticastIdCompare : public std::binary_function<MULTICAST_ID, MULTICAST_ID, bool>
{
    bool operator() (MULTICAST_ID id1, MULTICAST_ID id2) const
    {
        if (id1.m_address != id2.m_address)
        {
            bool res = (id1.m_address < id2.m_address);
            return res;
        }

        return (id1.m_port < id2.m_port);
    }
};


typedef map<MULTICAST_ID, R<CMulticastTransport>, CFunc_MulticastIdCompare> TMAP;

static TMAP s_transports;
static CReadWriteLock s_rwlock;


inline
TMAP::iterator
MtmpFind(
    MULTICAST_ID id
    )
{
    return s_transports.find(id);
}


VOID
MtmpRemoveTransport(
    MULTICAST_ID id
    )
/*++

Routine Description:

    Remove a transport from the transport database

Arguments:

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    CSW writeLock(s_rwlock);

    TMAP::iterator it = MtmpFind(id);

    //
    // The transport can be removed with the same name more than once
    // see comment below at MtmpCreateNewTransport.
    //
    if(it == s_transports.end())
        return;

    TrTRACE(Mtm, "MtmpRemoveTransport. transport to : 0x%p", &it->second);

    s_transports.erase(it);
}


R<CMulticastTransport>
MtmGetTransport(
    MULTICAST_ID id
    )
/*++

Routine Description:

    Find a transport by a queue name in the database

Arguments:

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    MtmpAssertValid();
    
    CSR readLock(s_rwlock);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer);
    TrTRACE(Mtm, "MtmGetTransport. Multicast address: %ls", buffer);

    TMAP::iterator it = MtmpFind(id);

    if(it == s_transports.end())
        return NULL;

    return it->second;
}


VOID
MtmpCreateNewTransport(
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    MULTICAST_ID id
    )
{
    //
    // The state of the map isn't consistent until the function
    // is completed (add a null transport for place holder). Get the CS to 
    // insure that other process doesn't enumerate the data structure during this time
    //
    CSW writeLock(s_rwlock);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer);
    TrTRACE(Mtm, "MtmpCreateNewTransport. multicast address: %ls, message source: 0x%p", buffer, pMessageSource);

    //
    // Add the multicast address to the map. We do it before creating the transport to insure 
    // that after creation we always succeed to add the new transport to the data 
    // structure (place holder)
    //
    pair<TMAP::iterator, bool> pr = s_transports.insert(TMAP::value_type(id, NULL));

    TMAP::iterator it = pr.first;

    if (! pr.second)
    {
        //
        // BUGBUG: The queue can close while it has an active message transport. As
        //         a result the CQueueMgr moved the queue from the group and remove it. 
        //         Now the Mtm is asked to create Mmt for this queue but it already has one.  
        //         So the Mtm releases the previous transport before creating a new one.
        //         When we will have a Connection Cordinetor we need to handle it better
        //                          Uri Habusha, 16-May-2000
        //
        s_transports.erase(it);

        pr = s_transports.insert(TMAP::value_type(id, NULL));

        it = pr.first;
        ASSERT(pr.second);
    }

    try
    {
        //
        // Get transport timeouts
        //
        CTimeDuration retryTimeout;
        CTimeDuration cleanupTimeout;

        MtmpGetTransportTimes(retryTimeout, cleanupTimeout);

        //
        // Replace the NULL transport in place holder, with the created transport
        //
        it->second = MmtCreateTransport(
                                id,
                                pMessageSource,
								pPerfmon,
                                retryTimeout,
                                cleanupTimeout
                                );
    }
    catch(const exception&)
    {
        //
        // Remove the place holder from the map
        //
        ASSERT(it->second.get() == NULL);

        s_transports.erase(it);

        throw;
    }

    TrTRACE(
        Mtm, 
        "Succeeded to create multicast message transport (pmt = 0x%p) to %ls",
        (it->second).get(),
        buffer
        );
} // MtmpCreateNewTransport


R<CMulticastTransport>
MtmFindFirst(
    VOID
    )
/*++

Routine Description:

    Find first transport in s_transports. The function returns a pointer to the
    CMulticastTransport, from which the caller can get the transport state and name.
    
    The caller must release the transport reference count

Arguments:

    None.

Returned Value:

    Pointer to CMulticastTransport. NULL is returned If the map is empty.

--*/
{
    MtmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.begin()->second;
}


R<CMulticastTransport>
MtmFindLast(
    VOID
    )
/*++

Routine Description:

    Find last transport in s_transports. The function returns a pointer to the
    CMulticastTransport, from which the caller can get the transport state and name.
    
    The caller must release the transport reference count

Arguments:

    None.

Returned Value:

    Pointer to CMulticastTransport. NULL is returned If the map is empty.

--*/
{
    MtmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.rbegin()->second;
}


R<CMulticastTransport>
MtmFindNext(
    const CMulticastTransport& transport
    )
/*++

Routine Description:

    Find next transport in s_transport.

Arguments:

    transport - reference to transport.

Returned Value:

    The next CMulticastTransport in the database. NULL is returned if there is no more data

--*/
{
    MtmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.upper_bound(transport.MulticastId());

    //
    // No element found
    //
    if(it == s_transports.end())
        return NULL;

    return it->second;
}


R<CMulticastTransport>
MtmFindPrev(
    const CMulticastTransport& transport
    )
/*++

Routine Description:

    Find prev transport in s_transport.

Arguments:

    transport - reference to transport.

Returned Value:

    The prev CMulticastTransport in the database. NULL is returned if there is no more data

--*/
{
    MtmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.lower_bound(transport.MulticastId());

    //
    // No element found
    //
    if(it == s_transports.begin())
        return NULL;

    --it;

    return it->second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mtm\lib\mtmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mtmp.h

Abstract:

    Multicast Transport Manager private functions.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef _MSMQ_Mtmp_H_
#define _MSMQ_Mtmp_H_

#include <mqsymbls.h>
#include <mqwin64a.h>
#include <qformat.h>


const TraceIdEntry Mtm = L"Multicast Transport Manager";


#ifdef _DEBUG

VOID MtmpAssertValid(VOID);
VOID MtmpSetInitialized(VOID);
BOOL MtmpIsInitialized(VOID);
VOID MtmpRegisterComponent(VOID);

#else // _DEBUG

#define MtmpAssertValid() ((VOID)0)
#define MtmpSetInitialized() ((VOID)0)
#define MtmpIsInitialized() TRUE
#define MtmpRegisterComponent() ((VOID)0)

#endif // _DEBUG

VOID 
MtmpInitConfiguration(
    VOID
    );

VOID 
MtmpGetTransportTimes(
    CTimeDuration& RetryTimeout,
    CTimeDuration& CleanupTimeout
    );

VOID 
MtmpRemoveTransport(
    MULTICAST_ID id
    );


class IMessagePool;
class ISessionPerfmon;

VOID
MtmpCreateNewTransport(
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    MULTICAST_ID id
    );

#endif // _MSMQ_Mtmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\noconnect.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    Noconnect.cpp

Abstract:
    This module contains the HTTP connection between 2 URT machines.

Author:
    Uri Habusha (urih), 4-Agu-99

Enviroment:
    Platform-indepdent

--*/

#include "libpch.h"
#include <WsRm.h>
#include "Ex.h"
#include "No.h"
#include "Nop.h"

#include "noconnect.tmh"

using namespace std;

// 
// MapSocketToOverlapped class use to map socket to overlapped. 
// The window notification mechanism that we use, doesn't return a conthext
// but only the associate SOCKET, we use the follwoing data structure to map 
// between a socket and the Overlapped (context).
//
class CMapSocketToOverlapped
{
public:

    void Register(SOCKET socket, EXOVERLAPPED* pov);
    EXOVERLAPPED* Unregister(SOCKET socket);

private:

    typedef map<SOCKET, EXOVERLAPPED*> SOKET2EXOV;

    mutable CCriticalSection m_cs;
    SOKET2EXOV m_Socket2Ov;

};


void
CMapSocketToOverlapped::Register(
    SOCKET socket,
    EXOVERLAPPED* pov
    )
{
    CS lock(m_cs);

    //
    // The socket musn't be found
    //
    ASSERT(m_Socket2Ov.find(socket) == m_Socket2Ov.end());
    m_Socket2Ov[socket] = pov;
}


EXOVERLAPPED*
CMapSocketToOverlapped::Unregister(
    SOCKET socket
    )
{
    CS lock(m_cs);

    SOKET2EXOV::iterator p = m_Socket2Ov.find(socket);
    if (p == m_Socket2Ov.end())
        return NULL;
    
    EXOVERLAPPED* pov = p->second;

    m_Socket2Ov.erase(p);

    return pov;
} 

//
// data base holding mapping between socket and Overlapped 
//
static CMapSocketToOverlapped s_SockToOv;


#ifdef _DEBUG

static void DumpSocketInformation(SOCKET socket)
{
    //
    // print debug message with the address of the connected machine
    //
    SOCKADDR_IN sin;
    INT intLength = sizeof(sin);

    int rc = getpeername(socket, (SOCKADDR*)&sin, &intLength); 
    ASSERT(rc == ERROR_SUCCESS);

    char SockAddress[100];
    DWORD dwLength = 100;
    WSAAddressToStringA(
        (SOCKADDR*)&sin, 
        sizeof(sin),
        NULL,
        SockAddress,
        &dwLength
        );

    TrTRACE(No, "Successfully connected to '%s'", SockAddress);
}

#else

#define DumpSocketInformation(socket) ((void)0)

#endif


static
void
ConnectionFailed(
    SOCKET socket,
    WORD result, 
    EXOVERLAPPED* pov
    )
{
    DBG_USED(result);
    TrERROR(No, "Failed to create connection. socket=0x%I64x, Error=%d", socket, result);

    //
    // Set the operation result on the overlapped structure
    // 
    pov->SetStatus(STATUS_UNSUCCESSFUL);
    ExPostRequest(pov);
}


static
void
ConnectionSucceeded(
    SOCKET socket,  
    EXOVERLAPPED* pov
    )
{
    DumpSocketInformation(socket);
    
/*
    //
    // Specify the total buffer space reserved for sending on the specific socket.
    //
    int opt = 18 * 1024;
    setsockopt(socket,
               SOL_SOCKET,
               SO_SNDBUF,
               (const char *)&opt,
               sizeof(opt)
               );
*/

    //
    // Associate the new incoming socket to I/O completion port. Ne infrastructure
    // use I/O completion port mechanism therfore all the socket must be associated 
    // with the I/O port.
    //
    ExAttachHandle(reinterpret_cast<HANDLE>(socket));

    //
    // Set the operation result on the overlapped structure
    // 
    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


void
NepCompleteConnect(
    SOCKET socket,
    WORD result
    )
/*++

Routine Description:

    Handles the reception of a USMSG_CONNECT message, which indicates
    a connection attempt is complete (though not necessarily
    successful). 
    
    The routine takes the following steps:
    1) looks for the overlapped structure associate with the socket.
    2) connection failed 
        2a) closes the socket
        2b) posts the overlapped structure to completion port.
        2c) exit
    3) Notify the caller that the connection complete (succssefully or not)


Arguments:

    socket - socket handle 

    Result - result of the connection

Return Value:

    None.

--*/
{
    //
    // Clear the windows message event notification.
    //
    NepSelectSocket(socket, 0, 0);
  
    //
    // Retreive the Overlapped structure
    //
    EXOVERLAPPED* pov;
    pov = s_SockToOv.Unregister(socket);

    if (pov == NULL)
    {
        //
        // When create connection fails winsock might return both synchronous and
        // asynchronous error notification. In such a case, UMS has already removed
        // the socket from the internal data structure and notified the caller, while
        // processing the synchronouse notification. 
        // Thus, when the assynchronous notification is received by the UMS, the socket 
        // is already removed from the internal data structure and UMS ignores the notfication.
        //
        // Currently, we notice that in case of no buffer space is available, winsock 
        // generates a multiple notification. Perhapse there are other cases.
        //                                              Uri Habusha, 9-Nov-99
        //
        ASSERT(result == WSAENOBUFS);
        return;
    }

    if (result != ERROR_SUCCESS) 
    {
        ConnectionFailed(socket, result, pov);        
        return;
    } 

    ConnectionSucceeded(socket, pov);
}


VOID
NoCloseConnection(
    SOCKET Socket
    )
/*++

Routine Description:
    The function closes an existing connection

Arguments:
    Socket - a socket, identifying a connection to close

Return Value:
    None.

--*/
{
    NopAssertValid();

    TrTRACE(No, "NoCloseConnection - Socket=0x%I64x", Socket);

    closesocket(Socket);
}


VOID
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN& Addr,
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine asynchronously connects to the destination IP address using
    the give socket.
    The following steps are used
    1) Save a mapping between the socket and the overlapped. 
    2) Set the socket up for windows message notification of FD_CONNECT events.
    3) Set up quality of service for the connection.
    4) conenct

Arguments:
    Socket - An unbinded stream socket
    Addr - The destination IP address
    pOveralpped - overlapped structure using latter to post the connection result.

Return Value:
    None.

--*/
{
    NopAssertValid();

    TrTRACE(No, "Trying to connect to " LOG_INADDR_FMT ", pov=0x%p, Socket=0x%I64x", LOG_INADDR(Addr), pov, Socket);

    ASSERT(Addr.sin_family == AF_INET);

    //
    // Set up socket for windows message event notification.
    //
    NepSelectSocket(
            Socket,
            FD_CONNECT,
            x_wmConnect
            );

    //
    // Add Overlapped to Map data structure.
    //
    s_SockToOv.Register(Socket, pov);

    //
    // establishes a connection to another socket application.
    // 
    int rc = WSAConnect(
                Socket,
                reinterpret_cast<const SOCKADDR*>(&Addr),
                sizeof(Addr),
                NULL,
                NULL,
                NULL,
                NULL
                );

    if((rc == SOCKET_ERROR) && (WSAGetLastError() != WSAEWOULDBLOCK))
    {
        TrERROR(No, "Failed to establish connection with " LOG_INADDR_FMT ". Error=%d", LOG_INADDR(Addr), WSAGetLastError());

        s_SockToOv.Unregister(Socket);

        throw exception();
    }
}


static
SOCKET
NopCreateConnection(
    int   Type,
    int   Protocol,
    DWORD Flags
    )
/*++

Routine Description:

    The routine creates an unbinded socket.

Arguments:

    Type     - Type specification of the new socket.

    Protocol - Protocl to be used with the socket.

    Flags    - Socket attributes flags.

Return Value:

    SOCKET.

--*/
{
    NopAssertValid();

    //
    // Create a socket for this connection.
    //
    SOCKET Socket = WSASocket(
                        AF_INET,
                        Type,
                        Protocol,
                        NULL,
                        NULL,
                        Flags
                        );

    if(Socket == INVALID_SOCKET) 
    {
        TrERROR(No, "Failed to create a socket. type=%d, protocol=%d, flags=%d, Error=%d", Type, Protocol, Flags, WSAGetLastError());
        throw exception();
    } 

    TrTRACE(No, "NopCreateConnection, Socket=0x%I64x, type=%d, protocol=%d, flags=%d", Socket, Type, Protocol, Flags);
    return Socket;
}


SOCKET
NoCreateStreamConnection(
    VOID
    )
{
    return NopCreateConnection(
               SOCK_STREAM,
               0,
               WSA_FLAG_OVERLAPPED
               );
} // NoCreateStreamConnection


SOCKET
NoCreatePgmConnection(
    VOID
    )
{
    return NopCreateConnection(
               SOCK_RDM, 
               IPPROTO_RM, 
               WSA_FLAG_OVERLAPPED | WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF
               );
} // NoCreatePgmConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mtm\test\mtmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmTest.cpp

Abstract:

    Multicast Transport manager library test

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include "Mtm.h"
#include "Cm.h"
#include "Mmt.h"
#include "msi.h"
#include "Mtmp.h"
#include "timetypes.h"

#include "MtmTest.tmh"

const TraceIdEntry MtmTest = L"Multicast Transport Manager Test";


class CGroup : public IMessagePool
{
public:
    CGroup() :
        IMessagePool()
    {
        AddRef();
    }

    ~CGroup()
    {
    }
    

    VOID Requeue(CQmPacket* )
    {
        throw exception();
    }


    VOID EndProcessing(CQmPacket* )
    {
        throw exception();
    }

    VOID LockMemoryAndDeleteStorage(CQmPacket* )
    {
        throw exception();
    }

    VOID GetFirstEntry(EXOVERLAPPED* , CACPacketPtrs& )
    {
        throw exception();
    }
    
    VOID CancelRequest(VOID)
    {
        throw exception();
    }
};


class CTestTransport : public CMulticastTransport
{
public:
    CTestTransport(
        MULTICAST_ID id
        ) :
        CMulticastTransport(id)
    {
    }
};


R<CMulticastTransport>
MmtCreateTransport(
    MULTICAST_ID id,
	IMessagePool *,
	ISessionPerfmon*, 
    const CTimeDuration&,
    const CTimeDuration&
    )
{
    return new CTestTransport(id);
}



static BOOL s_fCanCloseQueue = TRUE;

VOID CmQueryValue(const RegEntry&, CTimeDuration* pValue)
{
    *pValue = CTimeDuration(rand());
}


VOID MtmpInitConfiguration(VOID)
{
    NULL;
}


VOID 
MtmpGetTransportTimes(
    CTimeDuration& RetryTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    RetryTimeout = CTimeDuration(rand());
    CleanupTimeout = CTimeDuration(rand());
}


const MULTICAST_ID xMulticastId[] = {
//
//  address, port
//    
    1000, 80,
    1010, 90,
    1020, 100,
    1020, 110,
    1010, 95,
    1000, 85
    };
            

VOID CheckError(bool f, DWORD line)
{
    if (f)
        return;

    TrERROR(MtmTest, "Failed. Error in line %d", line);
    exit(1);
}


bool IsEqualMulticastId(MULTICAST_ID id1, MULTICAST_ID id2)
{
    return (id1.m_address == id2.m_address && id1.m_port == id2.m_port);
}


extern "C" int  __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:

    Test Multicast Transport Manager library

Arguments:

    Parameters.

Returned Value:

    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&MtmTest, 1);

    MtmInitialize();

    //
    // Add transport to Mtm
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[0]);

    //
    // Get first transport in TM. 
    //
    R<CMulticastTransport> tr = MtmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[0]), __LINE__);
                                               
    //
    // Get previous transport. Should failed since there is only one transport 
    //
    R<CMulticastTransport> tr2 = MtmFindPrev(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    //
    // remove the transport from Mtm map
    //
    MtmTransportClosed(tr->MulticastId());
    tr.free();

    //
    // Add new transport
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[1]);

    //
    // Get pointer to the transport. So afterwards the test can ask the next and prev
    //
    tr = MtmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[1]), __LINE__);


    //
    // add new transports to Mtm map
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[0]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[2]);

    //
    // Get previous transport
    //
    tr2 = MtmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr2->MulticastId(), xMulticastId[0]), __LINE__);
    tr2.free();


    //
    // remove the added transports
    //
    MtmTransportClosed(tr->MulticastId());

    R<CMulticastTransport> tr1 = MtmGetTransport(xMulticastId[2]);
    MtmTransportClosed(tr1->MulticastId());

    //
    // Find the previous transport of non-existing transport
    //
    tr2 = MtmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr2->MulticastId(), xMulticastId[0]), __LINE__);
    tr2.free();

    //
    // Find the next transport of non-existing transport
    // 
    tr2 = MtmFindNext(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    tr.free();


    //
    // Add new transports to Mtm 
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[1]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[2]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[3]);

    //
    // Enumerate the transport in order
    //
    DWORD i = 0;
    for(tr = MtmFindFirst(); tr.get() != NULL; tr = MtmFindNext(*tr.get()), ++i)
    {
        CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[i]), __LINE__);
    }


    //
    // Close transports
    //
    R<CMulticastTransport> tr3 = MtmGetTransport(xMulticastId[3]);
    MtmTransportClosed(tr3->MulticastId());

    R<CMulticastTransport> tr4 = MtmGetTransport(xMulticastId[0]);
    MtmTransportClosed(tr4->MulticastId());

    R<CMulticastTransport> tr5 = MtmGetTransport(xMulticastId[2]);
    MtmTransportClosed(tr5->MulticastId());


    //
    // Find the first transport in Mtm map, that is the only one
    //
    tr = MtmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[1]), __LINE__);
    tr.free();

    //
    // Close the queue, but act like there is message in the queue
    //
    s_fCanCloseQueue = FALSE;
    R<CMulticastTransport> tr6 = MtmGetTransport(xMulticastId[1]);
    MtmTransportClosed(tr6->MulticastId());

    tr = MtmFindFirst();
    CheckError((tr.get() == NULL), __LINE__);

    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[4]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[5]);

    tr = MtmGetTransport(xMulticastId[4]);
    CheckError((tr.get() != NULL), __LINE__);
    tr.free();

    TrTRACE(MtmTest, "Test passed successfully...");
    
    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\noaddr.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    noaddr.cpp

Abstract:
    Contains address resolution routine

Author:
    Uri Habusha (urih) 22-Aug-99

Enviroment:
    Platform-independent

--*/

#include "libpch.h"
#include <svcguid.h>
#include <Winsock2.h>
#include <No.h>
#include <buffer.h>
#include "Nop.h"

#include "noaddr.tmh"

using namespace std;

//
// Class that ends winsock look up in it's dtor
//
class CAutoEndWSALookupService
{
public:
	CAutoEndWSALookupService(
		HANDLE h = NULL
		):
		m_h(h)
		{
		}

	~CAutoEndWSALookupService()
	{
		if(m_h != NULL)
		{
			WSALookupServiceEnd(m_h);
		}
	}

	HANDLE& get()
	{
		return m_h;		
	}

private:
	HANDLE m_h;	
};



bool
NoGetHostByName(
    LPCWSTR host,
	vector<SOCKADDR_IN >* pAddr,
	bool fUseCache
    )
/*++

Routine Description:
    Return list of addreses for given unicode machine name

Parameters:
    host - A pointer to the null-terminated name of the host to resolve. 
	pAddr - pointer to vector of addresses the function should fill.
	fUseCache - indicate if to use cache for machine name translation (default use cache).
 
Returned Value:
    true on Success false on failure. 
	Call WSAGetLastError() to get the winsock error code in case of faliure.

--*/

{
	ASSERT(pAddr != NULL);
	static const int xResultBuffersize =  sizeof(WSAQUERYSET) + 1024;
   	CStaticResizeBuffer<char, xResultBuffersize> ResultBuffer;


    //
    // create the query
    //
	GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
    AFPROTOCOLS afp[] = { {AF_INET, IPPROTO_UDP}, {AF_INET, IPPROTO_TCP } };

	PWSAQUERYSET pwsaq = (PWSAQUERYSET)ResultBuffer.begin();
    memset(pwsaq, 0, sizeof(*pwsaq));
    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = const_cast<LPWSTR>(host);
    pwsaq->lpServiceClassId = &HostnameGuid;
    pwsaq->dwNameSpace = NS_ALL;
    pwsaq->dwNumberOfProtocols = TABLE_SIZE(afp);
    pwsaq->lpafpProtocols = &afp[0];
	ResultBuffer.resize(sizeof(WSAQUERYSET));


	//
	// get query handle
	//
	DWORD flags =  LUP_RETURN_ADDR;
	if(!fUseCache)
	{
		flags |= LUP_FLUSHCACHE;		
	}

	CAutoEndWSALookupService hLookup;
    int retcode = WSALookupServiceBegin(
								pwsaq,
                                flags,
                                &hLookup.get()
								);

  	

	if(retcode !=  0)
	{
		TrERROR(No, "WSALookupServiceNext got error %d ", WSAGetLastError());
		return false;
	}	


	//
	// Loop and get addresses for the given machine name
	//
 	for(;;)
	{
		DWORD dwLength = numeric_cast<DWORD>(ResultBuffer.capacity());
		retcode = WSALookupServiceNext(
								hLookup.get(),
								0,
								&dwLength,
								pwsaq
								);

		if(retcode != 0)
		{
			int ErrorCode = WSAGetLastError();
			if(ErrorCode == WSA_E_NO_MORE)
				break;

			//
			// Need more space
			//
			if(ErrorCode == WSAEFAULT)
			{
				ResultBuffer.reserve(dwLength + sizeof(WSAQUERYSET));
				pwsaq = (PWSAQUERYSET)ResultBuffer.begin();
				continue;
			}

			TrERROR(No, "WSALookupServiceNext got error %d ", ErrorCode);
			return false;
		}

		DWORD NumOfAddresses = pwsaq->dwNumberOfCsAddrs;
		ASSERT(NumOfAddresses != 0);
		const SOCKADDR_IN*  pAddress = (SOCKADDR_IN*)pwsaq->lpcsaBuffer->RemoteAddr.lpSockaddr;
		ASSERT(pAddress != NULL);
		copy(pAddress, pAddress + NumOfAddresses, back_inserter(*pAddr));
 	}
	return true; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\nodebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoDebug.cpp

Abstract:
    Network Output debugging

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Nop.h"

#include "nodebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Network Send state
//
void NopAssertValid(void)
{
    //
    // NoInitalize() has *not* been called. You should initialize the
    // Network Send library before using any of its funcionality.
    //
    ASSERT(NopIsInitialized());

    //
    // TODO:Add more Network Send validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void NopSetInitialized(void)
{
    LONG fNoAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Network Send library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fNoAlreadyInitialized);
}


BOOL NopIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    No,

    //
    // TODO: Add Network Send sub-component trace ID's to be used with TrXXXX.
    // For example, NoInit, as used in:
    // TrERROR(NoInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "NoDumpState(queue path name)",
        "Dump Network Send State to debugger",
        DumpState
    ),

    //
    // TODO: Add Network Send debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void NopRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\nop.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Nop.h

Abstract:
    Network Output private functions.

Author:
    Uri Habusha (urih) 12-Aug-99

--*/

#pragma once

const TraceIdEntry No = L"Network Output";

#ifdef _DEBUG

void NopAssertValid(void);
void NopSetInitialized(void);
BOOL NopIsInitialized(void);
void NopRegisterComponent(void);

#else // _DEBUG

#define NopAssertValid() ((void)0)
#define NopSetInitialized() ((void)0)
#define NopIsInitialized() TRUE
#define NopRegisterComponent() ((void)0)

#endif // _DEBUG

//
// No window message values
//
const DWORD x_wmConnect = WM_USER+2;

void
NepInitializeNotificationWindow(
    void
    );

//
//  Handles the reception of a USMSG_CONNECT message. 
//
void
NepCompleteConnect(
    SOCKET Socket,
    WORD Result
    );

//
// Select the socket with provider to receive messages for async window
//
void
NepSelectSocket(
    SOCKET Socket,
    LONG   AsyncEventMask,
    ULONG  wMsg
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\noinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoInit.cpp

Abstract:
    Network Output initialization

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "No.h"
#include "Nop.h"

#include "noinit.tmh"

//
// version of Winsock we need
//
const WORD x_WinsockVersion = MAKEWORD(2, 0);

VOID
NoInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Network Send library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Network Send library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!NopIsInitialized());

    NopRegisterComponent();

    //
    // Start WinSock 2.  If it fails, we don't need to call
    // WSACleanup().
    //
    WSADATA WSAData;
    if (WSAStartup(x_WinsockVersion, &WSAData))
    {
		TrERROR(No, "Start winsock 2.0 Failed. Error %d", GetLastError());
        throw exception();
    }

    //
    // Intialize the Network window notification
    //
    NepInitializeNotificationWindow();

    NopSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\norecv.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    Noio.cpp

Abstract:
    This module contains the general routine for sending/receiving .

Author:
    Uri Habusha (urih)  18-Jan-98

Enviroment:
    Platform-independent

--*/

#include "libpch.h"
#include "Ex.h"
#include "No.h"
#include "Nop.h"

#include "norecv.tmh"

//-------------------------------------------------------------------
//
// class CReceiveOv
//
//-------------------------------------------------------------------
class CReceiveOv : public EXOVERLAPPED {
public:
    CReceiveOv(
        EXOVERLAPPED* pContext,
        SOCKET Socket,
        char* Buffer,
        DWORD Size
		) : 
		EXOVERLAPPED(ReceiveSucceeded, ReceiveFailed), 
		m_pContext(pContext),
		m_Socket(Socket),
		m_Buffer(Buffer),
		m_Size(Size)
	{
	}

private:
	void ReceiveSucceeded();


	DWORD BytesReceived() const
	{
        //
        // In win64, InternalHigh is 64 bits. Since the max chunk of data
        // we read in one operation is always less than MAX_UNIT we can cast
        // it to DWORD safetly
        //
        ASSERT(0xFFFFFFFF >= InternalHigh);

		return static_cast<DWORD>(InternalHigh);
	}


private:
	static void	WINAPI ReceiveSucceeded(EXOVERLAPPED* pov);
	static void	WINAPI ReceiveFailed(EXOVERLAPPED* pov);

private:

    SOCKET m_Socket;
    char* m_Buffer;
	DWORD m_Size;
    EXOVERLAPPED* m_pContext;

};


void CReceiveOv::ReceiveSucceeded()
/*++

Routine Description:
    The routine calls when receive operation completes successfully.
	It continues to receive thill the entier caller buffer is satisfied.
	When the entire buffer is receive the caller gets notified.

Arguments:
    None.
     
Returned Value:
    None.
    
--*/
{
	P<CReceiveOv> ar(this);

    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
    if(BytesReceived() == 0)
    {
		TrERROR(No, "Receive from socket 0x%I64x failed. Bytes receive=0", m_Socket);
		m_pContext->CompleteRequest(STATUS_UNSUCCESSFUL);
        return;
    }

    if(BytesReceived() == m_Size)
    {

		TrTRACE(No, "Receive from socket 0x%I64x completed successfully", m_Socket);
		m_pContext->CompleteRequest(STATUS_SUCCESS);
		return;
	}

    //
    // Partial read. continue ...
    //
    m_Buffer += BytesReceived();
    m_Size -= BytesReceived();

	try
	{
		NoReceivePartialBuffer(m_Socket, m_Buffer, m_Size, this);
		ar.detach();
	}
	catch(const exception&)
	{
		TrERROR(No, "Failed to continue and receive eniter buffer. context=0x%p", m_pContext);
		m_pContext->CompleteRequest(STATUS_UNSUCCESSFUL);
	}

}


void WINAPI CReceiveOv::ReceiveSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(pov->GetStatus() == STATUS_SUCCESS);

    CReceiveOv* pReceiveOv = static_cast<CReceiveOv*>(pov);
	pReceiveOv->ReceiveSucceeded();
}


void WINAPI CReceiveOv::ReceiveFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when receive operation failes. It notifiy the
	original caller about the receive outcome.
    
Arguments:
    pointer to the calling overlapped structure
     
Returned Value:
    None.
    
--*/
{
    P<CReceiveOv> pReceiveOv = static_cast<CReceiveOv*>(pov);

    ASSERT(FAILED(pov->GetStatus()));

    TrERROR(No, "Receive from socket 0x%I64x failed. Status=%d", pReceiveOv->m_Socket, pov->GetStatus());

    //
    // retrieve information from receive OVERLAPPED
    //
    EXOVERLAPPED* pContext = pReceiveOv->m_pContext;
    pContext->CompleteRequest(pov->GetStatus());
}


VOID
NoReceiveCompleteBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine receive data on connected socket. The routine uses ReadFile
    for Asynchronous receive. When receive of the Data completed the program gets
    notification using the completion port mechanism.

Arguments:
    Socket - handle to connected socket.
    pBuffer - a buffer to store the data transfered
    Size - Buffer Size and no. of bytes to read
    pov - pointer to ovelapped structure pass to ReadFile

Return Value:
	None.

--*/
{
    NopAssertValid();

    P<CReceiveOv> pReceiveOv = new CReceiveOv(
										pov,
										Socket,
										static_cast<char*>(pBuffer),
										Size
										);

    NoReceivePartialBuffer(Socket, pBuffer, Size, pReceiveOv);
	pReceiveOv.detach();
}


VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine receive data on connected socket. The routine uses ReadFile
    for Asynchronous receive. When partial receive completes the caller gets
    notification using the completion port mechanism.

Arguments:
    Socket - The connection socket handle
    pBuffer - a buffer to store the data transfered
    Size - Buffer Size
    pov - pointer to ovelapped structure pass to ReadFile

Return Value:
	None.

--*/
{
    NopAssertValid();

    DWORD Flags = 0;
    DWORD nBytesReceived;
    WSABUF Chunk = { Size, static_cast<char*>(pBuffer) };

    int rc = WSARecv(
				Socket,
				&Chunk,
				1,
				&nBytesReceived,
				&Flags,
				pov,
				NULL
				);

    if ((rc == SOCKET_ERROR) && (WSAGetLastError() != ERROR_IO_PENDING))
    {
        TrERROR(No, "Receive Operation Failed. Error=%d", WSAGetLastError());
		throw exception();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\nosend.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    Noio.cpp

Abstract:
    This module contains the general routine for sending/receiving .

Author:
    Uri Habusha (urih)  18-Jan-98

Enviroment:
    Platform-independent

--*/

#include "libpch.h"
#include "Ex.h"
#include "No.h"
#include "Nop.h"

#include "nosend.tmh"

//
// Send Operation overlapped structure
//
class CSendOv : public EXOVERLAPPED
{
public:
    CSendOv(
        EXOVERLAPPED* pContext,
        SOCKET Socket
        ) :
		EXOVERLAPPED(SendSucceeded, SendFailed), 
		m_pContext(pContext),
		m_Socket(Socket)
	{
	}
    
    void SendLength(DWORD length)
    {
        m_SendLength = length;
    }

    DWORD SendLength(void)
    {
        return m_SendLength;
    }

    DWORD BytesSent(void)
    {
        //
        // In win64, InternalHigh is 64 bits. Since the max chunk of data
        // we read in one operation is always less than MAX_UNIT we can cast
        // it to DWORD safetly
        //
        ASSERT(0xFFFFFFFF >= InternalHigh);

		return static_cast<DWORD>(InternalHigh);
    }

    
private:
	static void	WINAPI SendSucceeded(EXOVERLAPPED* pov);
	static void	WINAPI SendFailed(EXOVERLAPPED* pov);

private:
    SOCKET m_Socket;
    EXOVERLAPPED* m_pContext;
  
    
        DWORD m_SendLength;
    

};



void
WINAPI
CSendOv::SendFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine calls when send operation failes.

    the routine retrieve the caller overlapped, close the socket,set the operation 
    result to failure error code and call to execute the completion routine
    
Arguments:
    pointer to the calling overlapped structure
     
Returned Value:
    None.
    
--*/
{
    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);

    ASSERT(pov->GetStatus() != STATUS_SUCCESS);

    TrERROR(No, "Send on socket 0x%I64x Failed. Error %d", pSendOv->m_Socket, pov->GetStatus());

    EXOVERLAPPED* pContext = pSendOv->m_pContext;
    pContext->CompleteRequest(pov->GetStatus());
}


void
WINAPI
CSendOv::SendSucceeded(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine calls when send operation completes successfully.

    the routine retrieve the caller overlapped, set the operation 
    result to STATUS_SUCCESS and call to execute the completion routine
    
Arguments:
    pointer to the calling overlapped structure
     
Returned Value:
    None.
    
--*/
{
    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);

    ASSERT(pov->GetStatus() == STATUS_SUCCESS);
	EXOVERLAPPED* pContext = pSendOv->m_pContext;

	//
	// gilsh - fix for bug 5583 - in rare cases (winsock bug) - The operation completed 
	// successfully but the number of sending bytes 
	// wasnt equivalent to the number of bytes that were requested to be sent. 
	// In that rare case we consider it as faliure. 
	//
	if( pSendOv->SendLength() != pSendOv->BytesSent() )
	{
		TrERROR( 
			No,
			"Unexpected winsock behavior, SendLength=%d BytesSent=%d",
			pSendOv->SendLength(),
			pSendOv->BytesSent()
			);
 
		pContext->CompleteRequest(STATUS_UNSUCCESSFUL);
		return;
	}

	TrTRACE(No, "Send operation on socket 0x%I64x completed Successfully", pSendOv->m_Socket);
	pContext->CompleteRequest(STATUS_SUCCESS);
}


VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF* sendBuf,                                     
    DWORD nBuffers, 
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine sends data to connected socket. The routine uses WriteFile
    to Asynchronous send. When the send of the Data completed the program gets
    notification using the completion port mechanism.

Arguments:
    Socket - handle to connected socket.
    sendBuf - a buffer containing the data to be transfered
    nBuffers - The length of data should be transfered
    pov - pointer to ovelapped structure pass to WriteFile

Return Value:
    None.

--*/
{
    NopAssertValid();

    ASSERT(nBuffers != 0);

    P<CSendOv> pSendOv = new CSendOv(pov, Socket);
   

	//
	// We compute the send length to verify that when send return succsefully -
	// all byte were actually sent. Because of winsock bug - in rare cases it not always
	// true
	//
    DWORD length = 0;
    for (DWORD i = 0; i < nBuffers; ++i)
    {
        length += sendBuf[i].len;
    }
    pSendOv->SendLength(length);

   

    int rc;
    DWORD NumberOfBytesSent;
    rc = WSASend(
            Socket,
            const_cast<WSABUF*>(sendBuf),
            nBuffers,
            &NumberOfBytesSent,
            0,
            pSendOv,
            NULL
            );

    if ((rc == SOCKET_ERROR) && (WSAGetLastError() != ERROR_IO_PENDING))
    {
        TrERROR(No, "Send Operation Failed. Error %d", WSAGetLastError());
        throw exception();
    }

    pSendOv.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\test\notest.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoTest.cpp

Abstract:
    Network Output library test

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef __NOTEST_H__
#define __NOTEST_H__

const TraceIdEntry No_Test = L"Network Output Test";

extern DWORD g_nMessages;
extern DWORD g_messageSize;

void 
TestConnect(
    LPCWSTR hostname,
    LPCWSTR dsetHost,
    USHORT port,
    LPCWSTR resource,
    HANDLE hEvent
    );

void
WaitForResponse(
    SOCKET s,
    HANDLE hEvent
    );

void
SendRequest(
    SOCKET s,
    LPWSTR host,
    LPWSTR resource
    );


#endif // __NOTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\imappingchangehandler.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    IMappingChangeHandler.h

Abstract:
	Abstract interface INotificationHandler for consuming the notification
	about mapping change.

Author:
    Gil Shafriri (gilsh) 21-Nov-00

--*/
#ifndef _MSMQ_IMappingChangeHandler_H_
#define _MSMQ_IMappingChangeHandler_H_

class bad_win32_error;

class IMappingChangeHandler : public CReference
{
public:
	virtual void ChangeNotification() throw() = 0 ;
	virtual void MonitoringWin32Error(LPCWSTR pMappingDir, DWORD err) throw() =0;
	virtual ~IMappingChangeHandler(){};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\test\notest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoTest.cpp

Abstract:
    Network Output library test

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "NoTest.tmh"

const USHORT HTTP_DEFAULT_PORT = 80;


static LPCWSTR* s_pQueueList = NULL;
static DWORD s_noOfQueues = 0;

static WCHAR s_proxyName[256];
static USHORT s_proxyPort;
static bool s_fUseProxy = false;

DWORD g_nMessages = INFINITE;
DWORD g_messageSize = 100;

static USHORT s_port = HTTP_DEFAULT_PORT;


static 
bool 
CrackUrl(
    LPCWSTR url,
    LPWSTR hostName,
    USHORT& port,
    LPWSTR resourceName
    )
/*++

Routine Description:

    Cracks an URL into its constituent parts. 

Arguments:

    url      - pointer to URL to crack. The url is null terminated string

    hostName - Address of a string value that contains the host name. The 
               routine assume that the buffer is big enough to hold the host name
               part of the URL.

    port - HTTP port number. If it doesn't specified in URL the default HTTP port
            is returned

Return Value:

    bool
        Success - true

        Failure - false. 

--*/
{
    ASSERT(url != NULL);

    const WCHAR httpScheme[] = L"http://";
    const DWORD httpSchemeLength = wcslen(httpScheme);
    const WCHAR HostNameBreakChars[] = L";:@?/";

    if (_wcsnicmp(url, httpScheme, httpSchemeLength) != 0)
        return false;

    //
    // Advance the URL to point on the host name
    //
    LPCWSTR HostNameBegin = url + httpSchemeLength;

    //
    // find the end of host name in url. it is terminated by "/", "?", ";",
    // ":" or by the end of URL
    //
    LPCWSTR HostNameEnd = wcspbrk(HostNameBegin, HostNameBreakChars);

    //
    // calculate the host name length
    //
    DWORD HostNameLength;
    if (HostNameEnd == NULL)
    {
        HostNameLength = wcslen(HostNameBegin);
    }
    else
    {
        DWORD_PTR temp = HostNameEnd - HostNameBegin;
        ASSERT(0xFFFFFFFF >= temp);

        HostNameLength = static_cast<DWORD>(temp);
    }

    //
    // copy the host name from URL to user buffer and add terminted
    // string in the end
    //
    wcsncpy(hostName, HostNameBegin, HostNameLength);
    hostName[HostNameLength] = L'\0';

    //
    // get the port number
    //
    port = HTTP_DEFAULT_PORT;
    resourceName[0] = L'\0';
    if(HostNameEnd == NULL)
        return true;

    if(*HostNameEnd == L':')
    {
        port = static_cast<USHORT>(_wtoi(HostNameEnd + 1));
        HostNameEnd = wcspbrk(HostNameEnd + 1, HostNameBreakChars);
    }

    if(HostNameEnd == NULL)
        return true;

    if(*HostNameEnd == L'/')
    {
        wcscpy(resourceName, HostNameEnd + 1);
    }

    return true;
}


bool
ParseCommand(
    int argc, 
    LPCTSTR argv[]
    )
{

    s_pQueueList = NULL;
    s_noOfQueues = 0;
    s_fUseProxy = false;
    //
    // Parse command line
    //
    --argc;
    ++argv;
    while (argc != 0)
    {
        if (argv[0][0] != L'-')
        {
            goto usage;
        }

        switch(argv[0][1])
        {
        case L'n':
        case L'N':
            g_nMessages = _wtoi(argv[1]);
            argc -= 2;
            argv += 2;
            break;

        case L's':
        case L'S':
            g_messageSize = _wtoi(argv[1]);
            argc -= 2;
            argv += 2;
            break;

        case L'c':
        case L'C':
            {
                ++argv;
                --argc;  
                s_pQueueList = argv;
                s_noOfQueues = 0;

                WCHAR hostName[256];
                WCHAR resourceName[256];
                USHORT port;

                while ((argc != 0) && CrackUrl(argv[0], hostName, port, resourceName))
                {
                    ++s_noOfQueues;
                    ++argv;
                    --argc;  
                } 
                break;
            }

        case L'p':
        case L'P':
            {
                WCHAR resourceName[256];
                
                if ((argc == 0) || 
                    (! CrackUrl(argv[1], s_proxyName, s_proxyPort, resourceName)) ||
                    resourceName[0] != L'\0'
                    )
                {
                    printf("Failed to parse test parameters. Illegal proxy name\n");
                    goto usage;
                }
                s_fUseProxy = true;

                argc -= 2;
                argv += 2;
                break;
            }

        default:
            goto usage;
        }
    }

    if (s_noOfQueues != 0)
    {
        return true;
    }

usage:
    printf("Usage:\n"
           "\tNoTest -c <list of queues url> -n <number of messages> -s <message size> -p <proxy url>[-? | -h]\n");
    printf("\tc - List of destination queues url\n");
    printf("\tn - Number of messages to send\n");
    printf("\ts - Message Size\n");
    printf("\tp - Proxy url\n");
    printf("\t?/h - Help message\n");
    printf("Example:\n");
    printf("\tNoTest -c http://urih0/queue1  http://urih5/queue2 -n 10 -s 1000 -p http://proxy:8080\n");
    
    return false;
}

static void TestNameResolution()
{
	//
	// Get unicode machine name
	//
	WCHAR wcname[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD len = TABLE_SIZE(wcname);
	BOOL fRet = GetComputerName(wcname, &len);
	if(!fRet)
	{
		TrERROR(No_Test, "could not  get computer name");
		throw exception();
	}

	//
	// Unicode name resolution
	//
  	std::vector<SOCKADDR_IN> wAddr;
	if(!NoGetHostByName(wcname, &wAddr))
	{
		TrERROR(No_Test, "unicode get name resolution of the local machine failed");
		throw exception();
	}
	ASSERT(wAddr.size() > 0);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Network Send library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    if (!ParseCommand(argc, argv))
    {
        return -1;
    }

    printf("Send messages to:\n");
    for (DWORD i = 0; i < s_noOfQueues; ++i)
    {
        printf("\t%ls\n", s_pQueueList[i]);
    }
    
    TrInitialize();

    ExInitialize(5);

    NoInitialize();

	TestNameResolution();
	

    HANDLE* CompleteEvent = new HANDLE[s_noOfQueues];

    for (DWORD i = 0; i < s_noOfQueues; ++i)
    {
        CompleteEvent[i] = CreateEvent(NULL,FALSE, FALSE, NULL);
        
        WCHAR hostName[256];
        WCHAR resourceName[256];
        USHORT port;

        bool f = CrackUrl(s_pQueueList[i], hostName, port, resourceName);
        ASSERT(f);
		DBG_USED(f);

        if (s_fUseProxy)
        {
            TestConnect(s_proxyName, hostName, s_proxyPort, s_pQueueList[i], CompleteEvent[i]);
            continue;
        }

        TestConnect(hostName, hostName, port, resourceName, CompleteEvent[i]);
    }


    WaitForMultipleObjects(s_noOfQueues, CompleteEvent, TRUE, INFINITE);

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\test\connect.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    connect.cpp

Abstract:
    connect functions

Author:
    Uri Habusha (urih) 2-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "connect.tmh"

using namespace std;

class ConnectOv : public EXOVERLAPPED
{
public:
    ConnectOv(
        LPWSTR hostName, 
        LPWSTR destHost,
        USHORT port,
        LPWSTR resource,
        HANDLE hEvent
        );

public:
    static void WINAPI ConnectSuccessed(EXOVERLAPPED* pov);
    static void WINAPI ConnectFailed(EXOVERLAPPED* pov);

private:
    void CreateSendRequest(void);

private:
    SOCKET m_socket;
    CTimeInstant m_time;

    AP<WCHAR> m_destHost;
    AP<WCHAR> m_host;
    AP<WCHAR> m_resource;
    USHORT m_port;

    HANDLE m_hEvent;
};


ConnectOv::ConnectOv(
    LPWSTR hostName,
    LPWSTR destHost,
    USHORT port,
    LPWSTR resource,
    HANDLE hEvent
    ) :
    EXOVERLAPPED(ConnectSuccessed, ConnectFailed),
    m_host(hostName),
    m_destHost(destHost), 
    m_resource(resource),
    m_port(port),
    m_hEvent(hEvent),
    m_socket(INVALID_SOCKET),
    m_time(ExGetCurrentTime())
{
	vector<SOCKADDR_IN> sockAddress;
    bool fSucc = NoGetHostByName(m_host, &sockAddress);
    if (!fSucc)
    {
        TrERROR(No_Test, "Failed to resolve Address of %ls Machine", m_host);
        throw exception();
    }

    SOCKADDR_IN Addr = sockAddress[0];
    TrTRACE(No_Test, "Resolved address for '%ls'. Address=" LOG_INADDR_FMT, m_host, LOG_INADDR(Addr));

    Addr.sin_port = htons(m_port);


    m_socket = NoCreateStreamConnection();
    if (m_socket == INVALID_SOCKET)
    {
        TrERROR(No_Test, "Failed to create socket. Error %d", GetLastError());
        throw exception();
    }

    NoConnect(m_socket, Addr, this);

}


void
WINAPI
ConnectOv::ConnectSuccessed(
    EXOVERLAPPED* pov
    )
{
    
    ASSERT(SUCCEEDED(pov->GetStatus()));

    P<ConnectOv> pcov = static_cast<ConnectOv*>(pov);

    ULONGLONG connectTime = (ExGetCurrentTime() - pcov->m_time).Ticks() / CTimeDuration::OneMilliSecond().Ticks();
    TrTRACE(No_Test, "Create connection with %ls complete successfully. Notified after %I64d ms ", pcov->m_host, connectTime);
 
    WaitForResponse(pcov->m_socket, pcov->m_hEvent);
    SendRequest(pcov->m_socket, pcov->m_destHost.detach(), pcov->m_resource.detach());
}


void
WINAPI
ConnectOv::ConnectFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));

    P<ConnectOv> pcov = static_cast<ConnectOv*>(pov);

    ULONGLONG connectTime = (ExGetCurrentTime() - pcov->m_time).Ticks() / CTimeDuration::OneMilliSecond().Ticks();
    TrERROR(No_Test, "Failed to create connection with %ls. Notified after %I64d ms", pcov->m_host, connectTime);

    if (SetEvent(pcov->m_hEvent) == 0)
    {
        TrERROR(No_Test, "Faield to set event. Error %d", GetLastError());
    }
}


void 
TestConnect(
    LPCWSTR hostname,
    LPCWSTR destHost,
    USHORT port,
    LPCWSTR resource,
    HANDLE hEvent
    )
{
    new ConnectOv(newwcs(hostname), newwcs(destHost), port, newwcs(resource), hEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\lib\nowin.cpp ===
/*++

  Copyright (c) 1997  Microsoft Corporation

Module Name:
    Nowin.cpp

Abstract:
    implementation of the functions handle Notification window.

Author:
    Uri Habusha (urih) 18-Jan-98

Enviroment:
    Platform-independent

--*/

#include "libpch.h"
#include "Nop.h"

#include "nowin.tmh"

const TCHAR x_NotifyWindowClassName[] = _T("No Notification Window");
static HWND s_hNotifyWindow = NULL;
 

inline
static
HWND
GetNotifyWindowHandle(
    void
    )
{
    ASSERT(s_hNotifyWindow != NULL);
	return s_hNotifyWindow;
}


LRESULT 
CALLBACK
WindowProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

  Routine Description:
    The function process Network window messages. 

  Arguments:
    hWnd - Identifies the window procedure that received the message. 
    Msg  - Specifies the message. 
    wParam - Specifies additional message information. The content of this parameter 
             depends on the value of the Msg parameter. 
    lParam - Specifies additional message information. The content of this parameter 
             depends on the value of the Msg parameter. 

  Returned Value:
    Always TRUE. Error should be handle in the function process the message 

  Note:

--*/
{
    switch(msg)
    {
        case x_wmConnect:
            NepCompleteConnect((SOCKET)wParam, WSAGETSELECTERROR(lParam));
            return TRUE;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
}


static
void
CreateNotifyWindow(
    void
    )
/*++

  Routine Description:
    The routine Create the window that using to handle the notification message

  Arguments:
    None.

  Returned Value:
    TRUE indicates create notification windows completed successfully. FALSE otherwise

  Note:

--*/
{
    ASSERT(s_hNotifyWindow == NULL);

    //
    // Register the window class.
    //
    WNDCLASS wndclass;
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = NULL;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = x_NotifyWindowClassName;

    if(!RegisterClass(&wndclass))
    {
        TrERROR(No, "RegisterClass failed. Error %d", GetLastError());
        throw exception();
    }


    //
    // Create the window.
    //
    s_hNotifyWindow = CreateWindow(
                        x_NotifyWindowClassName,   // lpszClassName
                        _TEXT(""),                  // lpszWindowName
                        WS_OVERLAPPEDWINDOW,        // dwStyle
                        CW_USEDEFAULT,              // x
                        CW_USEDEFAULT,              // y
                        CW_USEDEFAULT,              // nWidth
                        CW_USEDEFAULT,              // nHeight
                        NULL,                       // hwndParent
                        NULL,                       // hmenu
                        NULL,                       // hinst
                        NULL                        // lpvParam
                        );

    if(s_hNotifyWindow == NULL) 
    {
        TrERROR(No, "CreateWindow failed. Error %d", GetLastError());
        throw exception();
	}

    TrTRACE(No, "Create notification window completed successfully. Window Handle 0x%p", s_hNotifyWindow);
}


static
DWORD
WINAPI
WindowWorkingThread(
    LPVOID 
    )
/*++
Routine Description:

    Thread procedure passed to CreatThread(). The thread handle the 
    window message.

Arguments:

    None.

Return Value:

    The Return value of the worker thread

--*/

{
    ASSERT(s_hNotifyWindow == NULL);

    try
    {
        CreateNotifyWindow();
    }
    catch(const exception&)
    {
        s_hNotifyWindow = (HWND)-1;
        return (DWORD)-1;
    }

    MSG WinMsg;
	while(GetMessage(&WinMsg, NULL, 0, 0) != -1)
    {
		TranslateMessage(&WinMsg);
		DispatchMessage(&WinMsg);
	}

    TrERROR(No, "Exiting async thread. Error %d", GetLastError());

    return 0;   
}


void
NepInitializeNotificationWindow(
    void
    )
/*++

Routine Description:
    Initialize the notification window

Arguments:
    None.

Returned Value:
    TRUE, initilization completed successfully. FALSE otherwise

Note:

--*/
{
    ASSERT(s_hNotifyWindow == NULL);

    HANDLE hThread;
    DWORD  ThreadID;
    hThread = CreateThread(
                NULL,
                0,
                WindowWorkingThread,
                NULL,
                0,
                &ThreadID
                );
        
    if (hThread == NULL) 
    {
        TrERROR(No, "Failed to create notification window thread. Error=%d", GetLastError());
        throw exception();
    }

    CloseHandle(hThread);

    //
    // Busy loop. Waiting for window creation to complete.
    // 
    while (s_hNotifyWindow == NULL)
    {
        Sleep(10);
    }

    //
    // If the creation of the notification window failed, the thread set
    // the "s_hNotifyWindow" to -1. otherwise "s_hNotifyWindow" contains the window handle
    //
    if (s_hNotifyWindow == (HWND)-1)
    {
        TrERROR(No, "Failed to create notification window Error=%d.", GetLastError());
        throw exception();
    }
}


void
NepSelectSocket(
    SOCKET Socket,
    LONG   AsyncEventMask,
    ULONG  wMsg 
    )
/*++
Routine Description:

    Register the socket with provider to receive messages for async window.
   
Arguments:

    Socket - A pointer to a SOCKET object for the socket that is registering.

Return Value:

    On success TRUE, else a FALSE.

--*/
{
	//
    // Add the socket to the wait array
	//
    int rc = WSAAsyncSelect(
                Socket,
                GetNotifyWindowHandle(),
                wMsg,
                AsyncEventMask
                );

    BOOL fSucc = ((rc == 0) || (WSAGetLastError() == WSAEWOULDBLOCK));
    if (!fSucc)
    {
        TrERROR(No, "WSAAsyncSelect Failed. Error=%d", WSAGetLastError());
        throw exception();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\test\response.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    response.cpp

Abstract:
    response functions

Author:
    Uri Habusha (urih) 2-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "response.tmh"

static bool FindEndOfResponse(LPCSTR buf, DWORD length, DWORD& headerSize)
{
    headerSize = 0;

    if (4 > length)
        return false;

    for(DWORD i = 0; i < length - 3; ++i)
    {
        if (buf[i] != '\r')
            continue;

        if ((buf[i+1] == '\n') && (buf[i+2] == '\r') && (buf[i+3] == '\n'))
        {
            headerSize = i + 4;
            return true;
        }
    }

    return false;
}


class ResponseOv: public EXOVERLAPPED
{
public:
    ResponseOv(SOCKET s, HANDLE h, DWORD nMessages);

public:
    static void WINAPI ResponseSuccess(EXOVERLAPPED* pov);
    static void WINAPI ResponseFailed(EXOVERLAPPED* pov);

private:
    SOCKET m_socket;
    char m_buff[4096];

    DWORD m_bytesRead;
    DWORD m_nMessages;
    HANDLE m_hEvent;
};


ResponseOv::ResponseOv(
    SOCKET s, 
    HANDLE h, 
    DWORD nMessages
    ) :
    EXOVERLAPPED(ResponseSuccess, ResponseFailed),
    m_socket(s),
    m_bytesRead(0),
    m_nMessages(nMessages),
    m_hEvent(h)
{
    NoReceivePartialBuffer(m_socket, m_buff, TABLE_SIZE(m_buff), this);
};


void
WINAPI
ResponseOv::ResponseFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));

    P<ResponseOv> prov = static_cast<ResponseOv*>(pov);

    TrERROR(No_Test, "Failed to receive response on socket %I64x", prov->m_socket);

    if (SetEvent(prov->m_hEvent) == 0)
    {
        TrERROR(No_Test, "Faield to set event. Error %d", GetLastError());
    }
}


void
WINAPI
ResponseOv::ResponseSuccess(
    EXOVERLAPPED* pov
    )
{
    ResponseOv* prov = static_cast<ResponseOv*>(pov);

    TrTRACE(No_Test, "Response received %I64d bytes", pov->InternalHigh);

    ASSERT(0xFFFFFFFF >= pov->InternalHigh);
    prov->m_bytesRead += static_cast<DWORD>(pov->InternalHigh);

    DWORD headerSize;
    if(!FindEndOfResponse(prov->m_buff, prov->m_bytesRead, headerSize))
    {
        //
        // Receive the next response chunk
        //
        NoReceivePartialBuffer(
            prov->m_socket,
            prov->m_buff + prov->m_bytesRead,
            TABLE_SIZE(prov->m_buff) - prov->m_bytesRead,
            pov
            );

        return;
    }

    prov->m_buff[prov->m_bytesRead] = '\0';
    TrTRACE(No_Test, "Response: %s", prov->m_buff);

    if (--prov->m_nMessages == 0)
    {
        if (SetEvent(prov->m_hEvent) == 0)
        {
            TrERROR(No_Test, "Faield to set event. Error %d", GetLastError());
        }
        
        delete prov;

        return;
    }

    //
    // Handle extra data that was read
    //
    if (prov->m_bytesRead > headerSize)
    {
        memcpy(prov->m_buff, (prov->m_buff + headerSize), (prov->m_bytesRead - headerSize));
        prov->m_bytesRead = prov->m_bytesRead - headerSize;
        prov->m_bytesRead = 0;

        ResponseSuccess(prov);
        return;
    }

    //
    // Receive HTTP response
    //
    NoReceivePartialBuffer(
        prov->m_socket,
        prov->m_buff,
        TABLE_SIZE(prov->m_buff),
        prov
        );

}



void
WaitForResponse(
    SOCKET s,
    HANDLE hEvent
    )
{
    new ResponseOv(s, hEvent, g_nMessages);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\no\test\send.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    send.cpp

Abstract:
    send functions

Author:
    Uri Habusha (urih) 2-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "send.tmh"

const LPCSTR xMessages[] = {
/*0*/
       "<HEADERS>\n"
            "<MSM>\n"
                "<TO>%ls/%ls</TO>\n"
                "<FROM>http://www.home.com</FROM>\n"
                "<MSG>"
                    "<ID>%I64d</ID>"
                    "<CHN>%d</CHN>"
                "</MSG>"
            "</MSM>\n"
        "</HEADERS>\n"
        "<MyPayload>\n"
            "<MyType>XML</MyType>\n"
            "<MyName>Ticker</MyName>\n"
            "<quote name=\"MSFT\" time=\"12:53\" value=\"203.57\" splits=\"98\"/>\n"
        "</MyPayload>\n",
};


const char xFillBuffer[] = "abcdefghijklmnopqrstuvwxyz1234567890";


class SendOv : public EXOVERLAPPED
{
public:
    SendOv(
        SOCKET s, 
        LPWSTR host, 
        LPWSTR resource, 
        DWORD n
        );

public:
    static void WINAPI SendSuccessed(EXOVERLAPPED* pov);
    static void WINAPI SendFailed(EXOVERLAPPED* pov);

private:
    void SendHttpRequest(void);
    char* CreateMessage(void);

private:
    SOCKET m_socket;
    char m_request[256];
    char* m_pMsg;

    AP<WCHAR> m_host;
    AP<WCHAR> m_resource;

    DWORD m_nMessages;
    LARGE_INTEGER m_msgId;
};


SendOv::SendOv(
    SOCKET s, 
    LPWSTR host, 
    LPWSTR resource, 
    DWORD n
    ) :
    EXOVERLAPPED(SendSuccessed, SendFailed),
    m_socket(s),
    m_nMessages(n),
    m_host(host),
    m_resource(resource),
    m_pMsg(NULL)
{
    m_msgId.HighPart = static_cast<DWORD>(time(NULL));

    SendHttpRequest();
};



void
WINAPI
SendOv::SendFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));

    P<SendOv> psov = static_cast<SendOv*>(pov);

    TrERROR(No_Test, "failed to send HTTP request on socket = %I64x", psov->m_socket);
}


void
WINAPI
SendOv::SendSuccessed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    SendOv* psov = static_cast<SendOv*>(pov);

    //
    // Send next message
    //
    if (--psov->m_nMessages > 0)
    {
        psov->SendHttpRequest();
        return;
    }

    delete [] psov->m_pMsg;
    delete psov;
}


void SendOv::SendHttpRequest(void)
{
    delete [] m_pMsg;
    m_pMsg = CreateMessage();

    DWORD MessageLength = strlen(m_pMsg);

    sprintf(
        m_request, 
        "POST %ls HTTP/1.1\r\n"
        "Content-Length: %d\r\n"
        "Host: %ls\r\n"
        "Connection: keep-Alive\r\n"
        "\r\n",
        m_resource,
        MessageLength,
        m_host
        );

    WSABUF HttpRequestBuf[] = {
        {strlen(m_request), m_request},
        {MessageLength, m_pMsg},
    };

    NoSend(m_socket, HttpRequestBuf, TABLE_SIZE(HttpRequestBuf), this);
}


char* SendOv::CreateMessage(void)
{
    DWORD size;
    if (g_messageSize != INFINITE)
    {
        size = g_messageSize;
    }
    else
    {
        size = (rand() % (1024)) + 256;
    }

    char* Message = new char[size];

    int n = _snprintf(
                Message,
                size,
                xMessages[rand() % TABLE_SIZE(xMessages)],
                m_host,
                m_resource,
                ++m_msgId.QuadPart,
                (rand() % 3) + 1
                );

    if (0 > n)
    {
        ASSERT(g_messageSize != INFINITE);

        printf("The specified message size, is too small. Can't specified the UMP header\n");
        exit(-1);
    }

    Message[size-1] = '\0';
    --size;

    for (char* p = (Message + n); n > 0; p += n)
    {      
        size -= n;
        n = _snprintf(p, size, xFillBuffer);
    }

    return Message;
}




void
SendRequest(
    SOCKET s,
    LPWSTR host,
    LPWSTR resource
    )
{
    new SendOv(s, host, resource, g_nMessages);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\mappingchangehandler.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MappingChangeHandler.cpp

Abstract:
	Implementation of class CMappingChangeHandler (MappingChangeHandler.h).

	
Author:
    Gil Shafriri (gilsh) 21-Nov-00

--*/
#include <libpch.h>
#include <mqexception.h>
#include <qal.h>
#include "qalp.h"
#include "MappingChangeHandler.h"

#include "mappingchangehandler.tmh"

CMappingChangeHandler::CMappingChangeHandler(
			CQueueAlias& QueueAlias
			):
			m_QueueAlias(QueueAlias)
			{
			}


CMappingChangeHandler::~CMappingChangeHandler()
{

}




void CMappingChangeHandler::ChangeNotification() throw()
/*++

Routine Description:
	Called when the mapping directory is changed.
	The function reload the mapping from the mapping storage.

Arguments:
	None   


Returned value:
	None

--*/
{
	TrTRACE(xQal, "Queue Alias mapping is reloaded");

	//
	// Delay reload to avoid sharing violation.
	//
	Sleep(500);


	m_QueueAlias.Reload();	
}


void CMappingChangeHandler::MonitoringWin32Error(LPCWSTR pMappingDir, DWORD err)throw()
/*++

Routine Description:
	Called when win32 error accured while monitoring directory change.


Arguments:
	 err - Win32 error that happened.  
	 pMappingDir - Mapping directory path.


Returned value:
	None

Note:
	The error is reproted to the user process.
--*/
{
 	AppNotifyQalDirectoryMonitoringWin32Error(pMappingDir, err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\mappingchangehandler.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MappingChangeHandler.h

Abstract:
	Header for class CMappingChangeHandle. 	The class consume notification about queue mapping change and
	reload the mapping in that case.

	
Author:
    Gil Shafriri (gilsh) 21-Nov-00

--*/

#ifndef _MSMQ_MappingChangeHandler_H_
#define _MSMQ_MappingChangeHandler_H_


#include "IMappingChangeHandler.h"
class  CQueueAlias;
class  bad_win32_error;

class  CMappingChangeHandler : public IMappingChangeHandler
{
public:
	CMappingChangeHandler(CQueueAlias& QueueAlias);
	virtual ~CMappingChangeHandler();

	
private:
	CMappingChangeHandler(const CMappingChangeHandler&);
	CMappingChangeHandler& operator=(const CMappingChangeHandler&);

private:
	virtual void ChangeNotification() throw();
	virtual void MonitoringWin32Error(LPCWSTR pMappingDir, DWORD err) throw();
	
private:
	CQueueAlias& m_QueueAlias;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\mappingdirchangesensor.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MappingDirChangeSensor.h

Abstract:
	Header for class CMappingDirChangeSensor that monitor (in seperate thread) changes in a given directory (file change\creationdeletion +directory deletion). 
	It notify on the change using a callback interface.

Author:
    Gil Shafriri (gilsh) 21-Nov-00

--*/

#ifndef _MSMQ_MappingDirChangeSensor_H_
#define _MSMQ_MappingDirChangeSensor_H_
class  IMappingChangeHandler;


class CMappingDirChangeSensor 
{
public:
	CMappingDirChangeSensor(LPCWSTR pMappingDir, const R<IMappingChangeHandler>& NotificationHandler); 


private:
	void WaitForMappingChangeLoop();
	void WaitForMappingChange();
	void TurnOn();
	void ChangeNotification();
	static DWORD WINAPI NotificationThreadFunc(void* param);
	

private:
	CDirChangeNotificationHandle m_DirChangeNotificationHandle;

private:
	CMappingDirChangeSensor(const CMappingDirChangeSensor&);
	CMappingDirChangeSensor& operator=(const CMappingDirChangeSensor&);

private:
	AP<WCHAR> m_pMappingDir;
	R<IMappingChangeHandler> m_NotificationHandler;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\qaldebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stDebug.cpp

Abstract:
    Queue Alias debugging

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "qalp.h"

#include "qaldebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;


BOOL QalpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Validate Queue Alias state
//
void QalpAssertValid(void)
{
    ASSERT(QalpIsInitialized());
}



void QalpSetInitialized(void)
{
    LONG fstAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Socket Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fstAlreadyInitialized);
}



//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = 
{
    xQal
};

void QalpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
}




#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\qalglob.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qalglob.cpp
 
Abstract: 
    Holds some global function and data for qal.lib


Author:
    Gil Shafriri (gilsh) 22-Nov-00

Environment:
    Platform-independent.
--*/
#include <libpch.h>
#include <qal.h>
#include <mqexception.h>
#include "qalp.h"
#include "MappingChangeHandler.h"
#include "MappingDirChangeSensor.h"

#include "qalglob.tmh"

static P<CQueueAlias> s_pQueueAlias;
static P<CMappingDirChangeSensor> s_pMappingChangeSensor; 

static CMappingDirChangeSensor* CreateMappingChangeSensor(LPCWSTR pDir,CQueueAlias& QueueAlias )
{
	try
	{
		//
		// Create the monitoring object - will reload the mapping on mapping change
		// reported by 	the monitoring agent.
		//
		R<CMappingChangeHandler> MappingChangeHandler = new CMappingChangeHandler(QueueAlias);

		
		//
		// create monitoring sensor for the mapping directory 
		//
		CMappingDirChangeSensor*  pMappingChangeSensor = new CMappingDirChangeSensor(pDir, MappingChangeHandler);
		return 	pMappingChangeSensor;
	}
	catch(bad_win32_error& e)
	{
		AppNotifyQalDirectoryMonitoringWin32Error(pDir, e.error());
		return NULL;
	}
}


void   QalInitialize(LPCWSTR pDir)
/*++

Routine Description:
	Initialize the qal library - must be called  first
	befor any other function. The function creates one instance of	CQueueAlias
	object used by MSMQ.

Arguments:
	pDir - the mapping directory where xml mapping files located.


Returned value:
	None
--*/
{
	ASSERT(!QalpIsInitialized());
	QalpRegisterComponent();
	ASSERT(s_pQueueAlias.get() == NULL);
	ASSERT(s_pMappingChangeSensor.get() == NULL);
	s_pQueueAlias	 = new 	CQueueAlias(pDir);
	s_pMappingChangeSensor = CreateMappingChangeSensor(pDir, *s_pQueueAlias.get());
}


CQueueAlias& QalGetMapping(void)
/*++

Routine Description:
	return the queue mapping object


Returned value:
	Reference to  CQueueAlias object.

Note :
This function is used instead of the consructor of CQueueAlias (which is private)
to ensure that only one instance of this class will ever created.
--*/
{
	ASSERT(s_pQueueAlias.get() != NULL);
	return *(s_pQueueAlias.get());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\qalp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    qalp.h

Abstract:
	header for class CQueueAliasPersist -
	class that implements persistence of Queue\Alias mapping.
	It let the class user to persist\unpersist\enumerate Queues Aliases.

Author:
    Gil Shafriri (gilsh) 12-Apr-00

--*/



#ifndef _MSMQ_qalp_H_
#define _MSMQ_qalp_H_

#ifdef _DEBUG
void QalpRegisterComponent(void);
BOOL QalpIsInitialized(void);
#else
#define QalpRegisterComponent() ((void)0);
#define QalpIsInitialized() (TRUE);
#endif


const TraceIdEntry xQal = L"Queue Alias";



#endif // _MSMQ_qalp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\qalpcfg.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    qalpcfg.h

Abstract:
    Queue Aliase storage configuration class

Author:
    Gil Shafriri (Gilsh)

--*/



#ifndef QALPCFG_H
#define QALPCFG_H


//---------------------------------------------------------
//
// Queue Alias Storage configuration
//
//-------------------------------------------------------
class CQueueAliasStorageCfg
{
public:	
	static void SetQueueAliasDirectory(LPCWSTR pDir);
	static LPWSTR GetQueueAliasDirectory(void);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\mappingdirchangesensor.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MappingDirChangeSensor.cpp


Abstract:
	Implementation of class CMappingDirChangeSensor (DirMappingChangeSensor.h)
 

Author:
    Gil Shafriri (gilsh) 21-Nov-00

--*/
#include <libpch.h>
#include <mqexception.h>
#include "MappingDirChangeSensor.h"
#include "IMappingChangeHandler.h"
#include "qalp.h"

#include "mappingdirchangesensor.tmh"

static HANDLE CreateDirNotificationHandle(LPCWSTR pMappingDir)
/*++

Routine Description:
	Create directory notification handle. It will monitor
	files creation\deletion\modification  in the directory,
	and also directory deletion.

Arguments:
	Directory to monitor    


Returned value:
	None

--*/
{
	DWORD flags = FILE_NOTIFY_CHANGE_LAST_WRITE | 
				  FILE_NOTIFY_CHANGE_FILE_NAME;

	HANDLE h = FindFirstChangeNotification(
									pMappingDir,
									false, // no notification on sub directories
									flags
									);

	if(h == INVALID_HANDLE_VALUE)
	{
		DWORD err =  GetLastError();
		TrERROR(xQal, "FindFirstChangeNotification failed Error=%d", err);
		throw bad_win32_error(err);
	}
	return h;
}


CMappingDirChangeSensor::CMappingDirChangeSensor(
								LPCWSTR pMappingDir,
								const R<IMappingChangeHandler>& NotificationHandler
								):
								m_pMappingDir(newwcs(pMappingDir)),
								m_DirChangeNotificationHandle(CreateDirNotificationHandle(pMappingDir)),
								m_NotificationHandler(NotificationHandler)
					
{
	ASSERT(m_NotificationHandler.get() != NULL);
	TurnOn();
}


void CMappingDirChangeSensor::TurnOn()
/*++

Routine Description:
	Start thread that sense if the given directory was changed.

Arguments:
	NotificationHandler - callback object called on directory change or on error.


Returned value:
	None

Note:
	In case of error system error - bad_win32_error is thrown.  
--*/
{
	DWORD ThreadId;
	CHandle hThread = CreateThread(NULL, NULL, NotificationThreadFunc, this ,0, &ThreadId);
	if(hThread == NULL)
	{
		throw bad_win32_error(GetLastError());
	}
}



void CMappingDirChangeSensor::WaitForMappingChange()
/*++

Routine Description:
	Wait (for ever) for directory notification - return if  notification was received.

Arguments:
	None


Returned value:
	None

Note:
	In case of error system error - bad_win32_error is thrown.  
--*/
{
	//
	// Wait for directory change
	//
	DWORD status = WaitForSingleObject(m_DirChangeNotificationHandle, INFINITE);
	if(status == WAIT_FAILED)
	{
		DWORD err =  GetLastError();
		TrERROR(xQal,"WaitForSingleObject failed Error=%d", err);
		throw bad_win32_error(err);
	}

	ASSERT(status == WAIT_OBJECT_0);

	//
	// Make itself ready for the next call to this function.
	//
	bool fSuccess = FindNextChangeNotification(m_DirChangeNotificationHandle) == TRUE;
	if(!fSuccess)
	{
		DWORD err =  GetLastError();
		TrERROR(xQal, "FindNextChangeNotification failed Error=%d", err);
		throw bad_win32_error(err);
	}
}


void CMappingDirChangeSensor::ChangeNotification()
{
	try
	{
		m_NotificationHandler->ChangeNotification();
	}
	catch(const exception&)
	{
		TrERROR(xQal,"Got unknown error while reporte  mapping change");
	}
}



void CMappingDirChangeSensor::WaitForMappingChangeLoop()
/*++

Routine Description:
	Loop for ever and wait for directory chaNge notification.
	Use callback object to report the change or error.

Arguments:
	None


Returned value:
	None

--*/
{
	for(;;)
	{
		WaitForMappingChange();
		ChangeNotification();
	}
}			   


DWORD WINAPI CMappingDirChangeSensor::NotificationThreadFunc(void* param)
{
	CMappingDirChangeSensor* Me = static_cast<CMappingDirChangeSensor*>(param);
	ASSERT(Me != NULL);
	try
	{
		Me->WaitForMappingChangeLoop();
	}
	catch(const bad_win32_error& err)
	{
		LPCWSTR pMappingDir = Me->m_pMappingDir.get();
		Me->m_NotificationHandler->MonitoringWin32Error(pMappingDir, err.error());
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\qal.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qal.cpp
 
Abstract: 
    implemetation of class CQueueAlias (qal.h).


Author:
    Gil Shafriri (gilsh) 06-Apr-00

Environment:
    Platform-independent.
--*/

#include <libpch.h>
#include <Qal.h>
#include "qalp.h"
#include "qalpcfg.h"
#include "qalpxml.h"

#include "qal.tmh"

//---------------------------------------------------------
//
//  class CAutoStrMap - stl map that delete the string it contains at destruction
//
//----------------------------------------------------
class CAutoStrMap :private  std::map<LPCWSTR, LPCWSTR,CFunc_wcsicmp>
{
public:
	typedef std::map<LPCWSTR, LPCWSTR,CFunc_wcsicmp> AliasMap;
	typedef AliasMap::iterator iterator;
	typedef AliasMap::const_iterator const_iterator;
	using AliasMap::find;
	using AliasMap::end;
	using AliasMap::begin;
	using AliasMap::upper_bound;
  
public:
	~CAutoStrMap();

public:
	void Delete(const iterator& it);
	void Delete(LPCWSTR key);
	bool InsertCopy(LPCWSTR  Key, LPCWSTR  Value);
};



CAutoStrMap::~CAutoStrMap()
{
	for(;;)
	{
		iterator it = begin();
		if(it == end())
		{
			ASSERT(size() == 0);
			return;	
		}
		Delete(it);
	}
}


void CAutoStrMap::Delete(const iterator& it)
/*++

Routine Description:
	Remove item  from the map delete the key + value strings


	IN - it - iterator to item to delete

Returned value:
	None

--*/
{
	ASSERT(it != end());

	delete[] const_cast<LPWSTR>(it->first);
	delete[] const_cast<LPWSTR>(it->second);
	erase(it);  //lint !e534
}



void CAutoStrMap::Delete(LPCWSTR key)
/*++

Routine Description:
	Remove item from the map by given key. delete key + value strings

	IN -  key - key to delete.

Returned value:
	None

--*/
{
	ASSERT(key);
	iterator it = find(key);
	if(it != end())
	{
		Delete(it);	
	}
}


bool CAutoStrMap::InsertCopy(LPCWSTR  Key, LPCWSTR  Value)
/*++

Routine Description:
	copy key and value strings and insert the duplicated key/value into the map.

Arguments:
    IN - Key - key item

	IN - Value - value item.

Returned value:
	true if the key\value inserted - false if key already exists

--*/
{

	ASSERT(Key);
	ASSERT(Value);
	AP<WCHAR> DupKey = newwcs(Key);
	AP<WCHAR> DupValue = newwcs(Value);
	
	bool fSucess = insert(value_type(DupKey,DupValue)).second;
	if(fSucess)
	{
		DupKey.detach();	//lint !e534
		DupValue.detach();	//lint !e534
	}
	return fSucess;
}



//---------------------------------------------------------
//
//  class CQueueAliasImp - holds CQueueAlias private data
//
//---------------------------------------------------------
class CQueueAliasImp : public CReference
{
public:
	CQueueAliasImp(
		LPCWSTR pMappingDir
		):
		m_pStorage(pMappingDir)
	{
		LoadMaps();
	}

	bool GetQueue(LPCWSTR  pAliasFormatName, LPWSTR*  ppFormatName) const;      
	bool Create(LPCWSTR  pFormatName,LPCWSTR  pAliasFormatName);
	bool GetAlias(LPCWSTR pFormatName, LPWSTR* ppAliasFormatName )const;
	bool Delete(LPCWSTR pFormatName);
	bool 
	GetNextMapping(
			LPCWSTR  pRefAliasFormatName,
			LPWSTR* ppFormatName,
			LPWSTR* ppAliasFormatName
			)const;
	R<CQueueAliasImp> clone();
private:
	void LoadMaps();
	bool InsertToMaps(LPCWSTR  pFormatName,  LPCWSTR  pAliasFormatName);
	void RemoveFromMaps(LPCWSTR pFormatName, LPCWSTR pAliasFormatName);
	

private:  
  	CQueueAliasStorage m_pStorage;
	CAutoStrMap m_AliasToQueueMap;
	CAutoStrMap m_QueueToAliasMap;
};




R<CQueueAliasImp> CQueueAliasImp::clone()
{
	return new 	CQueueAliasImp(m_pStorage.GetMappingDir());
}


void CQueueAliasImp::LoadMaps(void)
/*++

Routine Description:
	load all mapping from xml files to memory

Arguments:
	None
				
Returned value:
	None

--*/   
{
	for(P<CQueueAliasStorage::CEnum> StorageEnum = m_pStorage.CreateEnumerator();;)
	{
	
		AP<WCHAR> pFormatName;
		AP<WCHAR> pAliasFormatName;				 

		bool fSuccess = StorageEnum->Next(&pFormatName, &pAliasFormatName);
		if(!fSuccess)
		{
			return;
		}

		ASSERT(pFormatName);		 
		ASSERT(pAliasFormatName);

		TrTRACE(xQal,"%ls -> %ls  mapping found", pAliasFormatName, pFormatName);
		fSuccess = AppNotifyQalMappingFound(pAliasFormatName.get(), pFormatName.get());
		if(!fSuccess)
		{
			TrERROR(xQal, "mapping from %ls to %ls rejected", pAliasFormatName, pFormatName	);
			continue;
		}

 		fSuccess = InsertToMaps(pFormatName, pAliasFormatName);
		if(!fSuccess)
		{
			TrERROR(xQal, "mapping from %ls to %ls ignored because of duplicate mapping", pAliasFormatName, pFormatName);
			AppNotifyQalDuplicateMappingError(pAliasFormatName, pFormatName);
   		}
		
	}
}



bool
CQueueAliasImp::Create(
	LPCWSTR  pFormatName,  
	LPCWSTR  pAliasFormatName
	)
{
	try
	{
		bool fSuccess = InsertToMaps(pAliasFormatName, pFormatName);
		if(!fSuccess)
		{
			RemoveFromMaps(pFormatName, pAliasFormatName);
			return false;
		}
	}
	catch(const exception&)
	{
		RemoveFromMaps(pFormatName,pAliasFormatName);
		throw;
	}
	return true;
}


bool 
CQueueAliasImp::Delete(
	LPCWSTR pFormatName
	)
{
	CAutoStrMap::iterator AliasMapIt = m_QueueToAliasMap.find(pFormatName);
	if(AliasMapIt == m_QueueToAliasMap.end())
	{
		return false;
	}
	CAutoStrMap::iterator QueueMapIt = m_AliasToQueueMap.find(AliasMapIt->second);

	ASSERT(QueueMapIt != m_AliasToQueueMap.end());


	//
	// remove from maps
	//
	m_QueueToAliasMap.Delete(AliasMapIt);
	m_AliasToQueueMap.Delete(QueueMapIt);
	
	return true;
}




bool
CQueueAliasImp::InsertToMaps(
	LPCWSTR  pFormatName,  
	LPCWSTR  pAliasFormatName
	)
/*++

Routine Description:
	insert new mapping into maps in memory

Arguments:
	IN -  pFormatName - Queue format name

	IN -  pAliasFormatName - alias formatname.

				
Returned value:
	true if new mapping created - false if already exsist.

--*/
{
	
	bool fSuccess =	m_AliasToQueueMap.InsertCopy(pAliasFormatName, pFormatName);
	if(!fSuccess)
	{
		TrERROR(xQal,"The alias %ls  already mapped to a queue",pAliasFormatName);
		return false;
	}
	
	//
	// If we this queue already has alias - we accept it and still return true.
	//
	fSuccess =	m_QueueToAliasMap.InsertCopy(pFormatName, pAliasFormatName);
	if(!fSuccess)
	{
		TrWARNING(xQal,"Queue mapping already exists  for queue %ls",pFormatName);
	}
	return true;
}


void CQueueAliasImp::RemoveFromMaps(LPCWSTR pFormatName,LPCWSTR pAliasFormatName)
{
	m_AliasToQueueMap.Delete(pAliasFormatName);
	m_QueueToAliasMap.Delete(pFormatName);	
}


bool
CQueueAliasImp::GetQueue(
	LPCWSTR  pAliasFormatName,  
	LPWSTR*  ppFormatName
	)const      
{
	CAutoStrMap::const_iterator it = m_AliasToQueueMap.find(pAliasFormatName);
	if(it == m_AliasToQueueMap.end())
	{
		return false;
	}
	*ppFormatName = newwcs(it->second);
	return true;
} 	


bool
CQueueAliasImp::GetAlias(
	LPCWSTR pFormatName,    
    LPWSTR* ppAliasFormatName  
  	)const       
{
	const CAutoStrMap::const_iterator it = m_QueueToAliasMap.find(pFormatName);
	if(it == m_QueueToAliasMap.end())
	{
		return false;	
	}											     
	*ppAliasFormatName = newwcs(it->second);
	return true;
} 	


bool 
CQueueAliasImp::GetNextMapping(
	LPCWSTR  pRefAliasFormatName,
	LPWSTR* ppFormatName,
	LPWSTR* ppAliasFormatName
	)const

{
	CAutoStrMap::const_iterator it;
	if(pRefAliasFormatName == NULL)
	{
		it = m_AliasToQueueMap.begin();
	}
	else
	{
		it = m_AliasToQueueMap.upper_bound(pRefAliasFormatName);		
	}

	if(it == m_AliasToQueueMap.end())
	{
		return false;
	}
	AP<WCHAR> pAliasFormatName = newwcs(it->first);
	AP<WCHAR> pFormatName  = newwcs(it->second);


	*ppAliasFormatName = pAliasFormatName.detach();
	*ppFormatName = pFormatName.detach();

	return true;
}



//---------------------------------------------------------
//
//  CQueueAlias Implementation
//
//---------------------------------------------------------
CQueueAlias::CQueueAlias(
	LPCWSTR pMappingDir
	):
	m_imp(new CQueueAliasImp(pMappingDir))

/*++

Routine Description:
	constructor - load all queues mapping into two maps :
		one that maps from queue to alias and one from alias to
		queue.

Arguments:
	None    


Returned value:
	None

--*/
{
}


CQueueAlias::~CQueueAlias()
{
}

 
bool
CQueueAlias::GetAlias(
	LPCWSTR pFormatName,    
    LPWSTR* ppAliasFormatName  
  	)const       
/*++

Routine Description:
	Get alias for given queue.

Arguments:
	IN - pFormatName - queue format name	    .

	OUT - ppAliasFormatName - receive the alias 
	for the queue after the function returns.
				
Returned value:
	true if alias was found for the queue. If not found - false is returned.

--*/
{
	ASSERT(pFormatName);
	ASSERT(ppAliasFormatName);
	CS cs(m_cs);
	return m_imp->GetAlias(pFormatName, ppAliasFormatName);
} 	


bool
CQueueAlias::GetQueue(
	LPCWSTR  pAliasFormatName,  
	LPWSTR*  ppFormatName
	)const      
/*++

Routine Description:
	Get queue for given alias

Arguments:
	IN -  pAliasFormatName - alias formatname.

	OUT - ppFormatName - receive the queue for the alias  after the function returns.
				
Returned value:
	true if queue was found for the alias. If not found - false is returned.

--*/
{
	ASSERT(pAliasFormatName);
	ASSERT(ppFormatName);
		
	CS cs(m_cs);
	return m_imp->GetQueue(pAliasFormatName, ppFormatName);
} 	


bool
CQueueAlias::Create(
	LPCWSTR  lpwsFormatName,  
	LPCWSTR  lpwcsAliasFormatName                                             
    )
/*++

Routine Description:
	Create new persistent queue\alias mapping 

Arguments:
	IN - LPCWSTR  pFormatName - queue format name

	IN - LPCWSTR  pAliasFormatName - alias format name.

				
Returned value:
	True is returned if the new mapping was added. 
	False is returned if the mapping already exist.	

--*/

{
	CS cs(m_cs);
	return m_imp->Create(lpwsFormatName, lpwcsAliasFormatName);
}


bool 
CQueueAlias::Delete(
	LPCWSTR pFormatName
	)

/*++

Routine Description:
	delete  queue mapping for given queue. 

Arguments:
	IN - LPCWSTR  pFormatName - queue formatname.

				
Returned value:
	True is returned if the the mapping was deleted.
	False is returned if the queue has no mapping.

Note :
At the moment this function is used only by the testing.
The mapping is not persit bebause our xml parser does not support
deleting information from xml document.
--*/
{
	CS cs(m_cs);
	return m_imp->Delete(pFormatName);
}


R<CQueueAliasImp> CQueueAlias::SafeGetImp()const
{
	CS cs(m_cs);
	return m_imp;
}




void CQueueAlias::Reload(void)
/*++

Routine Description:
	Clean existing mapping and reload new mapping from storage.
	Called when mapping is changed by CQalMonitor class.

Arguments:
	None
				
Returned value:
	None

Note:
 We would like to load new mapping when lock is not held -
 Therefor we take the implementation pointer(under lock)
 load new mapping when the lock  is not held , and then we replace implemmentation pointers under lock.
 --*/   
{	
	
	R<CQueueAliasImp> oldimp = SafeGetImp();
	R<CQueueAliasImp> newimp = oldimp->clone();

	//
	// now we replace the content of the mapping under lock.
	//
	CS cs(m_cs);
	m_imp = newimp;
}


bool 
CQueueAlias::GetNextMapping(
	LPCWSTR  pRefAliasFormatName,
	LPWSTR* ppFormatName,
	LPWSTR* ppAliasFormatName
	)const

/*++

Routine Description:
	Return the queue\alias mapping that it's alias name is just after a given name
	name (lexical compare).

Arguments:
	IN -  pRefAliasFormatName - reference alias.	

	OUT - ppFormatName - receive the queue formatname.

	OUT - ppAliasFormatName - receive the alias formatname.

				
Returned value:
	True if next queue\alias found - otherwise false.

--*/

{
	ASSERT(ppFormatName);
	ASSERT(ppAliasFormatName);
	
	CS cs(m_cs);
	return 	m_imp->GetNextMapping(pRefAliasFormatName, ppFormatName, ppAliasFormatName);  
}


CQueueAlias::CEnum CQueueAlias::CreateEnumerator()
/*++

Routine Description:
	create new queue\alias enumerator

Arguments:
	None	
				
Returned value:
	Pointer to enumerator - caller responsible to delete it

--*/
{
	return CQueueAlias::CEnum(this);			
}




//---------------------------------------------------------
//
//  CQueueAlias::CEnum Implementation
//
//---------------------------------------------------------

CQueueAlias::CEnum::CEnum(
	const CEnum& Enumerator
	) :
	m_QueueAlias(Enumerator.m_QueueAlias),
	m_alias(newwcs(Enumerator.m_alias))
{

}


CQueueAlias::CEnum& 
CQueueAlias::CEnum::operator=(
	const CQueueAlias::CEnum& Enumerator
	)
{
	if(this != &Enumerator)
	{
		ReplaceAlias(Enumerator.m_alias);
		m_QueueAlias = Enumerator.m_QueueAlias;
	}
	return *this;
}


CQueueAlias::CEnum::CEnum(
	const CQueueAlias* QueueAlias
	) :
	m_QueueAlias(QueueAlias),
	m_alias(NULL)
{
   
}


CQueueAlias::CEnum::~CEnum()
{
	delete[]  m_alias;
}//lint !e1740


void CQueueAlias::CEnum::Reset()
/*++

Routine Description:
	Reset enumerator to it start position.

Arguments:
	None	
				
Returned value:
	None
--*/

{
	delete[] m_alias;
	m_alias = NULL;
}



bool 
CQueueAlias::CEnum::Next(
	LPWSTR* ppFormatName,
	LPWSTR* ppAliasFormatName
	)
/*++

Routine Description:
	return next queue\alias mapping.

Arguments:
	OUT - LPWSTR* ppFormatName - receive queue formatname.
	
	OUT - LPWSTR* ppAliasFormatName - receive alias format name.	
				
Returned value:
	True if next queue\alias returned. False if end of mapping.
--*/
{
	ASSERT(ppFormatName);
	ASSERT(ppAliasFormatName);

	

	bool ret = m_QueueAlias->GetNextMapping(
									m_alias,
									ppFormatName,
									ppAliasFormatName
									);
	
	if(ret)
	{
		ReplaceAlias(*ppAliasFormatName);
	}
	return ret;
}


void CQueueAlias::CEnum::ReplaceAlias(LPCWSTR pNewAlias)
/*++

Routine Description:
	Replace the current alias that act as a reference in the enumeration
	process.

Arguments:
	IN - LPCWSTR pNewAlias - the new reference alias.
	
				
Returned value:
	None.

--*/
{	
	LPWSTR pTemp = newwcs(pNewAlias);
	delete[] m_alias;
	m_alias = pTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\qalpxml.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qal.cpp
 
Abstract: 
   Implementation of class CQueueAliasStorage (qalp.h).
   the class responsible for queue\alias mapping storage above xml files


Author:
    Gil Shafriri (gilsh) 27-Apr-00

Environment:
    Platform-independent.
--*/

#include <libpch.h>
#include <xml.h>
#include <mqexception.h>
#include <utf8.h>
#include <qal.h>
#include <strutl.h>
#include "qalpxml.h"
#include "qalp.h"

#include "qalpxml.tmh"

const LPCWSTR xMappingNameSpace = L"msmq-queue-mapping.xml";
const LPCWSTR xMappingNodeTag = L"mapping";
const LPCWSTR xQueueNodeTag = L"queue";
const LPCWSTR xNameSearchPath = L"!name";
const LPCWSTR xAliasSearchPath = L"!alias";
const BYTE xUtf8FileMark[] = {0XEF, 0XBB, 0xBF};
const BYTE xUnicodeFileMark[] = {0xFF, 0xFE};


//---------------------------------------------------------
//
//  CFileEnum helper class - class for file enumeration
//
//---------------------------------------------------

static LPWSTR  GetDir(LPCWSTR pDir)
{
	if(pDir == NULL)
	{
		return NULL;
	}
	return newwcscat(pDir,L"\\");
}


CFileEnum::CFileEnum(
		LPCWSTR pDir,
		LPCWSTR pFileName
		) :
		m_pDir(GetDir(pDir)),
		m_hSearchFile(CreateSearchHandle(m_pDir,pFileName)),
		m_end(pDir == NULL)

{
		
}



HANDLE CFileEnum::CreateSearchHandle(LPCWSTR  pDir,LPCWSTR pFileName)
/*++

Routine Description:
	Get First file ,in a given directory, that match query string . 


Arguments:
    IN - pDir - directory name to search

	IN - pFileName - File name query string to match. (for example "*.txt") 

Returned value:
	Search handle or  INVALID_HANDLE_VALUE 	search failed.

--*/

{
	ASSERT(pFileName != NULL);
	if(pDir == NULL)
	{
		return INVALID_HANDLE_VALUE;
	}

	AP<WCHAR> pFullPath =  newwcscat(pDir,pFileName);
	HANDLE  hSearchFile = FindFirstFile(pFullPath,&m_FileInfo);
	return hSearchFile;
}



LPWSTR CFileEnum::Next()
/*++

Routine Description:
	Get Next file name 


Arguments:
 None

Returned value:
	Full Filename path or NULL is no more files exists

--*/
{
	if(m_hSearchFile == INVALID_HANDLE_VALUE || m_end)
	{
		return NULL;
	}

	AP<WCHAR> FileName = newwcscat(m_pDir, m_FileInfo.cFileName);

	BOOL fSuccess = FindNextFile(m_hSearchFile,&m_FileInfo);
	if(!fSuccess)
	{
		if(GetLastError() != ERROR_NO_MORE_FILES)
		{
			TrERROR(xQal,"FindNextFile() failed for %ls with error %d",FileName,GetLastError());
			throw bad_alloc();
		}
		m_end = true;
	}
	return  FileName.detach();
}

class bad_unicode_file : public exception 
{
public:
    bad_unicode_file() :
	  exception("bad unicode file format") {}
};



//---------------------------------------------------------
//
//  static helper functions
//
//---------------------------------------------------


static void Rtrim(LPWSTR pStr)
{
	for(size_t index = wcslen(pStr);index-- != 0;)
	{
		if(!iswspace(pStr[index]))
		{
			pStr[index + 1] = L'\0';
			return;
		}
	} 
	pStr[0] =  L'\0';
}


static bool IsUtf8File(const BYTE* pBuffer, DWORD size)
/*++

Routine Description:
	Check if a given file buffer is utf8 format and not  simple ansi.

Arguments:
	IN - pBuffer - pointer to file data.
	IN - size - the size in  BYTES of the buffer pBuffer points to.

Returned value:
	true if utf8 file (starts with {0XEF, 0XBB, 0xBF} )
	
--*/
{
	ASSERT(pBuffer != NULL);
	return UtlIsStartSec(
					pBuffer,
					pBuffer + size,
					xUtf8FileMark,
					xUtf8FileMark + TABLE_SIZE(xUtf8FileMark)
					);
					
}


static bool IsUnicodeFile(const BYTE* pBuffer, DWORD size)
/*++

Routine Description:
	Check if a given file buffer is unicode file


Arguments:
	IN - pBuffer - pointer to file data.
	IN - size - the size in  BYTES of the buffer pBuffer points to.

Returned value:
	true if unicode file (starts with {0xFF, 0xFE} ) - false otherwise.
	bad_unicode_file exception is thrown if file format is invalid.
--*/
{
	ASSERT(pBuffer != NULL);

	bool fUnicodeFile = UtlIsStartSec(
								pBuffer,
								pBuffer + size,
								xUnicodeFileMark,
								xUnicodeFileMark + TABLE_SIZE(xUnicodeFileMark)
								);
					

	if(fUnicodeFile && (size % sizeof(WCHAR) != 0))
	{
		throw bad_unicode_file();
	}

	return fUnicodeFile;
}



static LPWSTR LoadFile(LPCWSTR pFileName, DWORD* pSize, DWORD* pDataStartOffset)
/*++

Routine Description:
	Load  xml file into memory and return pointer to it's memory.
	If the file is utf8 format and not unicode - convert it (in memory)
	to unicode and return pointer to it's memory.

Arguments:
	pFileName - full file path to load to memory.
	pSize - return file size in WCHARS
	pDataStartOffset - return the offset of the data start in WCHARS from file start.


Returned value:
	Pointer to NULL terminated unicode string that is the file content.

--*/


{
	CFileHandle hFile = CreateFile(
							pFileName, 
							GENERIC_READ, 
							FILE_SHARE_READ, 
							NULL,        // IpSecurityAttributes
							OPEN_EXISTING,
							NULL,      // dwFlagsAndAttributes
							NULL      // hTemplateFile
							);
    if(hFile == INVALID_HANDLE_VALUE)
	{
		DWORD err = GetLastError();
	    TrERROR(xQal,"CreateFile() failed for %ls with Error=%d",pFileName, err);
        throw bad_win32_error(err);
	}

    DWORD size = GetFileSize(hFile, NULL);
	if(size == 0xFFFFFFFF)
	{
		DWORD err = GetLastError();
		TrERROR(xQal,"GetFileSize() failed for %ls with Error=%d", pFileName, err);
		throw bad_win32_error(err);
	}
	
	AP<BYTE> pFileBuffer = new BYTE[size];
	DWORD ActualRead;
	BOOL fsuccess = ReadFile(hFile, pFileBuffer, size, &ActualRead, NULL);
	if(!fsuccess)
	{
		DWORD err = GetLastError();
		TrERROR(xQal,"Reading file %ls failed with Error=%d", pFileName, err);
		throw bad_win32_error(err);
	}
	ASSERT(ActualRead == size);

	//
	// If unicode file - just return pointer to the file data - the data itself starts
	// one UNICODE byte after the caracter 0xFEFF (mark for unicode file)
	//
	if(IsUnicodeFile(pFileBuffer.get(), size))
	{
		*pSize =  size/sizeof(WCHAR);
		*pDataStartOffset = TABLE_SIZE(xUnicodeFileMark)/sizeof(WCHAR);
		ASSERT(*pDataStartOffset == 1);
		return reinterpret_cast<WCHAR*>(pFileBuffer.detach());
	}

	//
	// If non UNICODE - then if ansy , the data starts at the file start.
	// if UTF8,  the data starts after the bytes (EF BB BF)
	//
	DWORD DataStartOffest = (DWORD)(IsUtf8File(pFileBuffer.get(), size) ? TABLE_SIZE(xUtf8FileMark) : 0);
	ASSERT(DataStartOffest <=  size);

	//
	// Assume the file is utf8 (or ansi) - convert it to unicode
	//
	size_t ActualSize;
	AP<WCHAR> pwBuffer = UtlUtf8ToWcs(pFileBuffer.get() + DataStartOffest , size - DataStartOffest,  &ActualSize);
	*pSize = numeric_cast<DWORD>(ActualSize);
	*pDataStartOffset = 0;
	return 	pwBuffer.detach();
}

static LPWSTR GetValue(	const XmlNode* pXmlNode,LPCWSTR pTag)
/*++

Routine Description:
	Get value of xml tag.

Arguments:
	IN - pXmlNode - xml node.
	IN - pTag - xml tag.


Returned value:
	Pointer to a value of a given tag or NULL if value or tag not found.

--*/

{
	const XmlNode* pQnode = XmlFindNode(pXmlNode,pTag);
	if(pQnode == NULL)
	{
		return NULL;
	}
	List<XmlValue>::iterator it = pQnode->m_values.begin();
	if(it ==  pQnode->m_values.end())
	{
		return NULL;
	}

	return it->m_value.ToStr(); 
}


//---------------------------------------------------------
//
//  CQueueAliasStorage Implementation
//
//---------------------------------------------------------
CQueueAliasStorage::CQueueAliasStorage(
	LPCWSTR pMappingDir
	):
	m_pMappingDir(newwcs(pMappingDir))
	
{
			
}


LPCWSTR CQueueAliasStorage::GetMappingDir() const
{
	return 	m_pMappingDir.get();
}




CQueueAliasStorage::CEnum* CQueueAliasStorage::CreateEnumerator()
/*++

Routine Description:
	Create enumerator of Queue\Aliase mapping

Arguments:
	None.

Returned value:
	Pointer to enumerator object.

--*/


{
	return 	new CEnum(m_pMappingDir , L"*.xml");
}




CQueueAliasStorage::CEnum::iterator*
CQueueAliasStorage::CEnum::GetNextFileQueuesMapping(
	void
	)
/*++

Routine Description:
	Return  pointer to iterator to queues mapping in the next xml file

Arguments:
		None


Returned value:
	Pointer to iterator or NULL if could more valid xml files found.

--*/

{
	AP<WCHAR>	 pDoc;
	CAutoXmlNode pTree;
	AP<WCHAR> pFileName;

	bool fSuccess = GetNextValidXmlFile(&pDoc,&pTree,&pFileName);
	if(!fSuccess)
	{
		return NULL;
	}

	const XmlNode* pNode = XmlFindNode(pTree,xMappingNodeTag);
	//
	// if we could not find "mapping" node
	// - move to next file
	//
	if(pNode == NULL)
	{
		TrERROR(
			xQal,
			"Could not find '%ls' node in file '%ls'",
			xMappingNodeTag,
			pFileName
			);

		AppNotifyQalInvalidMappingFileError(pFileName);
		return GetNextFileQueuesMapping();
	}
	
	//
	// if the "mapping" tag found but it is not in the namespace we expect
	// move to next file
	//
	if(pNode->m_namespace.m_uri != xMappingNameSpace)
	{
		TrERROR(
			xQal,
			"Node '%ls' is not in namespace '%ls' in file '%ls'",
			xMappingNodeTag,
			xMappingNameSpace,
			pFileName
			);

		AppNotifyQalInvalidMappingFileError(pFileName);
		return GetNextFileQueuesMapping();
	}
  
	return new iterator (&pNode->m_nodes,pDoc,pTree,pFileName);
}



bool CQueueAliasStorage::CEnum::GetNextValidXmlFile(LPWSTR* ppDoc,XmlNode** ppTree,LPWSTR* ppFileName)
/*++

Routine Description:
	Return  next valid xml file information.

Arguments:
		OUT - ppDoc - receive next valid xml buffer.
		OUT - ppTree - receive next valid xml tree (result of parsing).
		OUT - ppFileName - receive xml file path.


Returned value:
	True if next valid xml file was parsed successfuly or false otherwise.

--*/

{
	ASSERT(ppDoc);
	ASSERT(ppTree);

	AP<WCHAR> pFileName = m_FileEnum.Next();
	if(pFileName == NULL)
	{
		return false;
	}

  	try
	{
	    DWORD DocSize;
		DWORD DataStartOffet;
	    AP<WCHAR> pDoc = LoadFile(pFileName, &DocSize, &DataStartOffet);
		CAutoXmlNode pTree;
		XmlParseDocument(xwcs_t(pDoc + DataStartOffet, DocSize - DataStartOffet),&pTree);//lint !e534
		*ppDoc = pDoc.detach();
		*ppTree = pTree.detach();
		*ppFileName	= pFileName.detach();
		return true;
	}

  	
	catch(const bad_document& errdoc)
	{
		TrERROR(
			xQal,
			"Mapping file %ls is ignored. Failed to parse file at location=%ls",
			pFileName.get(),
			errdoc.Location()
			);

		AppNotifyQalInvalidMappingFileError(pFileName.get());
		return GetNextValidXmlFile(ppDoc, ppTree, ppFileName);	
	}


	catch(const bad_win32_error& err)
	{
		TrERROR(
			xQal,
			"Mapping file %ls is ignored. Failed to read file content, Error %d",
			pFileName.get(),
			err.error()
			);

		AppNotifyQalWin32FileError(pFileName.get(), err.error());
		return GetNextValidXmlFile(ppDoc, ppTree, ppFileName);	
	}
	

	catch(const exception&)
	{
		TrERROR(
			xQal,
			"Mapping file %ls is ignored. Unknown error",
			pFileName.get()
			);

		return GetNextValidXmlFile(ppDoc,ppTree,ppFileName);		
	}

}





CQueueAliasStorage::CEnum::CEnum(
	LPCWSTR pDir,
	LPCWSTR pFilename
	):
	 m_FileEnum(pDir,pFilename),
	 m_pIt(GetNextFileQueuesMapping())
{
	
}


CQueueAliasStorage::CEnum::~CEnum()
{
	delete m_pIt;
}


bool 
CQueueAliasStorage::CEnum::Next(
	LPWSTR* ppFormatName,
	LPWSTR* ppAliasFormatName
	)	

/*++

Routine Description:
	get next queue\alias mapping

Arguments:
	
	OUT - ppFormatName - receive the queue formatname.

	OUT - ppAliasFormatName - receive the alias formatname.
	   


Returned value:
	True if queue\alias mapping found - otherwise false.
	

--*/

{
	ASSERT(ppFormatName != NULL);
	ASSERT(ppAliasFormatName != NULL);

	if(m_pIt == NULL)
	{
		return false;				
	}
	
	//
	// if end of mapping in this file - move to next one
	//
	if(m_pIt->IsEnd())
	{
		MoveNextFile();		
		return Next(ppFormatName,ppAliasFormatName);
	}


	AP<WCHAR> pFormatName = GetValue(**m_pIt,xNameSearchPath);
	AP<WCHAR> pAliasFormatName = GetValue(**m_pIt,xAliasSearchPath);

	//
	// move to next mapping in the same xml file
	//
	MoveNext();


	if(pFormatName == NULL || pAliasFormatName == NULL)
	{
		TrERROR(xQal, "Invalid Queues Mapping in file '%ls'", m_pIt->GetFileName());
		AppNotifyQalInvalidMappingFileError(m_pIt->GetFileName());
		return Next(ppFormatName,ppAliasFormatName);
	}
	Rtrim(pFormatName);
	Rtrim(pAliasFormatName);

	  
	*ppFormatName = pFormatName.detach();
	*ppAliasFormatName = pAliasFormatName.detach();
 
	return true;
}



void CQueueAliasStorage::CEnum::MoveNextFile()
/*++

Routine Description:
	Move the state of the object to point to  queue\aliase mapping in the next valid xml file.

Arguments:
	None


Returned value:
	None

Note : If no valid xml file could be found - m_pIt member set to NULL.
	

--*/

{
	delete m_pIt;
	m_pIt = NULL;
	m_pIt = GetNextFileQueuesMapping();	
}


void CQueueAliasStorage::CEnum::MoveNext()
/*++

Routine Description:
	Move the state of the object to point to  next queue\aliase mapping in the current file.

Arguments:
	None


Returned value:
	None

Note : If no valid xml file could be found - m_pIt member set to NULL.
	

--*/

{
	ASSERT(m_pIt != NULL);
	ASSERT(!m_pIt->IsEnd() );

	m_pIt->Next();//LINT !e534 

	if(m_pIt == NULL || m_pIt->IsEnd())
	{
		return;
	}


	//
	// if the "queue" tag not found under "mapping" tag
	// move to next tag
	//
	if((**m_pIt)->m_tag != xQueueNodeTag)
	{
		TrERROR(
			xQal,
			"Mapping node is expected to have tag '%ls' in file '%ls'",
			xQueueNodeTag,
			m_pIt->GetFileName()
			);

		AppNotifyQalInvalidMappingFileError(m_pIt->GetFileName());
		MoveNext(); 
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\test\qalcfg.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qal.cpp
 
Abstract: 
   test simulation of class CQueueAliasCfg (qal.h).
 


Author:
    Gil Shafriri (gilsh) 5-May-00

Environment:
    Platform-independent.
--*/

#include <libpch.h>
#include <tr.h>
#include <qal.h>
#include "qalpxml.h"
#include "qalpcfg.h"

#include "QalCfg.tmh"

void CQueueAliasStorageCfg::SetQueueAliasDirectory(LPCWSTR /*pDir*/)
{

};

LPWSTR CQueueAliasStorageCfg::GetQueueAliasDirectory(void)
{
	static int fail=0;
	fail++;
	if( (fail % 10) == 0)
	{
		return NULL;
	}
	WCHAR froot[MAX_PATH];
	DWORD ret = GetEnvironmentVariable(L"froot",froot,MAX_PATH);
	ASSERT(ret != 0);
	UNREFERENCED_PARAMETER(ret);

	std::wstring  path = std::wstring(froot) + L"\\src\\lib\\qal\\test";
	return newwcs (path.c_str());

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\lib\qalpxml.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    qalp.h

Abstract:
	header for class CQueueAliasPersist -
	class that implements persistence of Queue\Alias mapping.
	It let the class user to persist\unpersist\enumerate Queues Aliases.
	The current implementation of the mapping is by xml files.

Author:
    Gil Shafriri (gilsh) 12-Apr-00

--*/



#ifndef _MSMQ_qalpxml_H_
#define _MSMQ_qalpxml_H_

#include <list.h>
#include <xml.h>


//---------------------------------------------------------
//
// File Enumeration
//
//---------------------------------------------------------

class  CFileEnum
{
public:
	CFileEnum(LPCWSTR pDir,LPCWSTR pFileName);
	LPWSTR Next(void);

private:
	HANDLE CreateSearchHandle(LPCWSTR  pDir,LPCWSTR pFileName);



private:
	WIN32_FIND_DATA  m_FileInfo;
	AP<WCHAR> m_pDir;
	CSearchFileHandle m_hSearchFile;
	bool m_end;


private:
	CFileEnum(const CFileEnum&);   // not implemented
	CFileEnum& operator=(const CFileEnum&);   // not implemented
};




//---------------------------------------------------------
//
// Queue Alias Storage
//
//---------------------------------------------------------


class  CQueueAliasStorage 
{
public:
	CQueueAliasStorage(LPCWSTR pMappingDir);


public:
	class CEnum
	{
	public:
		bool Next(LPWSTR* ppFormatName,LPWSTR* ppAliasFormatName);
		~CEnum();
		friend 	CQueueAliasStorage;

	public:
		class iterator
		{

		public:
			iterator(
				const List<XmlNode>* node,
				AP<WCHAR>& pDoc,
				CAutoXmlNode& XmlTree,
				AP<WCHAR>& pFileName
				):
				m_node(node),
				m_it(node->begin()),
				m_pDoc(pDoc.detach()),
				m_XmlTree(XmlTree.detach()),
				m_pFileName(pFileName.detach())
			{
			}	


		public:
			bool	IsEnd() const
			{
				return	 m_node->end() == m_it;
			}


			void Next()
			{
				ASSERT(!IsEnd());
				++m_it;
			}

			LPCWSTR GetFileName()const 
			{
				return m_pFileName;
			}

			const XmlNode* operator*()
			{
				ASSERT(!IsEnd());
				return &*m_it;
			}

	
		private:
			 iterator(const iterator&);// not implemented
			 iterator& operator=(const iterator&); //not implemented

		private:
			const List<XmlNode>* m_node;
			List<XmlNode>::iterator m_it;
			AP<WCHAR> m_pDoc;
			CAutoXmlNode m_XmlTree;
			AP<WCHAR> m_pFileName;
		};
		
	
	private:
		CEnum(const CEnum&);		   // not implemented
		CEnum& operator=(const CEnum&);//not implemented
	
	private:
		CEnum(LPCWSTR pDir,LPCWSTR pFileName);
		iterator*  GetNextFileQueuesMapping();
		bool  GetNextValidXmlFile(LPWSTR* ppDoc,XmlNode** ppTree,LPWSTR* ppFileName);
		void  MoveNext();
		void  MoveNextFile();


	private:
		CFileEnum m_FileEnum; 
		iterator* m_pIt;
	};


	CEnum*  CreateEnumerator();
	LPCWSTR GetMappingDir() const;

private:
	AP<WCHAR> m_pMappingDir;

private:
	CQueueAliasStorage(const CQueueAliasStorage&);		// not implemented 
	CQueueAliasStorage& operator=(const CQueueAliasStorage&); // not implemented
};




#endif // _MSMQ_qalpxml_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\qal\test\qaltest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    QalTest.cpp

Abstract:
    Queues Alias library test

Author:
    Gil Shafriri (gilsh) 06-Apr-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <stdio.h>
#include <tr.h>
#include <xml.h>
#include <Qal.h>
#include "qalpxml.h"
#include "qalpcfg.h"

#include "QalTest.tmh"


const TraceIdEntry QalTest = L"Queues Alias Test";
static bool TestInit();
static LPWSTR GenerateQueueName();
static LPWSTR GenerateAliasName();
static void Usage();
static int RunTest();
static void DeleteAll(CQueueAlias&);
static void CreateNew(CQueueAlias&);
static void PrintAll(CQueueAlias&);

extern "C" 
int 
__cdecl 
_tmain(
    int argc,
    LPCTSTR* argv
    )
/*++

Routine Description:
    Test Queues Alias library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	if(argc == 2  && (wcscmp(argv[1],L"/?") ==0 || wcscmp(argv[1],L"\?") ==0)  )
	{
		Usage();
		return 1;
	}

	if(!TestInit())
	{
		TrTRACE(QalTest, "Could not initialize test");
		return 1;
	}


	int count;
	int ret=0;
	if(argc == 2  && wcscmp(argv[1],L"-l") ==0)
	{
		count = 10000000;
	}
	else
	{
		count=3;
	}

	for(int i=0;i<count;i++)
	{
			ret=RunTest();
	}

    WPP_CLEANUP();
    return ret;
} 

static
int
RunTest()
{
	CQueueAlias Alias(NULL); 
	try
	{	
		LPCWSTR pDir = CQueueAliasStorageCfg::GetQueueAliasDirectory();
		CQueueAlias QueueAlias(pDir); 
		DeleteAll(QueueAlias);
		CreateNew(QueueAlias);
		PrintAll(QueueAlias);
		QueueAlias.Reload();
		DeleteAll(QueueAlias);
		QueueAlias.Reload();
		AP<WCHAR> pQueueName;
		bool fSuccess = QueueAlias.GetQueue(L"NOEXISTS ALIAS NAME", &pQueueName);
		ASSERT(!fSuccess);
		DBG_USED(fSuccess);
	}
	catch(const exception&)
	{
		TrTRACE(QalTest, "Got c++ exception");
	}
	TrTRACE(QalTest, "Test ok");
	return 0;
}

static
bool
TestInit()
{
	TrInitialize();
	XmlInitialize();
	return true;	
}

static LPWSTR GenerateQueueName()
{
	static int count=0;
	count++;
	
	WCHAR* QueueName = new WCHAR[100];
	swprintf(QueueName,L"QueueName%d",count);
	return QueueName;
}


static LPWSTR GenerateAliasName()
{
	static int count=0;
	count++;
	WCHAR* AliasName;
	AliasName= new WCHAR[100];
	swprintf(AliasName,L"Alias%d",count);

	return AliasName;
}

static void Usage()
{
	wprintf(L"qaltest [/l] \n");
	wprintf(L"-l : run forever (leak test) \n");
}


static void	CreateNew(CQueueAlias& QueueAlias)
{
	TrTRACE(QalTest, "Creating 1000 new  aliases");
	for(int i=0;i<1000;i++)
	{
		AP<WCHAR> queue = GenerateQueueName();
		AP<WCHAR> alias = GenerateAliasName();
		bool fSuccess =QueueAlias.Create(queue,alias);	
		ASSERT(fSuccess);
		UNREFERENCED_PARAMETER(fSuccess);
	
	}
}

static void DeleteAll(CQueueAlias& QueueAlias)
{
	TrTRACE(QalTest, "Deleting all  aliases");
	CQueueAlias::CEnum Enumerator=QueueAlias.CreateEnumerator();

	for(;;)
	{
		AP<WCHAR> pQueue;
		AP<WCHAR> pAlias;
		bool fEnd=Enumerator.Next(&pQueue,&pAlias);
		if(!fEnd)
		{
			break;
		}	
		bool fSuccess=QueueAlias.Delete(pQueue);
		ASSERT(fSuccess);
		UNREFERENCED_PARAMETER(fSuccess);

	}
}

static void PrintAll(CQueueAlias& QueueAlias)
{
	TrTRACE(QalTest,"Printing all aliases");

	CQueueAlias::CEnum Enumerator=QueueAlias.CreateEnumerator();
	for(;;)
	{
		AP<WCHAR> pQueue;
		AP<WCHAR> pAlias;
		bool fEnd=Enumerator.Next(&pQueue,&pAlias);
		if(!fEnd)
		{
			break;
		}	
		AP<WCHAR> TestQueue;
		AP<WCHAR> TestAlias; 
		
		bool fSuccess=QueueAlias.GetQueue(pAlias,&TestQueue);
		ASSERT(fSuccess);
		ASSERT(wcscmp(TestQueue,pQueue) == 0);

		fSuccess=QueueAlias.GetAlias(pQueue,&TestAlias);
		ASSERT(fSuccess);
		ASSERT(wcscmp(TestAlias,pAlias) == 0);

		TrTRACE(QalTest, "'%ls' = '%ls'", pQueue, pAlias);
  	}
}

//
// Error reporting function that needs to implement by qal.lib user
//
void AppNotifyQalDuplicateMappingError(LPCWSTR, LPCWSTR) throw()
{

}

void AppNotifyQalInvalidMappingFileError(LPCWSTR ) throw()
{

}

void AppNotifyQalXmlParserError(LPCWSTR )throw()
{

}


void AppNotifyQalWin32FileError(LPCWSTR , DWORD )throw()
{

}


bool AppNotifyQalMappingFound(LPWSTR, LPWSTR)throw()
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdad.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    RdAd.cpp

Abstract:
    Retreive information from AD

Author:
    Uri Habusha (urih), 10-Apr-2000

--*/

#include <libpch.h>
#include <mqexception.h>
#include "rd.h"
#include "rdp.h"
#include "rdds.h"
#include "rdad.h"
#include "mqtypes.h"
#include "ad.h"
#include "mqprops.h"

#include "rdad.tmh"

static 
void
CleanVars(
    DWORD num,
    MQPROPVARIANT * pVar
    )
/*++

  Routine Description:
    The routine cleans up allocated values in variants

  Arguments:
    num - number of variants to clena
    pVar - pointer to vars

  Returned Value:
    none 
    

 --*/
{
    for (DWORD i = 0; i < num; i++, pVar++)
    {
        switch (pVar->vt)
        {
            case VT_CLSID:
                delete pVar->puuid;
				pVar->vt = VT_NULL;
                break;

            case VT_LPWSTR:
                delete []pVar->pwszVal;
				pVar->vt = VT_NULL;
                break;
            
			case (VT_VECTOR | VT_CLSID):
                delete[] pVar->cauuid.pElems;
				pVar->vt = VT_NULL;
                break;
            
			default:
                break;
        }
    }
}


void
RdpGetMachineData(
    const GUID& id, 
    CACLSID& siteIds,
    CACLSID& outFrss,
    CACLSID& inFrss,
    LPWSTR* pName,
    bool* pfFrs,
    bool* pfForeign
    )
/*++

  Routine Description:
    The routine retrieves the requested machine values from AD

  Arguments:

  Returned Value:
    none 
    
 --*/
{
    PROPID prop[] = {
			PROPID_QM_SITE_IDS,
			PROPID_QM_OUTFRS,
			PROPID_QM_INFRS,
			PROPID_QM_PATHNAME,
			PROPID_QM_SERVICE_ROUTING,
			PROPID_QM_FOREIGN,
			};
		             
    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    HRESULT hr;
    hr = ADGetObjectPropertiesGuid(
                eMACHINE,
                NULL,   // pwcsDomainController,
				false,	// fServerName
                &id,
                TABLE_SIZE(prop),
                prop,
                var
                );

    if (FAILED(hr))
    {
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
        throw bad_ds_result(hr);
    }
    //
    //  Fill in the results
    //
    ASSERT(prop[0] == PROPID_QM_SITE_IDS);
    siteIds = var[0].cauuid;

    ASSERT(prop[1] == PROPID_QM_OUTFRS);
    outFrss = var[1].cauuid;
    
	ASSERT(prop[2] == PROPID_QM_INFRS);
    inFrss = var[2].cauuid;
    
	ASSERT(prop[3] == PROPID_QM_PATHNAME);
    *pName = var[3].pwszVal;
    
	ASSERT(prop[4] ==  PROPID_QM_SERVICE_ROUTING);
    *pfFrs = (var[4].bVal > 0) ? true : false;
    
	ASSERT(prop[5] == PROPID_QM_FOREIGN);
    *pfForeign = (var[5].bVal > 0) ? true : false;
}


void
RdpGetSiteData(
    const GUID& id, 
    bool* pfForeign,
    LPWSTR* pName
    )
/*++

  Routine Description:
    The routine retrieves the requested site values from AD

  Arguments:

  Returned Value:
    none 
    
 --*/
{
    PROPID prop[] = {
                PROPID_S_FOREIGN,
                PROPID_S_PATHNAME
                };

    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    HRESULT hr;
    hr = ADGetObjectPropertiesGuid(
                eSITE,
                NULL,   // pwcsDomainController,
				false,	// fServerName
                &id,
                TABLE_SIZE(prop),
                prop,
                var
                );
    if (FAILED(hr))
    {
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
        throw bad_ds_result(hr);
    }
    //
    //  Fill in the results
    //
    ASSERT(prop[0] == PROPID_S_FOREIGN);
    *pfForeign = (var[0].bVal > 0) ? true : false;

    ASSERT(prop[1] == PROPID_S_PATHNAME);
    *pName = var[1].pwszVal;
}


void 
RdpGetSiteLinks(
    SITELINKS& siteLinks
    )
/*++

  Routine Description:
    The routine query all routing links from AD

  Arguments:

  Returned Value:
    none 
    
 --*/
{
    //
    //  Query for all sites link
    //
    PROPID prop[] ={ 
			PROPID_L_GATES,
		    PROPID_L_NEIGHBOR1,
			PROPID_L_NEIGHBOR2,
			PROPID_L_COST
			};
	
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;
    hr = ADQueryAllLinks(
                NULL,       //  pwcsDomainController,
				false,		// fServerName
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        throw bad_ds_result(hr);
    }

    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    DWORD num = TABLE_SIZE(prop);

	try
	{
		while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
		{
			if ( num == 0)
			{
				//
				// no more results
				//
				break;
			}

			R<const CSiteLink> pSiteLink = new CSiteLink(
										var[0].cauuid,
										var[1].puuid,
										var[2].puuid,
										var[3].ulVal
										);

			siteLinks.push_back(pSiteLink);  
            
			for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
            {
                var[i].vt = VT_NULL;
            }
		}

		if (FAILED(hr))
		{
			siteLinks.erase(siteLinks.begin(), siteLinks.end());
			CleanVars(
				TABLE_SIZE(prop),
				var
				);
			throw bad_ds_result(hr);
		}

	}
	catch( const exception&)
	{
		siteLinks.erase(siteLinks.begin(), siteLinks.end());
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
		throw; 
	}
}


void 
RdpGetSites(
    SITESINFO& sites
    )
{
    //
    // query all sites
    //
    PROPID prop[] = {PROPID_S_SITEID}; 
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;
    hr =  ADQueryAllSites(
                NULL,       //pwcsDomainController
				false,		// fServerName
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        throw bad_ds_result(hr);
    }

    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)] = {{VT_NULL,0,0,0,0}};
    DWORD num = TABLE_SIZE(prop);

    try
    {
        while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
        {
            if ( num == 0)
            {
                break;
            }

			P<GUID> pClean = var[0].puuid;
            CSite * pSite = new CSite(*var[0].puuid);

            sites[&pSite->GetId()] = pSite;
            for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
            {
                var[i].vt = VT_NULL;
            }
        }

		if (FAILED(hr))
		{
			for (SITESINFO::iterator it = sites.begin(); it != sites.end(); )
			{
				delete it->second;
				it = sites.erase(it);
			}
			throw bad_ds_result(hr);
		}
    }
	catch( const exception&)
	{    
		for (SITESINFO::iterator it = sites.begin(); it != sites.end(); )
		{
			delete it->second;
			it = sites.erase(it);
		}
		throw; 
	}
}


void
RdpGetSiteFrs(
    const GUID& siteId,
    GUID2MACHINE& listOfFrs
    )
{

    //
    //  Query for all sites link
    //
    PROPID prop[] ={ PROPID_QM_MACHINE_ID,PROPID_QM_SITE_IDS,PROPID_QM_OUTFRS,
                     PROPID_QM_INFRS,PROPID_QM_PATHNAME,PROPID_QM_SERVICE_ROUTING,
                     PROPID_QM_FOREIGN}; 
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;
    hr = ADQuerySiteServers(
                NULL,       //  pwcsDomainController,
				false,		// fServerName
                &siteId,
                eRouter,
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        throw bad_ds_result(hr);
    }
    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    DWORD num = TABLE_SIZE(prop);

    try
    {
        while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
        {
            if ( num == 0)
            {
                //
                // no more results
                //
                break;
            }
            
			R<CMachine> pMachine = new CMachine(
                    *var[0].puuid,  // qm-id
                    var[1].cauuid,  // site ids
                    var[2].cauuid,  // out rs
                    var[3].cauuid,  // in rs
                    var[4].pwszVal, // pathname
                    (var[5].bVal > 0) ? true : false, // routing server
                    (var[6].bVal > 0) ? true : false  // foreign
                    );

            listOfFrs[&pMachine->GetId()] = pMachine;
            
			for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
            {
                var[i].vt = VT_NULL;
            }
			delete var[0].puuid;
        }

		if (FAILED(hr))
		{
			listOfFrs.erase(listOfFrs.begin(), listOfFrs.end());
			CleanVars(
				TABLE_SIZE(prop),
				var
				);
			throw bad_ds_result(hr);
		}
    }
	catch( const exception&)
	{   
		listOfFrs.erase(listOfFrs.begin(), listOfFrs.end());
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
		throw; 
	}
}


void
RdpGetConnectors(
    const GUID& site,
    CACLSID& connectorIds
    )
{
    connectorIds.cElems = 0;
    connectorIds.pElems = NULL;
    //
    // query all connecoter of the specified class
    //
    PROPID prop[] = {PROPID_QM_MACHINE_ID}; 
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;

    hr =  ADQueryConnectors(
                NULL,       //pwcsDomainController
				false,		// fServerName
                &site,
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        throw bad_ds_result(hr);
    }

    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)] ={{VT_NULL,0,0,0,0}};
    DWORD num = TABLE_SIZE(prop);

    const x_numAllocate = 10;
    DWORD numAllocated = x_numAllocate;
    AP<GUID> pResults = new GUID[x_numAllocate];
    DWORD next = 0;

    while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
    {
        if ( num == 0)
        {
            break;
        }

        P<GUID> pClean = var[0].puuid;
        
		//
        //  add one more result
        //
        if ( next == numAllocated)
        {
            //
            //  allocate more
            //
            AP<GUID> pTemp = pResults.detach();
            DWORD numPrevAllocated = numAllocated;
            numAllocated = numAllocated + x_numAllocate;
            *&pResults = new GUID[ numAllocated];
            memcpy(pResults, pTemp, numPrevAllocated * sizeof(GUID));

        }
        
		pResults[next] = *var[0].puuid;
        next++;
        for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
        {
            var[i].vt = VT_NULL;
        }

    }
    if (FAILED(hr))
    {
        throw bad_ds_result(hr);
    }

    connectorIds.pElems = pResults.detach();
    connectorIds.cElems = next;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rd.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    Rd.cpp

Abstract:
    Routing Decision Interface

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Rd.h"
#include "Rdp.h"
#include "RdDs.h"
#include "RdDesc.h"

#include "rd.tmh"

static CRoutingDecision* s_pRouteDecision;


VOID
RdRefresh(
    VOID
    )
{
    RdpAssertValid();

    s_pRouteDecision->Refresh();
}


VOID
RdGetRoutingTable(
    const GUID& DstMachineId,
    CRouteTable& RoutingTable
    )
{
    RdpAssertValid();

    s_pRouteDecision->GetRouteTable(DstMachineId, RoutingTable);

    //
    // Cleanup 
    //
    CRouteTable::RoutingInfo* pFirstPriority = RoutingTable.GetNextHopFirstPriority();
    CRouteTable::RoutingInfo* pSecondPriority = RoutingTable.GetNextHopSecondPriority();

    for(CRouteTable::RoutingInfo::const_iterator it = pFirstPriority->begin(); it != pFirstPriority->end(); ++it)
    {
        CRouteTable::RoutingInfo::iterator it2 = pSecondPriority->find(*it);
        if (it2 != pSecondPriority->end())
        {
            pSecondPriority->erase(it2);
        }
    }
}


void
RdGetConnector(
    const GUID& foreignId,
    GUID& connectorId
    )
{
    RdpAssertValid();

    return s_pRouteDecision->GetConnector(foreignId, connectorId);
}


void 
RdpInitRouteDecision (
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    )
{
    ASSERT(s_pRouteDecision == NULL);

    if (fRoutingServer)
    {
        s_pRouteDecision = new CServerDecision(rebuildInterval);
        return;
    }

    s_pRouteDecision = new CClientDecision(rebuildInterval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdad.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
  rdad.h

Abstract:
    Interface routine to AD

Author:
    Uri Habusha (urih), 10-Apr-2000

--*/

#pragma once

#ifndef __RDAD_H__
#define __RDAD_H__

void
RdpGetMachineData(
    const GUID& id, 
    CACLSID& siteIds,
    CACLSID& outFrss,
    CACLSID& inFrss,
    LPWSTR* pName,
    bool* pfFrs,
    bool* pfForeign
    );


void
RdpGetSiteData(
    const GUID& id, 
    bool* pfForeign,
    LPWSTR* pName
    );


void 
RdpGetSiteLinks(
    SITELINKS& siteLinks
    );


void 
RdpGetSites(
    SITESINFO& sites
    );


void
RdpGetSiteFrs(
    const GUID& siteId,
    GUID2MACHINE& listOfFrs
    );


void
RdpGetConnectors(
    const GUID& site,
    CACLSID& connectorIds
    );


//
// BUGBUG: Temporary, until we get Mc into the build. urih 30-Apr-2000
//
const GUID&
McGetMachineID(
    void
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rddesc.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    rddecs.cpp

Abstract:
    Implementation of Routing Decision.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "Rd.h"
#include "Cm.h"
#include "Rdp.h"          
#include "RdDs.h"
#include "RdDesc.h"
#include "RdAd.h"

#include "rddesc.tmh"

using namespace std;

bool CRoutingDecision::NeedRebuild(void) const
{
    return ((ExGetCurrentTime() - m_lastBuiltAt) >= m_rebuildInterval);
}


void 
CRoutingDecision::CleanupInformation(
    void
    )
/*++

  Routine Description:
    cleans up the internal data structure.

  Arguments:
    None.

  Returned Value:
    None. 

 --*/
{
    m_cachedMachines.erase(m_cachedMachines.begin(), m_cachedMachines.end());

    for (SITESINFO::iterator it1 = m_mySites.begin(); it1 != m_mySites.end();)
    {
        delete it1->second;
        it1 = m_mySites.erase(it1);
    }

    UpdateBuildTime(0);
}


void
CRoutingDecision::GetMyMachineInformation(
    void
    )
/*++

  Routine Description:
    Featch machine information from AD. If the Machine has out FRS, this is the 
    only possible routing and no more information is required. Otherwise, featch
    the site information.

  Arguments:
    None.

  Returned Value:
    None. An exception is raised if the operation fails

 --*/
{
    //
    // Get Machine information. Machine name, machine ID, Machine In/Out FRSs
    //
    m_pMyMachine->Update(McGetMachineID());

    //
    // Although the machine has out FRS, MSMQ needs to featch the site information, in
    // order to check that the OUT FRSs are valid (belong to machine sites)
    //

    //
    // Get my sites and the site gates
    //
    const CACLSID& SiteIds = m_pMyMachine->GetSiteIds();
    for (DWORD i = 0 ; i < SiteIds.cElems; ++i)
    {
        CSite* pSiteInfo = new CSite(SiteIds.pElems[i]);
        m_mySites[&pSiteInfo->GetId()] = pSiteInfo;
    }
}


R<const CMachine>
CRoutingDecision::GetMachineInfo(
    const GUID& id
    )
/*++

  Routine Description:
    The routine returns machine information for specific machine id. The routine 
    first looks if the information for the required machine already featched from
    the AD. The infomation can be cached either in the FRS machines list or in the 
    chached Data-Structure. If the data wasn't found the routine featch the data
    from AD and stores it in internal cache before returning the data. 

  Arguments:
    id - machine identification

  Returned Value:
    pointer to CMachine for the required machine. 
    
  Note:
    An exception is raised if the operation fails

 --*/
{
    //
    // Look for the machine in Local cache
    //
    {
        CSR lock(m_csCache);

        GUID2MACHINE::iterator it = m_cachedMachines.find(&id);
        if (it != m_cachedMachines.end())
            return it->second;
    }


    //
    // Look for the machine in Site FRS. This information is retreive in any case
    // so look first on it
    //
    for (SITESINFO::iterator its = m_mySites.begin(); its != m_mySites.end(); ++its)
    {
        const CSite* pSite = its->second;

        const GUID2MACHINE& MySiteFrsMachines = pSite->GetSiteFRS();

        GUID2MACHINE::const_iterator it = MySiteFrsMachines.find(&id);
        if (it != MySiteFrsMachines.end())
            return it->second;
    }

    R<CMachine> pRoute = new CMachine();
    pRoute->Update(id);

    {
        CSW loc(m_csCache);
        TrTRACE(Rd, "Add Machine %ls to the Routing Decision cache", pRoute->GetName());
    
        pair<GUID2MACHINE::iterator, bool> p;
        p = m_cachedMachines.insert(GUID2MACHINE::value_type(&pRoute->GetId(), pRoute));

        if (!p.second)
        {
            //
            // The machine already added between the checking and the insertion
            //
            return p.first->second;
        }
    }

    return pRoute;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RdInit.cpp

Abstract:
    Routing Decision initialization

Author:
    Uri Habusha (urih) 10-Apr-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Rd.h"
#include "Rdp.h"

#include "rdinit.tmh"

VOID
RdInitialize(
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    )
/*++

Routine Description:
    Initializes Routing Decision library

Arguments:
    fRoutingServer - boolean flag. Indicates if local machine is Routing server or not
    rebuildInterval - Indicates how often to rebuild the internal data structure

Returned Value:
    None.

--*/
{
    //
    // Validate that the Routing Decision library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!RdpIsInitialized());
    RdpRegisterComponent();

    //
    // Create Route descision Object
    //
    RdpInitRouteDecision(fRoutingServer, rebuildInterval);


    RdpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdclient.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    rdClient.cpp

Abstract:
    Implementation of Independent client Routing Decision.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "Rd.h"
#include "Rdp.h"          
#include "RdDs.h"
#include "RdDesc.h"
#include "RdAd.h"

#include "rdclient.tmh"

void
CClientDecision::Refresh(
    void
    )
/*++

  Routine Description:
    Refreshes the routine decision internal data structure.

    The routine frees the previous data, and access the DS to get updated data.
    The routine retreives information for the local machine. If data retreival
    succeedes the routine updates the build time.

    If updating the internal data failed, the routine raise an exception.

  
  Arguments:
    None.
    
  Returned Value:
    None. An exception is raised if the operation fails

  Note:
    Brfore the routine refreshes the internal data it erases the previous data and
    sets the last build time varaible to 0. If an exception is raised during retrieving 
    the data from AD or building the internal DS, the routine doesn't update the 
    last build time. This gurantee that next time the Routing Decision is called 
    the previous Data structures will be cleaned-up and rebuilt.
 --*/
{
    CSW lock(m_cs);

    TrTRACE(Rd, "Refresh Routing Decision internal data");

    //
    // Cleanup previous information
    //
    CleanupInformation();

    //
    // Get local machine information
    //
    GetMyMachineInformation();

    //
    // check that In/Out FRSs realy belong to this machine sites
    //
    m_pMyMachine->RemoveInvalidInOutFrs(m_mySites);

    //
    // Update last refresh time
    //
    CRoutingDecision::Refresh();
}



void 
CClientDecision::RouteToFrs(
    const CSite& site,
    const CRouteTable::RoutingInfo* pPrevRouteList,
    CRouteTable::RoutingInfo* pRouteList
    )
{
    //
    // If the machine is independent client. Also route to Any FRS in 
    // the site this is the second priority
    //
    const GUID2MACHINE& SiteFrss = site.GetSiteFRS();
    for(GUID2MACHINE::const_iterator it = SiteFrss.begin(); it != SiteFrss.end(); ++it)
    {
        const CMachine* pRoute = it->second.get();

        //
        // If the destination is also RS we already route to it directly
        //
        if (RdpIsMachineAlreadyUsed(pPrevRouteList, pRoute->GetId()))
        {
            continue;
        }

        pRouteList->insert(SafeAddRef(pRoute));
    }
}


void
CClientDecision::RouteToInFrs(
    CRouteTable& RouteTable,
    const CMachine* pDest
    )
{
    TrTRACE(Rd, "The Destination: %ls has IN FRSs. route to one of them", pDest->GetName());

    //
    // The destination computer must have IN FRSs
    //
    ASSERT(pDest->HasInFRS());

    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
    CRouteTable::RoutingInfo interSite;

    //
    // The destination machine has InFrs. Deliver the message to InFrs Machines
    // 
    const GUID* InFrsArray = pDest->GetAllInFRS();
    for (DWORD i = 0; i < pDest->GetNoOfInFRS(); ++i)
    {
        R<const CMachine> pRoute = GetMachineInfo(InFrsArray[i]);
        
        //
        // check that In-FRS is valid FRS in destiantion machine SITES
        //
        if (RdpIsCommonGuid(pDest->GetSiteIds(), pRoute->GetSiteIds()))
        {
            //
            // The next hop is one of the valid IN-FRS. 
            // 
            if (RdpIsCommonGuid(m_pMyMachine->GetSiteIds(),pRoute->GetSiteIds()))
            {
                //
                // In first priority try to forward the message to IN-FRS in my
                // site.
                //
                pFirstPriority->insert(pRoute);
            }
            else
            {
                //
                // In-FRS and my machine are not in same site. 
                //
                interSite.insert(pRoute);
            }
        }
    }

    if (pFirstPriority->empty())
    {
        for(CRouteTable::RoutingInfo::const_iterator it = interSite.begin(); it != interSite.end(); ++it)
        {
           pFirstPriority->insert(*it);
        }
    }
}


void 
CClientDecision::RouteToMySitesFrs(
    CRouteTable::RoutingInfo* pRouteList
    )
{
    TrTRACE(Rd, "The destination and my machine don't have a common site. Route to my sites RS");

    ASSERT(pRouteList->empty());

    //
    // The source and destination don't have common site. route to FRSs of the source sites
    //
    for(SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        const CSite* pSite = it->second;
        RouteToFrs(*pSite, NULL, pRouteList);
    }
}


void
CClientDecision::Route(
    CRouteTable& RouteTable, 
    const CMachine* pDest
    )
{
    TrTRACE(Rd, "Building Routing table. Destination machine: %ls", pDest->GetName());

    if (pDest->HasInFRS())
    {
        RouteToInFrs(RouteTable, pDest);
    }

    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
    CRouteTable::RoutingInfo* pNextPriority = RouteTable.GetNextHopSecondPriority();

    if (pFirstPriority->empty())
    {
        if (pDest->IsForeign())
        {
            TrTRACE(Rd, "Destination Machine: %ls is foreign machine. Don't route directly", pDest->GetName());
            
            pNextPriority = pFirstPriority;
        }
        else
        {
            TrTRACE(Rd, "Destination machine: %ls Doesn't have IN FRS in our common sites. try direct connection", pDest->GetName());

            //
            // The machine doesn't have InFRS. Use Direct route
            //
            pFirstPriority->insert(SafeAddRef(pDest));
        }
    }

    //
    // If the source and destination have a common site route to RS in the common site 
    // 
    const GUID* pCommonSiteId = m_pMyMachine->GetCommonSite(pDest->GetSiteIds(), false);
    if (pCommonSiteId == NULL)
    {
        //
        // The local machine and destination don't have a common site. Route
        // to my site FRS
        //
        RouteToMySitesFrs(pNextPriority);
        return;
    }

    //
    // There is a common site to local machine and destination. Route to FRS in
    // each common site
    //
    const CACLSID& destSites = pDest->GetSiteIds();
    const GUID* GuidArray = destSites.pElems;
	for (DWORD i=0; i < destSites.cElems; ++i)
	{
        //
        // look if a common site
        //
		if (RdpIsGuidContained(m_pMyMachine->GetSiteIds(), GuidArray[i]))
        {
            pCommonSiteId = &GuidArray[i];
            const CSite* pSite = m_mySites[pCommonSiteId];

            RouteToFrs(
                *pSite, 
                pFirstPriority,
                pNextPriority
                );
        }
    }
}


void
CClientDecision::RouteToOutFrs(
    CRouteTable::RoutingInfo* pRouteList
    )
/*++

  Routine Description:
    The routine route to out FRS of the local machine

  Arguments:
    pointer to routing table

  Returned value:
    None. The routine can raised exception

 --*/
{
    //
    // FRS can't have a list of out FRS
    //
    ASSERT(!m_pMyMachine->IsFRS());
    
    const GUID* pOutFrsId = m_pMyMachine->GetAllOutFRS();

    for(DWORD i = 0; i < m_pMyMachine->GetNoOfOutFRS(); ++i)
    {
        //
        // Get the machine name of the FRS machine identifier
        //
        pRouteList->insert(GetMachineInfo(pOutFrsId[i]));
    }
}


void 
CClientDecision::GetRouteTable(
    const GUID& DestMachineId,
    CRouteTable& RouteTable
    )
/*++

  Routine Description:
    The routine calculates and returnes the routing table for destination Machine.

  Arguments:
    DestMachineId - identefier of the destination machine
    RouteTable - refernce to the routing tabel

  Returned Value:
    None. An exception is raised if the operation fails

 --*/
{
    if (NeedRebuild())
        Refresh();

    CSR lock(m_cs);

    //
    // The internal data was corrupted. Before the routine gets the CS, refresh called
    // again and failed to refresh the internal data.
    //
    if (NeedRebuild())
        throw exception();
    
    //
    // Local machine can't be foreign machine
    //
    ASSERT(!m_pMyMachine->IsForeign());

    if (m_pMyMachine->HasOutFRS())
    {
        //
        // The local machine has out FRS, route to the out FRS
        //
        TrTRACE(Rd, "Building Routing table. Route to OUT FRSs");

        RouteToOutFrs(RouteTable.GetNextHopFirstPriority());
        return; 
    }

    //
    // My machine is not configured with OutFRS. Get the target machine information
    //
    R<const CMachine> destMachine = GetMachineInfo(DestMachineId);

    //
    // The destination machine can't be the local machine
    //
    ASSERT(destMachine->GetId() != m_pMyMachine->GetId());

    //
    // Independent client, is agnostic to inter/intra site routing.
    // First connect directly to the destination and second to local site FRS
    //
    Route(RouteTable, destMachine.get());
}


bool
CClientDecision::IsFrsInMySites(
    const GUID& id
    )
{
    for(SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        const CSite* pSite = it->second;

        const GUID2MACHINE& SiteFrss = pSite->GetSiteFRS();
        for(GUID2MACHINE::const_iterator its = SiteFrss.begin(); its != SiteFrss.end(); ++its)
        {
            const CMachine* pRoute = its->second.get();
            if (pRoute->GetId() == id)
                return true;
        }
    }

    return false;
}


void
CClientDecision::GetConnector(
    const GUID& foreignMachineId,
    GUID& connectorId
    )
{
    if (NeedRebuild())
        Refresh();

    CSR lock(m_cs);

    //
    // The internal data was corrupted. Before the routine gets the CS, refresh called
    // again and failed to refresh the internal data.
    //
    if (NeedRebuild())
        throw exception();
    
    //
    // Local machine can't be foreign machine
    //
    ASSERT(!m_pMyMachine->IsForeign());

    //
    // Get the target foreign machine information
    //
    R<const CMachine> destMachine = GetMachineInfo(foreignMachineId);
    ASSERT(destMachine->IsForeign());
    ASSERT(destMachine->GetSiteIds().cElems != 0);

    bool fFound = false;

    //
    // My machine and the foreign site doesn't have a common site (Foreign machine
    // can have only foreign sites and IC can't have a foreign site).
    // look for a connector to the foreign machine in the enterprize
    //
    const CACLSID& foreignSiteIds = destMachine->GetSiteIds();
    for (DWORD i = 0; i < foreignSiteIds.cElems; ++i)
    {
        CACLSID connectorsIds;
        RdpGetConnectors(foreignSiteIds.pElems[i], connectorsIds);

        if (connectorsIds.cElems == 0)
            continue;

        AP<GUID> pIds = connectorsIds.pElems;

        for (DWORD j = 0; j < connectorsIds.cElems; ++j)
        {
            if (IsFrsInMySites(pIds[j]))
            {
                connectorId = pIds[j];
                return;
            }
        }

        connectorId = pIds[0];
        fFound = true;
    }

    if (!fFound)
        throw bad_route(L"Can't find a connector machine.");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rddebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RdDebug.cpp

Abstract:
    Configuration Manager debugging

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent, _DEBUG only

--*/

#include "libpch.h"
#include "Rd.h"
#include "Rdp.h"

#include "rddebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Configuration Manager state
//
void RdpAssertValid(void)
{
    //
    // RdInitalize() has *not* been called. You should initialize the
    // Configuration Manager library before using any of its funcionality.
    //
    ASSERT(RdpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void RdpSetInitialized(void)
{
    LONG fRdAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Configuration Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fRdAlreadyInitialized);
}


BOOL RdpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Rd,

    //
    // TODO: Add Configuration Manager sub-component trace ID's to be used with TrXXXX.
    // For example, RdInit, as used in:
    // TrERROR(RdInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "RdDumpState(queue path name)",
        "Dump Configuration Manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add Configuration Manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void RdpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdnextsite.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    routeds.cpp

Abstract:
    Implementation of MachineRouteInfo class.

Author:
    Uri Habusha (urih), 12- Apr-2000

--*/

#include <libpch.h>
#include <rd.h>
#include "rdp.h"
#include "rdds.h"
#include "rddesc.h"
#include "RdAd.h"

#include "rdnextsite.tmh"

using namespace std;

class CRoutingNode
{
public:
    CRoutingNode(
        const CSite* pDestSite, 
        const CSite* pNeighbourSite,
        const CSite* pReachViaSite,
        bool fLinkGateAlongTheRoute
        ):
        m_pDestSite(pDestSite),
        m_pNeighbourSite(pNeighbourSite),
        m_pReachViaSite(pReachViaSite),
        m_fLinkGateAlongTheRoute(fLinkGateAlongTheRoute)
    {
    };


    virtual ~CRoutingNode()
    {
    };

    
    const CSite* GetDestSite(void) const
    {
        return m_pDestSite;
    };


    const CSite* GetNeighbourSite(void) const
    {
        return m_pNeighbourSite;
    }


    const CSite* ReachViaSite(void) const
    {
        return m_pReachViaSite;
    };


    bool IsSiteGateAlongTheRoute(void) const
    {
        return m_fLinkGateAlongTheRoute;
    }


private:
    const CSite* m_pDestSite;
    const CSite* m_pNeighbourSite;
    const CSite* m_pReachViaSite;

    bool m_fLinkGateAlongTheRoute;
};


void CServerDecision::CalculateNextSiteHop(void)
{
    ASSERT(m_sitesInfo.empty());

    UpdateSitesInfo();
    
    for(SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        CSite* pMySite = it->second;

        //
        // foreign site is virtual site
        //
        if (pMySite->IsForeign())
            continue;

        pMySite->CalculateNextSiteHop(m_sitesInfo);
    }
}


void CServerDecision::UpdateSitesInfo(void)
{
    RdpGetSites(m_sitesInfo);

    //
    //  Set siteLinks info
    //
    UpdateSiteLinksInfo();
}


void CServerDecision::UpdateSiteLinksInfo(void)
/*++

  Routine Description:
    The routine retrives the site link information from the DS and associate 
    it to the relevant sites in the map of site 

  Arguments:
    map of the enterprise sites

  Returned value:
    MQ_OK if completes successfully. Error otherwise

  NOTE: bad_alloc exception is handled in the upper level

 --*/
{
    //
    // read all site links information
    //

    SITELINKS siteLinks;
    RdpGetSiteLinks(siteLinks);

    for(SITELINKS::iterator it = siteLinks.begin(); it != siteLinks.end(); )
    {
        const CSiteLink* pSiteLink = it->get();

        //
        // All the sites should be in the sitesInfo structure
        //
        SITESINFO::iterator itSite;
        
        itSite = m_sitesInfo.find(pSiteLink->GetNeighbor1());
        ASSERT(itSite != m_sitesInfo.end());
        CSite* pSiteInfo1 = itSite->second;

        itSite = m_sitesInfo.find(pSiteLink->GetNeighbor2());
        ASSERT(itSite != m_sitesInfo.end());
        CSite* pSiteInfo2 = itSite->second;


        pSiteInfo1->AddSiteLink(pSiteLink);
        pSiteInfo2->AddSiteLink(pSiteLink);

        it = siteLinks.erase(it);
    }
}


void CSite::CalculateNextSiteHop(const SITESINFO& SitesInfo)
{

    typedef multimap<DWORD, CRoutingNode> DIJKSTRA_TABLE;
    DIJKSTRA_TABLE DijkstraTable;

    //
    // DIJKSTRA initilization. Add the current site
    //
    ASSERT(SitesInfo.find(&GetId()) != SitesInfo.end());
    const CSite* pLocalSite = SitesInfo.find(&GetId())->second;
    DijkstraTable.insert(DIJKSTRA_TABLE::value_type(0, CRoutingNode(pLocalSite, NULL, pLocalSite, false)));

    //
    // Iterate through all the site links for all sites in enterprise
    //
    while (!DijkstraTable.empty())
    {
        //
        // Get the site with minimum cost
        //
        pair<const DWORD, CRoutingNode> NextHop = *(DijkstraTable.begin());
        DijkstraTable.erase(DijkstraTable.begin());

        const CSite* pSiteInfo = (NextHop.second).GetDestSite();
        if (m_nextSiteHop.find(&pSiteInfo->GetId()) != m_nextSiteHop.end())
        {
            //
            // Already exist. Ignore it
            //
            continue;
        }

        //
        // A new site add it to next hop
        //
        const CSite* pReachViaSite = (NextHop.second).ReachViaSite();
        const CSite* pNeighbourSite = (NextHop.second).GetNeighbourSite();

        m_nextSiteHop[&pSiteInfo->GetId()] = CNextSiteHop(
                                                &pReachViaSite->GetId(),
                                                &pNeighbourSite->GetId(),
                                                pReachViaSite->IsForeign(),
                                                NextHop.second.IsSiteGateAlongTheRoute(),
                                                NextHop.first
                                                );

        //
        // foreign site is virtual site that MSMQ can't route via it
        //
        if (pSiteInfo->IsForeign())
            continue;

        //
        // Add all the sites that can be reach via this site to the Dijkstra table
        //
        const SITELINKS& SiteLinks = pSiteInfo->GetSiteLinks();
        for (SITELINKS::iterator it = SiteLinks.begin(); it != SiteLinks.end(); ++it)
        {
            const CSiteLink* pSiteLink = it->get();
            DWORD cost = NextHop.first + pSiteLink->GetCost();

            const GUID* NeighborId = pSiteLink->GetNeighborOf(pSiteInfo->GetId());
    
            ASSERT(SitesInfo.find(NeighborId) !=  SitesInfo.end());
            const CSite* pNeighborSite = SitesInfo.find(NeighborId)->second;

            bool fLinkGateAlongRoute = NextHop.second.IsSiteGateAlongTheRoute() ||
                                       (pSiteLink->GetLinkGates().cElems != 0);
            //
            // For first iteration, the ReachViaSite should be the next site
            // 
            if (pSiteInfo->GetId() == GetId())
            {
                CRoutingNode NextHop(pNeighborSite, pSiteInfo, pNeighborSite, fLinkGateAlongRoute);
                DijkstraTable.insert(DIJKSTRA_TABLE::value_type(cost, NextHop));
            }
            else
            {
                CRoutingNode NextHop(pNeighborSite, pSiteInfo, pReachViaSite, fLinkGateAlongRoute);
                DijkstraTable.insert(DIJKSTRA_TABLE::value_type(cost, NextHop));
            }
        }
    }

#ifdef _DEBUG
    for(NEXT_SITE_HOP::iterator itn = m_nextSiteHop.begin(); itn != m_nextSiteHop.end(); ++itn)
    {
        CSite* pDestSite = (SitesInfo.find(itn->first))->second;
        const CNextSiteHop& NextHop = itn->second;
        CSite* pViaSite = (SitesInfo.find(NextHop.m_pNextSiteId))->second;

        TrTRACE(Rd, "Site: %ls Reach via site:%ls cost %d (foreign %d)",  
                    pDestSite->GetName(), pViaSite->GetName(), NextHop.m_cost, NextHop.m_fTargetSiteIsForeign);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdds.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

  rdds.h

Abstract:

    Definition of Machine Info class.

Author:

    Uri Habusha (urih), 10-Apr-2000


--*/

#pragma once

#ifndef __RDDS_H__
#define __RDDS_H__


class CSite;
typedef std::map<const GUID*, CSite*, guid_less> SITESINFO;


class CMachine;
typedef std::map<const GUID*, R<CMachine>, guid_less> GUID2MACHINE;

class CSiteLink;
typedef std::list< R<const CSiteLink> > SITELINKS;


//---------------------------------------------------------
//
// class CSiteLink
//
//---------------------------------------------------------

class CSiteLink : public CReference
{
public:
    CSiteLink(
        CACLSID& linkGates, 
        GUID* pNeighbor1, 
        GUID* pNeighbor2, 
        DWORD cost
        ) :
        m_linkGates(linkGates),
        m_pNeighbor1(pNeighbor1),
        m_pNeighbor2(pNeighbor2),
        m_cost(cost)
    {
        RdpRandomPermutation(m_linkGates);
    }


    virtual ~CSiteLink();


    const CACLSID& GetLinkGates(void) const
    {
        return m_linkGates;
    };


    const GUID* GetNeighborOf(const GUID& siteId) const
    {
        if (siteId == *m_pNeighbor1)
            return m_pNeighbor2;
    
        if (siteId == *m_pNeighbor2)
            return m_pNeighbor1;

        return NULL;
    };


    const GUID* GetNeighbor1(void) const
    {
        return m_pNeighbor1;
    }


    const GUID* GetNeighbor2(void) const
    {
        return m_pNeighbor2;
    }


    DWORD GetCost() const
    {
        return m_cost;
    }

private:
    CACLSID m_linkGates;

    P<GUID> m_pNeighbor1;
    P<GUID> m_pNeighbor2;

    DWORD m_cost;  
};


//---------------------------------------------------------
//
// class CSite
//
//---------------------------------------------------------

class CSite
{
public: 
    CSite(const GUID& siteId);
    virtual ~CSite();

   
    R<const CSiteLink> GetSiteLinkToSite(const GUID& destSiteId) const;
    void CalculateNextSiteHop(const SITESINFO& SitesInfo);

    bool IsMyFrs(const GUID& frsId) const;

    const GUID& GetId(void) const
    {
        return m_id;
    }


    LPCWSTR GetName(void) const
    {
        return m_name;
    }


    void AddSiteLink(const CSiteLink* pSiteLink)
    {
        m_siteLinks.push_back(SafeAddRef(pSiteLink));
    };


    bool IsForeign(void) const
    {
        return m_fForeign;
    }


    const GUID2MACHINE& GetSiteFRS(void) const
    {
        return m_frsMachines;
    };

    
    void 
    GetNextSiteToReachDest(
        const CACLSID& DestSiteIds,
        bool fDestForeign,
        const GUID** ppReachViaSite,
        const GUID** ppDestSite,
        const GUID** ppNeighbourSite,
        bool* pfLinkGateAlongTheRoute,
        DWORD* pCost
        ) const;

private:
    const SITELINKS& GetSiteLinks(void) const
    {
        return m_siteLinks;
    };


    void UpdateMySiteFrs(void);


private:
    class CNextSiteHop
    {
    public:
        CNextSiteHop()
        {
            // default construtor is required by stl container
        }

        CNextSiteHop(
            const GUID* pNextSiteId,
            const GUID* pNeighbourSiteId,
            bool fForeign,
            bool fLinkGateAlongTheRoute,
            DWORD cost
            ) : 
            m_pNextSiteId(pNextSiteId),
            m_pNeighbourSiteId(pNeighbourSiteId),
            m_fTargetSiteIsForeign(fForeign),
            m_fLinkGateAlongTheRoute(fLinkGateAlongTheRoute),
            m_cost(cost) 
        {
        }

        const GUID* m_pNextSiteId;
        const GUID* m_pNeighbourSiteId;
        bool m_fTargetSiteIsForeign; 
        bool m_fLinkGateAlongTheRoute;
        DWORD m_cost;
    };


private:
    typedef std::map<const GUID*, CNextSiteHop, guid_less> NEXT_SITE_HOP;

    GUID m_id;
    AP<WCHAR> m_name;
    bool m_fForeign;
    bool m_fLinkGateAlongTheRoute;

    GUID2MACHINE m_frsMachines;
    SITELINKS m_siteLinks;

    NEXT_SITE_HOP m_nextSiteHop;
};
 


//---------------------------------------------------------
//
// class CMachine
//
//---------------------------------------------------------

class CMachine  : public CRouteMachine
{
public:
    CMachine();
    CMachine(
        const GUID& MyMachineId,
        const CACLSID& siteIds,
        const CACLSID& outFrss,
        const CACLSID& inFrss,
        LPWSTR pName,
        bool fFrs,
        bool fForeign
        );

    ~CMachine();

    void Update(const GUID& MyMachineId);

    bool IsMySite(const GUID& SiteId) const;
    
    const GUID* 
    GetCommonSite(
        const CACLSID& SiteIds,
        bool fCheckForeign,
        const SITESINFO* pMySitesInfo = NULL
        ) const;
    
    void
    RemoveInvalidInOutFrs(
        const SITESINFO& mySites
        );


    const GUID& GetId(void) const
    {
        return m_id;
    }


    LPCWSTR GetName(void) const
    {
        return m_name;
    }


    bool IsForeign(void) const
    {
        return m_fForeign;
    }

    const CACLSID& GetSiteIds(void) const
    {
        return m_siteIds;
    };


    DWORD GetNoOfInFRS() const 
    {
        return m_inFRSList.cElems;
    };


    DWORD GetNoOfOutFRS() const 
    {
        return m_outFRSList.cElems;
    };


    bool HasOutFRS() const
    {
        return (GetNoOfOutFRS() !=0);
    };


    bool HasInFRS()  const
    {
        return (GetNoOfInFRS() !=0);
    };


    const GUID* GetAllInFRS() const
    {
        return m_inFRSList.pElems;
    };

    
    const GUID* GetAllOutFRS() const 
    {
        return m_outFRSList.pElems;
    };

    
    bool IsFRS() const
    {
        return m_fIsFRS;
    };


    bool IsMyInFrs(const GUID& frsId) const
    {
        return RdpIsGuidContained(m_inFRSList, frsId);
    };


private:

    static
    bool 
    IsFrsInSites(
        const GUID& frsId,
        const SITESINFO& sites
        );

private:
    GUID m_id;
    LPWSTR m_name;

    CACLSID m_siteIds;
    CACLSID m_outFRSList;
    CACLSID m_inFRSList;

    bool m_fIsFRS;
    bool m_fForeign;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdds.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    rdds.cpp

Abstract:
    Implementation of MachineRouteInfo class.

Author:
    Uri Habusha (urih), 10-Apr-2000

--*/

#include <libpch.h>
#include "rd.h"
#include "rdp.h"
#include "rdds.h"
#include "rdad.h"

#include "rdds.tmh"

CMachine::CMachine(
    void
    ) :
    m_id(GUID_NULL),
    m_name(NULL),
    m_fIsFRS(false),
    m_fForeign(false)
{
    m_siteIds.cElems = 0;
    m_siteIds.pElems = NULL;
    m_outFRSList.cElems = 0;
    m_outFRSList.pElems = NULL;
    m_inFRSList.cElems = 0;
    m_inFRSList.pElems = NULL;
};

CMachine::CMachine(
    const GUID& MyMachineId,
    const CACLSID& siteIds,
    const CACLSID& outFrss,
    const CACLSID& inFrss,
    LPWSTR pName,
    bool fFrs,
    bool fForeign
    ) :
    m_id(MyMachineId),
    m_siteIds(siteIds),
    m_outFRSList(outFrss),
    m_inFRSList(inFrss),
    m_name(pName),
    m_fIsFRS(fFrs),
    m_fForeign(fForeign)
{
    RdpRandomPermutation(m_siteIds);
    RdpRandomPermutation(m_outFRSList);
    RdpRandomPermutation(m_inFRSList);
}




bool
CMachine::IsMySite(
    const GUID& siteId
    ) const
{
    for (DWORD i = 0; i < m_siteIds.cElems; ++i)
    {
        if (siteId == m_siteIds.pElems[i])
            return true;
    }

    return false;
}


const GUID* 
CMachine::GetCommonSite(
    const CACLSID& SiteIds,
    bool fCheckForeign,
    const SITESINFO* pMySitesInfo       // = NULL
    ) const
{
    for (DWORD i = 0; i < SiteIds.cElems; ++i)
    {
        if (IsMySite(SiteIds.pElems[i]))
        {
            if (fCheckForeign)
            {
                //
                // Local machine is RS, and can be part of Foreign site. However,
                // it is virtual site and can't be used for routing, ignore it
                //

                ASSERT(pMySitesInfo != NULL);
                ASSERT(IsFRS());

                //
                // Site must exist in Data-Base
                //
                ASSERT(pMySitesInfo->find(&SiteIds.pElems[i]) != pMySitesInfo->end());

                const CSite* pSite = pMySitesInfo->find(&SiteIds.pElems[i])->second;
                if (pSite->IsForeign())
                    continue;
            }

            return &SiteIds.pElems[i];
        }
    }

    return NULL;
}


bool 
CMachine::IsFrsInSites(
    const GUID& frsId,
    const SITESINFO& sites
    )
{
    for (SITESINFO::const_iterator itSite = sites.begin(); itSite != sites.end(); ++itSite)
    {
        CSite* pSite = itSite->second;

        if (pSite->IsMyFrs(frsId))
            return true;
    }
    return false;
}


void
CMachine::RemoveInvalidInOutFrs(
    const SITESINFO& sites
    )
{
    if (HasInFRS())
    {
        for (DWORD i =0; i < GetNoOfInFRS(); ++i)
        {
            GUID* pInFrs = m_inFRSList.pElems;

            if (! IsFrsInSites(pInFrs[i], sites))
            {
                for (DWORD j = i; j < GetNoOfInFRS(); ++j)
                {
                    pInFrs[j] = pInFrs[j+1];
                }
                --m_inFRSList.cElems;
            }
        }
    }

    if (HasOutFRS())
    {
        for (DWORD i =0; i < GetNoOfOutFRS(); ++i)
        {
            GUID* pOutFrs = m_outFRSList.pElems;

            if (! IsFrsInSites(pOutFrs[i], sites))
            {
                for (DWORD j = i; j < GetNoOfOutFRS(); ++j)
                {
                    pOutFrs[j] = pOutFrs[j+1];
                }
                --m_outFRSList.cElems;
            }
        }
    }
}


CMachine::~CMachine()
{
    delete [] m_name;
    delete [] m_siteIds.pElems;
    delete [] m_outFRSList.pElems;
    delete [] m_inFRSList.pElems;
}


void 
CMachine::Update(
    const GUID& machineId
    )
{
    //
    // free the previous data
    //
    delete [] m_name;
    delete [] m_siteIds.pElems;
    delete [] m_outFRSList.pElems;
    delete [] m_inFRSList.pElems;

    //
    // Clear the previous data
    //
    m_name = NULL;
    m_siteIds.cElems = 0;
    m_siteIds.pElems = NULL;
    m_outFRSList.cElems = 0;
    m_outFRSList.pElems = NULL;
    m_inFRSList.cElems = 0;
    m_inFRSList.pElems = NULL;

    //
    // have own copy of the QMId
    //
    m_id = machineId;

    RdpGetMachineData(
                m_id, 
                m_siteIds,
                m_outFRSList,
                m_inFRSList,
                &m_name,
                &m_fIsFRS,
                &m_fForeign
                );
    
    RdpRandomPermutation(m_siteIds);
    RdpRandomPermutation(m_outFRSList);
    RdpRandomPermutation(m_inFRSList);
}




CSite::CSite(
    const GUID& siteId
    ) : 
    m_id(siteId)
{
    RdpGetSiteData(m_id, &m_fForeign, &m_name);

    UpdateMySiteFrs();
}


CSite::~CSite()
{         
    m_siteLinks.erase(m_siteLinks.begin(), m_siteLinks.end());
    m_frsMachines.erase(m_frsMachines.begin(), m_frsMachines.end());
    m_nextSiteHop.erase(m_nextSiteHop.begin(), m_nextSiteHop.end());
}


bool
CSite::IsMyFrs(
    const GUID& frsId
    ) const
{
    return (m_frsMachines.find(&frsId) != m_frsMachines.end());
}


void 
CSite::GetNextSiteToReachDest(
    const CACLSID& DestSiteIds,
    bool fDestIsForeign,
    const GUID** ppReachViaSite,
    const GUID** ppDestSite,
    const GUID** ppNeighbourSite,  
    bool* pfLinkGateAlongTheRoute,
    DWORD* pCost
    ) const
{
    *ppReachViaSite = NULL;
    *pCost = INFINITE;

    for (DWORD i = 0; i < DestSiteIds.cElems; ++i)
    {
        //
        // Need to route to next site. Look for the sitelink that should be used 
        // for routing
        //
        NEXT_SITE_HOP::const_iterator it = m_nextSiteHop.find(&DestSiteIds.pElems[i]);
        if (it != m_nextSiteHop.end())
        {
            const CNextSiteHop& NextHop = it->second;
           
            if (
                //
                // The cost must be better
                //
                (NextHop.m_cost < *pCost) && 

                //
                // Use foreign site only to route to foreign destination. 
                // This code is special for connector machine, since only
                // connector can reside in foreign and regular sites.
                //
                ((!fDestIsForeign && ! NextHop.m_fTargetSiteIsForeign) || fDestIsForeign))
            {
                *ppDestSite = &DestSiteIds.pElems[i];
                *ppReachViaSite = NextHop.m_pNextSiteId;
                *ppNeighbourSite = NextHop.m_pNeighbourSiteId;
                *pfLinkGateAlongTheRoute = NextHop.m_fLinkGateAlongTheRoute;
                *pCost = NextHop.m_cost;
            }
        }
    }
}


R<const CSiteLink>
CSite::GetSiteLinkToSite(
    const GUID& destSiteId
    ) const
{
    ASSERT(m_siteLinks.begin() != m_siteLinks.end());

    for (SITELINKS::iterator it = m_siteLinks.begin(); it != m_siteLinks.end(); ++it)
    {
        const CSiteLink* pSiteLink = it->get();
        const GUID* pSrcSite = pSiteLink->GetNeighborOf(destSiteId);

        if (pSrcSite != NULL)
        {
            ASSERT(*pSrcSite == m_id);
            return SafeAddRef(pSiteLink);
        }
    }

    //
    // The function is called only when there is a site link between
    // my site and the destination site.
    //
    ASSERT(0);
    return NULL;
}


void
CSite::UpdateMySiteFrs(
    void
    )
{
    ASSERT(m_frsMachines.empty());

    TrTRACE(Rd, "Get Site: %ls, FRS machines.", GetName());

    RdpGetSiteFrs(GetId(), m_frsMachines);
}


CSiteLink::~CSiteLink()
{
    delete [] m_linkGates.pElems;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rddesc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  rddecs.h

Abstract:
    Definition of Routing Decision class.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __ROUTDECS_H__
#define __ROUTDECS_H__

#include "rwlock.h"
#include "Ex.h"

class CRoutingDecision
{
public:
    CRoutingDecision(
        CTimeDuration rebuildInterval
        ) :
        m_pMyMachine(new CMachine),
        m_rebuildInterval(rebuildInterval),
        m_lastBuiltAt(0)
    {
    }
    
    
    virtual ~CRoutingDecision()
    {
        CleanupInformation();
    }


    virtual void Refresh(void)
    {
        UpdateBuildTime(ExGetCurrentTime());
    }


    virtual
    void
    GetRouteTable(
        const GUID& DestMachineId,
        CRouteTable& RouteTable
        ) = 0;

    virtual
    void
    GetConnector(
        const GUID& foreignMachineId,
        GUID& connectorId
        ) = 0;

protected:
    void GetMyMachineInformation(void);
    R<const CMachine> GetMachineInfo(const GUID& MachineId);

    void CleanupInformation(void);
    bool NeedRebuild(void) const;


private:
    void UpdateBuildTime(CTimeInstant time)
    { 
        m_lastBuiltAt = time;
    }


protected:
    CReadWriteLock m_cs;

    R<CMachine> m_pMyMachine;
    SITESINFO m_mySites;

private:
    CTimeInstant m_lastBuiltAt;
    CTimeDuration m_rebuildInterval;

    CReadWriteLock m_csCache;
    GUID2MACHINE m_cachedMachines;
};


//---------------------------------------------------------
//
// class CClientDecision
//
//---------------------------------------------------------

class CClientDecision: public CRoutingDecision
{
public:
    CClientDecision(
        CTimeDuration rebuildInterval
        ) :
        CRoutingDecision(rebuildInterval)
    {
    }


    void
    GetRouteTable(
        const GUID& DestMachineId,
        CRouteTable& RouteTable
        );


    void
    GetConnector(
        const GUID& foreignMachineId,
        GUID& connectorId
        );

    
    void Refresh(void);

private:
    void 
    RouteToOutFrs(
        CRouteTable::RoutingInfo* pRouteList
        );

    void
    RouteToInFrs(
        CRouteTable& RouteTable,
        const CMachine* pDest
        );

    void 
    RouteToFrs(
        const CSite& site,
        const CRouteTable::RoutingInfo* pPrevRouteList,
        CRouteTable::RoutingInfo* pRouteList
        );

    void 
    RouteToMySitesFrs(
        CRouteTable::RoutingInfo* pRouteList
        );
    
    void
    Route(
        CRouteTable& RouteTable, 
        const CMachine* pDest
        );   

    bool
    IsFrsInMySites(
        const GUID& pId
        );


};


//---------------------------------------------------------
//
// class CServerDecision
//
//---------------------------------------------------------

class CServerDecision : public CRoutingDecision
{
public:
    CServerDecision(
        CTimeDuration rebuildInterval
        ) :
        CRoutingDecision(rebuildInterval)
    {
    }
    

    ~CServerDecision()
    {
        CleanupInformation();
    }

    
    void
    GetRouteTable(
        const GUID& DestMachineId,
        CRouteTable& RouteTable
        );


    void
    GetConnector(
        const GUID& foreignMachineId,
        GUID& connectorId
        );


    void Refresh(void);

private:
    void
    RouteIntraSite(
        const CMachine* pDestMachine,
        CRouteTable& RouteTable
        );

    void
    RouteToInFrsIntraSite(
        const CMachine* pDest,
        CRouteTable::RoutingInfo* pRouteList
        );

    void
    RouteInterSite(
        const CMachine* pDestMachine,
        CRouteTable& RouteTable 
        );

    void
    RouteToInFrsInterSite(
        const CMachine* pDestMachine,
        CRouteTable& RouteTable
        );
    
    R<const CSiteLink>
    FindSiteLinkToDestSite(
        const CMachine* pDestMachineInfo,
        const GUID** ppNextSiteId,
        const GUID** ppDestSiteId,
        const GUID** ppNeighbourSiteId,
        bool* pfLinkGateAlongTheRoute
        );

    void
    RouteToLinkGate(
        const CACLSID& LinkGates,
        CRouteTable& RouteTable
        );

    void
    RouteToFrsInSite(
        const GUID* pSiteId,
        const CRouteTable::RoutingInfo* pPrevRouteList,
        CRouteTable::RoutingInfo* pRouteList
        );

    bool
    IsMyMachineLinkGate(
        const CACLSID& LinkGates
        );

    void UpdateSiteLinksInfo(void);
    void UpdateSitesInfo(void);
    void CalculateNextSiteHop(void);

    void CleanupInformation(void);

private:
    SITESINFO m_sitesInfo;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Rdp.h

Abstract:
    Routing Decision private functions.

Author:
    Uri Habusha (urih) 10-Apr-00

--*/

#pragma once

#ifndef _MSMQ_Rdp_H_
#define _MSMQ_Rdp_H_

#include "timetypes.h"


const TraceIdEntry Rd = L"Routing Decision";

#ifdef _DEBUG

void RdpAssertValid(void);
void RdpSetInitialized(void);
BOOL RdpIsInitialized(void);
void RdpRegisterComponent(void);

#else // _DEBUG

#define RdpAssertValid() ((void)0)
#define RdpSetInitialized() ((void)0)
#define RdpIsInitialized() TRUE
#define RdpRegisterComponent() ((void)0)

#endif // _DEBUG

struct guid_less : public std::binary_function<const GUID*, const GUID*, bool> 
{
    bool operator()(const GUID* k1, const GUID* k2) const
    {
        return (memcmp(k1, k2, sizeof(GUID)) < 0);
    }
};

void
RdpInitRouteDecision(
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    );


bool
RdpIsGuidContained(
    const CACLSID& caclsid,
    const GUID& SearchGuid
    );


bool
RdpIsCommonGuid(
    const CACLSID& caclsid1,
    const CACLSID& caclsid2
    );


void
RdpRandomPermutation(
    CACLSID& e
    );


bool
RdpIsMachineAlreadyUsed(
    const CRouteTable::RoutingInfo* pRouteList,
    const GUID& id
    );

#endif // _MSMQ_Rdp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdserver.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    RdServer.cpp

Abstract:
    Implementation of Routing server Routing Decision.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "Rd.h"
#include "Cm.h"
#include "Rdp.h"          
#include "RdDs.h"
#include "RdDesc.h"
#include "RdAd.h"

#include "rdserver.tmh"

void 
CServerDecision::CleanupInformation(
    void
    )
{
    for (SITESINFO::iterator it = m_sitesInfo.begin(); it != m_sitesInfo.end(); )
    {
        delete it->second;
        it = m_sitesInfo.erase(it);
    }

    CRoutingDecision::CleanupInformation();
}


void
CServerDecision::Refresh(
    void
    )
/*++

  Routine Description:
    Initializes the routine decision internal data structure.

    The routine free the previous data, and access the DS to get updated data.
    The routine featchs information for the local machine and sites. If data fetching
    succeded the routine updates the build time.

    If updating the internal data failed, the routine raise an exception.

  
  Arguments:
    None.
    
  Returned Value:
    None. An exception is raised if the operation fails

  Note:
    Brfore the routine refreshes the internal data it erases the previous data and
    sets the last build time varaible to 0. If an exception is raised during retrieving 
    the data from AD or building the internal DS, the routine doesn't update the 
    last build time. This promise that next time the Routing Decision is called 
    the previous Data structures will be cleaned-up and rebuilt.

 --*/
{
    CSW lock(m_cs);

    TrTRACE(Rd, "Refresh Routing Decision internal data.");

    //
    // Cleanup previous information
    //
    CleanupInformation();

    //
    // Get local machine information
    //
    GetMyMachineInformation();

    //
    // My machine should be RS, otherwise we shouldn't reach here
    //
    ASSERT(m_pMyMachine->IsFRS());

    //
    // Routing server can't have OUT FRS list
    //
    ASSERT(! m_pMyMachine->HasOutFRS());

    //
    // Calculate site link and next site hop
    //
    CalculateNextSiteHop();

    //
    // Update last refresh time
    //
    CRoutingDecision::Refresh();
}


void
CServerDecision::RouteToInFrsIntraSite(
    const CMachine* pDest,
    CRouteTable::RoutingInfo* pRouteList
    )
{
    TrTRACE(Rd, "Route to destination: %ls, IN FRSs", pDest->GetName());

    ASSERT(pDest->HasInFRS());

    //
    // The destination machine has InFrs. Deliver the message to InFrs Machines
    // 
    const GUID* InFrsArray = pDest->GetAllInFRS();
    for (DWORD i = 0; i < pDest->GetNoOfInFRS(); ++i)
    {
        R<const CMachine> pRoute = GetMachineInfo(InFrsArray[i]);

        //
        // Check that in-Frs is in the same site as the source machine
        //
        const GUID* pCommonSiteId = m_pMyMachine->GetCommonSite(
                                                pRoute->GetSiteIds(), 
                                                (! pDest->IsForeign()),
                                                &m_mySites
                                                );
        if (pCommonSiteId != NULL)
        {
            pRouteList->insert(pRoute);
        }
    }
}


void
CServerDecision::RouteIntraSite(
    const CMachine* pDest,
    CRouteTable& RouteTable
    )
/*++ 

  Routine Description:
    Both, the source and destination machines are in the sam site. The routine finds 
    the possibile next hops for in site destination.

    Intra site, routing algorithm for independent client is:
        - First priority, direct connection to the destination or to valid 
          in-frss (if exist in same site).
        - Second priority. connection with one of RS in site.

    Intra site, routing algorithm for RS is:
        - First priority. direct connection to the destination machine or to valid
          in-Frs (if exist and the source isn't one of them)

  Arguments:
    RouteTable - routing table that the routine fills
    pDest - information of the destination machine

  Returned Value:
    None. the routine fills the routine table

  Note:
    The routine can throw an exeption

 --*/
{
    TrTRACE(Rd, "IntraSite routing to: %ls.", pDest->GetName());

    //
    // The destination and local machine should be in the same 
    // site. Otherwise it is not Intra site routing
    //
    ASSERT(m_pMyMachine->GetCommonSite(pDest->GetSiteIds(), (!pDest->IsForeign()), &m_mySites) != NULL);
    
    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();

    if (pDest->HasInFRS() && 
        ! pDest->IsMyInFrs(m_pMyMachine->GetId()))
    {
        RouteToInFrsIntraSite(pDest, pFirstPriority);

        if (!pFirstPriority->empty())
            return;

        //
        // Didn't find IN Frs that belong to my sites. Ignore In FRSs
        //        
    }

    //
    // The destination machine doesn't have InFRS or my machine is set 
    // as InFRS machine of the destination. Use Direct connection from 
    // FRS to Destination machine in Same site. Don't try alternative path
    //
    pFirstPriority->insert(SafeAddRef(pDest));
}


bool
CServerDecision::IsMyMachineLinkGate(
    const CACLSID& LinkGates
    )
{
   //
    // Scan all the site gates of the link and find if the source machine 
    // is one of the site gate. MSMQ doesn't need to route to the site gate
    //
    for (DWORD i = 0; i< LinkGates.cElems; ++i)
    {
        if (LinkGates.pElems[i] == m_pMyMachine->GetId())
        {
            return true;
        }
    }

    return false;
}


void
CServerDecision::RouteToLinkGate(
    const CACLSID& LinkGates,
    CRouteTable& RouteTable
    )
{
    //
    // Our link need to have a Link Gates. Otherwise the code 
    // doesn't reach this point
    //
    ASSERT(LinkGates.cElems > 0);

    for (DWORD i = 0; i< LinkGates.cElems; ++i)
    {
        ASSERT(LinkGates.pElems[i] != m_pMyMachine->GetId());

        //
        // Direct route to link gate
        //
        R<const CMachine> pRoute = GetMachineInfo(LinkGates.pElems[i]);
        (RouteTable.GetNextHopFirstPriority())->insert(pRoute);
    }
}


void
CServerDecision::RouteToInFrsInterSite(
    const CMachine* pDest,
    CRouteTable& RouteTable
    )
{
    ASSERT(! pDest->IsMyInFrs(m_pMyMachine->GetId()));

    //
    // The destination machine has InFrs. Deliver the message to InFrs Machines
    //
    const GUID* InFrsArray = pDest->GetAllInFRS();

    for (DWORD i = 0; i < pDest->GetNoOfInFRS(); ++i)
    {
        R<const CMachine> pRoute = GetMachineInfo(InFrsArray[i]);
        
        //
        // check that In-FRS is valid FRS in destiantion machine SITES
        //
        if (RdpIsCommonGuid(pDest->GetSiteIds(), pRoute->GetSiteIds()))
        {
            //
            // The next hop is one of the valid IN-FRS. 
            // 
            GetRouteTable(InFrsArray[i], RouteTable);
        }
    }
}


R<const CSiteLink>
CServerDecision::FindSiteLinkToDestSite(
    const CMachine* pDest,
    const GUID** ppNextSiteId,
    const GUID** ppDestSiteId,
    const GUID** ppNeighbourSite,
    bool* pfLinkGateAlongTheRoute
    )
{
    const GUID* pMySiteId = NULL;
    DWORD NextSiteCost = INFINITE;

    const CACLSID& DestSiteIds = pDest->GetSiteIds();

    //
    // Need to route to next site. Look for the sitelink that should be used 
    // for routing
    //
    for (SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        const GUID* pTempDestSiteId;
        const GUID* pTempViaSiteId;
        const GUID* pNeighbourSiteId;
        bool fLinkGateAlongTheRoute;
        DWORD TempCost;
        const CSite* pSite = it->second;

        pSite->GetNextSiteToReachDest(
                                DestSiteIds, 
                                pDest->IsForeign(), 
                                &pTempViaSiteId,
                                &pTempDestSiteId,
                                &pNeighbourSiteId,
                                &fLinkGateAlongTheRoute,
                                &TempCost
                                );

        if(NextSiteCost > TempCost)
        {
            pMySiteId = &pSite->GetId();
            *ppNextSiteId = pTempViaSiteId;
            *ppDestSiteId = pTempDestSiteId;
            *ppNeighbourSite = pNeighbourSiteId;
            *pfLinkGateAlongTheRoute = fLinkGateAlongTheRoute;
            NextSiteCost = TempCost;
        }
    }

    if (pMySiteId == NULL)
    {
        //
        // Can't route to destination site. there is no connectivity
        //
        TrWARNING(Rd, "Failed to route to destination site. There is no connectivity");
		return NULL;
    }

    const CSite* pMySite = m_sitesInfo.find(pMySiteId)->second;
    
    return pMySite->GetSiteLinkToSite(**ppNextSiteId);
}


void
CServerDecision::RouteToFrsInSite(
    const GUID* pSiteId,
    const CRouteTable::RoutingInfo* pPrevRouteList,
    CRouteTable::RoutingInfo* pRouteList
    )
{
    //
    // find site object
    //
    ASSERT(m_sitesInfo.find(pSiteId) != m_sitesInfo.end());
    CSite* pSite = m_sitesInfo.find(pSiteId)->second;

    const GUID2MACHINE& DestSiteFRS = pSite->GetSiteFRS();
    for(GUID2MACHINE::const_iterator it1 = DestSiteFRS.begin(); it1 != DestSiteFRS.end(); ++it1)
    {
        R<const CMachine> pRoute = GetMachineInfo(*it1->first);

        if (RdpIsMachineAlreadyUsed(pPrevRouteList, pRoute->GetId()))
        {
            //
            // We already route to this machine directly
            //
            continue;
        }

        pRouteList->insert(pRoute);
    }
}


void
CServerDecision::RouteInterSite(
    const CMachine* pDest,
    CRouteTable& RouteTable
    )
{
    TrTRACE(Rd, "InterSite routing to: %ls", pDest->GetName());

    if (pDest->HasInFRS())
    {
        RouteToInFrsInterSite(pDest, RouteTable);
        return;
    }

    const GUID* pNextSiteId = NULL;
    const GUID* pDestSiteId = NULL;
    const GUID* pNeighbourSite = NULL;
    bool fLinkGateAlongTheRoute;

	R<const CSiteLink> pSiteLink = FindSiteLinkToDestSite(
                                        pDest, 
                                        &pNextSiteId, 
                                        &pDestSiteId, 
                                        &pNeighbourSite,
                                        &fLinkGateAlongTheRoute
                                        );
	if(pSiteLink.get() == NULL)
	{
		//
		// There is no routing link between the sites. try direct connection
		//
		CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
		pFirstPriority->insert(SafeAddRef(pDest));
		return;
	}

    if (fLinkGateAlongTheRoute && 
        !IsMyMachineLinkGate(pSiteLink->GetLinkGates()))
    {
        //
        // If the next link has a link gates route the message to these link gates
        //
        if (pSiteLink->GetLinkGates().cElems != 0)
        {
            //
            // Local machine need a LinkGate:
            //      - Destination is in other Site,
            //      - Our Link is configured with Link Gates and Local machine is not a LinkGate,
            //
            RouteToLinkGate(pSiteLink->GetLinkGates(), RouteTable);
            return;
        }

        //
        // the next link doesn't have a link gate. Route the message to RSs in the 
        // next site along the best route.
        //
        RouteToFrsInSite(pNextSiteId, NULL, RouteTable.GetNextHopFirstPriority());
        return;
    }

    //
    // My machine is link gate, but next site isn't destination site, route
    // the message to RSs in next site along the best route.
    //
    if (IsMyMachineLinkGate(pSiteLink->GetLinkGates()) && 
        !RdpIsGuidContained(pDest->GetSiteIds(), *pNextSiteId))
    {
        ASSERT(fLinkGateAlongTheRoute);

        RouteToFrsInSite(pNextSiteId, NULL, RouteTable.GetNextHopFirstPriority());
        return;
    }

    //
    // Local machine is site gate and the next site is the destiantion site, or the 
    // site doesn't have a link gate along the route.
    // 

    //
    // Direct route
    //
    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
    pFirstPriority->insert(SafeAddRef(pDest));

    //
    // As A Second priority route to FRS in destination site
    //
    RouteToFrsInSite(
                pNextSiteId, 
                RouteTable.GetNextHopFirstPriority(),
                RouteTable.GetNextHopSecondPriority()
                );
}


void 
CServerDecision::GetRouteTable(
    const GUID& DestMachineId,
    CRouteTable& RouteTable
    )
/*++

  Routine Description:
    The routine calculates and returnes the routing table for destination Machine.

  Arguments:
    DestMachineId - identefier of the destination machine
    fRebuild - boolean flag, that indicates if internal cache should be rebuild
    pRouteTable - pointer to the routing tabel

  Returned Value:
    None. An exception is raised if the operation fails

 --*/
{
    if (NeedRebuild())
        Refresh();

    CSR lock(m_cs);

    if (NeedRebuild())
        throw exception();

    //
    // Routing server can't desclared with out RS list
    //
    ASSERT (! m_pMyMachine->HasOutFRS());

    //
    // Get the target machine information
    //
    R<const CMachine> pDest = GetMachineInfo(DestMachineId);

    //
    // The destination machine can't be the local machine
    //
    ASSERT(pDest->GetId() != m_pMyMachine->GetId());

    //
    // Check if inter-site. Both the local machine and destination should have a common 
    // site.
    //
    const GUID* pCommonSiteId = m_pMyMachine->GetCommonSite(
                                                    pDest->GetSiteIds(),
                                                    (! pDest->IsForeign()),
                                                    &m_mySites
                                                    );

    if (pCommonSiteId != NULL)
    {
        //
        // Intra site routing
        //
        RouteIntraSite(pDest.get(), RouteTable);
        return;
    }

    //
    // Inter site routing
    //
    RouteInterSite(pDest.get(), RouteTable);
}


void
CServerDecision::GetConnector(
    const GUID& foreignMachineId,
    GUID& connectorId
    )
{
    if (NeedRebuild())
        Refresh();

    CSR lock(m_cs);

    //
    // The internal data was corrupted. Before the routine gets the CS, refresh called
    // again and failed to refresh the internal data.
    //
    if (NeedRebuild())
        throw exception();
 
    //
    // Get the target foreign machine information
    //
    R<const CMachine> destMachine = GetMachineInfo(foreignMachineId);
    ASSERT(destMachine->IsForeign());

    TrTRACE(Rd, "Find connector to route to %ls", destMachine->GetName());

    const GUID* pNextSite = NULL;
    const GUID* pDestSite = NULL;
    const GUID* pNeighbourSite = NULL;
    bool fLinkGateAlongTheRoute;
    //
    // Get the best foreign site to reach the foreign machine and the
    // neighbour site that contain the connector machine
    //
    R<const CSiteLink> pLink = FindSiteLinkToDestSite(
                                                destMachine.get(),
                                                &pNextSite,
                                                &pDestSite,
                                                &pNeighbourSite,
                                                &fLinkGateAlongTheRoute
                                                );

	if (pLink.get() == NULL)
	{
        //
        // Can't route to destination site. there is no connectivity
        //
        TrWARNING(Rd, "Failed to route to destination site. There is no connectivity");
        throw bad_route(L"No connectivity to destination site.");
	}

    //
    // Get the connector machine for the foreign site
    //
    CACLSID ConnectorsIds;
    RdpGetConnectors(*pDestSite, ConnectorsIds);

    //
    // At least one connector should be exist in foreign site, otherwise
    // MSMQ can't reach the foreign machine. 
    //
    if (ConnectorsIds.cElems == 0)
    {
        TrERROR(Rd, "Failed to find possible route to foreign machine: %ls", destMachine->GetName());
        throw bad_route(L"No connectivity to destination foreign site.");
    }

    //
    // If local machine is connector by itself use it 
    //
    if (RdpIsGuidContained(ConnectorsIds, m_pMyMachine->GetId()))
    {
        //
        // local machine is connector
        //
        connectorId = m_pMyMachine->GetId();
        return;
    }

    //
    // Get the niegbour site connectors/FRS's
    //
    CACLSID NeighbourConnectors;
    RdpGetConnectors(*pNeighbourSite, NeighbourConnectors);
    RdpRandomPermutation(NeighbourConnectors);

    ASSERT(NeighbourConnectors.cElems != 0);

    //
    // Find the union of foreign site and neigbour site connectors. 
    //
    for (DWORD i = 0; i < NeighbourConnectors.cElems; ++i)
    {
        if (RdpIsGuidContained(ConnectorsIds, NeighbourConnectors.pElems[i]))
        {
            connectorId = NeighbourConnectors.pElems[i];
            return;
        }
    }

    TrERROR(Rd, "Failed to find possible route to foreign machine: %ls", destMachine->GetName());
    throw bad_route(L"No connectivity to destination foreign site.");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\lib\rdutil.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    util.cpp

Abstract:
    Implementation of utility routines for routing.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "rd.h"
#include "rdp.h"

#include "rdutil.tmh"

using namespace std;

bool
RdpIsGuidContained(
    const CACLSID& caclsid,
    const GUID& SearchGuid
    )
{
	const GUID* GuidArray = caclsid.pElems;
	for (DWORD i=0; i < caclsid.cElems; ++i)
	{
		if (GuidArray[i] == SearchGuid)
			return true;
	}

	return false;
}


bool
RdpIsCommonGuid(
    const CACLSID& caclsid1,
    const CACLSID& caclsid2
    )
{
	const GUID* GuidArray = caclsid1.pElems;
	for (DWORD i=0; i < caclsid1.cElems; ++i)
	{
		if (RdpIsGuidContained(caclsid2, GuidArray[i]))
			return true;
	}

	return false;
}
void
RdpRandomPermutation(
    CACLSID& e
    )
{
    if (e.cElems <=1)
        return;

    for(DWORD i = e.cElems; i>1;)
    {
        DWORD r = rand() % i;

        --i;
        swap(e.pElems[i], e.pElems[r]);
    }
}
   

bool
RdpIsMachineAlreadyUsed(
    const CRouteTable::RoutingInfo* pRouteList,
    const GUID& id
    )
{
    if (pRouteList == NULL)
        return false;

    //
    // BUGBUG: performance - use stl set find instead of linear search. urih 30-Apr-2000
    //
    for(CRouteTable::RoutingInfo::const_iterator it = pRouteList->begin(); it != pRouteList->end(); ++it)
    {
        if (id == (*it)->GetId())
            return true;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\cmachine.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  cmachine.h

Abstract:
    DS Stub machine object interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __CMACHINE_H__
#define __CMACHINE_H__

class CMachineObj
{
public:
    CMachineObj(
        std::wstring& Name, 
        bool DSService, 
        bool RoutingService, 
        bool DependentClient,
        bool fForeign
        );

    void
    GetProperties(
        DWORD cp,
        const PROPID aProp[],
        PROPVARIANT apVar[]
        ) const;

    
    bool IsBelongToSite(const CSiteObj* pSite);


    const std::wstring& GetMachineName(void) const 
    { 
        return m_Name; 
    };


    const GUID& GetMachineId(void) const 
    { 
        return m_Id; 
    };
    

    void AddSite(const CSiteObj* pSite) 
    { 
        m_sites.push_back(pSite); 
    };


    void AddInFrs(const CMachineObj* pMachine) 
    { 
        m_inFrs.push_back(pMachine); 
    };


    void AddOutFrs(const CMachineObj* pMachine) 
    {
        m_outFrs.push_back(pMachine);
    };


    const SiteList& GetSites(void) const 
    { 
        return m_sites;
    };


    const MachineList& GetInFrs(void) 
    { 
        return m_inFrs; 
    };


    const MachineList& GetOutFrs(void) 
    { 
        return m_outFrs; 
    };


    void RoutingService(bool f) 
    { 
        m_fRoutingService = f; 
    };


    bool RoutingService(void) const 
    { 
        return m_fRoutingService; 
    };


    void DSService(bool f) 
    { 
        m_fDSService = f;
    };


    bool DSService(void) const 
    { 
        return m_fDSService; 
    };


    void DependentClientService(bool f) 
    { 
        m_fDependentClient = f; 
    };


    bool DependentClientService(void) const 
    { 
        return m_fDependentClient; 
    };


    void Foreign(bool f) 
    { 
        m_fForeign = f;
    };


    bool Foreign(void) const 
    { 
        return m_fForeign; 
    };


private:
    void GetOutFrsProperty(PROPVARIANT& pVar) const;
    void GetInFrsProperty(PROPVARIANT& pVar) const;

private:
    std::wstring m_Name;
    GUID m_Id;
    SiteList m_sites;
    MachineList m_inFrs;
    MachineList m_outFrs;
    bool m_fDSService;
    bool m_fRoutingService;
    bool m_fDependentClient;
    bool m_fForeign;
};


class DBMachines
{
public:
    void AddMachine(CMachineObj* pMachine) 
    { 
        m_Machines[pMachine->GetMachineName()] = pMachine; 
    };


    const CMachineObj* FindMachine(std::wstring MachineName);
    const CMachineObj* FindMachine(const GUID& pMachineId);

private:
    typedef std::map<std::wstring, const CMachineObj*> MachineMap;

    MachineMap m_Machines;
};



#endif // __CMACHINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\csite.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    csite.cpp

Abstract:
    DS stub - site object implementation

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include <dsstubp.h>
#include <mqprops.h>

#include "csite.tmh"

using namespace std;

DBSite g_siteDataBase;

CSiteObj::CSiteObj(
    wstring Name, 
    bool fForeign
    ) :
    m_Name(Name),
    m_fForeign(fForeign)
{
    UuidCreate(&m_Id);
}


const CSiteLinkObj* 
CSiteObj::GetSiteLink(CSiteObj* pNeighbor)
{
    for(SiteLinkList::iterator it = m_SiteLink.begin(); it != m_SiteLink.end(); ++it)
    {
        const CSiteLinkObj* pSiteLink = *it;
        if (pSiteLink->IsSiteLinkBetween(this, pNeighbor))
            return pSiteLink;
    }

    return NULL;
}

const CSiteObj* 
DBSite::FindSite(
    const wstring& SiteName
    ) const
{
    SiteMap::const_iterator it = m_Sites.find(SiteName);
    if (it ==  m_Sites.end())
        return NULL;

    return it->second;
}


const CSiteObj* 
DBSite::FindSite(
    const GUID& id
    ) const
{
    for (SiteMap::const_iterator it = m_Sites.begin(); it != m_Sites.end(); ++it)
    {
        if (it->second->GetSiteId() == id)
            return it->second;
    }
        
    return NULL;
}


enum SitePropValue
{
    eSiteName = 1,
    eSiteForeign
};

PropertyValue SiteProperties[] = {
    { L"PROPID_S_PATHNAME",      eSiteName },
    { L"PROPID_S_FOREIGN",       eSiteForeign },
};

void CreateSiteObject(void)
{
    wstring SiteName;
    bool fForeign = false;

    GetNextLine(g_buffer);
    while(!g_buffer.empty())
    {
        //
        // New object
        //
        if (g_buffer.compare(0,1,L"[") == 0)
            break;

        //
        // line must be <property_name> = <property_value>
        //
        wstring PropName;
        wstring PropValue;
        if (!ParsePropertyLine(g_buffer, PropName, PropValue))
        {
            GetNextLine(g_buffer);
            continue;
        }


        switch(ValidateProperty(PropName, SiteProperties, TABLE_SIZE(SiteProperties)))
        {
            case  eSiteName:
                SiteName = PropValue;
                RemoveTralingBlank(SiteName);
                break;

            case eSiteForeign:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fForeign = true;
                }
                break;

            default:
                throw exception();

        }
        GetNextLine(g_buffer);
    }

    if (SiteName.empty())
    {
        FileError("Site Name is mandatory. Ignore the site");
        throw exception();
    }

    CSiteObj* pSite = new CSiteObj(SiteName, fForeign); 
    g_siteDataBase.AddSite(pSite);
}


void
CSiteObj::GetProperties(
    DWORD cp,
    const PROPID aProp[],
    PROPVARIANT apVar[]
    ) const
{
    for (DWORD i = 0; i < cp ; ++i)
    {
        switch (aProp[i])
        {
            case PROPID_S_PATHNAME:
                apVar[i].pwszVal = new WCHAR[wcslen(m_Name.data()) + 1];
                apVar[i].vt = VT_LPWSTR;

                swprintf(apVar[i].pwszVal, L"%s", m_Name.data());
                break;

            case PROPID_S_FOREIGN:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fForeign;
                break;

            case PROPID_S_GATES:
            {
                apVar[i].cauuid.pElems =new GUID[m_SiteGates.size()];
                apVar[i].cauuid.cElems = 0;

                for(MachineList::iterator it = m_SiteGates.begin(); it != m_SiteGates.end(); ++it)
                {
                    const CMachineObj* pMachine = *it;
                    apVar[i].cauuid.pElems[apVar[i].cauuid.cElems] = pMachine->GetMachineId();
                    ++apVar[i].cauuid.cElems;
                }

                break;
            }

            default:
                throw exception();
        }
    }
}

const CSiteObj* FindSite(const wstring& SiteName)
{
    return g_siteDataBase.FindSite(SiteName);
}

const CSiteObj* FindSite(const GUID& pSiteId)
{
    return g_siteDataBase.FindSite(pSiteId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\cmachine.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    cmachine.cpp

Abstract:
    DS stub - machine object implementation

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstubp.h"
#include "csite.h"
#include "cmachine.h"
#include "mqprops.h"

#include "cmachine.tmh"

using namespace std;

static DBMachines s_machinesDataBase;

CMachineObj::CMachineObj(
    wstring& Name, 
    bool DSService, 
    bool RoutingService, 
    bool DependentClient,
    bool fForeign
    ) :
    m_Name(Name),
    m_fDSService(DSService),
    m_fRoutingService(RoutingService),
    m_fDependentClient(DependentClient),
    m_fForeign(fForeign)
{
    UuidCreate(&m_Id);
}


bool CMachineObj::IsBelongToSite(const CSiteObj* pSite)
{
    for (SiteList::iterator it = m_sites.begin(); it != m_sites.end(); ++it)
    {
        if (*it == pSite)
            return true;
    }

    return false;
}

void
CMachineObj::GetOutFrsProperty(
    PROPVARIANT& pVar
    ) const
{
    DWORD index = 0;
    GUID* pElems = NULL;

    if (!m_outFrs.empty())
    {
        pElems = new GUID[m_outFrs.size()];
        for (MachineList::iterator it = m_outFrs.begin(); it != m_outFrs.end(); ++it)
        {
            const CMachineObj* pMachine = *it;
            pElems[index] = pMachine->GetMachineId();

            ++index;
        }

        ASSERT(index == m_outFrs.size());
    }

    pVar.cauuid.cElems = index;
    pVar.cauuid.pElems = pElems;

    pVar.vt = (VT_CLSID|VT_VECTOR);
}


void
CMachineObj::GetInFrsProperty(
    PROPVARIANT& pVar
    ) const
{
    DWORD index = 0;
    GUID* pElems = NULL;

    if (!m_inFrs.empty())
    {
        pElems = new GUID[m_inFrs.size()];
        for (MachineList::iterator it = m_inFrs.begin(); it != m_inFrs.end(); ++it)
        {
            const CMachineObj* pMachine = *it;
            pElems[index] = pMachine->GetMachineId();

            ++index;
        }

        ASSERT(index == m_inFrs.size());
    }

    pVar.cauuid.cElems = index;
    pVar.cauuid.pElems = pElems;

    pVar.vt = (VT_CLSID|VT_VECTOR);
}


void
CMachineObj::GetProperties(
    DWORD cp,
    const PROPID aProp[],
    PROPVARIANT apVar[]
    ) const
{
    for (DWORD i = 0; i < cp ; ++i)
    {
        switch (aProp[i])
        {
            case PROPID_QM_SITE_IDS:
            {
                apVar[i].cauuid.pElems =new GUID[m_sites.size()];
                apVar[i].cauuid.cElems = 0;

                for(SiteList::iterator it = m_sites.begin(); it != m_sites.end(); ++it)
                {
                    const CSiteObj* pSite = *it;
                    apVar[i].cauuid.pElems[apVar[i].cauuid.cElems] = pSite->GetSiteId();
                    ++apVar[i].cauuid.cElems;
                }

                break;
            }

            case PROPID_QM_MACHINE_ID: 
                apVar[i].puuid = new GUID;
                apVar[i].vt = VT_CLSID;
        
                memcpy(apVar[i].puuid, &m_Id, sizeof(GUID));
                break;

            case PROPID_QM_PATHNAME:
                apVar[i].pwszVal = new WCHAR[wcslen(m_Name.data()) + 1];
                apVar[i].vt = VT_LPWSTR;

                wcscpy(apVar[i].pwszVal, m_Name.data());
                break;


            case PROPID_QM_OUTFRS:
                GetOutFrsProperty(apVar[i]);
                break;

            case PROPID_QM_INFRS:
                GetInFrsProperty(apVar[i]);
                break;

            case PROPID_QM_FOREIGN:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fForeign;
                break;

            case PROPID_QM_SERVICE_ROUTING:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fRoutingService;
                break;

            case PROPID_QM_SERVICE_DSSERVER:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fDSService;
                break;

            case PROPID_QM_SERVICE_DEPCLIENTS:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fDependentClient;
                break;

            default:
                throw exception();
        }
    }
}


const CMachineObj* 
DBMachines::FindMachine(
    wstring MachineName
    )
{
    MachineMap::iterator it = m_Machines.find(MachineName);
    if (it ==  m_Machines.end())
        return NULL;

    return it->second;
}


const CMachineObj* 
DBMachines::FindMachine(
    const GUID& id
    )
{
    for (MachineMap::iterator it = m_Machines.begin(); it != m_Machines.end(); ++it)
    {
        if (it->second->GetMachineId() == id)
            return it->second;
    }
        
    return NULL;
}

enum MachinePropValue
{
    eName = 1,
    eSiteName,
    eOutFrs,
    eInFrs,
    eRouting,
    eDSServer,
    eDependentClient,
    eForeign,
};

PropertyValue MachineProperties[] = {
    { L"PROPID_QM_PATHNAME",             eName },
    { L"PROPID_QM_SITE_NAME",            eSiteName },       
    { L"PROPID_QM_OUTFRS",               eOutFrs },
    { L"PROPID_QM_INFRS",                eInFrs },
    { L"PROPID_QM_SERVICE_ROUTING",      eRouting },
    { L"PROPID_QM_SERVICE_DSSERVER",     eDSServer },
    { L"PROPID_QM_SERVICE_DEPCLIENTS",   eDependentClient },
    { L"PROPID_QM_FOREIGN",              eForeign },
};


static
void 
ParseSitesProperty(
    CMachineObj* pMachine, 
    wstring& SitesName
    )
{
    while(!SitesName.empty())
    {
        wstring siteName = GetNextNameFromList(SitesName);

        if (!siteName.empty())
        {
            CSiteObj* pSite = const_cast<CSiteObj*>(FindSite(siteName));
            if (pSite == NULL)
            {
                printf("Site %s doesn't exist. Can't be add Machine %s\n",
                        siteName, pMachine->GetMachineName());
                continue;
            }
            
            pSite->AddMachine(pMachine);
            pMachine->AddSite(pSite);
        }
    }
}


static
void
ParseInOutFrsProperty(
    CMachineObj* pMachine, 
    wstring& InOutFrs,
    bool fOutFrs
    )
{
    while(!InOutFrs.empty())
    {
        wstring FrsName = GetNextNameFromList(InOutFrs);

        if (!FrsName.empty())
        {
            const CMachineObj* pFrsMachine = s_machinesDataBase.FindMachine(FrsName);
            if (pFrsMachine == NULL)
            {
                printf("IN FRS %s doesn't exist. Can't be add Machine %s\n",
                        FrsName, pMachine->GetMachineName());
                continue;
            }
            
            if (!pFrsMachine->RoutingService())
            {
                printf("Machine %s cannot use as InFrs. It isn't Routing Service\n", FrsName);
                continue;
            }

            if (fOutFrs)
            {
                pMachine->AddOutFrs(pFrsMachine);
            }
            else
            {
                pMachine->AddInFrs(pFrsMachine);
            }
        }

    }
}


void CreateMachineObject(void)
{
    wstring MachineName;
    wstring SitesName;
    wstring OutFrs;
    wstring InFrs;

    bool fRoutingService = false;  
    bool fSetRoutingService = false;

    bool fDSService = false;
    bool fSetDSService  = false;

    bool fDependentClient = false;
    bool fSetDependentClient = false;

    bool fForeign = false;
    bool fSetForeign = false;

    GetNextLine(g_buffer);
    while(!g_buffer.empty())
    {
        //
        // New object
        //
        if (g_buffer.compare(0,1,L"[") == 0)
            break;

        //
        // line must be <property_name> = <property_value>
        //
        wstring PropName;
        wstring PropValue;
        if (!ParsePropertyLine(g_buffer, PropName, PropValue))
        {
            GetNextLine(g_buffer);
            continue;
        }

        switch(ValidateProperty(PropName, MachineProperties, TABLE_SIZE(MachineProperties)))
        {
            case  eName:
                MachineName = PropValue;
                RemoveTralingBlank(MachineName);
                break;

            case  eSiteName:
                SitesName = PropValue;
                break;

            case eOutFrs:
                OutFrs = PropValue;
                break;
    
            case eInFrs:
                InFrs = PropValue;
                break;

            case eRouting:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fRoutingService = true;
                }
                fSetRoutingService = true;
                break;

            case eDSServer:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fDSService = true;
                }
                fSetDSService = true;
                break;

            case eDependentClient:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fDependentClient = true;
                }
                fSetDependentClient = true;
                break;

            case eForeign:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fForeign = true;
                }
                fSetForeign = true;
                break;

            default:
                FileError("Illegal Machine Property");
        }

        GetNextLine(g_buffer);
    }

    if (MachineName.empty())
    {
        FileError("Machine Name is mandatory. Ignore the Machine decleration");
        throw exception();
    }

    CMachineObj* pMachine = const_cast<CMachineObj*>(s_machinesDataBase.FindMachine(MachineName));
    if (pMachine == NULL)
    {
        pMachine = new CMachineObj(
                            MachineName, 
                            fDSService, 
                            fRoutingService,
                            fDependentClient, 
                            fForeign
                            ); 
    }
    else
    {
        if (fSetRoutingService) 
            pMachine->RoutingService(fRoutingService);

        if (fSetDSService) 
            pMachine->DSService(fDSService);
        
        if (fSetDependentClient) 
            pMachine->DependentClientService(fDependentClient);
        
        if (fSetForeign) 
            pMachine->Foreign(fForeign);
    }

    //
    // Parse the site property
    //
    ParseSitesProperty(pMachine, SitesName);
    if (pMachine->GetSites().empty())
    {
        FileError("Machine must be joined atleast to 1 site");
        delete pMachine;
        return;
    }

    //
    // Insert machine to the machine DB
    //
    s_machinesDataBase.AddMachine(pMachine);

    //
    // Parse In/Out FRS of machine
    //
    ParseInOutFrsProperty(pMachine, OutFrs, true);
    ParseInOutFrsProperty(pMachine, InFrs, false);
}


const CMachineObj* FindMachine(const wstring& MachineName)
{
    return s_machinesDataBase.FindMachine(MachineName);
}

const CMachineObj* FindMachine(const GUID& pMachineId)
{
    return s_machinesDataBase.FindMachine(pMachineId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\csite.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  csite.h

Abstract:
    DS Stub site object interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __CSITE_H___
#define __CSITE_H___


class CSiteObj
{
public:
    CSiteObj(
        std::wstring name, 
        bool fForeign
        );

    void
    GetProperties(
        DWORD cp,
        const PROPID aProp[],
        PROPVARIANT aVar[] 
        ) const;

    const std::wstring& GetSiteName(void) const 
    {
        return m_Name;
    };


    const GUID& GetSiteId(void) const
    { 
        return m_Id; 
    };


    void AddSiteGate(CMachineObj* pMachine) 
    { 
        m_SiteGates.push_back(pMachine); 
    };


    void AddMachine(CMachineObj* pMachine) 
    { 
        m_Machines.push_back(pMachine); 
    };


    void AddSiteLink(CSiteLinkObj* pSiteLink) 
    {
        m_SiteLink.push_back(pSiteLink); 
    };


    bool IsForeign(void) const 
    { 
        return m_fForeign; 
    };

    
    const MachineList& GetSiteMachines(void) const
    {
        return m_Machines;
    }


    const CSiteLinkObj* GetSiteLink(CSiteObj* pNeighbor);
private:
    std::wstring m_Name;
    GUID m_Id;
    MachineList m_SiteGates;
    MachineList m_Machines;
    SiteLinkList m_SiteLink;

    bool m_fForeign;
};

class DBSite
{
public:
    void AddSite(CSiteObj* pSite) 
    { 
        m_Sites[pSite->GetSiteName()] = pSite; 
    };

    const CSiteObj* GetFirstSite(void) const
    {
        m_it = m_Sites.begin();
        if (m_it != m_Sites.end())
            return m_it->second;

        return NULL;
    }


    const CSiteObj* GetNextSite(void) const
    {
        ++m_it;
        if (m_it != m_Sites.end())
            return m_it->second;

        return NULL;
    }


    const CSiteObj* FindSite(const std::wstring& SiteName) const;
    const CSiteObj* FindSite(const GUID& pSiteId) const;

private:
    typedef std::map<std::wstring, const CSiteObj*> SiteMap;

    SiteMap m_Sites;
    mutable SiteMap::const_iterator m_it;
};

extern DBSite g_siteDataBase;


#endif //__CSITE_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\csitelink.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    csitelink.cpp

Abstract:
    DS stub - site-link object implementation

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstub.h"
#include "dsstubp.h"

#include "csitelink.tmh"

using namespace std;

DBSiteLink g_siteLinkDataBase;


CSiteLinkObj::CSiteLinkObj(
    const CSiteObj* pNeighbor1, 
    const CSiteObj* pNeighbor2,
    DWORD cost
    ) :
    m_pNeighbor1(pNeighbor1),
    m_pNeighbor2(pNeighbor2),
    m_cost(cost)
{
    UuidCreate(&m_Id);
}



enum SiteLinkPropValue
{
    eNeighbor1,
    eNeighbor2,
    eCost,
    eGates
};


PropertyValue SiteLinkProperties[] = {
    { L"PROPID_L_NEIGHBOR1",      eNeighbor1 },
    { L"PROPID_L_NEIGHBOR2",      eNeighbor2 },
    { L"PROPID_L_COST",           eCost },
    { L"PROPID_L_GATES",          eGates },
};


static
void 
ParseSiteGates(
    CSiteLinkObj* pSiteLink, 
    wstring& SiteGates,
    CSiteObj* pNeighbor1, 
    CSiteObj* pNeighbor2
    )
{
    while(!SiteGates.empty())
    {
        wstring siteGateName = GetNextNameFromList(SiteGates);

        if (!siteGateName.empty())
        {
            CMachineObj* pMachine = const_cast<CMachineObj*>(FindMachine(siteGateName));
            if (pMachine == NULL)
            {
                printf(" Site Gate machine %s doesn't exist.\n", siteGateName);
                continue;
            }
            
            pSiteLink->AddSiteGates(pMachine);
            if  (pMachine->IsBelongToSite(pNeighbor1))
            {
                pNeighbor1->AddSiteGate(pMachine);
            }
            else
            {
                if (pMachine->IsBelongToSite(pNeighbor2))
                {
                    pNeighbor2->AddSiteGate(pMachine);
                }
                else
                {
                    FileError("Site Gate Machine doesn't belong to any of the sites");
                }
            }
        }
    }
}


void CreateSiteLinkObject(void)
{
    DWORD Cost =1;
    wstring Neighbor1;
    wstring Neighbor2;
    wstring SiteGates;

    GetNextLine(g_buffer);
    while(!g_buffer.empty())
    {
        //
        // New object
        //
        if (g_buffer.compare(0,1,L"[") == 0)
            break;

        wstring PropName;
        wstring PropValue;
        if (!ParsePropertyLine(g_buffer, PropName, PropValue))
        {
            GetNextLine(g_buffer);
            continue;
        }

        switch(ValidateProperty(PropName, SiteLinkProperties, TABLE_SIZE(SiteLinkProperties)))
        {
            case  eNeighbor1:
                Neighbor1 = PropValue;
                RemoveBlanks(Neighbor1);
                break;

            case  eNeighbor2:
                Neighbor2 = PropValue;
                RemoveBlanks(Neighbor2);
                break;

            case eCost:
                Cost = _wtoi(PropValue.c_str());
                break;

            case eGates:
                SiteGates = PropValue;
                break;

            default:
                ASSERT(0);
        }
        GetNextLine(g_buffer);
    }

    if (Neighbor1.empty() || Neighbor2.empty())
    {
        FileError("Neighbor1 & Negihbor2 are mandatory for Site Link. Ignore the site Link");
        return;
    }

    CSiteObj* pNeighbor1 = const_cast<CSiteObj*>(FindSite(Neighbor1)); 
    CSiteObj* pNeighbor2 = const_cast<CSiteObj*>(FindSite(Neighbor2));
    
    if ((pNeighbor1 == NULL) || (pNeighbor2 == NULL))
    {
        FileError("Illegal Site member");
        return;
    }

    
    CSiteLinkObj* pSiteLink = const_cast<CSiteLinkObj*>(pNeighbor1->GetSiteLink(pNeighbor2));

    if(pSiteLink == NULL)
    {
        pSiteLink = new CSiteLinkObj(pNeighbor1, pNeighbor2, Cost);

        pNeighbor1->AddSiteLink(pSiteLink);
        pNeighbor2->AddSiteLink(pSiteLink);

        g_siteLinkDataBase.AddSiteLink(pSiteLink);
    }

    //
    // Parse the Site Gates
    //
    ParseSiteGates(pSiteLink, SiteGates, pNeighbor1, pNeighbor2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\csitelink.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  csite.h

Abstract:
    DS Stub site link object interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once 


#ifndef __CSITELINK_H___
#define __CSITELINK_H___


class CSiteLinkObj
{
public:
    CSiteLinkObj(    
        const CSiteObj* pNeighbor1, 
        const CSiteObj* pNeighbor2,
        DWORD cost
        );

    
    BOOL 
    IsSiteLinkBetween(
        const CSiteObj* pNeighbor1,
        const CSiteObj* pNeighbor2
        ) const;

    
    void AddSiteGates(const CMachineObj* pMachine) 
    { 
        m_SiteGates.push_back(pMachine); 
    };


    const MachineList& GetSiteLinkGates(void) const 
    {
        return m_SiteGates; 
    };


    const GUID& GetSiteLinkId(void) const
    {
        return m_Id;
    }

    const CSiteObj* GetNeighbor1(void) const
    {
        return m_pNeighbor1;
    }


    const CSiteObj* GetNeighbor2(void) const
    {
        return m_pNeighbor2;
    }


    const MachineList& GetSiteGates(void) const
    {
        return m_SiteGates;
    }

    
    DWORD GetCost(void) const
    {
        return m_cost;
    }


private:
    GUID m_Id;
    const CSiteObj* m_pNeighbor1;
    const CSiteObj* m_pNeighbor2;
    MachineList m_SiteGates;
    DWORD m_cost;
};

inline
BOOL 
CSiteLinkObj::IsSiteLinkBetween(
    const CSiteObj* pNeighbor1,
    const CSiteObj* pNeighbor2
    ) const 
{
    return (((pNeighbor1 == m_pNeighbor1) && (pNeighbor2 == m_pNeighbor2)) ||
            ((pNeighbor1 == m_pNeighbor2) && (pNeighbor2 == m_pNeighbor1)));
}


struct sitelink_less : public std::binary_function<const CSiteLinkObj*, const CSiteLinkObj*, bool> 
{
    bool operator()(const CSiteLinkObj* k1, const CSiteLinkObj* k2) const
    {
        return ((k1->GetSiteLinkId() == k2->GetSiteLinkId()) ? false : true);
    }
};


class DBSiteLink
{
public:
    DBSiteLink() :
      m_it(m_SiteLink.begin())
    {
    }


    void AddSiteLink(CSiteLinkObj* pSite) 
    { 
        m_SiteLink.insert(pSite); 
    };


    const CSiteLinkObj* GetFirstSiteLink(void) const
    {
        m_it = m_SiteLink.begin();
        if (m_it != m_SiteLink.end())
            return *m_it;

        return NULL;
    }


    const CSiteLinkObj* GetNextSiteLink(void) const
    {
        ++m_it;
        if (m_it != m_SiteLink.end())
            return *m_it;

        return NULL;
    }


private:
    typedef std::set<const CSiteLinkObj*, sitelink_less> SiteLinkMap;

    SiteLinkMap m_SiteLink;
    mutable SiteLinkMap::const_iterator m_it;
};


extern DBSiteLink g_siteLinkDataBase;

#endif //__CSITELINK_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\dsstub.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  dsstub.h

Abstract:
  DS Stub interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once 

#ifndef __DSSTUB_H__
#define __DSSTUB_H__

void
DSStubInitialize(
    LPCWSTR InitFilePath
    );


const GUID& GetMachineId(LPCWSTR MachineName);
void RemoveLeadingBlank(std::wstring& str);
void RemoveTralingBlank(std::wstring& str);


inline void RemoveBlanks(std::wstring& str)
{
    RemoveLeadingBlank(str);
    RemoveTralingBlank(str);
};


#endif // __DSSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\dsstubp.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    dsstubp.cpp

Abstract:
    DS stub - private routines using for reading the ini file

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstub.h"
#include "dsstubp.h"

#include "dsstubp.tmh"

using namespace std;

wstring g_buffer;
DWORD lineNo = 0;
wfstream iFile;


DWORD 
ValidateProperty(
    wstring buffer, 
    PropertyValue propValue[],
    DWORD noProps
    )
{
    WCHAR* str1 = const_cast<WCHAR*>(buffer.data());
    for (DWORD i =0; i < noProps; ++i)
    {
        if (_wcsnicmp(str1, propValue[i].PropName, wcslen(propValue[i].PropName)) != 0)
            continue;

        wstring temp = buffer.substr(wcslen(propValue[i].PropName));
        if (temp.find_first_not_of(L" \t") == temp.npos)
            return propValue[i].PropValue;
    }

    TrERROR(AdStub,"Illegal or Unsuported Property %ls",  str1);
    throw exception();
}

void RemoveLeadingBlank(wstring& str)
{
    DWORD_PTR pos = str.find_first_not_of(L" \t");
    if (pos != str.npos)
    {
        str = str.substr(pos);
        return;
    }

    str.erase();
}

void RemoveTralingBlank(wstring& str)
{
    DWORD_PTR endpos = str.find_first_of(L" \t");
    str = str.substr(0, endpos);
}

void GetNextLine(wstring& buffer)
{
    buffer.erase();
    while (!iFile.eof())
    {
        ++lineNo;

        getline(iFile, buffer);

        RemoveLeadingBlank(buffer);

        //
        // Ignore blank line
        //
        if (buffer.empty())
            continue;

        //
        // ignore comment
        //
        if (buffer.compare(0,2,L"//") == 0)
            continue;

        return;
    }
}


void
DspIntialize(
    LPCWSTR InitFilePath
    )
{
    char filePath[256];
    sprintf(filePath, "%ls", InitFilePath);

    iFile.open(filePath, ios::in);
    if (!iFile.is_open())
    {
        printf("Open DS initialization file Failed. %s\n", strerror(errno));
        throw exception();
    }

    lineNo = 0;
}


void FileError(LPSTR msg)
{
    TrERROR(AdStub, "%s. Line %d", msg, lineNo);
}


BOOL 
ParsePropertyLine(
    wstring& buffer,
    wstring& PropName,
    wstring& PropValue
    )
{
    //
    // line must be <property_name> = <property_value>
    //
    DWORD_PTR pos = buffer.find_first_of(L"=");
    if (pos == g_buffer.npos)
    {
        FileError("wrong site propery - Ignore it");
        return FALSE;
    }

    PropName = buffer.substr(0, pos-1);
    PropValue = buffer.substr(g_buffer.find_first_not_of(L" \t", pos+1));
    if(PropValue.empty())
    {
        FileError("wrong site propery - Ignore it");
        return FALSE;
    }
    
    return TRUE;
}

wstring
GetNextNameFromList(
      wstring& strList
      )
{
    wstring str;

    DWORD_PTR CommaPos = strList.find_first_of(L",");
    str = strList.substr(0, CommaPos);

    if (CommaPos == strList.npos)
    {
        strList.erase();
    }
    else
    {
        strList = strList.substr(CommaPos+1);
    }

    RemoveBlanks(str);
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\dsstub.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    dsstub.cpp

Abstract:
    DS stub - intilization

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstub.h"
#include "dsstubp.h"

#include "dsstub.tmh"

using namespace std;

enum ObjectTypes              
{
    eSite = 1,
    eMachine,
    eSiteLink,
    eNone
};

PropertyValue ObjectType[] = {
    { L"[site]",      eSite },
    { L"[machine]",   eMachine },
    { L"[sitelink]",    eSiteLink }
};


inline ObjectTypes GetObjectType(const wstring& buffer)
{
    return static_cast<ObjectTypes>(ValidateProperty(buffer, ObjectType, TABLE_SIZE(ObjectType)));
}

void
DSStubInitialize(
    LPCWSTR InitFilePath
    )
{
    DspIntialize(InitFilePath);

    GetNextLine(g_buffer);
    while (!g_buffer.empty())
    {
        switch (GetObjectType(g_buffer))
        {
            case eSite:
                CreateSiteObject();
                break;

            case eMachine:
                CreateMachineObject();
                break;

            case eSiteLink:
                CreateSiteLinkObject();
                break;

            default:
                FileError("Illegal Object Type");
                throw exception();

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\dsstubp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  dsstubp.h

Abstract:
    DS Stub private functions definition

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __DSSTUBP_H__
#define __DSSTUBP_H__



class CSiteObj;
typedef std::list<const CSiteObj*>  SiteList;

class CMachineObj;
typedef std::list<const CMachineObj*>  MachineList;

class CSiteLinkObj;
typedef std::list<const CSiteLinkObj*> SiteLinkList;


#include "csite.h"
#include "cmachine.h"
#include "csitelink.h"


const TraceIdEntry AdStub = L"AD stub";
extern std::wstring g_buffer;

struct PropertyValue
{
    WCHAR PropName[32];
    DWORD PropValue;
};


void 
DspIntialize(
    LPCWSTR InitFilePath
    );

void 
FileError(
    LPSTR msg
    );

void 
GetNextLine(
    std::wstring& buffer
    );

DWORD 
ValidateProperty(
    std::wstring buffer, 
    PropertyValue propValue[], 
    DWORD noProps
    );

void 
RemoveLeadingBlank(
    std::wstring& str
    );

void 
RemoveTralingBlank(
   std::wstring& str
   );


BOOL 
ParsePropertyLine(
    std::wstring& buffer,
    std::wstring& PropName,
    std::wstring& PropValue
    );


std::wstring 
GetNextNameFromList(
    std::wstring& strList
    );


void 
CreateSiteObject(
    void
    );

void 
CreateMachineObject(
    void
    );

void 
CreateSiteLinkObject(
    void
    );

const CSiteObj* 
FindSite(
    const std::wstring& SiteName
    );

const CSiteObj* 
FindSite(
    const GUID& pSiteId
    );

const CMachineObj* 
FindMachine(
    const std::wstring& MachineName
    );

const CMachineObj* 
FindMachine(
    const GUID& pMachineId
    );


#endif //__DSSTUBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\rdtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RdTest.cpp

Abstract:
    Routing Decision library test

Author:
    Uri Habusha (urih) 10-Apr-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Rd.h"
#include "dsstub.h"

#include "RdTest.tmh"

using namespace std;


const TraceIdEntry RdTest = L"Routing Decision Test";
const DWORD RoutingRebuildInterval = 60 * 1000;
static GUID s_SourceMachineId;

const GUID&
McGetMachineID(
    void
    )
{
    return s_SourceMachineId;
}



static void Usage()
{
    printf("Usage: RdTest <test ini file> \n");
    printf("\ttest ini file - Ini file that describes the DS, routing source and");
    printf("\t\tdestination and expected result");
    printf("\n");
    printf("Example, RdTest intarSiteRouting.ini\n");
    exit(-1);

} // Usage


bool 
GetTestParameters(
    LPCWSTR FilePath,
    LPWSTR DsIniFile,
    DWORD& NoOfTest,
    bool& fServer
    )
{
    
    GetPrivateProfileString(
        L"TestParameters",
        L"DSFile",
        L"ERROR",
        DsIniFile,
        256,
        FilePath
        );
    
    if(wcscmp(DsIniFile, L"ERROR") == 0)
        return false;
    
    WCHAR Buffer[256];
    GetPrivateProfileString(
        L"TestParameters",
        L"NoOfTest",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );

    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;

    NoOfTest = _wtol(Buffer);

    GetPrivateProfileString(
        L"TestParameters",
        L"RoutingType",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );

    if(_wcsicmp(Buffer, L"SERVER") == 0)
    {
        fServer = true;
    }
    else if (_wcsicmp(Buffer, L"CLIENT") == 0)
    {
        fServer = false;
    }
    else
    {
        return false;
    }

    return true;
}


bool
GetRouteTestParameters(
    LPCWSTR FilePath,
    LPCWSTR TestAppl,
    wstring& SourceMachine,
    wstring& DestinationMachine,
    bool& fRouteTest
    )
{
    WCHAR Buffer[256];
    
    GetPrivateProfileString(
        TestAppl,
        L"source",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;
    
    SourceMachine = Buffer;

    GetPrivateProfileString(
        TestAppl,
        L"Destination",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;

    DestinationMachine = Buffer;

    //
    // Get test type. Can be route table or connector
    //
    fRouteTest = true;
    GetPrivateProfileString(
        TestAppl,
        L"TestType",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );

    if(_wcsicmp(Buffer, L"CONNECTOR") == 0)
        fRouteTest = false;

    return true;
}


bool
CheckResult(
    wstring Expected,
    CRouteTable::RoutingInfo& routeInfo
    )
{
    DWORD NoOfMachines = 0;

    RemoveBlanks(Expected);
    DWORD PrevPos = (DWORD)(Expected.empty() ? Expected.npos : 0);

    while(PrevPos != Expected.npos)
    {
        DWORD_PTR pos = Expected.find_first_of(L',', PrevPos);
        wstring  RouteMachine= Expected.substr(PrevPos, (pos-PrevPos));
        RemoveBlanks(RouteMachine);
        PrevPos = (DWORD)(pos + ((pos != Expected.npos) ? 1 : 0)); 

        for(CRouteTable::RoutingInfo::iterator it = routeInfo.begin(); it != routeInfo.end(); ++it)
        {
            R<const CRouteMachine> pRoute = *it;
            if (_wcsicmp(pRoute->GetName(), RouteMachine.data()) == 0)
                break;
        }
        if (it == routeInfo.end())
            return false;

        ++NoOfMachines;
    }

    if (NoOfMachines != routeInfo.size())
        return false;

    return true;
}


void 
PrintRouteMachineName(
    const CRouteTable::RoutingInfo* routeInfo
    )
{
    for(CRouteTable::RoutingInfo::const_iterator it = routeInfo->begin(); it != routeInfo->end(); ++it)
    {
        printf("%ls ",(*it)->GetName());
    }
}


bool
GetExpectedResult(
    LPCWSTR FilePath,
    LPCWSTR TestAppl,
    wstring TestResult[2]
    )
{
    WCHAR Buffer[256];
    
    GetPrivateProfileString(
        TestAppl,
        L"firstPriority",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;
    
    TestResult[0] = Buffer;

    GetPrivateProfileString(
        TestAppl,
        L"SecondPriority",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") != 0)
        TestResult[1] = Buffer;

    return true;
}


void
CheckTestResult(
    LPCWSTR TestFilePath,
    LPCWSTR TestAppl,
    CRouteTable& RouteTable
    )
{
    bool fTestPass = true;

    wstring ExpectedResult[2];
    bool fSucc = GetExpectedResult(
                    TestFilePath,
                    TestAppl,
                    ExpectedResult
                    );
    if (!fSucc)
    {
        TrERROR(RdTest, "Can't retreive the test result for test %ls", TestAppl);
        throw exception();
    }

    bool f;
    f = CheckResult(ExpectedResult[0], *RouteTable.GetNextHopFirstPriority());
    if (!f)
    {
        fTestPass = false;
        printf("unmached result for first priority routing:\n");
        printf("\tExpected: %ls\n", ExpectedResult[0].data());
        printf("Getting Result:");
        PrintRouteMachineName(RouteTable.GetNextHopFirstPriority());
        printf("\n");
    }

    f = CheckResult(ExpectedResult[1], *RouteTable.GetNextHopSecondPriority());
    if (!f)
    {
        fTestPass = false;
        printf("unmached result for Second priority routing:\n");
        printf("\tExpected: %S\n", ExpectedResult[1].data());
        printf("\tGetting Result:");
        PrintRouteMachineName(RouteTable.GetNextHopSecondPriority());
        printf("\n");
    }

    if (fTestPass)
    {
        printf("TEST PASS\n");
    }
    else
    {
        printf("TEST FAILED\n");
        throw exception();
    }
}


void
CheckConnectorTestResult(
    LPCWSTR TestFilePath,
    LPCWSTR TestAppl,
    const GUID& ConnectorId
    )
{
    bool fTestPass = true;

    WCHAR ConnectorName[256];
    
    GetPrivateProfileString(
        TestAppl,
        L"ConnectorName",
        L"ERROR",
        ConnectorName,
        256,
        TestFilePath
        );
    if(wcscmp(ConnectorName, L"ERROR") == 0)
    {
        TrERROR(RdTest, "Can't retreive the test result for test %ls", TestAppl);
        throw exception();
    }

    if (GetMachineId(ConnectorName) != ConnectorId)
    {
        fTestPass = false;
        printf("unmached result for Connector machine:\n");
        printf("\tExpected: %ls\n", ConnectorName);
        printf("\n");
    }

    if (fTestPass)
    {
        printf("TEST PASS\n");
    }
    else
    {
        printf("TEST FAILED\n");
        throw exception();
    }
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Routing Decision library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    if (argc != 2)
        Usage();

    TrInitialize();
    TrRegisterComponent(&RdTest, 1);

    //
    // convert ini file name from UNICODE to ACII
    //
    WCHAR DsIniFile[256];
    DWORD NoOfTest;
    bool fServer;
    bool fSucc = GetTestParameters(argv[1], DsIniFile, NoOfTest, fServer);
    if(!fSucc)
    {
        TrERROR(RdTest, "Wrong test ini file. Can't find DS init file or Number of tests");
        exit(-1);
    }

    try
    {
        DSStubInitialize(DsIniFile);
    }
    catch (const exception&)
    {
        TrERROR(RdTest, "Failed to initialize the DS stub. Please Check the Ini file %ls", DsIniFile);
        return -1;
    }

    CTimeDuration rebuildInterval(RoutingRebuildInterval* CTimeDuration::OneMilliSecond().Ticks());
    RdInitialize(fServer, rebuildInterval);

    wstring PrevSourceMachine;
    try
    {
        for(DWORD TestIndex = 1;TestIndex <= NoOfTest; ++TestIndex)
        {
            WCHAR TestAppl[30];
            swprintf(TestAppl, L"Test%d", TestIndex);

            //
            // Get the Source Machine from test ini file
            //
            wstring SourceMachine;
            wstring DestinationMachine;
            bool fRouteTest;
            bool fSucc = GetRouteTestParameters(
                            argv[1],
                            TestAppl,
                            SourceMachine,
                            DestinationMachine,
                            fRouteTest
                            );

            if (!fSucc)
            {
                TrERROR(RdTest, "Failed to retrieve test parameters. File: %ls", argv[1]); 
                return -1;
            }

            //
            // Replace the current Machine ID in the registery with the 
            // test source machine ID
            //
            s_SourceMachineId = GetMachineId(SourceMachine.data());
            GUID DestinationMachineId = GetMachineId(DestinationMachine.data());

            printf("\n Test%d\n=================\n", TestIndex);


            //
            // Check if the routing Dtat-structure need to rebuild,
            // since we changed the source machine
            //
                            RdRefresh();
/*
            if (wcscmp(PrevSourceMachine.data(), SourceMachine.data()) != 0)
            {
                RdRefresh();

                //
                // Store the current source machine
                //
                PrevSourceMachine = SourceMachine;
            }
*/

            if (fRouteTest)
            {
                printf("Get a route Table from %S to %S...\n", 
                            SourceMachine.data(), DestinationMachine.data());
                CRouteTable RouteTable;
                RdGetRoutingTable(DestinationMachineId, RouteTable);

                CheckTestResult(
                    argv[1],
                    TestAppl,
                    RouteTable
                    );

                continue;
            }

            printf("Get connctor to route from %S to %S...\n", 
                        SourceMachine.data(), DestinationMachine.data());

            GUID ConnectorId;
            RdGetConnector(DestinationMachineId, ConnectorId);
            
            CheckConnectorTestResult(argv[1], TestAppl, ConnectorId);

        }
    }
    catch(const exception&)
    {
        TrERROR(RdTest, "Failed to calculate the routing table");
        return -1;
    }

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\rd\test\rdad.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    rdad.cpp

Abstract:
    Implemntation of Routing decision active directory routine. 

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "Rd.h"
#include "Rdp.h"
#include "RdDs.h"
#include "RdAd.h"
#include "dsstub.h"
#include "dsstubp.h"
#include "mqprops.h"

#include "rdad.tmh"

const GUID& GetMachineId(LPCWSTR MachineName)
{
    const CMachineObj* pMachine = FindMachine(MachineName);
    if (pMachine == NULL)
    {
        TrERROR(AdStub, "Failed to featch information for %ls machine", MachineName);
        throw exception();
    }

    return pMachine->GetMachineId();
}


void
RdpGetMachineData(
    const GUID& id, 
    CACLSID& siteIds,
    CACLSID& outFrss,
    CACLSID& inFrss,
    LPWSTR* pName,
    bool* pfFrs,
    bool* pfForeign
    )
{
    PROPVARIANT aVar[10];
    PROPID      aProp[10];
    DWORD cProp = 0;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_SITE_IDS;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_OUTFRS;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_INFRS;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_PATHNAME;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_SERVICE_ROUTING;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_FOREIGN;
    ++cProp;

    const CMachineObj* pMachine = FindMachine(id);
    pMachine->GetProperties(cProp, aProp, aVar);

    siteIds = aVar[0].cauuid;
    outFrss = aVar[1].cauuid;
    inFrss = aVar[2].cauuid;
    *pName = aVar[3].pwszVal;
    *pfFrs = (aVar[4].bVal == TRUE);
    *pfForeign = (aVar[5].bVal == TRUE);
}



void
RdpGetSiteData(
    const GUID& id, 
    bool* pfForeign,
    LPWSTR* pName
    )
{
    PROPVARIANT aVar[2];
    PROPID aProp[2];
    
    aVar[0].vt = VT_NULL;
    aProp[0] = PROPID_S_FOREIGN;

    aVar[1].vt = VT_NULL;
    aProp[1] = PROPID_S_PATHNAME;

    const CSiteObj* pSite = FindSite(id);
    pSite->GetProperties(2, aProp, aVar);

    *pfForeign = (aVar[0].bVal == TRUE);
    *pName = aVar[1].pwszVal;
}


void 
RdpGetSiteLinks(
    SITELINKS& siteLinks
    )
{
    const CSiteLinkObj* pSiteLink = g_siteLinkDataBase.GetFirstSiteLink();

    while (pSiteLink != NULL)
    {
        GUID* firstSiteId = new GUID;
        *firstSiteId = pSiteLink->GetNeighbor1()->GetSiteId();

        GUID* secondSiteId = new GUID;
        *secondSiteId = pSiteLink->GetNeighbor2()->GetSiteId();

        const MachineList& LinkGatesMachine = pSiteLink->GetSiteGates();

        CACLSID LinkGates = {0, 0};
        if (!LinkGatesMachine.empty())
        {
            LinkGates.pElems = new GUID[LinkGatesMachine.size()];
            for (MachineList::iterator it = LinkGatesMachine.begin(); it != LinkGatesMachine.end(); ++it)
            {
                const CMachineObj* pMachine = *it;
                LinkGates.pElems[LinkGates.cElems] = pMachine->GetMachineId();
                ++LinkGates.cElems;
            }
        }

        R<CSiteLink> pLink = new CSiteLink(
                                        LinkGates,
                                        firstSiteId, 
                                        secondSiteId,
                                        pSiteLink->GetCost()
                                        );

        siteLinks.push_back(pLink);

        pSiteLink = g_siteLinkDataBase.GetNextSiteLink();
    }
}


void 
RdpGetSites(
    SITESINFO& sites
    )
{
    const CSiteObj* pSite = g_siteDataBase.GetFirstSite();

    while (pSite != NULL)
    {
        P<WCHAR> siteName = new WCHAR[pSite->GetSiteName().length() + 1];
        wcscpy(siteName, const_cast<LPWSTR>(pSite->GetSiteName().data()));

        CSite*  pSiteInfo = new CSite(pSite->GetSiteId());
        
        //
        // Add the site to the site list map
        //
        sites[&pSiteInfo->GetId()] = pSiteInfo;

        siteName.detach();

        pSite = g_siteDataBase.GetNextSite();
    }

}


void
RdpGetSiteFrs(
    const GUID& siteId,
    GUID2MACHINE& listOfFrs
    )
{
    const CSiteObj* pSite = FindSite(siteId);
    const MachineList& siteMachine = pSite->GetSiteMachines();

    for(MachineList::iterator it = siteMachine.begin(); it != siteMachine.end(); ++it)
    {
        const CMachineObj* pMachine = *it;

        if (pMachine->RoutingService())
        {
            CMachine* pRouteMachine = new CMachine;
            pRouteMachine->Update(pMachine->GetMachineId());

            listOfFrs[&pRouteMachine->GetId()] = pRouteMachine;
        }
    }
}


void
RdpGetConnectors(
    const GUID& site,
    CACLSID& connectorIds
    )
{
    const CSiteObj* pSite = FindSite(site);
    const MachineList& siteMachine = pSite->GetSiteMachines();

    DWORD NoOfConnector = 0;
    for(MachineList::iterator it = siteMachine.begin(); it != siteMachine.end(); ++it)
    {
        if ((*it)->RoutingService())
        {
            ++NoOfConnector;
        }
    }

    AP<GUID> pIds = new GUID[NoOfConnector];
    DWORD i = 0;

    for(MachineList::iterator it = siteMachine.begin(); it != siteMachine.end(); ++it)
    {
        const CMachineObj* pMachine = *it;

        if (pMachine->RoutingService())
        {
            pIds[i] = pMachine->GetMachineId();
            ++i;
        }
    }

    ASSERT(i == NoOfConnector);

    connectorIds.cElems = NoOfConnector;
    connectorIds.pElems = pIds.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\encryptor.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    encryptor.h

Abstract:
    Header for class CSSlEncryptor responsible to encrypt data (copy the data not inplace encrtption !!)
	and to 	return encrypted buffers ready for delivery.


Author:
    Gil Shafriri (gilsh) 27-Feb-2001

--*/

#ifndef __ST_SSLENCRYPTOR_H
#define __ST_SSLENCRYPTOR_H
#include <buffer.h>

 
class CSSlEncryptor
{
public:
	CSSlEncryptor(const SecPkgContext_StreamSizes& StreamSizes, PCredHandle SecContext);


public:
	void Append(const void* pdata, size_t len);
	void Clear()
	{
		m_EncryptedBuffers.resize(0);
		m_EncryptedData.resize(0);
	}

	const std::vector<WSABUF>& GetEncrypted() const;

private:
	void FixPointers();


private:
	std::vector<WSABUF> m_EncryptedBuffers;
	CResizeBuffer<char> m_EncryptedData;
	const SecPkgContext_StreamSizes& m_StreamSizes;
	PCredHandle m_SecContext;
};

	 	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\sendchunks.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sendchunks.h

Abstract:
    Header file for class CSendChunks responsibile to cut given buffers to chunks
	limited to a given size. The class it used to encrypte user data chunk by 
	chunk.

Author:
    Gil Shafriri (gilsh) 28-Feb-00

--*/

class CSendChunks 
{
public:
	  CSendChunks(const WSABUF* Buffers, DWORD nBuffers);


public:
		void GetNextChunk(DWORD len, const void** ppBuffer,DWORD* pLen);

private:
		bool MoveNext(void);

private:
		const   WSABUF* m_Buffers;
		DWORD	m_nBuffers;
		DWORD	m_CurrentBuffer;
		DWORD	m_offset;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\sendchunks.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sendchunks.cpp

Abstract:
    Implementing class CSendChunks (sendchunks.h)

Author:
    Gil Shafriri (gilsh) 28-Feb-00

--*/

#include <libpch.h>
#include "sendchunks.h"

#include "sendchunks.tmh"

CSendChunks::CSendChunks(
						const WSABUF* Buffers,
						DWORD nBuffers
						):					
						m_Buffers(Buffers),
						m_nBuffers(nBuffers),
						m_CurrentBuffer(0),
						m_offset(0)
{

}



void CSendChunks::GetNextChunk(DWORD len, const void** ppBuffer,DWORD* pLen)
/*++

Routine Description:
    Get next chunk to send from user buffer 
  
Arguments:
	IN -  len - rthe requested chunk size
	OUT - ppBuffer - receive pointer to next chunk.
	OUT - pLen - the size of the chunk in *ppBuffer.

Returned Value:
None

--*/


{
	ASSERT(ppBuffer != NULL);
	ASSERT(pLen != NULL);
	ASSERT(len != 0);

	*ppBuffer = NULL;
	*pLen = NULL;
		
	const WSABUF* pBuffer =  &m_Buffers[m_CurrentBuffer];

	if(m_offset == pBuffer->len)
	{
		bool fSucess = MoveNext();
		if(!fSucess)
		{
			return;
		}
		GetNextChunk(len,ppBuffer,pLen);
		return ;
	}

	*pLen =  min(pBuffer->len - m_offset ,len);
	*ppBuffer =  pBuffer->buf + m_offset;
  	m_offset += *pLen;

	return;
		
}


bool CSendChunks::MoveNext(void)
{
	ASSERT(m_CurrentBuffer < m_nBuffers);
	if(m_CurrentBuffer == m_nBuffers -1 )
	{
		return false;
	}
	m_offset = 0;
	++m_CurrentBuffer;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\st.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.cpp

Abstract:
    Socket Transport public interface

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#include <libpch.h>
#include "stp.h"
#include "st.h"
#include "stsimple.h"
#include "stssl.h"
#include "StPgm.h"

#include "st.tmh"

ISocketTransport* StCreatePgmWinsockTransport()
{
    return new CPgmWinsock();

} // StCreatePgmWinsockTransport


ISocketTransport* StCreateSimpleWinsockTransport()
/*++

Routine Description:
    Create new simple winsock transport
  
Arguments:

  
Returned Value:
	Socket transport interface.
	caller has to delete the returned pointer.

--*/
{
	return new 	CSimpleWinsock();
}


ISocketTransport* StCreateSslWinsockTransport(const xwcs_t& ServerName,USHORT ServerPort,bool fProxy)
/*++

Routine Description:
    Create new ssl winsock transport
  
Arguments:
	ServerName - Server name to authenticate (destination server name).
	ServerPort - Port of the destination (used only if 	fProxy==true)
	fProxy - Indicating if we are connecting via proxy or not
  
Returned Value:
	Socket transport interface.
	Caller has to delete the returned pointer.

--*/

{
	return new 	CWinsockSSl(StpGetCredentials(), ServerName, ServerPort, fProxy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\encryptor.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    encryptor.cpp

Abstract:
    Implementing class CSSlEncryptor (encryptor.h)


Author:
    Gil Shafriri (gilsh) 27-Feb-2001

--*/

#include <libpch.h>
#include "stp.h"
#include "encryptor.h"

#include "encryptor.tmh"

CSSlEncryptor::CSSlEncryptor(
	const SecPkgContext_StreamSizes& StreamSizes,
	PCredHandle SecContext
	):
	m_EncryptedData(2048),
	m_StreamSizes(StreamSizes),
	m_SecContext(SecContext)
	{
 		m_EncryptedBuffers.reserve(2);
	}



void CSSlEncryptor::FixPointers()
/*++

Routine Description:
    This function is called to fix the pointers to the encrypted data
	because the buffer that holds the encrypted data was realocated and the data was moved.
  
Returned Value:
None

--*/
{
	size_t ofsset = 0;
	std::vector<WSABUF>::iterator it;
	for(it = m_EncryptedBuffers.begin(); it!= m_EncryptedBuffers.end(); ++it)
	{
		it->buf = m_EncryptedData.begin() + ofsset;
		ofsset += it->len;
	}

	ASSERT(m_EncryptedData.begin() + ofsset ==  m_EncryptedData.end() );
}


/*++

Routine Description:
    Encrypte data (copy the data,  no inplce encryption) and append it to the encrypted buffers.
	  
Arguments:
	pdata - data to encrypt
	len - data length in bytes
  
  
Returned Value:
None

--*/
void CSSlEncryptor::Append(const void* pdata, size_t DataLen)
{
	size_t Headerlen = m_StreamSizes.cbHeader;
	size_t TrailLen = m_StreamSizes.cbTrailer;
	size_t EncryptedLen = Headerlen + DataLen + TrailLen;
	size_t TotalNeededLen = EncryptedLen + m_EncryptedData.size();	
  
	if(m_EncryptedData.capacity() < TotalNeededLen)
	{
		//
		// Because we needed more space for the heade + body + trailer 
		// We must resize the vector holding the encrypted data - 
		// doing this will change the data location	so the pointers in 
		// the WSABUF are  not correct any more  - we need to fix them.
		//

		m_EncryptedData.reserve(TotalNeededLen * 2);	
		FixPointers();
	}

	//
	//Copy the body to it's place between the header and the trailer
	//
	char* pBody =  m_EncryptedData.end() +  Headerlen;
	memcpy(
		pBody,
		pdata,
		DataLen
		);


  
	SecBufferDesc   Message;
    SecBuffer       Buffers[4];
	

	//
	// SSL header buffer
	//
	char* pHeader =  m_EncryptedData.end();
    Buffers[0].pvBuffer     = pHeader;
    Buffers[0].cbBuffer     = numeric_cast<DWORD>(Headerlen);
    Buffers[0].BufferType   = SECBUFFER_STREAM_HEADER;


	//
	// SSL body buffer
	//
	Buffers[1].pvBuffer     = pBody;
    Buffers[1].cbBuffer     = numeric_cast<DWORD>(DataLen);
    Buffers[1].BufferType   = SECBUFFER_DATA;


	//
	// SSL trailer buffer
	//
	char* pTrail = pBody + DataLen;
    Buffers[2].pvBuffer     = pTrail;
    Buffers[2].cbBuffer     = numeric_cast<DWORD>(TrailLen);
    Buffers[2].BufferType   = SECBUFFER_STREAM_TRAILER;


	//
	// Empty buffer as termination
	//
    Buffers[3].BufferType   = SECBUFFER_EMPTY;

    Message.ulVersion       = SECBUFFER_VERSION;
    Message.cBuffers        = TABLE_SIZE(Buffers);
    Message.pBuffers        = Buffers;

	ASSERT(Buffers[1].pvBuffer >  Buffers[0].pvBuffer); 

    SECURITY_STATUS scRet = EncryptMessage(m_SecContext,0,&Message, 0);
	if(scRet != SEC_E_OK)
    {
		TrERROR(St, "EncryptMessage returned error %x", scRet);
	    throw exception();
    }

	WSABUF buf;
	buf.len = numeric_cast<DWORD>(EncryptedLen);
	buf.buf = pHeader; 
	m_EncryptedBuffers.push_back(buf);


	m_EncryptedData.resize(TotalNeededLen);
}


const std::vector<WSABUF>& CSSlEncryptor::GetEncrypted() const
{
	return m_EncryptedBuffers;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stInit.cpp

Abstract:
    Socket Transport initialization

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <autosec.h>
#include "stssl.h"
#include "stsimple.h"
#include "st.h"
#include "stp.h"

#include "stinit.tmh"


VOID
StInitialize()
/*++

Routine Description:
    Initializes Socket Transport library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(!StpIsInitialized());
	StpRegisterComponent();
	StpCreateCredentials();

	CWinsockSSl::InitClass();
	CSimpleWinsock::InitClass();

    StpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stp.h

Abstract:
    Socket Transport private functions.

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#pragma once

#ifndef _MSMQ_stp_H_
#define _MSMQ_stp_H_

#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>
#include <schannel.h>
#include <ex.h>

class  CSSPISecurityContext;
extern CSSPISecurityContext g_SSPISecurityContext;

const TraceIdEntry St = L"Socket Transport";

inline DWORD DataTransferLength(EXOVERLAPPED& ov)
{
    //
    // In win64, InternalHigh is 64 bits. Since the max chunk of data
    // we transfer in one operation is always less than MAX_UNIT we can cast
    // it to DWORD safetly
    //
    ASSERT(0xFFFFFFFF >= ov.InternalHigh);
	return numeric_cast<DWORD>(ov.InternalHigh);
}

void  StpSendData(const R<class IConnection>& con ,const void* pData, size_t cbData,EXOVERLAPPED* pov);
CredHandle* StpGetCredentials(void);
void  StpCreateCredentials(void);
void  StpPostComplete(EXOVERLAPPED** pov,HRESULT hr); 


//---------------------------------------------------------
//
//  class CAutoZeroPtr	- zero given pointer at destruction
//
//---------------------------------------------------------
template<class T>
class CAutoZeroPtr{
public:
    CAutoZeroPtr(T** pptr) : m_pptr(pptr) {}
   ~CAutoZeroPtr()
   { 
		if  (m_pptr) 
		{
			*m_pptr	= 0;
		}
   }
   T** detach()
   {
	   T** tmp = m_pptr; 
	   m_pptr = 0;
	   return tmp;
   }

private:
    CAutoZeroPtr(const CAutoZeroPtr&);
    CAutoZeroPtr& operator=(const CAutoZeroPtr&);

private:
    T** m_pptr;
};


#ifdef _DEBUG

void StpAssertValid(void);
void StpSetInitialized(void);
BOOL StpIsInitialized(void);
void StpRegisterComponent(void);

#else // _DEBUG

#define StpAssertValid() ((void)0)
#define StpSetInitialized() ((void)0)
#define StpIsInitialized() TRUE
#define StpRegisterComponent() ((void)0)

#endif // _DEBUG







#endif // _MSMQ_stp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stpgm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    StPgm.h

Abstract:

    Header for class CPgmWinsock that implements ISocketTransport interface
	for PGM protocol (multicast).

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#ifndef __ST_PGM_H
#define __ST_PGM_H

#include "st.h"
#include "rwlock.h"

class CPgmWinsockConnection : public IConnection
{
public:
	virtual 
	void 
	ReceivePartialBuffer(
        VOID* pBuffer,                                     
        DWORD Size, 
        EXOVERLAPPED* pov
        );


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		);


	virtual void Close();


private:
	CPgmWinsockConnection();

	void Init(const SOCKADDR_IN& Addr, EXOVERLAPPED* pOverlapped);

	bool IsClosed() const
	{
		return 	m_socket == INVALID_SOCKET;
	}
	friend class CPgmWinsock;



private:
	mutable CReadWriteLock m_CloseConnection;
	CSocketHandle m_socket;
};



class CPgmWinsock :public ISocketTransport
{
public:
	CPgmWinsock() {}
	

	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache	= true
    );
 
    virtual void CreateConnection(const SOCKADDR_IN& Addr,	EXOVERLAPPED* pOverlapped);

	virtual R<IConnection> GetConnection(void);
 
	virtual bool IsPipelineSupported();

private:
	R<CPgmWinsockConnection> m_pPgmWinsockConnection;

private:
	CPgmWinsock(const CPgmWinsock&);
	CPgmWinsock& operator=(const CPgmWinsock&);
};


#endif // __ST_PGM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stDebug.cpp

Abstract:
    Socket Transport debugging

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "st.h"
#include "stp.h"

#include "stdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Socket Transport state
//
void StpAssertValid(void)
{
    //
    // stInitalize() has *not* been called. You should initialize the
    // Socket Transport library before using any of its funcionality.
    //
    ASSERT(StpIsInitialized());

    //
    // TODO:Add more Socket Transport validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void StpSetInitialized(void)
{
    LONG fstAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Socket Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fstAlreadyInitialized);
}


BOOL StpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = 
{
    St
};

void StpRegisterComponent(void)
{
	 TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
}




#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsimple.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsimple.h

Abstract:
    Header for class CSimpleWinsock that implements ISocketTransport interface
	for non secure network protocol (simple winsock)

Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SIMPLE_H
#define __ST_SIMPLE_H
#include <rwlock.h>
#include "st.h"


class CWinsockConnection : public IConnection	
{					 
	~CWinsockConnection(){};

	virtual 
	void 
	ReceivePartialBuffer(
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					);


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		);


	virtual void Close();

private:
	CWinsockConnection();

	void Init(const SOCKADDR_IN& Addr,	EXOVERLAPPED* pOverlapped);

	bool IsClosed() const
	{
		return m_socket == INVALID_SOCKET;		
	}

	friend class CSimpleWinsock;

private:
	mutable CReadWriteLock m_CloseConnection;
	CSocketHandle m_socket;
};




class CSimpleWinsock :public ISocketTransport
{
public:
	CSimpleWinsock();
	~CSimpleWinsock();
 
	
public:

	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache	= true
    );

    virtual void CreateConnection(const SOCKADDR_IN& Addr, EXOVERLAPPED* pOverlapped);

	virtual R<IConnection> GetConnection(void);

	virtual bool IsPipelineSupported();
	static void InitClass();

private:
	static bool m_fIsPipelineSupported;


private:
	R<CWinsockConnection> m_pWinsockConnection;

private:
	CSimpleWinsock(const CSimpleWinsock&);
	CSimpleWinsock& operator=(const CSimpleWinsock&);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stp.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stp.cpp

Abstract:
    Socket Transport private functions implementation

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#include <libpch.h>
#include <no.h>
#include "stp.h"
#include "stsimple.h"
#include "stssl.h"

#include "stp.tmh"

static CSSPISecurityContext s_SSPISecurityContext;


void  StpSendData(const R<IConnection>& con ,const void* pData, size_t cbData,EXOVERLAPPED* pov)
/*++

Routine Description:
    Send data to destination.
  
Arguments:
	Socket - Connected socket.
	pData - Pointer to data
	cbData - data size
	pov - overlapp to call when finish.

  
Returned Value:
	None

--*/
{
	WSABUF buffer;
		
	buffer.buf = (char*)(pData);
	buffer.len = numeric_cast<DWORD>(cbData);
 
	con->Send(&buffer, 1, pov);
}


CredHandle* StpGetCredentials()
{
	ASSERT(s_SSPISecurityContext.IsValid());
	return s_SSPISecurityContext.getptr();
}


void  StpPostComplete(EXOVERLAPPED** ppOvl,HRESULT hr)
/*++

Routine Description:
    Complete ayncrounos call and zeroing in the given overlapp
  
Arguments:
	IN/OUT ppOvl - poinetr to overlapp to signal.
	IN - status return code
    
Returned Value:
	None 
--*/
{
	EXOVERLAPPED* pTmpOvl = *ppOvl;
	*ppOvl = NULL;
	pTmpOvl->SetStatus(hr);
	ExPostRequest(pTmpOvl);
}


void StpCreateCredentials()
/*++

Routine Description:
    Create credential handle.
  
Arguments:
    None.
    
Returned Value:
    Create handle (exception is thrown if on error)

--*/
{
	CCertOpenStore hMyCertStore = CertOpenStore(
											CERT_STORE_PROV_SYSTEM,
											X509_ASN_ENCODING,
											0,
											CERT_STORE_OPEN_EXISTING_FLAG | CERT_SYSTEM_STORE_SERVICES,
											L"MSMQ\\MY"
											);

	if(hMyCertStore == NULL)
    {
		TrERROR(St,"Could not open MSMQ Certificate Stote,Error=%x",GetLastError());
		throw exception();		   
    }

	SCHANNEL_CRED   SchannelCred;
	ZeroMemory(&SchannelCred, sizeof(SchannelCred));
	SchannelCred.dwVersion  = SCHANNEL_CRED_VERSION;
	SchannelCred.cCreds     = 1;
    SchannelCred.grbitEnabledProtocols = SP_PROT_SSL3;
    SchannelCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
    SchannelCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;


	CCertificateContext pCertContext = CertFindCertificateInStore(
															hMyCertStore, 
															0, 
															0,
															CERT_FIND_ANY,
															NULL,
															NULL
													        );

	//
	// If MSMQ service has certificate in it's service store - use it to get client credential
	//
	if(pCertContext == NULL)
	{
		TrWARNING(St,"Could not find certificate in MSMQ store, Error=%x" ,GetLastError());
        SchannelCred.paCred = NULL;
 	}
	else
	{
		SchannelCred.paCred  =  &pCertContext;
	}
 
    //
    // Create an SSPI credential.
    //
	CredHandle      phCreds;
	TimeStamp       tsExpiry;

    SECURITY_STATUS Status = AcquireCredentialsHandle(
										NULL,                   // Name of principal    
										UNISP_NAME_W,           // Name of package
										SECPKG_CRED_OUTBOUND,   // Flags indicating use
										NULL,                   // Pointer to logon ID
										&SchannelCred,          // Package specific data
										NULL,                   // Pointer to GetKey() func
										NULL,                   // Value to pass to GetKey()
										&phCreds,                // (out) Cred Handle
										&tsExpiry	            // (out) Lifetime (optional)
										);             

	
    if(Status != SEC_E_OK)
    {
		//
		// Somthing is wrong with the client certificate - use empty client credential
		//
		SchannelCred.paCred = NULL;
		Status = AcquireCredentialsHandle(
										NULL,                   // Name of principal    
										UNISP_NAME_W,           // Name of package
										SECPKG_CRED_OUTBOUND,   // Flags indicating use
										NULL,                   // Pointer to logon ID
										&SchannelCred,          // Package specific data
										NULL,                   // Pointer to GetKey() func
										NULL,                   // Value to pass to GetKey()
										&phCreds,                // (out) Cred Handle
										&tsExpiry	            // (out) Lifetime (optional)
										);             

		if(Status != SEC_E_OK)
		{
			TrERROR(St,"Failed to acquire credential  handle, Error=%x ",Status);
			throw exception();		 
		}
    }
 	s_SSPISecurityContext = phCreds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsimple.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsimple.h.cpp

Abstract:
    implementation of class CSimpleWinsock declared in (stsimple.h)
	It simply forward the functions calls to no library

Author:
    Gil Shafriri (gilsh) 23-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <no.h>
#include <cm.h>
#include "stsimple.h"
#include "stp.h"
#include "stsimple.tmh"


CWinsockConnection::CWinsockConnection(
				void
				)
				:
				m_socket(NoCreateStreamConnection())
{
}



void CWinsockConnection::Init(const SOCKADDR_IN& Addr, EXOVERLAPPED* pOverlapped)
{
	NoConnect(m_socket, Addr, pOverlapped);	
}



void CWinsockConnection::Close()
{
	CSW writelock(m_CloseConnection);
	m_socket.free();
}



void 
CWinsockConnection::Send(
				const WSABUF* Buffers,                                     
				DWORD nBuffers, 
				EXOVERLAPPED* pov
				)
{
	CSR readlock(m_CloseConnection);
	if(IsClosed())
	{
		throw exception();
	}
	NoSend(m_socket, Buffers, nBuffers, pov);	
}



void 
CWinsockConnection::ReceivePartialBuffer(				                 
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					)
{
	CSR readlock(m_CloseConnection);
	if(IsClosed())
	{
		throw exception();
	}
 	NoReceivePartialBuffer(m_socket, pBuffer, Size, pov);
}



bool CSimpleWinsock::m_fIsPipelineSupported = true;


static bool IsSimpleSocketPipeLineSupported()
/*++

Routine Description:
   Return the pipe line mode of the http delivery according registry setting
   - default is  pipeline mode
  
Arguments:
	Socket - Connected socket.

  
Returned Value:
	None

--*/

{
	DWORD fHttpPipeLineSupport;

	CmQueryValue(
			RegEntry(NULL, L"HttpPipeLine", TRUE),  
			&fHttpPipeLineSupport
			);

	bool fRet = (fHttpPipeLineSupport == TRUE); 
	TrTRACE(St,"http pipeline mode = %d", fRet);
	return fRet;
}

CSimpleWinsock::CSimpleWinsock()
{
}


CSimpleWinsock::~CSimpleWinsock()
{
}


void CSimpleWinsock::InitClass()
{
	m_fIsPipelineSupported	=  IsSimpleSocketPipeLineSupported();
}


void
CSimpleWinsock::CreateConnection(
					const SOCKADDR_IN& Addr,
					EXOVERLAPPED* pOverlapped
					)
{	
	//
	// Note - we must do two phase constrcution of the connection object
	// becaue the connection can be completed before we assign the pointer
	// to m_pWinsockConnection and a call to GetConnection upon connection completion
	// will find null pointer in m_pWinsockConnection.
	//
	m_pWinsockConnection = new CWinsockConnection();
	m_pWinsockConnection->Init(Addr, pOverlapped);
}




R<IConnection> CSimpleWinsock::GetConnection()
{
	return m_pWinsockConnection;	
}

	
bool
CSimpleWinsock::GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache
    )
{
	return NoGetHostByName(host, pAddr, fUseCache);
}



bool CSimpleWinsock::IsPipelineSupported()
/*++

Routine Description:
     return if this transport support pipelining. 
	 Piplining means sending more requests to the server
	 before complete reading all response from previous request.
  
Arguments:
   
Returned Value:
true support piplining false not support piplining

--*/
{
	return m_fIsPipelineSupported;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stpgm.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    StPgm.cpp

Abstract:

    Implementation of class CPgmWinsock.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <WsRm.h>
#include <no.h>
#include <Cm.h>
#include "StPgm.h"
#include "stp.h"
#include "stpgm.tmh"

static void STpDumpPGMSenderStats(const SOCKET socket );

static
SOCKET 
CreatePgmSocket()
{
    CSocketHandle socket = NoCreatePgmConnection();

    SOCKADDR_IN SrcSockAddr;
    SrcSockAddr.sin_family = AF_INET;
    SrcSockAddr.sin_port   = htons(0);
    SrcSockAddr.sin_addr.s_addr = 0;

    int rc;
    rc = bind(socket, (SOCKADDR *)&SrcSockAddr, sizeof(SrcSockAddr));
    if (rc == SOCKET_ERROR)
    {
        TrERROR(St, "Failed to bind to PGM socket, error %d", WSAGetLastError());
        throw exception();
    }

    RM_SEND_WINDOW win;
    
    CmQueryValue(
        RegEntry(NULL, L"MulticastRateKbitsPerSec",560),
        &win.RateKbitsPerSec
        );
                  
    CmQueryValue(
        RegEntry(NULL, L"MulticastWindowSizeInMSecs"),
        &win.WindowSizeInMSecs 
        );
             
    win.WindowSizeInBytes = 0;

    TrTRACE(St, "PGM window: Kbits/Sec=%d, Size(Msecs)=%d, Size(Bytes)=%d", win.RateKbitsPerSec, win.WindowSizeInMSecs, win.WindowSizeInBytes);

    rc = setsockopt(socket, IPPROTO_RM, RM_RATE_WINDOW_SIZE, (char *)&win, sizeof(win));
    if (rc == SOCKET_ERROR)
    {
        TrERROR(St, "Failed to set PGM send window parameters, error %d", WSAGetLastError());
        throw exception();
    }
    

    ULONG Info = 0;
    TrTRACE(St, "Set late join, join=%d", Info);
    rc = setsockopt(socket, IPPROTO_RM, RM_LATEJOIN, (char *)&Info, sizeof(ULONG));
    if (rc == SOCKET_ERROR)
    {
        TrERROR(St, "Failed to set PGM socket options, error %d", WSAGetLastError());
        throw exception();
    }

    ULONG PgmTimeToLive = 0;
    CmQueryValue(
        RegEntry(NULL, L"MulticastTimeToLive"),
        &PgmTimeToLive
        );
    
    if (PgmTimeToLive != 0)
    {
        rc = setsockopt(socket, IPPROTO_RM, RM_SET_MCAST_TTL, (char *)&PgmTimeToLive, sizeof(PgmTimeToLive));
        if (rc == SOCKET_ERROR)
        {
            TrERROR(St, "Failed to set PGM socket options, error %d", WSAGetLastError());
            throw exception();
        }
    }
    return socket.detach();
}


CPgmWinsockConnection::CPgmWinsockConnection(
				void
				):
				m_socket(CreatePgmSocket())
{
}


void CPgmWinsockConnection::Init(const SOCKADDR_IN& Addr, EXOVERLAPPED* pOverlapped)
{
	NoConnect(m_socket, Addr, pOverlapped);
}



void 
CPgmWinsockConnection::ReceivePartialBuffer(
    VOID*,                                     
    DWORD, 
    EXOVERLAPPED*
    )
{
	ASSERT(("CPgmWinsock::ReceivePartialBuffer should not be called!", 0));
    TrERROR(St, "CPgmWinsock::ReceivePartialBuffer should not be called!");
    throw exception();
}



void 
CPgmWinsockConnection::Send(
    const WSABUF* Buffers,
    DWORD nBuffers,
    EXOVERLAPPED* pov
    )
{
	CSR readlock(m_CloseConnection);
	if(IsClosed())
	{
		throw exception();
	}
	NoSend(m_socket, Buffers, nBuffers, pov);
}


void CPgmWinsockConnection::Close()
{
	ASSERT(!IsClosed());
	CSW writelock(m_CloseConnection);
    STpDumpPGMSenderStats(m_socket);
    m_socket.free();
}



void CPgmWinsock::CreateConnection(const SOCKADDR_IN& Addr, EXOVERLAPPED* pOverlapped)
{
	//
	// Note - we must do two phase constrcution of the connection object
	// becaue the connection can be completed before we assign the pointer
	// to m_pWinsockConnection and a call to GetConnection upon connection completion
	// will find null pointer in m_pWinsockConnection.
	//
	m_pPgmWinsockConnection = new  CPgmWinsockConnection();
	m_pPgmWinsockConnection->Init(Addr, pOverlapped);
} 


 
R<IConnection> CPgmWinsock::GetConnection()
{
	return m_pPgmWinsockConnection;
} 



bool
CPgmWinsock::GetHostByName(
	LPCWSTR,
	std::vector<SOCKADDR_IN>*,
	bool 
	)
{
	ASSERT(("CPgmWinsock::GetHostByName should not be called!", 0));
    TrERROR(St, "CPgmWinsock::GetHostByName should not be called!");
    throw exception();
}




bool 
CPgmWinsock::IsPipelineSupported(
    VOID
    )
{
	return true;
}



void STpDumpPGMSenderStats(const SOCKET socket )
/*++
  
	Function Description:
		Get statistic information from the PGM sockets.
	Arguments:
		socket - PGM socket.
	Return code:
		None

	
--*/
{
	if(!WPP_LEVEL_COMPID_ENABLED(rsTrace, St))
	{
		return;
	}
    RM_SENDER_STATS RmSenderStats;
    INT BufferLength = sizeof(RM_SENDER_STATS);
    memset (&RmSenderStats, 0, BufferLength);
    ULONG ret = getsockopt (socket, IPPROTO_RM, RM_SENDER_STATISTICS, (char *)&RmSenderStats, &BufferLength);
    if (ret != ERROR_SUCCESS)
    {
        TrERROR(St, "GetSenderStats:  Failed to retrieve sender stats! error = %d\n",WSAGetLastError());
        return ;
    }
    TrTRACE(St, "NaksReceived=<%I64d>", RmSenderStats.NaksReceived);
    TrTRACE(St, "NaksReceivedTooLate=<%I64d>", RmSenderStats.NaksReceivedTooLate);
    TrTRACE(St, "NumOutstandingNaks=<%I64d>", RmSenderStats.NumOutstandingNaks);
    TrTRACE(St, "NumNaksAfterRData=<%I64d>", RmSenderStats.NumNaksAfterRData);
    TrTRACE(St, "RepairPacketsSent=<%I64d>", RmSenderStats.RepairPacketsSent);
    TrTRACE(St, "BufferSpaceAvailable=<%I64d> bytes", RmSenderStats.BufferSpaceAvailable);
    TrTRACE(St, "LeadingEdgeSeqId=<%I64d>", RmSenderStats.LeadingEdgeSeqId);
    TrTRACE(St, "TrailingEdgeSeqId=<%I64d>", RmSenderStats.TrailingEdgeSeqId);
    TrTRACE(St, "Sequences in Window=<%I64d>", (RmSenderStats.LeadingEdgeSeqId-RmSenderStats.TrailingEdgeSeqId+1));
    TrTRACE(St, "RateKBitsPerSecLast=<%I64d>", RmSenderStats.RateKBitsPerSecLast);
    TrTRACE(St, "RateKBitsPerSecOverall=<%I64d>", RmSenderStats.RateKBitsPerSecOverall);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stssl.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stssl.h

Abstract:
    Header for class CWinsockSSl that implements ISocketTransport interface
	for secure  (using ssl).

Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSL_H
#define __ST_SSL_H

#include "st.h"
#include "stsslng.h"
#include "stp.h"

class CWinsockSSl :public ISocketTransport
{
public:
	CWinsockSSl(
		CredHandle* pCred,
		const xwcs_t& ServerName,
		USHORT ServerPort,
		bool fProxy
		);

	~CWinsockSSl();
	
public:
	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache	= true
    );
     
    virtual	void CreateConnection(const SOCKADDR_IN& Addr,	EXOVERLAPPED* pov);

	virtual R<IConnection> GetConnection();
  
	virtual bool IsPipelineSupported();
	static void InitClass();

private:
	CSSlNegotioation      m_CSSlNegotioation;

private:
	static bool m_fIsPipelineSupported;
	

private:
	CWinsockSSl(const CWinsockSSl&);
	CWinsockSSl& operator=(const CWinsockSSl&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stssl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stssl.cpp

Abstract:
    implementation of class CWinsockSSl declared in (stssl.h)

Author:
    Gil Shafriri (gilsh) 23-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <schannel.h>
#include <no.h>
#include <ex.h>
#include <tr.h>
#include <xstr.h>
#include <cm.h>
#include "stssl.h"
#include "stsslco.h"
#include "stp.h"

#include "stssl.tmh"

bool CWinsockSSl::m_fIsPipelineSupported = false;

static bool IsSslPipeLineSupported()
/*++

Routine Description:
   Return the pipe line mode of the https delivery according registry setting
   - default is non pipeline mode
  
Arguments:
	Socket - Connected socket.

  
Returned Value:
	None

--*/

{
	DWORD fHttpsPipeLineSupport;

	CmQueryValue(
			RegEntry(NULL, L"HttpsPipeLine", TRUE),  
			&fHttpsPipeLineSupport
			);

	bool fRet = (fHttpsPipeLineSupport == TRUE); 
	TrTRACE(St,"https pipeline mode = %d", fRet);
	return fRet;
}



void CWinsockSSl::InitClass()
{
	m_fIsPipelineSupported	=  IsSslPipeLineSupported();
}



//---------------------------------------------------------
//
//  CWinsockSSl Implementation
//
//---------------------------------------------------------

CWinsockSSl::CWinsockSSl(
					CredHandle* pCredentialsHandle,
					const xwcs_t& ServerName,
					USHORT ServerPort,
					bool fProxy
					):
					m_CSSlNegotioation(pCredentialsHandle,ServerName, ServerPort, fProxy )
				
				
{

}


CWinsockSSl::~CWinsockSSl()
{
}




bool
CWinsockSSl::GetHostByName(
	LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache
	)
{
	return 	NoGetHostByName(host, pAddr, fUseCache);
}



void 
CWinsockSSl::CreateConnection(
				const SOCKADDR_IN& Addr,
				EXOVERLAPPED* pOverlapped
				)
{
	TrTRACE(St,"Try to connect");
	m_CSSlNegotioation.CreateConnection(Addr, pOverlapped);
}


R<IConnection> CWinsockSSl::GetConnection()
{
	return m_CSSlNegotioation.GetConnection();
}



/*++

Routine Description:
     return if this transport support pipelining. 
	 Piplining means sending more requests to the server
	 before complete reading all response from previous request.
  
Arguments:
   
Returned Value:
true support piplining false not support piplining

--*/
bool CWinsockSSl::IsPipelineSupported()
{
	//
	// HTTS does not support pileling - because we can get request to renegotiate
	// at any time form the server.	When this happened - the server expects spesific handshake
	// data to be send, this will fail if we have pending send at the same time. 
	//
	return m_fIsPipelineSupported;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslco.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslcon.cpp

Abstract:
    implementation class CSSlSender declared in stsslco.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#include <libpch.h>
#include <no.h>
#include "stsslco.h"
#include "stp.h"

#include "stsslco.tmh"


CSSlConnection::CSSlConnection(
		CredHandle* SecContext,
		const SecPkgContext_StreamSizes& sizes,
		const R<IConnection>&  SimpleConnection,
		CSSlNegotioation& SSlNegotioation
		):
		m_SimpleConnection(SimpleConnection),
		m_SSLSender(SecContext, sizes, SSlNegotioation, m_ReadWriteLockAsyncExcutor),
		m_SSlReceiver(SecContext, sizes, SSlNegotioation, m_ReadWriteLockAsyncExcutor)
{
		ASSERT(m_SimpleConnection.get() != NULL);
}



void CSSlConnection::ReceivePartialBuffer(
						VOID* pBuffer,                                     
						DWORD Size, 
						EXOVERLAPPED* pov
						)
{
	m_SSlReceiver.ReceivePartialBuffer(m_SimpleConnection, pBuffer, Size, pov);
}
	


void CSSlConnection::Send(
			const WSABUF* Buffers,                                     
			DWORD nBuffers, 
			EXOVERLAPPED* pov
			)
{
	m_SSLSender.Send(m_SimpleConnection, Buffers , nBuffers, pov); 
}


//
//	At the moment closing the connection is just closing the socket
//	We sould consider doing it in the SSL way.
//
void CSSlConnection::Close()
{
	m_ReadWriteLockAsyncExcutor.Close();
	m_SimpleConnection->Close();	    	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslco.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslco.h

Abstract:
    Header for class CSSlConnection sending\reading data above ssl connection


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSLCO_H
#define __ST_SSLCO_H

#include <rwlockexe.h>
#include "stsslsn.h"
#include "stsslrd.h"
#include "st.h"



class CSSlConnection: public IConnection
{
public:
	CSSlConnection(
		CredHandle* SecContext,
		const SecPkgContext_StreamSizes& sizes,
		const R<IConnection>& SimpleConnection,
		CSSlNegotioation& SSlNegotioation
		);

public:
	void virtual ReceivePartialBuffer(
						VOID* pBuffer,                                     
						DWORD Size, 
						EXOVERLAPPED* pov
						);


 	void virtual Send(
			const WSABUF* Buffers,                                     
			DWORD nBuffers, 
			EXOVERLAPPED* pov
			);



	//
	//	At the moment closing the connection is just closing the socket
	//	We sould consider doing it in the SSL way.
	//
	void virtual Close();
	
	
private:
	R<IConnection> m_SimpleConnection;
    CSSlSender m_SSLSender;
	CSSlReceiver m_SSlReceiver;
	CReadWriteLockAsyncExcutor m_ReadWriteLockAsyncExcutor;
	  
private:
	CSSlConnection(const CSSlConnection&);
	CSSlConnection& operator=(const CSSlConnection&);
 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslrd.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslsn.h

Abstract:
    Header for class CSSlReceiver that receive data above ssl connection.
	The class is responsible to receive data from ssl connection, decrypte it and to
	copy it to caller buffer. The caller overlapp function will be called when
	some data (> 0) was decrypted OK ,or in case of error. It is the caller responsiblity
	to call	ReceivePartialBuffer() again to get more decrypted data.


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSLRD_H
#define __ST_SSLRD_H
#include <buffer.h>
#include <rwlockexe.h>
#include "stp.h"




//---------------------------------------------------------
//
//  CUserReceiveBuffer helper class 
//
//---------------------------------------------------------
class CUserReceiveBuffer
{
public:
	CUserReceiveBuffer():m_pBuffer(NULL),m_len(0),m_written(0)
	{
	}
	
	void CreateNew(void* pBuffer,size_t len)
	{
		m_pBuffer = pBuffer;
		m_len = len;
		m_written = 0;
	}

	size_t Write(const void* pData ,size_t len)
	{
		ASSERT(pData != NULL);
		ASSERT(m_pBuffer != NULL);
		size_t leftout =  m_len - m_written;
		size_t towrite =  min(len,leftout);
		memcpy((BYTE*)m_pBuffer + m_written,pData,towrite);	//lint !e668
		m_written += towrite;
		
		return towrite;
	}

private:
	void* m_pBuffer;                                     
	size_t m_len; 
	size_t m_written;
};

//---------------------------------------------------------
//
//  CDecryptionBuffer helper class 
//
//---------------------------------------------------------
class  CDecryptionBuffer :private  CResizeBuffer<BYTE>
{
public:
	using CResizeBuffer<BYTE>::capacity;
	using CResizeBuffer<BYTE>::size;
	using CResizeBuffer<BYTE>::reserve;
	using CResizeBuffer<BYTE>::begin;
	using CResizeBuffer<BYTE>::resize;


public:
	CDecryptionBuffer(
		size_t len
		):
	    CResizeBuffer<BYTE>(len),
		m_decryptedlen(0)
		{
		}
	

	//
	// reset buffer
	//
	void reset()
	{
		resize(0);
		m_decryptedlen = 0;
	}
 	
	//
	// Get decrypted length of the buffer
	//
	size_t DecryptedSize()const
	{
		return 	m_decryptedlen;
	}

	//
	// Set decrypted length of the buffer
	//
	void DecryptedSize(size_t newsize)
	{
		ASSERT(newsize <=  size());
		m_decryptedlen =  newsize;
	}
	

private:
	size_t  m_decryptedlen;


private:
	CDecryptionBuffer(const CDecryptionBuffer&);
	CDecryptionBuffer& operator=(const CDecryptionBuffer&);
};


//---------------------------------------------------------
//
//  CReNegotioationRequest  class -  Represent ssl renegotiation request
//
//---------------------------------------------------------
class CSSlNegotioation;
class CSSlReceiver;
class CReNegotioationRequest : public IAsyncExecutionRequest , public CReference, public EXOVERLAPPED
{
public:
	CReNegotioationRequest(
		CSSlReceiver& SSlReceiver
		):
		EXOVERLAPPED(Complete_Renegotiate, Complete_RenegotiateFailed),
		m_SSlReceiver(SSlReceiver),
		m_fRun(false)
		{
		}

private:
	virtual void Run();

private:
	virtual void Close() throw();

private:
	static void WINAPI  Complete_RenegotiateFailed(EXOVERLAPPED* pOvl);
	static void WINAPI  Complete_Renegotiate(EXOVERLAPPED* pOvl);


private:
	CSSlReceiver& m_SSlReceiver;
	bool m_fRun;
};


//---------------------------------------------------------
//
//  CSSlReceiver  class - receive data from a connection (async)
//
//---------------------------------------------------------
class CSSlReceiver :public EXOVERLAPPED
{


public:
	CSSlReceiver(
		PCredHandle SecContext,
		const SecPkgContext_StreamSizes& sizes,
		CSSlNegotioation& SSlNegotioation,
		CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
		);

	~CSSlReceiver();

public:
	void 
	ReceivePartialBuffer(	 
		const R<IConnection>& SimpleConnection,   
		VOID* pBuffer,                                     
		DWORD Size, 
		EXOVERLAPPED* pov
		);

	
private:
	void 
	ReceivePartialBufferInternal(	                          
		VOID* pBuffer,                                     
		DWORD Size 
		);

	void CopyExtraData();
	void ReceivePartialData();
	void ReceivePartialDataContinute();
	void Renegotiate();
	void RenegotiateFailed();
	void RenegotiateCompleted();
	void SetState(const EXOVERLAPPED& ovl);
	void BackToCallerWithError();
	void BackToCallerWithSuccess(size_t readcount);
	void IOReadMoreData();
	size_t WriteDataToCaller();
	SECURITY_STATUS TryDecrypteMessage();

private:
	static void WINAPI Complete_ReceivePartialData(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReceiveFailed(EXOVERLAPPED* pOvl);
	
	friend CReNegotioationRequest;

private:
	CSSlReceiver(const CSSlReceiver&);
	CSSlReceiver& operator=(const CSSlReceiver&);
	
private:
	CDecryptionBuffer m_DecryptionBuffer;
	CUserReceiveBuffer  m_UserReceiveBuffer;
	CredHandle* m_SecContext;
	SecPkgContext_StreamSizes m_Sizes;
	R<IConnection> m_SimpleConnection;
	EXOVERLAPPED* m_callerOvl;
	CSSlNegotioation& m_CSSlNegotioation;
	CReadWriteLockAsyncExcutor& m_ReadWriteLockAsyncExcutor;
};
	   


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslsn.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslsn.h

Abstract:
    Header for class CSSlSender sending data above ssl connection.
	The class is responsible to take caller buffers - and to send them
	encrypted chunk by chunk, over the ssl connection. The caller overlapp functions
	will be called only when all data is sent, or in case of error.



Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSLSN_H
#define __ST_SSLSN_H

#include "stp.h"


class CSSlNegotioation;
class ReadWriteLockAsyncExcutor;

class CSSlSender 
{
public:
	CSSlSender(
		PCredHandle SecContext,
		const SecPkgContext_StreamSizes& sizes,
		const CSSlNegotioation& SSlNegotioation,
		CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
		);


public:
	void Send(
			const R<IConnection>& SimpleConnection,                                              
			const WSABUF* Buffers,                                     
			DWORD nBuffers, 
			EXOVERLAPPED* pov
			);


private:
	friend class CSSLAsyncSend;
	void OnSendOk(CSSLAsyncSend* pSSLAsyncSend,  EXOVERLAPPED* pov);
	void OnSendFailed(CSSLAsyncSend* pSSLAsyncSend, EXOVERLAPPED* pov);


private:
	CSSlSender(const CSSlSender&);
	CSSlSender& operator=(const CSSlSender&);

private:
	PCredHandle m_SecContext;
	SecPkgContext_StreamSizes m_Sizes;
	const CSSlNegotioation& m_SSlNegotioation;
	CReadWriteLockAsyncExcutor& m_ReadWriteLockAsyncExcutor;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslng.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslfc.h

Abstract:
    Header for class CSSlNegotioation that implement creation of ssl connection.


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/


#ifndef __ST_SSLNG_H
#define __ST_SSLNG_H


#include <ex.h>
#include <xstr.h>
#include <autosec.h>
#include <buffer.h>

#include "stp.h"
#include "st.h"
#include "stsimple.h"

class CContextBuffer;
class CSSlConnection;
typedef  basic_xstr_t<BYTE>  xustr_t;



//---------------------------------------------------------
//
//  CHandShakeBuffer helper class Implementation
//
//---------------------------------------------------------
class  CHandShakeBuffer : private CResizeBuffer<BYTE>
{
public:
	using CResizeBuffer<BYTE>::capacity;
	using CResizeBuffer<BYTE>::resize;
	using CResizeBuffer<BYTE>::reserve;
	using CResizeBuffer<BYTE>::begin;
	using CResizeBuffer<BYTE>::free;
	using CResizeBuffer<BYTE>::size;

	enum {xReadBufferStartSize = 4096};


public:
	CHandShakeBuffer(
		) :
		CResizeBuffer<BYTE>(xReadBufferStartSize)
		{
		}

	void CreateNew()
	{
		reserve(xReadBufferStartSize);
		reset();
	}//lint !e429



	void reset()
	{
		m_pExtraData = xustr_t();
		resize(0);
	}

	const xustr_t ExtraData() const
	{
		return m_pExtraData;
	}

	void ExtraData(const xustr_t& ExData)
	{
		m_pExtraData = ExData;				
	}

private:
	xustr_t m_pExtraData;

private:
	CHandShakeBuffer(const CHandShakeBuffer&);
	CHandShakeBuffer& operator=(const CHandShakeBuffer&);
};


//---------------------------------------------------------
//
//  helper class CContextBuffer
//
//---------------------------------------------------------
class CContextBuffer 
{
public:
    CContextBuffer(void* h = NULL) : m_h(h) {}

   ~CContextBuffer()
   {
		free();
   }//lint !e1740


public:
   	void*  get()const
	{
		return m_h;
	}

	void free()
	{
		if (m_h != NULL) 
		{
			FreeContextBuffer(m_h);//lint !e534 
		}
		m_h = NULL;
	}

    void operator=(void* h)
	{
		free();
		m_h = h;
	}
	
	
private:
    CContextBuffer(const CContextBuffer&);
    CContextBuffer& operator=(const CContextBuffer&);

private:
    void*  m_h;
};


//---------------------------------------------------------
//
//  class CSSlNegotioation
//
//---------------------------------------------------------

class  CSSlNegotioation : public EXOVERLAPPED
{
public:
	CSSlNegotioation(
		CredHandle* pCredentialsHandle, 
		const xwcs_t& ServerName,
		USHORT ServerPort,
		bool fUseProxy
		);


public:
  	void 
	CreateConnection(
		const SOCKADDR_IN& Addr,
		EXOVERLAPPED* pOverlapped
		);

	void 
	ReConnect(
		const R<IConnection>& SimpleConnection,
		EXOVERLAPPED* pOverlapped
		);
	
   
	
	xustr_t ExtraData()const 
	{
		return m_pHandShakeBuffer.ExtraData();
	}

	void FreeHandShakeBuffer()
	{
		m_pHandShakeBuffer.free();
	}

	R<IConnection> virtual GetConnection();
	

private:
	SecPkgContext_StreamSizes GetSizes();
	void SetState(const EXOVERLAPPED& ovl);
	void ReadHandShakeData();
	void ReadProxyConnectResponse();
	void HandleHandShakeResponse();
	void SendStartConnectHandShake();
	void SendSslProxyConnectRequest();
	void ReadProxyConnectResponseContinute();
	void SendContinuteConnect(const void* pContext,DWORD len);
 	void SendFinishConnect(const void* pContext, DWORD len);
	void AuthenticateServer();
	void BackToCallerWithError();
	void BackToCallerWithSuccess();
	void HankShakeLoopContinuteNeeded(void* pContext, DWORD len, SecBuffer* pSecBuffer);
	void HankShakeLoopOk(const SecBuffer Buffer[2], void* pContext, DWORD len);
	void HankShakeLoop();


private:
	static void WINAPI Complete_SendSslProxyConnectRequest(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadProxyConnectResponse(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadHandShakeResponse(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_NetworkConnect(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ConnectFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendFinishConnect(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendHandShakeData(EXOVERLAPPED* pOvl);
	


private:
	CSSlNegotioation(const CSSlNegotioation&);
	CSSlNegotioation& operator=(const CSSlNegotioation&);


private:
	CredHandle* m_pCredentialsHandle;
	AP<WCHAR> m_pServerName;
	CContextBuffer m_SendConetext;
	CSSPISecurityContext  m_hContext;
	CHandShakeBuffer m_pHandShakeBuffer;
	R<CSSlConnection> m_pSSlConnection; 		
	EXOVERLAPPED* m_callerOvl;
	CSimpleWinsock m_SimpleWinsock;
	R<IConnection> m_SimpleConnection;
    bool   m_fServerAuthenticate;
	USHORT m_ServerPort;
	bool m_fUseProxy;
	std::string m_ProxySSlConnectRequestStr;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslng.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslnc.cpp

Abstract:
    implementation for class CSSlNegotioation declared in stsslng.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/
#include <libpch.h>
#include <schannel.h>
#include <no.h>
#include <xstr.h>
#include "stsslng.h"
#include "stsslco.h"
#include "stp.h"

#include "stsslng.tmh"

static
void
ReceivePartialBuffer(
    const R<IConnection>& SimpleConnection,                                              
    VOID* pBuffer,                                     
    size_t Size, 
    EXOVERLAPPED* pov
    )
{
	DWORD dwLen = numeric_cast<DWORD>(Size);
	SimpleConnection->ReceivePartialBuffer(pBuffer, dwLen ,	pov);
}



//---------------------------------------------------------
//
//  class CCertificateChain
//
//---------------------------------------------------------
class CCertificateChain{
public:
    CCertificateChain(PCCERT_CHAIN_CONTEXT  h = NULL) : m_h(h) {}
   ~CCertificateChain()
   { 
		if (m_h != NULL)				   
		{
			CertFreeCertificateChain(m_h); 
		}
   }

    PCCERT_CHAIN_CONTEXT* getptr()            { return &m_h; }
    PCCERT_CHAIN_CONTEXT  get() const         { return m_h; }

    PCCERT_CHAIN_CONTEXT  detach()                
	{ 
		PCCERT_CHAIN_CONTEXT h = m_h; 
		m_h = NULL; 
		return h;
	}

private:
    CCertificateChain(const CCertificateChain&);
    CCertificateChain& operator=(const CCertificateChain&);

private:
    PCCERT_CHAIN_CONTEXT  m_h;
};


static 
void
VerifyServerCertificate(
				PCCERT_CONTEXT  pServerCert,
				LPWSTR         pServerName
				)

/*++
Routine Description:
    Verify that the server certificate is valid
  
Arguments:
    pServerCert - server cetificate.
	pServerName - server name.
    
Returned Value:
   None

--*/

				

{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
  

    //
    // Build certificate chain.
    //

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

	//
	// BUGBUG - should we check revocation list 
	// with  CERT_CHAIN_REVOCATION_CHECK_CHAIN
	// as the six parameter 
	// of  CertGetCertificateChain function ?
	//
	CCertificateChain  pChainContext;
    if(!CertGetCertificateChain(
                            HCCE_LOCAL_MACHINE,
                            pServerCert,
                            NULL,
                            pServerCert->hCertStore,
                            &ChainPara,
                           	0, 
                            NULL,
                            pChainContext.getptr()))
    {
		TrERROR(St,"CertGetCertificateChain failed with error %x",GetLastError());
		throw exception();   
    }


    //
    // Validate certificate chain.
    // 

    memset(&polHttps,0, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = 0;
    polHttps.pwszServerName     = pServerName;

    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize  = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &polHttps;

    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if(!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_SSL,
                            pChainContext.get(),
                            &PolicyPara,
                            &PolicyStatus))
    {
		TrERROR(St,"Verify Certificate Chain Policy failed, Error=%x ",GetLastError());
		throw exception();   
    }


    if(PolicyStatus.dwError)
    {
		TrERROR(St,"Verify Certificate Chain Policy failed,  PolicyStatus.dwError=%x ",PolicyStatus.dwError);
		throw exception();   
    }
}



//---------------------------------------------------------
//
//  static callback member functions
//
//---------------------------------------------------------

void WINAPI CSSlNegotioation::Complete_NetworkConnect(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called when network connection completed succsefully.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
	MySelf->m_SimpleConnection = MySelf->m_SimpleWinsock.GetConnection();
	ASSERT(MySelf->m_SimpleConnection.get() != NULL); 

	try
	{
		if(MySelf->m_fUseProxy)
		{
			MySelf->SendSslProxyConnectRequest();
		}
		else
		{
			MySelf->SendStartConnectHandShake();
		}
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}
}

void WINAPI CSSlNegotioation::Complete_ConnectFailed(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called in any case of connection failure.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));

	MySelf->BackToCallerWithError();
}

void WINAPI  CSSlNegotioation::Complete_SendHandShakeData(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after sednding the first handshake data to the server completed
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));

	try
	{
		MySelf->ReadHandShakeData();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}

void WINAPI CSSlNegotioation::Complete_SendFinishConnect(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after sednding the end handshake data to the server completed
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
 	try
	{
		MySelf->AuthenticateServer();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}
}

void WINAPI CSSlNegotioation::Complete_ReadHandShakeResponse(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after reading data from the server completed
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));

	try
	{               
		MySelf->HandleHandShakeResponse();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}


void WINAPI CSSlNegotioation::Complete_SendSslProxyConnectRequest(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after sending "connect" request to the proxy completed.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
	try
	{               
		MySelf->ReadProxyConnectResponse();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}


void WINAPI CSSlNegotioation::Complete_ReadProxyConnectResponse(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called reading proxy partial response completed.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
	try
	{               
		MySelf->ReadProxyConnectResponseContinute();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}
}


//---------------------------------------------------------
//
//  none static callback member functions
//
//---------------------------------------------------------

CSSlNegotioation::CSSlNegotioation(
							CredHandle* pCredentialsHandle ,
						    const xwcs_t& ServerName,
						    USHORT ServerPort,
							bool fUseProxy
							):
						    EXOVERLAPPED(Complete_NetworkConnect,Complete_ConnectFailed),
							m_pCredentialsHandle(pCredentialsHandle),
							m_pServerName(ServerName.ToStr()),
						   	m_pSSlConnection(NULL),
						    m_callerOvl(NULL),
						  	m_fServerAuthenticate(true),
							m_ServerPort(ServerPort),
							m_fUseProxy(fUseProxy)

				
{

}





void CSSlNegotioation::SendStartConnectHandShake()
/*++

Routine Description:
    Start SSL connection handshake.
  
Arguments:
    None.
    
Returned Value:
    None

--*/

{
	if(m_pHandShakeBuffer.capacity() < CHandShakeBuffer::xReadBufferStartSize)
	{
		TrTRACE(St,"Creating new handshake buffer ");
		ASSERT(m_pHandShakeBuffer.size() == 0);
		m_pHandShakeBuffer.CreateNew();
	}
 
	//
    //  Initiate a ClientHello message and generate a token.
    //
	SecBuffer   OutBuffers;
    OutBuffers.pvBuffer   = NULL;
    OutBuffers.BufferType = SECBUFFER_TOKEN;
    OutBuffers.cbBuffer   = 0;

	SecBufferDesc   OutBuffer;
    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = &OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

	DWORD dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
						ISC_REQ_REPLAY_DETECT     |
						ISC_REQ_CONFIDENTIALITY   |
						ISC_RET_EXTENDED_ERROR    |
						ISC_REQ_ALLOCATE_MEMORY   |
						ISC_REQ_STREAM;


	DWORD           dwSSPIOutFlags;
	TimeStamp       tsExpiry;

    SECURITY_STATUS scRet = InitializeSecurityContext(
													m_pCredentialsHandle,
													NULL,
													m_pServerName.get(),
													dwSSPIFlags,
													0,
													SECURITY_NATIVE_DREP,
													NULL,
													0,
													m_hContext.getptr(),
													&OutBuffer,
													&dwSSPIOutFlags,
													&tsExpiry
													);



	if(scRet != SEC_I_CONTINUE_NEEDED || OutBuffers.cbBuffer == 0 )
    {
		TrERROR(St,"Initialize Security Context failed, Error=%x",scRet);
		throw exception();   
    }
   	


	//
    //save send buffer because we sent it ayncrounosly
	//
	m_SendConetext = OutBuffers.pvBuffer; 

	SetState(EXOVERLAPPED(Complete_SendHandShakeData,Complete_ConnectFailed));

	
	StpSendData(
		m_SimpleConnection,
		OutBuffers.pvBuffer,
		OutBuffers.cbBuffer,
		this
		);

}


void CSSlNegotioation::BackToCallerWithSuccess()
/*++

Routine Description:
    Called if connection was established. It signal the user overlapp
	with success code.
  
Arguments:
    None.
    
Returned Value:
    None

--*/
{
	TrTRACE(St,"connection established with %ls",m_pServerName.get());
	m_SendConetext.free();
	StpPostComplete(&m_callerOvl, STATUS_SUCCESS);
}


void  CSSlNegotioation::BackToCallerWithError()
/*++

Routine Description:
    Called if connection negotiation failed. It signal the user overlapp
	with error code.
  
Arguments:
    None.
    
Returned Value:
    None

--*/
{
	TrERROR(St,"connection negotiation failed with %ls",m_pServerName.get());
 	m_pHandShakeBuffer.free();
	m_SimpleConnection.free();
	m_SendConetext.free();
	StpPostComplete(&m_callerOvl,STATUS_UNSUCCESSFUL);
}


void CSSlNegotioation::CreateConnection(
		const SOCKADDR_IN& Addr,
		EXOVERLAPPED* pOverlapped
		)

/*++

Routine Description:
    Start SSL connection handshake.
  
Arguments:
 	 Addr - Address to connect to.
	 pOverlapped - function to call when finished or failed.
    
Returned Value:
    None

--*/
{
	ASSERT(pOverlapped != NULL);
	ASSERT(m_callerOvl == NULL);
	ASSERT(m_SimpleConnection.get() == NULL);

	TrTRACE(St,"Start connection negotiation with %ls",m_pServerName.get());

	SetState(EXOVERLAPPED(Complete_NetworkConnect,Complete_ConnectFailed));
	m_callerOvl =  pOverlapped;
	m_fServerAuthenticate = true;

	m_SimpleWinsock.CreateConnection(Addr, this);
}



void
CSSlNegotioation::ReConnect(
    const R<IConnection>& SimpleConnection,
    EXOVERLAPPED* pOverlapped
    )
{
	TrTRACE(St,"Start connection renegotiation with %ls",m_pServerName.get());
  
	m_callerOvl =  pOverlapped;
	m_SimpleConnection = SimpleConnection;
	m_fServerAuthenticate = false;
	m_pHandShakeBuffer.CreateNew();
	HankShakeLoop();
}


void CSSlNegotioation::HandleHandShakeResponse()
/*++

Routine Description:
     Called after client read data from the serve.
	 The data read will start handshake loop.
  
Arguments:
    None.
    
Returned Value:
    None

--*/
{
	//
	// if we did not read even single byte - this in an error
	// probably server closed the connection
	//
	DWORD ReadLen = DataTransferLength(*this);
	if(ReadLen == 0)
	{
		TrERROR(St,"Server closed the connection");
		throw exception();
	}
 	m_pHandShakeBuffer.resize(m_pHandShakeBuffer.size() + ReadLen);
	HankShakeLoop();
}


void CSSlNegotioation::SendFinishConnect(const void* pContext,DWORD len)
/*++

Routine Description:
	Send data to the server that finish successfuly the handshake,
  
Arguments:
	IN - pContext pointer to data to send.
	IN - len data length to send.

Returned Value:
	None

--*/
{
	SetState(EXOVERLAPPED(Complete_SendFinishConnect,Complete_ConnectFailed));


	StpSendData(
		m_SimpleConnection,
		pContext,
		len,
		this
		);

}



void CSSlNegotioation::SendContinuteConnect(const void* pContext,DWORD len)
/*++

Routine Description:
	Send token to the server and remaind in hankshake mode.  
  
Arguments:
	IN - pContext pointer to data to send.
	IN - len data length to send.

Returned Value:
	None

--*/



{
	SetState(EXOVERLAPPED(Complete_SendHandShakeData,Complete_ConnectFailed));


	StpSendData(
		m_SimpleConnection,
		pContext,
		len,
		this
		);

}



SecPkgContext_StreamSizes CSSlNegotioation::GetSizes() 
/*++

Routine Description:
	Get SSL sizes information of the header, trailer and max message.  
  
Arguments:


Returned Value:
	SSL sizes information structure.

--*/

{
	SecPkgContext_StreamSizes Sizes;

	//
    // Read stream encryption properties.
    //

    SECURITY_STATUS scRet = QueryContextAttributes(
								   m_hContext.getptr(),
                                   SECPKG_ATTR_STREAM_SIZES,
                                   &Sizes
								   );
    if(scRet != SEC_E_OK)
    {
		TrERROR(St,"QueryContextAttributes failed,Error=%x",scRet);
		throw exception();
    }

	return Sizes;
}



void CSSlNegotioation::AuthenticateServer()
/*++

Routine Description:
   Authenticate the server.
   Create new connection object if the server is
   authenticated.
  
Arguments:
	None

Returned Value:
	None

--*/
{

	if(!m_fServerAuthenticate)
	{
		BackToCallerWithSuccess();
		return;
	}

	// 
	//Get server's certificate.
	//
	CCertificateContext pRemoteCertContext;
	

    SECURITY_STATUS Status = QueryContextAttributes(
										m_hContext.getptr(),
										SECPKG_ATTR_REMOTE_CERT_CONTEXT,
										&pRemoteCertContext
										);
    if(Status != SEC_E_OK)
    {
		throw exception();
    }


	//
    // Attempt to validate server certificate.
	//
    VerifyServerCertificate(pRemoteCertContext,m_pServerName);
                                    

	//
	// create connection object
	//
	m_pSSlConnection = new CSSlConnection(
							m_hContext.getptr(),
							GetSizes(),
							m_SimpleConnection,
							*this
							);	


	//
	// at last we are connected !
	//
	BackToCallerWithSuccess();
}

void CSSlNegotioation::SetState(const EXOVERLAPPED& ovl)
{
	EXOVERLAPPED::operator=(ovl); //LINT !e530	 !e1013	  !e1015 !e534
}


void CSSlNegotioation::ReadHandShakeData()
/*++

Routine Description:
   Read hankshake data from the server.
  
Arguments:
	None

Returned Value:
	None

--*/
{
	ASSERT (m_pHandShakeBuffer.size() <=  m_pHandShakeBuffer.capacity());

	//
	//  if we need to resize the buffer 
	//
	if(m_pHandShakeBuffer.capacity() == m_pHandShakeBuffer.size())
	{
		m_pHandShakeBuffer.reserve(m_pHandShakeBuffer.size() * 2);		
	}
   	
   	SetState(EXOVERLAPPED(Complete_ReadHandShakeResponse, Complete_ConnectFailed));

	ReceivePartialBuffer(
					m_SimpleConnection,
					m_pHandShakeBuffer.begin() + m_pHandShakeBuffer.size(),
					m_pHandShakeBuffer.capacity() - m_pHandShakeBuffer.size(),
					this
					);

}


void CSSlNegotioation::ReadProxyConnectResponseContinute()
/*++

Routine Description:
	Continute reading the proxy connect response untill "\r\n\r\n"
  

Returned Value:
	None

--*/
{
 	DWORD ReadLen = DataTransferLength(*this);
	if(ReadLen == 0)
	{
		TrERROR(St,"Proxy closed the connection");
		throw exception();
	}

	const BYTE xProxyResponseEndStr[]= "\r\n\r\n";
	const BYTE* pFound = std::search(
					m_pHandShakeBuffer.begin(),
					m_pHandShakeBuffer.begin() + ReadLen,
					xProxyResponseEndStr,
					xProxyResponseEndStr + STRLEN(xProxyResponseEndStr)
					);
	//
	// make buffer ready for next step
	// we don't care about the proxy response data - just need to read it all
	// in order to start the ssl handshake.
	//
	m_pHandShakeBuffer.reset();

	//
	// if we did not find the "\r\n\r\n" in the response - continure reading
	//
	if(pFound == m_pHandShakeBuffer.begin() + ReadLen)
	{
		ReadProxyConnectResponse();
		return;
	}



	//
	// next step which is SSL handshake.
	//
	SendStartConnectHandShake();
}




void CSSlNegotioation::ReadProxyConnectResponse()
/*++

Routine Description:
  reading the proxy response fro the ssl connect request.
  

Returned Value:
	None

--*/
{
	SetState(EXOVERLAPPED(Complete_ReadProxyConnectResponse,Complete_ConnectFailed));
	
	
	ReceivePartialBuffer(
				m_SimpleConnection,
				m_pHandShakeBuffer.begin() + m_pHandShakeBuffer.size(),
				m_pHandShakeBuffer.capacity() - m_pHandShakeBuffer.size(),
				this
				);

}

void CSSlNegotioation::SendSslProxyConnectRequest()
/*++

Routine Description:
  Send to the proxy SSL connect request to remote host
  

Returned Value:
	None

Note:
	When working with proxy we must send special SSL connect request to the proxy
	before the handshake with the destination machine. This is needed because  proxy
	can't undestand the SSl handshake and don't know where to redirect the requst.
--*/
{

	char* ServerNameA = static_cast<char*>(_alloca(wcslen(m_pServerName.get()) + 1));
    sprintf(ServerNameA,"%ls",m_pServerName.get());


	//
	// preaper proxy connect(ssl tunneling) requset string
	//
	std::ostringstream ProxySSlConnectRequest;
	ProxySSlConnectRequest<<"CONNECT "
						  <<ServerNameA
					  	  <<':'
						  <<m_ServerPort
						  <<" HTTP/1.1\r\n\r\n";
							 

	m_ProxySSlConnectRequestStr =  ProxySSlConnectRequest.str();

	SetState(EXOVERLAPPED(Complete_SendSslProxyConnectRequest,Complete_ConnectFailed));
	StpSendData(
		m_SimpleConnection,
		m_ProxySSlConnectRequestStr.c_str(),
		m_ProxySSlConnectRequestStr.size(),
		this
		);

}


void 
CSSlNegotioation::HankShakeLoopContinuteNeeded(
	void* pContext,
	DWORD len,
	SecBuffer* pSecBuffer
	)
/*++

Routine Description:
   Continute the handshake loop.	
   Called by HankShakeLoop() when handshake loop is still going on.
  
Arguments:
	void* pContex - data to send to the server (if not NULL).
	len - context length.
	pSecBuffer - security buffer.

Returned Value:
	None

Note:
	If pSecBuffer has extra data - we use it as new input for HankShakeLoop(),
	otherwise - we send context data to the server , continute reading from server
	and staying	the  handshake loop.

--*/
{
	if(pSecBuffer->BufferType == SECBUFFER_EXTRA)
	{
			ASSERT(pContext == NULL);

			memmove(
				m_pHandShakeBuffer.begin(),
				m_pHandShakeBuffer.begin()+(m_pHandShakeBuffer.size() - pSecBuffer->cbBuffer),
				pSecBuffer->cbBuffer
				);

			m_pHandShakeBuffer.resize(pSecBuffer->cbBuffer);
			HankShakeLoop();
			return;
	}
	ASSERT(pContext != NULL);
	m_pHandShakeBuffer.reset();
	m_SendConetext	=  pContext;
	SendContinuteConnect(pContext, len);
}


void CSSlNegotioation::HankShakeLoopOk(const SecBuffer InBuffers[2], void* pContext, DWORD len)
/*++

Routine Description:
   Finish the Hand Shake loop.	
   Called by HankShakeLoop() when handshake loop finished successfully.
  
  
Arguments:
	void* pContex - data to send to the server (if not NULL).
					If pContex is NULL we go to do server authentication,
					otherwise - we send it to server and only then go to do server 
					authentication.
					  
	len - context len.

Returned Value:
	None

--*/
{

	//
	// check if server response has some application data for us - we should pointer to it
	//
	if(InBuffers[1].BufferType == SECBUFFER_EXTRA)
	{
        const BYTE* pInputBufferStart = static_cast<BYTE*>(InBuffers[0].pvBuffer);
        DWORD InputBufferLen = InBuffers[0].cbBuffer;
        DWORD ExtraDataLen = InBuffers[1].cbBuffer;
        const BYTE* pExtraDataPtr = pInputBufferStart + InputBufferLen - ExtraDataLen;
		xustr_t Exdata(pExtraDataPtr, ExtraDataLen);
        ASSERT(Exdata.Buffer() + Exdata.Length() == pInputBufferStart + InputBufferLen);
		m_pHandShakeBuffer.ExtraData(Exdata);
	}


	//
	// We need to send token to server
	//
	if(pContext != NULL)
	{
		//
		// send data token to server and we are done
		//
		m_SendConetext	=  pContext;
		SendFinishConnect(pContext,len);
		return;
	}

	//
	// now we should authenticate the server
	//
	AuthenticateServer();
}


void CSSlNegotioation::HankShakeLoop()
/*++

Routine Description:
   Perform the connection state machine loop.
  
Arguments:
	None

Returned Value:
	None

Note:
	The function is called after we have some data read from the server
	and it ask SSPI what to do next.

--*/
{
	//
    // Set up the input buffers. Buffer 0 is used to pass in data
    // received from the server. Schannel will consume some or all
    // of this. Leftover data (if any) will be placed in buffer 1 and
    // given a buffer type of SECBUFFER_EXTRA.
    //
	SecBuffer       InBuffers[2];

     
    InBuffers[0].pvBuffer   = m_pHandShakeBuffer.begin();
    InBuffers[0].cbBuffer   = numeric_cast<DWORD>(m_pHandShakeBuffer.size());
    InBuffers[0].BufferType = SECBUFFER_TOKEN;

    InBuffers[1].pvBuffer   = NULL;
    InBuffers[1].cbBuffer   = 0;
    InBuffers[1].BufferType = SECBUFFER_EMPTY;

	SecBufferDesc   InBuffer;
    InBuffer.cBuffers       = TABLE_SIZE(InBuffers);
    InBuffer.pBuffers       = InBuffers;
    InBuffer.ulVersion      = SECBUFFER_VERSION;

	
	SecBuffer       OutBuffers;
    OutBuffers.pvBuffer  = NULL;
    OutBuffers.BufferType= SECBUFFER_TOKEN;
    OutBuffers.cbBuffer  = 0;

	
	SecBufferDesc   OutBuffer;
    OutBuffer.cBuffers      = 1;
    OutBuffer.pBuffers      = &OutBuffers;
    OutBuffer.ulVersion     = SECBUFFER_VERSION;

	DWORD dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
					    ISC_REQ_REPLAY_DETECT     |
					    ISC_REQ_CONFIDENTIALITY   |
					    ISC_RET_EXTENDED_ERROR    |
					    ISC_REQ_ALLOCATE_MEMORY   |
					    ISC_REQ_STREAM;

	TimeStamp       tsExpiry;
	DWORD           dwSSPIOutFlags;

    //
    // Call InitializeSecurityContext to see what to do next
    //
    SECURITY_STATUS scRet  = InitializeSecurityContext(
											  m_pCredentialsHandle,
											  m_hContext.getptr(),
											  NULL,
											  dwSSPIFlags,
											  0,
											  SECURITY_NATIVE_DREP,
											  &InBuffer,
											  0,
											  NULL,
											  &OutBuffer,
											  &dwSSPIOutFlags,
											  &tsExpiry
											  );


	//
	// we should read more from the server
	//
	if(scRet == SEC_E_INCOMPLETE_MESSAGE)
	{
		ReadHandShakeData();
		return;
	}

	//
	// if the connection negotiation is not completed
	// 
	if(scRet == SEC_I_CONTINUE_NEEDED)
	{
		HankShakeLoopContinuteNeeded(OutBuffers.pvBuffer, OutBuffers.cbBuffer, &InBuffers[1] );	
		return;
	}

	//
	// it is completed
	//
	if(scRet == SEC_E_OK )
	{
		HankShakeLoopOk(InBuffers, OutBuffers.pvBuffer, OutBuffers.cbBuffer);	
		return;
	}

	//
	// Otherwise - it is something unexpected
	//
	TrERROR(St,"Could not Initialize Security Context, Error=%x",scRet);
	throw exception();
}


R<IConnection> CSSlNegotioation::GetConnection()
{
	ASSERT(m_pSSlConnection.get() != NULL);
	return m_pSSlConnection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslrd.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslrd.cpp	    

Abstract:
    implementation class CSSlReceiver declared in stsslrd.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#include <libpch.h>
#include <no.h>
#include "stsslrd.h"
#include "stp.h"
#include "stsslng.h"
#include "stsslco.h"


#include "stsslrd.tmh"

//---------------------------------------------------------
//
//  static helper  functions
//
//---------------------------------------------------------


static void SetReadCount(EXOVERLAPPED* pOvl,DWORD rcount)
{
	pOvl->InternalHigh = rcount;
}




//---------------------------------------------------------
//
//  static members callback functions
//
//---------------------------------------------------------


void WINAPI CSSlReceiver::Complete_ReceivePartialData(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called reading server partial response completed.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlReceiver* MySelf = static_cast<CSSlReceiver*>(pOvl);
	try
	{
		MySelf->ReceivePartialData();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}


void WINAPI CSSlReceiver::Complete_ReceiveFailed(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called in all cases of receive error.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlReceiver* MySelf = static_cast<CSSlReceiver*>(pOvl);
	MySelf->BackToCallerWithError();	
}




//---------------------------------------------------------
//
//  non static members  functions
//
//---------------------------------------------------------



CSSlReceiver::CSSlReceiver(
						PCredHandle SecContext,
						const SecPkgContext_StreamSizes& sizes,
						CSSlNegotioation& SSlNegotioation,
						CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
						):
						EXOVERLAPPED(Complete_ReceivePartialData,Complete_ReceiveFailed),
						m_DecryptionBuffer(sizes.cbMaximumMessage),
						m_SecContext(SecContext),
						m_Sizes(sizes),
						m_callerOvl(NULL),
						m_CSSlNegotioation(SSlNegotioation),
						m_ReadWriteLockAsyncExcutor(ReadWriteLockAsyncExcutor)
					
					
{
	CopyExtraData();
}


CSSlReceiver::~CSSlReceiver()
{
	//
	// ASSERT that there is no pending receive
	//
	ASSERT(m_callerOvl == 0);
}


void CSSlReceiver::IOReadMoreData()
{

	if(m_DecryptionBuffer.capacity()  == 	m_DecryptionBuffer.size())
	{
		TrTRACE(St,"Decryption buffer needs reallocation");
		m_DecryptionBuffer.reserve(m_DecryptionBuffer.size() * 2);
		ASSERT(m_DecryptionBuffer.capacity() > 0);
	}

	SetState(EXOVERLAPPED(Complete_ReceivePartialData,Complete_ReceiveFailed));

	DWORD size = numeric_cast<DWORD>(m_DecryptionBuffer.capacity() - m_DecryptionBuffer.size());
	m_SimpleConnection->ReceivePartialBuffer(
								m_DecryptionBuffer.begin() + m_DecryptionBuffer.size(),
								size,
								this
								);

}

size_t CSSlReceiver::WriteDataToCaller()
/*++

Routine Description:
    Write decrypted data to caller buffer.
  
Arguments:
  
  
Returned Value:
Number of bytes written.

--*/
{
	        
	       
			size_t written = m_UserReceiveBuffer.Write(
							m_DecryptionBuffer.begin(),
							m_DecryptionBuffer.DecryptedSize()
							);

			if(written == 0)
			{
				return 0;
			}

			//
			// shift remaining data to the buffer start
			//

			memmove(
				m_DecryptionBuffer.begin(),
				m_DecryptionBuffer.begin() + written,
				m_DecryptionBuffer.size() - written
				);

			m_DecryptionBuffer.DecryptedSize(m_DecryptionBuffer.DecryptedSize() - written);
			m_DecryptionBuffer.resize(m_DecryptionBuffer.size() - written);

			return written;	
}

void CSSlReceiver::ReceivePartialBufferInternal(			                          
						VOID* pBuffer,                                     
						DWORD Size 
						)

{
	m_UserReceiveBuffer.CreateNew(pBuffer,Size);


	//
	// write decrypted data left out to caller
	//
	size_t written = WriteDataToCaller();
	if(written != 0)
	{
		BackToCallerWithSuccess(written);
		return;
	}

	//
	// if we still have data to decrypte - decrypte it -
	// otherwise - go read more data
	//
	if(m_DecryptionBuffer.size()> 0)
	{
		ReceivePartialDataContinute();
	}
	else
	{
		IOReadMoreData();
	}
}

void CSSlReceiver::ReceivePartialBuffer(
						const R<IConnection>& SimpleConnection,                                              
						VOID* pBuffer,                                     
						DWORD Size, 
						EXOVERLAPPED* pov
						)

/*++

Routine Description:
    Receive data from the socket. 
  
Arguments:
	SimpleConnection - Connection to read from.
	pBuffer - Caller buffer                                     
	Size - Size of the buffer 
	pov	 - Caller overlap to signal when end
  
  
Returned Value:
None

--*/
{	
	ASSERT(SimpleConnection.get() != NULL);
	ASSERT(pov != NULL);
	ASSERT(m_callerOvl == NULL);
	ASSERT(Size != 0);
	ASSERT(pBuffer != NULL);
 	m_callerOvl = pov;
	m_SimpleConnection = SimpleConnection;

	TrTRACE(St,"Receive Partial Buffer called");


	//
	// make sure we zero caller overlapp in case of exception (to ease debugging)
	//
 	CAutoZeroPtr<EXOVERLAPPED>	AutoZeroPtr(&m_callerOvl);

 	ReceivePartialBufferInternal(pBuffer, Size);

	//
	//caller overlapp will be zero when we finish asynchronously 
	//
	AutoZeroPtr.detach();
}



SECURITY_STATUS CSSlReceiver::TryDecrypteMessage()
/*++

Routine Description:
    try to decrypte message we got. If we can decrytpte it
	(SEC_E_OK from 	DecryptMessage call) we move block in the read buffer
	so the all decrypted data is at the start and then extra ,
	non decrypted data. We throw away SSL header and trailer data.
  
Arguments:
    None.
  
Returned Value:
   return value of DecryptMessage.  

--*/


		  
{
	ASSERT(m_DecryptionBuffer.DecryptedSize() == 0);

	SecBuffer  Buffers[4];
	Buffers[0].pvBuffer     = m_DecryptionBuffer.begin();
	Buffers[0].cbBuffer     = numeric_cast<DWORD>(m_DecryptionBuffer.size());
	Buffers[0].BufferType   = SECBUFFER_DATA;

	Buffers[1].BufferType   = SECBUFFER_EMPTY;
	Buffers[2].BufferType   = SECBUFFER_EMPTY;
	Buffers[3].BufferType   = SECBUFFER_EMPTY;

	SecBufferDesc   Message;
	Message.ulVersion       = SECBUFFER_VERSION;
	Message.cBuffers        = TABLE_SIZE(Buffers);
	Message.pBuffers        = Buffers;

	SECURITY_STATUS scRet = DecryptMessage(m_SecContext, &Message, 0, NULL);
	if(scRet != SEC_E_OK)
	{
		return scRet;	
	}
 
	//
	// find data and extra (non decrypted) buffers
	//
	SecBuffer* pExtraBuffer = NULL;
	SecBuffer* pDataBuffer = NULL;
	for(DWORD i = 1; i <Message.cBuffers ; i++)
	{
		if(pExtraBuffer == NULL && Buffers[i].BufferType == SECBUFFER_EXTRA )
		{
			pExtraBuffer = &Buffers[i];
		}

		if(pDataBuffer == NULL && Buffers[i].BufferType == SECBUFFER_DATA )
		{
			pDataBuffer = &Buffers[i];
		}
	}
			
	//
	// shift decryption buffer so we have only data (no ssl header)
	//
	ASSERT(pDataBuffer != NULL);
	memmove(
		m_DecryptionBuffer.begin(),
		pDataBuffer->pvBuffer,
		pDataBuffer->cbBuffer
		);
  	m_DecryptionBuffer.DecryptedSize(pDataBuffer->cbBuffer);
	m_DecryptionBuffer.resize(m_DecryptionBuffer.DecryptedSize());


	//
	// shift extra buffer (not decrypted) just after the data
	//
	if(pExtraBuffer != NULL)
	{
		ASSERT(pExtraBuffer->pvBuffer >	pDataBuffer->pvBuffer);
		memmove(
			m_DecryptionBuffer.begin() + m_DecryptionBuffer.DecryptedSize(),
			pExtraBuffer->pvBuffer,
			pExtraBuffer->cbBuffer
			);
		m_DecryptionBuffer.resize(m_DecryptionBuffer.size() + pExtraBuffer->cbBuffer);
	}

 	return 	scRet;
}


void CSSlReceiver::ReceivePartialData()
{
/*++

Routine Description:
Called after read operation - check what we read and try to decrypt. 
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
 	DWORD ReadLen = DataTransferLength(*this);
	if(ReadLen == 0)
	{
		TrERROR(St,"Server closed the connection");
		BackToCallerWithSuccess(0);
		return;
	}
	m_DecryptionBuffer.resize(m_DecryptionBuffer.size() + ReadLen);
	ReceivePartialDataContinute();
}


void CSSlReceiver::ReceivePartialDataContinute()
/*++

Routine Description:
Called after read operation - check what we read and try to decrypt. 
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
  	SECURITY_STATUS scRet = TryDecrypteMessage();
	size_t written; 
	switch(scRet)
	{
		//
		// read more
		//
		case SEC_E_INCOMPLETE_MESSAGE:
		IOReadMoreData();
		return;

		//
		// renegotiation
		//
		case SEC_I_RENEGOTIATE:
		Renegotiate();
		return;

		//
		// the data was decrypted ok
		//
		case SEC_E_OK:
		written = WriteDataToCaller();
		ASSERT(written != 0);
		BackToCallerWithSuccess(written);
		return;
	

		default:
		TrERROR(St,"Could not Decrypt Message Error=%x",scRet);
		throw exception();
	}

}


void CSSlReceiver::Renegotiate()
/*++

Routine Description:
Start new ssl connection handshake. 
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
	TrTRACE(St,"Start Renegotiation");

	R<CReNegotioationRequest> ReNegotioationRequest = new CReNegotioationRequest(*this);

	//
	// Needs additional ref count for the async operation.
	//
	R<CReNegotioationRequest>  AsyncOperationRef = ReNegotioationRequest; 	

	m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderWriteLock(ReNegotioationRequest.get());

	AsyncOperationRef.detach();
}

void CSSlReceiver::RenegotiateFailed()
{
	TrERROR(St,"Renegotiation failed");
	BackToCallerWithError();
}


void CSSlReceiver::BackToCallerWithError()
{
	TrERROR(St,"Receive Failed");
	StpPostComplete(&m_callerOvl,STATUS_UNSUCCESSFUL);
}


void CSSlReceiver::BackToCallerWithSuccess(size_t read)
{
	DWORD dwread = numeric_cast<DWORD>(read);
	TrTRACE(St,"Receive Completed Ok reading %d bytes",dwread);
	SetReadCount(m_callerOvl,dwread);
	StpPostComplete(&m_callerOvl,STATUS_SUCCESS);
}


void CSSlReceiver::SetState(const EXOVERLAPPED& ovl)
{
	EXOVERLAPPED::operator=(ovl); //LINT !e530 !e534 !e1013 !e1015  	!e10
}

void CSSlReceiver::RenegotiateCompleted()
/*++

Routine Description:
ssl connection handshake. finished ok - continute reading
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
	TrTRACE(St,"Renegotiation Finished");
	
	m_DecryptionBuffer.reset();

	//
	//copy application data (if any) send with the negotiation
	//
	CopyExtraData();

	
	
	ReceivePartialDataContinute();
}

void CSSlReceiver::CopyExtraData()
/*++

Routine Description:
Copy application data (needs decryption !) sent from the server as part of finishing the handshake.
In theory - server can do it - in practice I have not seen it yet.
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
	xustr_t ExtraData =  m_CSSlNegotioation.ExtraData();
	DWORD ExtraDataLen = ExtraData.Length();
	if(ExtraDataLen != 0)
	{
		TrTRACE(St,"Copy application data sent as part of the connection negotiation");
		m_DecryptionBuffer.reserve(ExtraDataLen);
		
		//
		//copy application data from negotiation buffer (this data is application encrypted data)
		//
		memmove(
			m_DecryptionBuffer.begin(),
			ExtraData.Buffer(),
			ExtraDataLen
			);

		m_DecryptionBuffer.resize(ExtraDataLen);
	}
	m_CSSlNegotioation.FreeHandShakeBuffer();
}



void CReNegotioationRequest::Run()
/*++

Routine Description:
Start renegotiation execution.
  
Arguments:
    None.
  
Returned Value:
	None
	
Note - Run() and Close() cannot be called at the same time.
They are sync  by CReadWriteLockAsyncExcutor.

--*/
{
	m_SSlReceiver.m_CSSlNegotioation.ReConnect(m_SSlReceiver.m_SimpleConnection, this);
	m_fRun = true;
}


void CReNegotioationRequest::Close()throw()
/*++

Routine Description:
Force renegotiation callback  by explicit call back with error.

  
Arguments:
    None.
  
Returned Value:
	None		

Note - Run() and Close() cannot be called at the same time.
	They are sync  by CReadWriteLockAsyncExcutor.

  
--*/
{
	ASSERT(!m_fRun);
	SetStatus(STATUS_UNSUCCESSFUL);
	ExPostRequest(this);
}



void WINAPI  CReNegotioationRequest::Complete_RenegotiateFailed(EXOVERLAPPED* pOvl)
{
	CReNegotioationRequest* me = static_cast<CReNegotioationRequest*>(pOvl);
	R<CReNegotioationRequest> AutoDelete(me); 
	me->m_SSlReceiver.m_ReadWriteLockAsyncExcutor.UnlockWrite();

	me->m_SSlReceiver.RenegotiateFailed();
}


void WINAPI  CReNegotioationRequest::Complete_Renegotiate(EXOVERLAPPED* pOvl)
{
	CReNegotioationRequest* me = static_cast<CReNegotioationRequest*>(pOvl);
	R<CReNegotioationRequest> AutoDelete(me); 
	me->m_SSlReceiver.m_ReadWriteLockAsyncExcutor.UnlockWrite();

	try
	{
		me->m_SSlReceiver.RenegotiateCompleted();
	}
	catch(exception&)
	{
		me->m_SSlReceiver.RenegotiateFailed();		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\lib\stsslsn.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslsn.h

Abstract:
    implementation class CSSlSender declared in mtsslsn.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#include <libpch.h>
#include <no.h>
#include <rwlockexe.h>
#include "stsslng.h"
#include "stsslsn.h"
#include "stp.h"
#include "encryptor.h"
#include "sendchunks.h"


#include "stsslsn.tmh"

//---------------------------------------------------------
//
//  class CSSLAsyncSend resposibile to encrypte the data 
//  using encryptor class (CSSlEncryptor) and to send it over the SSL connection.
//  On send completion,  it callback to a CSSlSender object it holds
//  
//---------------------------------------------------------
class CSSLAsyncSend : public EXOVERLAPPED, public IAsyncExecutionRequest, public CReference
{
public:
	CSSLAsyncSend(
		PCredHandle SecContext,	
		const SecPkgContext_StreamSizes& Sizes,
		const R<IConnection>& SimpleConnection,
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov,
		CSSlSender* pSSlSender
		):
		EXOVERLAPPED(OnSendOk, OnSendFailed),
		m_SendChunks(Buffers, nBuffers),
		m_SSlEncryptor(Sizes, SecContext),
		m_MaximumMessageLen(Sizes.cbMaximumMessage),
		m_SimpleConnection(SimpleConnection),
		m_pov(pov),
		m_pSSlSender(pSSlSender),
		m_fRun(false)
		
	{
	}

private:
	virtual void Run()	
	{
		ASSERT(!m_fRun);

		EncryptAllChunks();	
		Send();

		m_fRun = true;
	}


	void Send()	
	{
		DWORD size = numeric_cast<DWORD>(m_SSlEncryptor.GetEncrypted().size());
		ASSERT(size != 0);
	
		m_SimpleConnection->Send(	
						m_SSlEncryptor.GetEncrypted().begin(),
						size,
						this
						);
	}


	//
	// Force callback - by doing explicit call back with error.
	//
	virtual void Close()throw()
	{
		ASSERT(!m_fRun);
		SetStatus(STATUS_UNSUCCESSFUL);
		ExPostRequest(this);		
	}


private:
	void EncryptAllChunks()
	{
		for(;;)
        {
			const void* pChunk;
			DWORD len;

			m_SendChunks.GetNextChunk(m_MaximumMessageLen, &pChunk, &len);
			if(pChunk == NULL)
				return;   
			
			m_SSlEncryptor.Append(pChunk , len);
        }
	}

		
private:
	static void WINAPI OnSendOk(EXOVERLAPPED* pov)
	{
		CSSLAsyncSend* myself = static_cast<CSSLAsyncSend*>(pov);		
		myself->m_pSSlSender->OnSendOk(myself,  myself->m_pov);	
	}



	static void WINAPI OnSendFailed(EXOVERLAPPED* pov)
	{
		CSSLAsyncSend* myself = static_cast<CSSLAsyncSend*>(pov);
		myself->m_pSSlSender->OnSendFailed(myself, myself->m_pov);
	}


private:	
	CSendChunks m_SendChunks;
	CSSlEncryptor m_SSlEncryptor;
	PCredHandle m_SecContext;	
	R<IConnection> m_SimpleConnection;
	const WSABUF* m_Buffers;                                     
	DWORD m_nBuffers; 
	EXOVERLAPPED* m_pov;
	CSSlSender* m_pSSlSender;
	DWORD  m_MaximumMessageLen;
	bool m_fRun;
};




CSSlSender::CSSlSender(
						PCredHandle SecContext,
						const SecPkgContext_StreamSizes& sizes,
						const CSSlNegotioation& SSlNegotioation,
						CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
						):
						m_SecContext(SecContext),
						m_Sizes(sizes),
						m_SSlNegotioation(SSlNegotioation),
						m_ReadWriteLockAsyncExcutor(ReadWriteLockAsyncExcutor)

{
}


void 
CSSlSender::Send(
	const R<IConnection>& SimpleConnection,                                              
	const WSABUF* Buffers,                                     
	DWORD nBuffers, 
	EXOVERLAPPED* pov
	)

/*++

Routine Description:
    Encrypte and send data buffers over ssl connection. 
  
Arguments:
	IN - Socket - connected ssl socket	.
	IN - Buffers - DATA buffers to send
	IN - nBuffers - number of buffers
	IN - pov - overlapp to finish the asyncrounous operation.
  
Returned Value:
None

--*/
{
	ASSERT(SimpleConnection.get() != NULL);

	R<CSSLAsyncSend> pSSLAsyncSend =  new CSSLAsyncSend(
												m_SecContext,	
												m_Sizes,
												SimpleConnection,
												Buffers,                                     
												nBuffers, 
												pov,
												this
												);
	//
	// Needs additional ref count for the async operation.
	//
	R<CSSLAsyncSend> AsyncOperationRef = pSSLAsyncSend;
	
	m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderReadLock(pSSLAsyncSend.get());

	AsyncOperationRef.detach();
}
  

void CSSlSender::OnSendFailed(CSSLAsyncSend* pSSLAsyncSend, EXOVERLAPPED* pov)
{
	pSSLAsyncSend->Release();
	m_ReadWriteLockAsyncExcutor.UnlockRead();
		
	pov->SetStatus(STATUS_UNSUCCESSFUL);
	ExPostRequest(pov);
}


void CSSlSender::OnSendOk(CSSLAsyncSend* pSSLAsyncSend,  EXOVERLAPPED* pov)
{
	pSSLAsyncSend->Release();
	m_ReadWriteLockAsyncExcutor.UnlockRead();


	pov->SetStatus(STATUS_SUCCESS);
	ExPostRequest(pov);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\clparser.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    clparser.h

Abstract:
    Class for parsing command line arguments
	The command line argument are in the format of "/token":"literal"

	Usage :
	main(int argc, WCHAR* argv[])
	{
	   CClParser<WCHAR> ClParser(argc, argv);
	   std::wstring name = ClParser[L"name"]; //get the literal for L"name" token
	   std::wstring Length = ClParser[L"l"];  //get the literal for L"l" token
	   bool b = ClParser.IsExists(L"p");      // does L"/p" exsists in the commandline ?
	} 	

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent

--*/

        
#ifndef CLPARSER_H
#define CLPARSER_H
 

template <class T>
class CClParser     
{   
	typedef std::basic_string<T> String;
public:
	CClParser(int argc, T* const* argv);
    bool IsExists(const T*  pToken)const;
    String operator[](const T* pToken)const;
	size_t GetNumber(const T*  pToken)const;

private:
	void ParseToken(const String& str);


private:
    std::map<String,String> m_map;
};    



template <class T> inline CClParser<T>::CClParser(int argc, T*const * argv)
{
    for (int i=1; i<argc; i++)
    {
        ParseToken(argv[i]);
    }
}

template <class T> inline size_t CClParser<T>::GetNumber(const T*  pToken)const
{
	std::map<String,String>::const_iterator it = m_map.find(String(pToken));
	if(it == m_map.end())
	{
		return 0;
	}
	std::basic_istringstream<T> istr(it->second);
	size_t value = 0;
	istr>>value;
	return value;
}


template <class T> inline void CClParser<T>::ParseToken(const String& str)
/*++

Routine Description:
 Get staring from the format /"token":"literal" and insert in into map
 when token is the key and literal is the value.

Arguments:
    str - string to parse.
     
Returned Value:
    None.
    
--*/
{   
	String::const_iterator StartToken = std::find(
										str.begin(),
										str.end(), 
										std::ctype<T>().widen('/')
										);

	String::const_iterator StartLiteral = std::find(
											str.begin(), 
											str.end(),
											std::ctype<T>().widen(':')
											);
										
	if(StartToken == str.end() ||	StartToken !=  str.begin()  )
	{
		return;
	}
	ASSERT(StartToken <  StartLiteral);

	String token (++StartToken , StartLiteral);

	//
	// if no ':" found - the literal considered as empty string ("")
	//
	if(StartLiteral == str.end())	
	{
		m_map[token] = String();
		return;
	}
	
	m_map[token] = String(++StartLiteral, str.end());
}


template <class T> inline bool CClParser<T>::IsExists(const T* pToken)const
/*++

Routine Description:
 Check if given token is exists in the command line

Arguments:
    pToken - token to check.
     
Returned Value:
   true if exists - false otherwise.
    
--*/
{
    std::map<String,String>::const_iterator p = m_map.find(String(pToken));
    return p != m_map.end();
}


template <class T> 
inline 
CClParser<T>::String 
CClParser<T>::operator[](
	const T*  pToken
	)const

/*++

Routine Description:
 Get literal for given token

Arguments:
    pToken - token. 
     
Returned Value:
   The literal that match the token or empty string if not exists.
    
--*/
{
	std::map<String,String>::const_iterator it = m_map.find(String(pToken));
	if(it != m_map.end())
	{
		return it->second;
	}
	return String();
}



 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\envcreate.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcreate.h

Abstract:
    Header for creating test envelop

Author:
    Gil Shafriri (gilsh) 07-Jan-2001

--*/


#ifndef _MSMQ_Envcreate_H_
#define _MSMQ_Envcreate_H_
std::string CreateEnvelop(const std::string& FileName,const std::string& Host,const std::string& Resource);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\sendbuffers.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SendBuffers.h

Abstract:
    Header for class CSendBuffers that create delivery buffers.

Author:
    Gil Shafriri (gilsh) 07-Jan-2001

--*/


#ifndef _MSMQ_CreateBufers_H_
#define _MSMQ_CreateBufers_H_

#include <buffer.h>
#include <xstr.h>

class CSendBuffers : public CReference
{
public:
	CSendBuffers(
		const std::string& Env, 
		const std::string& Host, 
		const std::string& Resource,
		const std::string& MessageBody
		);


public:
	size_t GetNumberOfBuffers() const;
	const WSABUF* GetSendBuffers() const;
	size_t GetSendDataLength() const;
	char*  SerializeSendData() const;


private:
	void CreateMultipartHeaders(
						const std::string& Host,
						const std::string& Resource
						);


	DWORD GenerateEnvelopeAttachmentHeader(
							DWORD dataSize,
							DWORD boundaryId
							);


	DWORD GenerateMultipartAttachmentHeader(
							DWORD dataSize,
							const xstr_t& contentId,
							DWORD boundaryId
							);


	void SetBufferPointers();

private:
	std::string m_envelope;
	std::string m_MessageBody;
	std::vector<WSABUF> m_buffers;
	CResizeBuffer<char>  m_HttpRequestData;
};






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\senderthread.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SenderThread.h

Abstract:
    Implements class CSenderThread that sends http\https request to a server

Author:
    Gil Shafriri (gilsh) 07-Jan-2001
--*/

#include <libpch.h>
#include <st.h>
#include <tr.h>
#include "senderthread.h"
#include "SendBuffers.h"
#include "envcreate.h"
#include "stp.h"

#include "senderthread.tmh"

const TraceIdEntry StTest = L"Socket Transport Test";

using namespace std;


static string WstringTostring(const wstring& wstr)
{
	string str( wstr.size(),' ');
	for(wstring::size_type i=0; i<wstr.size(); ++i)
	{
		str[i] = ctype<WCHAR>().narrow(wstr[i]);
	}
	return str;
}


//
// print server response data
//
static void DumpData(const char* data,size_t size)
{
	stringstream str;
	str.write(data,size);
	printf("ServerResponse : %s", str.str().c_str());
}



//
// return pointer in a response buffer where header ends (after \r\n\r\n") .
// 0 is returned if no header end found 
//
static size_t FindEndOfResponseHeader(const char* buf, size_t len)
{
	const char Termination[] = "\r\n\r\n";
	const char* found = search(buf, buf + len, Termination, Termination + STRLEN(Termination));
	return found == buf + len ? 0 : found + STRLEN(Termination) - buf ;
}




//
// get status code from response headers
//
static size_t GetStatus(LPCSTR p, size_t length)
{
	if(length <  STRLEN("HTTP/1.1"))
	{
		throw exception();	
	}
	istringstream statusstr(string(p + STRLEN("HTTP/1.1"),length - STRLEN("HTTP/1.1")) );
	USHORT status;
	statusstr>>status;
	if(!statusstr)
	{
		throw exception();		
	}
	return status;
}


bool IsContinuteResponse(LPCSTR p, size_t len)
{
	return GetStatus(p, len) == 100;
}



static size_t GetContentLength(LPCSTR p, size_t length)
{
	const char xContentlength[] = "Content-Length:";
	const char* found = search(
						p, 
						p + length,xContentlength, 
						xContentlength + STRLEN(xContentlength)
						);

	if(found == p + length || (found += STRLEN(xContentlength)) == p + length)
	{
		return 0;
	}

	istringstream contextLengthStr(string(found,p + length - found));
	size_t  Contentlength;
	contextLengthStr>>Contentlength;
	if(!contextLengthStr)
	{
		throw exception();		
	}
	return 	Contentlength;
}



//
// create event that test user will wait on untill test loop ends
//
static HANDLE CreateEndEvent()
{
	HANDLE event = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(event == NULL)
	{
		printf("Create event failed, Error=%d\n",GetLastError());
		throw exception();
	}
	return 	event;
}




CSenderThread::CSenderThread(
	const CClParser<WCHAR>& ClParser
	):
	EXOVERLAPPED(Complete_Connect, Complete_ConnectFailed),
	m_ClParser(ClParser),
	m_event(CreateEndEvent()),
	m_pTransport(CreateTransport()),
	m_ReadBuffer(1024),
	m_TotalRequestCount(GetTotalRequestCount()),
	m_CurrentRequestCount(0)
{

}


string CSenderThread::GenerateBody()  const
{
	size_t BodyLen =  m_ClParser.IsExists(L"bl") ? m_ClParser.GetNumber(L"bl") : xDeafultBodyLen;

	return string(BodyLen, 'a');
}


string CSenderThread::GetResource()  const
{
	wstring Resource;
	if(!m_ClParser.IsExists(L"p"))
	{
		Resource = m_ClParser[L"r"];				
	}
	else
	{
		Resource = wstring(L"HTTP://") + m_ClParser[L"h"] + m_ClParser[L"r"];
	}
	return 	WstringTostring(Resource);
}


R<CSendBuffers> CSenderThread::GetSendBuffers()	 const
{
	
	string Host =   WstringTostring(m_ClParser[L"h"]);
	string Resource = GetResource();
   	string Envelope = CreateEnvelop(WstringTostring(m_ClParser[L"f"]), Host, Resource);
	string MessageBody  = GenerateBody();

	return new CSendBuffers(Envelope,  Host, Resource, MessageBody);
}


CSenderThread::~CSenderThread()
{

}


//
// called by CStTest user after  CStTest::Run called to wait for end
//
void CSenderThread::WaitForEnd()
{
	WaitForSingleObject(m_event,INFINITE);
}


//
// Test failed - for what ever reason
//
void CSenderThread::Failed()
{
	SetEvent(m_event);
}


//
// create transport interafce - simple winsock transport or ssl transport
//
ISocketTransport* CSenderThread::CreateTransport()const
{
	if(!m_ClParser.IsExists(L"s") )
	{
		return StCreateSimpleWinsockTransport();
	}

	wstring  pServerName =  m_ClParser[L"h"];

	return StCreateSslWinsockTransport(
						xwcs_t(pServerName.c_str(), pServerName.size()),
						GetNextHopPort(),
						m_ClParser.IsExists(L"p")
						);


}



wstring CSenderThread::GetNextHop() const
{
	return m_ClParser.IsExists(L"p") ? m_ClParser[L"p"] : m_ClParser[L"h"];
}



USHORT CSenderThread::GetProtocolPort() const
{
	return m_ClParser.IsExists(L"s") ? x_DefaultHttpsPort : x_DefaultHttpPort; 
}



size_t CSenderThread::GetTotalRequestCount() const
{
	return m_ClParser.IsExists(L"rc") ? m_ClParser.GetNumber(L"rc") : xDefaultRequestCount;
}


USHORT CSenderThread::GetProxyPort() const
{
	return (USHORT)(m_ClParser.IsExists(L"pp") ? m_ClParser.GetNumber(L"pp") : xDefaultProxyPort);
}


USHORT CSenderThread::GetNextHopPort() const
{
	return m_ClParser.IsExists(L"p") ? GetProxyPort() : GetProtocolPort();
}



//
// Start running test state machine  by connecting to the server
//
void CSenderThread::Run()
{
	
	std::vector<SOCKADDR_IN> Address;
	wstring NextHop = GetNextHop();
	bool fRet = m_pTransport->GetHostByName(NextHop.c_str(), &Address); 
    if (!fRet)
    {
        printf("Failed to resolve address for '%ls'\n", NextHop.c_str());
        throw exception();
    }

	Address[0].sin_port = htons(GetNextHopPort());
 	m_pTransport->CreateConnection(Address[0], this);
}



//
// called when connecting to the server completed - call to send request
// to the server.
//
void WINAPI CSenderThread::Complete_Connect(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	MySelf->m_Connection  =  MySelf->m_pTransport->GetConnection();
	try
	{
		MySelf->SendRequest();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}


void CSenderThread::SetState(const EXOVERLAPPED& ovl)
{
	EXOVERLAPPED::operator=(ovl);	
}


void CSenderThread::LogRequest()const
{
	ofstream LogFile("sttest.log", ios_base::binary);
	AP<char>  AllRawData = 	m_SendBuffers->SerializeSendData();
	LogFile.write(AllRawData.get(), m_SendBuffers->GetSendDataLength());
	LogFile<<flush;
}


//
// Send request to the server
//
void CSenderThread::SendRequest()
{
	m_SendBuffers = GetSendBuffers();


	LogRequest();

	SetState(EXOVERLAPPED(Complete_SendRequest,Complete_SendFailed));
	m_ReadBuffer.resize(0);

	m_Connection->Send(
		m_SendBuffers->GetSendBuffers(), 
		numeric_cast<DWORD>(m_SendBuffers->GetNumberOfBuffers()), 
		this
		);

}

//
// sending request to the server completed - call to read response header
// 
void  WINAPI CSenderThread::Complete_SendRequest(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	try
	{
		MySelf->ReadPartialHeader();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}

//
// called if connected to destination or proxy failed.
//
void WINAPI CSenderThread::Complete_ConnectFailed(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	printf("Connect failed error %d\n",pOvl->GetStatus());
	MySelf->Failed();
}


//
// called if sending request failed.
//
void WINAPI CSenderThread::Complete_SendFailed(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	printf("Send failed error %d\n", pOvl->GetStatus());
	MySelf->Failed();
}

void CSenderThread::ReadPartialHeader()
{
	SetState(EXOVERLAPPED(Complete_ReadPartialHeader , Complete_ReceiveFailed));
	ASSERT(m_ReadBuffer.capacity() >= m_ReadBuffer.size());
	if(m_ReadBuffer.capacity() == m_ReadBuffer.size())
	{
		m_ReadBuffer.reserve(m_ReadBuffer.capacity() * 2);		
	}
   
	m_Connection->ReceivePartialBuffer(
					m_ReadBuffer.begin() + m_ReadBuffer.size(),
					numeric_cast<DWORD>(m_ReadBuffer.capacity() - m_ReadBuffer.size()),
					this
					);
}


//
// called when partial response header was read - call to continure reading the
// server response header
//
void WINAPI CSenderThread::Complete_ReadPartialHeader(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	try
	{
		MySelf->ReadPartialHeaderContinute();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}


//
// called if receiving the request failed.
//
void WINAPI CSenderThread::Complete_ReceiveFailed(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	printf("Receive failed error %d\n",pOvl->GetStatus());
	MySelf->Failed();
}


//
// start reading response data
//
void CSenderThread::ReadPartialContentData()
{
	SetState(EXOVERLAPPED(Complete_ReadPartialContentData, Complete_ReceiveFailed));
	ASSERT(m_ReadBuffer.capacity() > m_ReadBuffer.size());

	m_Connection->ReceivePartialBuffer(
					m_ReadBuffer.begin() + m_ReadBuffer.size(),
					numeric_cast<DWORD>(m_ReadBuffer.capacity() - m_ReadBuffer.size()),
					this
					);
}


void CSenderThread::TestRestart()
{
	if(++m_CurrentRequestCount == m_TotalRequestCount)
	{
		Done();
	}
	else
	{
		SendRequest();
	}
}



//
// Continute to read response data
//
void CSenderThread::ReadPartialContentDataContinute()
{
	size_t read = DataTransferLength(*this);
	if(read == 0)
    {
        printf("Failed to receive response, connection was closed.\n");
        throw exception();
    }

	DumpData(m_ReadBuffer.begin() + m_ReadBuffer.size(), read);

	m_ReadBuffer.resize(m_ReadBuffer.size() + read);


	//
	// if we are done reading the data
	//
	if(m_ReadBuffer.capacity() == m_ReadBuffer.size())
	{
		TestRestart();	
		return;
	}

	//
	// read more
	//
	ReadPartialContentData();
}


//
// this cycle is done - signal test caller
//
void CSenderThread::Done()
{
	SetEvent(m_event);
}



//
// called when partial response data read completed - call to continure reading the
// server response data
//
void WINAPI CSenderThread::Complete_ReadPartialContentData(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	try
	{
		MySelf->ReadPartialContentDataContinute();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}


void CSenderThread::HandleHeader()
{
	//
	// find out if we read all the header
	//
	size_t EndResponseHeader = FindEndOfResponseHeader(m_ReadBuffer.begin(), m_ReadBuffer.size());

	//
	// the header was not read yet - continute reading
	//
	if(EndResponseHeader == 0)
	{
		ReadPartialHeader();
		return;
	}

	if(IsContinuteResponse(m_ReadBuffer.begin(), EndResponseHeader))
	{
		size_t shiftSize = m_ReadBuffer.size() -  EndResponseHeader;
		memmove(
			m_ReadBuffer.begin(), 
			m_ReadBuffer.begin() + EndResponseHeader, 
			shiftSize
			);
		
		m_ReadBuffer.resize(shiftSize);
		HandleHeader();
		return;
	}



	//
	// start read content (if any)
	//
	size_t DataLen = GetContentLength(
		m_ReadBuffer.begin(), 
		EndResponseHeader
		);

	
	if(DataLen == 0)
	{
		TestRestart();
		return;
	}

	//
	// Get ready to read the buffer
	//
	m_ReadBuffer.reserve(DataLen);
	m_ReadBuffer.resize(0);

	ReadPartialContentData();
}



//
// Continute to readresponse header
//
void CSenderThread::ReadPartialHeaderContinute()
{
	size_t read = DataTransferLength(*this);
	if(read == 0)
    {
        printf("Failed to receive response, connection was closed.\n");
        throw exception();
    }
	DumpData(m_ReadBuffer.begin() + m_ReadBuffer.size(), read);
	m_ReadBuffer.resize(m_ReadBuffer.size() + read);

	ASSERT(m_ReadBuffer.capacity() >= m_ReadBuffer.size());
	HandleHeader();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\envcreate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcreate.h

Abstract:
    Implements creating test envelop

Author:
    Gil Shafriri (gilsh) 07-Jan-2001

--*/

#include <libpch.h>
#include "envcreate.h"

#include "envcreate.tmh"

using namespace std;

static string ReadEnvelop(const string& FileName)
{
	ifstream File(FileName.c_str() ,ios_base::binary );
	if(!File.is_open())
	{
		throw exception("could not open the input file");
	}
	string Envelop;
	char c;
	while( File.get(c))
	{
		Envelop.append(1,c);		
	}
	return Envelop;
}


static string GetNewAddresElement(const string& Host,const string& Resource)
{
	return string("<to>") +
		   "http://" +
		   Host +
		   Resource +
		   "</to>";
}

static void AdjustEnvelop(const string& Host, const string& Resource, string& Envelop)
{
	const char xToOpen[] = "<to";

	string::size_type  DestinastionTagOpen =  Envelop.find(xToOpen);
	if(DestinastionTagOpen == string::npos)
	{
		throw exception("could not find destination address in the envelop");
	}
	

	const char xToClose[] = "</to>";
	string::size_type  DestinastionTagClose =  Envelop.find(xToClose);
	if(DestinastionTagClose == string::npos)
	{
		throw exception("could not find destination address in the envelop");
	}
	
	const string Address = GetNewAddresElement(Host, Resource);

	string::iterator StartReplace = Envelop.begin() + DestinastionTagOpen;
	string::iterator EndReplace = Envelop.begin() + DestinastionTagClose + sizeof(xToClose) -1;
	Envelop.replace(
				StartReplace,
				EndReplace,
				Address.begin(),  
				Address.end()
				);

}


string CreateEnvelop(const string& FileName,const string& Host, const string& Resource)
/*++

Routine Description:
  Create srmp envelop out of template envelop.

    
Arguments:
  FileName - Envelope template file name
  Host  - Destination host machine
  Resource - http resource on the destination machine (e.g : "/msmq\myqueue")
     
Returned Value:
  Deliver srmp envelop
      
--*/
{
	const char x_DeafaultEnvelop[] = "<se:Envelope xmlns:se=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns=\"http://schemas.xmlsoap.org/srmp/\"><se:Header><path xmlns=\"http://schemas.xmlsoap.org/rp/\" se:mustUnderstand=\"1\"><action>MSMQ:mqsender label</action><to>http://gilsh019/msmq/private$/s</to><id>uuid:211969@b2762491-b9bd-46af-b007-663fe062c901</id></path><properties se:mustUnderstand=\"1\"><expiresAt>20380119T031407</expiresAt><sentAt>20010620T003131</sentAt></properties><Msmq xmlns=\"msmq.namespace.xml\"><Class>0</Class><Priority>3</Priority><Correlation>AAAAAAAAAAAAAAAAAAAAAAAAAAA=</Correlation><App>0</App><BodyType>8</BodyType><HashAlgorithm>32772</HashAlgorithm><SourceQmGuid>b2762491-b9bd-46af-b007-663fe062c901</SourceQmGuid><TTrq>20010918T003131</TTrq></Msmq></se:Header><se:Body></se:Body></se:Envelope>";


	string Envelop = FileName == "" ? x_DeafaultEnvelop : ReadEnvelop(FileName.c_str());
	AdjustEnvelop(Host, Resource, Envelop);
	return Envelop;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\sendbuffers.cpp ===
#include <libpch.h>
#include <bufutl.h>
#include <fntoken.h>
#include "sendbuffers.h"

#include "sendbuffers.tmh"

using namespace std;

#define BOUNDARY_LEADING_HYPHEN "--"
#define BOUNDARY_VALUE "MSMQ - SOAP boundary, %d "
#define GUID_STR_FORMAT "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
const char xEnvelopeContentType[] = "text/xml";
const char xApplicationContentType[] = "application/octet-stream";
const char xMultipartContentType[] = "multipart/related";
const char xHttpHeaderTerminater[] = "\r\n\r\n";
const char xMimeBodyId[] = "body@";

static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};
const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}



void CSendBuffers::CreateMultipartHeaders(
					  const string& Host,
					  const string& Resource
						)
{
	DWORD boundaryId = rand();
	ASSERT(m_buffers.size() == 0);

    DWORD totalSize = 0;
    DWORD envLen = numeric_cast<DWORD>(m_envelope.size());


	//
	// http header - is the first buffer to send. set with null values - we don't know yet it's size
	//
	WSABUF buffer;
	buffer.buf = NULL;
	buffer.len =  0;
	m_buffers.push_back(buffer);

      

	//
	// envelop header
	//
	buffer.buf = NULL;
	buffer.len =  GenerateEnvelopeAttachmentHeader(envLen, boundaryId);
	totalSize += buffer.len;
	m_buffers.push_back(buffer);

   
	//
	// Envelop body
	//
    buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = envLen;
    totalSize += buffer.len;
	m_buffers.push_back(buffer);


	//
	// Attachment(message body) headers
	//
    buffer.buf = NULL;
    buffer.len = numeric_cast<DWORD>(GenerateMultipartAttachmentHeader(
							    numeric_cast<DWORD>(m_MessageBody.size()),
                                xstr_t(xMimeBodyId, STRLEN(xMimeBodyId)),
                                boundaryId
                                ));

    totalSize +=  buffer.len;
	m_buffers.push_back(buffer);
  

	//
	// Attachement(messages body)  body
	//
    buffer.buf = const_cast<char*>(m_MessageBody.c_str());
    buffer.len = numeric_cast<DWORD>(m_MessageBody.size());
    totalSize +=  buffer.len;
	m_buffers.push_back(buffer);



    //
    // Add boundry seperator in the end of the request
    //
    size_t n = UtlSprintfAppend(
							&m_HttpRequestData,
							BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n", 
							boundaryId
							);


    buffer.buf = NULL;
    buffer.len = numeric_cast<DWORD>(n);
    totalSize += buffer.len;
    m_buffers.push_back(buffer);



    //
	// Set http header
	//
    m_buffers[0].len = numeric_cast<DWORD>(
						UtlSprintfAppend(
						&m_HttpRequestData,
                        "POST http://%s%s HTTP/1.1\r\n"
                        "Host: %s\r\n"
                        "Content-Type: %s; boundary=\"" BOUNDARY_VALUE "\"\r\n"
                        "Content-Length: %d\r\n"
                        "\r\n",
						Host.c_str(),
                        Resource.c_str(),
                        Host.c_str(),
                        xMultipartContentType,
                        boundaryId,
                        totalSize
                        ));


   	//
	//Now we need to fix set the send buffers to the formatted data.
	//Only at the end of the formatting we can do so - because the formatted buffers
	//can be realocated so pointer  are invalid untill the formating ends. 
	//
	SetBufferPointers();
}


DWORD
CSendBuffers::GenerateMultipartAttachmentHeader(
	DWORD dataSize,
    const xstr_t& contentId,
    DWORD boundaryId
    )
{
    const GUID* pGuid = &McGetMachineID();
    size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s\r\n"
                "Content-Length: %d\r\n"
                "Content-Id: %.*s" GUID_STR_FORMAT "\r\n"
                "\r\n",
                boundaryId,
                xApplicationContentType,
                dataSize,
                contentId.Length(), contentId.Buffer(),
                GUID_ELEMENTS(pGuid)
                );

    return numeric_cast<DWORD>(n);
}



void CSendBuffers::SetBufferPointers()
{
	ASSERT(m_buffers.size() != 0);
	size_t pos = 0;
	for(DWORD i = 1; i<m_buffers.size(); ++i)
	{
		ASSERT(pos <= m_HttpRequestData.size());
		if(m_buffers[i].buf  == NULL)
		{
			m_buffers[i].buf =	const_cast<char*>(m_HttpRequestData.begin() + pos);
			pos += m_buffers[i].len;
		}
	}
	ASSERT(m_buffers[0].buf == NULL);
	m_buffers[0].buf = const_cast<char*>(m_HttpRequestData.begin() + pos);
	pos += 	m_buffers[0].len;
	ASSERT(pos == m_HttpRequestData.size());
}	



DWORD
CSendBuffers::GenerateEnvelopeAttachmentHeader(
    DWORD dataSize,
    DWORD boundaryId
    )
{
	size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s; charset=UTF-8\r\n"
                "Content-Length: %d\r\n"
                "\r\n",
                boundaryId,
                xEnvelopeContentType,
                dataSize
                );

    return numeric_cast<DWORD>(n);
}





CSendBuffers::CSendBuffers(
				const std::string& envelope, 
				const std::string& Host, 
				const std::string& Resource,
				const string& MessageBody
				):
				m_envelope(envelope),
				m_MessageBody(MessageBody),
				m_HttpRequestData(512)
{
	CreateMultipartHeaders(Host, Resource);			
}



size_t CSendBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


const WSABUF* CSendBuffers::GetSendBuffers() const
{
	return m_buffers.begin();		
}


size_t CSendBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;	
}


char*  CSendBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<char>  SendData = new char[SendDataLength];
	char* ptr = SendData.get(); 
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);
	return 	SendData.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\sttest.cpp ===
#include <libpch.h>
#include <no.h>
#include <tr.h>
#include <ex.h>
#include <st.h>
#include <cm.h>
#include "envcreate.h"
#include "clparser.h"
#include "sendbuffers.h"
#include "senderthread.h"

#include "StTest.tmh"

using namespace std;
const TraceIdEntry StTest = L"Socket Transport Test";


//
// test initialization
//
static void Init()
{
	TrInitialize();
    TrRegisterComponent(&StTest, 1);
	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft");
	NoInitialize();
	ExInitialize(10);
    StInitialize();
}



static void Usage()
{
	printf("Sttest [/f:envelop file] [/l] [/h:destination host] [/r:resource] [/s] [/rc:request counts] [/p:proxy name] [/pp:proxy port] [/bl:body length]\n");
	printf("Options: \n");
	printf("/f:Envelop file  - Template file for srmp envelop  - Default built in envelop \n");
	printf("/h:Target Host - Destination machine to send requests to - required \n");
	printf("/r:Resource - Resource name on the target destination machine - required \n");
	printf("/s:Use secure channel (https) - Default http \n");
	printf("/rc:Number of requests to send on each connection - Default 1 \n");
	printf("/p:Proxy name - use proxy to connect to destination host - Default, no proxy \n");
	printf("/pp:Proxy Port - port number to connect to the proxy - Default, 80 \n");
	printf("/bl:Body length in bytes - Default 1000 \n");
	printf("/l:Run in loop - default, run once \n");
	printf("Example: sttest /f:http.txt /h:gilsh015  /r:/msmq\\myqueue\n");
}



static void DoTest(const CClParser<WCHAR>& ClParser)
{
	DWORD Loops;
	if(ClParser.IsExists(L"l"))
	{
		Loops = 10000000;
	}
	else
	{
		Loops = 1;
	}
	for(DWORD i=0; i<Loops; ++i)
	{
		//
		// Run sender thread
		//
		CSenderThread SenderThread(ClParser);
		SenderThread.Run();
		SenderThread.WaitForEnd();
	}
}



extern "C" int __cdecl wmain(int argc ,WCHAR** argv)
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

 	CClParser<WCHAR> ClParser(argc, argv);
	if(!ClParser.IsExists(L"r") || !ClParser.IsExists(L"h"))
	{
		Usage();
		return -1;
	}
	try
	{
		Init();
		DoTest(ClParser);
	}
	catch(const exception& )
	{
		return -1;
	}

    WPP_CLEANUP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\st\test\senderthread.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SenderThread.h

Abstract:
    Header for class CSenderThread that sends http\https request to a server

Author:
    Gil Shafriri (gilsh) 07-Jan-2001
--*/


#ifndef _MSMQ_SenderThread_H_
#define _MSMQ_SenderThread_H_

#include <ex.h>
#include <buffer.h>
#include "clparser.h"

class ISocketTransport;
class CSendBuffers;

class CSenderThread : public EXOVERLAPPED
{
public:
	CSenderThread(const CClParser<WCHAR>& ClParser);
	~CSenderThread();

public:
	void Run();
	void WaitForEnd();


private:
	std::wstring GetNextHop() const;
	size_t GetTotalRequestCount() const;
	USHORT GetNextHopPort()const;
	USHORT GetProtocolPort() const;
	R<CSendBuffers> GetSendBuffers() const;
	void Failed();
	ISocketTransport*  CreateTransport()const;
	void SetState(const EXOVERLAPPED& ovl);
	USHORT GetProxyPort()const;
	void SendRequest();
	void ReadPartialHeader();
	void ReadPartialHeaderContinute();
	void ReadPartialContentDataContinute();
	void ReadPartialContentData();
	void Done();
	void TestRestart();
	void HandleHeader();
	std::string GenerateBody()const;
	std::string GetResource()  const;
 	void LogRequest()const;

private:
	static void WINAPI Complete_Connect(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ConnectFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReceiveFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadPartialHeader(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendRequest(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadPartialContentData(EXOVERLAPPED* pOvl);

private:
	CClParser<WCHAR> m_ClParser;
	CHandle m_event;
	P<ISocketTransport> m_pTransport; 
	R<IConnection> m_Connection;
	R<CSendBuffers> m_SendBuffers;
	CResizeBuffer<char> m_ReadBuffer;
	size_t m_TotalRequestCount;
	size_t m_CurrentRequestCount;


private:
	static const USHORT x_DefaultHttpsPort = 443;
	static const USHORT x_DefaultHttpPort = 80;
	static const int xDefaultProxyPort = 80;
	static const int xDefaultRequestCount = 1;
	static const int xDeafultBodyLen = 1000;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\lib\sc_nt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sc_nt.cpp

Abstract:
    Service control API's

Author:
    Erez Haba (erezh) 03-Aug-99

Environment:
    Windows NT

--*/

#include <libpch.h>
#include <mqexception.h>
#include "Svc.h"
#include "Svcp.h"

#include "sc_nt.tmh"

static BOOL g_fUseDummyServiceCtrl = FALSE;


static void UseDummyServiceCtrl()
{
	g_fUseDummyServiceCtrl = TRUE;
}


static BOOL UsingDummyServiceCtrl()
{
	return g_fUseDummyServiceCtrl;
}


VOID
SvcpStartServiceCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	)
/*++

Routine Description:
    Forwarding the call to SCM StartServiceCtrlDispatcher. If the function
	fails a bad_alloc exception is raise.

	If failed to connect this function forward the call to the dummy SCM.
    This is to enable running the service as an executable.

Arguments:
    pServiceStartTable - The service Start table, that holds the service name
		and the Service main function.

Returned Value:
    None.

--*/
{
	if(::StartServiceCtrlDispatcher(pServiceStartTable))
        return;

    DWORD gle = GetLastError();
	if(gle != ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)
	{
	    TrERROR(Svc, "Failed to start control dispatcher. Error=%d", gle);
	    throw bad_win32_error(gle);
    }

	UseDummyServiceCtrl();
	SvcpStartDummyCtrlDispatcher(pServiceStartTable);
}


VOID
SvcpRegisterServiceCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	)
/*++

Routine Description:
    Forwarding the call to SCM RegisterServiceCtrlHandler.

	In debug builds this function forward the call to the dummy SCM, in case
	the connection to the NT SCM fails. This is to enable running the service
	as an executable.

Arguments:
    pHandler - The service handler function

Returned Value:
    None.

--*/
{
	if(UsingDummyServiceCtrl())
	{
		SvcpSetStatusHandle(SvcpRegisterDummyCtrlHandler(pHandler));
		return;
	}

	SERVICE_STATUS_HANDLE hStatus = ::RegisterServiceCtrlHandler(L"", pHandler);
	if(hStatus == 0)
	{
        DWORD gle = GetLastError();
		TrERROR(Svc, "Failed to register service control handler. Error=%d", gle);
		throw bad_win32_error(gle);
	}

	SvcpSetStatusHandle(hStatus);
}


VOID
SvcpSetServiceStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	)
/*++

Routine Description:
    Forwarding the call to SCM SetServiceStatus.

	In debug builds this function forward the call to the dummy SCM, in case
	the connection to the NT SCM fails. This is to enable running the service
	as an executable.

Arguments:
    hStatus - The status handle
	pServiceStatus - The service reported status

Returned Value:
    None.

--*/
{
	if(UsingDummyServiceCtrl())
	{
		SvcpSetDummyStatus(hStatus, pServiceStatus);
		return;
	}

	if(::SetServiceStatus(hStatus, pServiceStatus))
        return;

    DWORD gle = GetLastError();
    TrERROR(Svc, "Failed to set service status. Error=%d", gle);
	throw bad_win32_error(gle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\lib\status.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Status.cpp

Abstract:
    Service status functions

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "status.tmh"

//
// The service status handle
//
static SERVICE_STATUS_HANDLE s_StatusHandle = 0;

//
// The service status
//
static SERVICE_STATUS s_Status = {

	SERVICE_WIN32_OWN_PROCESS,
	SERVICE_START_PENDING,
	0,
	0,
	0,
	0,
	0,
};


VOID
SvcpSetStatusHandle(
	SERVICE_STATUS_HANDLE hStatus
	)
/*++

Routine Description:
    Captures the service Status Handle to be used latter

Arguments:
    hStatus - The service status handle

Returned Value:
    None.

--*/
{
	ASSERT(s_StatusHandle == 0);
	ASSERT(hStatus != 0);

	s_StatusHandle = hStatus;
}


inline void SetStatus(void)
{
	SvcpSetServiceStatus(s_StatusHandle, &s_Status);
}


VOID
SvcEnableControls(
	DWORD Controls
	)
/*++

Routine Description:
    Enable controls accepted by this service

Arguments:
    Controls - Controls to enable

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
	s_Status.dwControlsAccepted |= Controls;
	s_Status.dwCheckPoint = 0;
	s_Status.dwWaitHint = 0;
	SetStatus();
}


VOID
SvcDisableControls(
	DWORD Controls
	)
/*++

Routine Description:
    Disable controls to prevent SCM from dispatching them to this service

Arguments:
    Controls - Controls to disable

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
	s_Status.dwControlsAccepted &= ~Controls;
	s_Status.dwCheckPoint = 0;
	s_Status.dwWaitHint = 0;
	SetStatus();
}


DWORD
SvcQueryControls(
	VOID
	)
/*++

Routine Description:
    Query the current controls enabled

Arguments:
    None.

Returned Value:
    The current set of enabled controls

--*/
{
	SvcpAssertValid();
	return s_Status.dwControlsAccepted;
}


VOID
SvcReportState(
	DWORD State
	)
/*++

Routine Description:
    Report current service state to SCM

Arguments:
    State - Current service state

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
	s_Status.dwCurrentState = State;
	s_Status.dwCheckPoint = 0;
	s_Status.dwWaitHint = 0;
	SetStatus();
}


DWORD
SvcQueryState(
	VOID
	)
/*++

Routine Description:
    Query last reported service state

Arguments:
    None.

Returned Value:
    Last reported service state

--*/
{
	SvcpAssertValid();
	return s_Status.dwCurrentState;
}


VOID
SvcReportProgress(
	DWORD MilliSecondsToNextTick
	)
/*++

Routine Description:
    Report a 'Pending' progress to SCM. The ProgressTick is incremented with
	every report to indicate progress. The MilliSecondsToNextTick, give the max
	time to the next progress report.

Arguments:
	ProgressTick - Tick on every report
	MilliSecondsToNextTick - Max time to next report

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
    ASSERT(("Must be in pending state to report progress",
        (s_Status.dwCurrentState == SERVICE_START_PENDING) ||
        (s_Status.dwCurrentState == SERVICE_STOP_PENDING)
        ));

	++s_Status.dwCheckPoint;
	s_Status.dwWaitHint = MilliSecondsToNextTick;
	SetStatus();
}

VOID
SvcpInterrogate(
	VOID
	)
/*++

Routine Description:
    Report back when SCM interrogate the service for status.

Arguments:
	None.

Returned Value:
    None.

--*/
{
	SetStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\lib\sc_dummy.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sc_dummy.cpp

Abstract:
    Dummy Service Controller

Author:
    Erez Haba (erezh) 03-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <conio.h>
#include <mqexception.h>
#include "Svc.h"
#include "Svcp.h"

#include "sc_dummy.tmh"

//
// Dummy Status handle value to pass and accept fromt he service
//
const SERVICE_STATUS_HANDLE xDummyStatusHandle = reinterpret_cast<SERVICE_STATUS_HANDLE>(0x12345678);

//
// Dummy Service Name to be passed to ServiceMain
//
static LPWSTR s_ServiceName = L"Dummy";

//
// Service Controls handler (set by sevice call to RegisterServiceCtrlHandler)
//
static LPHANDLER_FUNCTION s_pServiceHandler = 0;

//
// Last service reported status as captured by our Dummy SCM
//
static SERVICE_STATUS s_LastStatus = { 0 };



static void Usage()
{
	printf(	"\n"
			"+-- Service Controls --+\n"
			"|                      |\n"
			"| S: Stop              |\n"
			"| P: Pause             |\n"
			"| D: shutDown          |\n"
			"| C: Continue          |\n"
			"| I: Interrogate       |\n"
			"|                      |\n"
			"+-- Manager Controls --+\n"
			"|                      |\n"
			"| Q: Quit              |\n"
			"| L: Print Last status |\n"
			"|                      |\n"
			"+----------------------+");
}


//
// Convert a State value to state text
//
static const char* StateText(DWORD State)
{
	char const* const xStateText[] = {
		"*invalid*",
		"Stopped",
		"Starting",
		"Stopping",
		"Running",
		"Continuing",
		"Pausing",
		"Paused",
	};

	if(State > SERVICE_PAUSED)
	{
		State = 0;
	}

	return xStateText[State];
}


//
// Convert Controls value to controls text
//
static const char* ControlsText(DWORD Controls)
{
	char const* const xControlsText[] = {
		"none",
		"Stop",
		"Pause,Continue",
		"Stop,Pause,Continue",
		"Shutdown",
		"Shutdown,Stop",
		"Shutdown,Pause,Continue",
		"Shutdown,Stop,Pause,Continue",
		"*unknown*",
		"*unknown*,Stop",
		"*unknown*,Pause,Continue",
		"*unknown*,Stop,Pause,Continue",
		"*unknown*,Shutdown",
		"*unknown*,Shutdown,Stop",
		"*unknown*,Shutdown,Pause,Continue",
		"*unknown*,Shutdown,Stop,Pause,Continue",
	};

	const DWORD xControlAllowed =
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_PAUSE_CONTINUE |
		SERVICE_ACCEPT_SHUTDOWN;

	if((Controls & ~xControlAllowed) != 0)
	{
		Controls = 0x8 | (Controls & xControlAllowed);
	}

	return xControlsText[Controls];
}


//
// Print the service state and accepted controls
//
static void PrintStatus(LPSERVICE_STATUS p)
{
	printf(
		"\nStatus: state=(%d) %s, accepts=(0x%x) %s",
		p->dwCurrentState,
		StateText(p->dwCurrentState),
		p->dwControlsAccepted,
		ControlsText(p->dwControlsAccepted)
		);
}


//
// Print the 'Pending' progress information
//
static void PrintProgress(LPSERVICE_STATUS p)
{
	printf(
		", tick=%d, wait=%dms",
		p->dwCheckPoint,
		p->dwWaitHint
		);
}


//
// Pring last service reported status
//
static void PrintLastStatus()
{
	PrintStatus(&s_LastStatus);
	PrintProgress(&s_LastStatus);
}


//
// Print an input indicated, showing the this Dummy SCM accepts input
//
static void PrintInputSign()
{
	printf(" >");
}


static void ContinueService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) == 0)
	{
		printf("\nService does not accepts Continue control");
		return;
	}

	if(s_LastStatus.dwCurrentState != SERVICE_PAUSED)
	{
		printf("\nService is not paused, can not continue");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_CONTINUE);
}


static void StopService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_STOP) == 0)
	{
		printf("\nService does not accepts Stop control");
		return;
	}

	if((s_LastStatus.dwCurrentState != SERVICE_PAUSED) &
	   (s_LastStatus.dwCurrentState != SERVICE_RUNNING))
	{
		printf("\nService is not running or paused, can not stop");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_STOP);
}


static void ShutdownService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) == 0)
	{
		printf("\nService does not accepts Shutdown control");
		return;
	}

	if(s_LastStatus.dwCurrentState == SERVICE_STOPPED)
	{
		printf("\nService already stopped, meaningless shutdown");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_SHUTDOWN);
}


static void PauseService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) == 0)
	{
		printf("\nService does not accepts Pause control");
		return;
	}

	if(s_LastStatus.dwCurrentState != SERVICE_RUNNING)
	{
		printf("\nService is not running, can not pause");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_PAUSE);
}


static void InterrogateService()
{
	s_pServiceHandler(SERVICE_CONTROL_INTERROGATE);
}


static
DWORD
WINAPI
ServiceControlThread(
	LPVOID /*pParameter*/
	)
/*++

Routine Description:
    This thread controls the service. It accepts console commands and dispatchs
	the control to the service handler.

Arguments:
    None.

Returned Value:
    None.

--*/
{
	Usage();

	for(;;)
	{
		PrintInputSign();

		switch(_getche())
		{
			case 'c':
			case 'C':
				ContinueService();
				break;

			case 's':
			case 'S':
				StopService();
				break;

			case 'd':
			case 'D':
				ShutdownService();
				break;

			case 'p':
			case 'P':
				PauseService();
				break;

			case 'i':
			case 'I':
				InterrogateService();
				break;

			case 'l':
			case 'L':
				PrintLastStatus();
				break;

			case 'q':
			case 'Q':
				ExitProcess(0);

			default:
				Usage();
		}
	}
	return 0;
}


VOID
SvcpStartDummyCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	)
/*++

Routine Description:
    Dummy service control dispatcher, emulates SCM StartServiceCtrlDispatcher.
	This function spawns a thread to run the service controller, and then goes
	and call ServiceMain

Arguments:
    pServiceStartTable - A Size 2 Table, that contains the service name
		and the Service main function.

Returned Value:
    None.

--*/
{
	ASSERT(pServiceStartTable[0].lpServiceName !=0);
	ASSERT(pServiceStartTable[0].lpServiceProc !=0);
	ASSERT(pServiceStartTable[1].lpServiceName ==0);
	ASSERT(pServiceStartTable[1].lpServiceProc ==0);

	DWORD ThreadID;
	HANDLE hThread = ::CreateThread(0, 0, ServiceControlThread, 0, 0, &ThreadID);

	if(hThread == NULL)
	{
        DWORD gle = GetLastError();
		TrERROR(Svc, "Failed to create dummy control dispatcher thread. Error=%d", gle);
		throw bad_win32_error(gle);
	}

	CloseHandle(hThread);

	//
	// Call service main funciton
	//
	pServiceStartTable[0].lpServiceProc(1, &s_ServiceName);
}


SERVICE_STATUS_HANDLE
SvcpRegisterDummyCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	)
/*++

Routine Description:
    Dummy service control registration, emulates SCM RegisterServiceCtrlHandler.
	The service handler function is stored for further use by the dispatcher.

Arguments:
    pHandler - The service handler function

Returned Value:
    A Dummy service status handle (fixed value)

--*/
{
	ASSERT(s_pServiceHandler == 0);
	ASSERT(pHandler != 0);

	s_pServiceHandler = pHandler;

	return xDummyStatusHandle;
}


VOID
SvcpSetDummyStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	)
/*++

Routine Description:
    Dummy service status report, emulates SCM SetServiceStatus.
	The service status is captured for further use by the dispatcher.
	The reported status or progress is displayed on the console.

Arguments:
    hStatus - A Dummy service status handle (fixed value)
	pServiceStatus - The service reported status

Returned Value:
    None.

--*/
{
	ASSERT(hStatus == xDummyStatusHandle);
	DBG_USED(hStatus);

	s_LastStatus = *pServiceStatus;
	if(s_LastStatus.dwCheckPoint == 0)
	{
		PrintStatus(&s_LastStatus);
		PrintInputSign();
	}
	else
	{
		printf(".");
	}
}


VOID
SvcpSetDummyServiceName(
    LPCWSTR DummyServiceName
    )
/*++

Routine Description:
    Sets Dummy service name. The dummy SCM does not have an external way
	to retrive the service name. Thus, during initialization the applicaion
    passes the preferd name.

Arguments:
    DummySericeName - The default name for the service.

Returned Value:
    None.

--*/
{
    //
    // We have to cast away constness as the service interface is detemined by
    // SCM. Neverhteless this parameter is only passed to AppRun which its
    // interface pases a const string
    //
    s_ServiceName = const_cast<LPWSTR>(DummyServiceName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\lib\svcinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcInit.cpp

Abstract:
    Service initialization

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "svcinit.tmh"

const SERVICE_TABLE_ENTRY xDispatchTable[2] =
{
	{L"", SvcpServiceMain},
	{0, 0}
};



VOID
SvcInitialize(
    LPCWSTR DummyServiceName
    )
/*++

Routine Description:
    Initializes Service library, This function does not actually returns until the service terminates.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Service library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!SvcpIsInitialized());
    SvcpRegisterComponent();

    SvcpSetDummyServiceName(DummyServiceName);

	//
	// Since the Control Dispatcher does not return until the service
	// actually terminates. Svc library state is set to initialized here
	// to prevent any other calls before termination.
	//
    SvcpSetInitialized();

	//
	// Start the control dispatcher. This function does not return until
	// the service terminates.
	//
	SvcpStartServiceCtrlDispatcher(xDispatchTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\lib\svcdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcDebug.cpp

Abstract:
    Service debugging

Author:
    Erez Haba (erezh) 18-Jun-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "svcdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Service state
//
void SvcpAssertValid(void)
{
    //
    // SvcInitalize() has *not* been called. You should initialize the
    // Service library before using any of its funcionality.
    //
    ASSERT(SvcpIsInitialized());

    //
    // TODO:Add more Service validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void SvcpSetInitialized(void)
{
    LONG fSvcAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Service library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fSvcAlreadyInitialized);
}


BOOL SvcpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Svc,

    //
    // TODO: Add Service sub-component trace ID's to be used with TrXXXX.
    // For example, SvcInit, as used in:
    // TrERROR(SvcInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "SvcDumpState(queue path name)",
        "Dump Service State to debugger",
        DumpState
    ),

    //
    // TODO: Add Service debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void SvcpRegisterComponent(void)
{
    //
    // ISSUE-2001/03/25-erezh   Temporarily removed tracing registration
    //
    // TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\lib\svcmain.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcMain.cpp

Abstract:
    Service Main function

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "svcmain.tmh"

static
VOID
WINAPI
SvcpHandler(
	DWORD Control
	)
/*++

Routine Description:
    The Service handle routine. Handles any commands comming in from SCM by
	dispatching the appropriate AppXXX function. Only Interrogate is
	implemented by this service library. all AppXXX functions should be
	overriden by the service implementation.

Arguments:
    Control - The service control

Returned Value:
    None.

--*/
{
	SvcpAssertValid();

	switch(Control)
	{
		case SERVICE_CONTROL_STOP:
			AppStop();
			break;

		case SERVICE_CONTROL_PAUSE:
			AppPause();
			break;

		case SERVICE_CONTROL_CONTINUE:
			AppContinue();
			break;

		case SERVICE_CONTROL_INTERROGATE:
			SvcpInterrogate();
			break;

		case SERVICE_CONTROL_SHUTDOWN:
			AppShutdown();
			break;

		default:
			ASSERT(("Unexpected Service Control 0x%x", 0));
	}
}


VOID
WINAPI
SvcpServiceMain(
	DWORD /*argc*/,
	LPTSTR* argv
	)
/*++

Routine Description:
    The Service main routine. As soon as the service start running this function
	is called by the SCM. This funciton register the Controls handler and calls
	the AppRun function, which returns only after the service stops.

Arguments:
	argc - number of parameters
	argv - parameter list. (the first one is the service name)

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
	SvcpRegisterServiceCtrlHandler(SvcpHandler);
	AppRun(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\lib\svcp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Svcp.h

Abstract:
    Service private functions.

Author:
    Erez Haba (erezh) 01-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Svcp_H_
#define _MSMQ_Svcp_H_

const TraceIdEntry Svc = L"Service";

#ifdef _DEBUG

void SvcpAssertValid(void);
void SvcpSetInitialized(void);
BOOL SvcpIsInitialized(void);
void SvcpRegisterComponent(void);

#else // _DEBUG

#define SvcpAssertValid() ((void)0)
#define SvcpSetInitialized() ((void)0)
#define SvcpIsInitialized() TRUE
#define SvcpRegisterComponent() ((void)0)

#endif // _DEBUG


//
// Service Controller Manager interfaces
//
VOID
SvcpStartServiceCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	);

VOID
SvcpRegisterServiceCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	);

VOID
SvcpSetStatusHandle(
	SERVICE_STATUS_HANDLE hStatus
	);


//
// Dummy Service Controller Manager
//
VOID
SvcpSetDummyServiceName(
    LPCWSTR DummyServiceName
    );

VOID
SvcpStartDummyCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	);

SERVICE_STATUS_HANDLE
SvcpRegisterDummyCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	);

VOID
SvcpSetDummyStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	);


//
// Status interfaces
//
VOID
SvcpSetServiceStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	);

VOID
SvcpInterrogate(
	VOID
	);


//
// Service Main fucntion
//
VOID
WINAPI
SvcpServiceMain(
	DWORD dwArgc,
	LPTSTR* lpszArgv
	);

#endif // _MSMQ_Svcp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\test\app.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    App.cpp

Abstract:
    Service Application stub functions

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"

#include "app.tmh"

VOID
AppRun(
	LPCWSTR /*ServiceName*/
	)
/*++

Routine Description:
    Stub implementation for application Run function. It should immidiatly
	report it state and enable the controls it accepts.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_RUNNING);

	SvcEnableControls(
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_PAUSE_CONTINUE |
		SERVICE_ACCEPT_SHUTDOWN
		);
}


VOID
AppStop(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Stop function. It should immidiatly
	report it state back, and take the procedure to stop the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_STOPPED);
}


VOID
AppPause(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Pause function. It should immidiatly
	report it state back, and take the procedure to pause the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_PAUSE_PENDING);

	for(int i = 1; i < 100; i++)
	{
		SvcReportProgress(3000);
		Sleep(2000);
	}

	SvcReportState(SERVICE_PAUSED);
}


VOID
AppContinue(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Continue function. It should immidiatly
	report it state back, and take the procedure to contineu the service from
	a paused state.

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_RUNNING);
}


VOID
AppShutdown(
	VOID
	)
{
	SvcReportState(SERVICE_STOPPED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\svc\test\svctest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcTest.cpp

Abstract:
    Service library test

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Svc.h"

#include "SvcTest.tmh"

const TraceIdEntry SvcTest = L"Service Test";


static void Usage()
{
    printf("Usage: SvcTest\n");
    printf("\n");
    printf("Example, SvcTest\n");
    exit(-1);

} // Usage


extern "C" int __cdecl _tmain(int argc, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Service library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&SvcTest, 1);

    if(argc != 1)
    {
        Usage();
    }

    try
    {
        SvcInitialize(L"SvcTest");
    }
    catch(const exception&)
    {
        //
        // Failed to start the service. If failed to connect, we shouldn't get
        // here as the service starts up using the dummy SCM. Therfore if we
        // get an exception the test completes with failure status
        //
        return -1;
    }

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmconfig.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tmap.cpp

Abstract:
    Transport Manager - Configuration routine

Author:
    Uri Habusha (urih) 29-Feb-2000

Environment:
    Platform-independent

--*/
#include <libpch.h>
#include <timetypes.h>
#include <Cm.h>
#include "Tmp.h"
#include "tmconset.h"

#include "tmconfig.tmh"

static CTimeDuration s_remoteResponseTimeout;
static CTimeDuration s_remoteCleanupTimeout;


static DWORD s_SendWindowinBytes;
static DWORD s_SendWindowinPackets; 

void 
TmpGetTransportTimes(
    CTimeDuration& ResponseTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    ResponseTimeout = s_remoteResponseTimeout;
    CleanupTimeout = s_remoteCleanupTimeout;
}

void 
TmpGetTransportWindows(
    DWORD& SendWindowinBytes,
    DWORD& SendWindowinPackets 
    )
{
   SendWindowinBytes = s_SendWindowinBytes;
   SendWindowinPackets = s_SendWindowinPackets; 
}
    
static void InitTransportTimeouts(void)
{
    CmQueryValue(
        RegEntry(NULL, L"HttpResponseTimeout", 2 * 60 * 1000),   // 2 minutes
        &s_remoteResponseTimeout
        );
                      
    
    CmQueryValue(
        RegEntry(NULL, L"HttpCleanupInterval", 2 * 60 * 1000),  // 2 minutes
        &s_remoteCleanupTimeout
        );

    //
    // Cleanup timeout should be greater than the response timeout, otherwise
    // the transport can be removed before receive the response
    //
    s_remoteCleanupTimeout = max(s_remoteCleanupTimeout, s_remoteResponseTimeout);
}

static void InitTransportWindows(void)
{
    CmQueryValue(
        RegEntry(NULL, L"SendWindowinBytes", 200000),
        &s_SendWindowinBytes
        );
    CmQueryValue(
        RegEntry(NULL, L"SendWindowinPackets",64),
        &s_SendWindowinPackets
        );

}







static void InitProxyServer(void)
{
	TmCreateProxySetting();
}


void TmpInitConfiguration(void)
{
    InitTransportTimeouts();
    InitTransportWindows();
    InitProxyServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tm.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tm.cpp

Abstract:
    Transport Manager general functions

Author:
    Uri Habusha (urih) 16-Feb-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <Mc.h>
#include <xstr.h>
#include "Tm.h"
#include "Tmp.h"
#include "tmconset.h"

#include "tm.tmh"

const WCHAR xHttpScheme[] = L"http://";
const WCHAR xHttpsScheme[] = L"https://";

//
// BUGBUG: is \\ legal sepeartor in url?
//						Uri habusha, 16-May-2000
//
const WCHAR xHostNameBreakChars[] = L";:@?/\\";
const USHORT xHttpsDefaultPort = 443;




static const xwcs_t CreateEmptyUri()
{
	static const WCHAR xSlash = L'/';
	return xwcs_t(&xSlash , 1);
}

static
void 
CrackUrl(
    LPCWSTR url,
    xwcs_t& hostName,
    xwcs_t& uri,
    USHORT* port,
	bool* pfSecure
    )
/*++

Routine Description:
    Cracks an URL into its constituent parts. 

Arguments:
    url - pointer to URL to crack. The url is null terminated string

    hostName - refrence to x_str structure, that will contains the begining of the
               host name in the URL and its length

    uri - refrence to x_str structure, that will contains the begining of the
          uri in the URL and its length

    port - pointer to USHORT that will contain the port number
    
Return Value:
    None.

--*/
{
    ASSERT(url != NULL);
	ASSERT(_wcsnicmp(url, xHttpScheme, STRLEN(xHttpScheme)) == 0 ||
		_wcsnicmp(url, xHttpsScheme, STRLEN(xHttpsScheme)) == 0 );

	const WCHAR*  ProtocolScheme;
	if(_wcsnicmp(url, xHttpScheme, STRLEN(xHttpScheme)) == 0 )
	{
		ProtocolScheme = xHttpScheme;		
		*pfSecure = false;
	}
	else
	{
		ProtocolScheme = xHttpsScheme;
		*pfSecure = true;
	}

	//
	// Advance the URL to point on the host name
	//
	LPCWSTR HostNameBegin = url + wcslen(ProtocolScheme);

	//
	// find the end of host name in url. it is terminated by "/", "?", ";",
	// ":" or by the end of URL
	//
	LPCWSTR HostNameEnd = wcspbrk(HostNameBegin, xHostNameBreakChars);

	//
	// calculate the host name length
	//
	DWORD HostNameLength;
	if (HostNameEnd == NULL)
	{
		HostNameLength = wcslen(HostNameBegin);
	}
	else
	{
		HostNameLength = UINT64_TO_UINT(HostNameEnd - HostNameBegin);
	}

	//
	// copy the host name from URL to user buffer and add terminted
	// string in the end
	//
    hostName = xwcs_t(HostNameBegin, HostNameLength);

	//
	// get the port number
	//
	if ((HostNameEnd == NULL) || (*HostNameEnd != L':'))
	{
		if(*pfSecure)
		{
			*port = xHttpsDefaultPort;
		}
		else
		{
			*port = xHttpDefaultPort;
		}
	}
    else
    {
	    *port = static_cast<USHORT>(_wtoi(HostNameEnd + 1));
        HostNameEnd = wcspbrk(HostNameEnd + 1, xHostNameBreakChars);
    }
        
    if (HostNameEnd == NULL)
    {
        uri = CreateEmptyUri();
    }
    else
    {
        uri = xwcs_t(HostNameEnd, wcslen(HostNameEnd));
    }
}



static
void 
GetNextHopInfo(
    LPCWSTR queueUrl, 
    xwcs_t& targetHost,
    xwcs_t& nextHop,
    xwcs_t& nextUri,
    USHORT* pPort,
	USHORT* pNextHopPort,
	bool* pfSecure
    )
{
    CrackUrl(queueUrl, targetHost, nextUri, pPort,pfSecure);

	P<CProxySetting>&  ProxySetting =  TmGetProxySetting();
    if (ProxySetting.get() == 0 || !ProxySetting->IsProxyRequired(targetHost))
    {
        //
        // The message should be delivered directly to the target machine
        //
        nextHop = targetHost;
		*pNextHopPort =  *pPort;
        return;
    }

    //
    // The message should deliver to proxy. Update the nextHop to be the proxy server
    // name, the port is the proxy port and the URI is the destination url
    //
    nextHop = ProxySetting->ProxyServerName();
	*pNextHopPort  =  ProxySetting->ProxyServerPort();

	//
	// if we are working with http(secure) we put full url in the request
	// because the proxy will  not change it (It is encrypted). 
	// It will be accepted on the target as if not proxy exists.
	//
	if(!(*pfSecure))
	{
		nextUri = xwcs_t(queueUrl, wcslen(queueUrl));
	}
}


VOID 
TmCreateTransport(
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	LPCWSTR url
    ) 
/*++

Routine Description:
    Handle new queue notifications. Let the message transport 

Arguments:
    pQueue - The newly created queue 
    Url - The Url the queue is assigned to

Returned Value:
    None.

--*/
{
    TmpAssertValid();

    ASSERT(url != NULL);
    ASSERT(pMessageSource != NULL);

    xwcs_t targetHost;
    xwcs_t nextHop;
    xwcs_t nextUri;
    USHORT port;
	USHORT NextHopPort;
	bool fSecure;

    GetNextHopInfo(url, targetHost, nextHop, nextUri, &port, &NextHopPort, &fSecure);
	TmpCreateNewTransport(
			targetHost, 
			nextHop, 
			nextUri, 
			port, 
			NextHopPort,
			pMessageSource,
			pPerfmon,
			url,
			fSecure
			);
	
}


VOID
TmTransportClosed(
    LPCWSTR url
    )
/*++

Routine Description:
    Notification for closing connection. Removes the transport from the
    internal database and checkes if a new transport should be created (the associated 
    queue is in idle state or not)

Arguments:
    Url - The endpoint URL, must be a uniqe key in the database.

Returned Value:
    None.

--*/
{
    TmpAssertValid();

    TrTRACE(Tm, "AppNotifyTransportClosed. transport to: %ls", url);

    TmpRemoveTransport(url);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmconset.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    tmconset.cpp

Abstract:
    connection setting classes inpmementation (tmconset.h)

Author:
    Gil Shafriri (gilsh) 8-Aug-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <strutl.h>
#include <tr.h>
#include "TmWinHttpProxy.h"
#include "tmconset.h"
#include "Tm.h"
#include "tmp.h"

#include "tmconset.tmh"

static P<CProxySetting> s_ProxySetting;  

static
bool 
IsInternalMachine(const xwcs_t& pMachineName)
/*++

Routine Description:
    Check if a given machine is internal machine in the intranet (proxy not needed) 

Arguments:
	const xwcs_t& pMachineName - machine name.    
    
Return Value:
    true if the machine is internal false if not.
	
Note :
When this function returns false it actually means "I dont know". Only machine name
that is not dns name(has '.') is 100% internal.
--*/
{
	const WCHAR*  start = pMachineName.Buffer();
	const WCHAR*  end = pMachineName.Buffer() + pMachineName.Length();
   	
	//
	// Could not find '.' in the name - so it is internal machine
	//
	return  std::find(start , end, L'.') == end;
}



static
void 
CreateBypassList(
			LPCWSTR pBypassListStr, 
			std::list<std::wstring>* pBypassList
			)
/*++

Routine Description:
    Creates bypass list of names (patterns) that connection to them should not be via proxy.
	It creates it from a given string of names seperated by ';'

Arguments:
	IN - pBypassListStr - list of names(patterns) seperated by ';'   
    
Return Value:
	List of strings parsed from pBypassListStr.  

--*/
{
	if(pBypassListStr == NULL)
		return;

	LPCWSTR end = pBypassListStr + wcslen(pBypassListStr);
	LPCWSTR ptr = pBypassListStr;

	while(ptr !=  end)
	{
		LPCWSTR found = std::find(ptr, end, L';');
		if(found == end)
		{
			pBypassList->push_back(std::wstring(ptr, end));
			return;
		}
		pBypassList->push_back(std::wstring(ptr, found));
		ptr = ++found;
	}
}


static
void
CrackProxyName(
	LPCWSTR proxyServer,
	xwcs_t* pHostName,
	USHORT* pPort
	)
/*++

Routine Description:
   Crack proxy name  of the format machine:port to machine name and port.

Arguments:
    proxyServer - pointer to proxy server string from the format machine:port

    hostName - pointer to x_str structure, that will contains the proxy machine name

    
    port - pointer to USHORT that will contain the port  number.
	       if proxyServer does not contains port number - default port 80 is returned.  
    
Return Value:
    None.

--*/
{
	const WCHAR* start =  proxyServer;
	const WCHAR* end =  proxyServer + wcslen(proxyServer);

	const WCHAR* found = std::find(start , end, L':');
	if(found != end)
	{
		*pHostName = xwcs_t(start, found - start);
		*pPort = numeric_cast<USHORT>(_wtoi(found + 1));
		if(*pPort == 0)
		{
			TrERROR(
				Tm,
				"the proxy port in %ls is invalid, use default port %d ",
				proxyServer,
				xHttpDefaultPort
				);

			*pPort = xHttpDefaultPort;
		}
		return;
	}

	*pHostName  = xwcs_t(start, end - start);
	*pPort = xHttpDefaultPort;
}


CProxySetting::CProxySetting(
						LPCWSTR proxyServer,
						LPCWSTR pBypassListStr
						):
						m_proxyServer(newwcs(proxyServer))
													
{
	CreateBypassList(pBypassListStr, &m_BypassList); 
	CrackProxyName(m_proxyServer, &m_ProxyServerName , &m_ProxyServerPort); 
}



bool CProxySetting::IsProxyRequired(const xwcs_t& pMachineName) const
/*++

Routine Description:
    Check if proxy is needed for connecting the given machine.
   
Arguments:
    pMachineName - machine name


Return Value:
    true if proxy is needed false if not.

Note : 
The function check one by one the bypass list and try to find match.
If match found - proxy is not needed (false is returned).

There is one exception - if in the bypass list we have the string "<local>"
It means that we should not use proxy if the given address is local (not dns).
--*/
{
	BypassList::const_iterator it;
	for(it = m_BypassList.begin(); it!= m_BypassList.end(); ++it)
	{
		//
		// if found the special string <local>  check if the machine is in the intranet
		// if so - we don't need proxy.
		//
		if(_wcsicmp(L"<local>", it->c_str() ) == 0)
		{
			bool fInternal = IsInternalMachine(pMachineName);
			if(fInternal)
				return false;


			continue;
		}

		//
		// Simple regural expression match - if match don't use proxy
		//
		bool fMatch = UtlSecIsMatch(
								pMachineName.Buffer(),
								pMachineName.Buffer() + pMachineName.Length(),
								it->c_str(),
								it->c_str() + it->size(),
								UtlCharNocaseCmp<WCHAR>()
								);

	   if(fMatch)
		   return false;

	}
	return true;
}


void TmCreateProxySetting()
/*++

Routine Description:
    create the web proxy configuration.
   


Return Value:
    None.

Note : The function set s_ProxySetting global variable.

--*/
{
    s_ProxySetting = GetWinhttpProxySetting();  
}


P<CProxySetting>& TmGetProxySetting()
{
	return s_ProxySetting;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmInit.cpp

Abstract:
    HTTP transport manager initialization

Author:
    Uri Habusha (urih) 03-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Tm.h"
#include "Tmp.h"

#include "tminit.tmh"

VOID
TmInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes HTTP transport manager library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the HTTP transport manager library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!TmpIsInitialized());
    TmpRegisterComponent();

    TmpInitConfiguration();

    TmpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmDebug.cpp

Abstract:
    HTTP transport manager debugging

Author:
    Uri Habusha (urih) 03-May-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Tm.h"
#include "Tmp.h"

#include "tmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate HTTP transport manager state
//
void TmpAssertValid(void)
{
    //
    // TmInitalize() has *not* been called. You should initialize the
    // HTTP transport manager library before using any of its funcionality.
    //
    ASSERT(TmpIsInitialized());

    //
    // TODO:Add more HTTP transport manager validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void TmpSetInitialized(void)
{
    LONG fTmAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The HTTP transport manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fTmAlreadyInitialized);
}


BOOL TmpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Tm,

    //
    // TODO: Add HTTP transport manager sub-component trace ID's to be used with TrXXXX.
    // For example, TmInit, as used in:
    // TrERROR(TmInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "TmDumpState(queue path name)",
        "Dump HTTP transport manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add HTTP transport manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void TmpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmconset.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    tmconset.h

Abstract:
    Header file for internet connection setting

Author:
    Gil Shafriri (gilsh) 03-May-00

--*/

#pragma once

#ifndef _MSMQ_CONSET_H_
#define _MSMQ_CONSET_H_

#include <xstr.h>



//
// class resposible for proxy setting
//
class CProxySetting
{
public:
	typedef std::list<std::wstring> BypassList;
	CProxySetting(LPCWSTR proxyServerUrl, LPCWSTR pBypassListStr);


public:
	const xwcs_t ProxyServerName() const
	{
		return m_ProxyServerName;
	}

	USHORT ProxyServerPort() const
	{
		return m_ProxyServerPort;
	}
	bool IsProxyRequired(const xwcs_t& pMachineName) const;

private:
	CProxySetting(const CProxySetting&);
	CProxySetting& operator=(const CProxySetting&);

private:
	AP<WCHAR> m_proxyServer;
	xwcs_t m_ProxyServerName;
	USHORT m_ProxyServerPort;
	std::list<std::wstring> m_BypassList;
};



void TmCreateProxySetting();
P<CProxySetting>& TmGetProxySetting();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmmap.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmMap.cpp

Abstract:
    URL to Transport mapping

Author:
    Uri Habusha (urih) 19-Jan-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Tm.h"
#include "Mt.h"
#include "rwlock.h"
#include "stlcmp.h"
#include "timetypes.h"
#include "Tmp.h"

#include "tmmap.tmh"

using namespace std;

typedef map<WCHAR*, R<CTransport>, CFunc_wcscmp> TMAP;

static TMAP s_transports;
static CReadWriteLock s_rwlock;


inline
TMAP::iterator
TmpFind(
    LPCWSTR url
    )
{
    return s_transports.find(const_cast<WCHAR*>(url));
}


void 
TmpRemoveTransport(
    LPCWSTR url
    )
/*++

Routine Description:
    Remove a transport from the transport database

Arguments:
    url - The endpoint URL, must be a uniqe key in the database.

Returned Value:
    None.

--*/
{
    CSW writeLock(s_rwlock);

    TMAP::iterator it = TmpFind(url);

    //
    // The transport can be removed with the same name more than once
    // see comment below at TmpCreateNewTransport.
    //
    if(it == s_transports.end())
        return;

    TrTRACE(Tm, "RemoveTransport. transport to : 0x%p", &it->second);

    delete [] it->first;
    s_transports.erase(it);
}


R<CTransport>
TmGetTransport(
    LPCWSTR url
    )
/*++

Routine Description:
    Find a transport by a url in the database

Arguments:
    url - The endpoint URL.

Returned Value:
    None.

--*/
{
    TmpAssertValid();
    
    CSR readLock(s_rwlock);

    TrTRACE(Tm, "TmGetTransport. url: %ls", url);

    TMAP::iterator it = TmpFind(url);

    if(it == s_transports.end())
        return NULL;

    return it->second;
}


void
TmpCreateNewTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT targetPort,
	USHORT nextHopPort,
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
    LPCWSTR queueUrl,
	bool fSecure
    )
{
    //
    // The state of the map isn't consistence until the function
    // is completed (add a null transport for place holder). Get the CS to 
    // insure that other process doesn't enumerate the data structure during this time
    //
    CSW writeLock(s_rwlock);

    TrTRACE(Tm, "TmNotifyNewQueue. url: %ls, queue: 0x%p", queueUrl, pMessageSource);

    //
    // Add the url to the map. We do it before creating the transport to inssure 
    // that after creation we always success to add the new transport to the data 
    // structure (place holder)
    //
    AP<WCHAR> mapurl = newwcs(queueUrl);
    pair<TMAP::iterator, bool> pr = s_transports.insert(TMAP::value_type(mapurl, NULL));

    TMAP::iterator it = pr.first;

    if (! pr.second)
    {
        //
        // BUGBUG: The queue can close while it has an active message transport. As
        //         a result the CQueueMgr moved the queue from the group and remove it. 
        //         Now the Tm is asked to create mt for this queue but it already has a one.  
        //         So the Tm release the previous transport before creating a new one.
        //         When we will have a Connection Cordinetor we need to handle it better
        //                          Uri Habusha, 16-May-2000
        //
        delete [] it->first;            
        s_transports.erase(it);

        pr = s_transports.insert(TMAP::value_type(mapurl, NULL));

        it = pr.first;
        ASSERT(pr.second);
    }

    mapurl.detach();

    try
    {
        //
        // Get transport timeouts
        //
        CTimeDuration responseTimeout;
        CTimeDuration cleanupTimeout;
 
        DWORD SendWindowinBytes, SendWindowinPackets;

        TmpGetTransportTimes(responseTimeout, cleanupTimeout);

        TmpGetTransportWindows(SendWindowinBytes,SendWindowinPackets);

        //
        // Replace the NULL transport in place holder, with the created transport
        //
        it->second = MtCreateTransport(
                                targetHost,
                                nextHop, 
                                nextUri, 
                                targetPort, 
								nextHopPort,
                                queueUrl,
                                pMessageSource, 
								pPerfmon,
                                responseTimeout, 
                                cleanupTimeout,
								fSecure,
                                SendWindowinBytes,
                                SendWindowinPackets
                                );
    }
    catch(const exception&)
    {
        //
        // Remove the place holder from the map
        //
        delete [] it->first;            
        ASSERT(it->second.get() == NULL);

        s_transports.erase(it);

        throw;
    }

    TrTRACE(
        Tm, 
        "Created message transnport (pmt = 0x%p), target host = %.*ls, next hop = %.*ls, port = %d, uri = %.*ls",
        (it->second).get(),
        LOG_XWCS(targetHost),
        LOG_XWCS(nextHop), 
        nextHopPort,
        LOG_XWCS(nextUri)
        );
}


R<CTransport>
TmFindFirst(
    void
    )
/*++

Routine Description:
    Find first transport in s_transports. The function returns a pointer to the
    CTransport, from which the caller can get the transport state and URL.
    
    The caller must release the transport reference count

Arguments:
    None..

Returned Value:
    Pointer to CTransport. NULL is returned If the map is empty.

--*/
{
    TmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.begin()->second;
}


R<CTransport>
TmFindLast(
    void
    )
/*++

Routine Description:
    Find last transport in s_transports. The function returns a pointer to the
    CTransport, from which the caller can get the transport state and URL.
    
    The caller must release the transport reference count

Arguments:
    None..

Returned Value:
    Pointer to CTransport. NULL is returned If the map is empty.

--*/
{
    TmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.rbegin()->second;
}


R<CTransport>
TmFindNext(
    const CTransport& transport
    )
/*++

Routine Description:
    Find next transport in s_transport.

Arguments:
    transport - reference to transport.

Returned Value:
    The next CTransport in the database. NULL is returned if there is no more data

--*/
{
    TmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.upper_bound(const_cast<WCHAR*>(transport.QueueUrl()));

    //
    // No element found
    //
    if(it == s_transports.end())
        return NULL;

    return it->second;
}


R<CTransport>
TmFindPrev(
    const CTransport& transport
    )
/*++

Routine Description:
    Find prev transport in s_transport.

Arguments:
    transport - reference to transport.

Returned Value:
    The prev CTransport in the database. NULL is returned if there is no more data

--*/
{
    TmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.lower_bound(const_cast<WCHAR*>(transport.QueueUrl()));

    //
    // No element found
    //
    if(it == s_transports.begin())
        return NULL;

    --it;

    return it->second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tmp.h

Abstract:
    HTTP transport manager private functions.

Author:
    Uri Habusha (urih) 03-May-00

--*/

#pragma once

#ifndef _MSMQ_Tmp_H_
#define _MSMQ_Tmp_H_

#include <xstr.h>

const TraceIdEntry Tm = L"HTTP transport manager";
const USHORT xHttpDefaultPort = 80;


#ifdef _DEBUG

void TmpAssertValid(void);
void TmpSetInitialized(void);
BOOL TmpIsInitialized(void);
void TmpRegisterComponent(void);

#else // _DEBUG

#define TmpAssertValid() ((void)0)
#define TmpSetInitialized() ((void)0)
#define TmpIsInitialized() TRUE
#define TmpRegisterComponent() ((void)0)

#endif // _DEBUG

void 
TmpInitConfiguration(
    void
    );


void 
TmpSetWebProxy(
    LPCWSTR proxyUrl,
	LPCWSTR pByPassList
    );


void 
TmpGetTransportTimes(
    CTimeDuration& ResponseTimeout,
    CTimeDuration& CleanupTimeout
    );

void 
TmpGetTransportWindows(
    DWORD& SendWindowinBytes,
    DWORD& SendWindowinPackets 
    );

void 
TmpRemoveTransport(
    LPCWSTR url
    );


class IMessagePool;
class ISessionPerfmon;

void
TmpCreateNewTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& uri,
    USHORT port,
	USHORT nextHopPort,
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
    LPCWSTR queueUrl,
	bool fSecure
    );

#endif // _MSMQ_Tmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmwinhttpproxy.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmWinHttpProxy.H

Abstract:
    Header that  exposes API  for getting proxy setting information using winhttp
	proxy setting for a machine in the registry.

Author:
    Gil Shafriri (gilsh) 15-April-2001

--*/
#ifndef _MSMQ_WINHTTPPROXY_H_
#define _MSMQ_WINHTTPPROXY_H_

class CProxySetting;
CProxySetting* GetWinhttpProxySetting();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\lib\tmwinhttpproxy.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmWinHttpProxy.cpp

Abstract:
    Implementing CreateWinhhtpProxySetting function (TmWinHttpProxy.h)

Author:
    Gil Shafriri (gilsh) 15-April-2001

--*/
#include <libpch.h>
#include <wininet.h>
#include <cm.h>
#include <utf8.h>
#include "TmWinHttpProxy.h"
#include "tmconset.h"
#include "tmp.h"
#include "TmWinHttpProxy.tmh"

//
// Class for reading winhhtp proxy blob information
//
class CProxyBlobReader
{
public:
	CProxyBlobReader(
		const BYTE* blob, 
		DWORD len
		):
		m_blob(blob),
		m_len(len),
		m_offset(0)
		{
		}


	//
	// Read data from the proxy blob and increament read location
	//
	void  Read(void* pData,  DWORD len)	throw(std::out_of_range)
	{
		if(m_len - m_offset < len)
		{
			TrERROR(Tm,"Invalid proxy setting block in registry");
			throw std::out_of_range("");
		}
		memcpy(pData, m_blob + 	m_offset, len);
		m_offset += len;
	}

	//
	// Read string from the proxy blob and increament the read location
	// String is formatted as length (4 bytes) and after that the string data.
	//
	void ReadStr(char** ppData)throw(std::out_of_range, std::bad_alloc)
	{
		DWORD StrLen;
		Read(&StrLen, sizeof(DWORD));
		AP<char> Str = new char[StrLen +1];
		Read(Str.get(), StrLen);
	   	Str[StrLen] ='\0';
		*ppData = Str.detach();
	}

	
private:
	const BYTE* m_blob;
	DWORD m_len;
	DWORD m_offset;
};



CProxySetting* GetWinhttpProxySetting()
/*++

Routine Description:
    Get proxy setting by reading winhttp proxy information from the registry.
	This information is set by proxycfg.exe tool

Arguments:
      None
	  
Return Value:
    Pointer to CProxySetting object.

--*/
{
	const WCHAR* xPath = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections";
	const WCHAR* xValueName = L"WinHttpSettings";

	RegEntry ProySettingRegName(
				xPath,
				xValueName,
				0,
                RegEntry::Optional,
                HKEY_LOCAL_MACHINE
                );


	AP<BYTE> ProxySettingBlob;
	DWORD len = 0;
    CmQueryValue(ProySettingRegName, &ProxySettingBlob, &len);
	if(len == 0)
	{
		return NULL;
	}		  

	//
	// Parse the proxy blob - throw non relevent data abd keep
	// proxy name and bypaslist
	//
 	CProxyBlobReader BlobReader(ProxySettingBlob, len);
	AP<char>  BypassList;
	AP<char> Proxy;
	try
	{		    
		DWORD StructSize;
		BlobReader.Read(&StructSize, sizeof(DWORD));

		DWORD CurrentSettingsVersion;
		BlobReader.Read(&CurrentSettingsVersion, sizeof(DWORD));

		DWORD Flags;
		BlobReader.Read(&Flags, sizeof(DWORD));
		if(!(Flags & PROXY_TYPE_PROXY))
			return NULL;


		BlobReader.ReadStr(&Proxy);
		BlobReader.ReadStr(&BypassList);
	}
	catch(const std::exception&)
	{
		return NULL;
	}

	AP<WCHAR> wcsProxy = UtlUtf8ToWcs((utf8_char*)Proxy.get());
	AP<WCHAR> wcsProxyBypass = UtlUtf8ToWcs((utf8_char*)BypassList.get());
	return new CProxySetting(wcsProxy, wcsProxyBypass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tr\lib\trdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TrDebug.cpp

Abstract:
    Tracing debugging

Author:
    Erez Haba (erezh) 06-Jan-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>

#ifdef _DEBUG

//
// Support ASSERT_BENIGN
// The default true for this value, so ASSERT_BENIGN will not create the false impression of asserting
// while it is not. The applicaiton may set this value directly;
//
bool g_fAssertBenign = true;

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tm\test\tmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmTest.cpp

Abstract:
    Transport manager library test

Author:
    Uri Habusha (urih) 19-Jan-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Tm.h>
#include <Cm.h>
#include <Mt.h>
#include <msi.h>
#include <spi.h>
#include "timetypes.h"

#include "Tmp.h"

#include "TmTest.tmh"

const TraceIdEntry TmTest = L"Transport manager Test";


class CGroup : public IMessagePool
{
public:
    CGroup() :
        IMessagePool()
    {
        AddRef();
    }

    ~CGroup()
    {
    }
    

    void Requeue(CQmPacket* )
    {
        throw exception();
    }


    void EndProcessing(CQmPacket* )
    {
        throw exception();
    }

    void LockMemoryAndDeleteStorage(CQmPacket* )
    {
        throw exception();
    }

    void GetFirstEntry(EXOVERLAPPED* , CACPacketPtrs& )
    {
        throw exception();
    }
    
    void CancelRequest(void)
    {
        throw exception();
    }
};


class CTestTransport : public CTransport
{
public:
    CTestTransport(
        LPCWSTR queueUrl
        ) :
        CTransport(queueUrl)
    {
    }

    LPCWSTR ConnectedHost(void) const
    {
        return 0;
    }
    

    LPCWSTR ConnectedUri(void) const
    {
        return 0;
    }
    
    
    USHORT ConnectedPort(void) const
    {
        return 0;
    }

};


R<CTransport>
MtCreateTransport(
    const xwcs_t&,
    const xwcs_t&,
    const xwcs_t&,
    USHORT,
	USHORT,
    LPCWSTR queueUrl,
	IMessagePool*,
	ISessionPerfmon*,
	const CTimeDuration&,
    const CTimeDuration&,
	bool,
    DWORD,
    DWORD
    )
{
    return new CTestTransport(queueUrl);
}



static BOOL s_fCanCloseQueue = TRUE;

void CmQueryValue(const RegEntry&, CTimeDuration* pValue)
{
   *pValue = CTimeDuration(rand());
}

void CmQueryValue(const RegEntry&, BYTE** ppData, DWORD* plen)
{
	const DWORD xSize = 100;
	AP<BYTE> pData = new BYTE[xSize];
	memset(pData,'a', xSize);
	*ppData = pData.detach();
	*plen =  xSize;
}



void TmpInitConfiguration(void)
{
    NULL;
}


void 
TmpGetTransportTimes(
    CTimeDuration& ResponseTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    ResponseTimeout = CTimeDuration(rand());
    CleanupTimeout = CTimeDuration(rand());
}


void 
TmpGetTransportWindows(
    DWORD& SendWindowinBytes,
    DWORD& SendWindowinPackets 
    )
{
   SendWindowinBytes = rand();
   SendWindowinPackets = rand(); 
}

const WCHAR* xQueueUrl[] = {
    L"http://m1:8889/ep1",
    L"http://m2/ep1",
    L"http://m3:9870/ep1/tt/ll lll ll",
    L"http://m4.ntdev.microsoft.com/ep1",
    L"http://m2/ep1$",
    L"http://m1/ep1$"
    };
            

void CheckError(bool f, DWORD line)
{
    if (f)
        return;

    TrERROR(TmTest, "Failed. Error in line %d", line);
    exit(1);
}


extern "C" int  __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Transport manager library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&TmTest, 1);

    TmInitialize();

    //
    // Add transport to TM
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[0]);

    //
    // Get first transport in TM. 
    //
    R<CTransport> tr = TmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[0]) == 0), __LINE__);
                                               
    //
    // Get previous transport. Should failed since there is only one transport 
    //
    R<CTransport> tr2 = TmFindPrev(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    //
    // remove the transport from Tm map
    //
    TmTransportClosed(tr->QueueUrl());
    tr.free();

    //
    // Add new transport
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[1]);

    //
    // Get pointer to the transport. So afterwards teh test can ask the next and prev
    //
    tr = TmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[1]) == 0), __LINE__);


    //
    // add new transports to Tm map
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[0]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[2]);

    //
    // Get previous transport
    //
    tr2 = TmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError((wcscmp(tr2->QueueUrl(), xQueueUrl[0]) == 0), __LINE__);
    tr2.free();


    //
    // remove the added transports
    TmTransportClosed(tr->QueueUrl());

    R<CTransport> tr1 = TmGetTransport(xQueueUrl[2]);
    TmTransportClosed(tr1->QueueUrl());

    //
    // Find the previous transport of non-existing transport
    //
    tr2 = TmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError((wcscmp(tr2->QueueUrl(), xQueueUrl[0]) == 0), __LINE__);
    tr2.free();

    //
    // Find the next transport of non-existing transport
    // 
    tr2 = TmFindNext(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    tr.free();


    //
    // Add new transports to Tm 
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[1]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[2]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[3]);

    //
    // Enumerate the transport in order
    //
    DWORD i = 0;
    for(tr = TmFindFirst(); tr.get() != NULL; tr = TmFindNext(*tr.get()), ++i)
    {
        CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[i]) == 0), __LINE__);
    }


    //
    // Close transports
    //
    R<CTransport> tr3 = TmGetTransport(xQueueUrl[3]);
    TmTransportClosed(tr3->QueueUrl());

    R<CTransport> tr4 = TmGetTransport(xQueueUrl[0]);
    TmTransportClosed(tr4->QueueUrl());

    R<CTransport> tr5 = TmGetTransport(xQueueUrl[2]);
    TmTransportClosed(tr5->QueueUrl());


    //
    // Find the first transport in Tm map, that is the only one
    //
    tr = TmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[1]) == 0), __LINE__);
    tr.free();

    //
    // Close the queue, but act like there is message in the queue
    //
    s_fCanCloseQueue = FALSE;
    R<CTransport> tr6 = TmGetTransport(xQueueUrl[1]);
    TmTransportClosed(tr6->QueueUrl());

    tr = TmFindFirst();
    CheckError((tr.get() == NULL), __LINE__);

    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[4]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[5]);

    tr = TmGetTransport(xQueueUrl[4]);
    CheckError((tr.get() != NULL), __LINE__);
    tr.free();

    TrTRACE(TmTest, "Test passed successfully...");
    
    WPP_CLEANUP();
    return 0;
}

BOOL
McIsLocalComputerName(
	LPCSTR /*host*/
	)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\tr\lib\dbgrpt.cpp ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:
    dbgrpt.cpp

Abstract:
    Assertion functions (the best functions ever :))

Author:
    Erez Haba (erezh) 30-Apr-2001

--*/


#include <libpch.h>
#include <signal.h>

//
// Assertion length constants
//
const int xMaxBoxLineLength = 64;
const int xMaxMessageLength = 1024;

#define MAILTO_MSG \
    "<mailto:msmqbugs@microsoft.com>"

//
// Assert box text
//
#define ASSERT_BOX_CAPTION \
    "Message Queuing"

#define ASSERT_BOX_HEADER_MSG \
    "Debug Assertion Failed!\n\n"

#define TOO_LONG_BOX_MSG \
    "Cannot display debug information. String is too long or an I/O error.\n"

#define ASSERT_BOX_FOOTER_MSG \
    "\n" \
    "\n" \
    "Please send this information to Message Queuing support  \n" \
     MAILTO_MSG "\n" \
    "\n" \
    "(Press Retry to debug the application)"

#define STRING_TOO_LONG_BOX_MSG  ASSERT_BOX_HEADER_MSG TOO_LONG_BOX_MSG ASSERT_BOX_FOOTER_MSG


//
// Debugger output text
//
#define STRING_TOO_LONG_DBG_MSG \
    "\n*** Assertion failed! " MAILTO_MSG "***\n\n"


static
int
TrpMessageBoxA(
    const char* Text,
    const char* Caption,
    unsigned int Type
    )
/*++

Routine Description:
    Load and display the assert messagae box.
    Use a dynamic load not to force static linking with user32.dll.
    This will leak the user32 dll in case of assertion, but who cares

Arguments:
    Text - The text to display in the box
    Caption - The messagae box title
    Type - The message box type attributes

Returned Value:
    The message box result, or 0 in case the box can not be loaded. 

--*/
{
    typedef int (APIENTRY * PFNMESSAGEBOXA)(HWND, LPCSTR, LPCSTR, UINT);
    static PFNMESSAGEBOXA pfnMessageBoxA = NULL;

    if (NULL == pfnMessageBoxA)
    {
        HINSTANCE hlib = LoadLibraryA("user32.dll");

        if (NULL == hlib)
            return 0;
        
        pfnMessageBoxA = (PFNMESSAGEBOXA) GetProcAddress(hlib, "MessageBoxA");
        if(NULL == pfnMessageBoxA)
            return 0;
    }

    return (*pfnMessageBoxA)(NULL, Text, Caption, Type);
}


static
bool
TrpAssertWindow(
    const char* FileName,
    unsigned int Line,
    const char* Text
    )
/*++

Routine Description:
    Format and display the assert box. This function aborts the applicaiton if
    required so.
    This function is called if no debugger is attached and kernel debugger
    not specified

Arguments:
    FileName - The assert file location
    Line - The assert line location
    Text - The assert text to display

Returned Value:
    true, if the user asked to break into the debugger;
    false if to ignore the assertion

--*/
{
    //
    // Shorten program name
    //
    char szExeName[MAX_PATH];
    if (!GetModuleFileNameA(NULL, szExeName, MAX_PATH))
        strcpy(szExeName, "<program name unknown>");

    char *szShortProgName = szExeName;
    if (strlen(szShortProgName) > xMaxBoxLineLength)
    {
        szShortProgName += strlen(szShortProgName) - xMaxBoxLineLength;
        strncpy(szShortProgName, "...", 3);
    }

    char szOutMessage[xMaxMessageLength];
    int n = _snprintf(
                szOutMessage,
                TABLE_SIZE(szOutMessage),
                ASSERT_BOX_HEADER_MSG
                "Program: %s\n"
                "File: %s\n"
                "Line: %u\n"
                "\n"
                "Expression: %s\n"
                ASSERT_BOX_FOOTER_MSG,
                szShortProgName,
                FileName,
                Line,
                Text
                );
    if(n < 0)
    {
        C_ASSERT(TABLE_SIZE(STRING_TOO_LONG_BOX_MSG) < TABLE_SIZE(szOutMessage));

        strcpy(szOutMessage, STRING_TOO_LONG_BOX_MSG);
    }

    //
    // Display the assertion
    //
    // Use,
    //      MB_SYSTEMMODAL
    //      Put the box always on top of all windows
    //
    //      MB_DEFBUTTON2
    //      Retry is the default button, to prevent accidental termination of the process
    //      by keystroke
    //
    //      MB_SERVICE_NOTIFICATION
    //      Make the box appear even if the service is not interactive with the desktop
    //
    int nCode = TrpMessageBoxA(
                    szOutMessage,
                    ASSERT_BOX_CAPTION,
                    MB_SYSTEMMODAL |
                        MB_ICONHAND |
                        MB_ABORTRETRYIGNORE | 
                        MB_SERVICE_NOTIFICATION |
                        MB_DEFBUTTON2
                    );

    //
    // Abort: abort the plrogram by rasing an abort signal
    //
    if (IDABORT == nCode)
    {
        raise(SIGABRT);
    }

    //
    // Ignore: continue execution
    //
    if(IDIGNORE == nCode)
        return false;

    //
    // Retry or message box failed: return true to break into the debugger
    //
    return true;
}


static
bool
TrpDebuggerBreak(
    const char* FileName,
    unsigned int Line,
    const char* Text
    )
/*++

Routine Description:
    Format and display the assert text.
    This funciton is called trying to break into user or kernel mode debugger.
    If it cannot break debug breakpoint exception is raised.

Arguments:
    FileName - The assert file location
    Line - The assert line location
    Text - The assert text to display

Returned Value:
    true, break into the debugger at the assert line
    false, a break into debuger was successful don't break again
    debug breakpoint exception, when no debugger was around to handle this break

--*/
{
    char szOutMessage[xMaxMessageLength];
    int n = _snprintf(
                szOutMessage,
                TABLE_SIZE(szOutMessage),
                "\n"
                "*** Assertion failed: %s\n"
                "    Source File: %s, line %u\n"
                "    " MAILTO_MSG "\n\n",
                Text,
                FileName,
                Line
                );
    if(n < 0)
    {
        C_ASSERT(TABLE_SIZE(STRING_TOO_LONG_DBG_MSG) < TABLE_SIZE(szOutMessage));

        strcpy(szOutMessage, STRING_TOO_LONG_DBG_MSG);
    }

    OutputDebugStringA(szOutMessage);

    //
    // The debugger is present, let it break on the assert line rather than here
    //
    if(IsDebuggerPresent())
        return true;

    //
    // No debugger is attached to this process, try kernel debugger.
    // Use VC7 cool breakpoint insert.
    //
    __debugbreak();
    return false;
}


bool
TrAssert(
    const char* FileName,
    unsigned int Line,
    const char* Text
    )
/*++

Routine Description:
    The assertion failed try to break into the debugger.
    First try directly and if no debugger respond pop-up a message box.

Arguments:
    FileName - The assert file location
    Line - The assert line location
    Text - The assert text to display

Returned Value:
    true, break into the debugger at the assert line
    false, ignore the assertion;

--*/
{
    __try
    {
        return TrpDebuggerBreak(FileName, Line, Text);
    }
    __except(GetExceptionCode() == STATUS_BREAKPOINT)
    {
        return TrpAssertWindow(FileName, Line, Text);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ts\lib\event.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    event.cpp

Abstract:
    Simulate Event Reporting

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ev.h"

#include "event.tmh"

static LONG s_fInitialized = FALSE;

void EvpSetInitialized(void)
{
    LONG fEvAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    ASSERT(!fEvAlreadyInitialized);
	DBG_USED(fEvAlreadyInitialized);
}


BOOL EvpIsInitialized(void)
{
    return s_fInitialized;
}



static HMODULE s_hInst = NULL;
const TraceIdEntry EvSim = L"EvSim";

static 
void
TraceReportEvent(
    DWORD EventId,
    va_list va
    )
/*++

Routine Description:
   The Routine printd the event-log message into tracing window

Arguments:
    EventId  - Message id
    pArglist - pointer to argument list for values for 
               formatted message

Returned Value:
    None.

--*/
{
    ASSERT(s_hInst != NULL);

    WCHAR msg[1024];
    DWORD ret = FormatMessage( 
                    FORMAT_MESSAGE_FROM_HMODULE,
                    s_hInst,
                    EventId,
                    0,
                    msg,
                    TABLE_SIZE(msg),
                    &va
                    );
    if (ret == 0)
    {
        TrERROR(EvSim, "Failed to Format Message. Error %d", GetLastError());
        return;
    }

    printf("(%x) %ls\n", EventId, msg);
}


void 
__cdecl
EvReport(
    DWORD EventId,
    DWORD,
    PVOID,
    WORD NoOfStrings
    ... 
    ) 
{
    ASSERT(EvpIsInitialized());

    //     
    // Look at the strings, if they were provided     
    //     
    va_list va;
    va_start(va, NoOfStrings);
   
    TraceReportEvent(EventId, va);

    va_end(va);

}

void
__cdecl
EvReport(
    DWORD EventId,
    WORD NoOfStrings
    ... 
    ) 
{
    ASSERT(EvpIsInitialized());

    va_list va;
    va_start(va, NoOfStrings);
   
    TraceReportEvent(EventId, va);

    va_end(va);
}


void 
EvReport(
    DWORD EventId
    ) 
{
    ASSERT(EvpIsInitialized());

    TraceReportEvent(EventId, NULL);
}


const WCHAR xEventFileValue[] = L"EventMessageFile";
const WCHAR xEventSourcePath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";

static void LoadEventReportLibrary(LPCWSTR ApplicationName)
{
    WCHAR RegApplicationEventPath[256];

    ASSERT(TABLE_SIZE(RegApplicationEventPath) > (wcslen(ApplicationName) + wcslen(xEventSourcePath)));
    swprintf(RegApplicationEventPath, L"%s%s", xEventSourcePath, ApplicationName);

    //
    // Featch the name of Event Report string library from registery
    //
    WCHAR LibraryName[256];

    HKEY hKey;
    int rc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    RegApplicationEventPath,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

    if (rc != ERROR_SUCCESS)
    {
        TrERROR(EvSim, "Can't open Registery Key %ls: Error %d", xEventSourcePath, GetLastError());
        return;
    }

    DWORD Type = REG_SZ;
    DWORD Size = 256 * sizeof(WCHAR);
    rc = RegQueryValueEx (
                hKey,
                xEventFileValue, 
                0,
                &Type, 
                reinterpret_cast<BYTE*>(&LibraryName),
                &Size
                );

    if (rc != ERROR_SUCCESS)
    {
        TrERROR(EvSim, "can't Read Registery Value %ls\\%ls. Error %d", xEventSourcePath, xEventFileValue, GetLastError());
        return;
    }

    //
    // get an handle to Event Report string library 
    //
    s_hInst = LoadLibrary(LibraryName);
    if (s_hInst == NULL) 
    {
        TrERROR(EvSim, "Can't Load Event report library %ls. Error=%d", LibraryName, GetLastError());
    }
}    


VOID
EvInitialize(
    LPCWSTR ApplicationName
    )
/*++

Routine Description:
    Initializes Event Report library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(!EvpIsInitialized());

    LoadEventReportLibrary(ApplicationName);
    
    EvpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\lib\strutl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    strutl.cpp
 
Abstract: 
    implementation file for string utilities

Author:
    Gil Shafriri (gilsh) 15-10-2000

--*/
#include <libpch.h>
#include <strutl.h>
#include <xstr.h>

#include "strutl.tmh"

/////////////////////////////////////
// CRefcountStr_t implementation	
////////////////////////////////////

//
// Take ownership with duplicate the string
//
template <class T>
CRefcountStr_t<T>::CRefcountStr_t(
	const T* str
	):
	m_autostr(UtlStrDup(str))
	{
	}

	//
	// Take ownership without duplicate	the string
	//
	template <class T>
	CRefcountStr_t<T>::CRefcountStr_t(
	T* str ,
	int
	):
	m_autostr(str)
	{
	}

//
// Take ownership without duplicate	the given string
//
template <class T>
CRefcountStr_t<T>::CRefcountStr_t(
	const basic_xstr_t<T>& xstr
	):
	m_autostr(xstr.ToStr())	
	{
	}


template <class T> const T* CRefcountStr_t<T>::getstr()
{
	return m_autostr.get();			
}


//
// Explicit instantiation
//
template class 	 CRefcountStr_t<wchar_t>;
template class 	 CRefcountStr_t<char>;


/////////////////////////////////////
// CStringToken implementation	
////////////////////////////////////


template <class T, class Pred >
CStringToken<T, Pred>::CStringToken<T, Pred>(
			const T* str,
			const T* delim,
			Pred pred
			):
			m_startstr(str),
			m_delim(delim),
			m_pred(pred),
			m_endstr(str + UtlCharLen<T>::len(str)),
			m_enddelim(delim + UtlCharLen<T>::len(delim))
{
							
}

template <class T, class Pred >
CStringToken<T, Pred>::CStringToken<T, Pred>(
			const basic_xstr_t<T>&  str,
			const basic_xstr_t<T>&  delim,
			Pred pred = Pred()
			):
			m_startstr(str.Buffer()),
			m_delim(delim.Buffer()),
			m_pred(pred),
			m_endstr(str.Buffer() + str.Length()),
			m_enddelim(delim.Buffer() + delim.Length())
{
}


template <class T, class Pred >
CStringToken<T, Pred>::CStringToken<T, Pred>(
			const basic_xstr_t<T>&  str,
			const T* delim,
			Pred pred = Pred()
			):
			m_startstr(str.Buffer()),
			m_delim(delim),
			m_pred(pred),
			m_endstr(str.Buffer() + str.Length()),
			m_enddelim(delim + UtlCharLen<T>::len(delim))

{
}


template <class T, class Pred>
CStringToken<T,Pred>::iterator 
CStringToken<T,Pred>::begin() const
{
	return FindFirst();
}


template <class T,class Pred>
CStringToken<T,Pred>::iterator 
CStringToken<T,Pred>::end()	const
{
	return 	iterator(m_endstr, m_endstr, this);
}


template <class T, class Pred> 
const CStringToken<T,Pred>::iterator 
CStringToken<T,Pred>::FindNext(
						const T* begin
						)const
{
	begin += m_enddelim - m_delim;
	ASSERT(m_endstr >= begin);
	const T* p = std::search(begin, m_endstr, m_delim, m_enddelim, m_pred);
	return p == m_endstr ? end() : iterator(begin, p, this);	
}
	    

template <class T, class Pred> 
const CStringToken<T,Pred>::iterator 
CStringToken<T, Pred>::FindFirst() const
						
{
	const T* p = std::search(m_startstr, m_endstr, m_delim, m_enddelim, m_pred);
	return p == m_endstr ? end() : iterator(m_startstr, p, this);
}


//
// Explicit instantiation
//
template class 	 CStringToken<wchar_t>;
template class 	 CStringToken<char>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\lib\utf8.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    utf8.cpp
 
Abstract: 
    Implementation of conversion functions from\to utf8 caracters set

Author:
    Gil Shafriri (gilsh) 15-10-2000

--*/
#include <libpch.h>
#include <utf8.h>
#include <strutl.h>

#include "utf8.tmh"

static size_t UtlUtf8LenOfWc(wchar_t wc)throw()
/*++

Routine Description:
	return the number of utf8 caracters representing the given unicode caracter.


Arguments:
     wc - unicode carcter.

Returned value:
	number of utf8 caracters representing the given unicode caracter.	
--*/
{
  if (wc < 0x80)
    return 1;

  if (wc < 0x800)
    return 2;

  return 3;
}


size_t UtlUtf8LenOfWcs(const wchar_t* pwc,	size_t cbWcs)throw()
/*++

Routine Description:
	Return the number of utf8 caracters representing the given unicode buffer.


Arguments:
     pwc - unicode buffer.
	 cbWcs - unicode buffer length in unicode caracters.

Returned value:
	The number of utf8 caracters representing the given unicode buffer.

--*/
{
	size_t len = 0;
	for(size_t i=0; i<cbWcs; ++i)
	{
		len += 	UtlUtf8LenOfWc(pwc[i]);	
	}
	return len;
}



size_t UtlUtf8LenOfWcs(const wchar_t* pwc)throw()
/*++

Routine Description:
	Return the number of utf8 caracters representing the given unicode null terminating string.


Arguments:
     pwc - unicode string.

Returned value:
	The number of utf8 caracters representing the given unicode null terminating string.

Note:
The null termination unicode caracter (L'\0') is not processed.
--*/
{
	size_t len = 0;
	while(*pwc != L'\0')
	{
		len += 	UtlUtf8LenOfWc(*pwc);	
		pwc++;
	}
	return len;
}

size_t
UtlWcToUtf8(
	wchar_t wc ,
	utf8_char *pUtf8, 
	size_t cbUtf8
	)
/*++

Routine Description:
	Convert single unicode caracter into one or more (up to 3) utf8 caracters.

Arguments:
     wc - Unicode caracter to convert.
	 pUtf8 - Output buffer that receive the utf8 carcters that are the conversion result.
	 cbUtf8 - the size in bytes of the space pUtf8 point to.

Returned value:
	The number of utf8 caracters that copied to the output buffer. If the function
	fails because of invalid input - bad_utf8 exception is thrown.

Note:
The null termination unicode caracter (L'\0') is not processed.
--*/
{
  size_t count = UtlUtf8LenOfWc(wc);
  ASSERT(count <= 3 && count > 0);
  

  if (cbUtf8 < count)
	  throw std::range_error("");


  switch (count) /* note: code falls through cases! */
  { 
	case 3: pUtf8[2] = (utf8_char)(0x80 | (wc & 0x3f)); wc = wc >> 6; wc |= 0x800;
	case 2: pUtf8[1] = (utf8_char)(0x80 | (wc & 0x3f)); wc = wc >> 6; wc |= 0xc0;
	case 1: pUtf8[0] = (utf8_char)(wc);
  }
  return count;
}

static
size_t
UtlUtf8ToWc(
	const utf8_char *pUtf8, 
	size_t cbUtf8,
	wchar_t *pwc
	)
/*++

Routine Description:
	Convert utf8 caracters into single unicode caracter.

Arguments:
     pUtf8 - Pointer to utf8 caracters that should be converted into single unicode caracter.
	 cbUtf8 - The length in bytes of the buffer pUtf8 points to.
	 pwc - Output buffer for the unicode caracter created.

Returned value:
	The number of utf8 caracters that converted. If the function failed because of invalid
	input - bad_utf8 exception is thrown.

--*/
{
	ASSERT(pwc != 0);
	ASSERT(pUtf8 != 0);
	ASSERT(cbUtf8 != 0);

	utf8_char c = pUtf8[0];

	if (c < 0x80)
	{
		*pwc = c;
		return 1;
	} 


	if (c < 0xc2) 
	{
		throw bad_utf8();
	}
 
	if (c < 0xe0) 
	{
		if (cbUtf8 < 2)
			throw std::range_error("");


		if (!((pUtf8[1] ^ 0x80) < 0x40))
		  throw bad_utf8();


		*pwc = ((wchar_t) (c & 0x1f) << 6) | (wchar_t) (pUtf8[1] ^ 0x80);
		return 2;
	}

	if (c < 0xf0) 
	{
		if (cbUtf8 < 3)
			throw std::range_error("");


		if (!((pUtf8[1] ^ 0x80) < 0x40 && (pUtf8[2] ^ 0x80) < 0x40
			  && (c >= 0xe1 || pUtf8[1] >= 0xa0)))
		  throw bad_utf8();


		*pwc = ((wchar_t) (c & 0x0f) << 12)
			   | ((wchar_t) (pUtf8[1] ^ 0x80) << 6)
			   | (wchar_t) (pUtf8[2] ^ 0x80);

		return 3;
	} 
	throw bad_utf8();
}

void 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8,
		wchar_t* pWcs,
		size_t cbWcs,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert utf8 array (not null terminating) into unicode string.

Arguments:
    pUtf8 - utf8 string to convert.
	size_t  cbUtf8 size in bytes of array pUtf8 points to.
	pWcs -  Output buffer for the converted unicode caracters
	cbWcs - The size in unicode caracters of the space that pWcs points to.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of unicode caracters in it >= strlen(pUtf8) +1

--*/
{
	size_t index = 0;
	const utf8_char* Utf8End = pUtf8 + cbUtf8;
	for(; pUtf8 != Utf8End; ++index)
	{
		size_t size = UtlUtf8ToWc(
							pUtf8, 
							cbWcs - index, 
							&pWcs[index]
							);

		pUtf8 += size; 
		ASSERT(pUtf8 <= Utf8End);
		ASSERT(index < cbWcs - 1);
	}
	ASSERT(index < cbWcs);
	pWcs[index] = L'\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}


void 
UtlUtf8ToWcs(
		const utf8_char *pUtf8,
		wchar_t* pWcs,
		size_t cbWcs,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert utf8 string into unicode string.

Arguments:
    pUtf8 - utf8 string to convert.
	pWcs -  Output buffer for the converted unicode caracters
	cbWcs - The size in unicode caracters of the space that pWcs points to.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of unicode caracters in it >= strlen(pUtf8) +1

--*/
{
	size_t index = 0;
	for(; *pUtf8 != '\0' ; ++index)
	{
		size_t size = UtlUtf8ToWc(
							pUtf8, 
							cbWcs - index, 
							&pWcs[index]
							);

		pUtf8 += size; 
		ASSERT(index < cbWcs - 1);
	}
	ASSERT(index < cbWcs);
	pWcs[index] = L'\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}


utf8_char* UtlWcsToUtf8(const wchar_t* pwcs, size_t* pActualLen)

/*++

Routine Description:
	Convert unicode string into utf8 string.

Arguments:
    pwcs - Unicode string to convert.
	pActualLen -  Receives the number of bytes created in utf8 format.


Returned value:
	Utf8 reperesentation of the given unicode string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown.

Note:
	It is the responsibility of the caller to call delete[] on returned pointer.
--*/
{
	ASSERT(pwcs != NULL);
	size_t len = UtlUtf8LenOfWcs(pwcs) +1;

	AP<utf8_char> pUtf8 = new utf8_char[len];
	UtlWcsToUtf8(pwcs, pUtf8.get(), len, pActualLen); 
	return pUtf8.detach();
}


wchar_t* UtlUtf8ToWcs(const utf8_char* pUtf8, size_t cbUtf8, size_t* pActualLen)
/*++

Routine Description:
	Convert utf8 array of bytes into unicode string.

Arguments:
    pUtf8 - utf8 array of bytes to convert.
	cbUtf8 - The length in bytes of the buffer pUtf8 points to.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	Unicode reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

Note:
	It is the responsibility of the caller to call delete[] on returned pointer.

--*/
{
	ASSERT(pUtf8 != NULL);
	
	size_t Wcslen = cbUtf8 + 1;
	AP<wchar_t> pWcs = new wchar_t[Wcslen];
	UtlUtf8ToWcs(pUtf8, cbUtf8, pWcs.get(), Wcslen, pActualLen);
	return 	pWcs.detach();
}


wchar_t* UtlUtf8ToWcs(const utf8_char* pUtf8, size_t* pActualLen)
/*++

Routine Description:
	Convert utf8 string into unicode string.

Arguments:
    pUtf8 - utf8 string to convert.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	Unicode reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

Note:
	It is the responsibility of the caller to call delete[] on returned pointer.

--*/
{
	ASSERT(pUtf8 != NULL);
	
	size_t len = UtlCharLen<utf8_char>::len(pUtf8) + 1;
	AP<wchar_t> pWcs = new wchar_t[len];
	UtlUtf8ToWcs(pUtf8, pWcs.get(), len, pActualLen);
	return 	pWcs.detach();
}


void
UtlWcsToUtf8(
		const wchar_t* pwcs, 
		size_t cbwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert unicode array (non null terminating) into utf8 string.

Arguments:
    pwcs - Unicode string to convert.
	cbwcs - Size in unicode characters of the array pwcs points to.
	pUtf8 - Pointer to buffer that receives the utf8 converted caracters.
	cbUtf8 - The size in bytes of the space that pUtf8 points to.
	pActualLen -  Receives the number of bytes created in utf8 format.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of bytes in it >= UtlWcsUtf8Len(pwcs) +1
--*/
{
	const  wchar_t* pwcsEnd = pwcs + cbwcs;
	size_t index = 0;
	for( ; pwcs != pwcsEnd; ++pwcs)
	{
		ASSERT(index < cbUtf8 - 1);
		index += UtlWcToUtf8(*pwcs, &pUtf8[index], cbUtf8 - index );
	}
	ASSERT(index < cbUtf8);
	pUtf8[index] = '\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}



void
UtlWcsToUtf8(
		const wchar_t* pwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert unicode string into utf8 string.

Arguments:
    pwcs - Unicode string to convert.
	pUtf8 - Pointer to buffer that receives the utf8 converted caracters.
	cbUtf8 - The size in bytes of the space that pUtf8 points to.
	pActualLen -  Receives the number of bytes created in utf8 format.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of bytes in it >= UtlWcsUtf8Len(pwcs) +1
--*/
{
	size_t index = 0;
	for( ; *pwcs != L'\0'; ++pwcs)
	{
		ASSERT(index < cbUtf8 -1);
		index += UtlWcToUtf8(*pwcs, &pUtf8[index], cbUtf8 - index );
	}

	ASSERT(index < cbUtf8);
	pUtf8[index] = '\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}


utf8_str 
UtlWcsToUtf8(
		const std::wstring& wcs
		)
/*++

Routine Description:
	Convert unicode stl string into utf8 stl string.

Arguments:
    wcs - Unicode stl string to convert.

Returned value:
	Stl utf8 string reperesentation of the given unicode string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown.

--*/
{
	size_t len = UtlUtf8LenOfWcs(wcs.c_str()) +1 ;
	utf8_str utf8(len ,' ');

	size_t ActualLen;
	UtlWcsToUtf8(wcs.c_str(), utf8.begin(), len, &ActualLen);

	ASSERT(ActualLen == len -1);
	utf8.resize(ActualLen);
	return utf8;
}

utf8_str 
UtlWcsToUtf8(
		const wchar_t* pwcs,
		size_t cbWcs
		)
/*++

Routine Description:
	Convert unicode buffer into utf8 stl string.

Arguments:
    pwcs - pointer to buffer to convert
	cbWcs - buffer length in unicode bytes

Returned value:
	Stl utf8 string reperesentation of the given unicode string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown.

--*/
{
	size_t len = UtlUtf8LenOfWcs(pwcs, cbWcs) +1;
	utf8_str utf8(len ,' ');

	size_t ActualLen;
	UtlWcsToUtf8(pwcs, cbWcs, utf8.begin(), len, &ActualLen);

	ASSERT(ActualLen == len -1);
	utf8.resize(ActualLen);
	return utf8;
}



std::wstring 
UtlUtf8ToWcs(
			const utf8_str& utf8
			)
/*++

Routine Description:
	Convert utf8 stl string into unicode stl string.

Arguments:
    pUtf8 - utf8 string to convert.

Returned value:
	Stl Unicode string reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

--*/
{
	return UtlUtf8ToWcs	(utf8.c_str(), utf8.size());
}


std::wstring 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8
		)
/*++

Routine Description:
	Convert utf8 array of bytes (non null terminating) into unicode stl string.

Arguments:
    pUtf8 - utf8 string to convert.
	cbUtf8 - The size in bytes  of the array pUtf8 points to.

Returned value:
	Stl Unicode string reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

--*/
{
	size_t len = cbUtf8 +1;

	std::wstring wcs(len ,L' ');
	ASSERT(wcs.size() == len);

	size_t ActualLen;
	UtlUtf8ToWcs(pUtf8, cbUtf8, wcs.begin(), len , &ActualLen);

	ASSERT(ActualLen <= cbUtf8);
	wcs.resize(ActualLen);

	return wcs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\lib\bufutl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    bufutl.cpp

Abstract:
   Implementation to some buffer utilities declared in buftl.h

Author:
    Gil Shafriri (gilsh) 30-7-2000

--*/
#include <libpch.h>
#include <buffer.h>
#include <strutl.h>

#include "bufutl.tmh"

template <class C>
class Utlvsnprintf;
template<> class Utlvsnprintf<char>
{
public:
	static int vsnprintf(char* buffer, size_t count, const char *format, va_list argptr )
	{
		return _vsnprintf(buffer, count, format, argptr);
	}
};


template<> class Utlvsnprintf<wchar_t>
{
public:
	static int vsnprintf(wchar_t* buffer, size_t count, const wchar_t *format, va_list argptr )
	{
			return _vsnwprintf(buffer, count, format, argptr);
	}
};


			   

template <class BUFFER, class T>
static 
size_t
UtlSprintfAppendInternal(
		BUFFER* pResizeBuffer, 
		const T* format,
		va_list va
		)
{
	int len = Utlvsnprintf<T>::vsnprintf(
					pResizeBuffer->begin() + pResizeBuffer->size(),
					pResizeBuffer->capacity() - pResizeBuffer->size(),
					format,
					va
					);
	//
	// If no space in the buffer - realloc
	//
	if(len == -1)
	{
		const size_t xAdditionalSpace = 128;
		pResizeBuffer->reserve(pResizeBuffer->capacity()*2 + xAdditionalSpace );
		return UtlSprintfAppendInternal(pResizeBuffer , format, va);
	}
	pResizeBuffer->resize(pResizeBuffer->size() + len);
	return numeric_cast<size_t>(len);

}


template <class BUFFER, class T>
size_t 
__cdecl 
UtlSprintfAppend(
	BUFFER* pResizeBuffer, 
	const T* format ,...
	)
/*++

Routine Description:
	Append formated string to given resizable buffer


Arguments:
    IN - pResizeBuffer - pointer resizable buffer of caracters

	IN - format - sprintf format string  followed by arguments 

Returned value:
	Number of bytes written to the buffer not including null terminate character.

Note :
The buffer might be reallocated if no space left.

--*/
{
	va_list va;
    va_start(va, format);

   	size_t written = UtlSprintfAppendInternal(pResizeBuffer, format,va);

	return written;
}





template <class BUFFER, class T>
size_t 
UtlStrAppend(
	BUFFER* pResizeBuffer, 
	const T* str
	)
/*++

Routine Description:
	Append  string to given resizable buffer


Arguments:
    IN - pResizeBuffer - pointer resizable buffer of caracters

	IN - str - string to append 

Returned value:
	Number of bytes written to the buffer not including null termination character.

Note :
The buffer might be reallocated if no space left.Null termination is appended but
the new size() will not include it.

--*/
{
	size_t len = UtlCharLen<T>::len(str) + 1;
	pResizeBuffer->append(str , len);


	//
	// Set the new size not including the null termination
	//
	pResizeBuffer->resize(pResizeBuffer->size() - 1);
	return len - 1;
}






//
// explicit instantiation
//
template size_t __cdecl UtlSprintfAppend(CResizeBuffer<char>* pResizeBuffer, const char* format, ...);
template size_t __cdecl UtlSprintfAppend(CResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t* format, ...);
template size_t __cdecl UtlSprintfAppend(CPreAllocatedResizeBuffer<char>* pResizeBuffer, const char* format, ...);
template size_t __cdecl UtlSprintfAppend(CPreAllocatedResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t* format, ...);



template size_t UtlStrAppend(CResizeBuffer<char>* pResizeBuffer, const char* str);
template size_t UtlStrAppend(CResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t*  wstr);
template size_t UtlStrAppend(CPreAllocatedResizeBuffer<char>* pResizeBuffer, const char* str);
template size_t UtlStrAppend(CPreAllocatedResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t* wstr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\test\buftest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    buftest.cpp

Abstract:
   Buffer + buffer utilities test module

Author:
    Gil Shafriri (gilsh) 1-8-2000

--*/
#include <libpch.h>
#include <buffer.h>
#include <bufutl.h>
#include "utltest.h"

#include "buftest.tmh"

void DoBufferUtlTest()
{
	const char* format = "this integer=%d and this string=%s and this second integer=%x\n";
	char buffer[1024];
	CResizeBuffer<char> ResizeBuffer(10);
	TrTRACE(UtlTest,"test formating string to resizable buffer");
	int int1 = 3;
	int int2 = 12233;
	const char* str= "string";
	size_t len1 = sprintf(buffer, format, int1, str,int2);
	size_t len2 = UtlSprintfAppend(&ResizeBuffer,format, int1, str, int2);
	if(len1 !=  len2 || len2 != ResizeBuffer.size() )
	{
		TrERROR(UtlTest,"length of the data written into the resizable buffer is incorrect");
		throw  exception();
	}
	
	if(strcmp(buffer, ResizeBuffer.begin()) != 0 )
	{
		TrERROR(UtlTest,"the formated data  written to the resizable buffer is incorrect");
		throw  exception();
	}

	CStaticResizeBuffer<char ,10> StaticResizeBuffer;
	len2 = UtlSprintfAppend(StaticResizeBuffer.get(), format, int1, str, int2);
	if(len1 !=  len2 || len2 != StaticResizeBuffer.size() )
	{
		TrERROR(UtlTest,"length of the data written into the resizable buffer is incorrect");
		throw  exception();
	}
	if(strcmp(buffer, StaticResizeBuffer.begin()) != 0 )
	{
		TrERROR(UtlTest,"the formated data  written to the resizable buffer is incorrect");
		throw  exception();
	}


	const WCHAR* wstr = L"WSTRING";
	CStaticResizeBuffer<WCHAR ,2> StaticResizeBuffer2;
	size_t l = UtlStrAppend(StaticResizeBuffer2.get(), wstr);
	if( l !=  wcslen(wstr))
	{
		TrERROR(UtlTest,"length of the string written into the resizable buffer is incorrect");
		throw  exception();
	}


	if(wcscmp(wstr, StaticResizeBuffer2.begin())	!= 0)
	{
		TrERROR(UtlTest,"string written into the resizable buffer is incorrect");
		throw  exception();
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\lib\timeutl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    timeutl.cpp
 
Abstract: 
    implementation of time utilities

Author:
    Gil Shafriri (gilsh) 15-10-2000

--*/
#include <libpch.h>
#include <timeutl.h>
#include <xstr.h>
#include <mqexception.h>
#include <strutl.h>

#include "timeutl.tmh"

using namespace std;

template <class T>
std::basic_ostream<T>& 
operator<<(
	std::basic_ostream<T>& o, 
	const CIso8601Time& Iso8601Time
	)
/*++

Routine Description:
	Serialize time integer returned for time() function into stream
	according to  Iso860 format.


Arguments:
    o - stream to format the string into.

	Iso8601Time - holds the number of seconds elapsed since midnight (00:00:00), January 1, 1970. 

Returned value:
	None

--*/
{
    struct tm* ts = gmtime(&Iso8601Time.m_time);
	ASSERT(ts != NULL);
	if(ts == NULL)
	{
		throw bad_time_value();
	}

	T oldfill = o.fill();
	o.fill(o.widen('0'));
	
	o<<setw(4)<<(ts->tm_year + 1900)
	 <<setw(2)<<ts->tm_mon + 1  
	 <<setw(2)<<ts->tm_mday;

	o.put(o.widen('T'))
	<<setw(2)<<ts->tm_hour
	<<setw(2)<<ts->tm_min
	<<setw(2)<<ts->tm_sec;

	o.fill(oldfill);

	return o;
}

//
// Explicit instantiation
//

template std::basic_ostream<char>& 
operator<<(
	std::basic_ostream<char>& o, 
	const CIso8601Time& Iso8601Time
	);


template std::basic_ostream<wchar_t>& 
operator<<(
	std::basic_ostream<wchar_t>& o, 
	const CIso8601Time& Iso8601Time
	);



void
UtlIso8601TimeToSystemTime(
    const xwcs_t& Iso860Time, 
    SYSTEMTIME* pSysTime
    )
/*++

Routine Description:
	convert  Iso860 absolute time format to system time format


Arguments:
    Iso8601Time -  Iso8601 absolute time format to convert

	pSysTime - will holds the system time after the function returns.

Returned value:
	None

  Note:
  the function throw bad_Iso8601Time exception in case of bad format

--*/
{
    memset(pSysTime, 0, sizeof(SYSTEMTIME));

    if (Iso860Time.Length() < 10)
        throw bad_time_format();

    DWORD year;
    DWORD month;
    DWORD day;
    DWORD hour;

    LPCWSTR ptime = Iso860Time.Buffer(); 
    swscanf(ptime, L"%04d%02d%02dT%02d", &year, &month, &day, &hour);

    if ((month > 12) || (day > 31) ||(hour > 24))
        throw bad_time_format();

    pSysTime->wYear = (WORD)year;
    pSysTime->wMonth = (WORD)month;
    pSysTime->wDay = (WORD)day;
	pSysTime->wHour = (WORD)hour;

   
    ptime += 11;
    DWORD remaningLength = Iso860Time.Length() - 11;  
    
    if (remaningLength == 0)
        return;

    if (remaningLength < 2)
        throw bad_time_format();

    swscanf(ptime, L"%02d", &pSysTime->wMinute );

    if (pSysTime->wMinute  > 59)
        throw bad_time_format();

    ptime += 2;
    remaningLength -= 2;

    if (remaningLength == 0)
        return;

    if (remaningLength != 2)
        throw bad_time_format();

    swscanf(ptime, L"%02d", &pSysTime->wSecond);

    if (pSysTime->wSecond > 59)
        throw bad_time_format();
	
}



time_t UtlSystemTimeToCrtTime(const SYSTEMTIME& SysTime)
/*++

Routine Description:
	convert  system time to c runtime time integer 
	(that is the number of seconds elapsed since midnight (00:00:00), January 1, 1970. )


Arguments:
    SysTime -  system time.

Returned value:
	c runtime time value

  Note:
  the function throw bad_Iso8601Time exception in case of bad format

--*/
{
	FILETIME FileTime;
	bool fSuccess = SystemTimeToFileTime(&SysTime, &FileTime) == TRUE;
	if(!fSuccess)
	{
		throw bad_win32_error(GetLastError());
	}
    
	// SystemTimeToFileTime() returns the system time in number 
    // of 100-nanosecond intervals since January 1, 1601. We
    // should return the number of seconds since January 1, 1970.
    // So we should subtract the number of 100-nanosecond intervals
    // since January 1, 1601 up until January 1, 1970, then divide
    // the result by 10**7.
	LARGE_INTEGER* pliFileTime = (LARGE_INTEGER*)&FileTime;
    pliFileTime->QuadPart -= 0x019db1ded53e8000;
    pliFileTime->QuadPart /= 10000000;

	ASSERT(FileTime.dwHighDateTime == 0);

	return min(FileTime.dwLowDateTime, LONG_MAX);
}



time_t
UtlIso8601TimeDuration(
    const xwcs_t& TimeDurationStr
    )
/*++

Routine Description:
	convert relative time duration string (Iso8601 5.5.3.2) to integer


Arguments:
    SysTime -  system time.

Returned value:
	Integer representing the number of seconds the string represent.

  Note:
  the function throw bad_time_format exception in case of bad format

--*/
{
	const  WCHAR xTimeDurationPrefix[] = L"P";
	LPCWSTR p = TimeDurationStr.Buffer() + STRLEN(xTimeDurationPrefix);
    LPCWSTR pEnd = TimeDurationStr.Buffer()+ TimeDurationStr.Length();

    if(!UtlIsStartSec(
			p,
			pEnd,
			xTimeDurationPrefix,
			xTimeDurationPrefix + STRLEN(xTimeDurationPrefix)
			))
	{
		throw bad_time_format();
	}

    DWORD years = 0;
    DWORD months = 0;
    DWORD hours = 0;
    DWORD days = 0;
    DWORD minutes = 0;
    DWORD seconds = 0;
    bool fTime = false;
    DWORD temp = 0;

	while(p++ != pEnd)
    {
        if (iswdigit(*p))
        {
            temp = temp*10 + (*p -L'0');
            continue;
        }

        switch(*p)
        {
			case L'Y':
			case L'y':
				years = temp;
				break;

			case L'M':
			case L'm':
				if (fTime)
				{
					minutes = temp;
				}
				else
				{
					months = temp;
				}
				break;

			case L'D':
			case L'd':
				days = temp;
				break;

			case L'H':
			case L'h':
				hours = temp;
				break;

			case L'S':
			case L's':
				seconds = temp;
				break;

			case L'T':
			case L't':
				fTime = true;
				break;

			default:
				throw bad_time_format();
				break;
			}

			temp = 0;
	}

    months += (years * 12);
    days += (months * 30);
    hours += (days * 24);
    minutes += (hours * 60);
    seconds += (minutes * 60);

    return min(seconds ,LONG_MAX);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\test\utf8test.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    utf8test.cpp

Abstract:
    Test the utf8 conversion functions

Author:
    Gil Shafriri (gilsh) 12-Nov-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <utf8.h>
#include "utltest.h"

#include "utf8test.tmh"

static void DoUtf8TestInternal(size_t rseed)
{	
	//
	// Fill unicode array with random strings
	//
	WCHAR wstr[1000];
	for(size_t i=0; i< TABLE_SIZE(wstr); i++)
	{
		WCHAR wc =  (WCHAR)(rand() % USHRT_MAX);
		wstr[i] = wc != 0 ? wc : (WCHAR)123;
	}
	wstr[TABLE_SIZE(wstr) -1] = L'\0';
	size_t len = wcslen(wstr);

	//
	//  convert it to utf8
	// 
	AP<unsigned char> str = UtlWcsToUtf8(wstr);	 


	//
	// check it length
	//
	if(str[UtlUtf8LenOfWcs(wstr)] != '\0')
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}
	if(UtlUtf8LenOfWcs(wstr) != strlen((char*)str.get()))
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}
  
	//
	// convert it back to unicode
	//
	AP<WCHAR> wstr2 = UtlUtf8ToWcs(str.get());
	if(wstr2[len] != L'\0')
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}
	
	//
	// check against original string
	//
	if(memcmp(wstr, wstr2, len*sizeof(WCHAR)) != 0)
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}

	//
	// convert it again to utf8
	//
	AP<unsigned char> str2 = UtlWcsToUtf8(wstr2.get());
	if(str2[UtlUtf8LenOfWcs(wstr)] != '\0')
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}

	//
	// check length
	//
	if(UtlUtf8LenOfWcs(wstr) != strlen((char*)str2.get()))
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}

	//
	// check the utf8 string accepted
	//
	if(memcmp(str2.get(), str.get(), UtlUtf8LenOfWcs(wstr)) != 0)
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}
	
	//
	// empty unicode conversion	test
	//
	const WCHAR* wnill=L"";
	AP<unsigned char> strnill = UtlWcsToUtf8(wnill);	 
	if(strnill[0] != '\0')
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}
		
	AP<WCHAR> wnill2 =  UtlUtf8ToWcs(strnill.get());
	if(wnill2[0] != L'\0')
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}


	//
	// stl conversion
	//
	std::wstring stlwcs(wstr);
	utf8_str stlstr = UtlWcsToUtf8(stlwcs);
	if(memcmp(stlstr.c_str(), str.get(), UtlUtf8LenOfWcs(wstr)) != 0)
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}

	size_t cbWcs = stlwcs.size();
	stlstr = UtlWcsToUtf8(stlwcs.c_str(), cbWcs);
	if(memcmp(stlstr.c_str(), str.get(), UtlUtf8LenOfWcs(wstr)) != 0)
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}


	
	if(stlstr.size() != UtlUtf8LenOfWcs(wstr))
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}


	stlstr = str.get();
	stlwcs = UtlUtf8ToWcs(stlstr);
	if(memcmp(stlwcs.c_str(), wstr, len*sizeof(WCHAR)) != 0)
	{
		TrERROR(UtlTest,"utf8 conversion error random seed = %I64d",rseed);
		throw exception();
	}
}


void DoUtf8Test()
{
	time_t rseed;
	time(&rseed);
	srand(numeric_cast<DWORD>(rseed));
   
	for(int i =0;i<1000;i++)
	{
		DoUtf8TestInternal(rseed);		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\test\utltest.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    utltest.h

Abstract:
	Headr file for utlities test   

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef UTLTEST_H
#define UTLTEST_H

const TraceIdEntry UtlTest = L"Utilities Test";
void  DoBufferUtlTest();
void  DoStringtest();
void  DoUtf8Test();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\test\strtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    strtest.cpp

Abstract:
  string test utilities

Author:
    Gil Shafriri (gilsh) 1-8-2000

--*/
#include <libpch.h>
#include <strutl.h>
#include <xstr.h>
#include "utltest.h"

#include "strtest.tmh"

static void DoCwstringexTest()
{
	const WCHAR xWstr[] = L"TEST STRING";
	std::wstring wstr(xWstr); 
	Cwstringex wstrex (wstr);
	Cwstringex wstr2ex(wstrex);
	if(wcscmp(wstr.c_str(), wstr2ex.getstr()) !=0)
	{
		TrERROR(UtlTest,"error in Cwstringex class");
		throw exception();
	}

	if(wstr.length() != wstr2ex.getlen() )
	{
		TrERROR(UtlTest,"error in Cwstringex class");
		throw exception();
	}

	Cwstringex wstr3ex(xWstr, STRLEN(xWstr));
	if(STRLEN(xWstr) != wstr3ex.getlen() )
	{
		TrERROR(UtlTest,"error in Cwstringex class");
		throw exception();
	}

	if(xWstr != wstr3ex.getstr() )
	{
		TrERROR(UtlTest,"error in Cwstringex class");
		throw exception();
	}
}




static void DoCRefcountStrTest()
{
	const WCHAR* xTestStr = L"TEST STR";
	R< CWcsRef > RefcountStr( new CWcsRef(xTestStr));
	R<CWcsRef> RefcountStr2;
	RefcountStr2 = 	RefcountStr;
	if(wcscmp(RefcountStr2->getstr(),xTestStr) != 0)
	{
		TrERROR(UtlTest,"error in CRefcountStr class");
		throw exception();
	}

	xwcs_t xstr(xTestStr,wcslen(xTestStr));
	R< CWcsRef > RefcountStr3(new CWcsRef(xstr)); 
	if(wcscmp(RefcountStr2->getstr(),xTestStr) != 0)
	{
		TrERROR(UtlTest,"error in CRefcountStr class");
		throw exception();
	}

	P<WCHAR> Str (newwcs(xTestStr));
	const WCHAR* pStr =   Str.get();
	R< CWcsRef > RefcountStr4( new CWcsRef(Str.detach(), 0 ));
	if(wcscmp(RefcountStr4->getstr(),xTestStr) != 0 || RefcountStr4->getstr() != pStr)
	{
		TrERROR(UtlTest,"error in CRefcountStr class");
		throw exception();
	}
}


static void DoStrMatchTest()
{
	static const char* xStr1 =  "microsoft.com";
	static const char* xPattern1 = "mic*.co*m";
	bool b = UtlStrIsMatch(xStr1, xPattern1);
    if(!b)
	{
		TrERROR(UtlTest,"%s should match %s" ,xPattern1, xStr1 );
		throw exception();
	}

	static const char* xStr2 =  "microsoft.com";
	static const char* xPattern2 = "*";
	b = UtlStrIsMatch(xStr2, xPattern2);
    if(!b)
	{
		TrERROR(UtlTest,"%s should match %s" ,xPattern2, xStr2 );
		throw exception();
	}

	static const char* xStr3 =  "microsoft.com";
	static const char* xPattern3 = "*r**f*";
	b = UtlStrIsMatch(xStr3, xPattern3);
    if(!b)
	{
		TrERROR(UtlTest,"%s should match %s" ,xPattern3, xStr3 );
		throw exception();
	}

	static const char* xStr4 =  "microsoft.com";
	static const char* xPattern4 = "microsoft.com****";
	b = UtlStrIsMatch(xStr4, xPattern4);
    if(!b)
	{
		TrERROR(UtlTest,"%s should match %s" ,xPattern4, xStr4 );
		throw exception();
	}
	
	static const char* xStr5 =  "microsoft.com";
	static const char* xPattern5 = "microsoft.com****a";
	b = UtlStrIsMatch(xStr5, xPattern5);
    if(b)
	{
		TrERROR(UtlTest,"%s should not match %s" ,xPattern5, xStr5 );
		throw exception();
	}

	static const WCHAR* xStr6 =  L"www.microsoft.com";
	static const WCHAR* xPattern6 = L"ww*w.micr*";
	b = UtlStrIsMatch(xStr6, xPattern6);
    if(!b)
	{
		TrERROR(UtlTest,"%ls should match %ls" ,xPattern6, xStr6 );
		throw exception();
	}

	static const WCHAR* xStr7 =  L"ww*w.microsoft.com";
	static const WCHAR* xPattern7 = L"ww^*w.micr*";
	b = UtlStrIsMatch(xStr7, xPattern7);
    if(!b)
	{
		TrERROR(UtlTest,"%ls should match %ls" ,xPattern7, xStr7);
		throw exception();
	}

	static const WCHAR* xStr8 =  L"ww*w.microsoft.com";
	static const WCHAR* xPattern8 = L"ww^^*w.micr*";
	b = UtlStrIsMatch(xStr8, xPattern8);
    if(b)
	{
		TrERROR(UtlTest,"%ls should not match %ls" ,xPattern8, xStr8);
		throw exception();
	}


	static const WCHAR* xStr9 =  L"*****^^^^^";
	static const WCHAR* xPattern9 = L"^*^*^*^*^*^^^^^^^^^^";
	b = UtlStrIsMatch(xStr9, xPattern9);
    if(!b)
	{
		TrERROR(UtlTest,"%ls should match %ls" ,xPattern9, xStr9);
		throw exception();
	}
}


static void	CheckStringParsing(const CStrToken& tokenizer, const char* tokens[], int tokensize)
{	

	std::vector<xstr_t>  v;
	std::copy(tokenizer.begin() ,  tokenizer.end(), std::back_inserter<std::vector<xstr_t> >(v));


	std::vector<xstr_t>  v2;
	for(int i =0;i<tokensize;i++)
	{
		v2.push_back(xstr_t(tokens[i],strlen(tokens[i])));		
	}


	if(!(v2 == v))
	{
		TrERROR(UtlTest,"incorrect string parsing");
		throw exception();
	}


	i=0;
	for(CStrToken::iterator it = tokenizer.begin();it !=  tokenizer.end();it++, i++)
	{
		xstr_t tok = *it;
		if(tok != xstr_t(tokens[i], strlen(tokens[i]) ))
		{
			TrERROR(UtlTest,"incorrect string parsing");
			throw exception();
		}
	}
	if(i != tokensize)
	{
			TrERROR(UtlTest,"incorrect string parsing");
			throw exception();
	}
}

static void DoStrTokenTest()
{
	const char* Tokens[] = {"aaa","bbb","ccc","ddd","yyyyyyyyyy"};
	const char* Delim =	 "\r\n";
	std::ostringstream str;
	for(int i = 0; i< TABLE_SIZE(Tokens); ++i)
	{
		str<<Tokens[i]<<Delim;	
	}

	const std::string tokenizedstr = str.str();
	CStrToken tokenizer(tokenizedstr.c_str(), Delim);
	CheckStringParsing(tokenizer, Tokens, TABLE_SIZE(Tokens));
	CStrToken tokenizer2(
				xstr_t(tokenizedstr.c_str(), tokenizedstr.size() ), 
				xstr_t(Delim,strlen(Delim)) 
				);

	CheckStringParsing(tokenizer2, Tokens, TABLE_SIZE(Tokens));
}

static void DoStrAlgoTest()
{
	const char* s1 ="Host: hhh";
	const char* s2 ="Host:";
	bool b = UtlIsStartSec(
		  s1,
		  s1 + strlen(s1),
		  s2,
		  s2 + strlen(s2)
		  );

	if(!b)
	{
		TrERROR(UtlTest,"bad result from UtlIsStart");
		throw exception();
	}

	const char* s3 ="Host: hhh";
	const char* s4 ="Host::";

	b = UtlIsStartSec(
		  s3,
		  s3 + strlen(s3),
		  s4,
		  s4 + strlen(s4)
		  );

	if(b)
	{
		TrERROR(UtlTest,"bad result from UtlIsStart");
		throw exception();
	}
     
	b = UtlIsStartSec(
		  s4,
		  s4 + strlen(s4),
		  s3,
		  s3 + strlen(s3)
		  );

	if(b)
	{
		TrERROR(UtlTest,"bad result from UtlIsStart");
		throw exception();
	}
}

static void DoStaticStrLenTest()
{
	char str[] = "123456789";
	std::wstring wstr= L"123456789";  


	if(wstr.size() != STRLEN(str))
	{
		TrERROR(UtlTest,"bad STRLEN");
		throw exception();
	}
	
	if(wstr.size()  != STRLEN("123456789"))
	{
		TrERROR(UtlTest,"bad STRLEN");
		throw exception();
	}

	if(wstr.size()  != strlen(str))
	{
		TrERROR(UtlTest,"bad STRLEN");
		throw exception();
	}

	xwcs_t x[100];
	if(TABLE_SIZE(x) != 100)
	{
		TrERROR(UtlTest,"bad TABLE_SIZE");
		throw exception();
	}
}

void DoStringtest()
{
	DoCwstringexTest();
	DoStrMatchTest();
	DoCRefcountStrTest();
	DoStrTokenTest();
	DoStrAlgoTest();
	DoStaticStrLenTest();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\utl\test\utltest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    UtlTest.cpp

Abstract:
    Utilities library test

Author:
    Gil Shafriri (gilsh) 31-Jul-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "utltest.h"

#include "UtlTest.tmh"

extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Utilities library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	try
	{
		
	   	TrInitialize();
		TrRegisterComponent(&UtlTest, 1);

		//
		// Buffer utilities test.
		//
		DoBufferUtlTest();

		//
		// String utilities test
		//
	    DoStringtest();

		//
		// Utf8 test
		//
		DoUtf8Test();
	
	}
	catch(const exception&)
	{
		TrERROR(UtlTest,"Get unexcepted exception - test failed");
		return 1;
	}
 	TrTRACE(UtlTest, "Test passed");

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\lib\base64.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    base64.cpp

Abstract:
    functions to convert from octet/bytes to base64 and vice versa

Author:
    Ilan Herbst (ilanh) 5-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <xds.h>
#include <xdsp.h>

#include "base64.tmh"

//
// Conversion table from base64 to wchar_t
// every base64 value (0-63) is map to the corresponding unicode character
//
const WCHAR xBase642AsciiW[] = {
	L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I', L'J',
	L'K', L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S', L'T',
	L'U', L'V', L'W', L'X', L'Y', L'Z', L'a', L'b', L'c', L'd', 
	L'e', L'f', L'g', L'h', L'i', L'j', L'k', L'l', L'm', L'n', 
	L'o', L'p', L'q', L'r', L's', L't', L'u', L'v', L'w', L'x', 
	L'y', L'z', L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', 
	L'8', L'9', L'+', L'/'
	};

C_ASSERT(TABLE_SIZE(xBase642AsciiW) == 64);

//
// Conversion table from base64 to char
// every base64 value (0-63) is map to the corresponding Ascii character
//
const char xBase642Ascii[] = {
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
	'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
	'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 
	'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 
	'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 
	'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', 
	'8', '9', '+', '/'
	};

C_ASSERT(TABLE_SIZE(xBase642Ascii) == 64);

//
// Conversion table from wchar_t to base64 value
// unused values are mark with 255 - we map only the base64 character
// to values from 0-63
//
const BYTE xAscii2Base64[128] = {
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255,  62, 255, 255, 255,  63,  52,  53,
	54,  55,  56,  57,  58,  59,  60,  61, 255, 255,
	255,   0, 255, 255, 255,   0,   1,   2,   3,   4,
	5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
	15,  16,  17,  18,  19,  20,  21,  22,  23,  24,
	25, 255, 255, 255, 255, 255, 255,  26,  27,  28,
	29,  30,  31,  32,  33,  34,  35,  36,  37,  38,
	39,  40,  41,  42,  43,  44,  45,  46,  47,  48,
	49,  50,  51, 255, 255, 255, 255, 255
	};

// C_ASSERT(xAscii2Base64[L'='] == 0);

//
// Mask bits in 24 bit value for the four 6 bit units
// for base64 values
// note the first char is the most significant 6 bit !!
//
const int xFirst6bChar = 0x00fc0000;
const int xSecond6bChar = 0x0003f000;
const int xThird6bChar = 0x00000fc0;
const int xFourth6bChar = 0x0000003f;

const int xFirst6bShift = 18;
const int xSecond6bShift = 12;
const int xThird6bShift = 6;
const int xFourth6bShift = 0;

//
// Mask bits in 24 bit value for the three 8 bit units
// note the first char is the most significant byte !!
//
const int xFirst8bChar = 0x00ff0000;
const int xSecond8bChar = 0x0000ff00;
const int xThird8bChar = 0x000000ff;

const int xFirst8bShift = 16;
const int xSecond8bShift = 8;
const int xThird8bShift = 0;


LPWSTR
Convert3OctetTo4Base64(
	DWORD ThreeOctet,
	LPWSTR pBase64Buffer
	)
/*++

Routine Description:
    Transform 3 Octet bytes to 4 base64 wchar_t
	3 characters (24 bit) are transform into 4 wchar_t in base64
	the function update the pBase64Buffer to point to the next location	and return
	the updated pointer.

Arguments:
	ThreeOctet - input 3Octet value (24 bit) 
	pBase64Buffer - base64 buffer that will be filled with 4 base64 wchar_t

Returned Value:
	updated pointer of pBase64Buffer which points to the next location

--*/
{
	//
	// Calc first 6 bits
	//
	DWORD Res = ((ThreeOctet & xFirst6bChar) >> xFirst6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	//
	// Calc second 6 bits
	//
	Res = ((ThreeOctet & xSecond6bChar) >> xSecond6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	//
	// Calc third 6 bits
	//
	Res = ((ThreeOctet & xThird6bChar) >> xThird6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	//
	// Calc fourth 6 bits
	//
	Res = ((ThreeOctet & xFourth6bChar) >> xFourth6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	return(pBase64Buffer);
}


LPSTR
Convert3OctetTo4Base64(
	DWORD ThreeOctet,
	LPSTR pBase64Buffer
	)
/*++

Routine Description:
    Transform 3 Octet bytes to 4 base64 chars
	3 characters (24 bit) are transform into 4 chars in base64
	the function update the pBase64Buffer to point to the next location	and return
	the updated pointer.

Arguments:
	ThreeOctet - input 3Octet value (24 bit) 
	pBase64Buffer - base64 buffer that will be filled with 4 base64 char

Returned Value:
	updated pointer of pBase64Buffer which points to the next location

--*/
{
	//
	// Calc first 6 bits
	//
	DWORD Res = ((ThreeOctet & xFirst6bChar) >> xFirst6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	//
	// Calc second 6 bits
	//
	Res = ((ThreeOctet & xSecond6bChar) >> xSecond6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	//
	// Calc third 6 bits
	//
	Res = ((ThreeOctet & xThird6bChar) >> xThird6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	//
	// Calc fourth 6 bits
	//
	Res = ((ThreeOctet & xFourth6bChar) >> xFourth6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	return(pBase64Buffer);
}


LPWSTR
Octet2Base64W(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	)
/*++

Routine Description:
    Transform Octet/char string to base64 wchar_t string
	every 3 characters (24 bit) are transform into 4 wchar_t in base64
	end condition: padd with zero to complete 24 bits (3 octet/char blocks)
	'=' is an extra char in base64 that indicates zero padding.
	1 char at the end (8 bit out of 24) --> '==' padding
	2 char at the end (16 bit out of 24) --> '=' padding
	(more details in the function)

	this function allocate and return the Base64 Buffer
	the caller is responsible to free this buffer

Arguments:
	OctetBuffer - input Octet buffer 
	OctetLen - Length of the Octet buffer (number of byte elements in buffer)
	Base64Len - (out) base64 buffer len (number of WCHAR elements in buffer)

Returned Value:
    wchar_t Base64 buffer

--*/
{
	//
	// Base64 Length - round up OctetLen to multiplies of complete 3 chars
	// each 3 chars will generate 4 base64 chars
	//
	*Base64Len =  ((OctetLen + 2) / 3) * 4;

	//
	// Extra byte for end of string
	//
	LPWSTR Base64Buffer = new WCHAR[*Base64Len+1];
	LPWSTR pBase64Buffer = Base64Buffer;

	//
	// going over complete 3 bytes/chars and transform them to 4 Base64 characters
	//
	int Complete3Chars = OctetLen / 3;

	//
	// Convert each 3 bytes of 8 bits to 4 bytes of 6 bits in base64
	//
	for(int i=0; i< Complete3Chars; ++i, OctetBuffer += 3)
	{
		//
		// Calc 24 bits value - from 3 bytes of 8 bits
		//
		DWORD Temp = ((OctetBuffer[0]) << xFirst8bShift) 
					 + ((OctetBuffer[1]) << xSecond8bShift) 
					 + ((OctetBuffer[2]) << xThird8bShift);

		pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 
	}

	//
	// Handling the remainder - 1/2 chars (not a complete 3 chars)
	//
	int Remainder = OctetLen - Complete3Chars * 3;

	switch(Remainder)
	{
		DWORD Temp;

		//
		// No reminder - all bytes in complete 3 bytes blocks
		//
		case 0:
			break;

		//
		// Only 1 byte left - we will have two 6 bits result and two = padding
		//
		case 1:

			//
			// Calc 24 bits value - from only 1 byte
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift); 

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Third, fourth 6 bits are zero --> = padding
			//
			pBase64Buffer -= 2;
			*pBase64Buffer = L'='; 
			++pBase64Buffer;
			*pBase64Buffer = L'='; 
			++pBase64Buffer;
			break;

		//
		// Only 2 bytes left - we will have three 6 bits result and one = padding
		//
		case 2:

			//
			// Calc 24 bits value - from 2 bytes
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift) 
				   + ((OctetBuffer[1]) << xSecond8bShift);

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Fourth 6 bits are zero --> = padding
			//
			--pBase64Buffer;
			*pBase64Buffer = L'='; 
			++pBase64Buffer;
			break;

		default:
			printf("Error remainder value should never get here \n");
			break;
	}

	//
	// Adding end of string
	//
	Base64Buffer[*Base64Len] = L'\0';
	return(Base64Buffer);
}


LPSTR
Octet2Base64(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	)
/*++

Routine Description:
    Transform Octet/char string to base64 char string
	every 3 characters (24 bit) are transform into 4 chars in base64
	end condition: padd with zero to complete 24 bits (3 octet/char blocks)
	'=' is an extra char in base64 that indicates zero padding.
	1 char at the end (8 bit out of 24) --> '==' padding
	2 char at the end (16 bit out of 24) --> '=' padding
	(more details in the function)

	this function allocate and return the Base64 Buffer
	the caller is responsible to free this buffer

Arguments:
	OctetBuffer - input Octet buffer 
	OctetLen - Length of the Octet buffer (number of byte elements in buffer)
	Base64Len - (out) base64 buffer len (number of WCHAR elements in buffer)

Returned Value:
    char Base64 buffer

--*/
{
	//
	// Base64 Length - round up OctetLen to multiplies of complete 3 chars
	// each 3 chars will generate 4 base64 chars
	//
	*Base64Len =  ((OctetLen + 2) / 3) * 4;

	//
	// Extra byte for end of string
	//
	LPSTR Base64Buffer = new char[*Base64Len+1];
	LPSTR pBase64Buffer = Base64Buffer;

	//
	// going over complete 3 bytes/chars and transform them to 4 Base64 characters
	//
	int Complete3Chars = OctetLen / 3;

	//
	// Convert each 3 bytes of 8 bits to 4 bytes of 6 bits in base64
	//
	for(int i=0; i< Complete3Chars; ++i, OctetBuffer += 3)
	{
		//
		// Calc 24 bits value - from 3 bytes of 8 bits
		//
		DWORD Temp = ((OctetBuffer[0]) << xFirst8bShift) 
					 + ((OctetBuffer[1]) << xSecond8bShift) 
					 + ((OctetBuffer[2]) << xThird8bShift);

		pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 
	}

	//
	// Handling the remainder - 1/2 chars (not a complete 3 chars)
	//
	int Remainder = OctetLen - Complete3Chars * 3;

	switch(Remainder)
	{
		DWORD Temp;

		//
		// No reminder - all bytes in complete 3 bytes blocks
		//
		case 0:
			break;

		//
		// Only 1 byte left - we will have two 6 bits result and two = padding
		//
		case 1:

			//
			// Calc 24 bits value - from only 1 byte
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift); 

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Third, fourth 6 bits are zero --> = padding
			//
			pBase64Buffer -= 2;
			*pBase64Buffer = '='; 
			++pBase64Buffer;
			*pBase64Buffer = '='; 
			++pBase64Buffer;
			break;

		//
		// Only 2 bytes left - we will have three 6 bits result and one = padding
		//
		case 2:

			//
			// Calc 24 bits value - from 2 bytes
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift) 
				   + ((OctetBuffer[1]) << xSecond8bShift);

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Fourth 6 bits are zero --> = padding
			//
			--pBase64Buffer;
			*pBase64Buffer = '='; 
			++pBase64Buffer;
			break;

		default:
			printf("Error remainder value should never get here \n");
			break;
	}

	//
	// Adding end of string
	//
	Base64Buffer[*Base64Len] = '\0';
	return(Base64Buffer);
}


BYTE GetBase64Value(wchar_t Base64CharW)
/*++

Routine Description:
	map Base64 wchar_t to base64 value.
	throw bad_base64 if Base64 char value is not acceptable.

Arguments:
    Base64CharW - (In) base64 wchar_t

Returned Value:
	Base64 value (0-63)
	throw bad_base64 if Base64 char value is not acceptable.

--*/
{
	if((Base64CharW >= TABLE_SIZE(xAscii2Base64)) || (xAscii2Base64[Base64CharW] == 255))
	{
		TrERROR(Xds, "bad base64 - base64 char is illegal %d", Base64CharW);
		throw bad_base64();
	}

	return(xAscii2Base64[Base64CharW]);
}


BYTE* 
Base642OctetW(
	LPCWSTR Base64Buffer, 
	DWORD Base64Len,
	DWORD *OctetLen 
	)
/*++

Routine Description:
    Transform wchar_t base64 string to Octet string
	every 4 wchar_t characters base64 (24 bit) are transform into 3 character
	'=' is an extra char in base64 that indicates zero padding.
	end condition: determinate according to the = padding in base64
	how many chars are at the final 4 base64 chars block
	'=' is an extra char that indicates padding
	no = --> last blocks of 4 base64 chars is full and transform to 3 Octet chars
	'=' --> last blocks of 4 base64 chars contain 3 base64 chars and will generate
			2 Octet chars
	'==' --> last blocks of 4 base64 chars contain 2 base64 chars and will generate
			 1 Octet chars

	this function allocate and return the Octet Buffer
	the caller is responsible to free this buffer

Arguments:
    Base64Buffer - (In) base64 buffer of wchar_t 
	Base64Len - (In) base64 buffer length (number of WCHAR elements in buffer)
	OctetLen - (Out) Length of the Octet buffer (number of byte elements in buffer)

Returned Value:
	Octet Buffer 

--*/
{
	DWORD Complete4Chars = Base64Len / 4;

	//
	// base64 length must be divided by 4 - complete 4 chars blocks
	//
	if((Complete4Chars * 4) != Base64Len)
	{
		TrERROR(Xds, "bad base64 - base64 buffer length %d dont divide by 4", Base64Len);
		throw bad_base64();
	}

	//
	// Calc Octec length
	//
	*OctetLen = Complete4Chars * 3;
	BYTE* OctetBuffer = new BYTE[*OctetLen];

	if(Base64Buffer[Base64Len - 2] == L'=')
	{
		//
		// '==' padding --> only 1 of the last 3 in the char is used
		//
		ASSERT(Base64Buffer[Base64Len - 1] == L'=');
		*OctetLen -= 2;
	}
	else if(Base64Buffer[Base64Len - 1] == L'=')
	{
		//
		// '=' padding --> only 2 of the last 3 char are used
		//
		*OctetLen -= 1;
	}

	BYTE* pOctetBuffer = OctetBuffer;

	//
	// Convert each 4 wchar_t of base64 (6 bits) to 3 Octet bytes of 8 bits
	// note '=' is mapped to 0 so no need to worry about last 4 base64 block
	// they might be extra Octet byte created in the last block
	// but we will ignore them because the correct value of OctetLen
	//
	for(DWORD i=0; i< Complete4Chars; ++i, Base64Buffer += 4)
	{
		//
		// Calc 24 bits value - from 4 bytes of 6 bits
		//
		DWORD Temp = (GetBase64Value(Base64Buffer[0]) << xFirst6bShift) 
				     + (GetBase64Value(Base64Buffer[1]) << xSecond6bShift) 
				     + (GetBase64Value(Base64Buffer[2]) << xThird6bShift) 
				     + (GetBase64Value(Base64Buffer[3]) << xFourth6bShift);

		//
		// Calc first 8 bits
		//
		DWORD Res = ((Temp & xFirst8bChar) >> xFirst8bShift); 
		ASSERT(Res < 256);
		*pOctetBuffer = static_cast<unsigned char>(Res);
		++pOctetBuffer;

		//
		// Calc second 8 bits
		//
		Res = ((Temp & xSecond8bChar) >> xSecond8bShift); 
		ASSERT(Res < 256);
		*pOctetBuffer = static_cast<unsigned char>(Res);
		++pOctetBuffer;

		//
		// Calc third 8 bits
		//
		Res = ((Temp & xThird8bChar) >> xThird8bShift); 
		ASSERT(Res < 256);
		*pOctetBuffer = static_cast<unsigned char>(Res); 
		++pOctetBuffer;
	}

	return(OctetBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\lib\xdsclass.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    XdsClass.cpp

Abstract:
    Xml digital signature Class constructors and other functions

Author:
    Ilan Herbst (ilanh) 12-Mar-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xds.h>
#include "Xdsp.h"

#include "xdsclass.tmh"

//
// CXdsReferenceInput
//

//
//  HashAlgorithm tables
//	We need both unicode (validation code is on unicode)
//  and ansi (creating the signature element is done in ansi)
//
const LPCWSTR xHashAlgorithm2DigestMethodNameW[] = {
	L"http://www.w3.org/2000/02/xmldsig#sha1",
	L"http://www.w3.org/2000/02/xmldsig#md5"
};

const LPCSTR xHashAlgorithm2DigestMethodName[] = {
	"http://www.w3.org/2000/02/xmldsig#sha1",
	"http://www.w3.org/2000/02/xmldsig#md5"
};

const ALG_ID xHashAlgorithm2AlgId[] = {
	CALG_SHA1,
	CALG_MD5
};

C_ASSERT(TABLE_SIZE(xHashAlgorithm2DigestMethodNameW) == TABLE_SIZE(xHashAlgorithm2AlgId));
C_ASSERT(TABLE_SIZE(xHashAlgorithm2DigestMethodName) == TABLE_SIZE(xHashAlgorithm2AlgId));


inline LPCSTR DigestMethodName(CXdsReference::HashAlgorithm HashAlg)
{
	ASSERT((HashAlg >= 0) && (HashAlg < TABLE_SIZE(xHashAlgorithm2DigestMethodName)));
    return(xHashAlgorithm2DigestMethodName[HashAlg]);
}


inline ALG_ID HashAlgId(CXdsReference::HashAlgorithm HashAlg)
{
	ASSERT((HashAlg >= 0) && (HashAlg < TABLE_SIZE(xHashAlgorithm2AlgId)));
    return(xHashAlgorithm2AlgId[HashAlg]);
}


inline LPCSTR DigestMethodName(ALG_ID HashAlgId)
{
	for(DWORD i = 0; i < TABLE_SIZE(xHashAlgorithm2AlgId); ++i)
	{
		if(HashAlgId == xHashAlgorithm2AlgId[i])
		{
			return(xHashAlgorithm2DigestMethodName[i]);
		}
	}

	//
	// dont suppose to get here
	//
	ASSERT(0);
	return(0);
}


CXdsReferenceInput::CXdsReferenceInput(
	HashAlgorithm HashAlg,
	LPCSTR DigestValue,
	LPCSTR Uri,
	LPCSTR Type
	) :
	m_ReferenceData(),
	m_HashAlgId(HashAlgId(HashAlg)),
	m_DigestMethodName(DigestMethodName(HashAlg)),
	m_DigestValue(newstr(DigestValue)),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))
/*++

Routine Description:
	m_ReferenceData empty
	DigestValue must be given

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_DigestValue != 0);
}


CXdsReferenceInput::CXdsReferenceInput(
	const xdsvoid_t& ReferenceData,
	HashAlgorithm HashAlg,
	LPCSTR Uri,
	LPCSTR Type,
	HCRYPTPROV hCsp
	) :
	m_ReferenceData(ReferenceData),
	m_HashAlgId(HashAlgId(HashAlg)),
	m_DigestMethodName(DigestMethodName(HashAlg)),
	m_DigestValue(XdsCalcDataDigest(
					  ReferenceData.Buffer(),
					  ReferenceData.Length(),
					  m_HashAlgId,
					  hCsp
					  )),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))

/*++

Routine Description:
	ReferenceData given for calc DigestValue

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_ReferenceData.Buffer() != 0);
}


CXdsReferenceInput::CXdsReferenceInput(
	ALG_ID AlgId,
	LPCSTR DigestValue,
	LPCSTR Uri,
	LPCSTR Type
	) :
	m_ReferenceData(),
	m_HashAlgId(AlgId),
	m_DigestMethodName(DigestMethodName(AlgId)),
	m_DigestValue(newstr(DigestValue)),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))
/*++

Routine Description:
	m_ReferenceData empty
	DigestValue must be given

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_DigestValue != 0);
}


CXdsReferenceInput::CXdsReferenceInput(
	const xdsvoid_t& ReferenceData,
	ALG_ID AlgId,
	LPCSTR Uri,
	LPCSTR Type,
	HCRYPTPROV hCsp
	) :
	m_ReferenceData(ReferenceData),
	m_HashAlgId(AlgId),
	m_DigestMethodName(DigestMethodName(AlgId)),
	m_DigestValue(XdsCalcDataDigest(
					  ReferenceData.Buffer(),
					  ReferenceData.Length(),
					  m_HashAlgId,
					  hCsp
					  )),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))

/*++

Routine Description:
	ReferenceData given for calc DigestValue

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_ReferenceData.Buffer() != 0);
}


//
// CXdsReferenceValidateInfo
//

ALG_ID HashAlgId(xwcs_t DigestMethodName)
{
	for(DWORD i = 0; i < TABLE_SIZE(xHashAlgorithm2DigestMethodNameW); ++i)
	{
		if(DigestMethodName == xHashAlgorithm2DigestMethodNameW[i])
		{
			return(xHashAlgorithm2AlgId[i]);
		}
	}

	//
	// should not get here
	//
	TrERROR(Xds, "Bad Xmldsig element - did not support mapping DigestMethodName %.*ls to AlgId", LOG_XWCS(DigestMethodName));
	throw bad_XmldsigElement();

}

	
CXdsReferenceValidateInfo::CXdsReferenceValidateInfo(
	xwcs_t Uri,
	xwcs_t DigestMethodName,
	xwcs_t DigestValue
	) :
	m_Uri(Uri),
	m_DigestValue(DigestValue),
	m_ReferenceData(),
	m_HashAlgId(::HashAlgId(DigestMethodName))
{
}


CXdsReferenceValidateInfo::CXdsReferenceValidateInfo(
	xwcs_t Uri,
	xwcs_t DigestMethodName,
	xwcs_t DigestValue,
	const xdsvoid_t& ReferenceData
	) :
	m_Uri(Uri),
	m_DigestValue(DigestValue),
	m_ReferenceData(ReferenceData),
	m_HashAlgId(::HashAlgId(DigestMethodName))
{
}


inline LPCSTR SignatureMethodName(CXdsSignedInfo::SignatureAlgorithm SignatureAlg)
{
	ASSERT((SignatureAlg >= 0) && (SignatureAlg < TABLE_SIZE(xSignatureAlgorithm2SignatureMethodName)));
    return(xSignatureAlgorithm2SignatureMethodName[SignatureAlg]);
}


inline ALG_ID SignatureAlgId(CXdsSignedInfo::SignatureAlgorithm SignatureAlg)
{
	ASSERT((SignatureAlg >= 0) && (SignatureAlg < TABLE_SIZE(xSignatureAlgorithm2AlgId)));
	return(xSignatureAlgorithm2AlgId[SignatureAlg]);
}


CXdsSignedInfo::CXdsSignedInfo(
	SignatureAlgorithm SignatureAlg,
	LPCSTR Id,
	std::vector<CXdsReferenceInput*>& ReferenceInputs
	):
	m_SignatureMethodName(SignatureMethodName(SignatureAlg)),
	m_SignatureAlgId(::SignatureAlgId(SignatureAlg)),
	m_Id(newstr(Id)),
	m_ReferenceInputs(ReferenceInputs)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\lib\xds.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    xds.cpp

Abstract:
    Xml digital signature functions

Author:
    Ilan Herbst (ilanh) 28-Feb-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xds.h>
#include "Xdsp.h"
#include <utf8.h>

#include "xds.tmh"


LPSTR
XdsCalcDataDigest(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Calc data digest base64 on a buffer
	this function return the DataDigest Buffer (this buffer is allocated by GetHashData function)
	the caller is responsible to free this buffer

Arguments:
    Data - input data to digest (WCHAR)
    DataLen - number of data elements
	AlgId - hash algorithm
	hCsp - crypto provider handle

Returned Value:
	String of the Hash buffer in base64 format

--*/
{
	//
	// Data digest
	//
	ASSERT(Data != 0);
	DWORD HashLen;
	AP<BYTE> HashBuffer = CryCalcHash(
							  hCsp,
							  reinterpret_cast<const BYTE *>(Data), 
							  DataLen,
							  AlgId,
							  &HashLen
							  );

	//
	// Convert digest string to base64 format
	//
	DWORD DataHashLen;
	LPSTR HashBase64 = Octet2Base64(HashBuffer, HashLen, &DataHashLen);

	return(HashBase64);
}


LPWSTR
XdsCalcDataDigestW(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Calc data digest base64 on a buffer
	this function return the DataDigest Buffer (this buffer is allocated by GetHashData function)
	the caller is responsible to free this buffer

Arguments:
    Data - input data to digest (WCHAR)
    DataLen - number of data elements
	AlgId - hash algorithm
	hCsp - crypto provider handle

Returned Value:
	WString of the Hash buffer in base64 format

--*/
{
	//
	// Data digest
	//
	ASSERT(Data != 0);
	DWORD HashLen;
	AP<BYTE> HashBuffer = CryCalcHash(
							  hCsp,
							  reinterpret_cast<const BYTE *>(Data), 
							  DataLen,
							  AlgId,
							  &HashLen
							  );

	//
	// Convert digest string to base64 format
	//
	DWORD DataHashLen;
	LPWSTR HashBase64 = Octet2Base64W(HashBuffer, HashLen, &DataHashLen);

	return(HashBase64);
}


LPSTR
XdsGetDataDigest(
	HCRYPTHASH hHash
	)
/*++

Routine Description:
	Get data digest base64 on a hash
	this function return the DataDigest Buffer (this buffer is allocated by GetHashData function)
	the caller is responsible to free this buffer

Arguments:
    hHash - input hash (hash object on data)

Returned Value:
	String of the Hash buffer in base64 format

--*/
{
	//
	// Data digest
	//
	ASSERT(hHash != 0);
	DWORD HashLen;
	AP<BYTE> HashBuffer = CryGetHashData(
							  hHash, 
							  &HashLen
							  );

	//
	// Convert digest string to base64 format
	//
	DWORD DataHashLen;
	LPSTR HashBase64 = Octet2Base64(HashBuffer, HashLen, &DataHashLen);

	return(HashBase64);
}


LPSTR
XdsCalcSignature(
	LPCSTR Data,
	DWORD DataLen,
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Calc signature on given data
	this function return the Signature Buffer that was allocated by CreateSignature function
	the caller is responsible to free this buffer

Arguments:
    Data - data to be signed (WCHAR)
    DataLen - number of data elements
	AlgId - hash algorithm
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	hCsp - crypto provider handle

Returned Value:
	String buffer of the signature in base64 format

--*/
{

	//
	// Sign Data
	//
	DWORD SignatureLen;
	AP<BYTE> SignBuffer = CryCreateSignature(
							  hCsp,
							  reinterpret_cast<const BYTE*>(Data), 
							  DataLen,
							  AlgId,
							  PrivateKeySpec,
							  &SignatureLen
							  );

	//
	// Convert signature string to base64 format
	//
	DWORD SignLen;
	LPSTR SignatureBase64 = Octet2Base64(SignBuffer, SignatureLen, &SignLen);

	return(SignatureBase64);
}


void
XdsValidateSignature(
	const XmlNode* pSignatureTree,
	HCRYPTKEY hKey,
	HCRYPTPROV hCsp
    )
/*++

Routine Description:
	Validate signature in parsed SignatureTree.
	If validation failed throw bad_signature() exception.
	If bad signature Element throw bad_XmldsigElement().

Arguments:
	pSignatureTree - pointer to the <Signature> (root)
	hKey - the public key corresponding to the private key that was used to signed the signature
	hCsp - crypto provider handle

Returned Value:
	Throw bad_signature() if validation failed, if validation was successfull normal termination
	Throw bad_XmldsigElement() if the Xmldsig Element is not ok
--*/
{
	//
	// Find SignedInfo Element in the signature tree
	//
	const XmlNode* pSignedInfoNode = XmlFindNode(
										 pSignatureTree, 
										 L"Signature!SignedInfo"
										 );

	if(pSignedInfoNode == NULL)
	{
		TrERROR(Xds, "bad Xmldsig element - SignedInfo element in signatre was not found");
		throw bad_XmldsigElement();
	}

	ALG_ID AlgId = 0;

	//
	// Elements in SignedInfo
	//
	const List<XmlNode>& SignedInfoNodeList = pSignedInfoNode->m_nodes;

	for(List<XmlNode>::iterator SignedInfoSubNode = SignedInfoNodeList.begin(); 
		SignedInfoSubNode != SignedInfoNodeList.end();
		++SignedInfoSubNode
		)
	{
		//
		// CanonicalizationMethod Element
		//
		if(SignedInfoSubNode->m_tag == L"CanonicalizationMethod")
		{
			//
			// BUGBUG: Dont handle CanonicalizationMethod yet
			//
			ASSERT(0);
		}

		//
		// SignatureMethod Element
		//
		if(SignedInfoSubNode->m_tag == L"SignatureMethod")
		{
			const xwcs_t* value = XmlGetAttributeValue(
									  &*SignedInfoSubNode, 
									  L"Algorithm"
									  );

			if(!value)
			{
				TrERROR(Xds, "bad Xmldsig Element - no Algorithm attribute was found in SignatureMethod element");
				throw bad_XmldsigElement();
			}

			//
			// Searching all possible names 
			//
			for(DWORD i = 0; i < TABLE_SIZE(xSignatureAlgorithm2SignatureMethodNameW); ++i)
			{
				if(*value == xSignatureAlgorithm2SignatureMethodNameW[i])
				{
					AlgId = xSignatureAlgorithm2AlgId[i]; // CALG_SHA1
				}
			}

			if(AlgId == 0)
			{
				TrERROR(Xds, "Bad Xmldsig Signature Algorithm %.*ls", LOG_XWCS(*value));
				throw bad_XmldsigElement();
			}
		}
	}

	//
	// Must have AlgId
	//
	if(AlgId == 0)
	{
		TrERROR(Xds, "bad XmldsigElement - did not find SignatureMethod");
		throw bad_XmldsigElement();
	}

	const XmlNode* pSignatureValueNode = XmlFindNode(
											 pSignatureTree, 
											 L"Signature!SignatureValue"
											 );

	if(pSignatureValueNode == NULL)
	{
		TrERROR(Xds, "bad XmldsigElement - did not found SignatureValue element in the signature");
		throw bad_XmldsigElement();
	}

	//
	// Convert the WCHAR base64 buffer to Octet buffer this is done because the signature result
	// is an Octet buffer that was latter transform to WCHAR base64 and was put in the SignatureValue element
	//
	DWORD SignValLen;
	AP<BYTE> SignValBuffer = Base642OctetW(
							     pSignatureValueNode->m_values.front().m_value.Buffer(), 
							     pSignatureValueNode->m_values.front().m_value.Length(), 
							     &SignValLen
							     );

	//
	// Convert the SignedInfo element to utf8 for validation
	// We must to this conversion because the signature was calculated on the utf8 format of SignedInfo element.
	//
	utf8_str pSignedInfoUtf8 = UtlWcsToUtf8(pSignedInfoNode->m_element.Buffer(), pSignedInfoNode->m_element.Length()); 

	//
	// Validate signature
	//
	bool fValidSignature = CryValidateSignature(
							   hCsp,
							   SignValBuffer, // Signature Value
							   SignValLen, 
							   pSignedInfoUtf8.data(), 
							   numeric_cast<DWORD>(pSignedInfoUtf8.size()),  // length of the data that was signed
							   AlgId,
							   hKey
							   );

	if(fValidSignature)
		return;

	TrERROR(Xds, "bad Signature Validation");
	throw bad_signature();
}


void
XdsValidateReference(
	const CXdsReferenceValidateInfo& ReferenceValidateInfo,
	HCRYPTPROV hCsp
    )
/*++

Routine Description:
	Validate reference in Xmldsig.
	If validation failed throw bad_reference() exception.

Arguments:
	ReferenceValidateInfo - Information for reference validation
	hCsp - crypto provider handle

Returned Value:
	Throw bad_reference() if validation failed, if validation was successfull normal termination

--*/
{
	//
	// Calc Digest Value on Reference data
	//
	ASSERT(ReferenceValidateInfo.ReferenceData().Buffer() != NULL);

	AP<WCHAR> VerifyDigestValue = XdsCalcDataDigestW(
								      ReferenceValidateInfo.ReferenceData().Buffer(),
								      ReferenceValidateInfo.ReferenceData().Length(),
								      ReferenceValidateInfo.HashAlgId(),
								      hCsp 
								      );

	//
	// Check for identical Hash values, xstr operator ==
	//
	bool fVerifyDigest = (ReferenceValidateInfo.DigestValue() == VerifyDigestValue);

	if(fVerifyDigest)
		return;

	TrERROR(Xds, "bad Refernce Validation");
	throw bad_reference();
}


ReferenceValidateVectorType
XdsGetReferenceValidateInfoVector(
	const XmlNode* pSignatureTree
    )
/*++

Routine Description:
	Get vector of pointers to CXdsReferenceValidateInfo from SignatureTree
	If bad signature Element throw bad_XmldsigElement().

Arguments:
    pSignatureTree - pointer to Signature root node

Returned Value:
	Vector of pointers to CXdsReferenceValidateInfo
	If bad signature Element throw bad_XmldsigElement().

--*/
{
	//
	// Find SignedInfo Element in the signature tree
	//
	const XmlNode* pSignedInfoNode = XmlFindNode(
										 pSignatureTree, 
										 L"Signature!SignedInfo"
										 );
	if(pSignedInfoNode == NULL)
	{
		TrERROR(Xds, "bad Xmldsig element - SignedInfo element in signatre was not found");
		throw bad_XmldsigElement();
	}

	ReferenceValidateVectorType ReferenceValidateVector;

	//
	// to free ReferenceValidateVector in case of exception we use the try block
	// 
	try
	{
		//
		// Creating Reference Validate Information
		//
		const List<XmlNode>& SignedInfoNodeList = pSignedInfoNode->m_nodes;

		for(List<XmlNode>::iterator SignedInfoSubNode = SignedInfoNodeList.begin(); 
			SignedInfoSubNode != SignedInfoNodeList.end();
			++SignedInfoSubNode
			)
		{
			if(SignedInfoSubNode->m_tag != L"Reference")
				continue;

			//
			// Handle Reference Elements only
			//

			const XmlNode* pRefNode = &*SignedInfoSubNode;

			//
			// Find Uri Attribute in Reference Element
			//
			const xwcs_t* pUri = XmlGetAttributeValue(
									 pRefNode, 
									 L"URI"
									 );
			
			if(pUri == NULL)
			{
				TrERROR(Xds, "bad Xmldsig element - URI element in Reference Element was not found");
				throw bad_XmldsigElement();
			}

			//
			// Find HashValue, DigestMethod Elements in Reference Element
			//
			const xwcs_t* pDigestValue = 0;
			const xwcs_t* pDigestMethod = 0;

			const List<XmlNode>& RefNodeList = pRefNode->m_nodes;

			for(List<XmlNode>::iterator RefSubNode = RefNodeList.begin(); 
				RefSubNode != RefNodeList.end();
				++RefSubNode
				)
			{
				if(RefSubNode->m_tag == L"Transforms")
				{
					//
					// Dont handle transforms
					//
					ASSERT(("", 0));
				}
				else if(RefSubNode->m_tag == L"DigestValue")
				{
					pDigestValue = &RefSubNode->m_values.front().m_value;
				}
				else if(RefSubNode->m_tag == L"DigestMethod")
				{
					pDigestMethod = XmlGetAttributeValue(
										&*RefSubNode, 
										L"Algorithm"
										);
				}
			}

			if(pDigestValue == NULL)
			{
				TrERROR(Xds, "bad Xmldsig element - DigestValue element in Reference Element was not found");
				throw bad_XmldsigElement();
			}
			if(pDigestMethod == NULL)
			{
				TrERROR(Xds, "bad Xmldsig element - DigestMethod element in Reference Element was not found");
				throw bad_XmldsigElement();
			}

			CXdsReferenceValidateInfo* pRefInfo = new CXdsReferenceValidateInfo(
														  *pUri,
														  *pDigestMethod,
														  *pDigestValue
					 									  );

			//
			// Insert to Vector
			//
			ReferenceValidateVector.push_back(pRefInfo);
		}

	}
	catch(const exception&)
	{
		//
		// Some exception occur, Free ReferenceValidateVector
		//
		for(ReferenceValidateVectorType::iterator ir = ReferenceValidateVector.begin(); 
			ir != ReferenceValidateVector.end();)
		{
			CXdsReferenceValidateInfo* pReferenceValidateInfo = *ir;
			ir = ReferenceValidateVector.erase(ir);
			delete pReferenceValidateInfo;
		}

		throw;
	}

	return(ReferenceValidateVector);
}


std::vector<bool>
XdsValidateAllReference(
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    )
/*++

Routine Description:
	Validate all reference in the ReferenceValidateInfoVector

Arguments:
    ReferenceValidateInfoVector - Vector of pointer to validate info for each reference 
	hCsp - crypto provider handle

Returned Value:
	Vector of bool containing the reference validation result
	the vector size is the number of references
	for each reference a bool value: 1 = validation is correct
									 0 = validation failed

--*/
{
	std::vector<bool> RefValidateResult;

	//
	// Validating each reference in the vector
	//
	for(ReferenceValidateVectorType::const_iterator ir = ReferenceValidateInfoVector.begin();
		ir != ReferenceValidateInfoVector.end();
		++ir
		)
	{
		//
		// Reference Validation, Reference inside the doc
		//
		try
		{
			XdsValidateReference(
				**ir,
				hCsp
				);

			//
			// Reference Validation ok
			//
			RefValidateResult.push_back(true);
		}
		catch (const bad_reference&)
		{
			//
			// Reference Validation failed
			//
			RefValidateResult.push_back(false);
		}
	}

	return(RefValidateResult);
}


void
XdsCoreValidation(
	const XmlNode* pSignatureNode,
	HCRYPTKEY hKey,
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    ) 
/*++

Routine Description:
	Perform CoreValidation on xml digital signature
	core validation is true if signature validation it true
	and each of the reference validation is true

	If validation failed throw bad_signature() or bad_reference() exception.
	depend on which part of the core validation failed.

Arguments:
	pSignatureNode - pointer to the SignatureNode (signature root)
	hKey - the public key from the corresponding to the private key that was used to signed the signature
	ReferenceValidateInfoVector -  Vector of pointer to validate info for each reference  
	hCsp - crypto provider handle

Returned Value:
	Throw bad_signature() or bad_reference() if validation failed, 
	if validation was successfull normal termination

--*/
{

	//
	// Signature Validation
	//
	XdsValidateSignature(
		pSignatureNode,
		hKey,
		hCsp
		);

	//
	// Reference Vector Validation
	//
	for(ReferenceValidateVectorType::const_iterator ir = ReferenceValidateInfoVector.begin();
		ir != ReferenceValidateInfoVector.end(); 
		++ir
		)
	{
		XdsValidateReference(
			**ir,
			hCsp
			);

	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\lib\xdsdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XdsDebug.cpp

Abstract:
    Xml Digital Signature debugging

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Xds.h"
#include "Xdsp.h"

#include "xdsdebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Validate Xml Digital Signature state
//
void XdspAssertValid(void)
{
    //
    // XdsInitalize() has *not* been called. You should initialize the
    // Xml Digital Signature library before using any of its funcionality.
    //
    ASSERT(XdspIsInitialized());

    //
    // TODO:Add more Xml Digital Signature validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void XdspSetInitialized(void)
{
    LONG fXdsAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Xml Digital Signature library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fXdsAlreadyInitialized);
}


BOOL XdspIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Xds,

    //
    // TODO: Add Xml Digital Signature sub-component trace ID's to be used with TrXXXX.
    // For example, XdsInit, as used in:
    // TrERROR(XdsInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "XdsDumpState(queue path name)",
        "Dump Xml Digital Signature State to debugger",
        DumpState
    ),

    //
    // TODO: Add Xml Digital Signature debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void XdspRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\lib\xdsinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XdsInit.cpp

Abstract:
    Xml Digital Signature initialization

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Xds.h"
#include "Xdsp.h"

#include "xdsinit.tmh"

VOID
XdsInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Xml Digital Signature library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Xml Digital Signature library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!XdspIsInitialized());
    XdspRegisterComponent();

    //
    // TODO: Write Xml Digital Signature initalization code here
    //

    XdspSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\lib\xdselements.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    xdsElements.cpp

Abstract:
    Xml digital signature functions for operators << of the signature elements 

Author:
    Ilan Herbst (ilanh) 28-Feb-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xds.h>
#include "Xdsp.h"

#include "xdselements.tmh"

using std::ostringstream;
using std::ostream;
using std::string;

//
// xEndLine: >
//
LPCSTR xEndLine = ">";

//
// xQEndLine: ">
//
LPCSTR xQEndLine = "\">";


ostream& operator<<(std::ostream& os, const CXdsReferenceInput& ReferenceInput)

/*++

Routine Description:
	Add Reference Element in XmlDsig to ostringstream
	according to RefElementInfo

Arguments:
    os - wstring stream that will be updated
	ReferenceInput - Reference element information

Returned Value:
	ostringstream with the Reference element

--*/
{
	//
	// Reference element
	//
	os << "<Reference URI=\"";
	os << static_cast<LPCSTR>(ReferenceInput.m_Uri);

	//
	// Type (optional)
	//
	if(ReferenceInput.m_Type)
	{
		os << "\" Type=\"";
		os << static_cast<LPCSTR>(ReferenceInput.m_Type);
	}

	os << xQEndLine;

	//
	// DigestMethod Element
	//
	os << "<DigestMethod Algorithm=\"";
	os << ReferenceInput.m_DigestMethodName;
	os << xQEndLine;
	os << "</DigestMethod>";

	//
	// DigestValue Element
	//
	ASSERT(ReferenceInput.m_DigestValue != 0);

	os << "<DigestValue>";
	os << static_cast<LPCSTR>(ReferenceInput.m_DigestValue);
	os << "</DigestValue>";

	//
	// Close Reference element
	//
	os << "</Reference>";

	return(os);
}


ostream& operator<<(std::ostream& os, const CXdsSignedInfo& SignedInfo)

/*++

Routine Description:
	Add SignedInfo Element in XmlDsig to ostringstream
	according to SignedInfo

Arguments:
    os - string stream that will be updated
	SignedInfo - SignedInfo element information

Returned Value:
	ostringstream with the SignedInfo element

--*/
{
	//
	// SignedInfo element
	//
	os << "<SignedInfo";

	//
	// m_Id (optional)
	//
	if(SignedInfo.m_Id)
	{
		os << " Id=\"";
		os << static_cast<LPCSTR>(SignedInfo.m_Id);
		os << "\"";
	}

	os << xEndLine;

	//
	// SignatureMethod
	//
	os << "<SignatureMethod Algorithm=\"";
	os << SignedInfo.m_SignatureMethodName << xQEndLine;
	os << "</SignatureMethod>";

	//
	// References
	//
	for(ReferenceInputVectorType::const_iterator it = SignedInfo.m_ReferenceInputs.begin(); 
			it != SignedInfo.m_ReferenceInputs.end(); 
			++it
			)
	{
		os << **it;
	}

	//
	// Close SignedInfo element
	//
	os << "</SignedInfo>";
	return(os);
}


ostringstream& operator<<(ostringstream& oss, const CXdsSignature& Signature)
/*++

Routine Description:
	Add Signature Element (XmlDsig) to ostringstream

	Note: If you need to detach string from ostringstream (this operation freeze the ostringstream)
		  and latter unfreeze the ostringstream 
	      this function is an example how to do this

	This Function calc the SignatureValue on the SignedInfo Element

Arguments:
    oss - string stream that will be updated
	Signature - Signature element information

Returned Value:
	ostringstream with the Signature element

--*/
{
	//
	// Signature element
	//
	oss << "<Signature xmlns=\"http://www.w3.org/2000/02/xmldsig#";
	oss << "\"";

	//
	// m_Id (optional)
	//
	if(Signature.m_Id)
	{
		//
		// Closing " xmlns "
		//
		oss << " Id=\"";
		oss << static_cast<LPCSTR>(Signature.m_Id);
		oss << "\"";

	}

	//
	// 4 white spaces at the beginning of SignedInfo, might be in SignedInfo function
	//
	oss << xEndLine;

	size_t SignedInfoStart = oss.str().size();

	//
	// SignedInfo element
	//
	oss << Signature.m_SignedInfo;

	size_t SignedInfoEnd = oss.str().size();

	//
	// SignatureValue
	//
	oss << "<SignatureValue>";

	if(Signature.m_SignatureValue)
	{
		oss << static_cast<LPCSTR>(Signature.m_SignatureValue);
	}
	else
	{
		//
		// BUGBUG: did not handle the canonalization transforms on SignedInfo
		//

		//
		// Signature Value on SignedInfoElement including start and end tag
		//
		string TempStr = oss.str();

		ASSERT((SignedInfoEnd - SignedInfoStart) < ULONG_MAX);

		AP<char> SignatureValue = XdsCalcSignature(
										 TempStr.data() + SignedInfoStart, // SignedInfo start
										 static_cast<DWORD>(SignedInfoEnd - SignedInfoStart),   // SignedInfo len
										 Signature.SignatureAlgId(),
										 Signature.m_PrivateKeySpec,
										 Signature.m_hCsp
										 );	

		oss << static_cast<LPCSTR>(SignatureValue);
	}

	oss << "</SignatureValue>";

	//
	// Optional KeyInfo 
	//
	if(Signature.m_KeyValue)
	{
		oss << "<KeyInfo>";
		oss << "<KeyValue>";
		oss << static_cast<LPCSTR>(Signature.m_KeyValue);
		oss << "</KeyValue>";
		oss << "</KeyInfo>";
	}

	//
	// Close Signature element
	//
	oss << "</Signature>";
	return(oss);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\lib\xdsp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xdsp.h

Abstract:
    Xml Digital Signature private functions.

Author:
    Ilan Herbst (ilanh) 06-Mar-00

--*/

#pragma once

const TraceIdEntry Xds = L"Xml Digital Signature";

#ifdef _DEBUG

void XdspAssertValid(void);
void XdspSetInitialized(void);
BOOL XdspIsInitialized(void);
void XdspRegisterComponent(void);

#else // _DEBUG

#define XdspAssertValid() ((void)0)
#define XdspSetInitialized() ((void)0)
#define XdspIsInitialized() TRUE
#define XdspRegisterComponent() ((void)0)

#endif // _DEBUG

//
//  SignatureAlgorithm tables
//	We need both unicode (validation code is on unicode)
//  and ansi (creating the signature element is done in ansi)
//
const LPCWSTR xSignatureAlgorithm2SignatureMethodNameW[] = {
	L"http://www.w3.org/2000/02/xmldsig#dsa"
};

const LPCSTR xSignatureAlgorithm2SignatureMethodName[] = {
	"http://www.w3.org/2000/02/xmldsig#dsa"
};

const ALG_ID xSignatureAlgorithm2AlgId[] = {
	CALG_SHA1
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\test\xdstest.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    XdsTest.cpp

Abstract:
    Xml Digital Signature library test

	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n"


Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Xds.h"
#include "Cry.h"
#include "xml.h"
#include "xstr.h"
#include <utf8.h>

#include "XdsTest.tmh"

const TraceIdEntry XdsTest = L"Xds Test";

//
// Ref1 data object
//
const LPCWSTR xRef1Data = 
	L"        <ReferenceObject1 ID=\"Ref1Id\">\r\n"
	L"            <Ref1Data>\r\n"
	L"                This Is Reference Number 1\r\n" 
	L"                msmq3 Reference test\r\n" 
	L"            </Ref1Data>\r\n"
	L"        </ReferenceObject1>\r\n";

//
// Ref2 data object
//
const LPCWSTR xRef2Data = 
	L"        <ReferenceObject2 ID=\"Ref2Id\">\r\n"
	L"            <Ref2Data>\r\n"
	L"                This Is Reference Number 2\r\n" 
	L"                the date is 9.3.2000\r\n" 
	L"            </Ref2Data>\r\n"
	L"        </ReferenceObject2>\r\n";

//
// Ref3 data object
//
const LPCWSTR xRef3Data = 
	L"        <ReferenceObject3 ID=\"Ref3Id\">\r\n"
	L"            <Ref3Data>\r\n"
	L"                This Is Reference Number 3\r\n" 
	L"                the day is thursday\r\n" 
	L"            </Ref3Data>\r\n"
	L"        </ReferenceObject3>\r\n";

//
// Ref4 data object
//
const LPCWSTR xRef4Data = 
	L"        <ReferenceObject4 ID=\"Ref4Id\">\r\n"
	L"            <Ref4Data>\r\n"
	L"                This Is Reference Number 4\r\n" 
	L"                Hello World\r\n" 
	L"            </Ref4Data>\r\n"
	L"        </ReferenceObject4>\r\n";


//
// Usage
//
const char xOptionSymbol1 = '-';
const char xOptionSymbol2 = '/';

const char xUsageText[] =
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n";

inline
void 
DumpUsageText( 
	void 
	)
{
	printf( "%s\n" , xUsageText );
}


DWORD g_PrivateKeySpec = AT_SIGNATURE;
BOOL g_fErrorneous = false;


void SetActivation( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments.

Arguments:
    main's command line arguments.

Returned Value:

proper command line syntax:
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n"
--*/
{
	
	if(argc == 1)
	{
		printf("Test AT_SIGNATURE Private Key\n");
		return;
	}

	for(int index = 1; index < argc; index++)
	{
		if((argv[index][0] != xOptionSymbol1) && (argv[index][0] != xOptionSymbol2))	
		{
			TrERROR(XdsTest, "invalid option switch %lc, option switch should be - or /", argv[index][0]);
			g_fErrorneous = true;
			continue;
		}

		//
		// consider argument as option and switch upon its second (sometimes also third) character.
		//
		switch(argv[index][1])
		{
			case 's':
			case 'S':
				g_PrivateKeySpec = AT_SIGNATURE;
				printf("Test AT_SIGNATURE Private Key\n");
				break;

			case 'x':
			case 'X':	
				g_PrivateKeySpec = AT_KEYEXCHANGE;
				printf("Test AT_KEYEXCHANGE Private Key\n");
				break;

			case 'H':	
			case 'h':
			case '?':
				g_fErrorneous = true;
				break;

			default:
				TrERROR(XdsTest, "invalid command line argument %ls", argv[index]);
				g_fErrorneous = true;
				return;
		};
	}

	return;
}



LPSTR TestCreateSignature(DWORD PrivateKeySpec, HCRYPTPROV hCsp)
/*++

Routine Description:
	Test create signature element functions
	This is an example what is need to be done in order to create signature
	This simulate the sender side

Arguments:
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	hCsp - crypto provider handle

Returned Value:
	Signature Element string

--*/
{
	//
	// First Signature Example
	//

	//
	// Test Building Signature Element from a given references
	// some of the references are internal - so data digest on them
	// is done.
	// some of the references are external and their data is not available
	// in this case must supply digest value

	//
	// Initialize References Information
	//


	CXdsReferenceInput::HashAlgorithm DigestMethod = CXdsReferenceInput::haSha1;
	//
	// Ref1 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference1Data(xRef1Data, wcslen(xRef1Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef1 = new CXdsReferenceInput(
										  Reference1Data,				
										  DigestMethod,
										  "#Ref1Id",
										  NULL /* Type */,
										  hCsp
										  );
	//
	// Ref2 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference2Data(xRef2Data, wcslen(xRef2Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef2 = new CXdsReferenceInput(
										  Reference2Data,				
										  DigestMethod,
										  "#Ref2Id",
										  NULL /* Type */,
										  hCsp
										  );
	//
	// Ref3 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference3Data(xRef3Data, wcslen(xRef3Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef3 = new CXdsReferenceInput(
										  Reference3Data,				
										  DigestMethod,
										  "#Ref3Id",
										  NULL /* Type */,
										  hCsp
										  );

	//
	// Ref4 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference4Data(xRef4Data, wcslen(xRef4Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef4 = new CXdsReferenceInput(
										  Reference4Data,				
										  DigestMethod,
										  "#Ref4Id",
										  NULL /* Type */,
										  hCsp
										  );
	//
	// Ref5 - External reference
	//			RefData is not given
	//			DigestValue is given
	//
	P<CXdsReferenceInput> pRef5 = new CXdsReferenceInput(
										  DigestMethod,
										  "j6lwx3rvEPO0vKtMup4NbeVu8nk=",
										  "#Ref5Id",
										  NULL /* Type */
										  );


	//
	// Create pReferenceInputs vector
	//
	ReferenceInputVectorType pReferenceInputs;

	pReferenceInputs.push_back(pRef1);
	pReferenceInputs.push_back(pRef4);
//	pReferenceInputs.push_back(pRef5);
	pReferenceInputs.push_back(pRef2);
	pReferenceInputs.push_back(pRef3);

	pRef1.detach();
	pRef2.detach();
	pRef3.detach();
	pRef4.detach();
//	pRef5.detach();
	
	CXdsSignedInfo::SignatureAlgorithm SignatureAlg = CXdsSignedInfo::saDsa;

	CXdsSignature SignatureInfoEx(
					  SignatureAlg,
					  "SignatureExample", /* SignedInfo Id */
					  pReferenceInputs,
					  NULL, // L"RunTime Signature", /* Signature Id */
					  hCsp,
					  PrivateKeySpec,
					  NULL /* KeyValue */
					  );

	LPSTR SignatureElementEx = SignatureInfoEx.SignatureElement();

	printf("\n%s\n", SignatureElementEx);

	return(SignatureElementEx);
}


void 
TestValidation(
	LPCSTR SignatureElementEx, 
	HCRYPTKEY hKey, 
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Test the validation of Xml signature element
	This simulate the reciever side

Arguments:
	SignatureElementEx - Signature Element string 
	hKey - Signer public key 
	hCsp - crypto provider handle

Returned Value:
	None.

--*/
{

	//
	// Convert to signature element from utf8 - Unicode.
	// The xml parser support only unicode buffers
	//
	size_t SignatureWSize;
	AP<WCHAR> pSignatureW = UtlUtf8ToWcs(reinterpret_cast<const BYTE*>(SignatureElementEx), strlen(SignatureElementEx),  &SignatureWSize);

	printf("SignatureW \n%.*ls\n", numeric_cast<DWORD>(SignatureWSize), pSignatureW);

	//
	// Parsing signature element
	//
	CAutoXmlNode SignatureTree;
	XmlParseDocument(xwcs_t(pSignatureW, numeric_cast<DWORD>(SignatureWSize)), &SignatureTree );
	XmlDumpTree(SignatureTree);

	//
	// Test Signature Validation on SignatureTree that was just created
	// note that the second parameter is the signer public key of the user that signed the signature
	//
	try
	{
		XdsValidateSignature(
			SignatureTree, 
			hKey, 
			hCsp
			);
		
		//
		// Normal termination --> Validation ok
		//
		printf("Signature Validation OK\n");
	}
	catch (const bad_signature&)
	{
		//
		// XdsValidateSignature throw excption --> Validation fail
		//
		printf("Signature Validation Failed - bad_signature excption\n");
	}

	//
	// Get reference vector from the SignatureTree
	//
	CReferenceValidateVectorTypeHelper ReferenceValidateVector = XdsGetReferenceValidateInfoVector(
																	 SignatureTree
																	 );
	//
	// Fill ReferenceData in the ReferenceValidateVector found in the signature
	//
	for(ReferenceValidateVectorType::iterator ir = ReferenceValidateVector->begin(); 
		ir != ReferenceValidateVector->end(); ++ir)
	{
		printf("Uri '%.*ls'\n", LOG_XWCS((*ir)->Uri()));

		//
		// Get ReferenceData according to Uri or some other mechanism
		// this need to be decided
		//
		xdsvoid_t ReferenceData;
		if((*ir)->Uri() == L"#Ref1Id")
		{
			ReferenceData = xdsvoid_t(xRef1Data, wcslen(xRef1Data) * sizeof(WCHAR));
		}
		else if((*ir)->Uri() == L"#Ref2Id")
		{
			ReferenceData = xdsvoid_t(xRef2Data, wcslen(xRef2Data) * sizeof(WCHAR));
		}
		else if((*ir)->Uri() == L"#Ref3Id")
		{
			ReferenceData = xdsvoid_t(xRef3Data, wcslen(xRef3Data) * sizeof(WCHAR));
		}
		else if((*ir)->Uri() == L"#Ref4Id")
		{
			ReferenceData = xdsvoid_t(xRef4Data, wcslen(xRef4Data) * sizeof(WCHAR));
		}
		else
		{
			//
			// If we dont know we fill an empty ReferenceData
			//
			ASSERT(0);
		}

		//
		// Set the pReferenceData in the ReferenceValidateVector
		//
		(*ir)->SetReferenceData(ReferenceData);

		printf("AlgId %d\n", (*ir)->HashAlgId());
		printf("DigestValue '%.*ls'\n", LOG_XWCS((*ir)->DigestValue()));
	}

	printf("CALG_SHA1 = %d\n", CALG_SHA1);

	//
	// Test reference validation - vector of validation values
	//
	std::vector<bool> RefValidateResult = XdsValidateAllReference(
											  *ReferenceValidateVector,	    
											  hCsp
											  );
	//
	// Reference Validation results
	//
	for(DWORD j=0; j < RefValidateResult.size(); j++)
	{
	    printf("Ref %d, ValidateRef = %d\n", j, RefValidateResult[j]);
	}

	//
	// Test CoreValidation
	// Important note: this should have the ReferenceValidateVector already filled
	//
	try
	{
		XdsCoreValidation(
			SignatureTree, 
			hKey, 
			*ReferenceValidateVector,	    
			hCsp
			);

	    printf("CoreValidation OK\n");
	}
	catch (const bad_signature&)
	{
		//
		// XdsCoreValidation throw Signature excption --> CoreValidation fail
		//
		printf("Core Validation Failed, Signature Validation Failed\n");
	}
	catch (const bad_reference&)
	{
		//
		// XdsCoreValidation throw Reference excption --> CoreValidation fail
		//
		printf("Core Validation Failed, Reference Validation Failed\n");
	}
	
}


void TestBase64()
/*++

Routine Description:
	Test base64 operations

Arguments:
    None

Returned Value:
	None.

--*/
{
	//
    // Testing Encrypt, Decrypt using Session key
    //
	AP<char> Buffer = newstr("Hello World");
	DWORD BufferLen = strlen(Buffer);

	printf("Original Octet data: '%.*s'\n", BufferLen, Buffer);

	//
	// Base64 functions test
	//
	FILE *fp = fopen("Hello.dat","w");
	fprintf(fp,"%.*s", BufferLen, Buffer);
	fclose(fp);

	//
	// Transfer SignBuffer to base64 wchar format
	//
	DWORD BufferWBase64Len;
	AP<WCHAR> BufferWBase64 = Octet2Base64W(reinterpret_cast<const BYTE*>(Buffer.get()), BufferLen, &BufferWBase64Len);

	printf("Base64 wchar Buffer: '%.*ls'\n", BufferWBase64Len, BufferWBase64);

	//
	// Transfer SignBuffer to base64 ansi format
	//
	DWORD BufferBase64Len;
	AP<char> BufferBase64 = Octet2Base64(reinterpret_cast<const BYTE*>(Buffer.get()), BufferLen, &BufferBase64Len);

	printf("Base64 ansi Buffer: '%.*s'\n", BufferBase64Len, BufferBase64);

	//
	// Test Utf8ToWcs
	//
	size_t WcsBufferBase64Len;
	AP<WCHAR> WcsBufferBase64 = UtlUtf8ToWcs(reinterpret_cast<const BYTE*>(BufferBase64.get()), BufferBase64Len, &WcsBufferBase64Len);

	if((BufferWBase64Len != WcsBufferBase64Len) ||
	   (wcsncmp(WcsBufferBase64, BufferWBase64, BufferWBase64Len) != 0))
	{
		printf("Base64 ansi Buffer after utf8Wcs does not match\n");
		throw bad_base64();
	}

	printf("UtlUtf8ToWcs test pass ok\n");

	//
	// Test WcsToUtf8
	//
	utf8_str Utf8BufferWBase64 = UtlWcsToUtf8(BufferWBase64, BufferWBase64Len);

	if((Utf8BufferWBase64.size() != BufferBase64Len) ||
	   (strncmp(reinterpret_cast<const char*>(Utf8BufferWBase64.data()), BufferBase64, BufferBase64Len) != 0))
	{
		printf("Base64 wchar Buffer after Wcsutf8 does not match\n");
		throw bad_base64();
	}

	printf("UtlWcsToUtf8 test pass ok\n");

	//
	// Transfer SignBase64 back to Octet format
	//
	DWORD OctetLen;
	AP<BYTE> OctetBuffer = Base642OctetW(BufferWBase64, BufferWBase64Len, &OctetLen);

	printf("Octet data after conversions (base64 and back): '%.*s'\n", OctetLen, reinterpret_cast<char*>(OctetBuffer.get()));
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Xml Digital Signature library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&XdsTest, 1);

	SetActivation(argc, argv);

	if(g_fErrorneous)
	{
		DumpUsageText();
		return 3;
	}

    XmlInitialize();
    XdsInitialize();

	try
	{
		//
		// Class that upon constructing initialize the Csp, retrieves user public/private key
		// This object will be used to perform an operations that call crypto api
		//
		CCspHandle hCsp(CryAcquireCsp(MS_DEF_PROV));
//		CCspHandle hCsp(CryAcquireCsp(MS_ENHANCED_PROV));


		AP<char> SignatureElement = TestCreateSignature(g_PrivateKeySpec, hCsp);

		//
		// for validation we need the signer key - in this case it is our key
		// in real use we need to get this key via certificate or other mechanishm
		// possible that this key will be in the xml dsig
		// then might get it from there
		//
		TestValidation(SignatureElement, CryGetPublicKey(g_PrivateKeySpec, hCsp), hCsp);
		
		TestBase64();
	}
	catch (const bad_CryptoProvider& badCspEx)
	{
		TrERROR(XdsTest, "bad Crypto Service Provider Excption ErrorCode = %x", badCspEx.error());
		return(-1);
	}
	catch (const bad_CryptoApi& badCryEx)
	{
		TrERROR(XdsTest, "bad Crypto Class Api Excption ErrorCode = %x", badCryEx.error());
		return(-1);
	}
	catch (const bad_XmldsigElement&)
	{
		TrERROR(XdsTest, "bad Xmldsig Element excption");
		return(-1);
	}
	catch (const bad_base64&)
	{
		TrERROR(XdsTest, "bad base64");
		return(-1);
	}

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xds\test\crysimulate.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    CrySimulate.cpp

Abstract:
    Simulation of Cry library functions for XdsTest

Author:
    Ilan Herbst (ilanh) 9-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cry.h"

#include "CrySimulate.tmh"

//
// Compilation flag for choosing to use this simulation or the Cry library implementation
//
#define CRY_SIMULATE

#ifdef CRY_SIMULATE

const TraceIdEntry CrySimulate = L"Cry Simulate";

const int xFailCycle = 30;
static int s_fail=0;

HCRYPTPROV 
CryAcquireCsp(
	LPCTSTR /*CspProvider*/
	)
/*++

Routine Description:
	Aquire Crypto Service Provider (csp) 

Arguments:
    hCsp - (out) handle to csp

Returned Value:
	None.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy provider execption");
		throw bad_CryptoProvider(2);
	}
	
	HCRYPTPROV hCsp = 5;
	return(hCsp);
}


HCRYPTKEY 
CryGetPublicKey(
	DWORD /*PrivateKeySpec*/,
	HCRYPTPROV /*hCsp*/
	)
/*++

Routine Description:
	get public key from the crypto service provider (csp) 

Arguments:
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
    hCsp - handle to the crypto provider.

Returned Value:
    handle to the public key 

--*/
{
    s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy crypto api execption in GetPublicKey");
		throw bad_CryptoApi(3);
	}
	//
	// Get user public key from the csp 
	//
	HCRYPTKEY hKey = 18;

	return(hKey);
}


HCRYPTHASH 
CryCreateHash(
	HCRYPTPROV /*hCsp*/, 
	ALG_ID /*AlgId*/
	)
/*++

Routine Description:
	Create initialized hash object 

Arguments:
    hCsp - handle to the crypto provider.
	AlgId - (in) hash algorithm

Returned Value:
	the initialized hash object

--*/
{
    s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy crypto api execption in CreateHash");
		throw bad_CryptoApi(5);
	}

	HCRYPTHASH hHash = 8;

	return(hHash);
}


void 
CryHashData(
	const BYTE * /*Buffer*/, 
	DWORD /*BufferLen*/, 
	HCRYPTHASH /*hHash*/
	)
/*++

Routine Description:
	Perform data digest on a buffer and put the result in hash object.

Arguments:
    Buffer - Input data to be hashed/digest.
	BufferLen - Length of the input data.
	hHash - Hash object to put the result of the digested data.

Returned Value:
	None.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy crypto api execption in HashData");
		throw bad_CryptoApi(8);
	}

	return;
}


BYTE* 
CryGetHashData(
	const HCRYPTHASH /*hHash*/,
	DWORD *HashValLen
	)
/*++

Routine Description:
	Get the Hash value from a Hash object.
	after getting this value we can not use this Hash object again

Arguments:
	hHash - Hash object to put the result of the digested data.
	HashValLen - Length of the hash value.

Returned Value:
	Hash value of the Hash object.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy crypto api execption in GetHashData");
		throw bad_CryptoApi(11);
	}

	const LPCSTR xDummyHash = "dummyhash";

	AP<BYTE> HashVal = reinterpret_cast<BYTE *>(newstr(xDummyHash));
	*HashValLen = strlen(xDummyHash);
	return(HashVal.detach());
}


BYTE* 
CryCalcHash(
	HCRYPTPROV /*hCsp*/,
	const BYTE* /*Buffer*/, 
	DWORD /*BufferLen*/, 
	ALG_ID /*AlgId*/,
	DWORD *HashLen
	)
/*++

Routine Description:
	Calc Hash buffer 
	this function return the HashData Buffer that was allocated in GetHashData function
	the caller is responsible to free this buffer


Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	HashLen - (out) Hash Value length

Returned Value:
    Hash Value

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy crypto api execption in CalcHash");
		throw bad_CryptoApi(20);
	}

	const LPCSTR xDummyHash = "dummyhash";

	AP<BYTE> HashVal = reinterpret_cast<BYTE *>(newstr(xDummyHash));
	*HashLen = strlen(xDummyHash);
	return(HashVal.detach());
}


BYTE* 
CryCreateSignature(
	HCRYPTPROV /*hCsp*/,
	const BYTE* /*Buffer*/, 
	DWORD /*BufferLen*/, 
	ALG_ID /*AlgId*/,
	DWORD /*PrivateKeySpec*/,
	DWORD *SignLen
	)
/*++

Routine Description:
	Create the signature on a given buffer - digest, sign. 
	This function allocate and return the Signature Buffer
	the caller is responsible to free this buffer

Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	SignLen - (out) SignBuffer length

Returned Value:
    Signature buffer

--*/
{
    s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy crypto api execption in CreateSignature");
		throw bad_CryptoApi(9);
	}

	const LPCSTR xDummySignature = "dummysignature";
    AP<BYTE> SignBuffer = reinterpret_cast<BYTE *>(newstr(xDummySignature));
	*SignLen = strlen(xDummySignature);
	return(SignBuffer.detach());
}


bool 
CryValidateSignature(
	HCRYPTPROV /*hCsp*/,
	const BYTE* /*SignBuffer*/, 
	DWORD /*SignBufferLen*/, 
	const BYTE* /*Buffer*/,
	DWORD /*BufferLen*/,
	ALG_ID /*AlgId*/,
	HCRYPTKEY /*hKey*/
	)
/*++

Routine Description:
	Validate signature according to the signature buffer and the original
	data buffer that was signed.

Arguments:
    hCsp - handle to the crypto provider.
	SignBuffer - Signature Buffer.
	SignBufferLen - Length of SignBuffer.
	Buffer - Original Buffer that was signed.
	BufferLen - Length of Buffer.
	AlgId - (in) hash algorithm
	hKey - Key for unlocking the signature (signer public key)

Returned Value:
	True if Signature validation was succesful
	False if failure in validate the signature.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(CrySimulate, "dummy crypto api execption in ValidateSignature");
		throw bad_CryptoApi(6);
	}

	return(true);
}


#endif // CRY_SIMULATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\lib\xmlinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XmlInit.cpp

Abstract:
    Xml initialization

Author:
    Erez Haba (erezh) 15-Sep-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Xml.h"
#include "Xmlp.h"

#include "xmlinit.tmh"

VOID
XmlInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Xml library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Xml library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!XmlpIsInitialized());
    XmlpRegisterComponent();

    //
    // TODO: Write Xml initalization code here
    //

    XmlpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\lib\encode.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    encode.cpp

Abstract:
	implemeting  CXmlEncode and  CXmlDecode(xml.h)  



Author:
    Gil Shafriri(gilsh) 15-Feb-2001

--*/

#include <libpch.h>
#include <xmlencode.h>
#include <xml.h>

#include "encode.tmh"

//---------------------------------------------------------
//
// CXmlSpecialCharsSet - holds a set of special xml caracters 
//
//---------------------------------------------------------
class CXmlSpecialCharsSet
{
public:
	static bool IsIncluded(WCHAR c) 
	{
		return c == L'<'  || 
			   c == '>'   || 
			   c == L'&'  || 
			   c == L'\"'; 
	}
};




CXmlEncode::CXmlEncode(
		const xwcs_t& wcs
		):
		m_wcs(wcs)
{

}


std::wostream& operator<<(std::wostream& o, const CXmlEncode& XmlEncode)
/*++

Routine Description:
    encode given data and write it encoded to stream 


Arguments:
	o - stream
	XmlEncode - holds the data to encode.

  
Returned Value:
	The input stream

Note:
	The function loop over the input and write it to the stream as is
	if it is not special xml caracter. If it is special caracter it encode
	it with '&' + '#' + char decimal value + ';' For example '<' is encoded as
	&#60;
  
--*/

{
	for(int i = 0; i<XmlEncode.m_wcs.Length(); ++i)
	{
		WCHAR wc = XmlEncode.m_wcs.Buffer()[i];
		if(!CXmlSpecialCharsSet::IsIncluded(wc))
		{
			o.put(wc);
		}
		else
		{
			const WCHAR* dec = L"0123456789";
			WCHAR DecimalHighByte = wc / 10;
			WCHAR DecimalLowByte = wc - (DecimalHighByte * 10);
			ASSERT(DecimalHighByte < 10 && 	DecimalLowByte < 10);
			o.put(L'&');
			o.put(L'#');
			o.put(dec[DecimalHighByte]);
			o.put(dec[DecimalLowByte]);
			o.put(L';');
		}
	}
	return o;
}




CXmlDecode::CXmlDecode(
	void
	):
	m_fConverted(false)
{

}


void CXmlDecode::Decode(const xwcs_t& encoded)
{
	m_DecodedBuffer.free();
	m_encoded =  encoded;

	const WCHAR* ptr =  encoded.Buffer();
	const WCHAR* end = encoded.Buffer() + encoded.Length();

	while(ptr != end)
	{
		if(*ptr ==  L'&')
		{	
			ptr = HandleSpeciallChar(ptr);
		}
		else
		{
			ptr = HandleReguralChar(ptr);
		}
	}					
}



const WCHAR* CXmlDecode::HandleReguralChar(const WCHAR* ptr)
{
	if(m_fConverted)
	{
		m_DecodedBuffer.append(*ptr);				
	}
	return ++ptr;
}


const WCHAR* CXmlDecode::HandleSpeciallChar(const WCHAR* ptr)
/*++

Routine Description:
    Decode encoded char and write it into the output decoded buffer.


Arguments:
	ptr - pointer to array of caracters encoding the special char.
	The encoding format is : "&#xx;" where xx is the decimal value
	of the ascii of the encoded char.

  
Returned Value:
	Pointer after the encoded sequence.

--*/
{
	//
	// If this is the first special char - copy all caracters  before it to the converted stream.
	//
	if(!m_fConverted)
	{
 		const WCHAR* begin = m_encoded.Buffer();
 		ASSERT(begin <= ptr);
		while(begin != ptr)
		{
			m_DecodedBuffer.append(*begin);								
			begin++;
		}
		m_fConverted = true;
	}
	ptr++;

	//
	//Encoded chars should start with L'#' just after the L'&'
	//
	if(*(ptr++) != L'#')
		throw bad_xml_encoding();


	//
	// Now loop over the caracters untill L';' and calculate
	// their decimal numeric value.
	//
	WCHAR decoded = 0;
	short i = 0;
	for(;;)
	{
		if(*ptr == L';')
			break;


		if(!iswdigit(*ptr))
			throw bad_xml_encoding();

		decoded = decoded * 10 + (*ptr - L'0');
		++ptr;
		++i;
	}

	if(decoded == 0 || i > 2)
		throw bad_xml_encoding();

	//
	// Add the caracter  to the decoded buffer
	//
	m_DecodedBuffer.append(decoded);

	//
	// Return the position for the next caracter
	//
	return ++ptr;
}



const xwcs_t CXmlDecode::get() const
/*++

Routine Description:
    Return the decoded characters


Arguments:
	None.

  
Returned Value:
	array of decoded characters.

Note:
If no caracters in the input caracters was decoded - the input caracters return as is.
If one of the  input caracters was decoded  - the decoded buffer is returned.

--*/
{
	return m_fConverted ? xwcs_t(m_DecodedBuffer.begin(), m_DecodedBuffer.size()) : m_encoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\lib\xmldebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XmlDebug.cpp

Abstract:
    Xml debugging

Author:
    Erez Haba (erezh) 15-Sep-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Xml.h"
#include "Xmlp.h"

#include "xmldebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Validate Xml state
//
void XmlpAssertValid(void)
{
    //
    // XmlInitalize() has *not* been called. You should initialize the
    // Xml library before using any of its funcionality.
    //
    ASSERT(XmlpIsInitialized());

    //
    // TODO:Add more Xml validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void XmlpSetInitialized(void)
{
    LONG fXmlAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Xml library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fXmlAlreadyInitialized);
}


BOOL XmlpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Xml,
	XmlDoc,
};



void XmlpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
}


//---------------------------------------------------------
//
//  helper stream functions 
//
//---------------------------------------------------





static std::wostream& operator<<(std::wostream& ostr,const xwcs_t& xwstr)
{
	ostr.write(xwstr.Buffer(), xwstr.Length());	 //lint !e534
	return ostr;
}


static std::wostream& operator<<(std::wostream& ostr,const XmlNameSpace& NameSpace)
{
	if(NameSpace.m_uri.Length() != 0)
	{
		ostr<<L"{"<<NameSpace.m_uri<<L"}";
	}

	if(NameSpace.m_prefix.Length() != 0)
	{
		ostr<<NameSpace.m_prefix<<L":";
	}
	return ostr;
}


static std::wostream& operator<<(std::wostream& ostr,const XmlAttribute& Attribute)
{
	ostr<<Attribute.m_namespace<<Attribute.m_tag<<L"="<<L"'"<<Attribute.m_value<<L"'";
	return ostr;
}


static std::wostream& operator<<(std::wostream& ostr,const XmlValue& Value)
{
	ostr<<Value.m_value;
	return ostr;
}





static void PrintXmlTree(const XmlNode* node, unsigned int level,std::wostringstream& ostr)
{
	ostr<<level<<std::setw(level*4)<<L" "<<L"<"<<node->m_namespace<<node->m_tag;
	typedef List<XmlAttribute>::iterator iterator;
	for(iterator ia = node->m_attributes.begin(); ia != node->m_attributes.end(); ++ia)
	{
		ostr<<L" "<<*ia;			
	}
	ostr<<L">\r\n";


	level++;
	for(List<XmlValue>::iterator iv = node->m_values.begin(); iv != node->m_values.end(); ++iv)
	{
		ostr<<level<<std::setw(level*4)<<L" "<<*iv<<L"\r\n";
	}


	for(List<XmlNode>::iterator in = node->m_nodes.begin(); in != node->m_nodes.end(); ++in)
	{
		PrintXmlTree(&*in,level,ostr);
	}
	

}


VOID
XmlDumpTree(
	const XmlNode* Tree
	)
{
	XmlpAssertValid();
	std::wostringstream wstr;
	PrintXmlTree(Tree,1,wstr);
	TrTRACE(XmlDoc, "Xml Tree dump:\r\n%ls",wstr.str().c_str());
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\lib\xmlns.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    xmlns.h

Abstract:
	Classes that help xml parser to  deal with  namespaces.  

	The basic functionality the parser needs it to save namespace declaration
	it find in the xml text - and to find the current uri for a given prefix.
	In general - each node inherites all namespaces was declared by parents nodes
	unless it override them. We need to maintain stack  per namespace prefix -
	to know what is the uri matching given prefix in an arbitrary scope.


Author:
    Gil Shafriri(gilsh) 9-May-2000

--*/

#pragma once

#ifndef _MSMQ_XMLNS_H_
#define _MSMQ_XMLNS_H_

#include <xstr.h>
#include <list.h>


class CNsUriNode;
typedef List<CNsUriNode,0> 	CNsStack;


//---------------------------------------------------------
//
//  CNsUriNode - class that represent namespace uri node.
//  it push itself it a stack in the ctor and pop itself
//  in dtor. 
//
//---------------------------------------------------
class CNsUriNode 
{
public:
	CNsUriNode(const xwcs_t& uri):m_uri(uri)
	{
	}

	xwcs_t Uri()const 
	{
		return m_uri;
	}

public:
	LIST_ENTRY  m_NsStack;    // must be first
	LIST_ENTRY  m_CleanStack;

private:
	xwcs_t	m_uri;
	

private:
	CNsUriNode(const CNsUriNode&);
	CNsUriNode& operator=(const CNsUriNode&);
};
C_ASSERT(offsetof(CNsUriNode,m_NsStack)== 0);





//---------------------------------------------------------
//
//  CNameSpaceInfo - Class that expose the functionality needs by the parser :
//	1) Save namespace declaration (prefix\uri pair )
//  2) Match uri to prefix.
// 	The parser create object of this class in the node scope - 
//  and save the declarations it find in this scope. 
//  The object itself responsible to clean the namespace declarations
//  saved in it's lifetime. (remember namespace declarations valid only in the scope they declared)
//---------------------------------------------------
class CNameSpaceInfo
{
public:
	CNameSpaceInfo(CNameSpaceInfo*);
	CNameSpaceInfo();
	~CNameSpaceInfo();

public:
	void  SaveUri(const xwcs_t& prefix,const xwcs_t& uri);
	const xwcs_t GetUri(const xwcs_t& prefix) const;

private:
	typedef List<CNsUriNode,offsetof(CNsUriNode,m_CleanStack)> CNsCleanStack;

	//
	// class CNameSpaceStacks - manage map of stacks. Stack per namespace prefix.
	// Namespace Uris are pushed\poped to\prom the correct stack according to their prefix.
	//
	class CNameSpaceStacks :public CReference
	{
	public:
		CNameSpaceStacks(){};
		~CNameSpaceStacks();

	public:
		const CNsUriNode* GetUri(const xwcs_t& prefix)const;
		void SaveUri(const xwcs_t& prefix, CNsUriNode* pNsUriNode);

	private:
		bool InsertStack(const xwcs_t& prefix,CNsStack* pCNsStack);
		CNsStack& OpenStack(const xwcs_t& prefix);

	   		
	private:
		CNameSpaceStacks(const CNameSpaceStacks&);
		CNameSpaceStacks& operator=(const CNameSpaceStacks&);


	private:
		typedef std::map<xwcs_t,CNsStack*> CStacksMap;
		CStacksMap m_map;
	};




private:
	R<CNameSpaceStacks> m_nsstacks;
	CNsCleanStack m_NsCleanStack;


private:
	CNameSpaceInfo(const CNameSpaceInfo&);
	CNameSpaceInfo& operator=(const CNameSpaceInfo&);
};







#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\lib\xmlp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xmlp.h

Abstract:
    Xml private functions.

Author:
    Erez Haba (erezh) 15-Sep-99

--*/

#pragma once

#ifndef _MSMQ_XMLP_H_
#define _MSMQ_XMLP_H_


const TraceIdEntry Xml = L"Xml";
const TraceIdEntry XmlDoc = L"Xml.Document";

#ifdef _DEBUG

void XmlpAssertValid(void);
void XmlpSetInitialized(void);
BOOL XmlpIsInitialized(void);
void XmlpRegisterComponent(void);

#else // _DEBUG

#define XmlpAssertValid() ((void)0)
#define XmlpSetInitialized() ((void)0)
#define XmlpIsInitialized() TRUE
#define XmlpRegisterComponent() ((void)0)

#endif // _DEBUG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\test\fmapper.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FMapper.cpp

Abstract:
    memory-mapped-files api abstraction.
   
	

Author:
    Nir Aides (niraides) 27-dec-99

--*/

#include <libpch.h>
#include "FMapper.h"

#include "fmapper.tmh"

CFileMapper::CFileMapper( LPCTSTR FileName )
{
    CFileHandle hFile = CreateFile(
							FileName, 
							GENERIC_READ, 
							FILE_SHARE_READ, 
							NULL,        // IpSecurityAttributes
							OPEN_EXISTING,
							NULL,      // dwFlagsAndAttributes
							NULL      // hTemplateFile
							);
    if(hFile == INVALID_HANDLE_VALUE)
        throw FileMappingError();

	m_size = ::GetFileSize( 
					hFile, 
					NULL    // lpFileSizeHigh 
					);

	if(m_size <= 0)
		throw FileMappingError();

    *&m_hFileMap = ::CreateFileMapping( 
						hFile,
						NULL,       // IpFileMappingAttributes
						PAGE_WRITECOPY,
						0,        // dwMaximumSizeHigh
						0,		 // dwMaximumSizeLow
						NULL    // lpName
						);
    if(m_hFileMap == NULL)
        throw FileMappingError();
}



LPVOID CFileMapper::MapViewOfFile( DWORD dwDesiredAccess )
{
	ASSERT( dwDesiredAccess == FILE_MAP_COPY || dwDesiredAccess == FILE_MAP_READ );

    LPVOID address = ::MapViewOfFile( 
							m_hFileMap,
							dwDesiredAccess,
							0,                // dwFileOffsetHigh
							0,				 // dwFileOffsetLow
							0				// dwNumberOfBytesToMap
							);

    return address;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\lib\parse.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    parse.cpp

Abstract:
    Super fast Xml document parser

Author:
    Erez Haba (erezh) 15-Sep-99

Environment:
    Platform-independent,

--*/			  
		
#include <libpch.h>
#include <Xml.h>
#include "Xmlp.h"
#include "xmlns.h"

#include "parse.tmh"

static const WCHAR* parse_element(const WCHAR* p,const WCHAR* end, XmlNode** ppNode,CNameSpaceInfo*  pNsInfo);


inline void operator+=(XmlNode& n,XmlAttribute& a)
{
    n.m_attributes.push_back(a);
}


inline void operator+=(XmlNode& n,XmlValue& v)
{
    n.m_values.push_back(v);
}


inline void operator+=(XmlNode& n, XmlNode& c)
{
    n.m_nodes.push_back(c);
}



static const WCHAR* skip_ws(const WCHAR* p, const WCHAR* end)
{
    while(p!= end && iswspace(*p))
    {
        ++p;
    }

    return p;
}


static bool is_start_sub_str(
			const WCHAR* f1,
			const WCHAR* l1,
			const WCHAR* f2,
			const WCHAR* l2)

/*++

Routine Description:
	check if [l1,f1) is at the start of [l2,f2)

 
Arguments:
--*/
{
	if ((l2 - f2) < (l1 - f1))
		return false;

	return (wcsncmp(f1, f2, l1 - f1) == 0);

}

static void check_end(const WCHAR* p,const WCHAR* end)
{
	if(p >= end)
	{
		TrERROR(Xml, "Unexpected end of document ");
        throw bad_document(p);
	}
}


static const WCHAR* find_char(const WCHAR* p, const WCHAR* end, WCHAR c)
{
	for(;p != end; p++)
	{
		if(*p == c)
			return p;
	}
	TrERROR(Xml, "Unexpected EOS while searching for '%lc'", c);
	throw bad_document(--p);
}


static const WCHAR* skip_comment(const WCHAR* p, const WCHAR* end)
{
	static const WCHAR xComment[] =	L"<!--";
	

    //
    // [15]  Comment ::=  '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->' 
    //
	if(!is_start_sub_str(
				xComment,
				xComment + STRLEN(xComment),
				p,
				end))
	{
		return p;
	}


	p += STRLEN(xComment);
    for(;;)
    {
		p = find_char(p, end, L'-');
		if(p+2 >=  end)
			return end;

        if(*++p != L'-')
            continue;
		
        if(*++p != L'>')
		{
			TrERROR(Xml, "Comment terminator '--' followed by %lc and not by '>'", *p);
            throw bad_document(p);
		}

        return ++p;
    }
}


static const WCHAR* skip_pi(const WCHAR* p,const WCHAR* end)
{
	static const WCHAR xPi[] = L"<?";

    //
    // [16]  PI ::=  '<?' Name (S (Char* - (Char* '?>' Char*)))? '?>' 
    //

	if(!is_start_sub_str(
				xPi,
				xPi + STRLEN(xPi),
				p,
				end))
	{
		return p;
	}


	p += STRLEN(xPi);
    for(;;)
    {
        p = find_char(p, end, L'?');
		if(p+1 >= end)
			return end;

        if(*++p != L'>')
			continue;

        return ++p;
    }
}


static const WCHAR* skip_misc(const WCHAR* p,const WCHAR* end)
{
    //
    // [27]  Misc ::=  Comment | PI |  S 
    //
    for(;;)
    {
        const WCHAR* q;
		q = skip_ws(p, end);
        q = skip_comment(q, end);
        q = skip_pi(q, end );

        if(p == q)
            return p;

        p = q;
    }
}


static const WCHAR* skip_doctype(const WCHAR* p, const WCHAR* end)
{
	static const WCHAR xDocType[] =  L"<!DOCTYPE";


    //
    // [28]  doctypedecl ::=  '<!DOCTYPE' S Name (S {bad system parse})? S? ('[' (problem maybe netsing)* ']' S?)? '>'
    //
    
	//
	// BUGBUG: Don't know how to parse DOCTYPE yet. gilsh 24-Apr-2000 
	//
	if(!is_start_sub_str(
				xDocType,
				xDocType + STRLEN(xDocType),
				p,
				end))
	{
		return p;
	}

	TrERROR(Xml, "Don't know how to skip DOCTYPE section");
    throw bad_document(p);
}


static const WCHAR* skip_name_char(const WCHAR* p, const WCHAR* end, const WCHAR** ppPrefix)
{
	const WCHAR* pStart = p;
	*ppPrefix = pStart;


   	DWORD PrefixCharCount = 0;
    while(p!= end && (iswalpha(*p) || iswdigit(*p) || *p == L'.' || *p == L'-' || *p == L'_' || *p == L':'))
    {
		//
		// the first time we see L':' we try to match qualified  name.
		// if we see another L':' - we consider it an non qualified  name
		//
		if(*p == L':')
		{
			if(PrefixCharCount++ == 0)
			{
				*ppPrefix = p;	
			}
			else
			{
			   *ppPrefix = pStart;	
			}
		}
        ++p;
    }
    return p;
}



static const WCHAR* parse_name(const WCHAR* p,const WCHAR* end, const WCHAR** ppPrefix)
{

	/* if qualified  name then try to match this : 

	// QName ::=  (Prefix ':')? LocalPart 
	// Prefix ::=  NCName 
	// LocalPart ::=  NCName 
	// NCName ::=  (Letter | '_') (NCNameChar)* 
    // NCNameChar ::=  Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender  

	*/

	
	/* if not, try to match this :

	//
	//NameChar ::=  Letter | Digit | '.' | '-' | '_' | ':' |  
	//

    */

	
	
	//
	// check if first char is (Letter | '_' | ':')
	// this check is valid even if the name is qualified.
	//
	check_end(p , end);

    if(!(iswalpha(*p) || *p == L'_' || *p == L':'))
	{
		TrERROR(Xml, "Bad first char in Name '%lc'", *p);
        throw bad_document(p);
	}
    return skip_name_char(p, end, ppPrefix);
}


static 
xwcs_t 
get_local_name(
	const WCHAR* pStartName,
	const WCHAR* pEndName,
	const WCHAR* pEndPrefix
	)
{
	if(pEndPrefix == pStartName)
	{
		return xwcs_t(pStartName , pEndName - pStartName);
	}
	ASSERT(*pEndPrefix == L':'); 
	return  xwcs_t(pEndPrefix+1,pEndName - (pEndPrefix+1));
}


static 
xwcs_t 
get_name_prefix(
	const WCHAR* pStartName,
	const WCHAR* pEndPrefix
	)
{
	return  xwcs_t(pStartName,pEndPrefix - pStartName);
}



static 
const 
WCHAR*  
parse_full_name(
	const WCHAR* pStartName,
	const WCHAR* end,
	xwcs_t* pPrefix,
	xwcs_t* pTag
	)

{
	const WCHAR* pEndPrefix;
	const WCHAR* pEndName = parse_name(pStartName, end, &pEndPrefix);
	*pTag  = get_local_name(pStartName,pEndName,pEndPrefix);
	*pPrefix = get_name_prefix(pStartName,pEndPrefix); 
	
	return 	pEndName;
}



static const WCHAR* parse_attribute(const WCHAR* p,const WCHAR* end, XmlAttribute** ppAttribute)
{
	
    //
    // [41]  Attribute ::=  Name  S? '=' S? AttValue
    // [10]  AttValue ::=  '"' [^"]* '"'  | "'" [^']* "'" 
    //
	xwcs_t tag;
	xwcs_t prefix;
	const WCHAR* q = parse_full_name(p, end, &prefix,&tag);



	p = skip_ws(q, end);
	check_end(p , end);

	if(*p != L'=')
	{
		TrERROR(Xml, "Missing '=' in attribute parsing");
		throw bad_document(p);
	}

	p = skip_ws(++p, end);
	check_end(p , end);


	WCHAR c = *p;
	if(c != L'\'' && c != L'"')
	{
        //
        // NTRAID#WINDOWS-353696-2001/03/28-shaik WPP: Compiler error on \" format
        //
		//TrERROR(Xml, "Attribute value does not start with a \' or a \" but with a '%lc'", c);
        TrERROR(Xml, "Attribute value does not start with a \' but with a '%lc'", c);
		throw bad_document(p);
	}

	q = find_char(++p, end, c);
	
	xwcs_t value(p, q - p);
	XmlAttribute* attrib = new XmlAttribute(prefix,tag,value);
	*ppAttribute = attrib;

    return ++q;
}
  

static const WCHAR* parse_char_data(const WCHAR* p,const WCHAR* end, XmlValue** ppValue)
{
	//
    // [14]  CharData ::=  [^<]*
    //
    const WCHAR* q = find_char(p, end, L'<');


//#pragma BUGBUG("Should traling white spaces be removed from char data while parsing?")

	//
	// We should have some data here
	//
	ASSERT(q != p);

	XmlValue* value = new XmlValue(xwcs_t(p, q - p));
	*ppValue = value;
    return q;
}


static const WCHAR* parse_cdsect(const WCHAR* p,const WCHAR* end, XmlValue** ppValue)
{
	static const WCHAR xCDATA[] =  L"<![CDATA[";

	//
    // [18]  CDSect ::=  '<![CDATA['  (Char* - (Char* ']]>' Char*))  ']]>' 
    //

    if(!is_start_sub_str(
				xCDATA,
				xCDATA + STRLEN(xCDATA),
				p,
				end))
	{
		TrERROR(GENERAL, "CDATA section does not start with '<![CDATA[' but rather with %.9ls", p);
        throw bad_document(p);
	}

	p += STRLEN(xCDATA);
    for(const WCHAR* q = p; ; q++)
    {
        q = find_char(q, end,  L']');
		check_end(p + 2, end);
		
        if(q[1] != ']')
            continue;

	
        if(q[2] != L'>')
            continue;

		XmlValue* value = new XmlValue(xwcs_t(p, q - p));
		*ppValue = value;
		return (q + 3);
    }
}


static xwcs_t get_namespace_prefix_declared(const XmlAttribute& Attribute)
/*++

Routine Description:
	get the prefix of namespace declaration.

 
Arguments:
IN - Attribute - attribute that declared namespace

  

Returned Value:
    prefix declared
--*/
{
	//
	// if default namespace declared  : xmlns="uri"
	//
	if(Attribute.m_namespace.m_prefix.Length() == 0)
	{
		return xwcs_t();	
	}

	//
	// spesific namespace prefix declared :	 xmlns:prefix="uri"
	//
	return 	Attribute.m_tag;
	
}

static bool is_namespace_declaration(const XmlAttribute* Attribute)
/*++

Routine Description:
    check if attributed parsed is not real attribute but namespace declaration
.

Arguments:
  

Returned Value:
    true if the attribute is namespace declaration - otherwise false.

--*/


{
	const LPCWSTR xNsDecKeyWord = L"xmlns";

	//
	// default namespace declaration "xmlns=uri"
	// no prefix declared.
	//
	if(Attribute->m_tag ==  xNsDecKeyWord)
	{
		return Attribute->m_namespace.m_prefix.Length() == 0;
	}


	//
	// spesific prefix declared "xmlns:prefix=uri".
	// little bit confusing - "xmlns" was parsed as
	// prefix and "prefix" was parsed as tag - because
	// parser thought it just regular attribute of the form
	// "prefix:tag=uri". 
	//
	if(Attribute->m_namespace.m_prefix == xNsDecKeyWord)
	{
		return  Attribute->m_tag.Length()  != 0;
	}

	return false;
	
}



static const xwcs_t get_namespace_uri(const CNameSpaceInfo& NsInfo,const xwcs_t& prefix)
/*++

Routine Description:
	return namespace uri for given namespace prefix

 
Arguments:
IN - NsInfo - namespace information class
IN - prefix - namespace prefix.
  

Returned Value:
    Namespace uri that match the prefix, or empty uri if no match found.
--*/

{
	xwcs_t uri =  NsInfo.GetUri(prefix);
	if(uri.Length() == 0  && prefix.Length() != 0)
	{
        TrERROR(Xml, "Prefix '%.*ls' has no namespace Uri declared", LOG_XWCS(prefix));

        //
        // At the moment we decided to return empty uri and not to throw
        // exception on prefix without namespace declaration.
        //
        return 	xwcs_t();

	}
	return  uri;
}


static void set_namespaces(const CNameSpaceInfo& NsInfo, XmlNode* pNode)
/*++

Routine Description:
	set namespaces uri to all node tag and attributea of the current node   

 
Arguments:
IN - NsInfo - namespace information class
IN - XmlNode* pNode - xml node

  

Returned Value:
    None

Note:
Parsing namespaces done into steps
1) Collecting namespaces declaration and the prefixes used
2) Setting the namespaces uri's collected to node tag and attributes of the current node.

This function perform step 2

--*/
{
	//
	// set uri for current node 
	//
	pNode->m_namespace.m_uri = get_namespace_uri(NsInfo,pNode->m_namespace.m_prefix);

	//
	// set uri for all attrubutes
	//
	for(List<XmlAttribute>::iterator it = pNode->m_attributes.begin();
		it != pNode->m_attributes.end();
		++it
		)
	{
		//
		//  default name space affects empty prefix of nodes only (not attributes) - 
		//  so we skip empty prefixes.  Here is the what the space recomendation
		//  spec say about it : 
		//

		/*
		5.2 Namespace Defaulting
		A default namespace is considered to apply to the element 
		where it is declared (if that element has no namespace prefix), 
		and to all elements with no prefix within the content of that element. 
		If the URI reference in a default namespace declaration is empty, 
		then unprefixed elements in the scope of the declaration are
		not considered to be in any namespace. Note that default namespaces 
		do not apply directly to attributes. 
		*/


		if(it->m_namespace.m_prefix.Length() > 0)
		{
			it->m_namespace.m_uri = get_namespace_uri(
										NsInfo,
										it->m_namespace.m_prefix
										);
		}
	}
}

//
// check if close tag match the open tag
// <prefix:tag> ... </prefix:tag>
//
static
bool 
is_tags_match(
			const xwcs_t& StartPrefix,
			const xwcs_t& StartTag,
			const xwcs_t& EndPrefix,
			const xwcs_t& EndTag
			)

/*++

Routine Description:
   	Check if close tag match the open tag.
    <prefix:tag> ... </prefix:tag>

 
Arguments:
IN - StartPrefix start prefix tag
IN - StartTag - start tag.
IN - EndPrefix - end prefix tag
IN - EndTag - end tag
  

Returned Value:
    true if tags match otherwise false.

--*/

{

	return (StartPrefix == EndPrefix) && (StartTag == EndTag);
}


static 
const 
WCHAR* 
parse_content(
		const WCHAR* p,
		const WCHAR* end, 
		XmlNode* pNode,
		CNameSpaceInfo*  pNsInfo
		)
{
	LPCWSTR pContent = p;

    //
    // [43]  content ::=  (element | CharData | CDSect | Misc)* 
    //
    for(;;)
    {
        p = skip_misc(p, end);
		check_end(p , end);

        if(*p != L'<')
        {
            //
            // Only char data (and Reference) do not begin with '<'
            //
            XmlValue* value;
             p = parse_char_data(p, end, &value);
            *pNode += *value;
            continue;
        }
        
        //
        // End of node detected '</'
        //
		check_end(p + 1 , end);
        if(p[1] == L'/')
            break;

        //
        // CDATA section detected '<!'
        //
        if(p[1] == L'!')
        {
            XmlValue* value;
            p = parse_cdsect(p, end, &value);
            *pNode += *value;
            continue;
        }

        //
        // Child element detected
        //
        {
            XmlNode* child;
            p = parse_element(p, end,&child,pNsInfo);
            *pNode += *child;
            continue;
        }
    }

	pNode->m_content = xwcs_t(pContent, p - pContent);
	return p;

}


static 
const 
WCHAR*  
parse_attributes(
	const WCHAR* p,
	const WCHAR* end,
	XmlNode* pNode,
	CNameSpaceInfo* pNsInfo,
	bool* bContinute
	)
{
	
	for(;;)
    {
		const WCHAR* q = p;
        p = skip_ws(p, end);
		check_end(p+1 ,end);

        if((p[0] == L'/') && (p[1] == L'>'))
        {
			LPCWSTR pElement = pNode->m_tag.Buffer() - 1;
			pNode->m_element = xwcs_t(pElement, p + 2 - pElement);
		

			//
			// m_content is initialize to NULL
			//
		             
			*bContinute = false;
            return (p + 2);
        }

        if(*p == L'>')
        {
            ++p;
            break;
        }

		//
		// There must be a white space before attribute name
		//
		if(q == p)
			throw bad_document(p);

        P<XmlAttribute> attribute;
        p = parse_attribute(p, end, &attribute);

		//
		// if the attribute id actually namespace declaration xmlns:prefix="uri"
		// the the attribute value is the namespace uri. This attribute is not inserted
		// to the attributes list.
		if(is_namespace_declaration(attribute))
		{
			pNsInfo->SaveUri(
						get_namespace_prefix_declared(*attribute),
						attribute->m_value
						);
							
		}
		else
		{
			*pNode += *(attribute.detach());
		}
    }
	*bContinute = true;
	return p;
}

static const WCHAR* create_new_node(const WCHAR* p,const WCHAR* end, XmlNode** ppNode)
{
	xwcs_t tag;
	xwcs_t prefix;
	p = parse_full_name(p, end, &prefix,&tag);
	*ppNode = new XmlNode(prefix,tag);
	return p;
}


#ifdef _DEBUG

static bool is_end_tag(const WCHAR* p)
{
	return (p[0] == L'<') && (p[1] == L'/');
}

#endif


static const WCHAR* parse_end_node(const WCHAR* p,const WCHAR* end, const  XmlNode& node)
{
	
	ASSERT(is_end_tag(p));

	//
    // [42]  ETag ::=  '</' Name S? '>' 
    //
    p += 2;


  	xwcs_t Prefix;
	xwcs_t Tag; 
	p = parse_full_name(p, end, &Prefix,&Tag);
	if(!is_tags_match(
				node.m_namespace.m_prefix,
				node.m_tag,
				Prefix,
				Tag))
       
	{
		TrERROR(
			Xml,
			"End tag '%.*ls:%.*ls' does not match Start tag '%.*ls:%.*ls'",
			LOG_XWCS(Prefix),
			LOG_XWCS(Tag), 
			LOG_XWCS(node.m_namespace.m_prefix),
			LOG_XWCS(node.m_tag)
			);

        throw bad_document(p);
	}

	p = skip_ws(p, end);
	check_end(p, end);
    if(*p != L'>')
	{
		TrERROR(Xml, "End tag does not close with a '>' but rather with a '%lc'", *p);
        throw bad_document(p);
	}
   	++p;


	return p;
}

static void parse_start_node(const WCHAR* p ,const WCHAR* end)
{
	//
    // [40]  STag ::=  '<' Name (S Attribute)* S? '>'
    // [44]  EmptyElemTag ::=  '<' Name (S Attribute)* S? '/>' 
    //
	check_end(p , end);
    if(*p != L'<')
	{
		TrERROR(Xml, "Element does not start with a '<' but rather with a '%lc'", *p);
        throw bad_document(p);
	}
}

static
const 
WCHAR* 
parse_element(
		const WCHAR* p, 
		const WCHAR* end,
		XmlNode** ppNode,
		CNameSpaceInfo*  pNsInfo
		)
{
	//
	// create local namespace info from previous level
	//
	CNameSpaceInfo LocalNameSpaceInfo(pNsInfo); 


	parse_start_node(p , end);

	//
	//  create node object
	//
	CAutoXmlNode node;
	p = create_new_node(++p, end, &node);


	//
	// add attributes found in the node (or namespaces declarations)
	//
 	bool bContinute;
	p = parse_attributes(p, end, node,&LocalNameSpaceInfo,&bContinute);
	if(!bContinute)
	{
		set_namespaces(LocalNameSpaceInfo,node);
		*ppNode = node.detach();
		return p;
	}

	//
	// add node content
	//
	p = parse_content(p, end , node, &LocalNameSpaceInfo);
	p = parse_end_node(p, end, *node);
	

	//
	// ilanh - m_element is the all element including opening < and closing >
	// node->m_tag.Buffer() is pointer to the tag name that is after the opening <
	// therefore need to substract one from node->m_tag.Buffer() (both for the pointer and for the length)
	//
	LPCWSTR pElement = node->m_tag.Buffer() - 1;
	node->m_element = xwcs_t(pElement, p - pElement);


	//
	// At the end - we should update namespace uri of attributes and nodes
	// only now we know the correct mapping from prefix to uri.
	//
	set_namespaces(LocalNameSpaceInfo,node);

	*ppNode = node.detach();
    return p;
}

const WCHAR*
XmlParseDocument(
	const xwcs_t& doc,
	XmlNode** ppTree
	)

/*++

Routine Description:
    Parse an XML document and return the reprisenting tree.

Arguments:
    p - Null terminated buffer to parse. Does not have to terminate at the end
		of the document, but must have a null terminator at a valid memory
		location after the document. (actually a must only for bad docuemnts)

	ppTree - Output, received the parsed  XML tree.

Returned Value:
    The end of the XML document

--*/


{
	XmlpAssertValid();

	const WCHAR* p = doc.Buffer();
	const WCHAR* end = doc.Buffer() + doc.Length();

	//
	// [1]  document ::=  prolog element Misc* 
	//

	//
	// [22]  prolog ::=  Misc* (doctypedecl Misc*)? 
	// [27]  Misc ::=  Comment | PI |  S 
	//


    p = skip_misc(p,end);
	p = skip_doctype(p, end);
    p = skip_misc(p , end);



	CNameSpaceInfo  NsInfo;
    p = parse_element(p, end,  ppTree, &NsInfo);
  

    return p;
}



VOID
XmlFreeTree(
	XmlNode* Tree
	)
/*++

Routine Description:
    Free a complete Xml tree structure.

Arguments:
    Tree - the tree to free

Returned Value:
    None.

--*/
{
	XmlpAssertValid();
	ASSERT(Tree != 0);

	while(!Tree->m_attributes.empty())
	{
		XmlAttribute& attrib = Tree->m_attributes.front();
		Tree->m_attributes.pop_front();
		delete &attrib;
	}

	while(!Tree->m_values.empty())
	{
		XmlValue& value = Tree->m_values.front();
		Tree->m_values.pop_front();
		delete &value;
	}

	while(!Tree->m_nodes.empty())
	{
		XmlNode& node = Tree->m_nodes.front();
		Tree->m_nodes.pop_front();
		XmlFreeTree(&node);
	}

	delete Tree;
}


static xwcs_t get_first_node_name(const WCHAR* Path)
{
	const WCHAR* p = Path;
	while((*p != L'!') && (*p != L'\0'))
	{
		++p;
	}

	return xwcs_t(Path, p - Path);
}

static
const
XmlNode*
XmlpFindSubNode(
	const XmlNode* Tree,
	const WCHAR* SubNodePath
	)
/*++

Routine Description:
    Get the element for a specific *relative* path. That is, don't match the
	root element tag.

Arguments:
    Tree - The tree to search
	SubNodePath - The element *relative* path in the format "!level1!level1.1!level1.1.1"

Returned Value:
    The deepest sub-element node if found NULL otherwise.

--*/
{
	XmlpAssertValid();
	ASSERT(Tree != 0);

	if(*SubNodePath == L'\0')
		return Tree;

	ASSERT(*SubNodePath == L'!');
	xwcs_t tag = get_first_node_name(++SubNodePath);

	const List<XmlNode>& n = Tree->m_nodes;
	for(List<XmlNode>::iterator in = n.begin(); in != n.end(); ++in)
	{
		if(in->m_tag == tag)
			return XmlpFindSubNode(&*in, SubNodePath + tag.Length());
	}

	return 0;
}


const
XmlNode*
XmlFindNode(
	const XmlNode* Tree,
	const WCHAR* NodePath
	)
/*++

Routine Description:
    Get the element for a specific relative or absolute node path. Absolute
	path includes matching the root element tag while Relative path doesn't.

Arguments:
    Tree - The tree to search
	NodePath - The element path in the *absolute* format "root!level1!level1.1!level1.1.1"
		or the *relative* format "!level1!level1.1!level1.1.1"

Returned Value:
    The element node if found NULL otherwise.

--*/
{
	XmlpAssertValid();
	ASSERT(Tree != 0);

	xwcs_t tag = get_first_node_name(NodePath);

	if((tag.Length() == 0) || (Tree->m_tag == tag))
		return XmlpFindSubNode(Tree, NodePath + tag.Length());

	return 0;
}

static
const
XmlAttribute*
XmlpFindAttribute(
	const XmlNode* Node,
	const WCHAR* AttributeTag
	)
/*++

Routine Description:
    Get an atribute node for a specific element.

Arguments:
    Node - The node to search
	AttributeTag- The attribute tag for that node

Returned Value:
    The attribute node if found NULL otherwise.

--*/
{
	XmlpAssertValid();
	ASSERT(Node != 0);

	const List<XmlAttribute>& a = Node->m_attributes;
	for(List<XmlAttribute>::iterator ia = a.begin(); ia != a.end(); ++ia)
	{
		if(ia->m_tag == AttributeTag)
			return &*ia;
	}

	return 0;
}


const
xwcs_t*
XmlGetNodeFirstValue(
	const XmlNode* Tree,
	const WCHAR* NodePath
	)
/*++

Routine Description:
    Get the first text value of a node.

Arguments:
    Tree - The tree to search
	NodePath - The element path in the *absolute* format "root!level1!level1.1!level1.1.1"
		or the *relative* format "!level1!level1.1!level1.1.1"

Returned Value:
    The element text value if found NULL otherwise.

--*/
{
	XmlpAssertValid();

	Tree = XmlFindNode(Tree, NodePath);
	if(Tree == 0)
		return 0;

	if(Tree->m_values.empty())
		return 0;

	return &Tree->m_values.front().m_value;
}


const
xwcs_t*
XmlGetAttributeValue(
	const XmlNode* Tree,
	const WCHAR* AttributeTag,
	const WCHAR* NodePath /* = NULL */
	)
/*++

Routine Description:
    Get attribute value for a specific node.

Arguments:
    Tree - The tree to search
	NodePath - The element path in the *absolute* format "root!level1!level1.1!level1.1.1"
		or the *relative* format "!level1!level1.1!level1.1.1"
	AttributeTag- the attribute tag for that node

Returned Value:
    Attribute value if found NULL otherwise.

--*/
{
	XmlpAssertValid();

	//
	// If no NodePath supplied assume that Tree is the requested node no update
	//
	if(NodePath != NULL)
	{
		//
		// Find NodePath in Tree
		//
		Tree = XmlFindNode(Tree, NodePath);
	}

	if(Tree == 0)
		return 0;

	const XmlAttribute* attrib = XmlpFindAttribute(Tree, AttributeTag);
	if(attrib == 0)
		return 0;

	return &attrib->m_value;
}


/*++
Description:
	This is the grammer description used with this parser

	[1]  document ::=  prolog element Misc* 

	Prolog 
	[22]  prolog ::=  Misc* (doctypedecl Misc*)? 
	[27]  Misc ::=  Comment | PI |  S 
 
	[28]  doctypedecl ::=  '<!DOCTYPE' S Name (S {problem with system})? S? ('[' (problem maybe netsing)* ']' S?)? '>'
	[15]  Comment ::=  '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->' 

	Processing Instructions
	[16]  PI ::=  '<?' Name (S (Char* - (Char* '?>' Char*)))? '?>' 


	Element 
	[39]  element ::=  EmptyElemTag | STag content ETag
	[44]  EmptyElemTag ::=  '<' Name (S Attribute)* S? '/>' 
 
	[40]  STag ::=  '<' Name (S Attribute)* S? '>'
	[41]  Attribute ::=  Name  S? '=' S? AttValue
	[42]  ETag ::=  '</' Name S? '>' 

 
	[10]  AttValue ::=  '"' [^"]* '"'  | "'" [^']* "'" 



	[43]  content ::=  (element | CharData | CDSect | PI | Comment)* 
 
	[14]  CharData ::=  [^<]*
	[18]  CDSect ::=  '<![CDATA['  (Char* - (Char* ']]>' Char*))  ']]>' 
 


	Names and Tokens 
	[3]  S ::=  (#x20 | #x9 | #xD | #xA)+ 
	[4]  NameChar ::=  Letter | Digit | '.' | '-' | '_' | ':' 
	[5]  Name ::=  (Letter | '_' | ':') (NameChar)* 

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\lib\xmlns.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    xmlns.cpp

Abstract:
  implementation of xml namespace support classes declared in (xmlns.h)

Author:
    Gil Shafriri(gilsh) 9-May-2000

--*/

#include <libpch.h>
#include "xmlns.h"

#include "xmlns.tmh"

//---------------------------------------------------------
//
//  CNameSpaceInfo - implementation 
//
//---------------------------------------------------------



CNameSpaceInfo::CNameSpaceInfo():m_nsstacks( new CNameSpaceStacks)
/*++

Routine Description:
    Constructor - initialize clean namespace information object.
	The object is created with this constructor at the parsing start. 


Arguments:
	None

  
Returned Value:
	None
  
--*/
{

}

CNameSpaceInfo::CNameSpaceInfo(
	CNameSpaceInfo* pNameSpaceInfo
	) : 
	m_nsstacks(pNameSpaceInfo->m_nsstacks)
/*++

Routine Description:
    Constructor - initialize namespace information based on namespace information 
	object of the previous level.	

	
Arguments:
	CNameSpaceInfo -  namespace information of 	previous level.

  
Returned Value:
	None
  
--*/
{

}






CNameSpaceInfo::~CNameSpaceInfo()
/*++

Routine Description:
    dtor - Does cleanup of the namespaces info declared in the lifetime of the object.	
	It pop from the cleanup stack UriNodes objects - get from the information on this objects
	the Uri stack it's  belongs to, pop it from this stack and delete the object.

  
Arguments:
	None	

  
Returned Value:
	None
  
--*/

{
	while(!m_NsCleanStack.empty())
	{
		CNsUriNode* pNsUriNode =  &m_NsCleanStack.front();
		ASSERT(pNsUriNode != NULL);

		//
		// remove from cleanup stack
		// here we can use the method remove because we know
		// the stack the item belongs.
		// this the prefered method to remove item from the list
		// because it does some validation befor removing
		//
		m_NsCleanStack.remove(*pNsUriNode);


		//
		// remove from namespace stack using link information.
		// saved on the node itself. Here we can't use
		// the method remove because we don't know to which 
		// namespace stack it belongs. Fourtunly - the node can unlik 
		// itself without knowing the list it is in. 
		//
		CNsStack::RemoveEntry(&pNsUriNode->m_NsStack);

		delete pNsUriNode;
	}
}


void  
CNameSpaceInfo::SaveUri(
	const xwcs_t& prefix,
	const xwcs_t& uri
	)
/*++

Routine Description:
    Save  prefix\uri namespace declaration. It save this mapping in a stack dedicated to
	the prefix. It also save this mapping in special cleanup stack - so when the object goes out of
	scope -  this namespace declaration will be removed.

  
Arguments:
	None	

  
Returned Value:
	None
  
--*/

{
	P<CNsUriNode> pNsUriNode  = new CNsUriNode(uri);
	m_nsstacks->SaveUri(prefix,pNsUriNode);
	m_NsCleanStack.push_front( *(pNsUriNode.detach()) );
}

const 
xwcs_t 
CNameSpaceInfo::GetUri(
	const xwcs_t& prefix
	)const

/*++

Routine Description:
    Get the current namespace uri for given namespace prefix.

  
Arguments:
	Namespace prefix.

  
Returned Value:
	Namespace uri or empty 	xwcs_t if not exists.
  
--*/

{
	const CNsUriNode* pNsUriNode = m_nsstacks->GetUri(prefix);
	if(pNsUriNode == NULL)
	{
		return xwcs_t();
	}

	return pNsUriNode->Uri();
}


//---------------------------------------------------------
//
//  CNameSpaceInfo::CNameSpaceStacks - implementation 
//
//---------------------------------------------------------


CNameSpaceInfo::CNameSpaceStacks::~CNameSpaceStacks()
/*++

Routine Description:
    remove and delete namespace prefixes stacks.
  
Arguments:
	None.

  
Returned Value:
	None
  
--*/


{
	for(;;)
	{
		CStacksMap::iterator it = m_map.begin();
		if(it == m_map.end() )
		{
			return;				
		}
		CNsStack* pCNsStack = it->second;
		ASSERT(pCNsStack->empty());
	
		delete 	pCNsStack;
		m_map.erase(it);//lint !e534
	}
}



const CNsUriNode* CNameSpaceInfo::CNameSpaceStacks::GetUri(const xwcs_t& prefix)const
/*++

Routine Description:
    Return namespace uri node for given namespace prefix.
	It find the stack for the prefix and pop from it the top item.
	

Arguments:
    IN - prefix	- namespace prefix.

  
Returned Value:
	The uri node in the top of the prefix stack. If not prefix exists - NULL is retuned .
  
--*/
{
	CStacksMap::const_iterator it = m_map.find(prefix);
	if(it == m_map.end())
	{
		return NULL;
	}
	CNsStack*  NsUriStack =  it->second;
	ASSERT(NsUriStack != NULL);

	if(NsUriStack->empty())
	{
		return NULL;
	}
	
	const CNsUriNode* NsUriNode = &NsUriStack->front();
	ASSERT(NsUriNode != NULL);
	return 	NsUriNode;
}



void
CNameSpaceInfo::CNameSpaceStacks::SaveUri(
	const xwcs_t& prefix,
	CNsUriNode* pNsUriNode 
	)

/*++

Routine Description:
    Save namespace uri of given prefix in the stack of that prefix.

Arguments:
    IN - prefix	- namespace prefix
	IN - pNsUriNode uri node to save.

  
Returned Value:
	pointer to CNsUriNode object saved
  
--*/

{
	//
	// get or create stack for the given uri
	//
	CNsStack& NsStack = OpenStack(prefix);

	
	NsStack.push_front(*pNsUriNode);

}

CNsStack& CNameSpaceInfo::CNameSpaceStacks::OpenStack(const xwcs_t& prefix)
/*++

Routine Description:
	Open uri stack for given prefix - If not exists create it


Arguments:
	prefix - namespace prefix.   

  
Returned Value:
	reference to uri stack of the given prefix.
  
--*/

{
	CStacksMap::const_iterator it = m_map.find(prefix);
	if(it != m_map.end())
	{
		return *it->second;
	}

	P<CNsStack> pNsNewStack = new CNsStack;
	bool fSuccess = InsertStack(prefix,pNsNewStack);
	ASSERT(fSuccess);
	DBG_USED(fSuccess);
	return *(pNsNewStack.detach());
}


bool CNameSpaceInfo::CNameSpaceStacks::InsertStack(const xwcs_t& prefix,CNsStack* pCNsStack)
/*++

Routine Description:
	Insert new stack into the map that contains namespace prefix stacks. 


Arguments:
    prefix	- namespace prefix
	pCNsStack - pointer to stack to insert to map

  
Returned Value:
	True is stack inserted - false if elready exists.
*/

{
	return m_map.insert(CStacksMap::value_type(prefix,pCNsStack)).second;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\test\fmapper.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FMapper.h

Abstract:
    memory-mapped-files api abstraction.

	1. each view can be defined to be either FILE_MAP_COPY, or FILE_MAP_READ. 
	2. throws FileMappingError() exceptions on api functions failure.
	3. it is the responsiblity of users to unmap views!
	4. CViewPtr is an auto pointer class to a file mapping view

Author:
    Nir Aides (niraides) 27-dec-99

--*/



#pragma once

              

//
// class objects thrown on exceptions
//
class FileMappingError {};



class CFileMapper
{
public:
    CFileMapper( LPCTSTR FileName );

    DWORD  GetFileSize( void ) const
	{
		return m_size;
	}

	//
	// dwDesiredAccess can be either FILE_MAP_COPY, or FILE_MAP_READ.
	//
    LPVOID MapViewOfFile( DWORD dwDesiredAccess );

private:

	//
	// unimplemented to prevent copy construction or assignment operator
	//
	CFileMapper( const CFileMapper &obj );
	operator=( const CFileMapper &obj );

private:
    CFileHandle m_hFileMap;

	DWORD m_size;
};



//---------------------------------------------------------
//
//  auto file map view class
//
//---------------------------------------------------------
class CViewPtr {
private:
    LPVOID m_p;

public:
    CViewPtr( LPVOID p = NULL ): m_p( p ) {}
   ~CViewPtr() 
   { 
	   if(m_p) UnmapViewOfFile( m_p ); 
   }

	operator LPVOID() const { return m_p; }
    LPVOID* operator&()     { return &m_p; }
    LPVOID  detach()        { LPVOID p = m_p; m_p = NULL; return p; }

private:
    CViewPtr( const CViewPtr& );
    CViewPtr& operator=( const CViewPtr& );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\xml\test\xmltest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XmlTest.cpp

Abstract:
    Xml library test.

	"usage: XmlTest [-h] [[-g|-b] <file name>] [-n <number>]\n\n"
	"    -h     dumps this usage text.\n"
	"    -g     signals <file name> contains a valid xml document (default).\n"
	"    -b     signals <file name> contains a bad   xml document.\n"
	"    -n     executes <number> parsing iterations of documents (default is 1).\n"
	"    if no file name specified, activates test with hardcoded xml files.";
  
Author:
	Nir Aides (niraides)	29-dec-99
    Erez Haba (erezh)		15-Sep-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xml.h>
#include <xmlencode.h>
#include "FMapper.h"

#include "XmlTest.tmh"


//-------------------- global structures and constants ----------------------

const TraceIdEntry XmlTest = L"Xml Test";



const char xOptionSymbol = '-';

const char xUsageText[] =
	"usage: XmlTest [-h] [[-g|-b] <file name>] [-n <number>]\n\n"
	"    -h     dumps this usage text.\n"
	"    -g     signals <file name> contains a valid xml document (default).\n"
	"    -b     signals <file name> contains a bad   xml document.\n"
	"    -n     executes <number> parsing iterations of documents (default is 1).\n\n"
	"    if no file name specified, activates test with hardcoded xml files.";



struct CActivationForm
{
	CActivationForm( void ):
		m_fEmptyForm( true ),
		m_fErrorneousForm( false ),
		m_fExpectingGoodDocument( true ), 
		m_fDumpUsage( false ), 
		m_iterations( 1 ),
		m_FileName( NULL )
	{}

	bool    m_fEmptyForm;
	bool	m_fErrorneousForm;

	bool    m_fExpectingGoodDocument;
	bool    m_fDumpUsage;
	int     m_iterations;
	LPCTSTR m_FileName;
};



CActivationForm g_ActivationForm;



//
// exception class thrown by TestBuffer on test failure
//
class TestFailed {};


	
//
// xGoodDocument & xBadDocument are the hardcoded xml files.
//

const WCHAR xGoodDocument[] =
	L"<?xml aldskjfaj ad;jf adsfj asdf asdf ?>"
	L"<!-- this is a comment - this is a comment -->\r\n"
	L"      \r\n"
	L"<root xmlns=\"gil\"  xmlns:nsprefix2=\"http://ms2.com\"   xmlns:nsprefix=\"http://ms3.com\" >"

		L"<!-- 1st comment in the root node -->\r\n"
		L"<nsprefix:node1  xmlns=\"gil2\" id=\"33\" type = 'xml'>"
			L"the node text 1st line"
			L"<!-- a comment in node 1 -->\r\n"
			L"more text"
			L"<node1.1 nsprefix2:type = 'an empty node'/>"
		L"</nsprefix:node1>"

		L"some root text 1-2"

		L"<![CDATA[ab123 adf a< ]<>]] ]>>!!&&]]]]>"

		L"<!-- 2nd comment in the root node -->\r\n"
		L"<node2 id=\"33\" type = 'xml' length = '\?\?'  >"
			L"<!-- a comment in node 2 -->\r\n"
			L"node 2 text"
			L"<node2.1 />"
			L"<node2.2 xmlns=\"gil2\" xmlns:nsprefix=\"http://ms3.com\" channel = \"1234\" id='111' nsprefix:timeout= \"33\">"
				L"text in node 2.2"
				L"<nsprefix:node2.2.1 tag = 'QoS' xmlns:nsprefix=\"http://ms4.com\">"
					L"<Durable/>"
					L"<Retry/>"
				L"</nsprefix:node2.2.1>\r\n"
				L"more text in node 2.2"
			L"</node2.2>"
		L"</node2>"

		L"<!-- 3rd comment in the root node -->\r\n"
		L"<node3 id=\"33\" type = 'xml'>"
			L"the node text 1st line"
			L"more text"
			L"<node3.2 type = 'empty node'/>"
		L"</node3>"

		L"some root text 3-4"

		L"<!-- 4th comment in the root node -->\r\n"
		L"<node4 id=\"33\" type = 'xml' length = '\?\?'  >"
			L"node 4 text"
			L"<node4.1 />"
			L"<node4.2 id='4.2'>"
				L"text in node 4.2"
				L"<node4.2.1 tag = 'QoS node 4'>"
					L"<Durable/>"
					L"<Retry/>"
				L"</node4.2.1>\r\n"
				L"more text in node 4.2"
			L"</node4.2>"
		L"</node4>"

	L"</root>"
	;








const WCHAR xBadDocument[] =
	L"<?xml aldskjfaj ad;jf adsfj asdf asdf ?>"
	L"<!-- this is a comment - this is a comment -->\r\n"
	L"      \r\n"
	L"<root>"

		L"<!-- 1st comment in the root node -->\r\n"
		L"<node1 id=\"33\" type = 'xml'>"
			L"the node text 1st line"
			L"<!-- a comment in node 1 -->\r\n"
			L"more text"
			L"<node1.1 type = 'an empty node'/>"
		L"</node2>"

		L"some root text 1-2"

		L"<![CDATA[ab123 adf a< ]<>]] ]>>!!&&]]]]>"
	;




//-------------------------- old section ------------------------------------

const WCHAR *ParseDocument( const xwcs_t& doc, bool fExpectingGoodDocument, bool fDump = true )
{
	try
	{
		CAutoXmlNode XmlRootNode;
		const WCHAR   *end = XmlParseDocument(doc, &XmlRootNode);

  		ASSERT((XmlRootNode->m_element.Buffer() + XmlRootNode->m_element.Length()) == end);

		ASSERT(XmlRootNode->m_content.Length() < XmlRootNode->m_element.Length());

		if(XmlRootNode->m_content.Length() != 0)
		{
			//
			// Check end element content for non empty elements
			//
			const WCHAR *pContentEnd = XmlRootNode->m_content.Buffer() +  XmlRootNode->m_content.Length();
			DBG_USED(pContentEnd);
			ASSERT( wcsncmp(pContentEnd, L"</", 2) == 0);
			DWORD prefixLen =  XmlRootNode->m_namespace.m_prefix.Length();
			if(prefixLen)
			{
				ASSERT( wcsncmp(pContentEnd + 3 + prefixLen , XmlRootNode->m_tag.Buffer(), XmlRootNode->m_tag.Length()) == 0);
			}
			else
			{
				ASSERT( wcsncmp(pContentEnd + 2 , XmlRootNode->m_tag.Buffer(), XmlRootNode->m_tag.Length()) == 0);
			}
		}

		TrTRACE( XmlTest, "%d characters parsed successfully.", doc.Length() );

		if(fDump)
		{
			XmlDumpTree(XmlRootNode);
		}

		if(!fExpectingGoodDocument)
		{
			TrERROR( XmlTest, "parsing succeeded while excpeting parsing failure." );
			throw TestFailed();
		}

		return end;
	}
	catch( const bad_document &BadDoc  )
	{
		
		TrTRACE( XmlTest, "parsing raised bad_document exception. offset=%I64d text='%.16ls'", BadDoc.Location() - doc.Buffer(), BadDoc.Location());

		if(fExpectingGoodDocument)
		{
			TrERROR( XmlTest, "parsing failed while excpeting succesful parsing." );
			throw TestFailed();
		}
		return BadDoc.Location();
	}
}



static void TestXmlFind(const WCHAR* Doc)
{
	CAutoXmlNode XmlRootNode;	  
	const WCHAR* End = XmlParseDocument(xwcs_t(Doc, wcslen(Doc)), &XmlRootNode);
	TrTRACE(XmlTest, "Searching %I64d characters document", End - Doc);

	const WCHAR NodePath[] = L"root!node4!node4.2";
	const WCHAR SubNodePath[] = L"!node4!node4.2";

	const XmlNode* node = XmlFindNode(XmlRootNode, NodePath);
	if(node == 0)
	{
		TrTRACE(XmlTest, "Failed to find node '%ls'", NodePath);
	}
	else
	{
		TrTRACE(XmlTest, "Found node '%ls' = 0x%p", NodePath, node);
	}

	ASSERT(node != 0);

	const XmlNode* SubNode = XmlFindNode(XmlRootNode, SubNodePath);
	if(SubNode == 0)
	{
		TrTRACE(XmlTest, "Failed to find sub node '%ls'", SubNodePath);
	}
	else
	{
		TrTRACE(XmlTest, "Found sub node '%ls' = 0x%p", SubNodePath, SubNode);
	}

	ASSERT(SubNode != 0);
	ASSERT(SubNode == node);

	const xwcs_t* value = XmlGetNodeFirstValue(XmlRootNode, NodePath);
	if(value == 0)
	{
		TrTRACE(XmlTest, "Failed to find node '%ls' value", NodePath);
	}
	else
	{
		TrTRACE(XmlTest, "Found node '%ls' value '%.*ls'", NodePath, LOG_XWCS(*value));
	}

	ASSERT(value != 0);

	const xwcs_t* SubValue = XmlGetNodeFirstValue(XmlRootNode, SubNodePath);
	if(SubValue == 0)
	{
		TrTRACE(XmlTest, "Failed to find sub node '%ls' value", SubNodePath);
	}
	else
	{
		TrTRACE(XmlTest, "Found sub node '%ls' value '%.*ls'", SubNodePath, LOG_XWCS(*SubValue));
	}

	ASSERT(SubValue != 0);
	ASSERT(SubValue == value);

	const WCHAR AttributeTag[] = L"id";

	value = XmlGetAttributeValue(XmlRootNode, AttributeTag, NodePath);
	if(value == 0)
	{
		TrTRACE(XmlTest, "Failed to find node '%ls' attribute '%ls' value", NodePath, AttributeTag);
	}
	else
	{
		TrTRACE(XmlTest, "Found node '%ls' attribute '%ls' = '%.*ls'", NodePath, AttributeTag, LOG_XWCS(*value));
	}

	ASSERT(value != 0);

	SubValue = XmlGetAttributeValue(XmlRootNode, AttributeTag, SubNodePath);
	if(SubValue == 0)
	{
		TrTRACE(XmlTest, "Failed to find sub node '%ls' attribute '%ls' value", SubNodePath, AttributeTag);
	}
	else
	{
		TrTRACE(XmlTest, "Found sub node '%ls' attribute '%ls' = '%.*ls'", SubNodePath, AttributeTag, LOG_XWCS(*SubValue));
	}

	ASSERT(SubValue != 0);
	ASSERT(SubValue == value);
}



void ExecBuiltInTest( void )
{
	//
	// forward declaration
	//
	void TestBuffer(const xwcs_t& doc , bool fExpectingGoodDocument, int iterations = 1 );

	printf("Parsing %d characters in good document\n", STRLEN(xGoodDocument) );
	TestBuffer( 
		xwcs_t(xGoodDocument,STRLEN(xGoodDocument)), 
		true, // expecting good document
		g_ActivationForm.m_iterations 
		);

	try
	{
		TrTRACE( XmlTest, "Searching good document." );
		TestXmlFind(xGoodDocument);
	}
	catch(const bad_document& bd)
	{
		TrTRACE(XmlTest, "Bad document exception while searching document. offset=%d text='%.16ls'", (int)(bd.Location() - xGoodDocument), bd.Location());
		throw TestFailed();
	}

	 
	printf("Parsing %d characters in bad document\n", STRLEN(xBadDocument));
	TestBuffer( 
		xwcs_t(xBadDocument,wcslen(xBadDocument)), 
		false, // expecting bad document
		g_ActivationForm.m_iterations 
		);

	//
	// copy the good ducument and make it none null terminated
	//
    AP<WCHAR> NoneNullTerminatingGoodDocument( newwcs(xGoodDocument));
	size_t len = wcslen(NoneNullTerminatingGoodDocument);
	NoneNullTerminatingGoodDocument[len] = L't';


   printf("Parsing %I64d characters in not null terminating good document\n", len);
   TestBuffer( 
		xwcs_t(NoneNullTerminatingGoodDocument, len), 
		true, // expecting good document
		g_ActivationForm.m_iterations 
		);

   
}



//----------------------------------- new section ------------------------------

inline
void DumpUsageText( void )
{
	TrTRACE( XmlTest, "%s\n" , xUsageText );
}



void SetActivationForm( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments to CActivationForm structure.

Arguments:
    main's command line arguments.

Returned Value:
	affects g_ActivationForm.
	on errorneous command line arguments, it sets the g_ActivationForm.m_fErrorneous field

proper command line syntax:
	"usage: XmlTest [-h] [[-g|-b] <file name>] [-n <number>]\n\n"
	"    -h     dumps this usage text.\n"
	"    -g     signals <file name> contains a valid xml document (default).\n"
	"    -b     signals <file name> contains a bad   xml document.\n"
	"    -n     executes <number> parsing iterations of documents (default is 1).\n"
	"    -q     eliminates parser output (good for tests with many iterations).\n\n"
	"    if no file name specified, activates test with hardcoded xml files.";
--*/
{
	g_ActivationForm.m_fErrorneousForm = false;
	g_ActivationForm.m_fEmptyForm      = false;

	if(argc == 1)
	{
		g_ActivationForm.m_fEmptyForm = true;
		return;
	}
	
	for(int index = 1; index < argc; index++)
	{
		if(argv[index][0] != xOptionSymbol)	
		{
			//
			// consider argument as file name
			//
			g_ActivationForm.m_FileName = argv[index];
			continue;
		}

		//
		// option symbols should consist of 2 chars only! '-' and 'xx'
		//
		if(argv[index][2] != 0)
		{
			g_ActivationForm.m_fErrorneousForm = true;
			return;
		}

		//
		// else consider argument as option and switch upon its second character.
		//
		switch(argv[index][1])
		{
		case 'G':
		case 'g':	// expect valid xml input files
			g_ActivationForm.m_fExpectingGoodDocument = true;
			break;

		case 'B':
		case 'b':	// expect bad xml input filed
			g_ActivationForm.m_fExpectingGoodDocument = false;
			break;

		case 'N':
		case 'n':	// set iterations number
			{
				index++;
			
				int result = swscanf( argv[index], L"%d", &g_ActivationForm.m_iterations );

				if(result == 0 || g_ActivationForm.m_iterations <= 0)
				{
					g_ActivationForm.m_fErrorneousForm = true;
					return;
				}
			}
			break;

		case 'h':	// output help
			g_ActivationForm.m_fDumpUsage = true;
			break;

		default:
			g_ActivationForm.m_fErrorneousForm = true;
			return;
		};
	}

	return;
}


static void EncodeTest()
{
	std::wstring  wstr = L"this is string without special caractes";
	std::wostringstream owstr;
	owstr<<CXmlEncode(xwcs_t(wstr.c_str(), wstr.size()));
	if(!(owstr.str() == wstr))
	{
		TrTRACE( XmlTest, "wrong xml encoding");
		throw TestFailed();
	}


	owstr.str(L"");
	wstr = L"this is string with  special caractes like < and > and spaces ";
	owstr<<CXmlEncode(xwcs_t(wstr.c_str(), wstr.size()));
	std::wstring encoded = 	owstr.str();
	if(encoded == wstr)
	{
		TrTRACE( XmlTest, "wrong xml encoding");
		throw TestFailed();
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(xwcs_t(encoded.c_str(), encoded.size()));
	xwcs_t  wcsDecoded =  XmlDecode.get();
	std::wstring wstrDecoded (wcsDecoded.Buffer(), wcsDecoded.Length());
	if(!(wstrDecoded ==  wstr) )
	{
		TrTRACE( XmlTest, "wrong xml encoding");
		throw TestFailed();
	}

}




void TestBuffer(const  xwcs_t& doc, bool fExpectingGoodDocument, int iterations = 1 )
/*++

Routine Description:
    parses the buffer n times, where n = 'iterations'.
	checks the results for consistency, and published performance results.
	consistency check is based on the value returned from the parser, which happens 
	to be the offset to the last character parsed by the parser.

Arguments:
    Parameters.

Returned Value:
	if reults are inconsistent or if ParseDocument() throws 'UnexpectedResults' 
	exception, then a 'TestFailed' exception is raised.

--*/
{
	const WCHAR *LastResultOffset = NULL;

	LARGE_INTEGER CounterFrequency;
	QueryPerformanceFrequency( &CounterFrequency );

	LARGE_INTEGER CounterStart;
	QueryPerformanceCounter( &CounterStart );

	for( int i = 0; i < iterations; i++)
	{
		const WCHAR *ResultOffset = ParseDocument( 
										doc,
										fExpectingGoodDocument,
										i == 0		// fDump (if true dumps parse tree)
										); 
		if(i == 0)
		{
			LastResultOffset = ResultOffset;
		}
		else if(ResultOffset != LastResultOffset)
		{
			TrTRACE( XmlTest, "INCONSISTENCY! on iteration %d.", i );
			throw TestFailed();
		}
	}

	LARGE_INTEGER CounterStop;
	QueryPerformanceCounter( &CounterStop );

	LONGLONG CounterMicroSec = ((CounterStop.QuadPart - CounterStart.QuadPart) * (1000000000 / CounterFrequency.QuadPart)) / 1000;
	printf("parsed %I64d characters in document.\n", LastResultOffset - doc.Buffer() );
	printf("parsed %I64d iterations in %I64d usec.\n", iterations, CounterMicroSec );
	printf("document parsed %I64d times per second.\n", (LONGLONG(1000000) * iterations) / CounterMicroSec );
}

static bool IsValidUnicodeFile(const WCHAR* pBuffer,DWORD size)
{
	const DWORD xUnicodeStartDword=0X3CFEFF;
	if(size < sizeof(DWORD) || pBuffer == NULL)
	{
		return false;
	}
	DWORD UnicodeStartDword=*(DWORD*)pBuffer; 
	return  UnicodeStartDword  == xUnicodeStartDword;
}


void ExecFileTest( void )
/*++

Routine Description:
	intiates test with specified file name.

Arguments:
    Parameters.

Returned Value:
	rethrows the FileMapper's exception, if any.

--*/
{
	TrTRACE( XmlTest, "parsing xml file \'%ls\'.", g_ActivationForm.m_FileName );
	
	CFileMapper  FileMap( g_ActivationForm.m_FileName );
	CViewPtr     view( FileMap.MapViewOfFile( FILE_MAP_READ ) );
	const WCHAR  *buffer = static_cast<WCHAR*>( static_cast<LPVOID>( view ) );


	if(!IsValidUnicodeFile(buffer,FileMap.GetFileSize()))
	{
		TrWARNING( XmlTest, "the xml file is not valid unicode file" );
		throw TestFailed();
	}
	
	DWORD len = (FileMap.GetFileSize() +1) / sizeof(WCHAR);
	TestBuffer(xwcs_t(buffer,len), g_ActivationForm.m_fExpectingGoodDocument, g_ActivationForm.m_iterations );
}



void ExecActivationForm( void )
{
	EncodeTest();


	//
	// if -h signaled in command line arguments dump usage text, and return.
	//
	if(g_ActivationForm.m_fDumpUsage)	
	{
		DumpUsageText();
		return;
	}

	//
	// if no file name specified. proceed with internal test
	//
	try
	{
		printf("TEST START\n");

		if(g_ActivationForm.m_FileName == NULL)	 
		{
			ExecBuiltInTest();
		}
		else
		{
			ExecFileTest();
		}

		printf("TEST PASSED\n");
	}
	catch( const TestFailed& )
	{
		printf("TEST FAILED\n");
		exit( 1 );
	}
	catch( const FileMappingError& )
	{
		printf("ERROR: file mapping error.\n");
		printf("TEST ABORTED\n");
		exit( 2 );
	}
		
}




extern "C" int _cdecl  _tmain( int argc, LPCTSTR argv[] )
/*++

Routine Description:
    Test Xml library

Arguments:
    Parameters.

Returned Value:
    0 - parser ok.
	1 - parser failed.
	2 - file mapping error.
	3 - bad argument list in command line

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&XmlTest, 1);

	XmlInitialize();

	SetActivationForm( argc, argv );
	if(g_ActivationForm.m_fErrorneousForm)
	{
		DumpUsageText();
		return 3;
	}

	//
	// try catches file mapping errors
	//
	ExecActivationForm();
	
	WPP_CLEANUP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\dbsys.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		dbsys.h

Abstract:
	"General purpose" definitions for the Database interface dll.

Author:
	Doron Juster (DoronJ)

Revisions:
   9-jan-96   DoronJ    Created
--*/

#ifndef __DBSYS_H__
#define __DBSYS_H__

// Include the system specific definition files

#include <_stdh.h>

#ifndef PURE
#define PURE  =0
#endif

//
//  don't use SQL A and W exports
//
#define SQL_NOUNICODEMAP

#include "mqdbmgr.h"

#endif // __DBSYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\dbodbc.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		dbodbc.h

Abstract:
   Define a database class, for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      09-Jan-96   Created

--*/

#ifndef __DBODBC_H__
#define __DBODBC_H__

#include "mqdbodbc.h"
#include "tblodbc.h"

class CMQODBCDataBase
{
public:
   CMQODBCDataBase() ;   // Constructor.
   ~CMQODBCDataBase() ;  // Destructor.

   MQDBSTATUS Connect(LPMQDBOPENDATABASE pOpen) ;
   MQDBSTATUS Disconnect() ;

   MQDBSTATUS GetVersion( IN LPMQDBVERSION  pVersion) ;

   MQDBSTATUS Transaction( IN MQDBTRANSACOP mqdbTransac) ;

   MQDBSTATUS GetSize( DWORD *pSize ) ;

   inline MQDBSTATUS SetMultipleQueries( IN BOOL fEnable )
      {
         m_fEnableMultipleQueries = fEnable ;
         return MQDB_OK ;
      }

   inline MQDBSTATUS SetNoLockQueries( IN BOOL fEnable )
      {
         m_fNoLockQueries = fEnable ;
         return MQDB_OK ;
      }

   inline BOOL  GetMultipleQueriesState( ) const
      {
         return m_fEnableMultipleQueries ;
      }

   inline BOOL  GetNoLockQueriesState( ) const
      {
         return m_fNoLockQueries ;
      }

   inline DWORD GetDMBSType( ) const
      {
         return m_dwDMBSType ;
      }

   MQDBSTATUS  GetDBStatus( IN SDWORD  sdwNativeError,
                            IN UCHAR   *pSqlError ) ;

   MQDBSTATUS  CheckSqlStatus( IN RETCODE        sqlError,
	                            IN CMQDBOdbcSTMT  *pStatement,
                               IN HSTMT          hStmt = SQL_NULL_HSTMT ) ;

   MQDBSTATUS  Escape( IN LPSTR lpszCommand ) ;

protected:
   HDBC  GethDbc() { return m_hConnection ; }

   friend MQDBSTATUS CMQODBCTable::Init(IN MQDBHANDLE hDatabase,
                                        IN LPSTR      lpszTableName) ;

   friend MQDBSTATUS CMQODBCTable::OpenJoin(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout) ;

private:
   DWORD    m_SQLConformance ;
	HDBC		m_hConnection;	 // Connection handle
	BOOL		m_fConnected;   // TRUE if connection to Data source succeeded

	char     m_szNameOfTypes[ MQDB_ODBC_NUMOF_TYPES][ MQDB_TYPE_NAME_LEN ] ;
                                       // Holds the name of data types.
   DWORD    m_dwDMBSType ;

   BOOL     m_fEnableMultipleQueries ;
    //
    // If TRUE, then multiple parallel queries are enabled. Important when
    // working with SQL server. If enabled, then statement options must be
    // properly set. FALSE by default.

   BOOL     m_fNoLockQueries ;
    //
    //  If TRUE, then query are done in "nolock" mode and this enable
    //  more concurency.

#ifdef _DEBUG
   int      m_OutstandingTransactions ;
      // Count number of outstanding transactions (transctions which
      // started but didn't yet commited or rollbacked).
#endif
} ;

#endif // __DBODBC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\apiodbc.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		apiodbc.cpp

Abstract:
   Implement the api exported by mqdbmgr.dll.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      09-Jan-96   Created

--*/

#include "dbsys.h"
#include "mqdbodbc.h"
#include "dbodbc.h"
#include "tblodbc.h"

#include "apiodbc.tmh"

MQDBSTATUS APIENTRY  MQDBGetVersion( IN MQDBHANDLE         hDatabase,
                                     IN OUT LPMQDBVERSION  pVersion )
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBGetVersion")));

   MQDBSTATUS dbstatus = MQDB_OK ;
   try
   {
      pVersion->dwMinor = 0 ;
      pVersion->dwMajor = 1 ;
      pVersion->dwProvider = MQDB_ODBC ;

      if (hDatabase)
      {
         // RetrieveDBMS name and version
         CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
         dbstatus = pDatabase->GetVersion( pVersion ) ;
      }
      else
      {
         pVersion->szDBMSName[0] = '\0' ;
         pVersion->szDBMSVer[0] = '\0' ;
      }
   }
   catch(...)
   {
      dbstatus = MQDB_E_INVALID_DATA ;
   }
   return dbstatus ;
}

STATIC int g_cInits = 0 ;

MQDBSTATUS APIENTRY  MQDBInitialize()
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBInitialize")));

   if (g_cInits == 0) {
      // Allocate the ODBC environment ;
      RETCODE sqlstatus = ::SQLAllocEnv(&g_hEnv);
		if (!ODBC_SUCCESS(sqlstatus)) {
         return MQDB_E_DATABASE ;
	   }
   }
   g_cInits++ ;
   return MQDB_OK ;
}


MQDBSTATUS APIENTRY  MQDBTerminate()
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBTerminate")));

   if (g_cInits == 0) {
      return  MQDB_E_INVALID_CALL ;
   }

   g_cInits-- ;
   if (g_cInits == 0) {
      // Free the ODBC environment ;
      ASSERT(g_hEnv != SQL_NULL_HENV) ;
      RETCODE sqlstatus = ::SQLFreeEnv(g_hEnv);
		if (!ODBC_SUCCESS(sqlstatus)) {
			return MQDB_E_DATABASE ;
      }
      g_hEnv = SQL_NULL_HENV;
	}
   return MQDB_OK ;
}


MQDBSTATUS APIENTRY  MQDBOpenDatabase(
                           IN OUT  LPMQDBOPENDATABASE pOpenDatabase)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBOpenDatabase")));

   if (g_hEnv == SQL_NULL_HENV) {
      return  MQDB_E_DLL_NOT_INIT ;
   }

   MQDBSTATUS status ;
   try
   {
      CMQODBCDataBase *pDatabase = new CMQODBCDataBase() ;
      ASSERT(pDatabase) ;
      status = pDatabase->Connect(pOpenDatabase) ;
      if (status == MQDB_OK) {
         pOpenDatabase->hDatabase = (MQDBHANDLE) pDatabase ;
      }
      else {
         // Cannot connect. Cleanup and delete the database object.
         MQDBSTATUS tmpstatus = pDatabase->Disconnect() ;
         UNREFERENCED_PARAMETER(tmpstatus);
         delete pDatabase ;
      }
   }
   catch(...)
   {
      status = MQDB_E_OUTOFMEMORY ;
   }
   return status ;

}


MQDBSTATUS APIENTRY  MQDBCloseDatabase(
                           IN MQDBHANDLE  hDatabase)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBCloseDatabase")));

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles.
	try
	{
      dbstatus = pDatabase->Disconnect() ;
      delete pDatabase ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenTable(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszTableName,
                     OUT LPMQDBHANDLE  phTable)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBOpenTable")));

   MQDBSTATUS dbstatus ;
   CMQODBCTable *pTable = NULL ;

   try
   {

      pTable = new CMQODBCTable() ;
      ASSERT(pTable) ;

      dbstatus = pTable->Init( hDatabase, lpszTableName ) ;
      if (dbstatus == MQDB_OK) {
         *phTable = (MQDBHANDLE) pTable ;
      }
   }
	catch(...)
	{
      if (!phTable) {
         dbstatus = MQDB_E_INVALID_DATA ;
      }
      else if (!pTable) {
   	  dbstatus = MQDB_E_OUTOFMEMORY ;
      }
      else {
         dbstatus = MQDB_E_UNKNOWN ;
      }
	}

   if (dbstatus != MQDB_OK) {
      if (pTable) {
         delete pTable ;
      }
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBCloseTable(
                     IN MQDBHANDLE     hTable)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBCloseTable")));

   if (!hTable) {
      return MQDB_E_BAD_HTABLE ;
   }

   MQDBSTATUS dbstatus ;
   CMQODBCTable *pTable = (CMQODBCTable *) hTable ;

   try
   {
      dbstatus = pTable->Close() ;
   }
   catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   if (dbstatus == MQDB_OK) {
      delete pTable ;
   }
   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBGetTableCount(IN MQDBHANDLE  hTable,
                                       OUT UINT       *puCount,
                                 IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                                       IN LONG        cWhere,
                                       IN MQDBOP      opWhere)
{
   if (!hTable)
   {
      return MQDB_E_BAD_HTABLE ;
   }

   MQDBSTATUS dbstatus ;
   CMQODBCTable *pTable = (CMQODBCTable *) hTable ;

   try
   {
      dbstatus = pTable->GetCount(puCount,
                                  pWhereColumnSearch,
                                  cWhere,
                                  opWhere) ;
   }
   catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBInsertRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN OUT LPMQDBHANDLE  lphInsert)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBInsertRecord")));

   if (cColumns <= 0) {
      return MQDB_E_BAD_CCOLUMNS ;
   }

   CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      if (!lphInsert) {
         // Direct execution. Preparation not needed.
         dbstatus = pTable->DirectInsertExec(  aColumnVal,
                                               cColumns) ;
      }
      else if (!(*lphInsert)) {
         // Prepare for future use and execute.
         dbstatus = pTable->PrepareInsert(  aColumnVal,
                                            cColumns) ;
         if (dbstatus == MQDB_OK) {
	         CMQDBOdbcSTMT *pStatement = pTable->GetInsertStmt() ;
	         ASSERT(pStatement) ;
            dbstatus = pTable->ExecuteInsert(  pStatement,
                                               aColumnVal,
                                               cColumns) ;
            if (dbstatus == MQDB_OK) {
               *lphInsert = (MQDBHANDLE) pStatement ;
            }
            else {
               // Could not execute the prepare insert.
               // Delete the prepared statement.
               pTable->DeletePreparedInsert() ;
            }
         }
      }
      else {
         // Use prepared statement. Bind and execute.
         dbstatus = pTable->ExecuteInsert( (CMQDBOdbcSTMT *)(*lphInsert),
                                            aColumnVal,
                                            cColumns) ;
      }
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBUpdateRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN OUT LPMQDBHANDLE  lphUpdate)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBUpdateRecord")));

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->UpdateRecord(  aColumnVal,
                                        cColumns,
                                        pWhereColumnSearch,
                                        lpszSearchCondition,
                                        1,
                                        AND,
                                        lphUpdate) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBUpdateRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN OUT LPMQDBHANDLE  lphUpdate)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBUpdateRecordEx")));

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->UpdateRecord(  aColumnVal,
                                        cColumns,
                                        pWhereColumnSearch,
                                        NULL,
                                        cWhere,
                                        opWhere,
                                        lphUpdate) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}

MQDBSTATUS APIENTRY  MQDBDeleteRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBDeleteRecordEx")));

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->DeleteRecord( pWhereColumnSearch,
                                       NULL,
                                       cWhere,
                                       opWhere) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBDeleteRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBDeleteRecord")));

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->DeleteRecord( pWhereColumnSearch,
                                       lpszSearchCondition,
                                       1,
                                       AND) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBOpenQuery")));

   MQDBSTATUS dbstatus ;
	// Guard against illegal handles and bad pointers.
   try
   {
      dbstatus = ((CMQODBCTable *) hTable)->OpenQuery(
                                    aColumnVal,
                                    cColumns,
                                    pWhereColumnSearch,
                                    lpszSearchCondition,
                                    1,
                                    AND,
                                    lpOrder,
                                    cOrders,
                                    phQuery,
                                    fGetFirst,
                                    dwTimeout ) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenQueryEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBOpenQueryEx")));

   MQDBSTATUS dbstatus ;
	// Guard against illegal handles and bad pointers.
   try
   {
      dbstatus = ((CMQODBCTable *) hTable)->OpenQuery(
                                    aColumnVal,
                                    cColumns,
                                    pWhereColumnSearch,
                                    NULL,
                                    cWhere,
                                    opWhere,
                                    lpOrder,
                                    cOrders,
                                    phQuery,
                                    fGetFirst,
                                    dwTimeout ) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBGetData(
                     IN MQDBHANDLE     hQuery,
                     IN MQDBCOLUMNVAL  aColumnVal[])
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBGetData")));

   MQDBSTATUS dbstatus ;
   try
   {
	   CMQDBOdbcSTMT *pStatement = (CMQDBOdbcSTMT *) hQuery ;
      dbstatus = pStatement->RetrieveRecordData( aColumnVal ) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HQUERY ;
   }
   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBCloseQuery(
                     IN MQDBHANDLE     hQuery)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBCloseQuery")));

   try
   {
	   CMQDBOdbcSTMT *pStatement = (CMQDBOdbcSTMT *) hQuery ;
      delete pStatement ;
      return MQDB_OK ;
   }
	catch(...)
   {
      return MQDB_E_BAD_HQUERY ;
   }
}


MQDBSTATUS APIENTRY  MQDBOpenJoinQuery(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBOpenJoinQuery")));

   MQDBSTATUS dbstatus ;
   CMQODBCTable * pTable ;

   try
   {
      pTable = new CMQODBCTable( hDatabase ) ;
      ASSERT(pTable) ;
      P<CMQODBCTable> p(pTable) ; // AutoDelete pointer.

      dbstatus = pTable->OpenJoin(  hDatabase,
                                    lpszLeftTableName,
                                    lpszRightTableName,
                                    aColumnVal,
                                    cLefts,
                                    cRights,
                                    opJoin,
                                    pWhereColumnSearch,
                                    cWhereLeft,
                                    cWhereRight,
                                    opWhere,
                                    pOrder,
                                    cOrders,
                                    phQuery,
                                    fGetFirst,
                                    dwTimeout ) ;
   }
   catch(...)
   {
      dbstatus = MQDB_E_INVALID_DATA ;
   }
   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenAggrQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout)
{
    DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBOpenAggrQuery")));

    MQDBSTATUS dbstatus ;
     // Guard against illegal handles and bad pointers.
    try
    {
       dbstatus = ((CMQODBCTable *) hTable)->OpenAggrQuery(
                                        aColumnVal,
                                        mqdbAggr,
                                        pWhereColumnSearch,
                                        NULL,
                                        cWhere,
                                        opWhere,
                                        dwTimeout ) ;
    }
	catch(...)
    {
       dbstatus = MQDB_E_BAD_HTABLE ;
    }

    return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBTransaction(
                     IN  MQDBHANDLE     hDatabase,
                     IN  MQDBTRANSACOP  mqdbTransac)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBTransaction")));

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
	try
	{
      dbstatus = pDatabase->Transaction( mqdbTransac) ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBFreeBuf( IN LPVOID lpMem )
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBFreeBuf")));

   MQDBSTATUS dbstatus = MQDB_OK ;
	// Guard against bad pointers.
	try
	{
      delete lpMem ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_INVALID_DATA ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBEscape(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszCommand )
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBEscape")));

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
	try
	{
      dbstatus = pDatabase->Escape( lpszCommand ) ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBSetOption(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBOPTION     mqdbOption,
                     IN DWORD          dwValue,
                     IN LPSTR          lpszValue,
                     IN MQDBHANDLE     hQuery )
{
	DBGMSG(( DBGMOD_PSAPI, DBGLVL_TRACE, TEXT("In MQDBSetOption") )) ;

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
	try
	{
      switch(mqdbOption)
      {
         case MQDBOPT_MULTIPLE_QUERIES:
            ASSERT(lpszValue == NULL) ;
            dbstatus = pDatabase->SetMultipleQueries( (BOOL) dwValue ) ;
            break ;

         case MQDBOPT_NOLOCK_QUERIES:
            ASSERT(lpszValue == NULL) ;
            dbstatus = pDatabase->SetNoLockQueries( (BOOL) dwValue ) ;
            break ;

         case MQDBOPT_INSERT_IDENTITY:
            ASSERT(lpszValue) ;
            char buff[512] ;
            lstrcpyA(buff, "set identity_insert ") ;
            lstrcatA(buff, lpszValue) ;
            if (dwValue)
            {
               lstrcatA(buff, " on") ;
            }
            else
            {
               lstrcatA(buff, " off") ;
            }
            dbstatus = MQDBEscape( hDatabase,
                                   buff ) ;
            break ;

         case MQDBOPT_QUERY_TIMEOUT:
         {
            ASSERT( hQuery ) ;
      	   CMQDBOdbcSTMT *pStatement = (CMQDBOdbcSTMT *) hQuery ;
            dbstatus = pStatement->SetQueryTimeout( dwValue ) ;
         }
            break ;

         default:
            dbstatus = MQDB_E_INVALID_DATA ;
            break ;
      }
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBExecute(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBHANDLE     hTable,
                     IN MQDBEXEC       ExecOp,
                     IN OUT DWORD      *pdwValue,
                     IN LPSTR          lpszValue )
{
    UNREFERENCED_PARAMETER(lpszValue);
	DBGMSG(( DBGMOD_PSAPI, DBGLVL_TRACE, TEXT("In MQDBExecute") )) ;

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   //
	try
	{
      switch(ExecOp)
      {
         case MQDBEXEC_UPDATE_STATISTICS:
         {
            CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
            dbstatus = pTable->UpdateStatistics() ;
            break ;
         }

         case MQDBEXEC_SPACE_USED:
         {
            //
            // On input, *pdwSize should be null if DBCC update is not
            // required. Else dbcc will be performed.
            //
            CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
            dbstatus = pDatabase->GetSize( pdwValue ) ;
            break ;
         }

         default:
            dbstatus = MQDB_E_INVALID_DATA ;
            break ;
      }
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBTruncateTable(
                     IN MQDBHANDLE        hTable)
{
	DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,TEXT("In MQDBTruncateTable")));

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->Truncate() ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\dbodbc.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		dbodbc.cpp

Abstract:
   Implement the database class for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   NirB          1995      Create first version, under different name.
   DoronJ      09-Jan-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "dbodbc.h"
#include "odbcstmt.h"
#include "odbcss.h"  // SQL server specific

#include "dbodbc.tmh"

// Constructor
CMQODBCDataBase::CMQODBCDataBase()
							: m_hConnection(SQL_NULL_HDBC),
							  m_fConnected(FALSE),
                       m_dwDMBSType(MQDBMSTYPE_UNKNOWN),
                       m_fEnableMultipleQueries(FALSE),
                       m_fNoLockQueries(FALSE),
                       m_SQLConformance(0)
{
#ifdef _DEBUG
   m_OutstandingTransactions = 0 ;
#endif
}

// Destructor
CMQODBCDataBase::~CMQODBCDataBase()
{
   ASSERT(m_OutstandingTransactions == 0) ;
}

// Connect to the data source. If necessary, create a new database.
MQDBSTATUS CMQODBCDataBase::Connect(LPMQDBOPENDATABASE pOpen)
{
   RETCODE sqlstatus	= SQL_SUCCESS;
   MQDBSTATUS dbstatus = MQDB_OK ;

   //
   // See if ODBC driver manager recognize the DSN name.
   //
   UWORD uDirection = SQL_FETCH_FIRST ;
   do
   {
      UCHAR szDSNDescription[ 256 ] ;
      UCHAR szDSNName[ SQL_MAX_DSN_LENGTH ] ;
      SWORD cDSNName ;
      SWORD cDSNDesc ;

      sqlstatus = SQLDataSources( g_hEnv,
                                  uDirection,
                                  szDSNName,
                                  SQL_MAX_DSN_LENGTH,
                                  &cDSNName,
                                  szDSNDescription,
                                  256,
                                  &cDSNDesc ) ;

      if ((sqlstatus == SQL_SUCCESS) &&
          (lstrcmpiA(pOpen->lpszDatabaseName, (char *) szDSNName) == 0))
      {
         if (lstrcmpiA("SQL Server", (char *) szDSNDescription) == 0)
         {
            m_dwDMBSType = MQDBMSTYPE_SQLSERVER ;
         }
         else
         {
            //
            // At present we support only SQL server.
            //
#ifdef _DEBUG
            WCHAR wDesc[128] ;
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 (char *)szDSNDescription,
                                 -1,
                                 wDesc,
                                 128 ) ;
            DBGMSG(( DBGMOD_PSAPI,DBGLVL_WARNING,
                           TEXT("MQDBMGR: Found MQIS on  %ls"), wDesc)) ;
            ASSERT(0) ;
#endif
         }
         break ;
      }
      uDirection = SQL_FETCH_NEXT ;
   } while (sqlstatus == SQL_SUCCESS) ;

   //
	// Allocate an ODBC connection handle
   //
	sqlstatus = ::SQLAllocConnect(
							g_hEnv,
							&m_hConnection);
	if (!ODBC_SUCCESS(sqlstatus))
		goto checkerror ;

	// Enable read and write
	sqlstatus = ::SQLSetConnectOption(
							m_hConnection,
							SQL_ACCESS_MODE,
							SQL_MODE_READ_WRITE);
	if (!ODBC_SUCCESS(sqlstatus))
		goto checkerror ;

	// Enable Auto commit.
	sqlstatus = ::SQLSetConnectOption(
							m_hConnection,
							SQL_AUTOCOMMIT,
							SQL_AUTOCOMMIT_ON);
	if (!ODBC_SUCCESS(sqlstatus))
		goto checkerror ;

   //
   //  Set security option. This option is relevant only for SQL server.
   //  Must be set before doing the connection.
   //
   if (m_dwDMBSType == MQDBMSTYPE_SQLSERVER)
   {
      sqlstatus = ::SQLSetConnectOption(
			            				m_hConnection,
                                 SQL_INTEGRATED_SECURITY,
                                 SQL_IS_ON ) ;
      if (!ODBC_SUCCESS(sqlstatus))
         goto checkerror ;
   }

	//
	// Connect to the data source
	//
	sqlstatus = ::SQLConnect(
						m_hConnection,
						(UCHAR *) pOpen->lpszDatabaseName,
						SQL_NTS,
						(UCHAR *) pOpen->lpszUserName,
						SQL_NTS,
						(UCHAR *) pOpen->lpszPassword,
						SQL_NTS);

   if (ODBC_SUCCESS_WINFO(sqlstatus))
   {
		if (OdbcStateIs(m_hConnection,
                      SQL_NULL_HSTMT,
                      OERR_GENERAL_WARNING))
      {
         //
         // This happen with SQL server. It tells that context was
         // changed to falcon. It's a success.
         //
         sqlstatus = SQL_SUCCESS ;
      }
   }

	if (!ODBC_SUCCESS(sqlstatus))
	{
      //
		// If the error is not "data source not found", terminate
      //
		if (!OdbcStateIs(m_hConnection,
                       SQL_NULL_HSTMT,
                       OERR_DSN_NOT_FOUND))
   		goto checkerror ;

      if (!pOpen->fCreate)
      {
         //
         // If database not found and caller don't want to create it
         // then leave.
         //
         return  MQDB_E_DB_NOT_FOUND ;
      }

      //
      // We can't create an SQL server database.
      //
      ASSERT(!pOpen->fCreate) ;
      return  MQDB_E_DB_NOT_FOUND ;
	}
	m_fConnected = TRUE ;

   //
   // Determine SQL conformance
   //
   SWORD swDummy ;
   sqlstatus = ::SQLGetInfo( m_hConnection,
                             SQL_ODBC_SQL_CONFORMANCE,
                             (PTR) &m_SQLConformance,
                             sizeof(m_SQLConformance),
                             &swDummy) ;
	if (!ODBC_SUCCESS(sqlstatus))
      goto checkerror ;

   ASSERT(!(m_SQLConformance & 0x0ffff0000)) ; // it's a 16bit value.

   // Find the data-source specific names for data types.
   int index ;
   for ( index = 0 ; index < MQDB_ODBC_NUMOF_TYPES ; index++ )
   {
      sqlstatus = GetDataTypeName(
   						m_hConnection,
                     dbODBCSQLTypes[ index ],
	                  m_szNameOfTypes[ index ],
	                  (SDWORD) MQDB_TYPE_NAME_LEN) ;
	   if (!ODBC_SUCCESS(sqlstatus))
         goto checkerror ;
   }

   if (m_dwDMBSType == MQDBMSTYPE_SQLSERVER)
   {
      //
      // Set prepared statement option. Relevant for SQL server only.
      //
      sqlstatus = ::SQLSetConnectOption(
		            				m_hConnection,
                              SQL_USE_PROCEDURE_FOR_PREPARE,
                              SQL_UP_ON_DROP ) ;
      if (!ODBC_SUCCESS(sqlstatus))
         goto checkerror ;
   }

   //
   // Check SQL version. Falcon can't run on SQL6.5 SP2 (build 240).
   //
   MQDBVERSION  dbVersion ;
   dbstatus = GetVersion( &dbVersion) ;
   if (dbstatus == MQDB_OK)
   {
      LPSTR lpVer = strchr(dbVersion.szDBMSVer, '6') ;
      if (lpVer)
      {
         if (!lstrcmpA(lpVer, "6.50.0240"))
         {
            dbstatus =  MQDB_E_UNSUPPORTED_DBMS ;
         }
      }
   }
   else
   {
      ASSERT(dbstatus == MQDB_OK) ;
      dbstatus = MQDB_OK ;   // this is not a major problem.
   }

#ifdef _DEBUG
   //
   // Print version of database.
   // For beta1, assert it's SQL server.
   //
   if ((dbstatus == MQDB_OK)  ||
       (dbstatus == MQDB_E_UNSUPPORTED_DBMS))
   {
      int icmp = lstrcmpA(dbVersion.szDBMSName, "Microsoft SQL Server") ;
      ASSERT(icmp == 0) ; // at present we support only SQL server.
      ASSERT(m_dwDMBSType == MQDBMSTYPE_SQLSERVER) ;

      WCHAR wName[128] ;
      WCHAR wVer[128] ;
      MultiByteToWideChar( CP_ACP,
                           0,
                           dbVersion.szDBMSName,
                           -1,
                           wName,
                           128 ) ;
      MultiByteToWideChar( CP_ACP,
                           0,
                           dbVersion.szDBMSVer,
                           -1,
                           wVer,
                           128 ) ;

	   DBGMSG(( DBGMOD_PSAPI,DBGLVL_TRACE,
               TEXT("Connect to database: %ls, Version %ls"), wName, wVer)) ;
   }
#endif

   return dbstatus ;

checkerror:
   if (m_hConnection != SQL_NULL_HDBC)
   {
      if (OdbcStateIs( m_hConnection, SQL_NULL_HSTMT, OERR_DBMS_NOT_AVAILABLE))
      {
         dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
      }
   }
   if (dbstatus == MQDB_OK)
   {
      dbstatus = MQDB_E_DATABASE ;
   }

   return dbstatus ;
}


// Disconnect from the data source.
MQDBSTATUS CMQODBCDataBase::Disconnect()
{
   RETCODE sqlstatus	= SQL_SUCCESS;
   MQDBSTATUS  dbstatus = MQDB_OK ;

	// Free connection
	if (m_hConnection != SQL_NULL_HDBC) {
		// Disconect
		if (m_fConnected) {
			sqlstatus = ::SQLDisconnect(m_hConnection);
			if (!ODBC_SUCCESS(sqlstatus)) {
				dbstatus = MQDB_E_DATABASE ;
         }
         else {
			   m_fConnected = FALSE;
         }
		}

		// Free the connection handle
		sqlstatus = ::SQLFreeConnect(m_hConnection);
		if (!ODBC_SUCCESS(sqlstatus)) {
			dbstatus = MQDB_E_DATABASE ;
      }
      else {
		   m_hConnection = SQL_NULL_HDBC;
      }
	}

   return dbstatus ;
}

MQDBSTATUS CMQODBCDataBase::GetVersion( IN LPMQDBVERSION  pVersion)
{
   RETCODE sqlstatus ;
   SWORD dwSize ;
   MQDBSTATUS dbstatus = MQDB_OK ;

   // Get the DBMS name
   sqlstatus = ::SQLGetInfo( m_hConnection,
                             SQL_DBMS_NAME,
                             pVersion->szDBMSName,
                             MQDB_VERSION_STRING_LEN,
                             &dwSize ) ;
   if (!ODBC_SUCCESS(sqlstatus))
   {
      OdbcStateIs( m_hConnection, SQL_NULL_HSTMT, OERR_GENERAL_WARNING) ;
      dbstatus = MQDB_E_DATABASE ;
   }
   else
   {
      ASSERT(dwSize < (SWORD) MQDB_VERSION_STRING_LEN) ;
   }

   // Get the DBMS version
   sqlstatus = ::SQLGetInfo( m_hConnection,
                             SQL_DBMS_VER,
                             pVersion->szDBMSVer,
                             MQDB_VERSION_STRING_LEN,
                             &dwSize ) ;
   if (!ODBC_SUCCESS(sqlstatus))
   {
      OdbcStateIs( m_hConnection, SQL_NULL_HSTMT, OERR_GENERAL_WARNING) ;
      dbstatus = MQDB_E_DATABASE ;
   }
   else
   {
      ASSERT(dwSize < (SWORD) MQDB_VERSION_STRING_LEN) ;
   }

   return dbstatus ;
}

// Handle transaction
MQDBSTATUS CMQODBCDataBase::Transaction(IN MQDBTRANSACOP mqdbTransac)
{
   RETCODE     sqlstatus = SQL_SUCCESS ;
   MQDBSTATUS  dbstatus = MQDB_OK ;

   switch (mqdbTransac) {
      case AUTO:
      {
     	   // Enable Auto commit.
	   	sqlstatus = ::SQLSetConnectOption(
			   					m_hConnection,
				   				SQL_AUTOCOMMIT,
					   			SQL_AUTOCOMMIT_ON);
         break ;
      }

      case BEGIN:
      {
     	   // Enable manual transaction mode.
	   	sqlstatus = ::SQLSetConnectOption(
			   					m_hConnection,
				   				SQL_AUTOCOMMIT,
					   			SQL_AUTOCOMMIT_OFF);
#ifdef _DEBUG
         m_OutstandingTransactions++ ;
         ASSERT(m_OutstandingTransactions <= 2) ;
#endif
         break ;
      }

      case COMMIT:
      {
         sqlstatus = ::SQLTransact(g_hEnv, m_hConnection, SQL_COMMIT) ;
#ifdef _DEBUG
         m_OutstandingTransactions-- ;
#endif
         break ;
      }

      case ROLLBACK:
      {
         sqlstatus = ::SQLTransact(g_hEnv, m_hConnection, SQL_ROLLBACK) ;
#ifdef _DEBUG
         m_OutstandingTransactions-- ;
#endif
         break ;
      }

      default:
      {
         dbstatus = MQDB_E_INVALID_DATA ;
         break ;
      }
   }

   if (!ODBC_SUCCESS(sqlstatus))
   {
      dbstatus = CheckSqlStatus( sqlstatus,
	                              NULL ) ;
   }
   return dbstatus ;
}

//
// Create a meaningfull error code.
//
MQDBSTATUS CMQODBCDataBase::GetDBStatus( IN SDWORD  sdwNativeError,
                                         IN UCHAR   *pSqlError )
{
   MQDBSTATUS dbstatus = MQDB_E_DATABASE ;

   if ( lstrcmpiA(OERR_DBMS_NOT_AVAILABLE, (char*)pSqlError) == 0 )
   {
      dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
   }
   else if ( m_dwDMBSType == MQDBMSTYPE_SQLSERVER )
   {
      //
      // DBMS type: Microsoft SQL Server.
      //
      if ( lstrcmpiA( (char *) pSqlError, OERR_SQL_SYNTAX_ERROR ) == 0 )
      {
         //
         //  Syntax errors
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_NONUNIQUESORT:
               dbstatus = MQDB_E_NON_UNIQUE_SORT ;
               break ;

            case SERR_MSSQL_TABLE_IS_FULL:
               dbstatus = MQDB_E_TABLE_FULL ;
               break ;

            default:
               break ;
         }
      }
      else if ( lstrcmpiA( (char *) pSqlError, OERR_GENERAL_WARNING ) == 0 )
      {
         //
         //  General warnings
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_NOT_AVAILABLE:
               dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
               break ;

            default:
               break ;
         }
      }
      else if ( lstrcmpiA( (char *) pSqlError, OERR_INVALID_STATE ) == 0 )
      {
         //
         // State errors. Operations done when database in wrong state.
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_READ_ONLY:
               dbstatus = MQDB_E_DB_READ_ONLY ;
               break ;

            default:
               break ;
         }
      }
      else if ( lstrcmpiA( (char *) pSqlError, OERR_SERIALIZATION ) == 0 )
      {
         //
         // Serialization / deadlock errors.
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_DEADLOCK:
               dbstatus = MQDB_E_DEADLOCK ;
               break ;

            default:
               break ;
         }
      }
   }

   return dbstatus ;
}

MQDBSTATUS CMQODBCDataBase::CheckSqlStatus(
                             IN RETCODE        sqlError,
	                          IN CMQDBOdbcSTMT  *pStatement,
                             IN HSTMT          hStmtIn /* SQL_NULL_HSTMT */ )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   if (!ODBC_SUCCESS(sqlError))
   {
      SDWORD  sdwNativeError ;
      UCHAR   szSqlState[ SQLSTATELEN ] ;

      HSTMT hStmt = hStmtIn ;
      if (hStmt == SQL_NULL_HSTMT)
      {
         if (pStatement)
         {
            hStmt = pStatement->GetHandle() ;
         }
      }
      else
      {
         ASSERT(!pStatement) ;
      }

      OdbcStateIsEx( m_hConnection,
                     hStmt,
                     OERR_GENERAL_WARNING,
                     &sdwNativeError,
                     szSqlState ) ;

      dbstatus = GetDBStatus( sdwNativeError, szSqlState ) ;
      ASSERT(dbstatus != MQDB_OK) ;
   }

   return dbstatus ;
}


MQDBSTATUS CMQODBCDataBase::GetSize( DWORD *pSize )
{
   MQDBSTATUS  dbstatus = MQDB_OK ;
   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.

   //
   // Execute the command
   //
   if (*pSize)
   {
	   pStatement->Allocate("sp_spaceused @updateusage = 'TRUE'") ;
   }
   else
   {
	   pStatement->Allocate("sp_spaceused") ;
   }
	RETCODE sqlstatus = pStatement->Execute();

   *pSize = (DWORD) -1 ;
   if (ODBC_SUCCESS(sqlstatus) || ODBC_SUCCESS_WINFO(sqlstatus))
   {
      MQDBCOLUMNVAL  pColumns[3] ;

      for ( int cColumns = 0 ; cColumns < 3 ; cColumns++ )
      {
         INIT_COLUMNVAL(pColumns[ cColumns ]) ;
         pColumns[ cColumns ].lpszColumnName = NULL ;
         pColumns[ cColumns ].nColumnValue   = NULL ;
         pColumns[ cColumns ].nColumnLength  = 0 ;
         pColumns[ cColumns ].mqdbColumnType = MQDB_STRING ;
      }

      dbstatus = pStatement->RetrieveRecordData( pColumns, 3 ) ;

      if (dbstatus == MQDB_OK)
      {
         DWORD  dwTotalSize = 0 ;
         DWORD  dwUnusedSize = 0 ;
         sscanf(((char *) pColumns[1].nColumnValue), "%lu", &dwTotalSize) ;
         sscanf(((char *) pColumns[2].nColumnValue), "%lu", &dwUnusedSize) ;
         ASSERT(dwTotalSize >= dwUnusedSize) ;

         DBGMSG(( DBGMOD_PSAPI,DBGLVL_WARNING,
               TEXT("MQDBMGR, GetSize: total- %lu MB, unused- %lu MB"),
                                             dwTotalSize, dwUnusedSize)) ;

         if (dwTotalSize != 0)
         {
            *pSize = 100 - ((dwUnusedSize * 100) / dwTotalSize) ;
         }
         else
         {
            dbstatus = MQDB_E_BAD_SIZE_VALUE ;
         }
      }

      //
      // Free the strings.
      //
      for ( cColumns = 0 ; cColumns < 3 ; cColumns++ )
      {
         ASSERT(pColumns[ cColumns ].nColumnValue) ;
         delete ((char *) pColumns[ cColumns ].nColumnValue) ;
      }
   }
   else
   {
      dbstatus = CheckSqlStatus( sqlstatus,
	                              pStatement ) ;
   }

   return dbstatus ;
}


MQDBSTATUS CMQODBCDataBase::Escape( IN LPSTR lpszCommand )
{
   MQDBSTATUS  dbstatus = MQDB_OK ;
   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.

   //
   // Execute the command
   //
	pStatement->Allocate(lpszCommand);
	RETCODE sqlstatus = pStatement->Execute();
   if (!ODBC_SUCCESS(sqlstatus))
   {
      dbstatus = CheckSqlStatus( sqlstatus,
	                              pStatement ) ;
   }
   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\mqdbodbc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		mqdbodbc.h

Abstract:
   ODBC related stuff.
   Define whatever is necessary for using ODBC.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      10-Jan-96   Created

--*/

#include "sqlext.h"

///////////////////////////////////////////////
//
//  Types of database managers
//
///////////////////////////////////////////////

#define  MQDBMSTYPE_UNKNOWN     1
#define  MQDBMSTYPE_SQLSERVER   2

///////////////////////////////////////////////
//
// Information returned in SQLError
//
///////////////////////////////////////////////

#define OERR_DSN_NOT_FOUND				"IM002"
#define OERR_TABLE_ALREADY_EXISTS	"S0001"
#define OERR_INDEX_ALREADY_EXISTS	"S0011"
#define OERR_CONSTRAINT_PROBLEM		"23000"
#define OERR_GENERAL_WARNING        "01000"
#define OERR_SQL_OPTION_CHANGED     "01S02"
#define OERR_SQL_SYNTAX_ERROR       "37000"
#define OERR_DBMS_NOT_AVAILABLE     "08S01"
#define OERR_INVALID_STATE          "25000"
#define OERR_SERIALIZATION          "40001"

#define ODBC_SUCCESS(s)       (s == SQL_SUCCESS)
#define ODBC_SUCCESS_WINFO(s) (s == SQL_SUCCESS_WITH_INFO)

#define  SQLSTATELEN   6   // Length of SQLSTATE string (including NULL).

///////////////////////////////////////////////
//
//  Specific DBMS errors
//
///////////////////////////////////////////////

#define  SERR_MSSQL_NONUNIQUESORT   169
#define  SERR_MSSQL_TABLE_IS_FULL   0x451
#define  SERR_MSSQL_READ_ONLY       3906
#define  SERR_MSSQL_NOT_AVAILABLE   230
#define  SERR_MSSQL_DEADLOCK        1205

///////////////////////////////////////////////
//
//  Data structures to handle SQL datatypes.
//  Defined and initialized in odbcdata.cpp.
//
///////////////////////////////////////////////

#define MQDB_ODBC_NUMOF_TYPES  8
#define MQDB_TYPE_NAME_LEN    32

#if (MQDB_ODBC_NUMOF_TYPES != MQDB_NUMOF_TYPES)
#error "mismatch in number of types"
#endif

// Best fit of our database column types to ODBC SQL types.
//
extern SWORD  dbODBCSQLTypes[] ;

// Precision of each type.
//
extern UDWORD dbODBCPrecision[] ;

// strings for operation names.
//
#define MQDB_ODBC_NUMOF_OPS  8
extern LPSTR dbODBCOpNameStr[] ;

// strings for ordering operation names.
//
#define MQDB_ODBC_NUMOF_ORDER_OP  2
extern LPSTR dbODBCOrderNameStr[] ;

// strings for aggregate operation names.
//
#define MQDB_ODBC_NUMOF_AGGR_OP  3
extern LPSTR dbODBCAggrNameStr[] ;

/////////////////////////////////////////
//
// Prototype of internal functions.
//
/////////////////////////////////////////

BOOL OdbcStateIs(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked) ;

BOOL OdbcStateIsEx(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked,
 				   IN    SDWORD *    pdwNativeError,
               IN    UCHAR *     pszSqlState) ;

RETCODE GetDataTypeName(
               IN    HDBC     hDbc,
					IN		SWORD  	swType,
					OUT	char *	szBuffer,
					IN		SDWORD   dwBuffSize) ;

MQDBSTATUS  FormatColumnData( IN LPSTR          szTmpBuff,
                              IN MQDBCOLUMNVAL  *pColumnVal) ;

BOOL  PrepareColumnNames( IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns,
                          IN OUT LPSTR         lpBuffer) ;

BOOL TypeMustBind( IN MQDBCOLUMNTYPE type ) ;

BOOL  FormatWhereString( IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                         IN OUT LPSTR         lpszBuf) ;

BOOL  FormatOpWhereString( IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhere,
                           IN MQDBOP            opWhere,
                           IN OUT LPSTR         lpszBuf) ;
////////////////////////
//
// Some useful macros.
//
////////////////////////

#define  DECLARE_BUFFER(bufname,bufsize)           \
   char bufname[ bufsize ] ;                       \
   bufname[ 0 ] = '\0' ;                           \
   bufname[ bufsize - 1 ] = '\0' ;                 \
   bufname[ bufsize - 2 ] = '\0' ;

#define  VERIFY_BUFFER(bufname,bufsize)            \
   if ((bufname[ bufsize - 1 ] != '\0') ||         \
       (bufname[ bufsize - 2 ] != '\0')) {         \
      return MQDB_E_INVALID_DATA ;                 \
   }

#define  RETURN_ON_ERROR      \
   if (dbstatus != MQDB_OK)   \
   {                          \
      return dbstatus ;       \
   }

//////////////////////////
//
// Global Variables.
//
//////////////////////////

extern HENV  g_hEnv ;

/////////////////////////
//
// Debug definitions
//
/////////////////////////

#ifdef _DEBUG
#undef STATIC
#define STATIC
#else
#undef STATIC
#define STATIC static
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcdata.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		odbcdata.cpp

Abstract:
   Define (and initialize if necessary) the global data of the dll.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Jan-96   Created

--*/

#include "dbsys.h"
#include "mqdbodbc.h"

#include "odbcdata.tmh"

SWORD  dbODBCSQLTypes[ MQDB_ODBC_NUMOF_TYPES ] = {
            SQL_SMALLINT,
            SQL_INTEGER,
            SQL_VARCHAR,
            SQL_LONGVARBINARY,
            SQL_LONGVARBINARY,
            SQL_BINARY,
            SQL_LONGVARBINARY,
            SQL_INTEGER} ;

UDWORD dbODBCPrecision[ MQDB_ODBC_NUMOF_TYPES ] = {
            5,
            10,
            0,
            0,
            0,
            0,
            0,
            10} ;

//
// note: the operation names must contain a leading space and trailing
//       space to ease formatting of sql commands.
//
LPSTR dbODBCOpNameStr[ MQDB_ODBC_NUMOF_OPS ] = {
      " = ",
      " <> ",
      " >= ",
      " > ",
      " <= ",
      " < ",
      " OR ",
      " AND " } ;

//
// note: the operation names must contain a leading space and trailing
//       comma to ease formatting of sql commands.
//
LPSTR dbODBCOrderNameStr[ MQDB_ODBC_NUMOF_ORDER_OP ] = {
   " ASC, ",
   " DESC, " } ;

//
//
//
LPSTR dbODBCAggrNameStr[ MQDB_ODBC_NUMOF_AGGR_OP ] = {
      " MAX(",
      " MIN(",
      " AVRG(" } ;

//
// Global ODBC envoronment handle.
//
HENV  g_hEnv = SQL_NULL_HENV ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcstmt.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		odbcstmt.h

Abstract:
	Define a statement class for implementing an ODBC statement.

	Class CMQDBOdbcSTMT


Author:
	Nir Ben-Zvi (nirb)
   Doron Juster (DoronJ)

Revisoins:
   NirB     1995        Create first version
   DoronJ   11-jan-96   Adopt for the mqdbmgr dll.
--*/

#ifndef __ODBCSTMT_H__
#define __ODBCSTMT_H__

#include "mqdbodbc.h"

/*
 * CMQDBOdbcSTMT - A class implemeting an ODBC statement
 *
 */
class CMQDBOdbcSTMT
{
public:
	CMQDBOdbcSTMT() { ASSERT(0); }
	CMQDBOdbcSTMT(
					IN		HDBC			hConnection);
	~CMQDBOdbcSTMT();

	RETCODE Allocate(			// Initialize statement
					IN		char * 	szSqlString);

	RETCODE Deallocate(); 		// Terminate statement

	RETCODE ChangeSqlString(  // Changes the sql command string
					IN		char * 	szSqlString);

	RETCODE Prepare();        // Prepare the statement

	RETCODE Execute( IN LPSTR lpszCommand = NULL ) ; // Execute the statement

	RETCODE Fetch();			// fetch the next row

	RETCODE GetStringColumn( 	// Return a string column
					IN		DWORD	 	dwCol,
					OUT	char **	ppszOut,
					IN		DWORD	*	pdwSize);

	RETCODE GetBinaryColumn( 	// Return a binary column
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	dwSize,
					IN		DWORD		dwOffset);

	RETCODE GetDwordColumn(		// Return a DWORD column
					IN		DWORD	 	dwCol,
					IN		DWORD *	pdwOut);

	RETCODE GetWordColumn(		// Return a DWORD column
					IN		DWORD	 	dwCol,
					IN		WORD *	pdwOut);

	RETCODE BindParameter(		// Bind a parameter to a prepared request
					IN		UDWORD	 	dwParameter,
					IN		SWORD		wCType,
					IN		SWORD		wSqlType,
					IN		UDWORD		dwPrecision,
					IN		UDWORD		dwSize,
					IN		PTR			pParameter,
					IN		SDWORD *	pcbValue);

	RETCODE GetDataTypeName(	// Return a data type name
					IN		SWORD	swType,
					OUT		char *	szBuffer,
					IN		DWORD	dwBufSize);

	RETCODE         EnableMultipleQueries( IN DWORD  dwDBMSType ) ;

	RETCODE         EnableNoLockQueries( IN DWORD  dwDBMSType ) ;

   inline HSTMT    GetHandle() { return m_hStatement ; }

	inline void     SetColumnsCount(LONG cColumns) { m_cColumns = cColumns ; }

   RETCODE         GetRowsCount(LONG *pCount) ;

   MQDBSTATUS      RetrieveRecordData( IN MQDBCOLUMNVAL   aColumnVal[],
                                       IN LONG            lColumns = 0 ) ;

   MQDBSTATUS      SetQueryTimeout( IN DWORD dwTimeout ) ;

private:
	RETCODE GetLargeColumn( 	// Return a binary or string column
               IN    SWORD    swType,
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	dwSize,
					IN		DWORD		dwOffset);

	HDBC				m_hConnection;		// Connection handle
	HSTMT				m_hStatement;		// A statement to be used
	BOOL				m_fAllocated;		// TRUE if statement allocated
	BOOL				m_fPrepared;		// TRUE if prepare was done
	BOOL				m_fShouldFree;		// TRUE if statement should be freed when changing string

	char *			m_szSqlString;		// The sql command buffer
   LONG           m_cColumns ;      // number of columns, for query.
};

#endif   // __ODBCSTMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		odbcutil.cpp

Abstract:
   Utility functions.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      10-Jan-96   Created. Based on NirB ODBC code.

--*/

#include "dbsys.h"
#include "mqdbodbc.h"
#include "odbcstmt.h"

#include "odbcutil.tmh"

/***********************************************************
*
* DllMain
*
*
* Input:
* ======
*
* Output:
* =======
* TRUE
*
************************************************************/

BOOL WINAPI DllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved)
{
    UNREFERENCED_PARAMETER(hMod);
    UNREFERENCED_PARAMETER(lpvReserved);

   if (fdwReason == DLL_PROCESS_ATTACH)
   {
      WPP_INIT_TRACING(L"Microsoft\\MSMQ");

      ASSERT(MQDB_ODBC_NUMOF_OPS      == MQDB_NUMOF_OPS) ;
      ASSERT(MQDB_ODBC_NUMOF_ORDER_OP == MQDB_NUMOF_ORDER_OP) ;
   }
   else if (fdwReason == DLL_PROCESS_DETACH)
   {
      WPP_CLEANUP();
      //ASSERT(g_hEnv == SQL_NULL_HENV) ;
   }
   else if (fdwReason == DLL_THREAD_ATTACH)
   {
   }
   else if (fdwReason == DLL_THREAD_DETACH)
   {
   }

	return TRUE;
}


/***********************************************************
*
* OdbcStateIs
* OdbcStateIsEx
*
* Check if the ODBC state (error returned from ODBC call) is as
* specified.
*
* Input:
* ======
* szStateToBeChecked	- The state to checked against what ODBC tell us.
*
* Output:
* =======
* TRUE if ODBC state matches the state to be checked.
*
************************************************************/

BOOL OdbcStateIsEx(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked,
 				   IN    SDWORD *    pdwNativeError,
               UCHAR             *pszSqlState)
{
	RETCODE sqlstatus;
	SWORD   dwCount;  // Not used.
	UCHAR   szBuffer[SQL_MAX_MESSAGE_LENGTH-1];


	// Get the current error state
 	sqlstatus = ::SQLError(
 						g_hEnv,
 						hDbc,
 						hStmt,
 						pszSqlState,
 						pdwNativeError,
 						szBuffer,
 						sizeof(szBuffer),
 						&dwCount);

	if (!ODBC_SUCCESS(sqlstatus))
		return FALSE;

#ifdef _DEBUG
	TCHAR   wzBuffer[SQL_MAX_MESSAGE_LENGTH-1];
   TCHAR   wzSqlState[SQLSTATELEN];

   MultiByteToWideChar( CP_ACP,
                        0,
                        (LPSTR) &szBuffer[0],
                        -1,
                        wzBuffer,
	                     SQL_MAX_MESSAGE_LENGTH-1 ) ;

   MultiByteToWideChar( CP_ACP,
                        0,
                        (LPSTR) pszSqlState,
                        -1,
                        wzSqlState,
	                     SQLSTATELEN ) ;

	DBGMSG(( DBGMOD_PSAPI, DBGLVL_ERROR,TEXT("SQLError (%ls, %lut): %ls"),
                          wzSqlState, (ULONG) *pdwNativeError, wzBuffer)) ;
#endif

	return ( lstrcmpiA(szStateToBeChecked, (char *)pszSqlState) == 0 ) ;
}


BOOL OdbcStateIs(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked)
{
   SDWORD  dwError ;
   UCHAR   szSqlState[SQLSTATELEN];

   return  OdbcStateIsEx(  hDbc,
                           hStmt,
					            szStateToBeChecked,
                           &dwError,
                           szSqlState ) ;
}

/***********************************************************
*
*  GetDataTypeName
*
*  This function return the data-source name for a data type
*
* Input:
* ======
* hDbc      - Handle of connection.
* swType 	- The requested data type.
* szBuffer	- The buffer that will get the returned name.
* dwBufSize	- Buffer size
*
* Output:
* =======
* ODBC driver return code.
*
************************************************************/

RETCODE GetDataTypeName(
               IN    HDBC     hDbc,
					IN		SWORD  	swType,
					OUT	char *	szBuffer,
					IN		SDWORD   dwBuffSize)
{
	RETCODE  sqlstatus ;
	SDWORD   dwLen ;
   HSTMT    hStmt ;

   // Allocate a statement. This function should be called only when
   // connecting to a new database so performance is not an issue and
   // we won't bother caching statement handles.

   sqlstatus = ::SQLAllocStmt(hDbc, &hStmt) ;
	if (!ODBC_SUCCESS(sqlstatus))
      return sqlstatus ;

   __try
   {
	   // Get type info
	   sqlstatus = ::SQLGetTypeInfo(hStmt, swType);
	   if (!ODBC_SUCCESS(sqlstatus))
		   __leave ;

   	// Fetch row
	   sqlstatus = ::SQLFetch(hStmt) ;
   	if (!ODBC_SUCCESS(sqlstatus))
	   	__leave ;

	   // Get data type name
	   sqlstatus = ::SQLGetData(
						hStmt,
						1,				// Column number 1
						SQL_C_CHAR,
						szBuffer,
						dwBuffSize,
						&dwLen);
   }
   __finally
   {
      RETCODE freestatus = ::SQLFreeStmt(hStmt, SQL_DROP) ;
   	if (ODBC_SUCCESS(sqlstatus))
         sqlstatus = freestatus ;
   }

	// Thats it folks
	return sqlstatus ;
}


/***********************************************************
*
*  PrepareColumnNames
*
*  Get an array of MQDBCOLUMNVAL and prepare a string with column names,
*  suitable for use in SQL syntax.
*
* Input:
* ======
* aColumnVal[] - Array of MQDBCOLUMNVAL
* cColumns     - number of columns in the array
* szBufer      - buffer for the string
*
* Output:
* =======
* TRUE if successful, FALSE otherwise
*
************************************************************/

BOOL  PrepareColumnNames( IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns,
                          IN OUT LPSTR         lpBuffer)
{
   __try
   {
      char szBuffer[256] ;
      LONG index = 1 ;

      wsprintfA(lpBuffer, "(%s", aColumnVal[0].lpszColumnName) ;
      for ( ; index < cColumns ; index++ ) {
         wsprintfA(szBuffer, ", %s", aColumnVal[ index ].lpszColumnName) ;
         lstrcatA( lpBuffer, szBuffer) ;
      }
      lstrcatA( lpBuffer, ")") ;
      return TRUE ;
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
      return FALSE ;
   }
}

/***********************************************************
*
*  FormatColumnData
*
*  Format a data item in a column into a string
*
* Input:
* ======
*
* Output:
* =======
* MQDB_OK if format succeeded.
*
************************************************************/


MQDBSTATUS  FormatColumnData( IN LPSTR          szTmpBuff,
                              IN MQDBCOLUMNVAL  *pColumnVal)
{
   switch (pColumnVal->mqdbColumnType)
   {
      case MQDB_SHORT:
      case MQDB_LONG:
      {
          wsprintfA(szTmpBuff, "%ld", pColumnVal->nColumnValue) ;
          break ;
      }

      case MQDB_STRING:
      {
          wsprintfA(szTmpBuff, "'%s'", (LPSTR) pColumnVal->nColumnValue) ;
          break ;
      }

      default:
      {
          ASSERT(0) ;
          return MQDB_E_UNKNOWN ;
      }
   }
   return MQDB_OK ;
}


/***********************************************************
*
*  TypeMustBind
*
*  Check if a data type must be bound instead of directly used
*  in direct execution.
*
* Input:
* ======
* cType- data type to be checked.
*
* Output:
* =======
* TRUE if must bind.
*
************************************************************/

BOOL TypeMustBind( IN MQDBCOLUMNTYPE cType )
{
   if ((cType != MQDB_SHORT) &&
       (cType != MQDB_LONG)  &&
       (cType != MQDB_STRING)) {
      return TRUE ;
   }
   else {
      return FALSE ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcss.h ===
/*
** ODBCSS.H - This is the application include file for the
** SQL Server driver specific defines.
**
** (C) Copyright 1993-1996 By Microsoft Corp.
**
*/

//	SQLSetConnectOption/SQLSetStmtOption driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

//	Connection Options
#define SQL_COPT_SS_BASE				1200
#define SQL_REMOTE_PWD					(SQL_COPT_SS_BASE+1) // dbrpwset SQLSetConnectOption only
#define SQL_USE_PROCEDURE_FOR_PREPARE	(SQL_COPT_SS_BASE+2) // Use create proc for SQLPrepare
#define SQL_INTEGRATED_SECURITY 		(SQL_COPT_SS_BASE+3) // Force integrated security on login
#define SQL_PRESERVE_CURSORS			(SQL_COPT_SS_BASE+4) // Preserve server cursors after SQLTransact
#define SQL_COPT_SS_USER_DATA			(SQL_COPT_SS_BASE+5) // dbgetuserdata/dbsetuserdata
#define SQL_COPT_SS_ANSI_OEM			(SQL_COPT_SS_BASE+6) // dbsetopt/DBANSItoOEM/DBOEMtoANSI
#define SQL_COPT_SS_ENLIST_IN_DTC		(SQL_COPT_SS_BASE+7) // Enlist in a Viper transaction
#define SQL_COPT_SS_ENLIST_IN_XA		(SQL_COPT_SS_BASE+8) // Enlist in a XA transaction
#define SQL_COPT_SS_CONNECTION_DEAD		(SQL_COPT_SS_BASE+9) // dbdead SQLGetConnectOption only
#define SQL_COPT_SS_FALLBACK_CONNECT	(SQL_COPT_SS_BASE+10) // Enables FallBack connections
#define SQL_COPT_SS_PERF_DATA			(SQL_COPT_SS_BASE+11) // Used to access SQL Server ODBC driver performance data
#define SQL_COPT_SS_PERF_DATA_LOG		(SQL_COPT_SS_BASE+12) // Used to set the logfile name for the Performance data
#define SQL_COPT_SS_PERF_QUERY_INTERVAL (SQL_COPT_SS_BASE+13) // Used to set the query logging threshold in milliseconds.
#define SQL_COPT_SS_PERF_QUERY_LOG		(SQL_COPT_SS_BASE+14) // Used to set the logfile name for saving queryies.
#define SQL_COPT_SS_PERF_QUERY			(SQL_COPT_SS_BASE+15) // Used to start and stop query logging.
#define SQL_COPT_SS_PERF_DATA_LOG_NOW	(SQL_COPT_SS_BASE+16) // Used to make a statistics log entry to disk.

#define SQL_COPT_SS_MAX_USED			SQL_COPT_SS_PERF_DATA_LOG_NOW

//	Statement Options
#define SQL_SOPT_SS_BASE				1225
#define SQL_TEXTPTR_LOGGING 			(SQL_SOPT_SS_BASE+0) // Text pointer logging
#define SQL_SOPT_SS_CURRENT_COMMAND		(SQL_SOPT_SS_BASE+1) // dbcurcmd SQLGetStmtOption only
#define SQL_SOPT_SS_MAX_USED			SQL_SOPT_SS_CURRENT_COMMAND


//	Defines for use with SQL_USE_PROCEDURE_FOR_PREPARE
#define SQL_UP_OFF		0L			//	Procedures won't be used for prepare
#define SQL_UP_ON		1L			//	Procedures will be used for prepare
#define SQL_UP_ON_DROP	2L			//	Temp procedures will be explicitly dropped
#define SQL_UP_DEFAULT	SQL_UP_ON

//	Defines for use with SQL_INTEGRATED_SECURITY - only useable before connecting
#define SQL_IS_OFF		0L			//	Integrated security isn't used
#define SQL_IS_ON		1L			//	Integrated security is used
#define SQL_IS_DEFAULT	SQL_IS_OFF

//	Defines for use with SQL_PRESERVE_CURSORS
#define SQL_PC_OFF		0L			//	Cursors are closed on SQLTransact
#define SQL_PC_ON		1L			//	Cursors remain open on SQLTransact
#define SQL_PC_DEFAULT	SQL_PC_OFF

//	Defines for use with SQL_COPT_SS_USER_DATA
#define SQL_UD_NOTSET	0L			//	No user data pointer set

//	Defines for use with SSQL_COPT_SS_ANSI_OEMQL_ANSI_OEM
#define SQL_AO_OFF		0L			//	ANSI/OEM translation is not performed
#define SQL_AO_ON		1L			//	ANSI/OEM translation is performed
#define SQL_AO_DEFAULT	SQL_AO_OFF	//	Default unless DSN OEM/ANSI checkbox is checked

//	Defines for use with SQL_COPT_SS_CONNECTION_DEAD
#define SQL_CD_FALSE	0L			//	Connection is open/available
#define SQL_CD_TRUE		1L			//	Connection is closed/dead

//	Defines for use with SQL_COPT_SS_FALLBACK_CONNECT
#define SQL_FB_OFF		0L			//	FallBack connections are disabled
#define SQL_FB_ON		1L			//	FallBack connections are enabled
#define SQL_FB_DEFAULT	SQL_FB_OFF

//	Defines for use with SQL_ENLIST_IN_DTC
#define SQL_DTC_DONE	0L			//	Delimits end of Viper transaction

//	Defines for use with SQL_TEXTPTR_LOGGING
#define SQL_TL_OFF		0L			//	No logging on text pointer ops
#define SQL_TL_ON		1L			//	Logging occurs on text pointer ops
#define SQL_TL_DEFAULT	SQL_TL_ON


//	SQLColAttributes driver specific defines.
//	SQLSet/GetDescField driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

#define SQL_CA_SS_BASE				1200
#define SQL_CA_SS_COLUMN_SSTYPE		(SQL_CA_SS_BASE+0)	//	dbcoltype/dbaltcoltype
#define SQL_CA_SS_COLUMN_UTYPE		(SQL_CA_SS_BASE+1)	//	dbcolutype/dbaltcolutype
#define SQL_CA_SS_NUM_ORDERS		(SQL_CA_SS_BASE+2)	//	dbnumorders
#define SQL_CA_SS_COLUMN_ORDER		(SQL_CA_SS_BASE+3)	//	dbcolorder
#define SQL_CA_SS_COLUMN_VARYLEN	(SQL_CA_SS_BASE+4)	//	dbvarylen
#define SQL_CA_SS_NUM_COMPUTES		(SQL_CA_SS_BASE+5)	//	dbnumcompute
#define SQL_CA_SS_COMPUTE_ID		(SQL_CA_SS_BASE+6)	//	dbnextrow status return
#define SQL_CA_SS_COMPUTE_BYLIST	(SQL_CA_SS_BASE+7)	//	dbbylist
#define SQL_CA_SS_COLUMN_ID			(SQL_CA_SS_BASE+8)	//	dbaltcolid
#define SQL_CA_SS_COLUMN_OP			(SQL_CA_SS_BASE+9)	//	dbaltcolop
#define SQL_CA_SS_MAX_USED			SQL_CA_SS_COLUMN_OP

// SQL Server Data Type Tokens. Returned by SQLColAttributes/SQL_CA_SS_COLUMN_SSTYPE.
#define SQLTEXT 			0x23
#define SQLVARBINARY		0x25
#define SQLINTN 			0x26
#define SQLVARCHAR			0x27
#define SQLBINARY			0x2d
#define SQLIMAGE			0x22
#define SQLCHARACTER		0x2f
#define SQLINT1 			0x30
#define SQLBIT				0x32
#define SQLINT2 			0x34
#define SQLINT4 			0x38
#define SQLMONEY			0x3c
#define SQLDATETIME 		0x3d
#define SQLFLT8 			0x3e
#define SQLFLTN 			0x6d
#define SQLMONEYN			0x6e
#define SQLDATETIMN 		0x6f
#define SQLFLT4 			0x3b
#define SQLMONEY4			0x7a
#define SQLDATETIM4 		0x3a
#define SQLDECIMAL			0x37
#define SQLDECIMALN			0x6a
#define SQLNUMERIC			0x3f
#define SQLNUMERICN 		0x6c

//	User Data Type definitions. Returned by SQLColAttributes/SQL_CA_SS_COLUMN_UTYPE.
#define SQLudtTEXT			19
#define SQLudtVARBINARY 	4
#define SQLudtINTN			13
#define SQLudtVARCHAR		2
#define SQLudtBINARY		3
#define SQLudtIMAGE 		20
#define SQLudtCHAR			1
#define SQLudtINT1			5
#define SQLudtBIT			16
#define SQLudtINT2			6
#define SQLudtINT4			7
#define SQLudtMONEY 		11
#define SQLudtDATETIME		12
#define SQLudtFLT8			8
#define SQLudtFLTN			14
#define SQLudtMONEYN		17
#define SQLudtDATETIMN		15
#define SQLudtSYSNAME		18
#define SQLudtTIMESTAMP 	80
#define SQLudtFLT4			23
#define SQLudtMONEY4		21
#define SQLudtDATETIM4		22
#define SQLudtDECML			24
#define SQLudtDECMLN		26
#define SQLudtNUM			10
#define SQLudtNUMN			25
#define MIN_USER_DATATYPE	100

// aggregate operator types (returned by SQLColAttributes/SQL_CA_SS_COLUMN_OP)
#define SQLAOPCNT	0x4b
#define SQLAOPSUM	0x4d
#define SQLAOPAVG	0x4f
#define SQLAOPMIN	0x51
#define SQLAOPMAX	0x52
#define SQLAOPANY	0x53
#define SQLAOPNOOP	0x56


//	SQLGetInfo driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

#define SQL_INFO_SS_FIRST		1200
#define SQL_INFO_SS_NETLIB_NAME (SQL_INFO_SS_FIRST+0) //  dbprocinfo
#define SQL_INFO_SS_MAX_USED	SQL_INFO_SS_NETLIB_NAME


//	Internal server datatypes - used when binding to SQL_C_BINARY
#ifndef MAXNUMERICLEN	// Resolve ODS/DBLib conflicts
typedef struct dbmoney
{						// Internal representation of MONEY data type
	LONG  mnyhigh;		// Money value *10,000 (High 32 bits/signed)
	ULONG mnylow;		// Money value *10,000 (Low 32 bits/unsigned)
} DBMONEY;

typedef struct dbdatetime
{						// Internal representation of DATETIME data type
	LONG  dtdays;		// No of days since Jan-1-1900 (maybe negative)
	ULONG dttime;		// No. of 300 hundredths of a second since midnight
} DBDATETIME;

typedef struct dbdatetime4
{						// Internal representation of SMALLDATETIME data type
	USHORT numdays; 	// No of days since Jan-1-1900
	USHORT nummins; 	// No. of minutes since midnight
} DBDATETIM4;

typedef LONG DBMONEY4;	// Internal representation of SMALLMONEY data type
						// Money value *10,000

#define MAXNUMERICLEN 16

#define DBNUM_PREC_TYPE BYTE
#define DBNUM_SCALE_TYPE BYTE
#define DBNUM_VAL_TYPE BYTE

typedef struct dbnumeric
{							// Internal representation of NUMERIC data type
	DBNUM_PREC_TYPE   precision;			// Precision
	DBNUM_SCALE_TYPE  scale;				// Scale
	BYTE			  sign; 				// Sign (1 if positive, 0 if negative)
	DBNUM_VAL_TYPE	  val[MAXNUMERICLEN];	// Value
} DBNUMERIC;

typedef DBNUMERIC DBDECIMAL;// Internal representation of DECIMAL data type
#endif //	MAXNUMERICLEN

/*****************************************************************
 This struct is a global used for 
 gathering statistal data on the driver.
 Access to this struct is controled via the 
 pStatCrit;
******************************************************************/

typedef struct sqlperf
{
	// Application Profile Statistics
	DWORD TimerResolution;
	DWORD SQLidu;
	DWORD SQLiduRows;
	DWORD SQLSelects;
	DWORD SQLSelectRows;
	DWORD Transactions;
	DWORD SQLPrepares;
	DWORD ExecDirects;
	DWORD SQLExecutes;
	DWORD CursorOpens;
	DWORD CursorSize;
	DWORD CursorUsed;
	LDOUBLE PercentCursorUsed;
	LDOUBLE AvgFetchTime;
	LDOUBLE AvgCursorSize; 
	LDOUBLE AvgCursorUsed;
	DWORD SQLFetchTime;
	DWORD SQLFetchCount;
	DWORD CurrentStmtCount;
	DWORD MaxOpenStmt;
	DWORD SumOpenStmt;
	
	// Connection Statistics
	DWORD CurrentConnectionCount;
	DWORD MaxConnectionsOpened;
	DWORD SumConnectionsOpened;
	DWORD SumConnectiontime;
	LDOUBLE AvgTimeOpened;

	// Network Statistics
	DWORD ServerRndTrips;
	DWORD BuffersSent;
	DWORD BuffersRec;
	DWORD BytesSent;
	DWORD BytesRec;

	// Time Statistics;
	DWORD msExecutionTime;
	DWORD msNetWorkServerTime;

} 	SQLPERF;

// The following are option for SQL_COPT_SS_PERF_DATA and SQL_COPT_SS_PERF_QUERY
#define SQL_PERF_START	1			// Starts the driver sampling performance data.
#define SQL_PERF_STOP	2			// Stops the counters from sampling performance data.

//	The following options have been deprecated

#define SQL_FAST_CONNECT				(SQL_COPT_SS_BASE+0)
//	Defines for use with SQL_FAST_CONNECT - only useable before connecting
#define SQL_FC_OFF		0L			//	Fast connect is off
#define SQL_FC_ON		1L			//	Fast connect is on
#define SQL_FC_DEFAULT	SQL_FC_OFF

/* 

The following data struct is used as the vParam with 
SQL_COPT_SS_ENLIST_IN_XA to enlist in a XA stansaction
when calling SQLSetStmtAttribute();

*/
typedef struct SQLXaTranTAG
{
    void FAR *transManager;
    void FAR *xaTransID;
    ULONG	xaTransIDLength;
    DWORD   dwErrorInfo;
} SQLXaTran;
                           
//	End of odbcss.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcstmt.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		odbcstmt.cpp

Abstract:
	Implements the odbc statement class CMQDBOdbcSTMT

Authors:
	Nir Ben-Zvi  (nirb)
   Doron Juster (DoronJ)

Revisoins:
   NirB       1995      Create first version
   DoronJ   11-jan-96   Adopt for the mqdbmgr dll.
--*/						

#include "dbsys.h"
#include "odbcstmt.h"

#include "odbcstmt.tmh"

/***********************************************************
*
* CMQDBOdbcSTMT::CMQDBOdbcSTMT
*
* Constructor. Initialize the variables
*
* Input:
* ======
* hConnection	- The connection handle
*
* Output:
* =======
* none
*
************************************************************/

CMQDBOdbcSTMT::CMQDBOdbcSTMT( IN  HDBC  hConnection )
							: m_hConnection(hConnection),
							  m_hStatement(SQL_NULL_HSTMT),
							  m_fAllocated(FALSE),
							  m_fPrepared(FALSE),
							  m_fShouldFree(FALSE),
							  m_szSqlString(NULL),
                       m_cColumns(0)
{
}

/***********************************************************
*
* CMQDBOdbcSTMT::~CMQDBOdbcSTMT
*
* Destructor.
* If the statement is allocated, deallocate it
*
* Input:
* ======
* none
*
* Output:
* =======
* none
*
************************************************************/

CMQDBOdbcSTMT::~CMQDBOdbcSTMT()
{
	if (m_fAllocated)
		Deallocate();
}

/***********************************************************
*
* CMQDBOdbcSTMT::Allocate
*
* This function allocates an ODBC statement
*
* Input:
* ======
* szSqlString - the sql command
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Allocate(
					IN		char *	 	szSqlString)
{
	RETCODE status;


	// Sanity check
	ASSERT(m_fAllocated == FALSE);

	// Allocate a statement
	status = ::SQLAllocStmt(
						m_hConnection,
						&m_hStatement);
	if (!ODBC_SUCCESS(status))
		return status;
	
	m_fAllocated = TRUE;


	// Set the sql string
	status = ChangeSqlString(szSqlString);


	// Thats it folks
	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Deallocate
*
* This function deallocates the statement
*
* Input:
* ======
* none
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Deallocate()
{
	RETCODE status;

	// Sanity
	ASSERT(m_fAllocated == TRUE);

	// Get rid of the buffer
	if (m_szSqlString != NULL)
	{
		delete m_szSqlString;
		m_szSqlString = NULL;
	}

	// Free the statement
	status = ::SQLFreeStmt(
						m_hStatement,
						SQL_DROP);
	if (!ODBC_SUCCESS(status))
		return status;

	// Thats it folks
	return SQL_SUCCESS;
}

/***********************************************************
*
* CMQDBOdbcSTMT::ChangeSqlString
*
* This function changes the sql command of the statement
*
* It also resets the stamtement state
*
* Input:
* ======
* szSqlString - the sql command
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::ChangeSqlString(
   					IN	char * 	szSqlString)
{
	// Sanity check
	ASSERT(m_fAllocated == TRUE);

	// Stop current statement processing but do not drop it
	if (m_fShouldFree)
	{
		::SQLFreeStmt(
					m_hStatement,
					SQL_CLOSE);
		::SQLFreeStmt(
					m_hStatement,
					SQL_UNBIND);
		::SQLFreeStmt(
					m_hStatement,
					SQL_RESET_PARAMS);
	}
	m_fPrepared = FALSE;
	m_fShouldFree = FALSE;

	// Drop the current sql string
	if (m_szSqlString != NULL)
	{
		delete m_szSqlString;
		m_szSqlString = NULL;
	}

	// Copy the sql string
	if (szSqlString != NULL)
	{
		m_szSqlString = new char[strlen(szSqlString)+1];
		ASSERT(m_szSqlString) ;
		strcpy(m_szSqlString,szSqlString);
	}
	else
   {
		m_szSqlString = NULL;
   }

	// Thats it folks
	return SQL_SUCCESS;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Prepare
*
* This function prepares the statement to be executed afterwords.
* This is done for two reasons:
* 1. Performance
* 2. The parameters are not known while preparing the statement.
*
* Input:
* ======
* none
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Prepare()
{
	RETCODE status;

	// Prepare the statement
	status = ::SQLPrepare(
							m_hStatement,
							(UCHAR *)m_szSqlString,
							SQL_NTS);
	if (!ODBC_SUCCESS(status))
		return status;

	// Indicate that the statement was prepared
	m_fPrepared = TRUE;

	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Execute
*
* This function executes the statement.
* If the statement was prepared, we use Execute otherwise we use ExecDirect.
*
* Input:
* ======
* IN LPSTR lpszCommand - if not null, this is the direct command to execute.
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Execute( IN LPSTR lpszCommand )
{
	RETCODE status;

   if (lpszCommand)
   {
      // Direct execution.
      //
   	ASSERT(!m_fPrepared) ;
      ASSERT(!m_szSqlString) ;

		status = ::SQLExecDirect( m_hStatement,
                                (UCHAR *) lpszCommand,
                                SQL_NTS);
   }
	else if (!m_fPrepared)
	{
		// No preperation done, use ExecDirect
      //
      ASSERT(m_szSqlString) ;
		status = ::SQLExecDirect( m_hStatement,
                                (UCHAR *) m_szSqlString,
                                SQL_NTS);
	}
	else
	{
      //
		// Execute a prepared statement
		status = ::SQLExecute(m_hStatement);
	}

	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Fetch
*
* This function calls the SQL to fetch the next row in a result set
*
* Input:
* ======
* none
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Fetch()		
{
	RETCODE status	=	SQL_SUCCESS;

	// If used again for other purposes, free the cursor
	m_fShouldFree = TRUE;

	// Get number of rows
	status = ::SQLFetch(m_hStatement);

	// Thats it folks
	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetStringColumn
*
* This function gets the data of a string column
*
* Input:
* ======
* dwCol	- Column number in result set
* pszOut	- Buffer to hold result
* dwSize	- Buffer size
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetStringColumn(
					IN		DWORD	 	dwCol,
					OUT	char **	ppszOut,
					IN		DWORD	*	pdwSize)
{
   return GetLargeColumn( SQL_C_CHAR,
					           dwCol,
					           ppszOut,
                          pdwSize,
		                    0) ;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetBinaryColumn
*
* This function gets the data of a binary column
*
* Input:
* ======
* dwCol		- Column number in result set
* ppOut		- Pointer to buffer that holds result (buffer can be NULL)
* dwSize 	- Buffer size (If pszOut is NULL the size is returned)
* dwOffset	- starting offset within the parameter
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetBinaryColumn(
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	pdwSize,
					IN		DWORD		dwOffset)
{
   return GetLargeColumn( SQL_C_BINARY,
					           dwCol,
					           ppOut,
                          pdwSize,
		                    dwOffset) ;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetLargeColumn
*
* This function gets the data of a binary column
*
* If the buffer provided is NULL the routine allocates it.
*
* Input:
* ======
* swType    - Type of data: either string or binary.
* dwCol		- Column number in result set
* ppOut		- Pointer to buffer that holds result (buffer can be NULL)
* dwSize 	- Buffer size (If pszOut is NULL the size is returned)
* dwOffset	- starting offset within the parameter
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetLargeColumn(
               IN    SWORD    swType,
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	pdwSize,
					IN		DWORD		dwOffset)
{
	RETCODE status			=	SQL_SUCCESS;
	SDWORD	dwOutSize;

    DBG_USED(dwOffset);

	// Sanity check
	ASSERT(ppOut != NULL && pdwSize != NULL);

	// BUGBUG Offset>0 currently unsupported
	ASSERT(dwOffset == 0);

	// If no buffer supplied
	if (*ppOut == NULL)
	{
		// Get the parameter length
        char	OneByte;
		status = ::SQLGetData(  m_hStatement,
            						(UWORD)dwCol,
				            		swType,
            						(PTR)&OneByte,
				            		0,
            						&dwOutSize);
		if (!ODBC_SUCCESS(status) && (status != SQL_SUCCESS_WITH_INFO))
        {
            OdbcStateIs( m_hConnection, m_hStatement, OERR_GENERAL_WARNING) ;
			return status;
        }

		//
        // If this is a NULL column
        //
		if (dwOutSize == SQL_NULL_DATA)
		{
			*pdwSize = 0 ;
		    *ppOut = NULL ;
			return SQL_SUCCESS;
		}

		// Allocate the output buffer
        if (swType == SQL_C_CHAR)
        {
           // include the null termination in the count.
		   dwOutSize++ ;
        }
		*pdwSize = dwOutSize;
		*ppOut = new char[ dwOutSize ] ;
		ASSERT(*ppOut) ;
	}

	// Get the data
	status = ::SQLGetData(
						m_hStatement,
						(UWORD)dwCol,
						swType,
						(PTR)*ppOut,
						*pdwSize,
						&dwOutSize);


	// If not all the data was read, it is still o.k.
	if (status == SQL_SUCCESS_WITH_INFO && *pdwSize != (DWORD)dwOutSize)
	{
		status = SQL_SUCCESS;

		// Update size read
		if (dwOutSize == SQL_NULL_DATA)
			*pdwSize = 0;
		else if (*pdwSize > (DWORD)dwOutSize)
			*pdwSize = dwOutSize;
	}

	// Thats it folks
	return status;
}

/***********************************************************
* CMQDBOdbcSTMT::GetDwordColumn
*
* This function gets the data of an INTEGER column
*
*
*
* Input:
* ======
* dwCol		- Column number in result set
* pdwOut	- Buffer to hold result
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetDwordColumn(
					IN		DWORD	 	dwCol,
					OUT	DWORD *	pdwOut)
{
	RETCODE status	=	SQL_SUCCESS;
	SDWORD	dwOutSize;

	// Get data
	status = ::SQLGetData(
						m_hStatement,
						(UWORD)dwCol,
						SQL_C_SLONG,
						(PTR)pdwOut,
						sizeof(DWORD),
						&dwOutSize);

	// Thats it folks
	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetWordColumn
*
* This function gets the data of an SHORT column
*
* Input:
* ======
* dwCol		- Column number in result set
* pdwOut	- Buffer to hold result
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetWordColumn(
					IN		DWORD	 	dwCol,
					OUT	WORD *	pwOut)
{
	RETCODE status	=	SQL_SUCCESS;
	SDWORD	dwOutSize;

	// Get data
	status = ::SQLGetData(
						m_hStatement,
						(UWORD)dwCol,
						SQL_C_SSHORT,
						(PTR)pwOut,
						sizeof(WORD),
						&dwOutSize);

	// Thats it folks
	return status;
}

/***********************************************************
* CMQDBOdbcSTMT::BindParameter
*
* This function binds a parameter to the statement
*
* Input:
* ======
* dwParameter	- Parameter number
* wCType		- The C data type
* wSqlType		- The SQL data type
* dwPrecision	- The precision of the data type
* dwSize		- Total number of bytes in parameter
* pParameter	- A pointer to the parameter location
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::BindParameter(
					IN		UDWORD	 	dwParameter,
					IN		SWORD	   	wCType,
					IN		SWORD	      wSqlType,
					IN		UDWORD		dwPrecision,
					IN		UDWORD		dwSize,
					IN		PTR			pParameter,
					IN		SDWORD *    pcbValue)
{
	return ::SQLBindParameter(
						m_hStatement,
						(UWORD)dwParameter,
						SQL_PARAM_INPUT,
						wCType,
						wSqlType,
						dwPrecision,
						0,
						pParameter,
						(SDWORD)dwSize,
						pcbValue);
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetDataTypeName
*
* This function gets the specified data type name
*
* Input:
* ======
* swType	- The requested type
* szBuffer	- The buffer that will hold the name returned
* dwBufSize	- Buffer size
*
* Output:
* =======
* status
* Data type name is inserted into the buffer
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetDataTypeName(
					IN		SWORD	   swType,
					OUT	char *	szBuffer,
					IN		DWORD	   dwBuffSize)
{
	RETCODE status	=	SQL_SUCCESS;
	SDWORD	dwLen;

	// If used again for other purposes, free the cursor
	m_fShouldFree = TRUE;

	// Get type info
	status = ::SQLGetTypeInfo(
							m_hStatement,
							swType);
	if (!ODBC_SUCCESS(status))
		return status;

	// Fetch row
	status = ::SQLFetch(
						m_hStatement);
	if (!ODBC_SUCCESS(status))
		return status;

	// Get data type name
	status = ::SQLGetData(
						m_hStatement,
						1,				// Column number 1
						SQL_C_CHAR,
						szBuffer,
						dwBuffSize,
						&dwLen);

	// Thats it folks
	return status;
}

/***********************************************************************
*
*  RETCODE CMQDBOdbcSTMT::EnableMultipleQueries()
*
*  Enable multiple (parallel) queries.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

RETCODE CMQDBOdbcSTMT::EnableMultipleQueries( IN DWORD dwDBMSType )
{
	RETCODE status	= SQL_SUCCESS ;

   if ( dwDBMSType == MQDBMSTYPE_SQLSERVER )
   {
      // For multiple queries on SQL server, set this option to get
      // type B cursor.
   	status = ::SQLSetStmtOption(
	      						m_hStatement,
			      				SQL_CURSOR_TYPE,
					      		SQL_CURSOR_KEYSET_DRIVEN );
   }

	// Thats it folks
	return status;
}

/***********************************************************************
*
*  RETCODE CMQDBOdbcSTMT::EnableNoLockQueries()
*
*  Enable queries without locks.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

RETCODE CMQDBOdbcSTMT::EnableNoLockQueries( IN DWORD dwDBMSType )
{
	RETCODE status	= SQL_SUCCESS ;

   if ( dwDBMSType == MQDBMSTYPE_SQLSERVER )
   {
   	status = ::SQLSetStmtOption(
	      						m_hStatement,
			      				SQL_CONCURRENCY,
					      		SQL_CONCUR_ROWVER ) ;
   }

	// Thats it folks
	return status;
}

/***********************************************************************
*
*  RETCODE  CMQDBOdbcSTMT::GetRowsCount(LONG *pCount)
*
*  Get number of rows which were affected by last command.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

RETCODE  CMQDBOdbcSTMT::GetRowsCount(LONG *pCount)
{
   SDWORD sdCount ;

   RETCODE sqlstatus = SQLRowCount( m_hStatement,
                                    &sdCount ) ;
   *pCount = (LONG) sdCount ;

	if (!ODBC_SUCCESS(sqlstatus))
   {
       OdbcStateIs( m_hConnection, m_hStatement, OERR_GENERAL_WARNING) ;
   }

   return sqlstatus ;
}

/***********************************************************
*
*  MQDBSTATUS  RetrieveRecordData()
*
*  Retrieve record columns into caller buffers.
*
* Input:
* ======
* hQuery       - handle of the query which selected the record.
* aColumnVal[] - Array of MQDBCOLUMNVAL
* cColumns     - number of columns in the array
*
* Output:
* =======
* MQDB_OK if succeeded.
*
************************************************************/

MQDBSTATUS  CMQDBOdbcSTMT::RetrieveRecordData(
                                  IN MQDBCOLUMNVAL  aColumnVal[],
                                  IN LONG           lColumns /*= 0*/ )
{
   RETCODE sqlstatus = Fetch() ;
   if (sqlstatus == SQL_NO_DATA_FOUND)
   {
      return MQDB_E_NO_MORE_DATA ;
   }

   HDBC  hDbc  = m_hConnection ;
   HSTMT hStmt = m_hStatement ;

   if (!ODBC_SUCCESS(sqlstatus))
   {
     MQDBSTATUS dbstatus = MQDB_E_DATABASE;
     if (OdbcStateIs( hDbc, hStmt, OERR_DBMS_NOT_AVAILABLE))
     {
        dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
     }
      return dbstatus ;
   }

   if (lColumns > 0)
   {
      ASSERT(m_cColumns == 0) ;
      m_cColumns = lColumns ;
   }

   LONG index = 0 ;
   for ( ; index < m_cColumns ; index++ )
   {
      switch( aColumnVal[ index ].mqdbColumnType )
      {
         case MQDB_STRING:
         {
            sqlstatus = GetStringColumn( (index+1),
                          (char **) &aColumnVal[ index ].nColumnValue,
                          (DWORD *) &aColumnVal[ index ].nColumnLength) ;
            break ;
         }

         case MQDB_SHORT:
         {
            sqlstatus = GetWordColumn( (index+1),
                          (WORD *) &(aColumnVal[ index ].nColumnValue)) ;
            break ;
         }

         case MQDB_LONG:
         case MQDB_IDENTITY:
         {
            sqlstatus = GetDwordColumn( (index+1),
                           (DWORD *) &(aColumnVal[ index ].nColumnValue)) ;
            break ;
         }

         default:
         {
            sqlstatus = GetBinaryColumn( (index + 1),
                          (char **) &(aColumnVal[ index ].nColumnValue),
                          (DWORD *) &(aColumnVal[ index ].nColumnLength),
                          0 /* offset */) ;
            break ;
         }
      }
      if (!ODBC_SUCCESS(sqlstatus))
      {
         OdbcStateIs( hDbc, hStmt, OERR_GENERAL_WARNING) ;
         return MQDB_E_DATABASE ;
      }
   }
   return MQDB_OK ;
}

/***********************************************************************
*
*  MQDBSTATUS  CMQDBOdbcSTMT::SetQueryTimeout( IN DWORD dwTimeout )
*
*  Set timeout for a query.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

MQDBSTATUS  CMQDBOdbcSTMT::SetQueryTimeout( IN DWORD dwTimeout )
{
	RETCODE status	=  ::SQLSetStmtOption( m_hStatement,
                                         SQL_QUERY_TIMEOUT,
                                         dwTimeout ) ;

   if (!ODBC_SUCCESS(status))
   {
      OdbcStateIs( m_hConnection, m_hStatement, OERR_GENERAL_WARNING) ;
      return  MQDB_E_INVALID_DATA ;
   }

	// Thats it folks
	return MQDB_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\stdh.cpp ===
//
// file:  stdh.cpp
//

#include "dbsys.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblinsrt.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblinsrt.cpp

Abstract:
   Implement the insert method for the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      08-Aug-96   Create, from tblodbc.cpp

--*/

#include "dbsys.h"
#include "tblodbc.h"
#include "dbodbc.h"

#include "tblinsrt.tmh"

#define INSERT_BUFFER_LEN  1024

//***********************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatInsertCmd
//
//  Format a SQL Insert command.
//
//  Input:
//  ======
//  aColumnVal[] - Array of MQDBCOLUMNVAL
//  cColumns     - number of columns in the array
//  szBufer      - buffer for the string
//
//  Output:
//  =======
//  MQDB_OK if format succeeded.
//
//************************************************************

MQDBSTATUS  CMQODBCTable::FormatInsertCmd(
                             IN MQDBCOLUMNVAL   aColumnVal[],
                             IN LONG            cColumns,
                             IN OUT LPSTR       lpBuffer )
{
   wsprintfA(lpBuffer, "INSERT INTO %s ", m_lpszTableName) ;

   if (aColumnVal[0].lpszColumnName)
   {
      // Only part of the columns are used.
      // Prepare string with column names.
      //
      DECLARE_BUFFER(szColBuffer, INSERT_BUFFER_LEN) ;

      if (!PrepareColumnNames( aColumnVal,
                               cColumns,
                               szColBuffer))
      {
         return MQDB_E_INVALID_DATA ;
      }
      VERIFY_BUFFER(szColBuffer, INSERT_BUFFER_LEN) ;
      lstrcatA(lpBuffer, szColBuffer) ;
   }
   lstrcatA(lpBuffer, "VALUES (") ;

   return MQDB_OK ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::ExecuteInsert
//
// Execute a prepared command
// It's the caller responsibility to supply the right number of columns
// with the right order.
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::ExecuteInsert(
	                       IN CMQDBOdbcSTMT    *pStatement,
                          IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns)
{
   //
   // First bind the parameters.
   //
   MQDBSTATUS dbstatus = MQDB_OK ;
   RETCODE sqlstatus ;
   LONG index = 1 ;

   for ( ; index <= cColumns ; index++ )
   {
       dbstatus = BindParameter( index,
                                 &aColumnVal[ index - 1 ],
                                 pStatement) ;
       if (dbstatus != MQDB_OK)
       {
          return dbstatus ;
       }
   }

   //
   // Next, execute.
   //
   sqlstatus = pStatement->Execute() ;
   return CheckSqlStatus( sqlstatus, pStatement) ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::PrepareInsert
//
// Prepare an Insert statement
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::PrepareInsert(
                          IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   DECLARE_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

   dbstatus =  FormatInsertCmd( aColumnVal,
                                cColumns,
                                szBuffer ) ;
   if (dbstatus != MQDB_OK)
   {
      return dbstatus ;
   }

   LONG index = 0 ;
   for ( ; index < cColumns - 1 ; index++ )
   {
       // Add the bind marking and delimiting comma between columns.
       //
       lstrcatA(szBuffer, " ? ,") ;
   }
   lstrcatA(szBuffer, "? )") ;

   VERIFY_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

   RETCODE  sqlstatus ;

   // Create a new statement.
   //
	ASSERT(!m_pInsertStatement) ;
	m_pInsertStatement = new CMQDBOdbcSTMT(m_hConnection) ;
   ASSERT(m_pInsertStatement) ;

   // Prepare the "INSERT" statement.
   //
	m_pInsertStatement->Allocate(szBuffer);
	sqlstatus = m_pInsertStatement->Prepare();

   dbstatus = CheckSqlStatus( sqlstatus, m_pInsertStatement ) ;
   if (dbstatus != MQDB_OK)
   {
      DeletePreparedInsert() ;
   }

   return dbstatus ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::FormatInsertData
//
//  Format the data into the command string for direct insert.
//  If data need binding then replace it with the '?' mark and bind.
//
//  Input
//  =====
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::FormatInsertData(
                                 IN MQDBCOLUMNVAL  *pColumnVal,
                                 IN LONG           cColumns,
                                 IN LPSTR          lpszBuffer,
	                              IN CMQDBOdbcSTMT  *pStatement)
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   LONG index = 0 ;
   int nBind = 1 ;

   for ( ; index < cColumns ; index++ )
   {
      dbstatus = FormatDirectData( pColumnVal,
                                   &nBind,
                                   lpszBuffer,
	                               pStatement);
      if (dbstatus != MQDB_OK)
      {
         break ;
      }
      pColumnVal++ ;
   }

   int nLen = lstrlenA(lpszBuffer) ;
   lpszBuffer[ nLen-1 ] = ')' ;

   return dbstatus ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::DirectInsertExec
//
// Insert a new record in the table. Direct execution without prepare.
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::DirectInsertExec(
                          IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns)
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   // format the command line.
   DECLARE_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

   dbstatus =  FormatInsertCmd( aColumnVal,
                                cColumns,
                                szBuffer ) ;
   if (dbstatus != MQDB_OK)
   {
      return dbstatus ;
   }

   //
   // Create a new statement.
   //
    CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT(m_hConnection) ;
    ASSERT(pStatement) ;
    P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
    pStatement->Allocate(NULL);

    dbstatus = FormatInsertData( aColumnVal,
                                cColumns,
                                szBuffer,
                                pStatement);
    if (dbstatus != MQDB_OK)
    {
      return dbstatus ;
    }

    VERIFY_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

    //
    // Execute the "INSERT" statement.
    //
    RETCODE  sqlstatus = pStatement->Execute( szBuffer );
    return CheckSqlStatus( sqlstatus, pStatement ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblodbc.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblodbc.cpp

Abstract:
   Implement the database table class for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Jan-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "tblodbc.h"
#include "dbodbc.h"

#include "tblodbc.tmh"

// Constructor
CMQODBCTable::CMQODBCTable()
							: m_hConnection(SQL_NULL_HDBC),
                       m_hDatabase(NULL),
                       m_lpszTableName(NULL)
{
	m_pInsertStatement = NULL ;
	m_pDeleteStatement = NULL ;
	m_pUpdateStatement = NULL ;
}

// Constructor
CMQODBCTable::CMQODBCTable( MQDBHANDLE hDatabase )
							: m_hConnection(SQL_NULL_HDBC),
                       m_hDatabase(hDatabase),
                       m_lpszTableName(NULL)
{
	m_pInsertStatement = NULL ;
	m_pDeleteStatement = NULL ;
	m_pUpdateStatement = NULL ;
}

// Destructor
CMQODBCTable::~CMQODBCTable()
{
   ASSERT(!m_lpszTableName) ;
   ASSERT(!m_pInsertStatement) ;
   ASSERT(!m_pDeleteStatement) ;
   ASSERT(!m_pUpdateStatement) ;
}

// Init the table object.
MQDBSTATUS CMQODBCTable::Init(IN MQDBHANDLE hDatabase,
                              IN LPSTR      lpszTableName)
{
   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   if (!pDatabase) {
      return MQDB_E_BAD_HDATABASE ;
   }
   m_hDatabase = hDatabase ;

   MQDBSTATUS dbstatus = MQDB_E_UNKNOWN ;
   HSTMT  hStmt = SQL_NULL_HSTMT ;
   RETCODE sqlstatus ;

   try
   {
      m_hConnection = pDatabase->GethDbc() ;

      // Check if table exist.
      // First allocate a statement.
      sqlstatus = ::SQLAllocStmt(m_hConnection, &hStmt) ;
		if (!ODBC_SUCCESS(sqlstatus)) {
         dbstatus = MQDB_E_OUTOFMEMORY ;
         goto endtry ;
      }

      // Next, look for the columns names
      sqlstatus = ::SQLColumns(hStmt,
                            NULL, 0,              /* All qualifiers */
                            NULL, 0,              /* All owners     */
                (UCHAR *)lpszTableName, SQL_NTS,  /* table name     */
                            NULL, 0);             /* All columns    */
      dbstatus = CheckSqlStatus( sqlstatus, NULL, hStmt) ;
		if (dbstatus != MQDB_OK)
      {
         goto endtry ;
      }

      //
      // Next, try to fetch the columns names
      //
      sqlstatus = ::SQLFetch(hStmt) ;
      if (sqlstatus == SQL_NO_DATA_FOUND)
      {
         //
         // Table doesn't exist.
         //
         dbstatus = MQDB_E_TABLE_NOT_FOUND ;
         goto endtry ;
      }
      else if (sqlstatus != SQL_SUCCESS)
      {
         dbstatus = CheckSqlStatus( sqlstatus, NULL, hStmt) ;
	   	ASSERT(dbstatus != MQDB_OK) ;
         goto endtry ;
      }

      m_lpszTableName = new char[ 1 + lstrlenA(lpszTableName) ];
      lstrcpyA(m_lpszTableName, lpszTableName) ;
      dbstatus = MQDB_OK ;
   }
   catch(...)
   {
   }
endtry:

   if (hStmt != SQL_NULL_HSTMT) {
      sqlstatus = ::SQLFreeStmt(hStmt, SQL_DROP) ;
	   if (!ODBC_SUCCESS(sqlstatus)) {
         if (dbstatus == MQDB_OK) {
            dbstatus = MQDB_E_DATABASE ;
         }
      }
   }

   return dbstatus ;
}

// Close the table object.
MQDBSTATUS CMQODBCTable::Close()
{
   delete m_lpszTableName ;
   m_lpszTableName = NULL ;
   if (m_pInsertStatement)
   {
      delete m_pInsertStatement ;
      m_pInsertStatement = NULL ;
   }
   if (m_pUpdateStatement)
   {
      delete m_pUpdateStatement ;
      m_pUpdateStatement = NULL ;
   }
   if (m_pDeleteStatement)
   {
      delete m_pDeleteStatement ;
      m_pDeleteStatement = NULL ;
   }
   return MQDB_OK ;
}

//********************************************************************
//
//  MQDBSTATUS CMQODBCTable::DeleteRecord
//
// Delete records from the table.
//
//********************************************************************

#define  DELETE_BUFFER_LEN  1024

MQDBSTATUS CMQODBCTable::DeleteRecord(
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere)
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   DECLARE_BUFFER(szBuffer, DELETE_BUFFER_LEN) ;

   wsprintfA(szBuffer, "DELETE FROM %s", m_lpszTableName) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
	pStatement->Allocate(NULL) ;

   if (lpszSearchCondition)
   {
      lstrcatA( szBuffer, " WHERE ") ;
      lstrcatA( szBuffer, lpszSearchCondition) ;
   }
   else if (!pWhereColumnSearch)
   {
      return  MQDB_E_INVALID_DATA ;
   }
   else
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer ) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, DELETE_BUFFER_LEN) ;

   return ExecWhereStatement( szBuffer,
                              pWhereColumnSearch,
                              cWhere,
	                           pStatement) ;
}

#undef  DELETE_BUFFER_LEN

//********************************************************************
//
//  MQDBSTATUS CMQODBCTable::Truncate
//
// Truncate the table (delete all rows)
//
//********************************************************************

#define  TRUNCATE_BUFFER_LEN  128

MQDBSTATUS CMQODBCTable::Truncate()
{
   DECLARE_BUFFER(szBuffer, TRUNCATE_BUFFER_LEN) ;
   wsprintfA(szBuffer, "TRUNCATE TABLE %s", m_lpszTableName) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
	pStatement->Allocate(szBuffer) ;

	RETCODE sqlstatus = pStatement->Execute();
   MQDBSTATUS dbstatus =  CheckSqlStatus( sqlstatus, pStatement) ;
   return dbstatus ;
}

//-----------------------------------------------------
//
//  MQDBSTATUS CMQODBCTable::GetCount()
//
//-----------------------------------------------------

#define  COUNT_BUFFER_LEN  512

MQDBSTATUS CMQODBCTable::GetCount( IN UINT *puCount,
                                   IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                                   IN LONG               cWhere,
                                   IN MQDBOP             opWhere)
{
   *puCount = 0 ;
   MQDBSTATUS  dbstatus = MQDB_OK ;
   //
   // Create a new statement.
   //
   CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.

   //
   // Execute the command
   //
   DECLARE_BUFFER(szBuffer, COUNT_BUFFER_LEN) ;

   lstrcatA(szBuffer, "SELECT count(*) from ") ;
   lstrcatA(szBuffer, m_lpszTableName) ;

   pStatement->Allocate(NULL) ;

   if (pWhereColumnSearch)
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer) ;
   }

   RETCODE sqlstatus = pStatement->Execute(szBuffer);

   if (ODBC_SUCCESS(sqlstatus) || ODBC_SUCCESS_WINFO(sqlstatus))
   {
      MQDBCOLUMNVAL  pColumns[2] ;

      int cColumns = 0 ;
      INIT_COLUMNVAL(pColumns[ cColumns ]) ;
      pColumns[ cColumns ].lpszColumnName = NULL ;
      pColumns[ cColumns ].nColumnValue   = NULL ;
      pColumns[ cColumns ].nColumnLength  = 0 ;
      pColumns[ cColumns ].mqdbColumnType = MQDB_LONG ;

      dbstatus = pStatement->RetrieveRecordData( pColumns, 1 ) ;

      if (dbstatus == MQDB_OK)
      {
         *puCount = pColumns[ 0 ].nColumnValue ;
      }
   }
   else
   {
      dbstatus = CheckSqlStatus( sqlstatus,
                                 pStatement ) ;
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblodbc.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblodbc.h

Abstract:
   Define a database table class, for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Jan-96   Created

--*/

#ifndef __TBLODBC_H__
#define __TBLODBC_H__

#include "mqdbodbc.h"
#include "odbcstmt.h"

class CMQODBCTable
{
public:
   CMQODBCTable() ;   // Constructor.
   CMQODBCTable( MQDBHANDLE hDatabase ) ;   // Constructor.
   ~CMQODBCTable() ;  // Destructor.

   MQDBSTATUS  Init(IN MQDBHANDLE hDatabase,
                    IN LPSTR      lpszTableName) ;
   MQDBSTATUS  Close() ;

   MQDBSTATUS  DirectInsertExec( IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns) ;

   MQDBSTATUS  ExecuteInsert(
	                     IN CMQDBOdbcSTMT    *pStatement,
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns) ;

   MQDBSTATUS  PrepareInsert( IN MQDBCOLUMNVAL     aColumnVal[],
                              IN LONG              cColumns) ;

   inline void DeletePreparedInsert() ;

   MQDBSTATUS  Truncate() ;

   MQDBSTATUS  UpdateRecord(
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere,
                        IN OUT LPMQDBHANDLE  lphUpdate) ;

   MQDBSTATUS  DeleteRecord(
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere) ;

   MQDBSTATUS  OpenQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0) ;

   MQDBSTATUS  OpenAggrQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout = 0) ;

   MQDBSTATUS  OpenJoin(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0) ;

   MQDBSTATUS  UpdateStatistics() ;

   MQDBSTATUS  GetCount(IN UINT              *puCount,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LONG               cWhere,
                        IN MQDBOP             opWhere) ;

protected:
	CMQDBOdbcSTMT *  GetInsertStmt() { return m_pInsertStatement ; }

   friend MQDBSTATUS APIENTRY  MQDBInsertRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

private:
   MQDBSTATUS  BindParameter( IN LONG           index,
                              IN MQDBCOLUMNVAL  *pColumnCal,
                              IN CMQDBOdbcSTMT  *pStatement) ;

   MQDBSTATUS  FormatDirectData(  IN MQDBCOLUMNVAL  *pColumnVal,
                                  IN int*           pBind,
                                  IN LPSTR          lpszBuffer,
	                               IN CMQDBOdbcSTMT  *pStatement) ;

   void        FormatOrderString( IN LPSTR szBuffer,
                                  IN LPMQDBSEARCHORDER pOrder,
                                  IN LONG              cOrders ) ;

   MQDBSTATUS  FormatOpWhereString(
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhere,
                           IN MQDBOP            opWhere,
                           IN OUT int *         pBind,
	                        IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf ) ;

   MQDBSTATUS  FormatJoinWhereString(
                           IN LPSTR             lpszLeftTableName,
                           IN LPSTR             lpszRightTableName,
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhereLeft,
                           IN DWORD             cWhereRight,
                           IN MQDBOP            opWhere,
                           IN OUT int *         pBind,
                        	IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf) ;

   MQDBSTATUS  FormatDirectJoinData(
                            IN LPSTR             lpszTableName,
                            IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                            IN OUT int *         pBind,
                            IN CMQDBOdbcSTMT     *pStatement,
                            IN OUT LPSTR         lpszBuf ) ;

   MQDBSTATUS  DirectUpdateExec( IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns,
                                 IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                                 IN LPSTR             lpszSearchCondition,
                                 IN LONG              cWhere,
                                 IN MQDBOP            opWhere ) ;

   MQDBSTATUS  ExecuteUpdate( IN CMQDBOdbcSTMT *pStatement,
                              IN LPSTR         lpszCommand = NULL ) ;

   MQDBSTATUS  FormatUpdateCmd(
                             IN MQDBCOLUMNVAL   aColumnVal[],
                             IN LONG            cColumns,
                             IN OUT  int *      pBind,
	                          IN CMQDBOdbcSTMT   *pStatement,
                             IN OUT LPSTR       lpBuffer ) ;

   MQDBSTATUS  BindAndExecuteUpdate(
	                     IN CMQDBOdbcSTMT    *pStatement,
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere ) ;

   MQDBSTATUS  PrepareUpdate( IN MQDBCOLUMNVAL     aColumnVal[],
                              IN LONG              cColumns,
                              IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                              IN LPSTR             lpszSearchCondition,
                              IN LONG              cWhere,
                              IN MQDBOP            opWhere ) ;

   MQDBSTATUS  ExecWhereStatement( IN LPSTR            lpszBuf,
                                   IN MQDBCOLUMNSEARCH *pColSearch,
                                   IN DWORD            cWhere,
	                                IN CMQDBOdbcSTMT    *pStatement ) ;

   MQDBSTATUS  BindWhere( IN LONG             index,
                          IN MQDBCOLUMNSEARCH *pColSearch,
                          IN LONG             cWhere,
                          IN CMQDBOdbcSTMT    *pStatement ) ;

   MQDBSTATUS  CreateQueryStatement(
                                 IN LPSTR             szBuffer,
                                 IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cVal,
                                 IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                                 IN LONG              cWhere,
                              	IN CMQDBOdbcSTMT     *pStatement,
                                 OUT LPMQDBHANDLE     phQuery,
                                 IN BOOL              fGetFirst) ;

   MQDBSTATUS  FormatInsertData( IN MQDBCOLUMNVAL  *pColumnVal,
                                 IN LONG           cColumns,
                                 IN LPSTR          lpszBuffer,
	                              IN CMQDBOdbcSTMT  *pStatement) ;

   MQDBSTATUS  CheckSqlStatus( IN RETCODE        sqlError,
	                            IN CMQDBOdbcSTMT  *pStatement,
                               IN HSTMT          hStmt = SQL_NULL_HSTMT ) ;

   MQDBSTATUS  FormatInsertCmd( IN MQDBCOLUMNVAL   aColumnVal[],
                                IN LONG            cColumns,
                                IN OUT LPSTR       lpBuffer ) ;

   MQDBHANDLE     m_hDatabase ;        // database handle
	HDBC				m_hConnection ;  		// Connection handle
   LPSTR          m_lpszTableName ;
	CMQDBOdbcSTMT *m_pInsertStatement ; // Prepared insert statement.
	CMQDBOdbcSTMT *m_pUpdateStatement ; // Prepared update statement.
	CMQDBOdbcSTMT *m_pDeleteStatement ;

} ;

//
// delete the prepared insert statement.
//
inline void CMQODBCTable::DeletePreparedInsert()
{
   ASSERT(m_pInsertStatement) ;
   delete m_pInsertStatement ;
   m_pInsertStatement = NULL ;
}

#endif // __TBLODBC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\tbloupdt.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tbloupdt.cpp

Abstract:
   Implement the update method for the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      14-Feb-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "tblodbc.h"

#include "tbloupdt.tmh"

#define  UPDATE_BUFFER_LEN 1024

//****************************************************************
//
//  MQDBSTATUS CMQODBCTable::UpdateRecord
//
// Update a record.
//
//****************************************************************

MQDBSTATUS CMQODBCTable::UpdateRecord(
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere,
                        IN OUT LPMQDBHANDLE  lphUpdate)
{
   MQDBSTATUS dbstatus ;

   if (!lphUpdate)
   {
      // Direct execution. Preparation not needed.
      //
      dbstatus = DirectUpdateExec(  aColumnVal,
                                    cColumns,
                                    pWhereColumnSearch,
                                    lpszSearchCondition,
                                    cWhere,
                                    opWhere ) ;
   }
   else if (!(*lphUpdate))
   {
      // Prepare for future use and execute.
      //
      dbstatus = PrepareUpdate(  aColumnVal,
                                 cColumns,
                                 pWhereColumnSearch,
                                 lpszSearchCondition,
                                 cWhere,
                                 opWhere ) ;
      if (dbstatus == MQDB_OK)
      {
         CMQDBOdbcSTMT *pStatement = m_pUpdateStatement ;
         ASSERT(pStatement) ;
         dbstatus = BindAndExecuteUpdate( pStatement,
                                          aColumnVal,
                                          cColumns,
                                          pWhereColumnSearch,
                                          lpszSearchCondition,
                                          cWhere,
                                          opWhere ) ;
         if (dbstatus == MQDB_OK)
         {
            *lphUpdate = (MQDBHANDLE) pStatement ;
         }
         else
         {
            // The execution failed. Delete the prepared statement.
            delete m_pUpdateStatement ;
            m_pUpdateStatement = NULL ;
         }
      }
   }
   else
   {
      // Use prepared statement. Bind and execute.
      //
      dbstatus = BindAndExecuteUpdate( (CMQDBOdbcSTMT *)(*lphUpdate),
                                       aColumnVal,
                                       cColumns,
                                       pWhereColumnSearch,
                                       lpszSearchCondition,
                                       cWhere,
                                       opWhere ) ;
   }

   return  dbstatus ;
}

//***********************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatUpdateCmd
//
//  Format a SQL Update command.
//
//  Input:
//  ======
//  fPrepared    - TRUE if prepared statement.
//  aColumnVal[] - Array of MQDBCOLUMNVAL
//  cColumns     - number of columns in the array
//  szBufer      - buffer for the string
//
//  Output:
//  =======
//  MQDB_OK if format succeeded.
//
//************************************************************

MQDBSTATUS  CMQODBCTable::FormatUpdateCmd(
                             IN MQDBCOLUMNVAL   aColumnVal[],
                             IN LONG            cColumns,
                             IN OUT int*        pBind,
	                          IN CMQDBOdbcSTMT   *pStatement,
                             IN OUT LPSTR       lpBuffer )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   wsprintfA(lpBuffer, "UPDATE %s SET ", m_lpszTableName) ;

   LONG index = 0 ;

   for ( ; index < cColumns ; index++ )
   {
      lstrcatA( lpBuffer, aColumnVal[ index].lpszColumnName ) ;
      if (!pStatement)
      {
         lstrcatA( lpBuffer, " = ?," ) ;
      }
      else
      {
         lstrcatA( lpBuffer, " = " ) ;
         dbstatus = FormatDirectData( &aColumnVal[ index ],
                                      pBind,
                                      lpBuffer,
                                      pStatement ) ;
         if (dbstatus != MQDB_OK)
         {
            return dbstatus ;
         }
      }
   }

   int nLen = lstrlenA(lpBuffer) ;
   lpBuffer[ nLen-1 ] = '\0' ;

   return dbstatus ;
}

//************************************************************
//
//  MQDBSTATUS CMQODBCTable::DirectUpdateExec
//
//  Update a record in the table. Direct execution.
//
//************************************************************

MQDBSTATUS CMQODBCTable::DirectUpdateExec(
                                 IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns,
                                 IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                                 IN LPSTR             lpszSearchCondition,
                                 IN LONG              cWhere,
                                 IN MQDBOP            opWhere )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   // format the command line.
   DECLARE_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
	pStatement->Allocate(NULL) ;

   int  nBind = 1 ;
   dbstatus =  FormatUpdateCmd( aColumnVal,
                                cColumns,
                                &nBind,
                                pStatement,
                                szBuffer ) ;
   RETURN_ON_ERROR ;

   if (lpszSearchCondition)
   {
      lstrcatA(szBuffer, " WHERE ") ;
      lstrcatA(szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer ) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   //
   // Execute the "UPDATE" statement.
   //
   dbstatus = ExecuteUpdate( pStatement, szBuffer ) ;
   return dbstatus ;
}

//*********************************************************************
//
// Execute a prepared UPDATE statement.
//
//*********************************************************************

MQDBSTATUS CMQODBCTable::BindAndExecuteUpdate(
	                     IN CMQDBOdbcSTMT    *pStatement,
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere )
{
    UNREFERENCED_PARAMETER(lpszSearchCondition);
    UNREFERENCED_PARAMETER(opWhere);

    // First bind the parameters.
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG index = 1 ;

   for ( ; index <= cColumns ; index++ )
   {
       dbstatus = BindParameter( index,
                                 &aColumnVal[ index - 1 ],
                                 pStatement) ;
       RETURN_ON_ERROR ;
   }

   if (pWhereColumnSearch)
   {
       index = cColumns + 1 ;
       dbstatus = BindWhere( index,
                             pWhereColumnSearch,
                             cWhere,
                             pStatement ) ;
       RETURN_ON_ERROR ;
   }

   // Next, execute.
   dbstatus = ExecuteUpdate( pStatement ) ;
   return dbstatus ;
}

//******************************************************************
//
// Prepare an UPDATE statement.
//
//******************************************************************

MQDBSTATUS CMQODBCTable::PrepareUpdate(
                              IN MQDBCOLUMNVAL     aColumnVal[],
                              IN LONG              cColumns,
                              IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                              IN LPSTR             lpszSearchCondition,
                              IN LONG              cWhere,
                              IN MQDBOP            opWhere )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   DECLARE_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   dbstatus =  FormatUpdateCmd( aColumnVal,
                                cColumns,
                                NULL,
                                NULL,
                                szBuffer ) ;
   RETURN_ON_ERROR ;

   if (lpszSearchCondition)
   {
      lstrcatA(szBuffer, " WHERE ") ;
      lstrcatA(szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      NULL,
                                      NULL,
                                      szBuffer ) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   RETCODE  sqlstatus ;

   // Create a new statement.
   //
	ASSERT(!m_pUpdateStatement) ;
	m_pUpdateStatement = new CMQDBOdbcSTMT( m_hConnection) ;
	ASSERT(m_pUpdateStatement) ;

   // Prepare the "UPDATE" statement.
   //
	m_pUpdateStatement->Allocate(szBuffer);
	sqlstatus = m_pUpdateStatement->Prepare();

   dbstatus = CheckSqlStatus( sqlstatus, m_pUpdateStatement) ;
   if (dbstatus != MQDB_OK)
   {
	   delete m_pUpdateStatement ;
	   m_pUpdateStatement = NULL ;
   }

   return dbstatus ;
}

//********************************************************************
//
//  MQDBSTATUS CMQODBCTable::ExecuteUpdate
//
// Execute the update and set the return code.
// If no record was updated then error "MQDB_E_NO_ROW_UPDATED" is returned.
//
//********************************************************************

MQDBSTATUS CMQODBCTable::ExecuteUpdate( IN CMQDBOdbcSTMT *pStatement,
                                        IN LPSTR         lpszCommand )
{
	RETCODE sqlstatus = pStatement->Execute(lpszCommand);

   MQDBSTATUS dbstatus = CheckSqlStatus( sqlstatus, pStatement ) ;
   if (dbstatus == MQDB_OK)
   {
      LONG lCount ;
      sqlstatus = pStatement->GetRowsCount(&lCount) ;
      if (ODBC_SUCCESS(sqlstatus))
      {
         if (lCount == 0)
         {
            //
            // No row was updated. We consider this an error, although
            // SQL semantic consider this as success.
            //
            dbstatus = MQDB_E_NO_ROW_UPDATED ;
         }
      }
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\tbloutil.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tbloutil.cpp

Abstract:
   Implement utility methods for the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      14-Feb-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "dbodbc.h"
#include "tblodbc.h"

#include "tbloutil.tmh"

MQDBSTATUS CMQODBCTable::CheckSqlStatus(
                             IN RETCODE        sqlError,
	                          IN CMQDBOdbcSTMT  *pStatement,
                             IN HSTMT          hStmtIn /* SQL_NULL_HSTMT */ )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   if (!ODBC_SUCCESS(sqlError))
   {
      CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
      ASSERT(pDatabase) ;
      dbstatus = pDatabase->CheckSqlStatus( sqlError,
	                                         pStatement,
                                            hStmtIn ) ;
   }

   return dbstatus ;
}


//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::FormatDirectData
//
//  Format the data into the command string of a direct execution string.
//  If data need binding then replace it with the '?' mark and bind.
//
//  Input
//  =====
// int* nBind- index for binding. Incremented here if binding was done.
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::FormatDirectData(
                                 IN MQDBCOLUMNVAL  *pColumnVal,
                                 IN int*           pBind,
                                 IN LPSTR          lpszBuffer,
	                              IN CMQDBOdbcSTMT  *pStatement)
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   switch (pColumnVal->mqdbColumnType)
   {
      case MQDB_SHORT:
      case MQDB_LONG:
      case MQDB_IDENTITY:
      {
          char szTmpBuff[ 24 ] ;
          wsprintfA(szTmpBuff, "%ld,", pColumnVal->nColumnValue) ;
          lstrcatA(lpszBuffer, szTmpBuff) ;
          break ;
      }

      case MQDB_STRING:
      {
          lstrcatA(lpszBuffer, "'") ;
          lstrcatA(lpszBuffer, (LPSTR) pColumnVal->nColumnValue) ;
          lstrcatA(lpszBuffer, "',") ;
          break ;
      }

      default:
      {
          lstrcatA(lpszBuffer, "?,") ;
          ASSERT(pBind) ;
          dbstatus = BindParameter( *pBind,
                                    pColumnVal,
                                    pStatement) ;
          RETURN_ON_ERROR ;
          (*pBind)++ ;
          break ;
      }
   }

   return dbstatus ;
}

/***********************************************************
*
*  BOOL  CMQODBCTable::FormatOpWhereString
*
*  Format a "WHERE" string for a SELECT, UPDATE or DELETE.
*
* Input:
* ======
* IN pWhereColumnSearch - poitner to a search structure.
* IN cWhere - Number of search conditions in the Where arrary.
* IN opWhere - Operation to be performed between the conditions (AND or OR).
* IN OUT  lpszBuf - buffer to contain the string. The string prepared
*                   by this function is catenated to the present content
*                   of lpszBuf.
*
* Output:
* =======
* TRUE if one of the value must be bound before execution.
*
************************************************************/

MQDBSTATUS  CMQODBCTable::FormatOpWhereString(
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhere,
                           IN MQDBOP            opWhere,
                           IN OUT  int*         pBind,
	                        IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf )
{
   ASSERT((opWhere == AND) || (opWhere == OR)) ;

   MQDBSTATUS dbstatus = MQDB_OK ;

   lstrcatA( lpszBuf, " WHERE ") ;

   DWORD index = 0 ;
   for ( ; index < cWhere ; index++ )
   {
      lstrcatA(lpszBuf, " (") ;
      lstrcatA(lpszBuf, pWhereColumnSearch->mqdbColumnVal.lpszColumnName) ;

      switch (pWhereColumnSearch->mqdbColumnVal.mqdbColumnType)
      {
         case MQDB_STRING:
            lstrcatA( lpszBuf,
                         dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ] ) ;
            lstrcatA( lpszBuf,
                  (LPSTR) pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
            break ;

         case MQDB_SHORT:
         case MQDB_LONG:
         case MQDB_IDENTITY:
         {
            char szTmpBuff[ 24 ] ;
            lstrcatA( lpszBuf,
                         dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ] ) ;
            wsprintfA( szTmpBuff, "%ld)",
                         pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
            lstrcatA( lpszBuf, szTmpBuff) ;
            break ;
         }

         default:
         {
            // bind the "where".
            //
            MQDBCOLUMNTYPE cType =
                       pWhereColumnSearch->mqdbColumnVal.mqdbColumnType ;
            if ((dbODBCSQLTypes[ cType ] == SQL_LONGVARBINARY) &&
              pWhereColumnSearch->mqdbOp == EQ)
            {
               lstrcatA( lpszBuf, " LIKE ?)") ;
            }
            else
            {
               lstrcatA( lpszBuf,
                         dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ] ) ;
               lstrcatA( lpszBuf, "?)") ;
            }

            if (pStatement)
            {
               // Bind
               //
               ASSERT(pBind) ;
               dbstatus = BindParameter( *pBind,
                                      &pWhereColumnSearch->mqdbColumnVal,
                                      pStatement) ;
               RETURN_ON_ERROR ;
               (*pBind)++ ;
            }
         }
      }

      if (index < (cWhere - 1))
      {
         lstrcatA( lpszBuf, dbODBCOpNameStr[ opWhere ]) ;
      }
      pWhereColumnSearch++ ;
   }

   return dbstatus ;
}

/*************************************************************************
*
*  ExecWhereStatement
*
*  Execute a statement with a WHERE clause. Only for SELECT or DELETE.
*  UPDATE is done differently, because its statement may already be
*  prepared and the updated values must be bound.
*
**************************************************************************/

MQDBSTATUS  CMQODBCTable::ExecWhereStatement(
                                       IN LPSTR            lpszBuf,
                                       IN MQDBCOLUMNSEARCH *pColSearch,
                                       IN DWORD            cWhere,
                                       IN CMQDBOdbcSTMT    *pStatement )
{
    UNREFERENCED_PARAMETER(cWhere);
    UNREFERENCED_PARAMETER(pColSearch);

   ASSERT(pStatement) ;

   RETCODE  sqlstatus ;
   MQDBSTATUS dbstatus = MQDB_OK ;

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   ASSERT(pDatabase) ;
   if ( pDatabase->GetMultipleQueriesState() )
   {
      DWORD dwDBMSType = pDatabase->GetDMBSType() ;
      RETCODE st = pStatement->EnableMultipleQueries( dwDBMSType ) ;
      DBG_USED(st);
      ASSERT( st == SQL_SUCCESS ) ;
   }

   sqlstatus = pStatement->Execute(lpszBuf);
   if (!ODBC_SUCCESS(sqlstatus))
   {
      SDWORD  sdwNativeError ;
      UCHAR   szSqlState[SQLSTATELEN];

      if ( !OdbcStateIsEx( m_hConnection,
                           pStatement->GetHandle(),
                           OERR_SQL_OPTION_CHANGED,
                           &sdwNativeError,
                           szSqlState ))
      {
         if (!lstrcmpA((const char *)szSqlState, OERR_DBMS_NOT_AVAILABLE))
         {
            dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
         }
         else
         {
            ASSERT( sqlstatus != SQL_SUCCESS_WITH_INFO ) ;
            dbstatus = pDatabase->GetDBStatus( sdwNativeError,
                                               szSqlState ) ;
            if (dbstatus == MQDB_OK)
            {
               dbstatus = MQDB_E_DATABASE ;
            }
         }
      }
      else
      {
         //
         // SQL server change the cursor type. This is OK!.
         //
         ASSERT( sqlstatus == SQL_SUCCESS_WITH_INFO ) ;
         ASSERT( (pDatabase->GetMultipleQueriesState()) ||
                 (pDatabase->GetNoLockQueriesState()) ) ;
      }
   }

   return dbstatus ;
}

//*****************************************************************
//
//  MQDBSTATUS CMQODBCTable::BindParameter
//
// Bind a parameter
//
//*****************************************************************

MQDBSTATUS CMQODBCTable::BindParameter( IN LONG           index,
                                        IN MQDBCOLUMNVAL  *pColumnVal,
                                        IN CMQDBOdbcSTMT  *pStatement)
{
   ASSERT(pColumnVal->cbSize == 24) ;

   RETCODE sqlstatus ;
   SWORD fSqlType = dbODBCSQLTypes[ pColumnVal->mqdbColumnType ] ;
   switch (fSqlType)
   {
      case SQL_SMALLINT:
      case SQL_INTEGER:
      {
         sqlstatus = pStatement->BindParameter( (UDWORD) index,
                                                SQL_C_DEFAULT,
                                                fSqlType,
              dbODBCPrecision[ pColumnVal->mqdbColumnType ],
                               pColumnVal->nColumnLength,
                               (PTR) &(pColumnVal->nColumnValue),
                               (SDWORD *) NULL) ;
         break ;
      }

      default:
      {
         SDWORD  *sdSize = (SDWORD *) &(pColumnVal->dwReserve_A) ;
         *sdSize = pColumnVal->nColumnLength ;
         sqlstatus = pStatement->BindParameter( (UDWORD) index,
                                                SQL_C_DEFAULT,
                                                fSqlType,
                                        pColumnVal->nColumnLength,
                                        pColumnVal->nColumnLength,
                                        (PTR) pColumnVal->nColumnValue,
                                                sdSize) ;
         break ;
      }
   }
   if (!ODBC_SUCCESS(sqlstatus))
   {
       MQDBSTATUS dbstatus = MQDB_E_DATABASE ;
       if (OdbcStateIs( m_hConnection, pStatement->GetHandle(),
                                                     OERR_DBMS_NOT_AVAILABLE))
       {
          dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
       }
       return dbstatus ;
   }
   return MQDB_OK ;
}

MQDBSTATUS CMQODBCTable::BindWhere( IN LONG             index,
                                    IN MQDBCOLUMNSEARCH *pColSearch,
                                    IN LONG             cWhere,
                                    IN CMQDBOdbcSTMT    *pStatement )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG windex = 0 ;
   for ( ; windex < cWhere ; windex++ )
   {
      if (TypeMustBind(pColSearch->mqdbColumnVal.mqdbColumnType))
      {
         dbstatus = BindParameter( index,
                                   &(pColSearch->mqdbColumnVal),
                                   pStatement) ;
         if (dbstatus != MQDB_OK)
         {
            return dbstatus ;
         }
         index++ ;
      }
      pColSearch++ ;
   }
   return dbstatus ;
}


MQDBSTATUS CMQODBCTable::UpdateStatistics()
{
   char szCommand[128] = {"UPDATE STATISTICS "} ;
   lstrcatA(szCommand,  m_lpszTableName) ;

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   return  pDatabase->Escape( szCommand ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigfin.cpp ===
//
// cMqMigFinish.cpp : implementation file
//

#include "stdafx.h"
#include "MqMig.h"
#include "cMigFin.h"
#include "loadmig.h"

#include "cmigfin.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HRESULT  g_hrResultMigration ;
extern BOOL     g_fIsLoggingDisable ;

/////////////////////////////////////////////////////////////////////////////
// cMqMigFinish property page

IMPLEMENT_DYNCREATE(cMqMigFinish, CPropertyPageEx)

cMqMigFinish::cMqMigFinish() : CPropertyPageEx(cMqMigFinish::IDD)
{
	//{{AFX_DATA_INIT(cMqMigFinish)
	//}}AFX_DATA_INIT
	m_psp.dwFlags |= PSP_HIDEHEADER;
}

cMqMigFinish::~cMqMigFinish()
{
}

void cMqMigFinish::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMqMigFinish)
	DDX_Control(pDX, IDC_VIEW_LOG_FILE, m_cbViewLogFile);
	DDX_Control(pDX, IDC_FINISH_TEXT, m_Text);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMqMigFinish, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMqMigFinish)
	ON_BN_CLICKED(IDC_VIEW_LOG_FILE, OnViewLogFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMqMigFinish message handlers

BOOL cMqMigFinish::OnSetActive()
{
    CPropertyPageEx::OnSetActive();

	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*) GetParent();
	
    CString strMessage;
    if (SUCCEEDED(g_hrResultMigration))
    {
        //
        // disable the "back" button if migration was successful.
        //
        pageFather->SetWizardButtons(PSWIZB_FINISH);
        strMessage.LoadString(IDS_MIGRATION_SUCCEDED);
    }
    else
    {
        pageFather->SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);

        if (g_hrResultMigration == HRESULT_FROM_WIN32(E_ACCESSDENIED) ||
            g_hrResultMigration == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
        {
            strMessage.LoadString(IDS_INSUFFICIENT_PERMISSION);
        }
        else if (g_fIsLoggingDisable)
        {
            strMessage.LoadString(IDS_MIGRATION_FAILED_NO_LOG);	
        }
        else
        {
            strMessage.LoadString(IDS_MIGRATION_FAILED);	
        }
    }

    m_Text.SetWindowText( strMessage );

    if (g_fIsLoggingDisable)
    {
        //
        // disable "view log file" button
        //
        m_cbViewLogFile.EnableWindow( FALSE );
    }
    else
    {
        m_cbViewLogFile.EnableWindow() ;
    }

    return TRUE ;
}

void cMqMigFinish::OnViewLogFile()
{
	// TODO: Add your control notification handler code here
	ViewLogFile();
}

LRESULT cMqMigFinish::OnWizardBack()
{
	// TODO: Add your specialized code here and/or call the base class
	
	return IDD_MQMIG_PREMIG ;
}

BOOL cMqMigFinish::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblquery.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblquery.cpp

Abstract:
   Implement the query methods in the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Aug-96   Created

--*/

#include "dbsys.h"
#include "tblodbc.h"
#include "dbodbc.h"

#include "tblquery.tmh"

#define QUERY_BUFFER_LEN  1024
#define JOIN_BUFFER_LEN   2048

//*******************************************************************
//
//  MQDBSTATUS CMQODBCTable::OpenQuery
//
// Query and get records from the database.
//
//*******************************************************************

MQDBSTATUS CMQODBCTable::OpenQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   //
   // Check validity of parameters.
   //
   if (cColumns < 0)
   {
      return MQDB_E_BAD_CCOLUMNS ;
   }
   else if (fGetFirst)
   {
      if (!aColumnVal)
      {
         return MQDB_E_INVALID_DATA ;
      }
   }
   else if (!phQuery)
   {
      return MQDB_E_INVALID_DATA ;
   }

   //
   // Parameters are valid. Format the query command.
   //
   DECLARE_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   lstrcatA(szBuffer, "SELECT ") ;
   if (!aColumnVal || !aColumnVal[0].lpszColumnName)
   {
      // Retrieve all columns.
      //
      lstrcatA(szBuffer, " *") ;
   }
   else
   {
      LONG index ;
      for ( index = 0 ; index < cColumns ; index++ )
      {
         lstrcatA( szBuffer, aColumnVal[ index ].lpszColumnName) ;
         lstrcatA( szBuffer, ", ") ;
      }
      int nLen = lstrlenA(szBuffer) ;
      szBuffer[ nLen - 2 ] = '\0' ;
   }
   lstrcatA( szBuffer, " FROM " ) ;
   lstrcatA( szBuffer, m_lpszTableName ) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
	pStatement->Allocate(NULL) ;

   //
   //  Handle the "NoLock" condition
   //
   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   ASSERT(pDatabase) ;
   if ( pDatabase->GetNoLockQueriesState() )
   {
      DWORD dwDBMSType = pDatabase->GetDMBSType() ;
      pStatement->EnableNoLockQueries( dwDBMSType ) ;
      lstrcatA( szBuffer, " NOLOCK " ) ;
   }

   //
   // Handle timeout
   //
   if (dwTimeout != 0)
   {
      dbstatus = pStatement->SetQueryTimeout( dwTimeout ) ;
      if (dbstatus != MQDB_OK)
      {
         delete pStatement ;
         return dbstatus ;
      }
   }

   if (lpszSearchCondition)
   {
      ASSERT(cWhere == 1) ;
      lstrcatA( szBuffer, " WHERE ") ;
      lstrcatA( szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer) ;
      RETURN_ON_ERROR ;
   }

   FormatOrderString( szBuffer,
                      lpOrder,
                      cOrders ) ;

   VERIFY_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   return CreateQueryStatement( szBuffer,
                                aColumnVal,
                                cColumns,
                                pWhereColumnSearch,
                                cWhere,
                                pStatement,
                                phQuery,
                                fGetFirst) ;
}

//*******************************************************************
//
//  MQDBSTATUS CMQODBCTable::OpenJoin
//
//*******************************************************************

MQDBSTATUS CMQODBCTable::OpenJoin(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout )
{
    UNREFERENCED_PARAMETER(dwTimeout);

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   if (!pDatabase)
   {
      return MQDB_E_BAD_HDATABASE ;
   }
   m_hConnection = pDatabase->GethDbc() ;

   DECLARE_BUFFER(szBuffer, JOIN_BUFFER_LEN) ;
   char szTmpBuff[ JOIN_BUFFER_LEN ] ;
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG index ;

   if (cLefts > 0)
   {
      lstrcatA( szBuffer, "SELECT ") ;
      for ( index = 0 ; index < cLefts ; index++ )
      {
         wsprintfA( szTmpBuff, "%s.%s, ", lpszLeftTableName,
                                  aColumnVal[ index ].lpszColumnName) ;
         lstrcatA( szBuffer, szTmpBuff) ;
      }
      int nLen = lstrlenA( szBuffer ) ;
      szBuffer[ nLen - 2 ] = '\0' ;
   }
   else if (cRights <= 0)
   {
      return MQDB_E_INVALID_DATA ;
   }
   else
   {
      wsprintfA(szBuffer, "SELECT %s.%s", lpszRightTableName,
                                       aColumnVal[0].lpszColumnName) ;
   }

   for ( index = cLefts ; index < (cRights + cLefts) ; index++ )
   {
        wsprintfA(szTmpBuff, ", %s.%s", lpszRightTableName,
                                  aColumnVal[ index ].lpszColumnName) ;
        lstrcatA( szBuffer, szTmpBuff) ;
   }

   if (opJoin->fOuterJoin)
   {
      wsprintfA(szTmpBuff, " FROM {oj %s LEFT OUTER JOIN %s",
                               lpszLeftTableName, lpszRightTableName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
      wsprintfA(szTmpBuff, " ON %s.%s %s %s.%s}", lpszLeftTableName,
                                        opJoin->lpszLeftColumnName,
                                        dbODBCOpNameStr[ opJoin->opJoin ],
                                        lpszRightTableName,
                                        opJoin->lpszRightColumnName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
   }
   else
   {
      // Inner Join.
      wsprintfA(szTmpBuff, " FROM %s, %s", lpszLeftTableName,
                                           lpszRightTableName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
   }

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
	pStatement->Allocate(NULL) ;

   int nBind = 1 ;
   if (pWhereColumnSearch)
   {
      dbstatus = FormatJoinWhereString( lpszLeftTableName,
                                        lpszRightTableName,
                                        pWhereColumnSearch,
                                        cWhereLeft,
                                        cWhereRight,
                                        opWhere,
                                        &nBind,
                                        pStatement,
                                        szBuffer) ;
      RETURN_ON_ERROR ;
      if (!opJoin->fOuterJoin)
      {
         lstrcatA(szBuffer, " AND") ;
      }
   }
   else if (!opJoin->fOuterJoin)
   {
      lstrcatA(szBuffer, " WHERE") ;
   }

   if (!opJoin->fOuterJoin)
   {
      wsprintfA(szTmpBuff, " %s.%s%s%s.%s", lpszLeftTableName,
                                        opJoin->lpszLeftColumnName,
                                        dbODBCOpNameStr[ opJoin->opJoin ],
                                        lpszRightTableName,
                                        opJoin->lpszRightColumnName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
   }

   FormatOrderString( szBuffer,
                      pOrder,
                      cOrders ) ;

   VERIFY_BUFFER(szBuffer, JOIN_BUFFER_LEN) ;

   return CreateQueryStatement( szBuffer,
                                aColumnVal,
                                (cLefts + cRights),
                                pWhereColumnSearch,
                                (cWhereLeft + cWhereRight),
                                pStatement,
                                phQuery,
                                fGetFirst) ;
}

//*******************************************************************
//
//  MQDBSTATUS CMQODBCTable::OpenAggrQuery
//
//  Aggregate query
//
//*******************************************************************

MQDBSTATUS CMQODBCTable::OpenAggrQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout)
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG       cColumns = 1 ;

   //
   // Parameters are valid. Format the query command.
   //
   DECLARE_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   lstrcatA(szBuffer, "SELECT ") ;
   if (!aColumnVal || !aColumnVal[0].lpszColumnName)
   {
      //
      // A column must be specified.
      //
      return  MQDB_E_INVALID_DATA ;
   }
   else if ((aColumnVal[ 0 ].mqdbColumnType != MQDB_SHORT) &&
            (aColumnVal[ 0 ].mqdbColumnType != MQDB_LONG)  &&
            (aColumnVal[ 0 ].mqdbColumnType != MQDB_FIXBINARY))
   {
      //
      // We can aggregate only a numeric column.
      //
      return  MQDB_E_INVALID_DATA ;
   }
   else
   {
      lstrcatA( szBuffer, dbODBCAggrNameStr[ mqdbAggr ]) ;
      lstrcatA( szBuffer, aColumnVal[ 0 ].lpszColumnName) ;
      lstrcatA( szBuffer, ")" ) ;
   }
   lstrcatA( szBuffer, " FROM " ) ;
   lstrcatA( szBuffer, m_lpszTableName ) ;

   //
   // Create a new statement.
   //
   CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   pStatement->Allocate(NULL) ;

   //
   //  Handle the "NoLock" condition
   //
   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   ASSERT(pDatabase) ;
   if ( pDatabase->GetNoLockQueriesState() )
   {
      DWORD dwDBMSType = pDatabase->GetDMBSType() ;
      pStatement->EnableNoLockQueries( dwDBMSType ) ;
      lstrcatA( szBuffer, " NOLOCK " ) ;
   }

   //
   // Handle timeout
   //
   if (dwTimeout != 0)
   {
      dbstatus = pStatement->SetQueryTimeout( dwTimeout ) ;
      if (dbstatus != MQDB_OK)
      {
         delete pStatement ;
         return dbstatus ;
      }
   }

   if (lpszSearchCondition)
   {
      ASSERT(cWhere == 1) ;
      lstrcatA( szBuffer, " WHERE ") ;
      lstrcatA( szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   return CreateQueryStatement( szBuffer,
                                aColumnVal,
                                cColumns,
                                pWhereColumnSearch,
                                cWhere,
                                pStatement,
                                NULL,
                                TRUE ) ;
}

//*******************************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatDirectJoinData
//
//*******************************************************************

MQDBSTATUS  CMQODBCTable::FormatDirectJoinData(
                            IN LPSTR             lpszTableName,
                            IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                            IN OUT int *         pBind,
                            IN CMQDBOdbcSTMT     *pStatement,
                            IN OUT LPSTR         lpszBuf )
{
   MQDBSTATUS  dbstatus = MQDB_OK ;

   char szTmpBuff[ JOIN_BUFFER_LEN ] ;
   wsprintfA( szTmpBuff, " (%s.%s %s ",  lpszTableName,
            pWhereColumnSearch->mqdbColumnVal.lpszColumnName,
            dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ]) ;
   lstrcatA( lpszBuf, szTmpBuff) ;

   switch (pWhereColumnSearch->mqdbColumnVal.mqdbColumnType)
   {
      case MQDB_STRING:
      {
         lstrcatA( lpszBuf, "'") ;
         lstrcatA( lpszBuf, (LPSTR)
                     pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
         lstrcatA( lpszBuf, "')") ;
         break ;
      }

      case MQDB_SHORT:
      case MQDB_LONG:
      {
         wsprintfA( szTmpBuff, "%ld)",
                      pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
         lstrcatA( lpszBuf, szTmpBuff) ;
         break ;
      }

      default:
      {
         // bind the "where".
         //
         lstrcatA( lpszBuf, "?)") ;
         ASSERT(pBind) ;
         dbstatus = BindParameter( *pBind,
                                   &pWhereColumnSearch->mqdbColumnVal,
                                   pStatement) ;
         RETURN_ON_ERROR ;
         (*pBind)++ ;
         break ;
      }
   }

   return dbstatus ;
}

//*******************************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatJoinWhereString
//
//*******************************************************************

MQDBSTATUS  CMQODBCTable::FormatJoinWhereString(
                           IN LPSTR             lpszLeftTableName,
                           IN LPSTR             lpszRightTableName,
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhereLeft,
                           IN DWORD             cWhereRight,
                           IN MQDBOP            opWhere,
                           IN OUT int *         pBind,
                        	IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf)
{
   ASSERT((opWhere == AND) || (opWhere == OR)) ;

   MQDBSTATUS dbstatus = MQDB_OK ;
   lstrcatA( lpszBuf, " WHERE ") ;

   DWORD index = 0 ;
   for ( ; index < cWhereLeft ; index++ )
   {
      dbstatus = FormatDirectJoinData( lpszLeftTableName,
                                       pWhereColumnSearch,
                                       pBind,
                                       pStatement,
                                       lpszBuf ) ;
      RETURN_ON_ERROR ;

      if (index < ((cWhereLeft + cWhereRight) - 1))
      {
         lstrcatA( lpszBuf, dbODBCOpNameStr[ opWhere ]) ;
      }
      pWhereColumnSearch++ ;
   }

   index = cWhereLeft ;
   for ( ; index < (cWhereLeft + cWhereRight) ; index++ )
   {
      dbstatus = FormatDirectJoinData( lpszRightTableName,
                                       pWhereColumnSearch,
                                       pBind,
                                       pStatement,
                                       lpszBuf ) ;
      RETURN_ON_ERROR ;

      if (index < ((cWhereLeft + cWhereRight) - 1))
      {
         lstrcatA( lpszBuf, dbODBCOpNameStr[ opWhere ]) ;
      }
      pWhereColumnSearch++ ;
   }

   return dbstatus ;
}

//*********************************************************************
//
//  void  CMQODBCTable::FormatOrderString
//
//*********************************************************************

void  CMQODBCTable::FormatOrderString( IN LPSTR szBuffer,
                                       IN LPMQDBSEARCHORDER pOrder,
                                       IN LONG              cOrders )
{
	LONG index ;

   if (pOrder && (cOrders > 0))
   {
      lstrcatA( szBuffer, " ORDER BY ") ;
      for ( index = 0 ; index < cOrders ; index++ )
      {
         lstrcatA( szBuffer, pOrder->lpszColumnName) ;
         lstrcatA( szBuffer, dbODBCOrderNameStr[ pOrder->nOrder ]) ;
         pOrder++ ;
      }

      int nLen = lstrlenA( szBuffer ) ;
      szBuffer[ nLen - 2 ] = '\0' ;
   }
}

//*********************************************************************
//
//  MQDBSTATUS CMQODBCTable::CreateQueryStatement
//
//*********************************************************************

MQDBSTATUS CMQODBCTable::CreateQueryStatement(
                                 IN LPSTR             szBuffer,
                                 IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns,
                                 IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                                 IN LONG              cWhere,
                                 IN CMQDBOdbcSTMT     *pStatement,
                                 OUT LPMQDBHANDLE     phQuery,
                                 IN BOOL              fGetFirst)
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   dbstatus = ExecWhereStatement( szBuffer,
                                  pWhereColumnSearch,
                                  cWhere,
                                  pStatement ) ;
   RETURN_ON_ERROR ;

   pStatement->SetColumnsCount(cColumns);

   try
   {
      if (fGetFirst)
      {
         // Fetch the data.
         //
         dbstatus = pStatement->RetrieveRecordData( aColumnVal ) ;
         if ((dbstatus == MQDB_OK) && phQuery)
         {
            *phQuery = (MQDBHANDLE) pStatement ;
         }
         else
         {
            // We can reach here if dbstatus == MQDB_E_NO_MORE_DATA.
            // In this case it seems ok to delete the statemant. The
            // caller can't use it for retrieving data.
            delete pStatement ;
            pStatement = NULL ;
         }
      }
      else
      {
         *phQuery = (MQDBHANDLE) pStatement ;
      }
   }
	catch(...)
   {
      delete pStatement ;
      pStatement = NULL ;
      dbstatus = MQDB_E_INVALID_DATA ;
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmighelp.h ===
#if !defined(AFX_CMIGHELP_H__8FD65A45_E034_11D2_BE6C_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGHELP_H__8FD65A45_E034_11D2_BE6C_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigHelp.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigHelp dialog

class cMigHelp : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigHelp)

// Construction
public:
	cMigHelp();
	~cMigHelp();

// Dialog Data
	//{{AFX_DATA(cMigHelp)
	enum { IDD = IDD_MQMIG_HELP };
	BOOL	m_fRead;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigHelp)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	void openHtmlHelp();
	// Generated message map functions
	//{{AFX_MSG(cMigHelp)
	afx_msg void OnCheckRead();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGHELP_H__8FD65A45_E034_11D2_BE6C_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigfin.h ===
#if !defined(AFX_CMQMIGFINISH_H__B8874CD0_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_CMQMIGFINISH_H__B8874CD0_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMqMigFinish.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMqMigFinish dialog

class cMqMigFinish : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMqMigFinish)

// Construction
public:
	cMqMigFinish();
	~cMqMigFinish();

// Dialog Data
	//{{AFX_DATA(cMqMigFinish)
	enum { IDD = IDD_MQMIG_FINISH };
	CButton	m_cbViewLogFile;
	CStatic	m_Text;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMqMigFinish)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMqMigFinish)
	afx_msg void OnViewLogFile();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMQMIGFINISH_H__B8874CD0_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmighelp.cpp ===
// cMigHelp.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigHelp.h"

#include "cmighelp.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL g_fHelpRead = FALSE;

/////////////////////////////////////////////////////////////////////////////
// cMigHelp property page

IMPLEMENT_DYNCREATE(cMigHelp, CPropertyPageEx)

cMigHelp::cMigHelp() : CPropertyPageEx(cMigHelp::IDD,0, IDS_HELP_TITLE, IDS_HELP_SUBTITLE)
{
	//{{AFX_DATA_INIT(cMigHelp)
	m_fRead = FALSE;
	//}}AFX_DATA_INIT
}

cMigHelp::~cMigHelp()
{
}

void cMigHelp::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigHelp)
	DDX_Check(pDX, IDC_MQMIG_CHECK1, m_fRead);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigHelp, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigHelp)
	ON_BN_CLICKED(IDC_MQMIG_CHECK1, OnCheckRead)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMigHelp message handlers

BOOL cMigHelp::OnSetActive() 
{
	// The default button is Back
	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_BACK);
	return CPropertyPageEx::OnSetActive();
}

void cMigHelp::OnCheckRead() 
{
	UpdateData(TRUE);
	CPropertySheetEx* pageFather;	
	pageFather = (CPropertySheetEx*)GetParent();
	if(m_fRead)
	{
		pageFather->SetWizardButtons(PSWIZB_BACK|PSWIZB_NEXT);
		g_fHelpRead = TRUE;
	}
	else
	{
		pageFather->SetWizardButtons(PSWIZB_BACK);
		g_fHelpRead = FALSE;
	}
}

BOOL cMigHelp::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						openHtmlHelp();
						return TRUE;
		
	}		
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}

void cMigHelp::openHtmlHelp()
{
	HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT|PSWIZB_BACK);
	g_fHelpRead = TRUE;
	m_fRead = TRUE;
	UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigpre.cpp ===
// cMigPre.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigPre.h"
#include "loadmig.h"

#include "cmigpre.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HRESULT  g_hrResultAnalyze ;
extern bool     b_FirstWaitPage ;
extern BOOL     g_fIsLoggingDisable ;

/////////////////////////////////////////////////////////////////////////////
// cMigPre property page

IMPLEMENT_DYNCREATE(cMigPre, CPropertyPageEx)

cMigPre::cMigPre() : CPropertyPageEx( cMigPre::IDD,
                                      0,
                                      IDS_PREIMPORT_TITLE,
                                      IDS_PREIMPORT_SUBTITLE )
{
	//{{AFX_DATA_INIT(cMigPre)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

cMigPre::~cMigPre()
{
}

void cMigPre::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigPre)
	DDX_Control(pDX, IDC_VIEW_LOG_FILE, m_cbViewLogFile);
	DDX_Control(pDX, IDC_TEXT1, m_Text);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigPre, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigPre)
	ON_BN_CLICKED(IDC_VIEW_LOG_FILE, OnViewLogFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMigPre message handlers

BOOL cMigPre::OnSetActive()
{

	CPropertySheetEx* pageFather;
	HWND hCancel;

	pageFather = (CPropertySheetEx*) GetParent();
    pageFather->SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);

    //
    // Enable the cancel button.
    //
	hCancel=::GetDlgItem( ((CWnd*)pageFather)->m_hWnd ,IDCANCEL);
	ASSERT(hCancel != NULL);
	if(FALSE == ::IsWindowEnabled(hCancel))
    {
		::EnableWindow(hCancel,TRUE);
    }
	
    //
    // By default, disable "view log file" button
    //
    m_cbViewLogFile.EnableWindow( FALSE );

    CString strMessage;
    if (SUCCEEDED(g_hrResultAnalyze))
    {
        strMessage.LoadString(IDS_ANALYSIS_SUCCEEDED);
    }
    else
    {
        if (!g_fIsLoggingDisable)
        {
            strMessage.LoadString(IDS_ANALYSIS_FAILED);	
            m_cbViewLogFile.EnableWindow();
        }
        else
        {
            strMessage.LoadString(IDS_ANALYSIS_FAILED_NO_LOG);	
        }
    }
    m_Text.SetWindowText( strMessage );

	return CPropertyPageEx::OnSetActive();
}

LRESULT cMigPre::OnWizardNext()
{
    //
    // skip to the wait page  and clear flag.
    //
    b_FirstWaitPage = false ;
    g_fReadOnly = FALSE;

	return CPropertyPageEx::OnWizardNext();
}

LRESULT cMigPre::OnWizardBack()
{
    //
    // jump diretctly to the server page
    //
	return IDD_MQMIG_SERVER;
}

void cMigPre::OnViewLogFile()
{
	// TODO: Add your control notification handler code here
	ViewLogFile();
}



BOOL cMigPre::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmiglog.cpp ===
// cMigLog.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigLog.h"
#include "loadmig.h"
#include "Shlwapi.h"

#include "cmiglog.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern LPTSTR  g_pszLogFileName ;
extern ULONG   g_ulTraceFlags ;

BOOL g_fIsLoggingDisable = FALSE;
const int DISABLE_LOGGING = 4 ;
BOOL g_fAlreadyAsked = FALSE;

BOOL FormDirectory( IN const TCHAR * lpPathName);
BOOL CreateDirectoryTree( IN const TCHAR * pszDirTree);


/////////////////////////////////////////////////////////////////////////////
// cMigLog property page

IMPLEMENT_DYNCREATE(cMigLog, CPropertyPageEx)

cMigLog::cMigLog() : CPropertyPageEx(cMigLog::IDD, 0, IDS_LOGGING_TITLE, IDS_LOGGING_SUBTITLE)
{	
	TCHAR strPathName[MAX_PATH];
	CString cPathName;
	GetSystemDirectory(strPathName,MAX_PATH);
	cPathName=strPathName;
	cPathName+="\\mqmig.log";
	
	//{{AFX_DATA_INIT(cMigLog)
	m_iValue = 0 ; // Error Button as default button
	m_strFileName = cPathName;
	//}}AFX_DATA_INIT
}

cMigLog::~cMigLog()

{
}

void cMigLog::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigLog)
	DDX_Radio(pDX, IDC_RADIO_ERR, m_iValue);
	DDX_Text(pDX, IDC_EDIT_LOGFILE, m_strFileName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigLog, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigLog)
	ON_BN_CLICKED(IDC_MQMIG_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_RADIO_DISABLE, OnRadioDisable)
	ON_BN_CLICKED(IDC_RADIO_ERR, OnRadioErr)
	ON_BN_CLICKED(IDC_RADIO_INFO, OnRadioInfo)
	ON_BN_CLICKED(IDC_RADIO_TRACE, OnRadioTrace)
	ON_BN_CLICKED(IDC_RADIO_WARN, OnRadioWarn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// cMigLog message handlers

BOOL cMigLog::OnSetActive()
{
	/*enabeling the back and next button for the server page by using a pointer to the father*/
	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT |PSWIZB_BACK);

	return CPropertyPageEx::OnSetActive();
}

LRESULT cMigLog::OnWizardNext()
{

	UpdateData(TRUE);  // executing DDX to get data to the object
	//
	//if disable radio button was picked there is no need for further cheacking
	//
    g_fIsLoggingDisable = FALSE ;
	if (m_iValue != DISABLE_LOGGING)
	{

		if( m_strFileName.GetLength() == 0)
		{
			CResString cMustFile(IDS_STR_MUST_FILE) ;
			CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			::MessageBox( NULL,
			              cMustFile.Get(),
				          cErrorTitle.Get(),
					      (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
			return -1; // error we must stay in the same page
		}
		
		if ((m_strFileName[1] != TEXT(':')) || (m_strFileName[2] != TEXT('\\')))
		{
			CResString cMustFile(IDS_STR_WRONG_PATH) ;
			CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			::MessageBox( NULL,
			              cMustFile.Get(),
				          cErrorTitle.Get(),
					      (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
			return -1;
		}

		CString strRootPath;
        strRootPath.Format(TEXT("%c:\\"), m_strFileName[0]);
        if (GetDriveType(strRootPath) != DRIVE_FIXED)
        {
            CResString cMustFile(IDS_DRIVE_NOT_VALID) ;
			CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			::MessageBox( NULL,
			              cMustFile.Get(),
				          cErrorTitle.Get(),
					      (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
			return -1;
        }
		if (GetFileAttributes(m_strFileName) == 0xFFFFFFFF )
	    {
            ULONG ulError = GetLastError();
            if (ulError == ERROR_PATH_NOT_FOUND)
            {
                CResString cMustFile(IDS_STR_WRONG_PATH) ;
				CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

				::MessageBox( NULL,
							  cMustFile.Get(),
							  cErrorTitle.Get(),
							  (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
				return -1;               
            }
		}

		//
	    // if disasble logging was not selected if file exists but user was already asked about file replacing
		// (funtion: OnBrowse) to do nothing
		//
		if ( GetFileAttributes(m_strFileName) != 0xFFFFFFFF &&
			 !g_fAlreadyAsked  )
		{	
			//
			// the file exists, replace it?
			//
		    CResString cReplaceFile(IDS_STR_REPLACE_FILE);
            CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			TCHAR szError[1024] ;
            _stprintf(szError,_T("%s %s"), m_strFileName, cReplaceFile.Get());
	
		    if (::MessageBox (
			        NULL,
				    szError,
					cErrorTitle.Get(),
				    (MB_TASKMODAL | MB_YESNO | MB_ICONEXCLAMATION )) == IDNO)
		    {
		        return -1; // NO was selected, we must stay in that page
		    }
            //
            // YES was selected, it is time to delete this file
            //
            DeleteFile (m_strFileName);
		}
	
		LPTSTR strPathName = new  TCHAR[ 1 + _tcslen(m_strFileName) ] ;
		_tcscpy(strPathName, m_strFileName) ;
		BOOL bNameWasRemoved = PathRemoveFileSpec(strPathName);
        UNREFERENCED_PARAMETER(bNameWasRemoved);
		//
		//if disable logging was not selected and if path doesn't exists at all prompt a messsage
		//(i.e)it is ok that the file itself doesn't exists in this part
		//

		if(FALSE == PathIsDirectory(strPathName))
		{
			//
			// the path doesn't exists, create it?
			//
			CResString cPreCreatePath(IDS_STR_PRE_CREATE_PATH);
			CResString cCreatePath(IDS_STR_CREATE_PATH);
	        CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

		    TCHAR szError[1024] ;
		    _stprintf(szError, _T("%s %s %s"), cPreCreatePath.Get(), strPathName, cCreatePath.Get());

			if (::MessageBox (
				    NULL,
					szError,
			        cErrorTitle.Get(),
				    (MB_TASKMODAL | MB_YESNO | MB_ICONEXCLAMATION )) == IDNO)
		    {
			    return -1; // NO was selected, we must stay in this page
		    }
			else //== IDYES -> create the specified path
			{
				BOOL bCreateSuccess = CreateDirectoryTree(strPathName);
				if(bCreateSuccess == FALSE)
				{
					CResString cPathCreateFail(IDS_STR_PATH_CREATE_ERROR);
					::MessageBox(
						          NULL,cPathCreateFail.Get(),
								  cErrorTitle.Get(),
								  MB_TASKMODAL | MB_OK | MB_ICONEXCLAMATION);
					return -1;//we must stay in the same page
				}
			
			}

		}

	}//(m_iValue != DISABLE_LOGGING)
    else
    {
        g_fIsLoggingDisable = TRUE;
    }

	if (g_pszLogFileName)
    {
        delete g_pszLogFileName ;
    }
    LPCTSTR pName = m_strFileName ;
    g_pszLogFileName = new TCHAR[ 1 + _tcslen(pName) ] ;
    _tcscpy(g_pszLogFileName, pName) ;

    g_ulTraceFlags = m_iValue ;

	return CPropertyPageEx::OnWizardNext() ;
}

void cMigLog::OnBrowse()
{	
	CString fileName;

	// DDX is called to ensure that data from the radio buttons will be instored in the object
	UpdateData(TRUE);
	static CFileDialog browse( FALSE,
                               TEXT("log"),
                               TEXT("mqmig"),
                                 (OFN_NOCHANGEDIR   |
                                  OFN_PATHMUSTEXIST |
                                  OFN_HIDEREADONLY  |
                                  OFN_OVERWRITEPROMPT) ) ;
		
	if(browse.DoModal() == IDOK)
	{	
        g_fAlreadyAsked = TRUE;
		m_strFileName = browse.GetPathName();
		UpdateData(FALSE);
	}
	else // IDCANCEL
	{

	}

}

static BOOL s_fEnabled = TRUE ;//TRUE if Edit & Browse are Enabled

void cMigLog::OnRadioDisable()
{
    if (!s_fEnabled)
    {
        return ;
    }

    CWnd *hEdit = GetDlgItem(IDC_EDIT_LOGFILE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, FALSE) ;
    }

    hEdit = GetDlgItem(IDC_MQMIG_BROWSE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, FALSE) ;
    }

    s_fEnabled = FALSE ;

    if (g_pszLogFileName)
    {
        delete g_pszLogFileName ;
        g_pszLogFileName = NULL ;
    }
}

void cMigLog::_EnableBrowsing()
{
    if (s_fEnabled)
    {
        return ;
    }

    CWnd *hEdit = GetDlgItem(IDC_EDIT_LOGFILE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, TRUE) ;
    }

    hEdit = GetDlgItem(IDC_MQMIG_BROWSE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, TRUE) ;
    }

    s_fEnabled = TRUE ;
}

void cMigLog::OnRadioErr()
{
    _EnableBrowsing() ;
}

void cMigLog::OnRadioInfo()
{
    _EnableBrowsing() ;
}

void cMigLog::OnRadioTrace()
{
    _EnableBrowsing() ;
}

void cMigLog::OnRadioWarn()
{
    _EnableBrowsing() ;
}


//+-------------------------------------------------------------------------
//
//  Function:   FormDirectory
//
//  Synopsis:   Handle directory creation.
//
//--------------------------------------------------------------------------
BOOL FormDirectory(  IN const TCHAR * lpPathName  )
{
    if (!CreateDirectory(lpPathName, 0))
    {
        DWORD dwError = GetLastError();
        if (dwError != ERROR_ALREADY_EXISTS)
        {
            return FALSE;
        }
    }

    return TRUE;//directory was created succesfully

} //FormDirectory


//+-------------------------------------------------------------------------
//
//  Function:   CreateDirectoryTree
//
//  Synopsis:   Handle directory tree creation.
//
//--------------------------------------------------------------------------
BOOL CreateDirectoryTree(  IN const TCHAR * pszDirTree   )
{
    //
    // pszDirTree must include a drive letter, such that its format is:
    // x:\dir1\dir2\dir3
    // Where dir1\dir2\dir3 is optional, but x:\ is not optional.
    //
    if (!pszDirTree)//pointer is null
	{
        return FALSE;
	}
    if (lstrlen(pszDirTree) < 3)//the path must include a drive letter "X:\"
	{
        return FALSE;
	}

	//
	//check if the path begin with the ":\" sign
	//
    if ( (TEXT(':') != pszDirTree[1]) ||
		 (TEXT('\\') != pszDirTree[2] )          )
	{
        return FALSE;
	}

	//
    // check if drive letter is legal
    //
	TCHAR cDriveLetter =  pszDirTree[0];
	TCHAR szDrive[4]= _T("x:\\");
	szDrive[0] = cDriveLetter;
	if (FALSE == PathFileExists(szDrive))
	{
		return FALSE;
	}

    if (3 == lstrlen(pszDirTree))//the path is the root
	{
        return TRUE;
	}

    TCHAR szDirectory[MAX_PATH];
    lstrcpy(szDirectory, pszDirTree);
    TCHAR * pszDir = szDirectory,
          * pszDirStart = szDirectory;
    UINT uCounter = 0;
    while ( *pszDir )
    {
        //
        // Ignore first backslash - it's right after drive letter
        //
        if ( *pszDir == TEXT('\\'))
        {
            uCounter++;
            if (1 != uCounter)
            {
                *pszDir = 0;// set the new end of the string

                if (!FormDirectory(pszDirStart))
				{
                    return FALSE;
				}

                *pszDir = TEXT('\\') ;//reset the sttring to it's original status
            }
        }

        pszDir = CharNext(pszDir);
    }//While

    if (!FormDirectory(pszDirStart))//last directory
	{
        return FALSE;
	}

    return TRUE;

} //CreateDirectoryTree



BOOL cMigLog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}

LRESULT cMigLog::OnWizardBack() 
{
	//
	//we need to skip the help page and go directly to the welcome page
	//
	return IDD_MQMIG_WELCOME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmiglog.h ===
#if !defined(AFX_CMIGLOG_H__5377E054_D1F6_11D1_9394_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGLOG_H__5377E054_D1F6_11D1_9394_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigLog.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigLog dialog

class cMigLog : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigLog)

// Construction
public:
	cMigLog();
	~cMigLog();

// Dialog Data
	//{{AFX_DATA(cMigLog)
	enum { IDD = IDD_MQMIG_LOGIN };
	int		m_iValue;
	CString	m_strFileName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigLog)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMigLog)
	afx_msg void OnBrowse();
	afx_msg void OnRadioDisable();
	afx_msg void OnRadioErr();
	afx_msg void OnRadioInfo();
	afx_msg void OnRadioTrace();
	afx_msg void OnRadioWarn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void _EnableBrowsing() ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGLOG_H__5377E054_D1F6_11D1_9394_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigpre.h ===
#if !defined(AFX_CMIGPRE_H__09A53B26_52B0_11D2_BE44_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGPRE_H__09A53B26_52B0_11D2_BE44_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigPre.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigPre dialog

class cMigPre : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigPre)

// Construction
public:
	cMigPre();
	~cMigPre();

// Dialog Data
	//{{AFX_DATA(cMigPre)
	enum { IDD = IDD_MQMIG_PREMIG };
	CButton	m_cbViewLogFile;
	CStatic	m_Text;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigPre)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMigPre)
	afx_msg void OnViewLogFile();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGPRE_H__09A53B26_52B0_11D2_BE44_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigser.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cmigser.cpp

Abstract:

    Thie page enable you to choose analysis of MQIS SQL database.
    User can uncheck the check box and skip the analysis phase.

Author:

    Erez  Vizel
    Doron Juster  (DoronJ)

--*/

#include "stdafx.h"
#include "MqMig.h"
#include "cMigSer.h"
#include "loadmig.H"
#include "mqsymbls.h"

#include "cmigser.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HRESULT   g_hrResultAnalyze ;
bool b_FirstWaitPage = true ;
//
// Flag to deterine which page will follow the wait page (as it is used twice)
//

/////////////////////////////////////////////////////////////////////////////
// cMqMigServer property page

IMPLEMENT_DYNCREATE(cMqMigServer, CPropertyPageEx)

cMqMigServer::cMqMigServer() : CPropertyPageEx(cMqMigServer::IDD, 0, IDS_ANALYZE_TITLE, IDS_ANALYZE_SUBTITLE)
{
	//{{AFX_DATA_INIT(cMqMigServer)
	m_bRead = TRUE;
	//}}AFX_DATA_INIT

	/* obtaining the deafult MQIS Server Name ( host computer)  */
    if (g_fIsRecoveryMode || g_fIsClusterMode)
    {
        m_strMachineName = g_pszRemoteMQISServer;
    }
    else
    {
        TCHAR buffer[MAX_COMPUTERNAME_LENGTH+1];
	    unsigned long length=MAX_COMPUTERNAME_LENGTH+1;
	    GetComputerName(buffer,&length);
	    m_strMachineName = buffer;
    }	
}

cMqMigServer::~cMqMigServer()
{
}

void cMqMigServer::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMqMigServer)
	DDX_Check(pDX, IDC_CHECK_READ, m_bRead);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMqMigServer, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMqMigServer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMqMigServer message handlers

BOOL cMqMigServer::OnSetActive()
{
	/*enabeling the back and next button for the server page by using a pointer to the father*/
	HWND hCancel;
	CPropertySheetEx* pageFather;

    b_FirstWaitPage = true ;

	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT |PSWIZB_BACK);

	hCancel=::GetDlgItem( ((CWnd*)pageFather)->m_hWnd ,IDCANCEL);/*enable the cancel button*/
	ASSERT(hCancel != NULL);
	if(FALSE == ::IsWindowEnabled(hCancel))
    {
		::EnableWindow(hCancel,TRUE);
	}
    return CPropertyPageEx::OnSetActive();
}

BOOL cMqMigServer::OnInitDialog()
{
	CPropertyPageEx::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT cMqMigServer::OnWizardNext()
{
	UpdateData(TRUE); // executing DDX(retrive data)
	
    g_fReadOnly = m_bRead ;

    if (g_pszMQISServerName)
    {
        delete g_pszMQISServerName ;
    }

    LPCTSTR pName = m_strMachineName ;
    g_pszMQISServerName = new TCHAR[ 1 + _tcslen(pName) ] ;
    _tcscpy(g_pszMQISServerName, pName) ;

	if (m_bRead == FALSE)
	{
        //
        // if analysis is unchecked then skip to the pre-migration page.
        //
        g_hrResultAnalyze = MQMig_OK ;
        b_FirstWaitPage = false ;
	    return IDD_MQMIG_PREMIG; //skip to the pre migration page
	}

	return CPropertyPageEx::OnWizardNext();//if analyze is checked go to wait page
}



BOOL cMqMigServer::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigser.h ===
#if !defined(AFX_CMQMIGSERVER_H__B8874CD1_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_CMQMIGSERVER_H__B8874CD1_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMqMigServer.h : header file
//
#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMqMigServer dialog

class cMqMigServer : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMqMigServer)

// Construction
public:
	cMqMigServer();
	~cMqMigServer();

// Dialog Data
	//{{AFX_DATA(cMqMigServer)
	enum { IDD = IDD_MQMIG_SERVER };
	BOOL	m_bRead;
	//}}AFX_DATA

	CString m_strMachineName;
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMqMigServer)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMqMigServer)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMQMIGSERVER_H__B8874CD1_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigwait.cpp ===
//
// cMigWait.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigWait.h"
#include "sThrPrm.h"
#include <uniansi.h>
#include "mqtempl.h"
#include "thrSite.h"
#include "loadmig.h"
#include "..\mqmigrat\mqmigui.h"
#include "loadmig.h"

#include "cmigwait.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern bool b_FirstWaitPage ;
extern UINT _PRE_MIGRATION_PAGE;
extern UINT _FINISH_PAGE;

const UINT g_iSiteLowLimit = 0 ;
UINT       g_iSiteHighLimit = 0 ;// will be set during run time
const UINT g_iMachineLowLimit = 0 ;
UINT       g_iMachineHighLimit = 0 ;
const UINT g_iQueueLowLimit=0 ;
UINT       g_iQueueHighLimit = 0 ;
const UINT g_iUserLowLimit=0 ;
UINT       g_iUserHighLimit = 0 ;

extern BOOL g_fMigrationCompleted ;

BOOL setLimit();

DWORD g_InitTime;


/////////////////////////////////////////////////////////////////////////////
// cMigWait property page

IMPLEMENT_DYNCREATE(cMigWait, CPropertyPageEx)

cMigWait::cMigWait()
{
    ASSERT(0) ;
}

cMigWait::cMigWait(UINT uTitle, UINT uSubTitle) :
    CPropertyPageEx(cMigWait::IDD, 0, uTitle, uSubTitle)
{
	//{{AFX_DATA_INIT(cMigWait)		
	//}}AFX_DATA_INIT
    m_strQueue.LoadString(IDS_QUEUES) ;
	m_strMachine.LoadString(IDS_MACHINES) ;
	m_strSite.LoadString(IDS_MQMIG_SITES) ;
	m_strUser.LoadString(IDS_USERS) ;	
}

cMigWait::~cMigWait()
{
}

void cMigWait::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigWait)
	DDX_Control(pDX, IDC_ELAPSED_TIME, m_ElapsedTimeText);
	DDX_Control(pDX, IDC_STATIC_USER, m_UserText);
	DDX_Control(pDX, IDC_PROGRESS_USER, m_cProgressUser);
	DDX_Control(pDX, IDC_PLEASE_WAIT, m_WaitText);
	DDX_Control(pDX, IDC_PROGRESS_SITE, m_cProgressSite);
	DDX_Control(pDX, IDC_PROGRESS_QUEUE, m_cProgressQueue);
	DDX_Control(pDX, IDC_PROGRESS_MACHINE, m_cProgressMachine);
	DDX_Text(pDX, IDC_STATIC_QUEUE, m_strQueue);
	DDX_Text(pDX, IDC_STATIC_MACHINE, m_strMachine);
	DDX_Text(pDX, IDC_STATIC_SITE, m_strSite);
	DDX_Text(pDX, IDC_STATIC_USER, m_strUser);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigWait, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigWait)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMigWait message handlers

BOOL cMigWait::OnSetActive()
{	
	g_InitTime = GetTickCount ();
	OnStartTimer() ;
	HWND hCancel;
	sThreadParm  *pProgressBar;
    sThreadParm  *pMigration;
	CPropertySheetEx* pageFather;

	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(0);/*Disabling the back and next buttons*/
	hCancel=::GetDlgItem( ((CWnd*)pageFather)->m_hWnd ,IDCANCEL);/*Disable the cancel button*/
	ASSERT(hCancel != NULL);
	::EnableWindow(hCancel,FALSE);

	setLimit(); //initialyzing high limit

	pProgressBar = new sThreadParm;
	
	pProgressBar->pPageFather = pageFather;
	pProgressBar->pSiteProgress = &m_cProgressSite;
	pProgressBar->pMachineProgress = &m_cProgressMachine;
	pProgressBar->pQueueProgress = &m_cProgressQueue;
	pProgressBar->pUserProgress = &m_cProgressUser;
	
	if (g_iUserHighLimit == 0)
	{
		//
		// either there are no users or migration tool runs on PSC =>
		// disable this control
		//
		m_cProgressUser.ShowWindow(SW_HIDE);
		m_UserText.ShowWindow(SW_HIDE);
	}
	else
	{
		m_cProgressUser.ShowWindow(SW_SHOW);
		m_UserText.ShowWindow(SW_SHOW);		
	}

    pMigration = new  sThreadParm;
    pMigration->pPageFather = pageFather;
	pMigration->pSiteProgress = &m_cProgressSite;
	pMigration->pMachineProgress = &m_cProgressMachine;
	pMigration->pQueueProgress = &m_cProgressQueue;
	pMigration->pUserProgress = &m_cProgressUser;

    g_fMigrationCompleted = FALSE;
    CString strMessage;

    if (b_FirstWaitPage == true)
    {
		pProgressBar->iPageNumber=_PRE_MIGRATION_PAGE;
        pMigration->iPageNumber=_PRE_MIGRATION_PAGE;
        strMessage.LoadString(IDS_WAIT_ANALYZE) ;
    }
	else
    {
		pProgressBar->iPageNumber=_FINISH_PAGE;
        pMigration->iPageNumber=_FINISH_PAGE;
        strMessage.LoadString(IDS_WAIT_MIGRATE) ;
    }

    m_WaitText.SetWindowText( strMessage );

	CString strElapsedTime;
	strElapsedTime.Format(IDS_ELAPSED_TIME_TEXT, 0, 0, 0);
	m_ElapsedTimeText.SetWindowText (strElapsedTime);

    //
    // ProgressBarsThread is the thread that advance the progress bars.
    //
	AfxBeginThread((ProgressBarsThread),(void *)(pProgressBar));

	if (b_FirstWaitPage == false)
    {
		AfxBeginThread((RunMigrationThread),(void *)(pMigration));
    }
	else
    {
		AfxBeginThread((AnalyzeThread),(void *)(pMigration));
    }
	
	return CPropertyPageEx::OnSetActive();
}

///////////////////////////////////////////////////////////////////////////////
// void ChangeStringValue()

void cMigWait::ChangeStringValue()
{
	m_strSite.LoadString(IDS_USERS) ;
	m_strQueue = "  ";
	m_strMachine ="  ";
	UpdateData(FALSE);
}

///////////////////////////////////////////////////////////////////////////////////////
// Void setLimit() - set the limit of the progress bars, using exported function
BOOL setLimit()
{
    BOOL f = LoadMQMigratLibrary(); // load dll
    if (!f)
    {
        return FALSE;
    }

    MQMig_GetObjectsCount_ROUTINE pfnGetObjectsCount =
            (MQMig_GetObjectsCount_ROUTINE)
                         GetProcAddress( g_hLib, "MQMig_GetObjectsCount" ) ;
    ASSERT(pfnGetObjectsCount != NULL) ;

    if (pfnGetObjectsCount != NULL)
    {
        TCHAR ServerName[MAX_COMPUTERNAME_LENGTH+1];
        if (g_fIsRecoveryMode)
        {
            lstrcpy (ServerName, g_pszRemoteMQISServer);
        }
        else
        {
            unsigned long length=MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName(ServerName,&length);
        }

		HRESULT hr = (*pfnGetObjectsCount)( ServerName,
                                           &g_iSiteHighLimit,
							               &g_iMachineHighLimit,
							               &g_iQueueHighLimit,
										   &g_iUserHighLimit) ;
        UNREFERENCED_PARAMETER(hr);
	}
	else //false
	{
		return FALSE;
	}

    return TRUE ;
}



BOOL cMigWait::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	switch (((NMHDR FAR *) lParam)->code)
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}

void cMigWait::OnStartTimer()
{
   m_nTimer = SetTimer(1, 15000, 0);
}

void cMigWait::OnStopTimer()
{
   ::KillTimer(m_hWnd, m_nTimer);
}

void cMigWait::OnTimer(UINT nIDEvent)
{
	// TODO: Add your message handler code here and/or call default
	DWORD dwCurTime = GetTickCount ();	
	
	//
	// Elapsed time in seconds
	//
	DWORD dwElapsedTime = (dwCurTime - g_InitTime) / 1000;

	DWORD dwElapsedSec = dwElapsedTime % 60;
	DWORD dwElapsedMin = dwElapsedTime / 60;
	DWORD dwElapsedHour = dwElapsedMin / 60;
	dwElapsedMin = dwElapsedMin % 60;
		
	static ULONG sTimer = 0;
	CString strElapsedTime;
	strElapsedTime.Format(IDS_ELAPSED_TIME_TEXT,
			dwElapsedHour, dwElapsedMin, dwElapsedSec);
	m_ElapsedTimeText.SetWindowText (strElapsedTime);	

	CPropertyPageEx::OnTimer(nIDEvent);
}

BOOL cMigWait::OnKillActive()
{
	// TODO: Add your specialized code here and/or call the base class
	OnStopTimer();
	return CPropertyPageEx::OnKillActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigwait.h ===
#if !defined(AFX_CMIGWAIT_H__E7C820A6_2B76_11D2_BE3B_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGWAIT_H__E7C820A6_2B76_11D2_BE3B_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigWait.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigWait dialog

class cMigWait : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigWait)

// Construction
public:
	void ChangeStringValue();
	cMigWait();
	cMigWait(UINT uTitle, UINT uSubTitle);
	~cMigWait();
	void OnStartTimer() ;
	void OnStopTimer() ;	
	UINT m_nTimer;

// Dialog Data
	//{{AFX_DATA(cMigWait)
	enum { IDD = IDD_MQMIG_WAIT };
	CStatic	m_ElapsedTimeText;
	CStatic	m_UserText;
	CProgressCtrl	m_cProgressUser;
	CStatic	m_WaitText;
	CProgressCtrl	m_cProgressSite;
	CProgressCtrl	m_cProgressQueue;
	CProgressCtrl	m_cProgressMachine;
	CString	m_strQueue;
	CString	m_strMachine;
	CString	m_strSite;
	CString	m_strUser;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigWait)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMigWait)
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGWAIT_H__E7C820A6_2B76_11D2_BE3B_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigwel.cpp ===
// cMqMigWelcome.cpp : implementation file
//

#include "stdafx.h"
#include "MqMig.h"
#include "cMigWel.h"
#include "textfont.h"

#include "cmigwel.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// cMqMigWelcome property page

IMPLEMENT_DYNCREATE(cMqMigWelcome, CPropertyPageEx)

cMqMigWelcome::cMqMigWelcome() : CPropertyPageEx(cMqMigWelcome::IDD)
{
	//{{AFX_DATA_INIT(cMqMigWelcome)
	//}}AFX_DATA_INIT
	m_psp.dwFlags |= PSP_HIDEHEADER;
}

cMqMigWelcome::~cMqMigWelcome()
{
}

void cMqMigWelcome::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMqMigWelcome)
	DDX_Control(pDX, IDC_WELCOME_TEXT, m_strWelcomeTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMqMigWelcome, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMqMigWelcome)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMqMigWelcome message handlers

BOOL cMqMigWelcome::OnSetActive()
{
	/*disabeling the back button for the welcome page by using a pointer to the father*/

	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT);

    CFont cFont ;
    LOGFONT lf = { 0,
                   0,
                   0,
                   0,
                   WELCONE_TITLE_WEIGHT,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0,
                   DEFAULT_PITCH,
                   TEXT("Verdana")};
    BOOL fFont = cFont.CreateFontIndirect(&lf) ;
    if (fFont)
    {
        m_strWelcomeTitle.SetFont(&cFont, TRUE) ;
    }

    CString strMessage;
    strMessage.LoadString(IDS_WELCOME_TITLE_TEXT) ;
    m_strWelcomeTitle.SetWindowText( strMessage );
	BOOL fSetActive = CPropertyPageEx::OnSetActive();
	return fSetActive;
}


BOOL cMqMigWelcome::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						//
						//Help file was viewed mark the help as read
						//
						g_fHelpRead = TRUE;
						return TRUE;
		
	}

	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}




LRESULT cMqMigWelcome::OnWizardNext() 
{
	if(g_fHelpRead )
	{	
		//
		//If the help file was viewed in this page or the second page skip
		//directly to the third page
		//
		return IDD_MQMIG_LOGIN;
	}
	else
	{
		return CPropertyPageEx::OnWizardNext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cwizsht.cpp ===
// cWizSheet.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cWizSht.h"

#include "cwizsht.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

UINT _PRE_MIGRATION_PAGE;
UINT _FINISH_PAGE;
UINT _SERVICE_PAGE;
CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cWizSheet

IMPLEMENT_DYNAMIC(cWizSheet, CPropertySheetEx)

cWizSheet::cWizSheet() :
    CPropertySheetEx(IDS_MIGTOOL_CAPTION, 0, 0, GetHbmWatermark(), 0, GetHbmHeader())
{	
	
    m_hIcon = AfxGetApp()->LoadIcon( IDI_ICON1 );//load the icon
    ASSERT(m_hIcon != NULL);
    UINT uiPageCount = 0;
    AddPage(&m_cWelcome);

    uiPageCount++;
    AddPage(&m_cHelp);

    uiPageCount++;
    AddPage(&m_cLoginning);

    uiPageCount++;
    AddPage(&m_cServer);

    uiPageCount++;
    m_pcWaitFirst = new cMigWait(IDS_WAIT_TITLE, IDS_WAIT_SUBTITLE) ;
    AddPage(m_pcWaitFirst);

    uiPageCount++;
    _PRE_MIGRATION_PAGE = uiPageCount;
    AddPage(&m_cPreMigration);

    uiPageCount++;
    m_pcWaitSecond = new cMigWait(IDS_WAIT2_TITLE, IDS_WAIT2_SUBTITLE) ;
    AddPage(m_pcWaitSecond);

    uiPageCount++;
    _SERVICE_PAGE = uiPageCount;
    AddPage(&m_cService);    

    uiPageCount++;
    _FINISH_PAGE  = uiPageCount;
    AddPage(&m_cFinish);    

    // set the WIZARD97 flag so we'll get the new look
    m_psh.dwFlags |= PSH_WIZARD97;
}

cWizSheet::~cWizSheet()
{
	if (theApp.m_hWndMain == m_hWnd)
	{
		theApp.m_hWndMain = 0;
	}
}


BEGIN_MESSAGE_MAP(cWizSheet, CPropertySheetEx)
	//{{AFX_MSG_MAP(cWizSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cWizSheet message handlers

BOOL cWizSheet::OnInitDialog()
{	
	CMenu* pMenu;
	BOOL bResult = CPropertySheetEx::OnInitDialog();
	theApp.m_hWndMain = m_hWnd;
	
	SetIcon(m_hIcon,TRUE); //Set the Big Icon
	SetIcon(m_hIcon,FALSE);//Set the Small Icon
	::SetWindowLong( m_hWnd, GWL_STYLE, GetStyle() |WS_MINIMIZEBOX );//add minimize button
	pMenu=GetSystemMenu(FALSE);
    int count = pMenu->GetMenuItemCount();
    //
    // add the menu item to the end
    //
	pMenu->InsertMenu(count,MF_BYPOSITION | MF_STRING,SC_MINIMIZE, _T("Minimize"));
	DrawMenuBar();
	initHtmlHelpString();
	return bResult;

}



//////////////////////////////////////////////////////////////////////////////////
/// void AddPage() 
	
void cWizSheet::AddPage(CPropertyPageEx * pPage)
{
    CPropertySheetEx::AddPage(pPage);
}

HBITMAP cWizSheet::GetHbmWatermark()
{
    static CBitmap cbmWatermark;
    static LONG lFlag = -1;

    if (InterlockedIncrement(&lFlag) == 0) // First time
    {
        cbmWatermark.LoadBitmap(IDB_WIZARD_WATERMARK);
    }

    return cbmWatermark;
}

HBITMAP cWizSheet::GetHbmHeader()
{
    static CBitmap cbmHeader;
    static LONG lFlag = -1;

    if (InterlockedIncrement(&lFlag) == 0) // First time
    {
        cbmHeader.LoadBitmap(IDB_WIZARD_HEADER);
    }

    return cbmHeader;

}

void cWizSheet::initHtmlHelpString()
{	
	CString str;
	TCHAR szWinDir[MAX_PATH];
	::GetWindowsDirectory(szWinDir,MAX_PATH);
	g_strHtmlString = szWinDir;
	str.LoadString(IDS_HTML_HELP_PATH);
	g_strHtmlString += str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\commonui.h ===
//
// file: commonui.h
//

#ifndef _COMMONUI_H_
#define _COMMONUI_H_

const UINT cwcResBuf = 2048;

extern HINSTANCE g_hResourceMod ;

class CResString
{
public:
    CResString() { _awc[ 0 ] = 0; }

    CResString( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
    }

    BOOL Load( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
        return ( 0 != _awc[ 0 ] );
    }

    TCHAR const * Get() { return _awc; }

private:
    TCHAR _awc[ cwcResBuf ];
};

#endif // _COMMONUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\csrvcacc.cpp ===
// cSrvcAcc.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cSrvcAcc.h"
#include "loadmig.h"

#include "csrvcacc.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSrvcAcc property page

IMPLEMENT_DYNCREATE(CSrvcAcc, CPropertyPageEx)

CSrvcAcc::CSrvcAcc() : CPropertyPageEx(CSrvcAcc::IDD,0, IDS_SRVCACC_TITLE, IDS_SRVCACC_SUBTITLE)
{
	//{{AFX_DATA_INIT(CSrvcAcc)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSrvcAcc::~CSrvcAcc()
{
}

void CSrvcAcc::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSrvcAcc)
		// NOTE: the ClassWizard will add DDX and DDV calls here
    DDX_Check(pDX, IDC_DONE, m_fDone);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSrvcAcc, CPropertyPageEx)
	//{{AFX_MSG_MAP(CSrvcAcc)
	ON_BN_CLICKED(IDC_DONE, OnCheckDone)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSrvcAcc message handlers

LRESULT CSrvcAcc::OnWizardNext() 
{
	// TODO: Add your specialized code here and/or call the base class
	BOOL f = StartReplicationService();
    UNREFERENCED_PARAMETER(f);
	
    return CPropertyPageEx::OnWizardNext();
}

LRESULT CSrvcAcc::OnWizardBack() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return IDD_MQMIG_PREMIG ;
}

BOOL CSrvcAcc::OnSetActive() 
{
	// TODO: Add your specialized code here and/or call the base class	
    m_fDone = FALSE;

    //
    // Enable the cancel button.
    //
    CPropertySheetEx* pageFather;    
	pageFather = (CPropertySheetEx*)GetParent();

	HWND hCancel=::GetDlgItem( ((CWnd*)pageFather)->m_hWnd ,IDCANCEL);
	ASSERT(hCancel != NULL);
	if(FALSE == ::IsWindowEnabled(hCancel))
    {
		::EnableWindow(hCancel,TRUE);
    }

	return CPropertyPageEx::OnSetActive();	
}

void CSrvcAcc::OnCheckDone() 
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	CPropertySheetEx* pageFather;	
	pageFather = (CPropertySheetEx*)GetParent();
	if(m_fDone)
	{
		pageFather->SetWizardButtons(PSWIZB_NEXT);		
	}	
    else
    {
        pageFather->SetWizardButtons(0);
    }
}

BOOL CSrvcAcc::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cmigwel.h ===
#if !defined(AFX_CMQMIGWELCOME_H__B8874CD5_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_CMQMIGWELCOME_H__B8874CD5_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMqMigWelcome.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
extern BOOL g_fHelpRead;
/////////////////////////////////////////////////////////////////////////////
// cMqMigWelcome dialog

class cMqMigWelcome : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMqMigWelcome)

// Construction
public:
	cMqMigWelcome();
	~cMqMigWelcome();

// Dialog Data
	//{{AFX_DATA(cMqMigWelcome)
	enum { IDD = IDD_MQMIG_WELCOME };
	CStatic	m_strWelcomeTitle;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMqMigWelcome)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(cMqMigWelcome)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMQMIGWELCOME_H__B8874CD5_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\cwizsht.h ===
#if !defined(AFX_CWIZSHEET_H__88BEB485_2CFA_11D2_BE3C_0020AFEDDF63__INCLUDED_)
#define AFX_CWIZSHEET_H__88BEB485_2CFA_11D2_BE3C_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cMigWel.h"
#include "cMigSer.h"
#include "cMigFin.h"
#include "cMigLog.h"
#include "cmigWait.h"
#include "cMigPre.h"
#include "cMigHelp.h"	// Added by ClassView
#include "csrvcacc.h"

// cWizSheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// cWizSheet

class cWizSheet : public CPropertySheetEx
{
	DECLARE_DYNAMIC(cWizSheet)

// Construction
public:
	cWizSheet();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(cWizSheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	void AddPage(CPropertyPageEx *pPage);
	virtual ~cWizSheet();

// Data
private:
	
    HICON m_hIcon;
    cMqMigWelcome m_cWelcome;	
    cMqMigServer  m_cServer;
    cMigWait      *m_pcWaitFirst ;
    cMigLog       m_cLoginning ;
    cMigPre	      m_cPreMigration;
    cMigWait      *m_pcWaitSecond ;
    CSrvcAcc      m_cService ;
    cMqMigFinish  m_cFinish;
    cMigHelp	  m_cHelp;


	// Generated message map functions
protected:
	void initHtmlHelpString();
	static HBITMAP GetHbmHeader();
	static HBITMAP GetHbmWatermark();
	//{{AFX_MSG(cWizSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CWIZSHEET_H__88BEB485_2CFA_11D2_BE3C_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\csrvcacc.h ===
#if !defined(AFX_CSRVCACC_H__5BB3076F_D930_44C8_BFEB_90C51EB64730__INCLUDED_)
#define AFX_CSRVCACC_H__5BB3076F_D930_44C8_BFEB_90C51EB64730__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cSrvcAcc.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;

/////////////////////////////////////////////////////////////////////////////
// CSrvcAcc dialog

class CSrvcAcc : public CPropertyPageEx
{
	DECLARE_DYNCREATE(CSrvcAcc)

// Construction
public:
	CSrvcAcc();
	~CSrvcAcc();

// Dialog Data
	//{{AFX_DATA(CSrvcAcc)
	enum { IDD = IDD_MQMIG_SERVICE };
	BOOL m_fDone;
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSrvcAcc)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSrvcAcc)
	afx_msg void OnCheckDone();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CSRVCACC_H__5BB3076F_D930_44C8_BFEB_90C51EB64730__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\initwait.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    initwait.cpp

Abstract:

    Display the initial "please wait" box.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

#include "stdafx.h"
#include "commonui.h"
#include "resource.h"
#include "initwait.h"
#include "mqmig.h"

#include "initwait.tmh"

static HWND    s_hwndWait = NULL ;
static HANDLE  s_hEvent = NULL ;
static HANDLE  s_hThread = NULL ;

extern BOOL g_fUpdateRemoteMQIS;

//+----------------------------------------------
//
//  void  DisplayInitError( DWORD dwError )
//
//  Display a "fatal" error at initialization.
//
//+----------------------------------------------

int  DisplayInitError( DWORD dwError,
                       UINT  uiType,
                       DWORD dwTitle )
{
    DestroyWaitWindow() ;

    uiType |= MB_SETFOREGROUND ;

    CResString cErrorText(dwError) ;
    CResString cErrorTitle(dwTitle) ;

    int iMsgStatus = MessageBox( NULL,
                                 cErrorText.Get(),
                                 cErrorTitle.Get(),
                                 uiType ) ;
    return iMsgStatus ;
}

//+--------------------------------------------------------------
//
// Function: _MsmqWaitDlgProc
//
// Synopsis: Dialog procedure for the Wait dialog
//
//+--------------------------------------------------------------

static BOOL CALLBACK  _MsmqWaitDlgProc( IN const HWND   hdlg,
                                        IN const UINT   msg,
                                        IN const WPARAM wParam,
                                        IN const LPARAM lParam )
{
    switch( msg )
    {
        case WM_DESTROY:
            if (s_hEvent)
            {
                SetEvent(s_hEvent) ;
            }
			//
            // Fall through
            //

        default:
            return DefWindowProc(hdlg, msg, wParam, lParam);
            break;
    }  

} // _MsmqWaitDlgProc

//+--------------------------------------------------------------
//
// Function: _DisplayWaitThread()
//
//+--------------------------------------------------------------

static DWORD  _DisplayWaitThread(void *lpV)
{
    UNREFERENCED_PARAMETER(lpV);
    if (s_hwndWait == NULL)
    {
        s_hEvent = CreateEvent( NULL,
                                FALSE,
                                FALSE,
                                NULL ) ;

        s_hwndWait = CreateDialog( g_hResourceMod ,
                                   MAKEINTRESOURCE(IDD_INIT_WAIT),
                                   NULL,
                                  (DLGPROC) _MsmqWaitDlgProc ) ;
        ASSERT(s_hwndWait);

        if (s_hwndWait)
        {
            if (g_fUpdateRemoteMQIS)
            {
                CString strInitWait;
                strInitWait.LoadString(IDS_INITUPDATE);
                
                SetDlgItemText(
                      s_hwndWait,           // handle to dialog box
                      IDC_INITTEXT,         // identifier of control
                      strInitWait           // text to set
                      );
 
            }
            ShowWindow(s_hwndWait, SW_SHOW);
        }

        while (TRUE)
        {
            DWORD result = MsgWaitForMultipleObjects( 1,
                                                      &s_hEvent,
                                                      FALSE,
                                                      INFINITE,
                                                      QS_ALLINPUT ) ;
            if (result == WAIT_OBJECT_0)
            {
                //
                // Our process terminated.
                //
                CloseHandle(s_hEvent) ;
                s_hEvent = NULL ;

                return 1 ;
            }
            else if (result == (WAIT_OBJECT_0 + 1))
            {
                // Read all of the messages in this next loop,
                // removing each message as we read it.
                //
                MSG msg ;
                while (PeekMessage(&msg, s_hwndWait, 0, 0, PM_REMOVE))
                {
                    if (msg.message == WM_QUIT)
                    {
                        // If it's a quit message, we're out of here.
                        return 0 ;
                    }
                    else
                    {
                       // Otherwise, dispatch the message.
                       DispatchMessage(&msg);
                    }
                }
            }
            else
            {
                ASSERT(0) ;
                return 0 ;
            }
        }
    }

    return 0 ;
}

//+--------------------------------------------------------------
//
// Function: DisplayWaitWindow()
//
//+--------------------------------------------------------------

void DisplayWaitWindow()
{
    if (s_hwndWait == NULL)
    {
        DWORD dwID ;
        s_hThread = CreateThread( NULL,
                                  0,
                          (LPTHREAD_START_ROUTINE) _DisplayWaitThread,
                                  NULL,
                                  0,
                                 &dwID ) ;
        if (s_hThread)
        {
            int j = 0 ;
            while ((j < 10) && (s_hwndWait == NULL))
            {
                Sleep(100) ;
                j++ ;
            }
        }
		theApp.m_hWndMain = s_hwndWait;
    }
    else
    {
        SetForegroundWindow(s_hwndWait) ;
        BringWindowToTop(s_hwndWait) ;
        ShowWindow(s_hwndWait, SW_SHOW);
    }
}

//+--------------------------------------------------------------
//
// Function: DestroyWaitWindow
//
// Synopsis: Kills the Wait dialog
//
//+--------------------------------------------------------------

void DestroyWaitWindow(BOOL fFinalDestroy)
{
    if (s_hwndWait)
    {
        ShowWindow(s_hwndWait, SW_HIDE);
        if (fFinalDestroy)
        {
			if (theApp.m_hWndMain == s_hwndWait)
			{
				theApp.m_hWndMain = 0;
			}
            SendMessage(s_hwndWait, WM_DESTROY, 0, 0);
            WaitForSingleObject(s_hThread, INFINITE) ;
            CloseHandle(s_hThread) ;
            s_hThread = NULL ;
            s_hwndWait = NULL  ;
        }
    }

} // DestroyWaitWindow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\mgmtwin.cpp ===
// MgmtWin.cpp : implementation file
//

#include "stdafx.h"
#include "MgmtWin.h"
#include "mqmig.h"

#include "mgmtwin.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CManagementWindow

CManagementWindow::CManagementWindow()
{
}

CManagementWindow::~CManagementWindow()
{
}


BEGIN_MESSAGE_MAP(CManagementWindow, CWnd)
	//{{AFX_MSG_MAP(CManagementWindow)
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CManagementWindow message handlers

void CManagementWindow::OnSetFocus(CWnd* pOldWnd) 
{
	CWnd::OnSetFocus(pOldWnd);

	if (theApp.m_hWndMain == 0)
	{
		Sleep (500);
	}

	if (theApp.m_hWndMain != 0 && theApp.m_hWndMain != m_hWnd)
	{
		CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

		HWND ErrorWnd = ::FindWindow(
							NULL,				// pointer to class name
							cErrorTitle.Get()   // pointer to window name
						);
	
		::ShowWindow(theApp.m_hWndMain, SW_HIDE ); 
		::ShowWindow(theApp.m_hWndMain, SW_SHOWMINIMIZED ); 
		::ShowWindow(theApp.m_hWndMain, SW_SHOWNORMAL );

		if (ErrorWnd != NULL)
		{
			::ShowWindow(ErrorWnd, SW_HIDE ); 
			::ShowWindow(ErrorWnd, SW_SHOWMINIMIZED ); 
			::ShowWindow(ErrorWnd, SW_SHOWNORMAL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\loadmig.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: loadmig.h

Abstract: load the migration dll and run migration.

Author:

    Doron Juster  (DoronJ)   19-Apr-98

--*/


extern BOOL    g_fReadOnly  ;
extern BOOL    g_fAlreadyExist ;
extern LPTSTR  g_pszMQISServerName ;

extern HINSTANCE g_hLib ; //global handel for the migrate.dll

extern BOOL      g_fIsRecoveryMode ;
extern BOOL      g_fIsClusterMode ;
extern BOOL      g_fIsWebMode ;
extern LPTSTR    g_pszRemoteMQISServer ;

extern BOOL      g_fIsPEC ;
extern BOOL      g_fIsOneServer ;

HRESULT  RunMigration() ;
void     ViewLogFile();

BOOL LoadMQMigratLibrary();

UINT __cdecl RunMigrationThread(LPVOID lpV) ;
UINT __cdecl AnalyzeThread(LPVOID lpV) ;

BOOL SetSiteIdOfPEC ();

BOOL RegisterReplicationService () ;

BOOL StartReplicationService() ;

#ifdef _DEBUG

UINT  ReadDebugIntFlag(TCHAR *pwcsDebugFlag, UINT iDefault) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\initwait.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    initwait.h

Abstract:

    Display the initial "please wait" box.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

void DisplayWaitWindow() ;
void DestroyWaitWindow(BOOL fFinalDestroy = FALSE) ;

int  DisplayInitError( DWORD dwError,
                       UINT  uiType = (MB_OK | MB_ICONSTOP | MB_TASKMODAL),
                       DWORD dwTitle = IDS_STR_ERROR_TITLE ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\localds.cpp ===
//
// file: localds.cpp
//
// Check if local machine is also a domain controller. Migration tool
// can run only on a Dc machine.
//

#include "stdafx.h"
#include "mqtempl.h"
#include <winldap.h>

#include "localds.tmh"


static bool IsServerGC(LPCWSTR pwszServerName)
/*++

Routine Description:
	Check that the server is GC

Arguments:
	pwszServerName - Server Name

Return Value:
	true if server is GC, false otherwise 
--*/
{
	LDAP* pLdap = ldap_init(
						const_cast<LPWSTR>(pwszServerName), 
						LDAP_GC_PORT
						);

	if(pLdap == NULL)
	{
		return false;
	}

    ULONG LdapError = ldap_set_option( 
							pLdap,
							LDAP_OPT_AREC_EXCLUSIVE,
							LDAP_OPT_ON  
							);

	if (LdapError != LDAP_SUCCESS)
    {
		return false;
    }

	LdapError = ldap_connect(pLdap, 0);
	if (LdapError != LDAP_SUCCESS)
    {
		return false;
    }

    ldap_unbind(pLdap);
	return true;
}


//+----------------------------------
//
//   BOOL IsLocalMachineDC()
//
//+----------------------------------

BOOL IsLocalMachineDC()
{
    BOOL  fIsDc = FALSE;

    DWORD dwNumChars = 0;
    P<TCHAR>  pwszComputerName = NULL;
    BOOL f = GetComputerNameEx( 
					ComputerNameDnsFullyQualified,
					NULL,
					&dwNumChars 
					);
    if (dwNumChars > 0)
    {
        pwszComputerName = new TCHAR[dwNumChars];
        f = GetComputerNameEx( 
				ComputerNameDnsFullyQualified,
				pwszComputerName,
				&dwNumChars 
				);
    }
    else
    {
        //
        // Maybe DNS names not supported. Try netbios.
        //
        dwNumChars = MAX_COMPUTERNAME_LENGTH + 2;
        pwszComputerName = new TCHAR[dwNumChars];
        f = GetComputerName( 
				pwszComputerName,
				&dwNumChars 
				);
    }
    if (!f)
    {
        return FALSE;
    }

	if(IsServerGC(pwszComputerName))
    {
        //
        // We opened connection with local GC. So we're a GC :=)
        //
        fIsDc = TRUE;
    }

    return fIsDc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\mgmtwin.h ===
#if !defined(AFX_MGMTWIN_H__64E9578A_E2B2_11D2_B185_0004ACC6C88D__INCLUDED_)
#define AFX_MGMTWIN_H__64E9578A_E2B2_11D2_B185_0004ACC6C88D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MgmtWin.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CManagementWindow window

class CManagementWindow : public CWnd
{
// Construction
public:
	CManagementWindow();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CManagementWindow)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CManagementWindow();

	// Generated message map functions
protected:
	//{{AFX_MSG(CManagementWindow)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MGMTWIN_H__64E9578A_E2B2_11D2_B185_0004ACC6C88D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\loadmig.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    loadmig.cpp

Abstract:

    Call different functions from migration dll.
Author:

    Doron Juster  (DoronJ)  07-Feb-1999

--*/

#include "stdafx.h"
#include <mqtempl.h>
#include <winsvc.h>
#include "resource.h"
#include "mqsymbls.h"
#include "..\..\setup\msmqocm\service.h"
#include "..\..\setup\msmqocm\comreg.h"
#include <uniansi.h>
#include "..\mqmigrat\mqmigui.h"
#include "initwait.h"
#include "loadmig.h"
#include "migservc.h"
#include "..\..\replserv\mq1repl\migrepl.h"
#include "mqnames.h"

#include "loadmig.tmh"

BOOL      g_fReadOnly  = FALSE ;
BOOL      g_fAlreadyExist = FALSE ;
LPTSTR    g_pszMQISServerName = NULL ;
LPTSTR    g_pszLogFileName = NULL ;
ULONG     g_ulTraceFlags = 0 ;
HINSTANCE g_hLib = NULL ;
HRESULT   g_hrResultAnalyze = MQMig_OK ;
HRESULT   g_hrResultMigration = MQMig_OK ;
BOOL      g_fMigrationCompleted = FALSE;

BOOL      g_fIsPEC = FALSE;
BOOL      g_fIsOneServer = FALSE;

//+-------------------------------
//
//  BOOL _RemoveFromWelcome()
//
//+-------------------------------

BOOL _RemoveFromWelcome()
{
    LONG rc = RegDeleteKey (HKEY_LOCAL_MACHINE, WELCOME_TODOLIST_MSMQ_KEY) ;

	BOOL f;
    if (rc != ERROR_SUCCESS)
    {
		f = CheckRegistry ( REMOVED_FROM_WELCOME );
		if (!f)
		{
			DisplayInitError( IDS_STR_CANT_DEL_WELCOME,
                          (MB_OK | MB_ICONWARNING | MB_TASKMODAL),
                          IDS_STR_WARNING_TITLE ) ;
		}
    }
	else
	{
		f = UpdateRegistryDW ( REMOVED_FROM_WELCOME, 1 );
	}

    return TRUE ;
}

//+---------------------------------
//
//  BOOL _StartMSMQService()
//
//+---------------------------------

BOOL _StartMSMQService()
{
    CResString cErrorTitle(IDS_STR_SERVICE_FAIL_TITLE) ;
    CResString cWarningTitle(IDS_STR_SERVICE_WARNING_TITLE) ;

    SC_HANDLE hServiceCtrlMgr = OpenSCManager( NULL,
                                               NULL,
                                               SC_MANAGER_ALL_ACCESS );
    if (!hServiceCtrlMgr)
    {
        CResString cCantOpenMgr(IDS_STR_CANT_OPEN_MGR) ;
        MessageBox( NULL,
                    cCantOpenMgr.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
    }

    //
    // Open a handle to the MSMQ service
    //
    SC_HANDLE hService = OpenService( hServiceCtrlMgr,
                                      MSMQ_SERVICE_NAME,
                                      SERVICE_ALL_ACCESS );
    if (!hService)
    {
        CResString cCantOpenMsmq(IDS_STR_CANT_OPEN_MSMQ) ;
        MessageBox( NULL,
                    cCantOpenMsmq.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
    }

    //
    // Set the start mode to be autostart.
    //
    BOOL f = ChangeServiceConfig( hService,
                                  SERVICE_NO_CHANGE ,
                                  SERVICE_AUTO_START,
                                  SERVICE_NO_CHANGE,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL ) ;
    if (!f)
    {
        CResString cCantCnfgMsmq(IDS_STR_CANT_CNFG_MSMQ) ;
        MessageBox( NULL,
                    cCantCnfgMsmq.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
    }

    //
    // Now start the MSMQ service.
    // Continue even if failed. User can start it later.
    //
    BOOL fMSMQStarted = TRUE ;
    if (!StartService( hService, 0, NULL ))
    {
        CResString cCantStartMsmq(IDS_STR_CANT_START_MSMQ) ;
        MessageBox( NULL,
                    cCantStartMsmq.Get(),
                    cWarningTitle.Get(),
                    (MB_OK | MB_ICONWARNING | MB_TASKMODAL)) ;
        fMSMQStarted = FALSE ;
    }    

    CloseServiceHandle( hService ) ;
    CloseServiceHandle( hServiceCtrlMgr ) ;
    return f ;    
    
}

//+--------------------------------------
//
//  BOOL  LoadMQMigratLibrary()
//
//+--------------------------------------

BOOL LoadMQMigratLibrary()
{
    if (g_hLib)
    {
        return TRUE ;
    }

    TCHAR  szDllName[ MAX_PATH ] ;
    DWORD dw = GetModuleFileName( NULL,
                                  szDllName,
                               (sizeof(szDllName) / sizeof(szDllName[0]))) ;
    if (dw == 0)
    {
        return FALSE ;
    }

    TCHAR *p = _tcsrchr(szDllName, TEXT('\\')) ;
    if (p)
    {
        p++ ;
        _tcscpy(p, MQMIGRAT_DLL_NAME) ;
        _tprintf(TEXT("Loading %s\n"), szDllName) ;

        g_hLib = LoadLibrary(szDllName) ;
        if (!g_hLib)
        {
            return FALSE ;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//+-----------------------------------------------------------------------
//
// UINT MQMigUI_DisplayMessageBox()
//
//  This is a callback routine, called from the migration dll. We want
//  to keep all localizable resources in the exe, not in the dll.
//
//+-----------------------------------------------------------------------

UINT MQMigUI_DisplayMessageBox( ULONG ulTextId,
                                UINT  ulMsgBoxType )
{
    CResString cText(ulTextId) ;
    CResString cWarningTitle(IDS_STR_DEL_WELCOME_TITLE) ;

    return MessageBox( NULL,
                       cText.Get(),
                       cWarningTitle.Get(),
                       ulMsgBoxType ) ;
}

//+--------------------------------------
//
//  BOOL  _RunMigrationInternal()
//
//+--------------------------------------

static BOOL  _RunMigrationInternal(HRESULT  *phrResult)
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        return FALSE;
    }

    MQMig_MigrateFromMQIS_ROUTINE  pfnMigrate =
                 (MQMig_MigrateFromMQIS_ROUTINE)
                         GetProcAddress( g_hLib, "MQMig_MigrateFromMQIS" ) ;
    if (pfnMigrate)
    {
        g_fIsPEC = FALSE ;
        g_fIsOneServer = FALSE;
        try
        {
            *phrResult = (*pfnMigrate) ( g_pszMQISServerName,
                                         NULL,
                                         g_fReadOnly,
                                         TRUE,//g_fAlreadyExist,
                                         g_fIsRecoveryMode,
                                         g_fIsClusterMode,
                                         g_fIsWebMode, 
                                         g_pszLogFileName,
                                         g_ulTraceFlags,
                                        &g_fIsPEC,
                                        &g_fIsOneServer ) ;
        }
        catch (...)
        {
            *phrResult = MQMig_E_UNKNOWN ;
        }

        g_fMigrationCompleted = TRUE;

#ifdef _DEBUG

        BOOL fErr = FALSE ;

        if (g_fReadOnly)
        {
            fErr =  ReadDebugIntFlag(TEXT("FailAnalysis"), 0) ;
        }
        else
        {
            fErr =  ReadDebugIntFlag(TEXT("FailUpgrade"), 0) ;
        }

        if (fErr)
        {
            *phrResult = MQMig_E_UNKNOWN ;
        }

#endif
        
        if (!g_fReadOnly)
        {
            //
            // It does not matter if migration succeeded or not:
            // register replication service and create replication 
            // service queue to allow user to run it manually (if user
            // prefers to ignore all migration problem and continue)
            //

            BOOL f;
            //
            // On PEC, start the replication service too.        
            // If we have only server in Enterprise (it is PEC), 
	        // we don't need replication service.        
            //
            if (g_fIsPEC && 
                !g_fIsOneServer)
            {
                f = RegisterReplicationService () ;
            }

            if (SUCCEEDED(*phrResult))
            {
                //
                // Migration succeeded and non-read-only mode
                //
                BOOL fStart = _StartMSMQService() ;
                UNREFERENCED_PARAMETER(fStart);

                if (!g_fIsRecoveryMode && !g_fIsClusterMode)
                {
                    //
                    // we are in normal mode
                    //
                    BOOL fWelcome = _RemoveFromWelcome() ;
                    UNREFERENCED_PARAMETER(fWelcome);
                }
            }                        
        }        
    }
    else //pfnMigrate
    {
        return FALSE ;
    }

    return TRUE ;
}

//+----------------------------
//
//  BOOL  RunMigration()
//
//+----------------------------

HRESULT  RunMigration()
{
    HRESULT hrResult = MQMig_OK ;

    BOOL f = _RunMigrationInternal(&hrResult) ;

    if (!f)
    {
        DisplayInitError( IDS_STR_CANT_START ) ;
        hrResult = MQMig_E_QUIT ;
    }

    return hrResult;
}

//+--------------------------------------------------------------
//
//  BOOL  CheckVersionOfMQISServers()
//
//  returns TRUE if user choosed to continue migration process.
//
//+--------------------------------------------------------------

BOOL CheckVersionOfMQISServers()
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        DisplayInitError( IDS_STR_CANT_START ) ;
        return f;
    }

    MQMig_CheckMSMQVersionOfServers_ROUTINE pfnCheckVer =
                     (MQMig_CheckMSMQVersionOfServers_ROUTINE)
               GetProcAddress( g_hLib, "MQMig_CheckMSMQVersionOfServers" ) ;
    ASSERT(pfnCheckVer) ;

    if (pfnCheckVer)
    {
        TCHAR ServerName[MAX_COMPUTERNAME_LENGTH+1];
        if (g_fIsClusterMode)
        {
            lstrcpy (ServerName, g_pszRemoteMQISServer);
        }
        else
        {
            unsigned long length=MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName(ServerName, &length);
        }        

        UINT iCount = 0;
        AP<WCHAR> wszOldVerServers = NULL;
        HRESULT hr = (*pfnCheckVer) (
                            ServerName,
                            g_fIsClusterMode,
                            &iCount,
                            &wszOldVerServers ) ;
        if (FAILED(hr))
        {
            CResString cCantCheck(IDS_STR_CANT_CHECK) ;
            CResString cToContinue(IDS_STR_TO_CONTINUE) ;
            TCHAR szError[1024] ;
            _stprintf(szError, _T("%s %x.%s"), cCantCheck.Get(), hr, cToContinue.Get());

            CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;
            DestroyWaitWindow() ; 

            if (MessageBox( NULL,
                            szError,
                            cErrorTitle.Get(),
                            (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)) == IDCANCEL)
            {			
                return FALSE;
            }
            return TRUE;    //continue migration process
        }

        if (iCount == 0)
        {
            return TRUE;
        }

        DWORD dwSize = wcslen(wszOldVerServers) + 1;
        CResString cOldVerServers(IDS_OLD_VER_SERVERS) ;
        CResString cToContinue(IDS_STR_TO_CONTINUE) ;
        AP<TCHAR> szError = new TCHAR[1024 + dwSize] ;
        _stprintf(szError, _T("%s%s%s"), cOldVerServers.Get(), wszOldVerServers, cToContinue.Get());

        CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;
        DestroyWaitWindow() ;

        if (MessageBox( NULL,
                    szError,
                    cErrorTitle.Get(),
                    (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)) == IDCANCEL)
        {		
            return FALSE;
        }
    }

    return TRUE;
}


//+--------------------------------------------------------------
//
//  void  ViewLogFile()
//
//  Function shows log file using notepad
//
//+--------------------------------------------------------------

void ViewLogFile()
{
    PROCESS_INFORMATION infoProcess;
    STARTUPINFO	infoStartup;
    memset(&infoStartup, 0, sizeof(STARTUPINFO)) ;
    infoStartup.cb = sizeof(STARTUPINFO) ;
    infoStartup.dwFlags = STARTF_USESHOWWINDOW ;
    infoStartup.wShowWindow = SW_NORMAL ;

    //
    // Create the process
    //
    TCHAR szCommand[256];
    TCHAR szSystemDir[MAX_PATH];
    GetSystemDirectory( szSystemDir,MAX_PATH);
    CString strNotepad;
    strNotepad.LoadString(IDS_NOTEPAD) ;
    _stprintf(szCommand, TEXT("%s\\%s %s"),
        szSystemDir, strNotepad, g_pszLogFileName);

    if (!CreateProcess( NULL,
                        szCommand,
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_CONSOLE,
                        NULL,
                        NULL,
                        &infoStartup,
                        &infoProcess ))
    {
		DWORD dwErr = GetLastError();
        UNREFERENCED_PARAMETER(dwErr);
        return;
    }

    if (WaitForSingleObject(infoProcess.hProcess, 0) == WAIT_FAILED)
    {
       DWORD dwErr = GetLastError();
       UNREFERENCED_PARAMETER(dwErr);
    }

    //
    // Close the thread and process handles
    //
    CloseHandle(infoProcess.hThread);
    CloseHandle(infoProcess.hProcess);
}

//+--------------------------------------------------------------
//
//  BOOL  SetSiteIdOfPEC
//
//  returns TRUE if SiteID of PEC machine was set successfully.
//
//+--------------------------------------------------------------

BOOL SetSiteIdOfPEC ()
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE;
    }

    MQMig_SetSiteIdOfPEC_ROUTINE pfnSetSiteId =
                     (MQMig_SetSiteIdOfPEC_ROUTINE)
               GetProcAddress( g_hLib, "MQMig_SetSiteIdOfPEC" ) ;
    ASSERT(pfnSetSiteId) ;

    BOOL fRes = TRUE;
    if (pfnSetSiteId)
    {
        HRESULT hr = (*pfnSetSiteId) (
                            g_pszRemoteMQISServer,
                            g_fIsClusterMode,
                            IDS_STR_CANT_START,
                            IDS_CANT_CONNECT_DATABASE,
                            IDS_CANT_GET_SITEID,                            
                            IDS_CANT_UPDATE_REGISTRY,
                            IDS_CANT_UPDATE_DS                            
                            ) ;
        if (hr != MQMig_OK)
        {
            DisplayInitError(hr) ;
            fRes = FALSE;
        }
    }
    else
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        fRes = FALSE;
    }

    return fRes;
}

//+--------------------------------------------------------------
//
//  BOOL  UpdateRemoteMQIS()
//
//  returns TRUE if remote MQIS databases were updated successfully.
//
//+--------------------------------------------------------------

BOOL UpdateRemoteMQIS()
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE;
    }

    MQMig_UpdateRemoteMQIS_ROUTINE pfnUpdateRemoteMQIS =
                     (MQMig_UpdateRemoteMQIS_ROUTINE)
               GetProcAddress( g_hLib, "MQMig_UpdateRemoteMQIS" ) ;
    ASSERT(pfnUpdateRemoteMQIS) ;

    BOOL fRes = TRUE;
    if (pfnUpdateRemoteMQIS)
    {        
        AP<WCHAR> pwszNonUpdatedServers = NULL;
        AP<WCHAR> pwszUpdatedServers = NULL;
        HRESULT hr = (*pfnUpdateRemoteMQIS) (                                                        
                            IDS_CANT_GET_REGISTRY,
                            IDS_STR_CANT_START,
                            IDS_CANT_UPDATE_MQIS,
                            &pwszUpdatedServers,
                            &pwszNonUpdatedServers
                            ) ;
        if (hr != MQMig_OK)
        {
            switch (hr)
            {
            case IDS_CANT_GET_REGISTRY:   
            case IDS_STR_CANT_START:
                DisplayInitError(hr) ;
                break;

            case IDS_CANT_UPDATE_MQIS:
                {      
                    DWORD dwLen = 1 + wcslen(pwszNonUpdatedServers) ;
                    AP<CHAR> pszNonUpdServerName = new CHAR[ dwLen ] ;
                    ConvertToMultiByteString(pwszNonUpdatedServers, pszNonUpdServerName, dwLen);                                       
                    
                    CString cTextFailed;
                    cTextFailed.FormatMessage(IDS_CANT_UPDATE_MQIS, pszNonUpdServerName);
                    
                    CString cText = cTextFailed;

                    CResString cTitle(IDS_STR_ERROR_TITLE) ;

                    if (pwszUpdatedServers)
                    {                        
                        dwLen = 1 + wcslen(pwszUpdatedServers) ;
                        AP<CHAR> pszUpdServerName = new CHAR[ dwLen ] ;
                        ConvertToMultiByteString(pwszUpdatedServers, pszUpdServerName, dwLen);                    

                        CString cTextSucc ;
                        cTextSucc.FormatMessage(IDS_UPDATE_SUCCEEDED, pszUpdServerName);
                                                
                        cText.FormatMessage(IDS_UPDATE_PARTIALLY, cTextFailed, cTextSucc);
                    }                    

                    MessageBox( NULL,
                                cText,
                                cTitle.Get(),
                                (MB_OK | MB_ICONSTOP | MB_TASKMODAL) ) ;
                }
                break;

            default:
                break;
            }            
            fRes = FALSE;
        }
        else
        {   
            if (pwszUpdatedServers)
            {
                DWORD dwLen = 1 + wcslen(pwszUpdatedServers) ;
                AP<CHAR> pszServerName = new CHAR[ dwLen ] ;
                ConvertToMultiByteString(pwszUpdatedServers, pszServerName, dwLen);                    

                CString cText ;
			    cText.FormatMessage(IDS_UPDATE_SUCCEEDED, pszServerName);
                
                CResString cTitle(IDS_MIGTOOL_CAPTION);
                MessageBox( NULL,
                            cText,
                            cTitle.Get(),
                            (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL) ) ;
            }
            else
            {
                //
                // the list is empty: maybe we ran this on PSC or 
                // there were no servers in .ini list
                //
                CString cText ;
			    cText.FormatMessage(IDS_NO_SERVER_TO_UPDATE);
                
                CResString cTitle(IDS_MIGTOOL_CAPTION);
                MessageBox( NULL,
                            cText,
                            cTitle.Get(),
                            (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL) ) ;
            }
        }
    }
    else
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        fRes = FALSE;
    }

    return fRes;    
}

//+--------------------------------------------------------------
//
//  BOOL  IsValidDllVersion()
//
//  returns TRUE if valid dll version is loaded
//
//+--------------------------------------------------------------

BOOL IsValidDllVersion ()
{
    TCHAR   szExeName[ MAX_PATH ] ;
    TCHAR   szDllName[ MAX_PATH ];
    
    DWORD dw = GetModuleFileName( NULL,
                                  szDllName,
                               (sizeof(szDllName) / sizeof(szDllName[0]))) ;
    if (dw == 0)
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE ;
    }

    _tcscpy (szExeName, szDllName);

    TCHAR *p = _tcsrchr(szDllName, TEXT('\\')) ;
    if (p)
    {
        p++ ;
        _tcscpy(p, MQMIGRAT_DLL_NAME) ;        
    }
    else
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE;
    }

    //
    // get file version of .exe
    //
    DWORD dwZero;

    DWORD dwInfoSize = GetFileVersionInfoSize(
                                    szExeName,	// pointer to filename string
                                    &dwZero 	// pointer to variable to receive zero
                                );

    if (0 == dwInfoSize)
    {
        //
        // Probably file does not exist
        //
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    P<char>bufExeVer = new char[dwInfoSize];

    BOOL f = GetFileVersionInfo(
                        szExeName,	// pointer to filename string
                        0,	// ignored
                        dwInfoSize,	// size of buffer
                        bufExeVer 	// pointer to buffer to receive file-version info.
                        );

    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    VS_FIXEDFILEINFO *pvExe;
    UINT uiBufLen;

    f =  VerQueryValue(
                bufExeVer,	// address of buffer for version resource
                _T("\\"),	// address of value to retrieve
                (void **)&pvExe,	// address of buffer for version pointer
                &uiBufLen 	// address of version-value length buffer
                );
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION);
        return FALSE;
    }

    //
    // get file version of .dll
    //
    dwInfoSize = GetFileVersionInfoSize(
                        szDllName,	// pointer to filename string
                        &dwZero 	// pointer to variable to receive zero
                    );

    if (0 == dwInfoSize)
    {
        //
        // Probably file does not exist
        //
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    P<char>bufDllVer = new char[dwInfoSize];

    f = GetFileVersionInfo(
                szDllName,	// pointer to filename string
                0,	// ignored
                dwInfoSize,	// size of buffer
                bufDllVer 	// pointer to buffer to receive file-version info.
                );

    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    VS_FIXEDFILEINFO *pvDll;
   
    f =  VerQueryValue(
                bufDllVer,	// address of buffer for version resource
                _T("\\"),	// address of value to retrieve
                (void **)&pvDll,	// address of buffer for version pointer
                &uiBufLen 	// address of version-value length buffer
                );
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION);
        return FALSE;
    }

    //
    // compare version of .dll and .exe
    //
    if (pvExe->dwFileVersionMS == pvDll->dwFileVersionMS &&
        pvExe->dwFileVersionLS == pvDll->dwFileVersionLS)
    {
        return TRUE;
    }

    DisplayInitError (IDS_STR_WRONG_DLL_VERSION);        
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\migservc.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    migservc.cpp

Abstract:

    - generic code to handle services.
    - code to check status of SQL server.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

#include "stdafx.h"
#include <winsvc.h>
#include "resource.h"
#include "initwait.h"
#include "loadmig.h"
#include "..\..\setup\msmqocm\service.h"
#include <mqtempl.h>
#include <privque.h>
#include <uniansi.h>
#include <mqtypes.h>
#include <mqprops.h>
#include <_mqini.h>
#include <_mqdef.h>
#include "mqnames.h"

#include "migservc.tmh"

SC_HANDLE g_hServiceCtrlMgr = NULL ;

#define SQL_SERVICE_NAME                    TEXT("MSSqlServer")
#define WAIT_INTERVAL                       100
#define MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES 10

//+--------------------------------------------------------------
//
//  BOOL  StartAService(SC_HANDLE hService)
//
//  returns TRUE if service started
//
//+--------------------------------------------------------------

BOOL StartAService(SC_HANDLE hService)
{
    BOOL f = StartService (hService, 0, NULL);
    if (!f)
    {
        //
        // Failed to start service
        //
        return f;
    }

    //
    // Wait until the service has finished initializing
    //
    SERVICE_STATUS statusService;
    DWORD dwWait = 0;
    do
    {
        Sleep(WAIT_INTERVAL);
        dwWait += WAIT_INTERVAL;

        if (!QueryServiceStatus(hService, &statusService))
        {
            return FALSE;
        }
        if (statusService.dwCurrentState == SERVICE_RUNNING)
        {
            break;
        }

        if (dwWait > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
        {
            return FALSE;
		}
    } while (TRUE);

    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  StopAService(SC_HANDLE hService)
//
//  returns TRUE if service stopped
//
//+--------------------------------------------------------------

BOOL StopAService (SC_HANDLE hService)
{
    SERVICE_STATUS statusService;
    BOOL f = ControlService(
                    hService,               // handle to service
                    SERVICE_CONTROL_STOP,   // control code
                    &statusService          // pointer to service status structure
                    );

    if (!f)
    {
        return FALSE;
    }

    //
    // Wait until the service has finished stopping
    //
    DWORD dwWait = 0;
    do
    {
        if (statusService.dwCurrentState == SERVICE_STOPPED)
        {
            break;
        }

        if (dwWait > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
        {
            return FALSE;
		}

        Sleep(WAIT_INTERVAL);
        dwWait += WAIT_INTERVAL;

        if (!QueryServiceStatus(hService, &statusService))
        {
            return FALSE;
        }

    } while (TRUE);


    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  DisableAService(SC_HANDLE hService)
//
//  returns TRUE if service disabled
//
//+--------------------------------------------------------------

BOOL DisableAService (IN  SC_HANDLE  hService)
{
    BOOL f = ChangeServiceConfig(
                  hService ,            // handle to service
                  SERVICE_NO_CHANGE ,   // type of service
                  SERVICE_DISABLED ,    // when to start service
                  SERVICE_NO_CHANGE ,   // severity if service fails to start
                  NULL ,                // pointer to service binary file name
                  NULL ,                // pointer to load ordering group name
                  NULL ,                // pointer to variable to get tag identifier
                  NULL ,                // pointer to array of dependency names
                  NULL ,                // pointer to account name of service
                  NULL ,                // pointer to password for service account
                  NULL                  // pointer to display name
                  );
    if (!f)
    {
        HRESULT hr = GetLastError();
        UNREFERENCED_PARAMETER(hr);
        return FALSE;
    }

    //
    // Wait until the service will be disabled
    //
    P<QUERY_SERVICE_CONFIG> pConfig = new QUERY_SERVICE_CONFIG ;
    DWORD   dwReqSize = 0 ;
    DWORD   dwWait = 0;
    do
    {
        BOOL fConfig = QueryServiceConfig( hService,
                                           pConfig,
                                           sizeof(QUERY_SERVICE_CONFIG),
                                           &dwReqSize ) ;
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            delete pConfig ;
            pConfig = (QUERY_SERVICE_CONFIG*) new BYTE[ dwReqSize ] ;
            fConfig = QueryServiceConfig( hService,
                                          pConfig,
                                          dwReqSize,
                                         &dwReqSize ) ;
        }

        if (!fConfig)
        {
            return FALSE;
        }

        if (pConfig->dwStartType  == SERVICE_DISABLED)
        {
            break;
        }

        Sleep(WAIT_INTERVAL);
        dwWait += WAIT_INTERVAL;

        if (dwWait > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
        {
            return FALSE;
		}
    } while (TRUE);

    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL _GetServiceState()
//
//  This function query the service manager for status and configuration
//  of a service.
//  return TRUE if service is registered and its status is available.
//
//+--------------------------------------------------------------

static BOOL _GetServiceState( IN  LPTSTR     ptszServiceName,
                              IN  DWORD      dwManagerError,
                              IN  DWORD      dwOpenError,
                              IN  DWORD      dwQueryError,
                              OUT SC_HANDLE *phService,
                              OUT DWORD     *pdwErrorCode,
                              OUT DWORD     *pdwStatus,
                              OUT DWORD     *pdwConfig )
{
    if (!g_hServiceCtrlMgr)
    {
        g_hServiceCtrlMgr = OpenSCManager( NULL,
                                           NULL,
                                           SC_MANAGER_ALL_ACCESS );
    }
    if (!g_hServiceCtrlMgr)
    {
        *pdwErrorCode = dwManagerError ;
        return FALSE;
	}

    //
    // Open a handle to the service
    //
    *phService = OpenService( g_hServiceCtrlMgr,
                              ptszServiceName,
                              SERVICE_ALL_ACCESS) ;
    if (!*phService)
    {
        //
        // Service not installed
        //
        *pdwErrorCode = dwOpenError ;
        return FALSE;
    }

    if (pdwStatus)
    {
        SERVICE_STATUS statusService;
        if (!QueryServiceStatus(*phService, &statusService))
        {
            //
            // Service is not installed
            //
            *pdwErrorCode = dwQueryError ;
            CloseServiceHandle(*phService);
            *phService = NULL;

            return FALSE;
        }
        *pdwStatus = statusService.dwCurrentState ;
    }

    if (pdwConfig)
    {
        P<QUERY_SERVICE_CONFIG> pConfig = new QUERY_SERVICE_CONFIG ;
        DWORD  dwReqSize = 0 ;
        SetLastError(0) ;
        BOOL fConfig = QueryServiceConfig(*phService,
                                           pConfig,
                                           sizeof(QUERY_SERVICE_CONFIG),
                                           &dwReqSize ) ;
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            delete pConfig ;
            pConfig = (QUERY_SERVICE_CONFIG*) new BYTE[ dwReqSize ] ;
            fConfig = QueryServiceConfig(*phService,
                                          pConfig,
                                          dwReqSize,
                                         &dwReqSize ) ;
        }

        if (fConfig)
        {
            *pdwConfig = pConfig->dwStartType ;
        }
        else
        {
            *pdwErrorCode = dwQueryError ;
            CloseServiceHandle(*phService);
            *phService = NULL;

            return FALSE;
        }
    }

    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  CheckSQLServerStatus()
//
//  returns TRUE if SQL Server is running
//
//+--------------------------------------------------------------

BOOL CheckSQLServerStatus()
{
    DWORD     dwErr = 0 ;
    DWORD     dwServiceStatus = 0 ;
    SC_HANDLE hService = NULL;
    BOOL f = _GetServiceState( SQL_SERVICE_NAME,
                               IDS_STR_FAILED_OPEN_MGR,
                               IDS_STR_CANT_OPEN_SQLSERVER,
                               IDS_STR_CANT_GET_SQLSERVER_STATUS,
                              &hService,
                              &dwErr,
                              &dwServiceStatus,
                               NULL ) ;

    if (f && (dwServiceStatus == SERVICE_RUNNING))
    {
        //
        // SQL Server is running
        //
        CloseServiceHandle(hService);
        return f;
    }

    if (!hService)
    {
        ASSERT(dwErr) ;
        DisplayInitError( dwErr ) ;

        return FALSE;
    }

    int iMsgStatus = DisplayInitError( IDS_SQL_NOT_STARTED,
                      (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)) ;
    if (iMsgStatus == IDCANCEL)
    {
        CloseServiceHandle(hService);
        return FALSE;
    }

    //
    // start SQL Server
    //
    DisplayWaitWindow() ;

    f = StartAService(hService);
    CloseServiceHandle(hService);
    if (f)
    {
        return f;
    }

    //
    // failed to start SQL Server
    //
    DisplayInitError( IDS_STR_CANT_START_SQL_SERVER ) ;
    return f;
}

//+------------------------------------------------------------------------
//
//  BOOL IsMSMQServiceDisabled()
//
//  Check if MSMQ service is disabled. If not, don't run the migration tool.
//  We don't want that the tool be run by mistake, after MQIS was already
//  migrated and MSMQ service started.
//  Return TRUE if MSMQ service is disabled.
//
//+------------------------------------------------------------------------

BOOL IsMSMQServiceDisabled()
{
    DWORD     dwErr = 0 ;
    DWORD     dwServiceConfig = 0 ;
    SC_HANDLE hService = NULL;
    BOOL f = _GetServiceState( MSMQ_SERVICE_NAME,
                               IDS_STR_FAILED_OPEN_MGR,
                               IDS_CANT_OPEN_MSMQ_SRVICE,
                               IDS_CANT_GET_MSMQ_CONFIG,
                              &hService,
                              &dwErr,
                               NULL,
                              &dwServiceConfig ) ;
    if (f)
    {
        CloseServiceHandle(hService);
        if (dwServiceConfig == SERVICE_DISABLED)
        {
            return TRUE ;
        }
        dwErr = IDS_MSMQ_NOT_DISABLED ;
    }

    ASSERT(dwErr) ;
    DisplayInitError( dwErr ) ;

    return FALSE ;
}

//+--------------------------------------------------------------
//
//  BOOL  RegisterReplicationService ()
//
//  returns TRUE if service was created succesfully
//
//+--------------------------------------------------------------

BOOL RegisterReplicationService ()
{
    //
    // Form the display name of the mq1sync service
    //
    CResString strDisplayName(IDS_MQ1SYNCSERVICE_LABEL);

    //
    // BUGBUG:  if mq1sync.exe and mq1repl.dll are not in %windir%\system32
    //          we have to copy these files to there!
    //

    //
    // Form the path to the mq1sync service
    //
    TCHAR szSystemDir[MAX_PATH * MAX_BYTES_PER_CHAR];	
	BOOL f = GetSystemDirectory(szSystemDir, MAX_PATH) ;
    ASSERT (f);

    TCHAR szServicePath[MAX_PATH * MAX_BYTES_PER_CHAR];
    _stprintf(szServicePath, TEXT("%s\\%s"),
              szSystemDir,
              MQ1SYNC_SERVICE_PATH);

    //
    // The mq1sync service depends on the MSMQ service
    //
    TCHAR szDependencies[MAX_PATH * MAX_BYTES_PER_CHAR];
    lstrcpy(szDependencies, MSMQ_SERVICE_NAME);
    TCHAR * pszNextDependency = szDependencies + lstrlen(szDependencies) + 1;
    lstrcpy(pszNextDependency, TEXT(""));

    //
    // Determine the service type
    //
#ifndef _DEBUG
#define SERVICE_TYPE    SERVICE_WIN32_OWN_PROCESS
#else
#define SERVICE_TYPE    SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS
#endif

    if (!g_hServiceCtrlMgr)
    {
        g_hServiceCtrlMgr = OpenSCManager( NULL,
                                           NULL,
                                           SC_MANAGER_ALL_ACCESS );
    }
    if (!g_hServiceCtrlMgr)
    {
        DisplayInitError(IDS_STR_FAILED_OPEN_MGR) ;
        return FALSE;
	}

    //
    // Create the service
    //
    LPCTSTR szServiceName = MQ1SYNC_SERVICE_NAME;
	
    SC_HANDLE hService = CreateService(
                                g_hServiceCtrlMgr,
                                szServiceName,
                                strDisplayName.Get(),
                                SERVICE_ALL_ACCESS,
                                SERVICE_TYPE,
                                SERVICE_DISABLED,
                                SERVICE_ERROR_NORMAL,
                                szServicePath,
                                NULL,
                                NULL,
                                szDependencies,
                                NULL,
                                NULL
                                );

    if (hService == NULL)
    {
        if (ERROR_SERVICE_EXISTS != GetLastError())
        {
            DisplayInitError(IDS_STR_FAILED_CREATE_REPLSERV) ;
            return FALSE;
        }
        //
        // BUGBUG: do we have to check if service stopped and disabled?
        // In general, we are here only if msmq service was stopped and disabled.
        // Replication service depends on msmq service.
        // It means, that it was stopped too.
        //
    }
	if (hService)
    {
        CResString strDesc(IDS_MQ1SYNC_SERVICE_DESCRIPTION);
		SERVICE_DESCRIPTION ServiceDescription;
		ServiceDescription.lpDescription = const_cast<TCHAR*> (strDesc.Get());

		f = ChangeServiceConfig2(
               hService,
               SERVICE_CONFIG_DESCRIPTION,
               &ServiceDescription
               );
		ASSERT(f);
    }

    CloseServiceHandle(hService);

    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  CheckRegistry ()
//
//	Function checks if specific value exists in registry
//  returns TRUE if registry value exists
//
//+--------------------------------------------------------------

BOOL CheckRegistry (LPTSTR  lpszRegName)
{
	HKEY hRegKey;

    TCHAR szKeyName[256 * MAX_BYTES_PER_CHAR];
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, lpszRegName);

	TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));

    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
    _tcscpy(szValueName, _tcsinc(pLastBackslash));
    _tcscpy(pLastBackslash, TEXT(""));

	HRESULT hResult = RegOpenKeyEx(
						  FALCON_REG_POS,			// handle to open key
						  szKeyName,				// address of name of subkey to open
						  0,						// reserved
						  KEY_QUERY_VALUE ,			// security access mask
						  &hRegKey					// address of handle to open key
						  );
	if (hResult != ERROR_SUCCESS)
	{
		return FALSE;
	}

	hResult =  RegQueryValueEx(
					hRegKey,            // handle to key to query
					szValueName,		// address of name of value to query
					NULL,				// reserved
					NULL,				// address of buffer for value type
					NULL,				// address of data buffer
					NULL				// address of data buffer size
					);
	RegCloseKey(hRegKey);
	if (hResult != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  UpdateRegistryDW ()
//
//  returns TRUE if registry was updated succesfully
//
//+--------------------------------------------------------------

BOOL UpdateRegistryDW (LPTSTR  lpszRegName,
                       DWORD   dwValue )
{
	HKEY hRegKey;

    TCHAR szKeyName[256 * MAX_BYTES_PER_CHAR];
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, lpszRegName);

    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));

    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
    _tcscpy(szValueName, _tcsinc(pLastBackslash));
    _tcscpy(pLastBackslash, TEXT(""));

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;	
	HRESULT hResult = RegCreateKeyEx( FALCON_REG_POS,
							  szKeyName,
							  0,
							  NULL,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
							  &hRegKey,
							  &dwDisposition);

	if (hResult != ERROR_SUCCESS)
	{
        DisplayInitError( IDS_CANT_UPDATE_REGISTRY );
		return FALSE;
	}

    BYTE *pValueData = (BYTE *) &dwValue;
	hResult = RegSetValueEx( hRegKey,
                             szValueName,
                             0,
                             REG_DWORD,
                             pValueData,
                             sizeof(DWORD));

    if (hResult != ERROR_SUCCESS)
	{
        RegCloseKey(hRegKey);
        DisplayInitError( IDS_CANT_UPDATE_REGISTRY );
		return FALSE;
	}

    RegFlushKey(hRegKey);
    RegCloseKey(hRegKey);

    return TRUE;
}


//+------------------------------------------------------------------------
//
//  BOOL StopAndDisableService ()
//
//  Return TRUE if service was stopped and disabled
//
//+------------------------------------------------------------------------

BOOL StopAndDisableService (IN  LPTSTR     ptszServiceName)
{
    //
    // stop and disable service
    //
    DWORD     dwErr = 0 ;
    DWORD     dwServiceConfig = 0 ;
    DWORD     dwServiceStatus = 0 ;
    SC_HANDLE hService = NULL;

    DWORD      dwOpenError;
    DWORD      dwQueryError;
    DWORD      dwStopError;
    DWORD      dwDisableError;

    if (lstrcmpi(ptszServiceName, MSMQ_SERVICE_NAME) == 0)
    {
        dwOpenError = IDS_CANT_OPEN_MSMQ_SRVICE;
        dwQueryError = IDS_CANT_GET_MSMQ_CONFIG;
        dwStopError = IDS_STR_CANT_STOP_MSMQ;
        dwDisableError = IDS_STR_CANT_DISABLE_MSMQ;
    }
    else if (lstrcmpi(ptszServiceName, MQ1SYNC_SERVICE_NAME) == 0)
    {
        dwOpenError = IDS_CANT_OPEN_MQ1SYNC_SRVICE;
        dwQueryError = IDS_CANT_GET_MQ1SYNC_CONFIG;
        dwStopError = IDS_STR_CANT_STOP_MQ1SYNC;
        dwDisableError = IDS_STR_CANT_DISABLE_MQ1SYNC;
    }
    else
    {
        ASSERT(0);
        return FALSE;
    }

    BOOL f = _GetServiceState( ptszServiceName,
                               IDS_STR_FAILED_OPEN_MGR,
                               dwOpenError,
                               dwQueryError,
                              &hService,
                              &dwErr,
                              &dwServiceStatus,
                              &dwServiceConfig ) ;
    if (!f)
    {
        if (dwErr == IDS_CANT_OPEN_MQ1SYNC_SRVICE)
        {
            //
            // We are here only if we are in the "web" mode, i.e.
            // old version of migtool was ran before and we try to run
            // its improved version now.
            // The error means that the replication service was not created.
            // It is normal (if migtool failed before), we can continue.
            // The service will be created at the end of migration process.
            //
            ASSERT (g_fIsWebMode);
            return TRUE;
        }
        ASSERT(dwErr) ;
        DisplayInitError( dwErr ) ;
        return FALSE;
    }

    if (dwServiceStatus != SERVICE_STOPPED)
    {
        f = StopAService (hService) ;
        if (!f)
        {
            DisplayInitError(dwStopError) ;
            return FALSE;
        }
    }

    if (dwServiceConfig != SERVICE_DISABLED)
    {
        f = DisableAService (hService) ;
        if (!f)
        {
            DisplayInitError(dwDisableError) ;
            return FALSE;
        }
    }
    CloseServiceHandle(hService);

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  BOOL PrepareSpecialMode()
//
//  For recovery purpose we have to do the following:
//      - stop msmq service
//      - recovery mode: set to registry correct SiteId of this machine
//
//
//  Return TRUE if every thing succeeded
//
//+------------------------------------------------------------------------

BOOL PrepareSpecialMode ()
{
    //
    // stop and disable msmq service
    //
    BOOL f = StopAndDisableService (MSMQ_SERVICE_NAME);
    if (!f)
    {
        return FALSE;
    }

    //
    // Setup set SiteID of Default-First-Site to registry.
    // We need to get MasterId of the PEC/PSC machine (its site id)
    // from remote MQIS database and create entry MasterId in Migration section
    // with this value and (only in recovery mode) change value of SiteId entry
    // in registry and in DS. In addition, we'll get service of remote machine
    // and put this value to registry.
    //
    f = SetSiteIdOfPEC();
    if (!f)
    {
        return FALSE;
    }

    return TRUE;
}

//+--------------------------------------------------------------
//
// Function: StartReplicationService
//
// Synopsis: Start replication service.
//
//+--------------------------------------------------------------
BOOL StartReplicationService()
{
    CResString cErrorTitle(IDS_STR_SERVICE_FAIL_TITLE) ;
    CResString cWarningTitle(IDS_STR_SERVICE_WARNING_TITLE) ;

    SC_HANDLE hServiceCtrlMgr = OpenSCManager( NULL,
                                               NULL,
                                               SC_MANAGER_ALL_ACCESS );
    if (!hServiceCtrlMgr)
    {
        CResString cCantOpenMgr(IDS_STR_CANT_OPEN_MGR) ;
        MessageBox( NULL,
                    cCantOpenMgr.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
	}

    SC_HANDLE hService = OpenService( hServiceCtrlMgr,
                                      MQ1SYNC_SERVICE_NAME,
                                      SERVICE_ALL_ACCESS );
    if (!hService)
    {
        CloseServiceHandle( hServiceCtrlMgr ) ;

        CResString cCantOpenMq1Sync(IDS_STR_CANT_OPEN_MQ1SYNC) ;
        MessageBox( NULL,
                    cCantOpenMq1Sync.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
    }

    //
    // Bug 5327/ 5234:
    // scenario: user already run the wizard and replicaton service was started
    // then user like to run the wizard again.
    // For that user need to disable msmq and mq1sync services
    // When wizard is finished, replication service can't start because
    // its start mode is SERVICE_DISABLED.
    // It is important for "web" mode too: when user run wizard from the web after
    // he already ran it.
    //
    // Set the start mode to be autostart.
    //
    BOOL f = ChangeServiceConfig( hService,
                                  SERVICE_NO_CHANGE ,
                                  SERVICE_AUTO_START,
                                  SERVICE_NO_CHANGE,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL ) ;
    if (!f)
    {
        CResString cCantCnfgMsmq(IDS_STR_CANT_CNFG_MQ1SYNC) ;
        MessageBox( NULL,
                    cCantCnfgMsmq.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        CloseServiceHandle( hService ) ;
        CloseServiceHandle( hServiceCtrlMgr ) ;
        return FALSE;
    }

    f = StartAService(hService);
    if (!f)
    {
        CResString cCantStartMq1Sync(IDS_STR_CANT_START_MQ1SYNC) ;
        MessageBox( NULL,
                    cCantStartMq1Sync.Get(),
                    cWarningTitle.Get(),
                    (MB_OK | MB_ICONWARNING | MB_TASKMODAL)) ;
    }

    CloseServiceHandle( hService ) ;
    CloseServiceHandle( hServiceCtrlMgr ) ;
    return f ;
}

//+------------------------------------------------------------------------
//
//  BOOL PrepareToReRun
//
//  We are here if user run the CD version of wizard and like to repair
//  msmq object in ADS using web version.
//
//  Return TRUE if every thing succeeded
//
//+------------------------------------------------------------------------
BOOL PrepareToReRun()
{
    CResString cRestore(IDS_STR_RESTORE_OBJECTS) ;
    CResString cToContinue(IDS_STR_TO_CONTINUE) ;
    AP<TCHAR> szError = new TCHAR[1024] ;
    _stprintf(szError,_T("%s%s"), cRestore.Get(), cToContinue.Get());

    CResString cErrorTitle(IDS_STR_WARNING_TITLE) ;

    if (MessageBox( NULL,
                szError,
                cErrorTitle.Get(),
                (MB_OKCANCEL | MB_ICONWARNING | MB_TASKMODAL | MB_SETFOREGROUND)) == IDCANCEL)
    {		
        return FALSE;
    }

    //
    // stop and disable replication service
    //
    BOOL f = StopAndDisableService (MQ1SYNC_SERVICE_NAME);
    if (!f)
    {
        return FALSE;
    }

    //
    // stop and disable msmq service
    //
    f = StopAndDisableService (MSMQ_SERVICE_NAME);
    if (!f)
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\migservc.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    migservc.h

Abstract:

    - generic code to handle services.
    - code to check status of SQL server.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

#include <winsvc.h>

BOOL StartAService(SC_HANDLE hService) ;

BOOL IsMSMQServiceDisabled() ;

BOOL PrepareSpecialMode ();

BOOL UpdateRegistryDW (
		   LPTSTR  lpszRegName,
           DWORD   dwValue 
		   );

BOOL CheckRegistry (LPTSTR  lpszRegName);

BOOL PrepareToReRun ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\mqmig.h ===
// MqMig.h : main header file for the MQMIG application
//

#if !defined(AFX_MQMIG_H__0EDB9A87_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_MQMIG_H__0EDB9A87_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp:
// See MqMig.cpp for the implementation of this class
//

class CMqMigApp : public CWinApp
{
public:
	HWND m_hWndMain;
	CMqMigApp();
    BOOL AnalyzeCommandLine() ;
    LPTSTR SkipSpaces (LPTSTR pszStr) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMqMigApp)
	public:
	virtual BOOL InitInstance();
	virtual int  ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMqMigApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

extern CMqMigApp theApp;
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MQMIG_H__0EDB9A87_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\miguidbg.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    miguidbg.cpp

Abstract:

    Code for debugging the migration tool.
Author:

    Doron Juster  (DoronJ)  07-Feb-1999

--*/

#include "stdafx.h"

#include "miguidbg.tmh"

//+------------------------------------
//
//  UINT  ReadDebugIntFlag()
//
//+------------------------------------

#ifdef _DEBUG

UINT  ReadDebugIntFlag(TCHAR *pwcsDebugFlag, UINT iDefault)
{
    static BOOL   s_fInitialized = FALSE ;
    static TCHAR  s_szIniName[ MAX_PATH ] = {TEXT('\0')} ;

    if (!s_fInitialized)
    {
        DWORD dw = GetModuleFileName( NULL,
                                      s_szIniName,
                       (sizeof(s_szIniName) / sizeof(s_szIniName[0]))) ;
        if (dw != 0)
        {
            TCHAR *p = _tcsrchr(s_szIniName, TEXT('\\')) ;
            if (p)
            {
                p++ ;
                _tcscpy(p, TEXT("migtool.ini")) ;
            }
        }
        s_fInitialized = TRUE ;
    }

    UINT uiDbg = GetPrivateProfileInt( TEXT("Debug"),
                                       pwcsDebugFlag,
                                       iDefault,
                                       s_szIniName ) ;
    return uiDbg ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\mqmig.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name: MqMig.cpp

Abstract: Defines the class behaviors for the application.

Author:

    Erez Vizel
    Doron Juster

--*/

#include "stdafx.h"
#include "MqMig.h"
#include "cWizSht.h"
#include "initwait.h"
#include "migservc.h"
#include "mgmtwin.h"
#include "_mqres.h"

#include "mqmig.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HINSTANCE g_hLib ;
HINSTANCE  g_hResourceMod = MQGetResourceHandle();

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp

BEGIN_MESSAGE_MAP(CMqMigApp, CWinApp)
	//{{AFX_MSG_MAP(CMqMigApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp construction

CMqMigApp::CMqMigApp() :
	m_hWndMain(0)
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMqMigApp object

CMqMigApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp initialization

BOOL IsLocalMachineDC() ;
BOOL CheckVersionOfMQISServers();
BOOL CheckSQLServerStatus();
BOOL UpdateRemoteMQIS();
BOOL IsValidDllVersion ();

BOOL      g_fIsRecoveryMode = FALSE;
BOOL      g_fIsClusterMode = FALSE;
BOOL      g_fIsWebMode = FALSE;
LPTSTR    g_pszRemoteMQISServer = NULL ;
BOOL      g_fUpdateRemoteMQIS = FALSE;

LPVOID s_lpvMem = NULL;
HANDLE s_hMapMem = NULL;

BOOL CMqMigApp::InitInstance()
{

#ifdef _CHECKED
    // Send asserts to message box
    _set_error_mode(_OUT_TO_MSGBOX);
#endif

    CManagementWindow mgmtWin;
	if (mgmtWin.CreateEx(0, AfxRegisterWndClass(0), TEXT("MsmqMigrationMgmtWin"), 0, 0,0,0,0, 
		               HWND_DESKTOP, 0) == 0)
	{
		ASSERT(0);
		mgmtWin.m_hWnd = 0;
	}

	// create a global memory file map

	s_hMapMem = CreateFileMapping(
						(HANDLE)0xFFFFFFFF, NULL, PAGE_READWRITE,
						0,1024, TEXT("mqmig") );
	if ( !s_hMapMem )
	{
		return FALSE;
	}
	DWORD dwLastErr = GetLastError();
	// Get a pointer to the shared memory
	s_lpvMem = MapViewOfFile( s_hMapMem, FILE_MAP_WRITE, 0,0, 0 );
	if ( !s_lpvMem ) {
		return FALSE;
	}

	if (dwLastErr == ERROR_ALREADY_EXISTS)
	{	
		HWND hWnd;
		memcpy( &hWnd, (char*)s_lpvMem, sizeof (ULONG) );
		::PostMessage(hWnd, WM_SETFOCUS, 0 , 0);
        return FALSE;
	}
	else
	{
		memcpy( (char*)s_lpvMem, &(mgmtWin.m_hWnd), sizeof (ULONG) );
	}

    AfxSetResourceHandle(g_hResourceMod);
    
    //
    // analyze command line
    //
    if (m_lpCmdLine[0] != '\0')
    {
        BOOL f = AnalyzeCommandLine();
        if (!f)
        {
            //
            // parameters were wrong
            //
            CString cText ;
			cText.FormatMessage(IDS_MQMIG_USAGE, m_pszExeName);

            CResString cTitle(IDS_STR_ERROR_TITLE) ;

            MessageBox( NULL,
                        cText,
                        cTitle.Get(),
                        (MB_OK | MB_ICONSTOP | MB_TASKMODAL) ) ;
            return FALSE;
        }
    }

    //
    // Display the "please wait" box.
    // Do it after acquiring the module handle.
    //
    DisplayWaitWindow() ;

    //
    // first of all, verify that dll version is valid
    //
    BOOL f = IsValidDllVersion ();
    if (!f)
    {
        DestroyWaitWindow(TRUE) ;
        return FALSE;
    }

    if (g_fUpdateRemoteMQIS)
    {
        //
        // we don't need UI in this mode
        //
        BOOL f = UpdateRemoteMQIS();
        UNREFERENCED_PARAMETER(f);
        DestroyWaitWindow(TRUE) ;        
        return FALSE;
    }

    if (g_fIsWebMode)
    {
        //
        // if we are in the web and cluster/recovery mode we have to call PrepareToReRun
        // before PrepareSpecialMode because we have to stop replication service
        // before msmq service. PrepareSpecialMode tries to stop msmq service and it failed
        // if replication service is running. PrepareToReRun stops both services 
        // in the right order.
        //
        BOOL f = PrepareToReRun ();
        if (!f)
        {
            DestroyWaitWindow(TRUE) ;
            return FALSE ;
        }
    }

    if (g_fIsRecoveryMode || g_fIsClusterMode)
    {
        BOOL f = PrepareSpecialMode ();
        if (!f)
        {
            DestroyWaitWindow(TRUE) ;
            return FALSE;
        }
    }        

    if (!IsMSMQServiceDisabled())
    {
        //
        // Service is not disabled. quit!
        // The MSMQ service must be disabled in order for the migration
        // tool to start running.
        //
        DestroyWaitWindow(TRUE) ;
        return FALSE ;
    }

    //
    // Next, check if we're a DC.
    //
    f = IsLocalMachineDC() ;
    if (!f)
    {
        DisplayInitError( IDS_STR_NOT_DC ) ;
        DestroyWaitWindow(TRUE) ;
        return FALSE ;
    }

    //
    // Check now if SQL server is installed and running on this computer
    // If we are in recovery/cluster mode we don't have SQL Server installed on this
    // computer
    //
    if (!g_fIsRecoveryMode && !g_fIsClusterMode)
    {
        f = CheckSQLServerStatus();
        if (!f)
        {
            DestroyWaitWindow(TRUE) ;
            return FALSE;
        }
    }

    if (!g_fIsRecoveryMode)
    {
        //
        // Check now if version of each MQIS server is not less than MSMQ SP4
        // We need to check that in both normal and cluster modes.
        //
        f = CheckVersionOfMQISServers();
        if (!f)
        {
            DestroyWaitWindow(TRUE) ;
            return FALSE;
        }
    }

	cWizSheet cMigSheet ;
    DestroyWaitWindow(TRUE) ;

	int nResponse = cMigSheet.DoModal();	
    UNREFERENCED_PARAMETER(nResponse);

	//
    // Since the dialog has been closed, return FALSE so that we exit the
	// application, rather than start the application's message pump.
    //
	return FALSE;
}

//+----------------------------------------------------------------
//
// int  CMqMigApp::ExitInstance()
//
//  this is called when process exit. Free the migration dll.
//
//+----------------------------------------------------------------

int  CMqMigApp::ExitInstance()
{
	if (s_lpvMem)
	{
		// disconect process from global shared memory
		UnmapViewOfFile( s_lpvMem );
	}

	if (s_hMapMem)
	{
		// close the global memory FileMapping handle
		CloseHandle( s_hMapMem );
	}

    if (g_hLib)
    {
        FreeLibrary(g_hLib) ;
        g_hLib = NULL ;
    }
    return 0 ;
}

LPTSTR CMqMigApp::SkipSpaces (LPTSTR pszStr)
{
    while (*pszStr == _T(' '))
    {
        pszStr = CharNext(pszStr);
    }	
	return pszStr;
}

BOOL CMqMigApp::AnalyzeCommandLine()
{
    //
	// skip program name
	//
    LPTSTR pszCurParam = m_lpCmdLine;
    pszCurParam = CharLower(pszCurParam);

    while (*pszCurParam != _T('/') && *pszCurParam != _T('\0') )
    {
        pszCurParam = CharNext(pszCurParam);
    }
    if (*pszCurParam == _T('\0'))
    {
        return FALSE;
    }

    while (*pszCurParam != _T('\0') )
	{		
        if (*pszCurParam != _T('/'))
        {
            return FALSE;
        }
				
        pszCurParam = CharNext(pszCurParam);	
        switch (*pszCurParam)
        {
        case 'r':
            if (g_fIsRecoveryMode)
            {
                //
                // we already got this parameter
                //
                return FALSE;
            }
            g_fIsRecoveryMode = TRUE;
            pszCurParam = CharNext(pszCurParam);
            pszCurParam = SkipSpaces(pszCurParam);
            break;
        case 'c':
            if (g_fIsClusterMode)
            {
                //
                // we already got this parameter
                //
                return FALSE;
            }
            g_fIsClusterMode = TRUE;
            pszCurParam = CharNext(pszCurParam);
            pszCurParam = SkipSpaces(pszCurParam);
            break;
        case 'u':
            if (g_fUpdateRemoteMQIS)
            {
                //
                // we already got this parameter
                //
                return FALSE;
            }
            g_fUpdateRemoteMQIS = TRUE;
            pszCurParam = CharNext(pszCurParam);
            pszCurParam = SkipSpaces(pszCurParam);
            break;
        case 's':
            {
                if (g_pszRemoteMQISServer)
                {
                    //
                    // we already got this parameter
                    //
                    return FALSE;
                }						
                pszCurParam = CharNext(pszCurParam);
			    pszCurParam = SkipSpaces(pszCurParam);

                g_pszRemoteMQISServer = new TCHAR[ 1 + _tcslen(pszCurParam)] ;

                LPTSTR pszServer = g_pszRemoteMQISServer;
                while ( *pszCurParam != _T('\0') &&
                        *pszCurParam != _T('/') &&
                        *pszCurParam != _T(' '))
			    {				
                    *pszServer = *pszCurParam;
                    pszCurParam = CharNext(pszCurParam);
                    pszServer = CharNext(pszServer);
			    }			
                *pszServer = _T('\0');
			
                if (g_pszRemoteMQISServer[0] == '\0')
                {
                    //
                    // we did not get value
                    //
                    delete g_pszRemoteMQISServer;
                    return FALSE;
                }
                if (*pszCurParam != _T('\0'))
                {
                    pszCurParam = CharNext(pszCurParam);
			        pszCurParam = SkipSpaces(pszCurParam);
                }
            }
            break;
        case '?':
            return FALSE;
        default:
            return FALSE;
		}	
	}

    //
    // verify all parameters: /r OR /c AND /s <server name> are mandatory
    //
    if ( (g_fIsRecoveryMode || g_fIsClusterMode) && // for these parameters 
          g_pszRemoteMQISServer == NULL )           // server name is mandatory
    {
        g_fIsRecoveryMode = FALSE;
        g_fIsClusterMode = FALSE;
        return FALSE;
    }

    if (g_fUpdateRemoteMQIS  &&  //for this flag we don't need server name       
        g_pszRemoteMQISServer)
    {        
        delete g_pszRemoteMQISServer;
        g_pszRemoteMQISServer = NULL;
        return FALSE;
    }

    if (!g_fIsRecoveryMode && 
        !g_fIsClusterMode &&
        !g_fUpdateRemoteMQIS)
    {
        delete g_pszRemoteMQISServer;
        g_pszRemoteMQISServer = NULL;
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\resource.h ===
#include "..\..\mqutil\res\migtools\migdllres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\prgrsbar.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: prgrsbar.cpp

Abstract: implement the progress bars in the "wait" page.

Author:

    Erez Vizel
    Doron Juster

--*/

#include "stdafx.h"
#include "thrSite.h"
#include "sThrPrm.h"
#include "loadmig.h"
#include "..\mqmigrat\mqmigui.h"

#include "prgrsbar.tmh"

extern BOOL g_fMigrationCompleted;

//+----------------------------------------------------------------------
//
//  UINT ProgSiteThread(LPVOID var)
//
//  This thread read the migration counters from mqmigrat.dll and update
//  the progress bars.
//
//+----------------------------------------------------------------------

UINT __cdecl ProgressBarsThread(LPVOID lpV)
{	
	UINT iLastSitePosition = 0 ;
    UINT iLastQueuePosition = 0 ;
    UINT iLastMachinePosition = 0 ;
	UINT iLastUserPosition = 0 ;
	UINT iSiteCounter = 0 ;
    UINT iMachineCounter = 0 ;
    UINT iQueueCounter = 0 ;
	UINT iUserCounter = 0 ;

	sThreadParm* pVar = (sThreadParm*) lpV ;

	//
    //  Setting the progress ranges
    //
	(pVar->pSiteProgress)->SetRange( (short) g_iSiteLowLimit, (short) g_iSiteHighLimit);
	(pVar->pMachineProgress)->SetRange( (short) g_iMachineLowLimit, (short) g_iMachineHighLimit) ;
	(pVar->pQueueProgress)->SetRange( (short) g_iQueueLowLimit, (short) g_iQueueHighLimit) ;
	(pVar->pUserProgress)->SetRange( (short) g_iUserLowLimit, (short) g_iUserHighLimit);

	//
    //  Reseting the progress bars
    //
    (pVar->pSiteProgress)->SetPos(g_iSiteLowLimit);
	(pVar->pQueueProgress)->SetPos(g_iQueueLowLimit);
	(pVar->pMachineProgress)->SetPos(g_iMachineLowLimit);
	(pVar->pUserProgress)->SetPos(g_iUserLowLimit);

	//
	// Loading the Dll
	//
    BOOL f = LoadMQMigratLibrary(); // load dll
    if (!f)
    {
        return FALSE;  //error in loading the dll
    }

    MQMig_GetAllCounters_ROUTINE pfnGetAllCounters =
                 (MQMig_GetAllCounters_ROUTINE)
                          GetProcAddress( g_hLib, "MQMig_GetAllCounters" ) ;
	ASSERT(pfnGetAllCounters != NULL);

	if(pfnGetAllCounters == NULL)
	{	
		//
		//Error free the dll
		//
		return FALSE;
	}

	while( !g_fMigrationCompleted )
	{	
		//
		//Updating the value of the counters
		//
		HRESULT hr = (*pfnGetAllCounters)( &iSiteCounter,
                                           &iMachineCounter,
                                           &iQueueCounter,
										   &iUserCounter) ;
        UNREFERENCED_PARAMETER(hr);
		if(	(iSiteCounter    != iLastSitePosition)    ||
			(iMachineCounter != iLastMachinePosition) ||
			(iQueueCounter   != iLastQueuePosition)	  ||
			(iUserCounter    != iLastUserPosition)	)
		{
			iLastSitePosition =
                        (pVar->pSiteProgress)->SetPos((iSiteCounter)) ;
			iLastMachinePosition =
                        (pVar->pMachineProgress)->SetPos(iMachineCounter) ;
			iLastQueuePosition =
                        (pVar->pQueueProgress)->SetPos(iQueueCounter) ;
			iLastUserPosition =
                        (pVar->pUserProgress)->SetPos(iUserCounter) ;
		}
        Sleep(250);
	}

	//
    //  Leave the progress bars full.
    //
    delete lpV ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0EDB9A8B_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_STDAFX_H__0EDB9A8B_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _DEBUG
#undef _DEBUG
#endif

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxdlgs.h>

#ifdef DBG
    #include <assert.h>
	#undef ASSERT
	#define ASSERT(f) assert(f)
#endif // DBG


#include <mqmacro.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0EDB9A8B_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)

#include "commonui.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\sthrprm.h ===
#ifndef _THRPARM
#define _THRPARM
#include "stdafx.h"
typedef struct ThreadParm
{
	CPropertySheetEx* pPageFather;
	CProgressCtrl*  pSiteProgress;
	CProgressCtrl*  pMachineProgress;
	CProgressCtrl*  pQueueProgress;
	CProgressCtrl*  pUserProgress;
	int iPageNumber;
	
} sThreadParm;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\textfont.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    textfont.h

Abstract:

    define fonts for text in the upgrade wizard.

Author:

    Doron Juster  (DoronJ)  07-Feb-1999

--*/

#define  WELCONE_TITLE_WEIGHT   (FW_BOLD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\thranz.h ===
#ifndef _ANALYZE_THREAD
#define _ANALYZE_THREAD

extern HRESULT RunMigration();
extern  g_fSuccess;

UINT AnalyzeThread(LPVOID Dummy);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\thrmig.h ===
#ifndef _RUN_MIGRATION_THREAD
#define _RUN_MIGRATION_THREAD

extern HRESULT RunMigration();
extern  g_fSuccess;
UINT RunMigrationThread(LPVOID Dummy);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\thranz.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    thranz.cpp

Abstract:

    Thread that run the migration process in "analysis", read only, mode.

Author:

    Erez  Vizel
    Doron Juster  (DoronJ)

--*/

#include "stdafx.h"
#include "loadmig.h"
#include "sThrPrm.h"
#include "mqsymbls.h"

#include "thranz.tmh"

extern HRESULT   g_hrResultAnalyze ;

//+------------------------------------
//
//  UINT AnalyzeThread(LPVOID lpV)
//
//+------------------------------------

UINT __cdecl AnalyzeThread(LPVOID lpV)
{
    sThreadParm* pVar = (sThreadParm*) (lpV) ;
	
	//
    //  Reseting the progress bars
    //	
    (pVar->pSiteProgress)->SetPos(0);
	(pVar->pQueueProgress)->SetPos(0);
	(pVar->pMachineProgress)->SetPos(0);
	(pVar->pUserProgress)->SetPos(0);


    g_hrResultAnalyze = RunMigration() ;

    if (g_hrResultAnalyze == MQMig_E_QUIT)
    {
        ExitProcess(0) ;
    }

    //
    // Activating the next page,
    // either Pre-Migration page or the Finish page.
    //	
    UINT i=( (pVar->pPageFather)->SetActivePage(pVar->iPageNumber));
    UNREFERENCED_PARAMETER(i);

	delete lpV ;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\thrsite.h ===
//
//
//
#ifndef _progSiteThread_h_
#define _progSiteThread_h_

extern UINT       g_iSiteHighLimit;
extern const UINT g_iSiteLowLimit;
extern UINT       g_iMachineHighLimit;
extern const UINT g_iMachineLowLimit;
extern UINT       g_iQueueHighLimit;
extern const UINT g_iQueueLowLimit;
extern UINT       g_iUserHighLimit;
extern const UINT g_iUserLowLimit;


UINT __cdecl ProgressBarsThread(LPVOID progress);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\database.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    database.cpp

Abstract:

    SQL database related code.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include <mqsec.h>

#include "database.tmh"

void StringToSeqNum( IN TCHAR    pszSeqNum[],
                     OUT CSeqNum *psn );


MQDBHANDLE g_hDatabase = NULL ;
MQDBHANDLE g_hEntTable = NULL ;
MQDBHANDLE g_hSiteTable = NULL ;
MQDBHANDLE g_hSiteLinkTable = NULL ;
MQDBHANDLE g_hCNsTable = NULL ;
MQDBHANDLE g_hMachineTable = NULL ;
MQDBHANDLE g_hMachineCNsTable = NULL ;
MQDBHANDLE g_hQueueTable = NULL ;
MQDBHANDLE g_hUsersTable = NULL ;
MQDBHANDLE g_hDeletedTable = NULL ;

//--------------------------------------------------
//
//  HRESULT ConnectToDatabase()
//
//--------------------------------------------------

HRESULT ConnectToDatabase(BOOL fConnectAlways)
{
    static BOOL s_fConnected = FALSE ;
    if (s_fConnected && !fConnectAlways)
    {
        return TRUE ;
    }

    HRESULT hr = MQDBInitialize() ;
    CHECK_HR(hr) ;

    MQDBOPENDATABASE mqdbOpen = {DSN_NAME,
                                 NULL,
                                 "msmq",
                                 "Falcon",
                                 FALSE,
                                 NULL} ;
    hr = MQDBOpenDatabase(&mqdbOpen) ;
    CHECK_HR(hr) ;

    g_hDatabase =  mqdbOpen.hDatabase ;
    s_fConnected = TRUE;
    return hr  ;
}

//--------------------------------------------------
//
//   HRESULT OpenUsersTable()
//
//--------------------------------------------------

HRESULT OpenUsersTable()
{
    HRESULT hr ;
    if (!g_hUsersTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            USER_TABLE_NAME,
                            &g_hUsersTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetUserCount(UINT *pcUsers)
//
//--------------------------------------------------

HRESULT GetUserCount(UINT *pcUsers)
{
    HRESULT hr = OpenUsersTable();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hUsersTable,
                            pcUsers ) ;
    return hr ;
}

//--------------------------------------------------
//
//   HRESULT _OpenMachineTable()
//
//--------------------------------------------------

static HRESULT _OpenMachineTable()
{
    HRESULT hr ;
    if (!g_hMachineTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            MACHINE_TABLE_NAME,
                            &g_hMachineTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenMachineCNsTable()
//
//--------------------------------------------------

HRESULT OpenMachineCNsTable()
{
    HRESULT hr ;
    if (!g_hMachineCNsTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            MACHINE_CN_TABLE_NAME,
                            &g_hMachineCNsTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenCNsTable()
//
//--------------------------------------------------

HRESULT OpenCNsTable()
{
    HRESULT hr ;
    if (!g_hCNsTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            CN_TABLE_NAME,
                            &g_hCNsTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetCNCount(UINT *pcCNs)
//
//--------------------------------------------------

HRESULT GetCNCount(UINT *pcCNs)
{
    HRESULT hr = OpenCNsTable();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hCNsTable,
                            pcCNs ) ;
    return hr ;
}

//--------------------------------------------------
//
//   HRESULT OpenQueueTable()
//
//--------------------------------------------------

HRESULT OpenQueueTable()
{
    HRESULT hr ;
    if (!g_hQueueTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            QUEUE_TABLE_NAME,
                            &g_hQueueTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenDeletedTable()
//
//--------------------------------------------------

HRESULT OpenDeletedTable()
{
    HRESULT hr ;
    if (!g_hDeletedTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            DELETED_TABLE_NAME,
                            &g_hDeletedTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenEntTable()
//
//--------------------------------------------------

HRESULT OpenEntTable()
{
    HRESULT hr ;
    if (!g_hEntTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            ENTERPRISE_TABLE_NAME,
                            &g_hEntTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenSiteLinkTable()
//
//--------------------------------------------------

HRESULT OpenSiteLinkTable()
{
    HRESULT hr ;
    if (!g_hSiteLinkTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            LINK_TABLE_NAME,
                            &g_hSiteLinkTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetSiteLinkCount(UINT *pcSiteLinks)
//
//--------------------------------------------------

HRESULT GetSiteLinkCount(UINT *pcSiteLinks)
{
    HRESULT hr = OpenSiteLinkTable();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hSiteLinkTable,
                            pcSiteLinks ) ;
    return hr ;
}

//--------------------------------------------------
//
//   HRESULT _OpenSiteTable()
//
//--------------------------------------------------

HRESULT _OpenSiteTable()
{
    HRESULT hr ;
    if (!g_hSiteTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            SITE_TABLE_NAME,
                            &g_hSiteTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetSitesCount(UINT *pcSites)
//
//--------------------------------------------------

HRESULT GetSitesCount(UINT *pcSites)
{
    HRESULT hr = _OpenSiteTable ();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hSiteTable,
                            pcSites ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetAllMachinesCount(UINT *pcMachines)
//
//--------------------------------------------------

HRESULT GetAllMachinesCount(UINT *pcMachines)
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hMachineTable,
                            pcMachines ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetAllQueuesCount(UINT *pcQueues)
//
//--------------------------------------------------

HRESULT GetAllQueuesCount(UINT *pcQueues)
{
    HRESULT hr = OpenQueueTable() ;
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hQueueTable,
                            pcQueues ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetMachinesCount(UINT *pcMachines)
//
//--------------------------------------------------

HRESULT GetMachinesCount(IN  GUID *pSiteGuid,
                         OUT UINT *pcMachines)
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    MQDBCOLUMNSEARCH ColSearch[2] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = M_OWNERID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = M_OWNERID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    hr = MQDBGetTableCount( g_hMachineTable,
                            pcMachines,
                            ColSearch ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetQueuesCount(UINT *pcMachines)
//
//--------------------------------------------------

HRESULT GetQueuesCount( IN  GUID *pMachineGuid,
                        OUT UINT *pcQueues )
{
    HRESULT hr = OpenQueueTable() ;
    CHECK_HR(hr) ;

    LONG cColumns = 0 ;
    MQDBCOLUMNSEARCH ColSearch[2] ;

    INIT_COLUMNSEARCH(ColSearch[ cColumns ]) ;
    ColSearch[ cColumns ].mqdbColumnVal.lpszColumnName = Q_QMID_COL ;
    ColSearch[ cColumns ].mqdbColumnVal.mqdbColumnType = Q_QMID_CTYPE ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnValue = (LONG) pMachineGuid ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[ cColumns ].mqdbOp = EQ ;
    cColumns++ ;

    hr = MQDBGetTableCount( g_hQueueTable,
                            pcQueues,
                            ColSearch,
                            cColumns ) ;

    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetAllQueuesInSiteCount(IN  GUID *pSiteGuid,
//                                  OUT UINT *pcQueues)
//
//--------------------------------------------------

HRESULT GetAllQueuesInSiteCount( IN  GUID *pSiteGuid,
                                 OUT UINT *pcQueues )
{
    HRESULT hr = OpenQueueTable() ;
    CHECK_HR(hr) ;

    LONG cColumns = 0 ;
    MQDBCOLUMNSEARCH ColSearch[2] ;

    INIT_COLUMNSEARCH(ColSearch[ cColumns ]) ;
    ColSearch[ cColumns ].mqdbColumnVal.lpszColumnName = Q_OWNERID_COL ;
    ColSearch[ cColumns ].mqdbColumnVal.mqdbColumnType = Q_OWNERID_CTYPE ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[ cColumns ].mqdbOp = EQ ;
    cColumns++ ;

    hr = MQDBGetTableCount( g_hQueueTable,
                            pcQueues,
                            ColSearch,
                            cColumns ) ;

    return hr ;
}

HRESULT GetAllObjectsNumber (IN  GUID *pSiteGuid,
                             IN  BOOL    fPec,
                             OUT UINT *puiAllObjectNumber )
{
    HRESULT hr;
    UINT CurNum;	
    if (fPec)
    {
        // get site number
        hr = GetSitesCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // get user number
        hr = GetUserCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // get sitelink number
        hr = GetSiteLinkCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // get CN number (if needed)
        hr = GetCNCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // +1 (enterprise object)
        (*puiAllObjectNumber) ++;
    }
    else
    {
        hr = GetAllQueuesInSiteCount( pSiteGuid, &CurNum );
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        hr = GetMachinesCount( pSiteGuid, &CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;
    }

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT  FindLargestSeqNum(GUID *pMasterId)
//
//--------------------------------------------------

#define  PROCESS_RESULT     \
    if (SUCCEEDED(hr) &&                                                  \
        ((const unsigned char *) pColumns[ iSeqNumIndex ].nColumnValue )) \
    {                                                                     \
        snLsn.SetValue(                                                   \
          (const unsigned char *) pColumns[ iSeqNumIndex ].nColumnValue ) ; \
                                                                            \
        if (snLsn > snMaxLsn)                                               \
        {                                                                   \
            snMaxLsn = snLsn;                                               \
        }                                                                   \
        MQDBFreeBuf ((void *) pColumns[ iSeqNumIndex ].nColumnValue) ;      \
    }                                                                       \
    else if (SUCCEEDED(hr))                                                 \
    {                                                                       \
        /*                                                                  \
           success with NULL value. It's OK, as NO_MORE_DATA                \
        */                                                                  \
    }                                                                       \
    else if (hr == MQDB_E_NO_MORE_DATA)                                     \
    {                                                                       \
        /*                                                                  \
           that's OK.                                                       \
        */                                                                  \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        ASSERT(0) ;                                                         \
        return hr ;                                                         \
    }

HRESULT  FindLargestSeqNum( GUID    *pMasterId,
                            CSeqNum &snMaxLsn,
                            BOOL    fPec )
{
    CSeqNum snLsn;

    LONG cAlloc = 1 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;
    MQDBCOLUMNSEARCH ColSearch[1] ;

    if (fPec)
    {
        //
        // for PEC, look also in the Enterprise, Site, CN and users table.
        //

        HRESULT hr = OpenUsersTable() ;
        CHECK_HR(hr) ;

        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = U_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = U_SEQNUM_CTYPE ;
        UINT iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hUsersTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // Search the enterprise table.
        //
        hr = OpenEntTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = E_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = E_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hEntTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // Search the CNs table.
        //
        hr = OpenCNsTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = CN_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = CN_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hCNsTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // Search the site table.
        //
        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = S_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = S_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;
        ASSERT(g_hSiteTable) ;

        hr =  MQDBOpenAggrQuery( g_hSiteTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // search the sitelink table
        //
        hr = OpenSiteLinkTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = L_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = L_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hSiteLinkTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;
    }
    else
    {
        //
        // Reteive SeqNum from the Queue table.
        //
        HRESULT hr = OpenQueueTable() ;
        CHECK_HR(hr) ;

        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = Q_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = Q_SEQNUM_CTYPE ;
        UINT iSeqNumIndex = cColumns ;
        cColumns++ ;

        INIT_COLUMNSEARCH(ColSearch[0]) ;
        ColSearch[0].mqdbColumnVal.lpszColumnName = Q_OWNERID_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = Q_OWNERID_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pMasterId ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
        ColSearch[0].mqdbOp = EQ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hQueueTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 ColSearch,
                                 1,
                                 AND);
        PROCESS_RESULT ;

        //
        // Reteive SeqNum from the Machine table.
        //
        hr = _OpenMachineTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = M_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = M_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        INIT_COLUMNSEARCH(ColSearch[0]) ;
        ColSearch[0].mqdbColumnVal.lpszColumnName = M_OWNERID_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = M_OWNERID_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pMasterId ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
        ColSearch[0].mqdbOp = EQ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hMachineTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 ColSearch,
                                 1,
                                 AND);
        PROCESS_RESULT ;
    }

    //
    // Reteive SeqNum from the Deleted table.
    //
    HRESULT hr = OpenDeletedTable() ;
    CHECK_HR(hr) ;

    cColumns = 0 ;
    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = D_SEQNUM_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = D_SEQNUM_CTYPE ;
    UINT iSeqNumIndex = cColumns ;
    cColumns++ ;

    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = D_OWNERID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = D_OWNERID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pMasterId ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cColumns == cAlloc) ;

    hr =  MQDBOpenAggrQuery( g_hDeletedTable,
                             pColumns,
                             MQDBAGGR_MAX,
                             ColSearch,
                             1,
                             AND);
    PROCESS_RESULT ;

    return S_OK ;
}

//+--------------------------------------------------
//
//  HRESULT EnableMultipleQueries(BOOL fEnable)
//
//+--------------------------------------------------

HRESULT EnableMultipleQueries(BOOL fEnable)
{
    HRESULT hr = MQDBSetOption( g_hDatabase,
                                MQDBOPT_MULTIPLE_QUERIES,
                                fEnable,
                                NULL ) ;
    return hr ;
}

//--------------------------------------------------
//
//  void    CleanupDatabase()
//
//--------------------------------------------------

void    CleanupDatabase()
{
    if (g_hEntTable)
    {
        MQDBCloseTable(g_hEntTable) ;
        g_hEntTable = NULL ;
    }
    if (g_hSiteTable)
    {
        MQDBCloseTable(g_hSiteTable) ;
        g_hSiteTable = NULL ;
    }
    if (g_hMachineTable)
    {
        MQDBCloseTable(g_hMachineTable) ;
        g_hMachineTable = NULL ;
    }
    if (g_hMachineCNsTable)
    {
        MQDBCloseTable(g_hMachineCNsTable) ;
        g_hMachineCNsTable = NULL ;
    }
    if (g_hCNsTable)
    {
        MQDBCloseTable(g_hCNsTable) ;
        g_hCNsTable = NULL ;
    }
    if (g_hQueueTable)
    {
        MQDBCloseTable(g_hQueueTable) ;
        g_hQueueTable = NULL ;
    }
    if (g_hUsersTable)
    {
        MQDBCloseTable(g_hUsersTable) ;
        g_hUsersTable = NULL ;
    }
    if (g_hDeletedTable)
    {
        MQDBCloseTable(g_hDeletedTable) ;
        g_hDeletedTable = NULL ;
    }
}

//--------------------------------------------------
//
//  HRESULT    CheckVersion (UINT   *piCount, LPTSTR *ppszServers)
//
//--------------------------------------------------
#define INIT_MACHINE_COLUMN(_ColName, _ColIndex, _Index)            \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT CheckVersion (
              OUT UINT   *piOldVerServersCount,
              OUT LPTSTR *ppszOldVerServers
              )
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    UINT cMachines;
    hr = MQDBGetTableCount( g_hMachineTable,
                            &cMachines ) ;
    CHECK_HR(hr) ;

    if (cMachines == 0)
    {
        return MQMig_E_NO_MACHINES_AVAIL ;
    }

    ULONG cAlloc = 5 ;
    ULONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_MACHINE_COLUMN(M_NAME1,          iName1Index,      cbColumns) ;
    INIT_MACHINE_COLUMN(M_NAME2,          iName2Index,      cbColumns) ;
    INIT_MACHINE_COLUMN(M_SERVICES,       iServiceIndex,    cbColumns) ;
    INIT_MACHINE_COLUMN(M_MTYPE,          iTypeIndex,       cbColumns) ;
    INIT_MACHINE_COLUMN(M_OWNERID,        iOwnerIdIndex,    cbColumns) ;

    #undef  INIT_MACHINE_COLUMN

    //
    // Restriction. query by machine service.
    //
    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = M_SERVICES_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = M_SERVICES_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (ULONG) SERVICE_BSC ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(ULONG) ;
    ColSearch[0].mqdbOp = GE ;

    ASSERT(cbColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hMachineTable,
                                       pColumns,
                                       cbColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    LPWSTR *ppwcsOldVerServers = new LPWSTR[cMachines];
    *piOldVerServersCount = 0;

    UINT iIndex = 0 ;
	
    TCHAR *pszFileName = GetIniFileName ();
    ULONG ulServerCount = 0;

    while(SUCCEEDED(status))
    {
        if (iIndex >= cMachines)
        {
            status = MQMig_E_TOO_MANY_MACHINES ;
            break ;
        }

        //
        // Get one name buffer from both name columns.
        //
        P<BYTE> pwzBuf = NULL ;
        DWORD  dwIndexs[2] = { iName1Index, iName2Index } ;
        HRESULT hr =  BlobFromColumns( pColumns,
                                       dwIndexs,
                                       2,
                                       (BYTE**) &pwzBuf ) ;
        CHECK_HR(hr) ;
        WCHAR *pwzMachineName = (WCHAR*) (pwzBuf + sizeof(DWORD)) ;

        //
        // we check version on all PSCs and on all BSCs of PEC
        //
        if ( (DWORD)pColumns[ iServiceIndex ].nColumnValue == SERVICE_PSC   ||
             ( (DWORD)pColumns[ iServiceIndex ].nColumnValue == SERVICE_BSC &&
                memcmp (  &g_MySiteGuid,
                          (void*) pColumns[ iOwnerIdIndex ].nColumnValue,
                          sizeof(GUID)) == 0 ) )
        {
            BOOL fOldVersion;
            hr = AnalyzeMachineType ((LPWSTR) pColumns[ iTypeIndex ].nColumnValue,
                                     &fOldVersion);
            if (FAILED(hr))
            {
                LogMigrationEvent(  MigLog_Error,
                                    hr,
                                    pwzMachineName,
                                    (LPWSTR) pColumns[ iTypeIndex ].nColumnValue
                                    ) ;
            }
            if (SUCCEEDED(hr) && fOldVersion)
            {
                LogMigrationEvent(  MigLog_Info,
                                    MQMig_I_OLD_MSMQ_VERSION,
                                    pwzMachineName,
                                    (LPWSTR) pColumns[ iTypeIndex ].nColumnValue
                                    ) ;

                ppwcsOldVerServers[*piOldVerServersCount] = new WCHAR[wcslen(pwzMachineName)+1];
		        wcscpy (ppwcsOldVerServers[*piOldVerServersCount], pwzMachineName);
                (*piOldVerServersCount)++;
            }
            if (g_fClusterMode)
            {
                //
                // we have to save all PSC's name and all PEC's BSCs in .ini file 
                // in order to send them new PEC name at the end of migration
                //
                ulServerCount++;
                TCHAR tszKeyName[50];
                _stprintf(tszKeyName, TEXT("%s%lu"), 
					MIGRATION_ALLSERVERS_NAME_KEY, ulServerCount);
                BOOL f = WritePrivateProfileString( 
                                        MIGRATION_ALLSERVERS_SECTION,
                                        tszKeyName,
                                        pwzMachineName,
                                        pszFileName ) ;
                UNREFERENCED_PARAMETER(f);
            }
        }

        MQDBFreeBuf((void*) pColumns[ iName1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iName2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iTypeIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iOwnerIdIndex ].nColumnValue) ;
        for ( ULONG i = 0 ; i < cbColumns; i++ )
        {		
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
        CHECK_HR(hr) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    if (g_fClusterMode)
    {
        //
        // we have to save all PSC's name and all PEC's BSCs in .ini file 
        // in order to send them new PEC name at the end of migration
        //
        TCHAR szBuf[20];
        _ltot( ulServerCount, szBuf, 10 );
        BOOL f = WritePrivateProfileString( 
                                MIGRATION_ALLSERVERSNUM_SECTION,
                                MIGRATION_ALLSERVERSNUM_KEY,
                                szBuf,
                                pszFileName ) ;
        UNREFERENCED_PARAMETER(f);
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_SQL_FAIL, status) ;
        return status ;
    }

    if (*piOldVerServersCount == 0)
    {
        delete ppwcsOldVerServers;
        return MQMig_OK;
    }

    //
    // build list of servers
    //
    DWORD dwSize = 0;
    for (UINT i=0; i<*piOldVerServersCount; i++)
    {
        dwSize += wcslen(ppwcsOldVerServers[i]);
    }
    //
    // add place for '\n' after each server name
    //
    dwSize += *piOldVerServersCount;

    WCHAR *pwcsServersList = new WCHAR[dwSize + 1];
    pwcsServersList[0] = L'\0';
    for (i=0; i<*piOldVerServersCount; i++)
    {
        wcscat (pwcsServersList, ppwcsOldVerServers[i]);
        delete ppwcsOldVerServers[i];
        wcscat (pwcsServersList, L"\n");
    }
    delete [] ppwcsOldVerServers;

    *ppszOldVerServers = pwcsServersList;

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT    GetSiteIdOfPEC (IN  GUID *pMyMachineGuid, OUT GUID *pSiteId)
//
//--------------------------------------------------

#define INIT_MACHINE_COLUMN(_ColName, _ColIndex, _Index)            \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT GetSiteIdOfPEC (IN LPTSTR pszRemoteMQISName,
                        OUT ULONG *pulService,
                        OUT GUID  *pSiteId)
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    UINT cMachines;
    hr = MQDBGetTableCount( g_hMachineTable,
                            &cMachines ) ;
    CHECK_HR(hr) ;

    if (cMachines == 0)
    {
        return MQMig_E_NO_MACHINES_AVAIL ;
    }

    ULONG cAlloc = 2 ;
    ULONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_MACHINE_COLUMN(M_OWNERID,  iOwnerIdIndex,  cbColumns) ;
    INIT_MACHINE_COLUMN(M_SERVICES, iServicesIndex, cbColumns) ;

    #undef  INIT_MACHINE_COLUMN

    ASSERT(cbColumns == cAlloc) ;

    //
    // For cluster mode we get remote clustered server and we have to 
    // find Services and OwnerId of this server according to its name.
    // For recovery mode we have to find OwnerId according to Services
    // since we run wizard in this mode only for crashed PEC. In this case
    // given server name is server where we recovery PEC from.
    //        
    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;

    if (g_fClusterMode)
    {
        DWORD dwHashKey = CalHashKey( pszRemoteMQISName );
        
        ColSearch[0].mqdbColumnVal.lpszColumnName = M_HKEY_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = M_HKEY_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) dwHashKey ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(LONG) ;
        ColSearch[0].mqdbOp = EQ ;                  
    }
    else
    {
        //
        // recovery mode
        //       
        ColSearch[0].mqdbColumnVal.lpszColumnName = M_SERVICES_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = M_SERVICES_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) SERVICE_PEC ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(LONG) ;
        ColSearch[0].mqdbOp = EQ ;                        
    }

    CHQuery hQuery ;   

    MQDBSTATUS status = MQDBOpenQuery( g_hMachineTable,
                                       pColumns,
                                       cbColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
						               TRUE ) ;        
    CHECK_HR(status) ;

    UINT iIndex = 0 ;

    while(SUCCEEDED(status))
    {
        if (iIndex >= 1)
        {
            //
            // only one machine with the given service/ name must be found
            //
            status = MQMig_E_TOO_MANY_MACHINES ;
            break ;
        }
        memcpy (pSiteId, (void*) pColumns[ iOwnerIdIndex ].nColumnValue, sizeof(GUID));        
        MQDBFreeBuf((void*) pColumns[ iOwnerIdIndex ].nColumnValue) ;

        *pulService = pColumns[ iServicesIndex ].nColumnValue;

        for ( ULONG i = 0 ; i < cbColumns; i++ )
        {		
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
        CHECK_HR(hr) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;    
    }
    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_SQL_FAIL, status) ;
        return status ;
    }  

    if (*pulService < SERVICE_PSC && g_fClusterMode)
    {
        //
        // for cluster mode: remote machine on cluster must be either PSC or PEC
        //
        LogMigrationEvent(  MigLog_Error, MQMig_E_CLUSTER_WRONG_SERVICE, 
                            pszRemoteMQISName, *pulService) ;
        return MQMig_E_CLUSTER_WRONG_SERVICE;
    }

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT _UpdateEnterpriseTable()
//  Update enterprise table of remote databases: 
//		change PEC name to name of this local machine
//
//--------------------------------------------------

HRESULT _UpdateEnterpriseTable(LPTSTR pszLocalComputerName)
{
    HRESULT hr = OpenEntTable();
    if (FAILED(hr))
    {
        return hr;
    }

    MQDBCOLUMNVAL mqdbPecNameUpdate =
    { sizeof(MQDBCOLUMNVAL), E_PECNAME_COL, (long)pszLocalComputerName, E_PECNAME_CLEN, E_PECNAME_CTYPE, 0};
       
    hr =  MQDBUpdateRecord(
               g_hEntTable,
               &mqdbPecNameUpdate,
               1,
               NULL,
               NULL,
               NULL) ;
    return hr;
}

//--------------------------------------------------
//
//  HRESULT _UpdateMachineTable()
//  Update machine table of remote databases: 
//		change services of former PEC to SERVICE_SRV
//
//--------------------------------------------------

HRESULT _UpdateMachineTable()
{
    HRESULT hr = _OpenMachineTable();
    if (FAILED(hr))
    {
        return hr;
    }
	
    ASSERT(g_FormerPECGuid != GUID_NULL);
    
    MQDBCOLUMNVAL mqdbServiceUpdate =
    { sizeof(MQDBCOLUMNVAL), M_SERVICES_COL, (long)SERVICE_SRV, M_SERVICES_CLEN, M_SERVICES_CTYPE, 0};
   
    MQDBCOLUMNSEARCH mqdbServiceSearch =
    {{sizeof(MQDBCOLUMNVAL), M_QMID_COL, (long)(&g_FormerPECGuid), M_QMID_CLEN, M_QMID_CTYPE, 0}, EQ, FALSE};
   
    hr =  MQDBUpdateRecord(
               g_hMachineTable,
               &mqdbServiceUpdate,
               1,
               &mqdbServiceSearch,
               NULL,
               NULL) ;
		
    return hr;
}

//--------------------------------------------------
//
//  HRESULT _UpdateSiteTable()
//  Update site table of remote databases: 
//		change PSC name of former PEC site to new PEC name
//
//--------------------------------------------------

HRESULT _UpdateSiteTable(LPTSTR pszLocalComputerName)
{
    HRESULT hr = _OpenSiteTable();
    if (FAILED(hr))
    {
        return hr;
    }	

    MQDBCOLUMNVAL mqdbPSCNameUpdate =
    { sizeof(MQDBCOLUMNVAL), S_PSC_COL, (long)pszLocalComputerName, S_PSC_CLEN, S_PSC_CTYPE, 0};
   
    MQDBCOLUMNSEARCH mqdbPSCNameSearch =
    {{sizeof(MQDBCOLUMNVAL), S_ID_COL, (long)(&g_MySiteGuid), S_ID_CLEN, S_ID_CTYPE, 0}, EQ, FALSE};
   
    hr =  MQDBUpdateRecord(
               g_hSiteTable,
               &mqdbPSCNameUpdate,
               1,
               &mqdbPSCNameSearch,
               NULL,
               NULL) ;
		
    return hr;
}

//--------------------------------------------------
//
//  void _PrepareMultipleColumns ()
//	Split values for multiple columns
//
//--------------------------------------------------

void _PrepareMultipleColumns (
			IN	ULONG           ulNumOfColumns,
			IN	unsigned char   *pData,
			IN	long            lSize,
			OUT	MQDBCOLUMNVAL   *pColumns
			)
{	
    unsigned char * pcNextToCopy = pData ;	
    MQDBCOLUMNVAL * pColumnVal = pColumns;
    char *pTempBuff ;

    for (ULONG i=0; i<ulNumOfColumns; i++, pColumnVal++)
    {
        if ( lSize )
        {
            //
            //  Into each section of the value we add the length.
            //  The reason for this is:
            //  the first entries of multiple entry property are of fixbinary type
            //  No matter which part of a fixbinary enrty is filled, when it is read,
            //  The returned length is field length ( not the length of the part
            //  which was filled).
            //

            //
            //  For the length we leave two bytes
            //
            if ( pColumnVal->nColumnLength == 0)    // this is a varbinary column
            {
                pColumnVal->nColumnLength = lSize + MQIS_LENGTH_PREFIX_LEN;
            }
            else
            {
                pColumnVal->nColumnLength = ( lSize + MQIS_LENGTH_PREFIX_LEN > pColumnVal->nColumnLength ) ? pColumnVal->nColumnLength : lSize + MQIS_LENGTH_PREFIX_LEN;
            }
            pTempBuff = new char[pColumnVal->nColumnLength];

            //
            //  Data legth = column length - 2
            //
            *((short *)pTempBuff) = (short)pColumnVal->nColumnLength - MQIS_LENGTH_PREFIX_LEN;
            memcpy( pTempBuff + MQIS_LENGTH_PREFIX_LEN, pcNextToCopy, pColumnVal->nColumnLength -MQIS_LENGTH_PREFIX_LEN);
            pColumnVal->nColumnValue = (long)pTempBuff;
            lSize -= pColumnVal->nColumnLength - MQIS_LENGTH_PREFIX_LEN;
            pcNextToCopy += pColumnVal->nColumnLength - MQIS_LENGTH_PREFIX_LEN;
        }
        else
        {
            //
            // size is 0
            //
            pColumnVal->nColumnLength = 0;            
        }
    }
    return;
}
	
//--------------------------------------------------
//
//  HRESULT    _AddThisMachine(LPTSTR pszLocalComputerName)
//	Add this local machine to remote databases
//
//--------------------------------------------------

HRESULT _AddThisMachine(LPTSTR pszLocalComputerName)
{
    HRESULT hr = _OpenMachineTable();
    if (FAILED(hr))
    {
	    return hr;
    }

    //
    // the first is to get max seqnum from registry
    //
    static BOOL		s_fIsMaxSNFound = FALSE;
    static CSeqNum  s_snMax;

    if (!s_fIsMaxSNFound)
    {
        unsigned short *lpszGuid ;
        UuidToString( &g_MySiteGuid, &lpszGuid ) ;
    	        
        TCHAR wszSeq[ SEQ_NUM_BUF_LEN ] ;
        memset(wszSeq, 0, sizeof(wszSeq)) ;

        TCHAR *pszFileName = GetIniFileName ();
        GetPrivateProfileString( MIGRATION_SEQ_NUM_SECTION,
                                 lpszGuid,
                                 TEXT(""),
                                 wszSeq,
                                 (sizeof(wszSeq) / sizeof(wszSeq[0])),
                                 pszFileName ) ;
        RpcStringFree( &lpszGuid ) ;

        if (_tcslen(wszSeq) != 16)
        {
	        //
	        // all seq numbers are saved in the ini file as strings of 16
	        // chatacters
	        //        
	        return MQMig_E_CANNOT_UPDATE_SERVER;
        }

        //
        // it will be SN for this machine object in remote MQIS database
        //
        StringToSeqNum( wszSeq,
                        &s_snMax ) ;

        s_fIsMaxSNFound = TRUE;
    }

    //
    // get properties from ADS
    //
    #define PROP_NUM	5
    PROPID propIDs[PROP_NUM];
    PROPVARIANT propVariants[PROP_NUM];
    DWORD iProps = 0;

    propIDs[ iProps ] = PROPID_QM_OLDSERVICE ;   
    propVariants[ iProps ].vt = VT_UI4 ;
    DWORD dwServiceIndex = iProps;
    iProps++;
    
    propIDs[ iProps ] = PROPID_QM_SIGN_PKS ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].blob.cbSize = 0 ;
    propVariants[ iProps ].blob.pBlobData = NULL ;
    DWORD dwSignKeyIndex = iProps ;
    iProps++;

    propIDs[ iProps ] = PROPID_QM_ENCRYPT_PKS ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].blob.cbSize = 0 ;
    propVariants[ iProps ].blob.pBlobData = NULL ;
    DWORD dwExchKeyIndex = iProps ;
    iProps++;

    propIDs[ iProps ] = PROPID_QM_SECURITY ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].blob.cbSize = 0 ;
    propVariants[ iProps ].blob.pBlobData = NULL ;
    DWORD dwSecurityIndex = iProps ;
    iProps++;

    propIDs[ iProps ] = PROPID_QM_SITE_ID ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].puuid = NULL ;
    DWORD dwSiteIdIndex = iProps ;
    iProps++;    

    ASSERT (iProps <= PROP_NUM);

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  

    hr = DSCoreGetProps(
             MQDS_MACHINE,
             NULL, // pathname
             &g_MyMachineGuid,
             iProps,
             propIDs,
             &requestContext,
             propVariants);

    if (FAILED(hr))
    {
        return hr;
    }

    P<MQDSPUBLICKEYS> pPublicSignKeys = NULL ;
    P<MQDSPUBLICKEYS> pPublicExchKeys = NULL ;

    if (propVariants[ dwSignKeyIndex ].blob.pBlobData)
    {
        //
        // Extract msmq1.0 public key from Windows 2000 ADS blob.
        //
        BYTE *pSignKey = NULL ;
        DWORD dwKeySize = 0 ;
        pPublicSignKeys = (MQDSPUBLICKEYS *)
                       propVariants[ dwSignKeyIndex ].blob.pBlobData ;

        HRESULT hr1 =  MQSec_UnpackPublicKey(
                                     pPublicSignKeys,
                                     x_MQ_Encryption_Provider_40,
                                     x_MQ_Encryption_Provider_Type_40,
                                    &pSignKey,
                                    &dwKeySize ) ;
        
        if (SUCCEEDED(hr1))
        {
            ASSERT(pSignKey && dwKeySize) ;
            propVariants[ dwSignKeyIndex ].blob.pBlobData = pSignKey ;
            propVariants[ dwSignKeyIndex ].blob.cbSize = dwKeySize ;
        }
        else
        {
            propVariants[ dwSignKeyIndex ].blob.pBlobData = NULL ;
            propVariants[ dwSignKeyIndex ].blob.cbSize = 0 ;
        }
    }

    if (propVariants[ dwExchKeyIndex ].blob.pBlobData)
    {
        //
        // Extract msmq1.0 public key from Windows 2000 ADS blob.
        //
        BYTE *pExchKey = NULL ;
        DWORD dwKeySize = 0 ;
        pPublicExchKeys = (MQDSPUBLICKEYS *)
                       propVariants[ dwExchKeyIndex ].blob.pBlobData ;

        HRESULT hr1 =  MQSec_UnpackPublicKey(
                                     pPublicExchKeys,
                                     x_MQ_Encryption_Provider_40,
                                     x_MQ_Encryption_Provider_Type_40,
                                    &pExchKey,
                                    &dwKeySize ) ;
        
        if (SUCCEEDED(hr1))
        {
            ASSERT(pExchKey && dwKeySize) ;
            propVariants[ dwExchKeyIndex ].blob.pBlobData = pExchKey ;
            propVariants[ dwExchKeyIndex ].blob.cbSize = dwKeySize ;
        }
        else
        {
            propVariants[ dwExchKeyIndex ].blob.pBlobData = NULL ;
            propVariants[ dwExchKeyIndex ].blob.cbSize = 0 ;
        }
    }

    //
    // prepare columns
    //
    #define     COL_NUM  26
    MQDBCOLUMNVAL aColumnVal[COL_NUM];
    LONG cColumns =0;

    //
    // prepare name columns
    //
    #define NAME_COL_NUM	2
    MQDBCOLUMNVAL NameColumn[NAME_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_NAME1_COL, 0, M_NAME1_CLEN, M_NAME1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_NAME2_COL, 0, M_NAME2_CLEN, M_NAME2_CTYPE, 0}		
    } ;		
	    
    _PrepareMultipleColumns (
            NAME_COL_NUM,
            (unsigned char *)pszLocalComputerName,
            (1 + lstrlen(pszLocalComputerName))* sizeof(TCHAR),
            NameColumn
            );
    for (ULONG i=0; i<NAME_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= NameColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = NameColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= NameColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= NameColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = NameColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= NameColumn[i].dwReserve_A ;
        cColumns++ ;
    }

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_SITE_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (propVariants[ dwSiteIdIndex ].puuid) ;
    aColumnVal[cColumns].nColumnLength	= M_SITE_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_SITE_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_OWNERID_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (&g_MySiteGuid) ;
    aColumnVal[cColumns].nColumnLength	= M_OWNERID_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_OWNERID_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_QMID_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (&g_MyMachineGuid) ;
    aColumnVal[cColumns].nColumnLength	= M_QMID_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_QMID_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_SEQNUM_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (&s_snMax) ;
    aColumnVal[cColumns].nColumnLength	= M_SEQNUM_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_SEQNUM_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    //
    // prepare OutFRS columns
    //
    GUID guidNull = GUID_NULL;
    #define OUTFRS_COL_NUM 3
    MQDBCOLUMNVAL OutFRSColumn[OUTFRS_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_OUTFRS1_COL, long (&guidNull), M_OUTFRS1_CLEN, M_OUTFRS1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_OUTFRS2_COL, long (&guidNull), M_OUTFRS2_CLEN, M_OUTFRS2_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_OUTFRS3_COL, long (&guidNull), M_OUTFRS3_CLEN, M_OUTFRS3_CTYPE, 0}
    } ;	

    for (i=0; i<OUTFRS_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= OutFRSColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = OutFRSColumn[i].lpszColumnName ;         
        aColumnVal[cColumns].nColumnValue	= OutFRSColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= OutFRSColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = OutFRSColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= OutFRSColumn[i].dwReserve_A ;        
        cColumns++ ;
    }

    //
    // prepare InFRS columns
    //
    #define INFRS_COL_NUM 3
    MQDBCOLUMNVAL InFRSColumn[INFRS_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_INFRS1_COL, long (&guidNull), M_INFRS1_CLEN, M_INFRS1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_INFRS2_COL, long (&guidNull), M_INFRS2_CLEN, M_INFRS2_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_INFRS3_COL, long (&guidNull), M_INFRS3_CLEN, M_INFRS3_CTYPE, 0}
    } ;

    for (i=0; i<INFRS_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= InFRSColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = InFRSColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= InFRSColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= InFRSColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = InFRSColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= InFRSColumn[i].dwReserve_A ;        
        cColumns++ ;
    }

    //
    // prepare sign crpt columns
    //
    #define SIGNCRT_COL_NUM	2
    MQDBCOLUMNVAL SignCrtColumn[SIGNCRT_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_SIGNCRT1_COL, 0, M_SIGNCRT1_CLEN, M_SIGNCRT1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_SIGNCRT2_COL, 0, M_SIGNCRT2_CLEN, M_SIGNCRT2_CTYPE, 0}		
    } ;		
	    
    _PrepareMultipleColumns (
            SIGNCRT_COL_NUM,
            propVariants[ dwSignKeyIndex ].blob.pBlobData,
            propVariants[ dwSignKeyIndex ].blob.cbSize,
            SignCrtColumn
            );
    for (i=0; i<SIGNCRT_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= SignCrtColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = SignCrtColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= SignCrtColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= SignCrtColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = SignCrtColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= SignCrtColumn[i].dwReserve_A ;
        cColumns++ ;
    }

    //
    // prepare encrpt columns
    //
    #define ENCRPTCRT_COL_NUM	2
    MQDBCOLUMNVAL EncrptCrtColumn[ENCRPTCRT_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_ENCRPTCRT1_COL, 0, M_ENCRPTCRT1_CLEN, M_ENCRPTCRT1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_ENCRPTCRT2_COL, 0, M_ENCRPTCRT2_CLEN, M_ENCRPTCRT2_CTYPE, 0}		
    } ;		
	    
    _PrepareMultipleColumns (
            ENCRPTCRT_COL_NUM,
            propVariants[ dwExchKeyIndex ].blob.pBlobData,
            propVariants[ dwExchKeyIndex ].blob.cbSize,
            EncrptCrtColumn
            );
    for (i=0; i<ENCRPTCRT_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= EncrptCrtColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = EncrptCrtColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= EncrptCrtColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= EncrptCrtColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = EncrptCrtColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= EncrptCrtColumn[i].dwReserve_A ;
        cColumns++ ;
    }	

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_SERVICES_COL ; 
    aColumnVal[cColumns].nColumnValue	= propVariants[ dwServiceIndex ].ulVal ;
    aColumnVal[cColumns].nColumnLength	= M_SERVICES_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_SERVICES_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;	

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_HKEY_COL ; 
    aColumnVal[cColumns].nColumnValue	= CalHashKey( pszLocalComputerName ) ; ;
    aColumnVal[cColumns].nColumnLength	= M_HKEY_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_HKEY_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;	
	    
    //
    // prepare security columns
    //
    #define SECURITY_COL_NUM	3
    MQDBCOLUMNVAL SecurityColumn[SECURITY_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_SECURITY1_COL, 0, M_SECURITY1_CLEN, M_SECURITY1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_SECURITY2_COL, 0, M_SECURITY2_CLEN, M_SECURITY2_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_SECURITY3_COL, 0, M_SECURITY3_CLEN, M_SECURITY3_CTYPE, 0}
    } ;		
	    
    _PrepareMultipleColumns (
            SECURITY_COL_NUM,
            propVariants[ dwSecurityIndex ].blob.pBlobData,
            propVariants[ dwSecurityIndex ].blob.cbSize,
            SecurityColumn
            );

    for (i=0; i<SECURITY_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= SecurityColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = SecurityColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= SecurityColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= SecurityColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = SecurityColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= SecurityColumn[i].dwReserve_A ;
        cColumns++ ;
    }

    ASSERT (cColumns <= COL_NUM);
    //
    // insert records
    //
    hr = MQDBInsertRecord(
             g_hMachineTable,
             aColumnVal,
             cColumns,
             NULL
             ) ;

    if (FAILED(hr))
    {
        //
        // maybe this record was created at the previous time
        // it is OK
        //
        
    }

    if (propVariants[ dwSecurityIndex ].blob.pBlobData)
    {
        delete propVariants[ dwSecurityIndex ].blob.pBlobData ;
    }
    if (propVariants[ dwSiteIdIndex ].puuid)
    {
        delete propVariants[ dwSiteIdIndex ].puuid ;
    }    
    
    for (i=0; i<SECURITY_COL_NUM; i++)
    {
        MQDBFreeBuf((void*) SecurityColumn[i].nColumnValue) ;
    }
    for (i=0; i<ENCRPTCRT_COL_NUM; i++)
    {		
        MQDBFreeBuf((void*) EncrptCrtColumn[i].nColumnValue) ;
    }
    for (i=0; i<SIGNCRT_COL_NUM; i++)
    {
        MQDBFreeBuf((void*) SignCrtColumn[i].nColumnValue) ;
    }
    for (i=0; i<NAME_COL_NUM; i++)
    {
        MQDBFreeBuf((void*) NameColumn[i].nColumnValue) ;
    }

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT    ChangeRemoteMQIS()
//  We have to change PEC name and other properties on all PSC and PEC's BSCs.
//
//--------------------------------------------------

HRESULT ChangeRemoteMQIS ()
{
    HRESULT hr = MQMig_OK;

    TCHAR *pszFileName = GetIniFileName ();
    ULONG ulServerNum = GetPrivateProfileInt(
                                MIGRATION_ALLSERVERSNUM_SECTION,	// address of section name
                                MIGRATION_ALLSERVERSNUM_KEY,      // address of key name
                                0,							    // return value if key name is not found
                                pszFileName					    // address of initialization filename);
                                );

    if (ulServerNum == 0)
    {
        return MQMig_OK;
    }

    //
    // get local computer name
    //
    WCHAR wszComputerName[ MAX_COMPUTERNAME_LENGTH + 2 ] ;
    DWORD dwSize = sizeof(wszComputerName) / sizeof(wszComputerName[0]) ;
    GetComputerName( wszComputerName,
                     &dwSize ) ;
    CharLower( wszComputerName);	//we save names in database in lower case


    HRESULT hr1 = MQMig_OK;
    BOOL f;

    //
    // for each server in .ini file change 
    // - PEC name to local computer name
    // - service of former PEC to SERVICE_SRV
    // - PSC name in former PEC's site to local computer name
    // - add local machine to machine table
    //
    ULONG ulNonUpdatedServers = 0;
    
    for (ULONG i=0; i<ulServerNum; i++)
    {
        TCHAR szCurServerName[MAX_PATH];
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_ALLSERVERS_NAME_KEY, i+1);
        DWORD dwRetSize =  GetPrivateProfileString(
                                    MIGRATION_ALLSERVERS_SECTION ,			// points to section name
                                    tszKeyName,	// points to key name
                                    TEXT(""),                 // points to default string
                                    szCurServerName,          // points to destination buffer
                                    MAX_PATH,                 // size of destination buffer
                                    pszFileName               // points to initialization filename);
                                    );
        if (_tcscmp(szCurServerName, TEXT("")) == 0 ||  
            dwRetSize == 0)     //low resources
        {
            //
            // we cannot get server name: either low resources
            // or there is no this section. It means that server from
            // this section was updated at the previous time
            //
            continue;
        }

        //
        // connect to database on server with the name szCurServerName
        //
        CleanupDatabase();
        MQDBCloseDatabase (g_hDatabase);
        g_hDatabase = NULL;

        char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
        ConvertToMultiByteString(szCurServerName,
                                 szDSNServerName,
			         (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
        lstrcpy(szDSNServerName, szCurServerName) ;
#endif		
        hr = MakeMQISDsn(szDSNServerName, TRUE) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szCurServerName, hr) ;
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;	
            ulNonUpdatedServers++;
            continue;			
        }

        hr =  ConnectToDatabase(TRUE) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szCurServerName, hr) ;
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;	
            ulNonUpdatedServers++;
            continue;
        }        

        //
        // update remote database tables
        //
        hr = _UpdateEnterpriseTable(wszComputerName);		
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        hr = _UpdateMachineTable();
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;			
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        //
        // in general we need to do it only for BSCs of PEC
        //
        hr = _UpdateSiteTable(wszComputerName);
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;			
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        hr = _AddThisMachine(wszComputerName);
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;			
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        //
        // remove this key from .ini
        //
        f = WritePrivateProfileString( 
                    MIGRATION_ALLSERVERS_SECTION,
                    tszKeyName,
                    NULL,
                    pszFileName ) ;        
    }

    if (ulNonUpdatedServers)
    {
        //
        // save number of all non-updated MQIS servers in .ini
        //
        TCHAR szBuf[10];
        _ltot( ulNonUpdatedServers, szBuf, 10 );
        f = WritePrivateProfileString( MIGRATION_NONUPDATED_SERVERNUM_SECTION,
                                       MIGRATION_ALLSERVERSNUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
        ASSERT(f) ;
    }
    else
    {
        //
        // we are here if all MQIS servers were updated successfully
        //
        f = WritePrivateProfileString( 
                            MIGRATION_ALLSERVERS_SECTION,
                            NULL,
                            NULL,
                            pszFileName ) ;
        ASSERT(f) ;

        f = WritePrivateProfileString( 
                            MIGRATION_ALLSERVERSNUM_SECTION,
                            NULL,
                            NULL,
                            pszFileName ) ;
        ASSERT(f) ;

        f = WritePrivateProfileString( 
                            MIGRATION_NONUPDATED_SERVERNUM_SECTION,
                            NULL,
                            NULL,
                            pszFileName ) ;
        ASSERT(f) ;
    }

    if (FAILED(hr1))
    {
        return hr1;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmig\thrmig.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    thrmig.cpp

Abstract:

    thread to run migration code (in mqmigrat.dll)

Author:

    Erez Vizel

--*/

#include "stdafx.h"
#include "loadmig.h"
#include "sThrPrm.h"
#include "mqsymbls.h"

#include "thrmig.tmh"

extern HRESULT   g_hrResultMigration ;

extern UINT _FINISH_PAGE;
extern UINT _SERVICE_PAGE;

//+-----------------------------------------
//
//  UINT RunMigrationThread(LPVOID lpV)
//
//+-----------------------------------------

UINT __cdecl RunMigrationThread(LPVOID lpV)
{
    sThreadParm* pVar = (sThreadParm*)(lpV);
	//
    //  Reseting the progress bars
    //	
    (pVar->pSiteProgress)->SetPos(0);
	(pVar->pQueueProgress)->SetPos(0);
	(pVar->pMachineProgress)->SetPos(0);
	(pVar->pUserProgress)->SetPos(0);

    g_hrResultMigration = RunMigration() ;

    if (g_hrResultMigration == MQMig_E_QUIT)
    {
        ExitProcess(0) ;
    }

    //
    // Activate the ServiceAccount or Finish page.
    //
    if (g_fIsPEC &&         //this machine is PEC
        !g_fIsOneServer &&  //there is more than one MQIS server in Enterprise
        SUCCEEDED(g_hrResultMigration) )    //migration process succeeded
    {
        pVar->iPageNumber = _SERVICE_PAGE;
    }
    else
    {
        pVar->iPageNumber = _FINISH_PAGE;
    }

    UINT i=( (pVar->pPageFather)->SetActivePage(pVar->iPageNumber));
    UNREFERENCED_PARAMETER(i);

	delete lpV ;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\exstub.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    exstub.cpp

Abstract:
    Ex stub function

Author:
    Ilan Herbst (ilanh) 19-July-2000

Environment:
    Platform-independent,

--*/

#include "migrat.h"
#include "mqmacro.h"
#include "ex.h"

#include "exstub.tmh"

VOID                             
ExSetTimer(
    CTimer* /*pTimer*/,
    const CTimeDuration& /*Timeout*/
    )
{
    ASSERT(("MQMIGRAT dont suppose to call ExSetTimer", 0));
    return;
}


BOOL
ExCancelTimer(
    CTimer* /*pTimer*/
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\makedsn.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    makedsn.cpp

Abstract:

    Configure ODBC manager related code.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

//#ifdef UNICODE
//
// ODBC is ANSI
//
#undef   UNICODE
#undef  _UNICODE
#define _MBCS
//#endif

#define STRICT 1
#include <windows.h>

#define __FALCON_STDH_H
#define _NO_SEQNUM_
#define _NO_NT5DS_
#include "migrat.h"

#include <odbcinst.h>

#include "makedsn.tmh"

//
// ODBC data source parameters for the SQL Server database
//
const char MQIS_DSN_STRING[] = { "DSN=" DSN_NAME "\0"
                                 "Database=MQIS\0"
                                 "UseProcForPrepare=Yes\0"
                                 "Description=Remote MQIS database\0" } ;

#define MQIS_SERVER_STRING      "Server=%s"


HRESULT  MakeMQISDsn(LPSTR lpszServerName, BOOL fMakeAlways)
{
    HRESULT hr = MQMig_OK ;
    static BOOL s_fMakeDsn = FALSE ;
    if (s_fMakeDsn && !fMakeAlways)
    {
        return MQMig_OK ;
    }
   
    //
    // Load ODBCCP32.DLL, the ODBC control panel library
    //
    HINSTANCE hODBCCP32DLL = LoadLibrary(TEXT("ODBCCP32.DLL"));
    if (hODBCCP32DLL == NULL)
    {
        hr = MQMig_E_CANT_LOAD_ODBCCP ;
        LogMigrationEvent( MigLog_Error,
                           hr,
                           GetLastError()) ;
        return hr ;
    }

    //
    // Obtain a pointer to the data source configuration function
    //
    typedef HRESULT (APIENTRY *FUNCSQLCONFIGDATASOURCE)
                                        (HWND, WORD, LPCSTR, LPCSTR);
    FUNCSQLCONFIGDATASOURCE pfSQLConfigDataSource =
        (FUNCSQLCONFIGDATASOURCE)GetProcAddress(hODBCCP32DLL,
                                                "SQLConfigDataSource");
    if (pfSQLConfigDataSource == NULL)
    {
        hr = MQMig_E_CANT_GETADRS_ODBCCP ;
        LogMigrationEvent( MigLog_Error,
                           hr,
                           GetLastError()) ;
        return hr ;
    }

    //
    // Create the ODBC data source for the SQL Server database; if unable to
    // add the data source, try configuring it, in case it already exists
    //
    char szDSNServer[ 512 ] ;
    sprintf(szDSNServer, MQIS_SERVER_STRING, lpszServerName) ;

    char szDSNString[ 1024 ] ;
    DWORD dwSize = sizeof(MQIS_DSN_STRING) ;
    memcpy( szDSNString, MQIS_DSN_STRING, dwSize) ;
    //_tcscpy(&szDSNString[ dwSize-1 ], szDSNServer) ;
    //dwSize += _tcslen(szDSNServer) ;
    strcpy(&szDSNString[ dwSize-1 ], szDSNServer) ;
    dwSize += strlen(szDSNServer) ;

    szDSNString[dwSize] = '\0' ;
    szDSNString[dwSize+1] = '\0' ;

    if (!pfSQLConfigDataSource(NULL, ODBC_ADD_SYS_DSN,
                               "SQL Server", szDSNString) &&
        !pfSQLConfigDataSource(NULL, ODBC_CONFIG_SYS_DSN,
                               "SQL Server", szDSNString))
    {
        hr = MQMig_E_CANT_CREATE_DSN ;
        LogMigrationEvent( MigLog_Error,
                           hr ) ;
        return hr ;
    }

    //
    // Free the ODBC control panel library
    //
    FreeLibrary(hODBCCP32DLL);

    s_fMakeDsn = TRUE;

    return MQMig_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\machutil.cpp ===
#include "migrat.h"
#include <mixmode.h>
#include <lmaccess.h>
#include "resource.h"
#include <dsproto.h>
#include <mqsec.h>

#include "machutil.tmh"

//+--------------------------------------------------------------
//
//  BOOL IsInsertPKey
//  Returns FALSE if we are run on the PEC not at the first time.
//
//+--------------------------------------------------------------

BOOL IsInsertPKey (GUID *pMachineGuid)
{
    if ( (g_dwMyService == SERVICE_PEC) &&        //migration tool run on PEC machine
         (*pMachineGuid == g_MyMachineGuid) )     //current machine is the PEC machine
    {
        //
        // We have to check if PEC machine already exist in ADS.
        // If so, don't change its public key in DS.
        //
        PROPID      PKeyProp = PROPID_QM_ENCRYPT_PK;
        PROPVARIANT PKeyVar;
        PKeyVar.vt = VT_NULL ;
        PKeyVar.blob.cbSize = 0 ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                          e_ALL_PROTOCOLS);

        HRESULT hr = DSCoreGetProps( MQDS_MACHINE,
                                     NULL,  // path name
                                     pMachineGuid,
                                     1,
                                     &PKeyProp,
                                     &requestContext,
                                     &PKeyVar);
        if (SUCCEEDED(hr))
        {            
            delete PKeyVar.blob.pBlobData;
            return FALSE;
        }
    }    
    return TRUE;
}

//+--------------------------------------------------------------
//
//  HRESULT GetFRSs
//  Returns array of Out or In FRSs
//
//+--------------------------------------------------------------

HRESULT GetFRSs (IN MQDBCOLUMNVAL    *pColumns,
                 IN UINT             uiFirstIndex,
                 OUT UINT            *puiFRSCount, 
                 OUT GUID            **ppguidFRS )
{       
    GUID guidNull = GUID_NULL;
    GUID *pFRSs = new GUID[ 3 ] ;                           

    *puiFRSCount = 0;    

    for (UINT iCount=0; iCount < 3; iCount++)
    {        
        GUID *pGuid = (GUID*) pColumns[ uiFirstIndex + iCount ].nColumnValue;
        if (memcmp(pGuid, &guidNull, sizeof(GUID)) != 0)
        {
            memcpy (&pFRSs[*puiFRSCount],
                    pGuid,
                    sizeof(GUID));
            (*puiFRSCount) ++;
        }
    }

    if (*puiFRSCount)
    {
        *ppguidFRS = pFRSs ; 
    }
        
    return MQMig_OK;
}

//+----------------------------------
//
//  HRESULT  PreparePBKeysForNT5DS
//  Returns size and value of machine public keys
//
//+----------------------------------

HRESULT PreparePBKeysForNT5DS( 
                   IN MQDBCOLUMNVAL *pColumns,
                   IN UINT           iIndex1,
                   IN UINT           iIndex2,
                   OUT ULONG         *pulSize,
                   OUT BYTE          **ppPKey
                   )
{
    P<BYTE> pBuf = NULL ;
    DWORD  dwIndexs[2] = { iIndex1, iIndex2 } ;
    HRESULT hr =  BlobFromColumns( pColumns,
                                   dwIndexs,
                                   2,
                                  &pBuf ) ;
    if (FAILED(hr))
    {
        ASSERT(!pBuf) ;
        return hr ;
    }

    BYTE *pTmpB = pBuf ;
    PMQDS_PublicKey pPbKey = (PMQDS_PublicKey) pTmpB ;

    P<MQDSPUBLICKEYS> pPublicKeys = NULL ;

    hr = MQSec_PackPublicKey( (BYTE*)pPbKey->abPublicKeyBlob,
                               pPbKey->dwPublikKeyBlobSize,
                               x_MQ_Encryption_Provider_40,
                               x_MQ_Encryption_Provider_Type_40,
                              &pPublicKeys ) ;
    if (FAILED(hr))
    {
       return hr ;
    }   
    
    *pulSize = 0;
    MQDSPUBLICKEYS *pTmpK = pPublicKeys ;
    BYTE *pData = NULL;

    if (pPublicKeys)
    {
        *pulSize = pPublicKeys->ulLen ;  
        pData = new BYTE[*pulSize];
        memcpy (pData, (BYTE*) pTmpK, *pulSize);
        *ppPKey = pData; 
    }   

    return hr ;
}

//+------------------------------
//
//  HRESULT  ResetSettingFlag ()
//  Touch setting attribute: either MQ_SET_NT4_ATTRIBUTE or MQ_SET_MIGRATED_ATTRIBUTE
//  The first set to 0, the second is to FALSE
//
//+------------------------------

HRESULT  ResetSettingFlag( IN DWORD   dwNumSites,
                           IN GUID*   pguidSites,
                           IN LPWSTR  wszMachineName,
                           IN WCHAR   *wszAttributeName,
                           IN WCHAR   *wszValue)
{
    HRESULT hr;

    PLDAP pLdap = NULL ;
    TCHAR *pwszDefName = NULL ;

    hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    ASSERT (dwNumSites == 1);
    for (DWORD i = 0; i<dwNumSites; i++)
    {
        //
        // get site name by guid
        //
        PROPID      SiteNameProp = PROPID_S_FULL_NAME;
        PROPVARIANT SiteNameVar;
        SiteNameVar.vt = VT_NULL;
        SiteNameVar.pwszVal = NULL ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant

        hr  = DSCoreGetProps( MQDS_SITE,
                              NULL, // pathname
                              &pguidSites[i],
                              1,
                              &SiteNameProp,
                              &requestContext,
                              &SiteNameVar ) ;
        if (FAILED(hr))
        {
            return hr;
        }

        DWORD len = wcslen(SiteNameVar.pwszVal);
        const WCHAR x_wcsCnServers[] =  L"CN=Servers,";
        const DWORD x_wcsCnServersLength = (sizeof(x_wcsCnServers)/sizeof(WCHAR)) -1;
        AP<WCHAR> pwcsServersContainer =  new WCHAR [ len + x_wcsCnServersLength + 1];
        swprintf(
             pwcsServersContainer,
             L"%s%s",
             x_wcsCnServers,
             SiteNameVar.pwszVal
             );
        delete SiteNameVar.pwszVal;

        DWORD LenSuffix = lstrlen(pwcsServersContainer);
        DWORD LenPrefix = lstrlen(wszMachineName);
        DWORD LenObject = lstrlen(x_MsmqSettingName); //MSMQ Setting
        DWORD Length =
                CN_PREFIX_LEN +                   // "CN="
                CN_PREFIX_LEN +                   // "CN="
                LenPrefix +                       // "pwcsPrefix"
                2 +                               // ",", ","
                LenSuffix +                       // "pwcsSuffix"
                LenObject +                       // "MSMQ Setting"
                1 ;                               // '\0'

        AP<unsigned short> pwcsPath = new WCHAR[Length];

        swprintf(
            pwcsPath,
            L"%s"             // "CN="
            L"%s"             // "MSMQ Setting"
            TEXT(",")
            L"%s"             // "CN="
            L"%s"             // "pwcsPrefix"
            TEXT(",")
            L"%s",            // "pwcsSuffix"
            CN_PREFIX,
            x_MsmqSettingName,
            CN_PREFIX,
            wszMachineName,
            pwcsServersContainer
            );

        hr = ModifyAttribute(
                 pwcsPath,
                 wszAttributeName, 
                 wszValue 
                 );
        if (FAILED(hr))
        {
            return hr;
        }
    }

    return MQMig_OK;
}
            
//+--------------------------------------------------------------
//
//  HRESULT GetAllMachineSites
//	For foreign machine returns all its foreign CN
//  For connector returns all real sites + all its foreign CNs
//  Otherwise returns all real sites
//
//  Currently instead of all real site we put guid of NT4 site (pOwnerId)
//
//+--------------------------------------------------------------

HRESULT GetAllMachineSites ( IN GUID    *pMachineGuid,
                             IN LPWSTR  wszMachineName,
                             IN GUID    *pOwnerGuid,
                             IN BOOL    fForeign,
                             OUT DWORD  *pdwNumSites,
                             OUT GUID   **ppguidSites,
                             OUT BOOL   *pfIsConnector) 
{    
    DWORD   dwNumCNs = 0;
    GUID    *pguidCNs = NULL ;    
    HRESULT hr = GetMachineCNs(pMachineGuid,
                               &dwNumCNs,
                               &pguidCNs ) ;

    if (fForeign)
    {     
        *pdwNumSites = dwNumCNs;          
        *ppguidSites = pguidCNs;
        return hr;
    }

    //
    // For now, ownerid is also siteid.
    // In the future, when code is ready, will look for "real site", the
    // nt5 site where machine should really be. Now just call that
    // funtion, but don't use the site it return.
    //    
    //DWORD     dwRealNumSites = 0;    	
    //AP<GUID>  pguidRealSites = NULL ;

    //hr = DSCoreGetComputerSites(wszMachineName,
    //                            &dwRealNumSites,
    //                            &pguidRealSites ) ;
    //CHECK_HR(hr) ;
    //ASSERT(dwRealNumSites); // Must be > 0

    GUID *pSites = new GUID[ dwNumCNs + 1 ] ;                     
    *ppguidSites = pSites ;   

    //
    // NT4 site is the first site in array
    //
    *pdwNumSites = 1;
    memcpy (&pSites[0], pOwnerGuid, sizeof(GUID));

    //
    // Bug 5012.
    // Find all foreign CNs in pguidCNs and add them to array of Site Ids
    //
    *pfIsConnector = FALSE;
    UINT iIndex = 0;
    TCHAR *pszFileName = GetIniFileName ();

    for (UINT i=0; i<dwNumCNs; i++)
    {
	    //
	    // look for this CN guid in .ini file in ForeignCN section		
	    //
	    if (IsObjectGuidInIniFile (&(pguidCNs[i]), MIGRATION_FOREIGN_SECTION))
	    {
            *pfIsConnector = TRUE;

            memcpy (&pSites[*pdwNumSites], &pguidCNs[i], sizeof(GUID));
            (*pdwNumSites)++;
       
            unsigned short *lpszForeignCN ;

            UuidToString( &pguidCNs[i], &lpszForeignCN ) ;                            

            //
            // save foreign cn guid in .ini to create site link later
            //         
            iIndex ++;
            TCHAR szBuf[20];
            _ltot( iIndex, szBuf, 10 );

            TCHAR tszName[50];
            _stprintf(tszName, TEXT("%s - %s"), 
                MIGRATION_CONNECTOR_FOREIGNCN_NUM_SECTION, wszMachineName);
            BOOL f = WritePrivateProfileString( tszName,
                                                MIGRATION_CONNECTOR_FOREIGNCN_NUM_KEY,
                                                szBuf,
                                                pszFileName ) ;
            ASSERT(f) ;   

            _stprintf(tszName, TEXT("%s%lu"), 
                MIGRATION_CONNECTOR_FOREIGNCN_KEY, iIndex);                
            f = WritePrivateProfileString(  wszMachineName,
                                            tszName,
                                            lpszForeignCN,
                                            pszFileName ) ;
            ASSERT(f) ; 
                                                
            RpcStringFree( &lpszForeignCN ) ;     
	    }
    }

    return hr;
}

//+-----------------------------------------------
//
//  HRESULT SaveMachineWithInvalidNameInIniFile()
//
//+-----------------------------------------------

void SaveMachineWithInvalidNameInIniFile (LPWSTR wszMachineName, GUID *pMachineGuid)
{
    TCHAR *pszFileName = GetIniFileName ();
    //
    // we save machine in the form 
    // <guid>=<machine name> in order to improve searching by GUID
    //
    unsigned short *lpszMachineId ;
	UuidToString( pMachineGuid, &lpszMachineId ) ;    
    BOOL f = WritePrivateProfileString(  
                    MIGRATION_MACHINE_WITH_INVALID_NAME,
                    lpszMachineId,
                    wszMachineName,                                        
                    pszFileName ) ;
    DBG_USED(f);
    ASSERT(f);
    RpcStringFree( &lpszMachineId );
}

//+-----------------------------------------------
//
//  HRESULT _CreateComputersObject()
//
//+-----------------------------------------------

static HRESULT _CreateComputerObject( LPWSTR wszMachineName, GUID *pMachineGuid )
{
    PLDAP pLdap = NULL ;
    TCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_COMPUTER_CREATED, wszMachineName, hr ) ;
        return hr ;
    }

    //
    // Now that container object exist, it's time to
    // create the computer object.
    //
	DWORD iComProperty =0;
    PROPID propComIDs[2] ;
    PROPVARIANT propComVariants[2] ;

    //
    // Ronit says that sam account should end with a $.
    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
    DWORD dwNetBiosNameLen = __min(wcslen( wszMachineName ), MAX_COM_SAM_ACCOUNT_LENGTH);

    AP<TCHAR> tszAccount = new TCHAR[2 + dwNetBiosNameLen];
    _tcsncpy(tszAccount, wszMachineName, dwNetBiosNameLen);
    tszAccount[dwNetBiosNameLen] = L'$';
    tszAccount[dwNetBiosNameLen + 1] = 0;

    propComIDs[iComProperty] = PROPID_COM_SAM_ACCOUNT ;
    propComVariants[iComProperty].vt = VT_LPWSTR ;
    propComVariants[iComProperty].pwszVal = tszAccount ;
    iComProperty++;

    propComIDs[iComProperty] = PROPID_COM_ACCOUNT_CONTROL ;
    propComVariants[iComProperty].vt = VT_UI4 ;
    propComVariants[iComProperty].ulVal = DEFAULT_COM_ACCOUNT_CONTROL ;
    iComProperty++;

	DWORD iComPropertyEx =0;
    PROPID propComIDsEx[1] ;
    PROPVARIANT propComVariantsEx[1] ;

    DWORD dwSize = _tcslen(pwszDefName) +
                   _tcslen(MIG_DEFAULT_COMPUTERS_CONTAINER) +
                   OU_PREFIX_LEN + 2 ;
    P<TCHAR> tszContainer = new TCHAR[ dwSize ] ;
    _tcscpy(tszContainer, OU_PREFIX) ;
    _tcscat(tszContainer, MIG_DEFAULT_COMPUTERS_CONTAINER) ;
    _tcscat(tszContainer, LDAP_COMMA) ;
    _tcscat(tszContainer, pwszDefName) ;

    propComIDsEx[iComPropertyEx] = PROPID_COM_CONTAINER ;
    propComVariantsEx[iComPropertyEx].vt = VT_LPWSTR ;
    propComVariantsEx[iComPropertyEx].pwszVal = tszContainer ;
    iComPropertyEx++;

    ASSERT( iComProperty ==
            (sizeof(propComIDs) / sizeof(propComIDs[0])) ) ;
    ASSERT( iComPropertyEx ==
            (sizeof(propComIDsEx) / sizeof(propComIDsEx[0])) ) ;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

    hr = DSCoreCreateObject( MQDS_COMPUTER,
                             wszMachineName,
                             iComProperty,
                             propComIDs,
                             propComVariants,
                             iComPropertyEx,
                             propComIDsEx,
                             propComVariantsEx,
                             &requestContext,
                             NULL,
                             NULL ) ;
    if (SUCCEEDED(hr))
    {
        LogMigrationEvent( MigLog_Info, MQMig_I_COMPUTER_CREATED, wszMachineName ) ;
    }
    else 
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_COMPUTER_CREATED, wszMachineName, hr ) ;
        if (!IsObjectNameValid(wszMachineName))
        {
            SaveMachineWithInvalidNameInIniFile (wszMachineName, pMachineGuid);           
            LogMigrationEvent(MigLog_Event, MQMig_E_INVALID_MACHINE_NAME, wszMachineName) ;
            hr = MQMig_E_INVALID_MACHINE_NAME ;
        }   
    }

    return hr ;
}

//+--------------------------------------------------------------
//
//  HRESULT CreateMachineObject
//  Create machine object and computer object if needed
//  If local machine is PSC or we are in the "web" mode try to set
//  properties at first
//
//+--------------------------------------------------------------
                             
HRESULT CreateMachineObjectInADS (
                IN DWORD    dwService,
                IN BOOL     fWasServerOnCluster,
                IN GUID     *pOwnerGuid,
                IN GUID     *pMachineGuid,
                IN LPWSTR   wszSiteName,
                IN LPWSTR   wszMachineName,
                IN DWORD    SetPropIdCount,
                IN DWORD    iProperty,
                IN PROPID   *propIDs,
                IN PROPVARIANT *propVariants
                )
{
    HRESULT hr = MQMig_OK;
    HRESULT hrSet = MQMig_OK;
    
    if (g_dwMyService == SERVICE_PSC || g_fWebMode)
    {
        //
        // We are here if the wizard run on PSC or we are in the "web" 
        // mode. We try to set properties at first.
        // If it is web mode "set" allow us to repair                   
        //      - server msmq object in ADS to resolve connector machine problem
        //      - client msmq object in ADS to resolve Out/In FRS problem
        //            
        if (memcmp(pMachineGuid, &g_MyMachineGuid, sizeof(GUID)) == 0 ||
            fWasServerOnCluster)
        {
            //
            // current machine is local server OR
            // (bug 5423) we handle machine that was PSC on cluster
            //
            // assume that server already exist in DS, we have to reset NT4Flag
            //
            hr = ResetSettingFlag(  1,                  //dwNumSites,
                                    pOwnerGuid,         //pguidSites,
                                    wszMachineName,
                                    const_cast<WCHAR*> (MQ_SET_NT4_ATTRIBUTE),
                                    L"0");
        }

        //
        // this is PSC, assume that object exist, try to set properties
        //
        if (SUCCEEDED(hr))
        {
            CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);

            hr = DSCoreSetObjectProperties (  MQDS_MACHINE,
                                              NULL,
                                              pMachineGuid,
                                              SetPropIdCount,
                                              propIDs,
                                              propVariants,
                                              &requestContext,
                                              NULL );
            if (SUCCEEDED(hr))
            {
                return MQMig_OK;
            }
            hrSet = hr;
        }
    }
   
    PROPID      propIDsSetting[3];
    PROPVARIANT propVariantsSetting[3] ;
    DWORD       iPropsSetting = 0 ;

    PROPID  *pPropIdSetting = NULL;
    PROPVARIANT *pPropVariantSetting = NULL;

    if (dwService != SERVICE_NONE)   
    {
        pPropIdSetting = propIDsSetting;
        pPropVariantSetting = propVariantsSetting; 

        //
        // for a Falcon server, prepare the PROPID_SET properties too.
        //
        ULONG ulNt4 = 1 ;
        if (memcmp(pMachineGuid, &g_MyMachineGuid, sizeof(GUID)) == 0 ||
            fWasServerOnCluster)
        {
            //
            // My machine is NT5, so reset the NT4 flag.
            // OR we handle now machine that was PEC/PSC on cluster
            //
            ulNt4 = 0 ;
        }

        propIDsSetting[ iPropsSetting ] = PROPID_SET_NT4 ;
	    propVariantsSetting[ iPropsSetting ].vt = VT_UI4 ;
        propVariantsSetting[ iPropsSetting ].ulVal = ulNt4 ;
	    iPropsSetting++;

        propIDsSetting[ iPropsSetting ] = PROPID_SET_MASTERID;
	    propVariantsSetting[ iPropsSetting ].vt = VT_CLSID;
        propVariantsSetting[ iPropsSetting ].puuid = pOwnerGuid ;
	    iPropsSetting++;

        propIDsSetting[ iPropsSetting ] = PROPID_SET_SITENAME ;
	    propVariantsSetting[ iPropsSetting ].vt = VT_LPWSTR ;
        propVariantsSetting[ iPropsSetting ].pwszVal = wszSiteName ;
	    iPropsSetting++;

	    ASSERT(iPropsSetting == 3) ;        
    }

    hr = DSCoreCreateMigratedObject( MQDS_MACHINE,
                                     wszMachineName,
                                     iProperty,
                                     propIDs,
                                     propVariants,
                                     iPropsSetting,
                                     pPropIdSetting,
                                     pPropVariantSetting,
                                     NULL,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     FALSE,
                                     NULL,
                                     NULL) ;

    if (hr == MQ_ERROR_MACHINE_NOT_FOUND ||
        hr == MQDS_OBJECT_NOT_FOUND)
    {
        hr = _CreateComputerObject( wszMachineName, pMachineGuid ) ;
        if (SUCCEEDED(hr))
        {
            //
            // Try again to create the MSMQ machine, now that the
            // DS computer object was already created.
            //
            CDSRequestContext requestContext( e_DoNotImpersonate,
                                        e_ALL_PROTOCOLS);

            hr = DSCoreCreateObject( MQDS_MACHINE,
                                     wszMachineName,
                                     iProperty,
                                     propIDs,
                                     propVariants,
                                     iPropsSetting,
                                     pPropIdSetting,
                                     pPropVariantSetting,
                                     &requestContext,
                                     NULL,
                                     NULL ) ;
        }
    }
   
    if (hr == MQ_ERROR_MACHINE_EXISTS)
    {
        //
        // it is possible if we run migtool at the second time on PEC
        // or we run it on PSC
        //
        if (FAILED(hrSet))
        {
            //
            // if Set failed with error OBJECT_NOT_FOUND create must be succeeded or 
            // at least failed with error other than MQ_ERROR_MACHINE_EXISTS.
            // So if Set failed with any error and Create failed with MQ_ERROR_MACHINE_EXISTS
            // we have to return error code from Set.
            //
            return hrSet;
        }

        hr = MQMig_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migcfgsd.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migcfgsd.cpp

Abstract:

    Set SecurityDescriptor of the cn=configuration object to let use
    "addGuid".

Author:

    Doron Juster  (DoronJ)  03-Feb-1998

--*/

#include "migrat.h"
#include <aclapi.h>
#include "..\..\mqsec\inc\permit.h"

#include "migcfgsd.tmh"

static  PACTRL_ACCESS        s_pCurrentAccessDomain = NULL;
static  PACTRL_ACCESS        s_pCurrentAccessCnfg   = NULL;

static BOOL s_fConfigurationSDChanged = FALSE ;

//+------------------------------------------
//
//  HRESULT _SetAddGuidPermission()
//
//+------------------------------------------

static  HRESULT _SetAddGuidPermission(BOOL fConfiguration)
{
    PLDAP pLdap = NULL ;
    TCHAR *wszPathDef = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &wszPathDef) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *wszPath = wszPathDef ;
    P<TCHAR> pPath = NULL ;

    if (fConfiguration)
    {
        DWORD dwSize = _tcslen(wszPathDef) + _tcslen(CN_CONFIGURATION) + 2 ;
        pPath = new WCHAR[ dwSize ] ;
        _tcscpy(pPath, CN_CONFIGURATION) ;
        _tcscat(pPath, wszPathDef) ;
        wszPath = pPath ;
    }

    WCHAR wszUser[ 512 ] ;
    DWORD dwSize = sizeof(wszUser) / sizeof(wszUser[0]) ;
    BOOL f = GetUserName(wszUser, &dwSize) ;

    DWORD dwLastErr ;
    if (!f)
    {
        hr = MQMig_E_CANT_GET_USER ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwLastErr, dwLastErr) ;
        return hr ;
    }

    WCHAR *pwszProvider = NULL ; // L"Windows NT Access Provider",

    PACTRL_ACCESS         pAccess = NULL;
    SECURITY_INFORMATION  SeInfo = DACL_SECURITY_INFORMATION;

    PACTRL_ACCESS  pCurrentAccess ;
    DWORD dwErr = GetNamedSecurityInfoEx( wszPath,
                                          SE_DS_OBJECT_ALL,
                                          SeInfo,
                                          pwszProvider,
                                          NULL,
                                          &pCurrentAccess,
                                          NULL,
                                          NULL,
                                          NULL ) ;
    if (dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_GET_SECURITYINFO ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwErr, dwErr) ;
        return hr ;
    }

    if (fConfiguration)
    {
        s_pCurrentAccessCnfg = pCurrentAccess ;
    }
    else
    {
        s_pCurrentAccessDomain = pCurrentAccess ;
    }

    //
    // Add the right to set guid.
    //
    PWSTR  pwszControlGuids[] = {L"440820ad-65b4-11d1-a3da-0000f875ae0d"} ;

    ACTRL_ACCESS_ENTRY  AccessEntry;
    //
    // Build the entry
    //
    BuildTrusteeWithName(&(AccessEntry.Trustee),
                         wszUser) ;

    AccessEntry.Access             = RIGHT_DS_READ_PROPERTY  |
                                     RIGHT_DS_WRITE_PROPERTY |
                                     RIGHT_DS_CONTROL_ACCESS ;

    AccessEntry.fAccessFlags       = ACTRL_ACCESS_ALLOWED ;
    AccessEntry.Inheritance        = OBJECT_INHERIT_ACE ; //NO_INHERITANCE ;
    AccessEntry.lpInheritProperty  = NULL;
    AccessEntry.ProvSpecificAccess = 0;

    if (g_fReadOnly)
    {
        //
        ///  Query was ok. leave.
        //
        return MQMig_OK ;
    }

    dwErr = SetEntriesInAccessList(1,
                                   &AccessEntry,
                                   GRANT_ACCESS,
                                   pwszControlGuids[0],
                                   pCurrentAccess,
                                   &pAccess);
    if(dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_SET_ENTRIES ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwErr, dwErr) ;
        return hr ;
    }

    dwErr = SetNamedSecurityInfoEx( wszPath,
                                    SE_DS_OBJECT_ALL,
                                    SeInfo,
                                    pwszProvider,
                                    pAccess,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
    LocalFree(pAccess) ;
    if (dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_SET_SECURITYINFO ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwErr, dwErr) ;
        return hr ;
    }

    LogMigrationEvent(MigLog_Trace, MQMig_I_SET_PERMISSION, wszPath) ;
    s_fConfigurationSDChanged = TRUE ;
    return MQMig_OK ;
}

//+------------------------------------------
//
//  HRESULT GrantAddGuidPermissions()
//
//+------------------------------------------

HRESULT GrantAddGuidPermissions()
{
    HRESULT hr =  _SetAddGuidPermission(FALSE) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr =  _SetAddGuidPermission(TRUE) ;
    return hr ;
}

//+----------------------------------------------
//
// HRESULT _RestorePermissionsInternal()
//
//+----------------------------------------------

static HRESULT _RestorePermissionsInternal(BOOL fConfiguration)
{
    HRESULT hr = MQMig_OK ;

    PLDAP pLdap = NULL ;
    TCHAR *wszPathDef = NULL ;

    hr =  InitLDAP(&pLdap, &wszPathDef) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *wszPath = wszPathDef ;
    P<TCHAR> pPath = NULL ;

    if (fConfiguration)
    {
        DWORD dwSize = _tcslen(wszPathDef) + _tcslen(CN_CONFIGURATION) + 2 ;
        pPath = new WCHAR[ dwSize ] ;
        _tcscpy(pPath, CN_CONFIGURATION) ;
        _tcscat(pPath, wszPathDef) ;
        wszPath = pPath ;
    }

    WCHAR *pwszProvider = NULL ; // L"Windows NT Access Provider",
    SECURITY_INFORMATION  SeInfo = DACL_SECURITY_INFORMATION;

    PACTRL_ACCESS  pCurrentAccess ;
    if (fConfiguration)
    {
        pCurrentAccess = s_pCurrentAccessCnfg ;
    }
    else
    {
        pCurrentAccess = s_pCurrentAccessDomain ;
    }

    DWORD dwErr = SetNamedSecurityInfoEx( wszPath,
                                          SE_DS_OBJECT_ALL,
                                          SeInfo,
                                          pwszProvider,
                                          pCurrentAccess,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_RSTR_SECURITYINFO ;
        DWORD dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, wszPath, dwErr, dwErr) ;
        return hr ;
    }

    LogMigrationEvent(MigLog_Trace, MQMig_I_RESTORE_PERMISSION, wszPath) ;
    return hr ;
}

//+------------------------------------
//
//  HRESULT RestorePermissions()
//
//+------------------------------------

HRESULT RestorePermissions()
{
    if (!s_fConfigurationSDChanged)
    {
        return MQMig_OK ;
    }

    HRESULT hr = _RestorePermissionsInternal(FALSE) ;
    hr = _RestorePermissionsInternal(TRUE) ;

    //
    // Free memory.
    //
    if (s_pCurrentAccessDomain)
    {
        LocalFree(s_pCurrentAccessDomain) ;
        s_pCurrentAccessDomain = NULL ;
    }
    if (s_pCurrentAccessCnfg)
    {
        LocalFree(s_pCurrentAccessCnfg) ;
        s_pCurrentAccessCnfg = NULL ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migdebug.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migdebug.cpp

Abstract:

    Code for debugging the migration tool.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "migdebug.tmh"

//+------------------------------------
//
//  UINT  ReadDebugIntFlag()
//
//+------------------------------------

UINT  ReadDebugIntFlag(WCHAR *pwcsDebugFlag, UINT iDefault)
{
    static BOOL   s_fInitialized = FALSE ;
    static TCHAR  s_szIniName[ MAX_PATH ] = {TEXT('\0')} ;

    if (!s_fInitialized)
    {
        DWORD dw = GetModuleFileName( NULL,
                                      s_szIniName,
                       (sizeof(s_szIniName) / sizeof(s_szIniName[0]))) ;
        if (dw != 0)
        {
            TCHAR *p = _tcsrchr(s_szIniName, TEXT('\\')) ;
            if (p)
            {
                p++ ;
                _tcscpy(p, TEXT("migtool.ini")) ;
            }
        }
        s_fInitialized = TRUE ;
    }

    UINT uiDbg = GetPrivateProfileInt( TEXT("Debug"),
                                       pwcsDebugFlag,
                                       iDefault,
                                       s_szIniName ) ;
    return uiDbg ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migcns.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migcns.cpp

Abstract:

    Migration NT4 CN objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include <_ta.h>

#include "migcns.tmh"

#define INIT_CNS_COLUMN(_ColName, _ColIndex, _Index)                \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

//+----------------------------------------
//
//  HRESULT  GetMachineCNs()
//
//  Get all the CNs of a machine.
//
//+----------------------------------------

HRESULT  GetMachineCNs(IN  GUID   *pMachineGuid,
                       OUT DWORD  *pdwNumofCNs,
                       OUT GUID   **ppCNGuids )
{
    HRESULT hr = OpenMachineCNsTable() ;
    CHECK_HR(hr) ;

    //
    // First, get number of records we need to retrieve.
    //
    LONG cColumns = 0 ;
    MQDBCOLUMNSEARCH ColSearch[1] ;

    INIT_COLUMNSEARCH(ColSearch[ cColumns ]) ;
    ColSearch[ cColumns ].mqdbColumnVal.lpszColumnName = MCN_QMID_COL ;
    ColSearch[ cColumns ].mqdbColumnVal.mqdbColumnType = MCN_QMID_CTYPE ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnValue = (LONG) pMachineGuid ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[ cColumns ].mqdbOp = EQ ;
    cColumns++ ;

    hr = MQDBGetTableCount( g_hMachineCNsTable,
                            (UINT*) pdwNumofCNs,
                            ColSearch,
                            cColumns ) ;
    CHECK_HR(hr) ;
    if (*pdwNumofCNs == 0)
    {
        ASSERT(*pdwNumofCNs > 0) ;
        return MQMig_E_NO_FOREIGN_CNS ;
    }

    //
    // Next, fetch all these CNs.
    //
    GUID *pCNs = new GUID[ *pdwNumofCNs ] ;    
    *ppCNGuids = pCNs;

    cColumns = 0 ;
	LONG cAlloc = 1 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_CNS_COLUMN(MCN_CNVAL,  iCNValIndex,	 cColumns) ;
    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hMachineCNsTable,
                                       pColumns,
                                       cColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    while(SUCCEEDED(status))
    {
        if (iIndex >= *pdwNumofCNs)
        {
            status = MQMig_E_TOO_MANY_MCNS ;
            break ;
        }

        memcpy( &pCNs[ iIndex ], 
                (void*) pColumns[ iCNValIndex ].nColumnValue,
                sizeof(GUID) ) ;

        for ( LONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MCNS_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != *pdwNumofCNs)
    {
        //
        // Mismatch in number of CNs records.
        //
        hr = MQMig_E_FEWER_MCNS ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, *pdwNumofCNs) ;
        return hr ;
    }
    return MQMig_OK ;
}

//-----------------------------------------
//
//  HRESULT _MigrateACN()
//
//-----------------------------------------

static HRESULT _MigrateACN (
			WCHAR   *wcsCNName,
			GUID    *pCNGuid,
			UINT	uiProtocolId,
			UINT    iIndex
			)
{
    DBG_USED(iIndex);
    static DWORD  s_dwForeignSiteNumber = 0  ;

    HRESULT hr = MQMig_OK ;
    BOOL  fForeign = FALSE ;
    unsigned short *lpszGuid ;

#ifdef _DEBUG
    UuidToString( pCNGuid, &lpszGuid ) ;
	
    LogMigrationEvent(MigLog_Info, MQMig_I_CN_INFO,
							iIndex,
                            wcsCNName,
							lpszGuid,
							uiProtocolId
							) ;

    RpcStringFree( &lpszGuid ) ;	
#endif

    if (g_fReadOnly)
    {
        //
        // Read-Only mode.
        //
        return MQMig_OK ;
    }

    TCHAR *pszFileName = GetIniFileName ();

    static ULONG s_ulIpCount = 0;
    static ULONG s_ulIpxCount = 0;
    static ULONG s_ulForeignCount = 0;

    UuidToString( pCNGuid, &lpszGuid ) ;

    TCHAR tszCNSectionName[50];
    TCHAR tszNumSectionName[50];
    ULONG ulCurNum;

    switch (uiProtocolId)
    {
        case IP_ADDRESS_TYPE:
		case IP_RAS_ADDRESS_TYPE:
			_tcscpy(tszCNSectionName, MIGRATION_IP_SECTION);
            _tcscpy(tszNumSectionName, MIGRATION_IP_CNNUM_SECTION);
			s_ulIpCount++;
            ulCurNum = s_ulIpCount;
			break;

		case IPX_ADDRESS_TYPE:
		case IPX_RAS_ADDRESS_TYPE:
			_tcscpy(tszCNSectionName, MIGRATION_IPX_SECTION);
            _tcscpy(tszNumSectionName, MIGRATION_IPX_CNNUM_SECTION);
			s_ulIpxCount++;
            ulCurNum = s_ulIpxCount;
			break;

		case FOREIGN_ADDRESS_TYPE:
            fForeign = TRUE ;
			_tcscpy(tszCNSectionName, MIGRATION_FOREIGN_SECTION);
            _tcscpy(tszNumSectionName, MIGRATION_FOREIGN_CNNUM_SECTION);
			s_ulForeignCount++;
            ulCurNum = s_ulForeignCount;
			break;

		default:
			ASSERT(0) ;
			return MQMig_E_CNS_SQL_FAIL;		
    }

    TCHAR tszKeyName[50];
    _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_CN_KEY, ulCurNum);
    
    TCHAR szBuf[20];
    _ltot( ulCurNum, szBuf, 10 );
    BOOL f = WritePrivateProfileString( tszNumSectionName,
                                        MIGRATION_CNNUM_KEY,
                                        szBuf,
                                        pszFileName ) ;
    ASSERT(f) ;   

    if (!fForeign)
    {
        f = WritePrivateProfileString(  tszCNSectionName,
                                        tszKeyName,
                                        lpszGuid,
                                        pszFileName ) ;
        ASSERT(f) ;                 	
    }
    else
    {        
        //
        // if cn is foreign we save it in the form 
        // <guid>=CN<number> in order to improve searching by GUID
        //
        f = WritePrivateProfileString(  tszCNSectionName,
                                        lpszGuid,
                                        tszKeyName,                                        
                                        pszFileName ) ;
        ASSERT(f) ;        

        if (g_dwMyService == SERVICE_PEC)
        {
            //
            // Bug 5012.
            // Create foreign site only if this machine is PEC.
            //
            hr = CreateSite( pCNGuid, wcsCNName, TRUE ) ;
            if (SUCCEEDED(hr))
            {
                LogMigrationEvent( MigLog_Trace,
                                   MQMig_I_FOREIGN_SITE,
                                   wcsCNName ) ;
            }
            else
            {
                LogMigrationEvent( MigLog_Error,
                                   MQMig_E_FOREIGN_SITE,
                                   wcsCNName, hr ) ;
            }
        }
    }
    RpcStringFree( &lpszGuid ) ;

    return hr ;
}

//-------------------------------------------
//
//  HRESULT MigrateCNs()
//
//  CNs are not really migrated. What we're doing is to record all CNs
//  in the ini file. that is needed for replication of machine objects from
//  NT5 to NT4. Because we don't keep CN data in the Nt5 DS, we assign
//  all CNs to each machine address when replicating the machine to NT4
//  world. That may make routing on the nt4 side less efficient.
//  As a side effect, when encounting a foreign CN, we create a foreign
//  site which has its GUID.
//
//-------------------------------------------

HRESULT MigrateCNs()
{
    HRESULT hr = OpenCNsTable() ;
    CHECK_HR(hr) ;

    ULONG cColumns = 0 ;
	ULONG cAlloc = 3 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_CNS_COLUMN(CN_NAME,		iNameIndex,		cColumns) ;
	INIT_CNS_COLUMN(CN_VAL,			iGuidIndex,		cColumns) ;
	INIT_CNS_COLUMN(CN_PROTOCOLID,	iProtocolIndex, cColumns);
	
    ASSERT(cColumns == cAlloc);

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hCNsTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
	if (status == MQDB_E_NO_MORE_DATA)
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_NO_CNS) ;
        return MQMig_E_NO_CNS ;
    }
    CHECK_HR(status) ;

    UINT iIndex = 0 ;

    while(SUCCEEDED(status))
    {
        //
        // Migrate each CN
		//
		status = _MigrateACN (
					(WCHAR *) pColumns[ iNameIndex ].nColumnValue,		//cn name
					(GUID *) pColumns[ iGuidIndex ].nColumnValue,		//cn guid						
					(UINT) pColumns[ iProtocolIndex ].nColumnValue,
					iIndex
					);

        for ( ULONG i = 0 ; i < cColumns; i++ )
        {		
			if (i != iProtocolIndex)
			{
				MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
			}
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
		CHECK_HR(status) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_CNS_SQL_FAIL, status) ;
        return status ;
    }

    return MQMig_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migent.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migent.cpp

Abstract:

    Migration NT4 Enterprise objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include "resource.h"
#include "dsreqinf.h"

#include "migent.tmh"

#define SITELINK_PROP_NUM  7

//+-------------------------------------------------------------------------
//
//  HRESULT SaveSiteLink()
//
//	If we are going to delete Enterprise Object we have to save before
//	all site links those were created in Windows2000 Enterprise.
//	It allows us to mix two enterprises correctly.
//	When we'll create new Enterprise Object with NT4 guid, we'll restore 
//	all site links.
//
//+-------------------------------------------------------------------------

HRESULT SaveSiteLink ()
{
	HRESULT hr = MQMig_OK;

    //
    // Lookup the Neighbors Id and Gates of the object Site Link
    //
	PROPID columnsetPropertyIDs[SITELINK_PROP_NUM]; 

	DWORD dwCount = 0;	
	columnsetPropertyIDs[dwCount] = PROPID_L_NEIGHBOR1;
	DWORD dwNeighbor1Id = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_NEIGHBOR2;
	DWORD dwNeighbor2Id = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_GATES_DN;
	DWORD dwGates = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_FULL_PATH;
	DWORD dwFullPath = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_COST;
	DWORD dwCost = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_DESCRIPTION;
	DWORD dwDescription = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_ID ;
	DWORD dwId = dwCount;
	dwCount ++;

	ASSERT (dwCount == SITELINK_PROP_NUM);

    MQCOLUMNSET columnsetSiteLink;
    columnsetSiteLink.cCol = SITELINK_PROP_NUM;
    columnsetSiteLink.aCol = columnsetPropertyIDs;

    HANDLE hQuery;    
	
	hr = LookupBegin(&columnsetSiteLink, &hQuery);
	if (FAILED(hr))
	{
		LogMigrationEvent(	MigLog_Error, 
							MQMig_E_SITELINK_LOOKUPBEGIN_FAILED, 
							hr) ;
		return hr;
	}	
	
	PROPVARIANT paVariant[SITELINK_PROP_NUM];
	ULONG ulSiteLinkCount = 0;

	TCHAR *pszFileName = GetIniFileName ();

	TCHAR szBuf[20];
	BOOL f;
	HRESULT hr1 = MQMig_OK;	

	while (SUCCEEDED(hr))
    {
		hr = LookupNext( hQuery,
		                 &dwCount,
                         paVariant ) ;
		if (FAILED(hr))		
		{
			LogMigrationEvent(	MigLog_Error, 
								MQMig_E_SITELINK_LOOKUPNEXT_FAILED, 
								hr) ;
			break;
		}

		if (dwCount == 0)
		{
			//there is no result
			break;
		}
		
		ulSiteLinkCount ++;
		TCHAR tszSectionName[50];
		_stprintf(tszSectionName, TEXT("%s%lu"), MIGRATION_SITELINK_SECTION, ulSiteLinkCount);
				
		//
		//	Save all properties in .ini
		//
		//	Save Neighbor1 ID
		//		
		unsigned short *lpszGuid ;
		UuidToString( paVariant[dwNeighbor1Id].puuid, &lpszGuid ) ;				
				
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_NEIGHBOR1_KEY,
                                       lpszGuid,
                                       pszFileName ) ;
		ASSERT(f);

		RpcStringFree( &lpszGuid ) ;
		delete paVariant[dwNeighbor1Id].puuid;		
					
		//
		//	Save Neighbor2 ID
		//		
		UuidToString( paVariant[dwNeighbor2Id].puuid, &lpszGuid ) ;				
				
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_NEIGHBOR2_KEY,
                                       lpszGuid,
                                       pszFileName ) ;
		ASSERT(f);

		RpcStringFree( &lpszGuid ) ;
		delete paVariant[dwNeighbor2Id].puuid;		

		//
		//	Save cost
		//		
		if (paVariant[dwCost].ulVal > MQ_MAX_LINK_COST)
		{
			//
			// if one of the neighbors is foreign site, LookupNext returns
			// cost = real cost + MQ_MAX_LINK_COST
			// We have to save real value in order to create link with real value
			//
			paVariant[dwCost].ulVal -= MQ_MAX_LINK_COST;

		}
		_ltot( paVariant[dwCost].ulVal, szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_COST_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);

		//
		//	Save full path
		//
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_PATH_KEY,
                                       paVariant[dwFullPath].pwszVal,
                                       pszFileName ) ;
		ASSERT(f);

		_ltot( wcslen(paVariant[dwFullPath].pwszVal), szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_PATHLENGTH_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);

		delete paVariant[dwFullPath].pwszVal;

		//
		//	Save description
		//
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_DESCRIPTION_KEY,
                                       paVariant[dwDescription].pwszVal,
                                       pszFileName ) ;
		ASSERT(f);
		
		_ltot( wcslen(paVariant[dwDescription].pwszVal), szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_DESCRIPTIONLENGTH_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);

		delete paVariant[dwDescription].pwszVal;

		//
		//	Save gates
		//
		//	Save number of gates
		//
		_ltot( paVariant[dwGates].calpwstr.cElems, szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_SITEGATENUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);	
		
		//
		// save all site gates if needed
		//
		if (paVariant[dwGates].calpwstr.cElems)
		{
			//
			//	Save length of all site gate names
			//
			ULONG ulLength = 0;
			for (ULONG i = 0; i < paVariant[dwGates].calpwstr.cElems; i++)
			{
				ulLength += wcslen (paVariant[dwGates].calpwstr.pElems[i]) + 1;			
			}
			_ltot( ulLength, szBuf, 10 );
			f = WritePrivateProfileString( tszSectionName,
										   MIGRATION_SITELINK_SITEGATELENGTH_KEY,
										   szBuf,
										   pszFileName ) ;
			ASSERT(f);	

			//
			//	construct and save site gate string: SiteGateName1;SiteGateName2; ...
			//
			WCHAR *pwszSiteGates = new WCHAR [ulLength + 1];
			pwszSiteGates[0] = L'\0';
			for (i = 0; i < paVariant[dwGates].calpwstr.cElems; i++)
			{
				wcscat (pwszSiteGates, paVariant[dwGates].calpwstr.pElems[i]);
				wcscat (pwszSiteGates, L";");
			}
			f = WritePrivateProfileString( tszSectionName,
										   MIGRATION_SITELINK_SITEGATE_KEY,
										   pwszSiteGates,
										   pszFileName ) ;
			ASSERT(f);
			delete pwszSiteGates;			
		}
		delete [] paVariant[dwGates].calpwstr.pElems;	

		//
		// delete this sitelink
		//		
		CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

		hr = DSCoreDeleteObject( 
					MQDS_SITELINK,
                    NULL,
                    paVariant[dwId].puuid,
                    &requestContext,
                    NULL
					);		
		if (FAILED(hr))
		{		
			UuidToString( paVariant[dwId].puuid, &lpszGuid ) ;				
			LogMigrationEvent( MigLog_Error, MQMig_E_CANNOT_DELETE_SITELINK, 
				lpszGuid, 
				hr) ;
			RpcStringFree( &lpszGuid ) ;

			hr1 = MQMig_E_CANNOT_DELETE_SITELINK ;
			//
			// we continue with the next site link			
			//
			hr = MQMig_OK;
		}

		delete paVariant[dwId].puuid ;	
    }

	HRESULT hRes = LookupEnd( hQuery ) ;
    DBG_USED(hRes);
	ASSERT(SUCCEEDED(hRes)) ;


	if (ulSiteLinkCount == 0)
	{
		LogMigrationEvent(MigLog_Info, MQMig_I_NO_SITELINK );		
	}
	else
	{
		LogMigrationEvent( MigLog_Info, MQMig_I_SITELINK_COUNT, ulSiteLinkCount);
		_ltot( ulSiteLinkCount, szBuf, 10 );
		f = WritePrivateProfileString( MIGRATION_SITELINKNUM_SECTON,
                                       MIGRATION_SITELINKNUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
	}		

	if (FAILED(hr1))
	{
		return hr1;
	}
	return hr;
}

//+-------------------------------------------------------------------------
//
//  HRESULT _RestoreSiteLink()
//
//	Restore all Windows2000 MSMQ site link: get all properties from
//	.ini file and create these site link with new guid under new msmqServices
//
//+-------------------------------------------------------------------------

HRESULT _RestoreSiteLink()
{
	HRESULT hr = MQMig_OK;

	TCHAR *pszFileName = GetIniFileName ();
	ULONG ulSiteLinkCount = GetPrivateProfileInt(
								  MIGRATION_SITELINKNUM_SECTON,	// address of section name
								  MIGRATION_SITELINKNUM_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );
	if (ulSiteLinkCount == 0)
	{
		return MQMig_OK;
	}

	HRESULT hr1 = MQMig_OK;
	ULONG ulNonCreatedSiteLinkCount = ulSiteLinkCount;

	for (ULONG ulCount=0; ulCount<ulSiteLinkCount; ulCount++)
	{
		TCHAR tszSectionName[50];
		_stprintf(tszSectionName, TEXT("%s%lu"), MIGRATION_SITELINK_SECTION, ulCount+1);
		
        DWORD dwRetSize;				
		//
		// get Neighbor1 
		//
		GUID Neighbor1Id = GUID_NULL;
		TCHAR szGuid[50];
	
		dwRetSize =  GetPrivateProfileString(
                          tszSectionName,			// points to section name
                          MIGRATION_SITELINK_NEIGHBOR1_KEY,	// points to key name
                          TEXT(""),                 // points to default string
                          szGuid,          // points to destination buffer
                          50,                 // size of destination buffer
                          pszFileName               // points to initialization filename);
                          );
        if (_tcscmp(szGuid, TEXT("")) == 0)
        {
			//
			// we cannot create such site link
			//
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
            continue;
        }	
		UuidFromString(&(szGuid[0]), &Neighbor1Id);

		//
		// get Neighbor2 
		//		
		GUID Neighbor2Id = GUID_NULL;		
	
		dwRetSize =  GetPrivateProfileString(
                          tszSectionName,			// points to section name
                          MIGRATION_SITELINK_NEIGHBOR2_KEY,	// points to key name
                          TEXT(""),                 // points to default string
                          szGuid,          // points to destination buffer
                          50,                 // size of destination buffer
                          pszFileName               // points to initialization filename);
                          );
        if (_tcscmp(szGuid, TEXT("")) == 0)
        {
            //
			// we cannot create such site link
			//
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
            continue;
        }	
		UuidFromString(&(szGuid[0]), &Neighbor2Id);		

		//
		// get cost
		//
		ULONG ulCost = GetPrivateProfileInt(
								  tszSectionName,	// address of section name
								  MIGRATION_SITELINK_COST_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );

		//
		// get full path of site link
		//
		ULONG ulLength = GetPrivateProfileInt(
							  tszSectionName,	// address of section name
							  MIGRATION_SITELINK_PATHLENGTH_KEY,    // address of key name
							  0,							// return value if key name is not found
							  pszFileName					// address of initialization filename);
							  );
		ASSERT(ulLength);

		TCHAR *pszSiteLinkPath = new TCHAR[ulLength+1];
		dwRetSize =  GetPrivateProfileString(
                          tszSectionName,			// points to section name
                          MIGRATION_SITELINK_PATH_KEY,	// points to key name
                          TEXT(""),                 // points to default string
                          pszSiteLinkPath,          // points to destination buffer
                          ulLength+1,                 // size of destination buffer
                          pszFileName               // points to initialization filename);
                          );
        if (_tcscmp(pszSiteLinkPath, TEXT("")) == 0)
        {
            //
			// we cannot create such site link
			//
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
			if (pszSiteLinkPath)
			{
				delete pszSiteLinkPath;
			}
            continue;
        }
		
		//
		// get site gates
		//
		ULONG ulGatesNum = GetPrivateProfileInt(
								  tszSectionName,	// address of section name
								  MIGRATION_SITELINK_SITEGATENUM_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );			
		LPTSTR *ppSiteGates = NULL;			
		if (ulGatesNum)
		{
			//
			// there is site gate for this site link
			//
			ulLength = GetPrivateProfileInt(
								  tszSectionName,	// address of section name
								  MIGRATION_SITELINK_SITEGATELENGTH_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );
			ASSERT(ulLength);
			TCHAR *pszSiteGate = new TCHAR[ulLength+1];

			dwRetSize =  GetPrivateProfileString(
							  tszSectionName,			// points to section name
							  MIGRATION_SITELINK_SITEGATE_KEY,	// points to key name
							  TEXT(""),                 // points to default string
							  pszSiteGate,		        // points to destination buffer
							  ulLength+1,                 // size of destination buffer
							  pszFileName               // points to initialization filename);
							  );
			//
			// create array of site gates
			//
			ppSiteGates = new LPTSTR[ ulGatesNum ];
			TCHAR *ptr = pszSiteGate;
			TCHAR chFind = _T(';');

			for (ULONG i=0; i<ulGatesNum && *ptr != _T('\0'); i++)
			{
				//
				// site gate names are separated by ';'
				//
				TCHAR *pdest = _tcschr( ptr, chFind );
				ULONG ulCurLength = pdest - ptr ;  //not including last ';' 
				
				ppSiteGates[i] = new TCHAR[ulCurLength+1];				
				_tcsncpy( ppSiteGates[i], ptr, ulCurLength );
				TCHAR *ptrTmp = ppSiteGates[i];
				ptrTmp[ulCurLength] = _T('\0');

				ptr = pdest + 1;	//the first character after ';'
			}
			delete pszSiteGate;
		}

		//
		// get description
		//
		ulLength = GetPrivateProfileInt(
						  tszSectionName,	// address of section name
						  MIGRATION_SITELINK_DESCRIPTIONLENGTH_KEY,    // address of key name
						  0,							// return value if key name is not found
						  pszFileName					// address of initialization filename);
						  );		

		TCHAR *pszDescription = NULL;	
		if (ulLength)
		{
			//
			// there is description in .ini for this sitelink
			//
			pszDescription = new TCHAR[ulLength+1];
			dwRetSize =  GetPrivateProfileString(
							  tszSectionName,			// points to section name
							  MIGRATION_SITELINK_DESCRIPTION_KEY,	// points to key name
							  TEXT(""),                 // points to default string
							  pszDescription,	        // points to destination buffer
							  ulLength+1,                 // size of destination buffer
							  pszFileName               // points to initialization filename);
							  );	
		}

		//
		// Create this sitelink in DS
		//	
		// Prepare the properties for DS call.
		//		
		PROPVARIANT paVariant[SITELINK_PROP_NUM];
		PROPID      paPropId[SITELINK_PROP_NUM];
		DWORD          PropIdCount = 0;
	
		paPropId[ PropIdCount ] = PROPID_L_FULL_PATH;    //PropId
		paVariant[ PropIdCount ].vt = VT_LPWSTR;          //Type
		paVariant[ PropIdCount ].pwszVal = pszSiteLinkPath;
		PropIdCount++;

		paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR1;    //PropId
		paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
		paVariant[ PropIdCount ].puuid = &Neighbor1Id;
		PropIdCount++;

		paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR2;    //PropId
		paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
		paVariant[ PropIdCount ].puuid = &Neighbor2Id;
		PropIdCount++;

		paPropId[ PropIdCount ] = PROPID_L_COST;    //PropId
		paVariant[ PropIdCount ].vt = VT_UI4;       //Type
		paVariant[ PropIdCount ].ulVal = ulCost;
		PropIdCount++;

		if (pszDescription)
		{
		    //
		    // BUG 5225.
		    // Add description only if exists.
		    //
		    paPropId[ PropIdCount ] = PROPID_L_DESCRIPTION;    //PropId
		    paVariant[ PropIdCount ].vt = VT_LPWSTR;          //Type
		    paVariant[ PropIdCount ].pwszVal = pszDescription;
		    PropIdCount++;
		}
		
		paPropId[ PropIdCount ] = PROPID_L_GATES_DN;    //PropId
		paVariant[ PropIdCount ].vt = VT_LPWSTR | VT_VECTOR;          //Type
		paVariant[ PropIdCount ].calpwstr.cElems = ulGatesNum;
		paVariant[ PropIdCount ].calpwstr.pElems = ppSiteGates;	
		PropIdCount++;

		ASSERT((LONG) PropIdCount <= SITELINK_PROP_NUM) ;  

		CDSRequestContext requestContext( e_DoNotImpersonate,
									e_ALL_PROTOCOLS);  // not relevant 

		HRESULT hr = DSCoreCreateObject ( MQDS_SITELINK,
										  NULL,			//or pszSiteLinkPath??
										  PropIdCount,
										  paPropId,
										  paVariant,
										  0,        // ex props
										  NULL,     // ex props
										  NULL,     // ex props
										  &requestContext,
										  NULL,
										  NULL ) ;

		if (FAILED(hr))
		{
			LogMigrationEvent(	MigLog_Warning, 
								MQMig_E_CANNOT_CREATE_SITELINK, 
								pszSiteLinkPath, hr) ;	
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
		}
		else
		{
			//
			// site link was created successfully
			//
			LogMigrationEvent(	MigLog_Info, 
								MQMig_I_SITELINK_CREATED, 
								pszSiteLinkPath) ;
			//
			// remove this section from .ini
			//
			BOOL f = WritePrivateProfileString( 
								tszSectionName,
								NULL,
								NULL,
								pszFileName ) ;
            UNREFERENCED_PARAMETER(f);
			ulNonCreatedSiteLinkCount --;
		}

		delete pszSiteLinkPath;

		if (pszDescription)
		{
			delete pszDescription;
		}		
		if (ppSiteGates)
		{
			delete [] ppSiteGates;
		}
	
	}	//for

	//
	// remove this section from .ini file.
	// If we leave some site link section to handle them later
	// we have to put here real site link number, i.e. number of
	// non-created site link. We need to renumerate site link sections too.
	//
	BOOL f;
	if (FAILED(hr) || FAILED(hr1))
	{
		ASSERT (ulNonCreatedSiteLinkCount);

		TCHAR szBuf[10];
		_ltot( ulNonCreatedSiteLinkCount, szBuf, 10 );
		f = WritePrivateProfileString( MIGRATION_NONRESTORED_SITELINKNUM_SECTON,
                                       MIGRATION_SITELINKNUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
	}
	else
	{
		//
		// remove this section from .ini file.
		//
		ASSERT (ulNonCreatedSiteLinkCount == 0);
		f = WritePrivateProfileString( 
						MIGRATION_SITELINKNUM_SECTON,
						NULL,
						NULL,
						pszFileName ) ;
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  HRESULT _DeleteEnterprise()
//
//  Delete the enterprise object.
//  By default, when promoting the first server in a new NT5 enterprise to
//  be a domain controller, it has a default msmq enterprise object.
//  When migrating an existing msmq enterprise, we delete this default
//  object and create a new one with the existing guid.
//
//+-------------------------------------------------------------------------

HRESULT _DeleteEnterprise()
{
    HRESULT hr;

	//
	// save all SiteLink if there is in .ini file and then delete them
	//
	hr = SaveSiteLink ();
	if (FAILED(hr))
	{
		//
		// it is critical error: if there is non-deleted site link object
		// we can't delete msmqService object
		//
		return hr;
	}

    PLDAP pLdap = NULL ;
    TCHAR *pwszDefName = NULL ;

    hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    const WCHAR x_wcsCnServices[] =  L"CN=MsmqServices,";

    DWORD Length = (sizeof(x_wcsCnServices)/sizeof(WCHAR))  +  //CN=MsmqServices,
                   (sizeof(SITE_LINK_ROOT) / sizeof(TCHAR)) +  //CN=Services,CN=Configuration,
                   wcslen(pwszDefName) + 1;
    AP<unsigned short> pwcsPath = new WCHAR[Length];
    swprintf(
            pwcsPath,
            L"%s"             // "CN=MsmqServices,"
            L"%s"             // "CN=Services,CN=Configuration,"
            L"%s",            // pwszDefName
            x_wcsCnServices,
            SITE_LINK_ROOT,
            pwszDefName
            );	
	
    ULONG ulRes = ldap_delete_s( pLdap,
                                 pwcsPath ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_CANNOT_DELETE_ENTERPRISE, pwcsPath, ulRes) ;
        return MQMig_E_CANNOT_DELETE_ENTERPRISE ;
    }
    else
    {
        LogMigrationEvent( MigLog_Info, MQMig_I_DELETE_ENTERPRISE, pwcsPath) ;
    }

    return MQMig_OK;
}

//+----------------------------------------------
//
//  HRESULT CreateMSMQEnterprise()
//
//  Create the msmqService object in NT5 DS.
//
//+----------------------------------------------
HRESULT  _CreateMSMQEnterprise(
                IN ULONG                uLongLived,
                IN GUID                *pEntGuid,
                IN SECURITY_DESCRIPTOR *pEsd,
                IN BYTE                 bNameStyle,
                IN LPWSTR               pwszCSPName,
                IN USHORT               uiVersion,
                IN USHORT               uiInterval1,
                IN USHORT               uiInterval2
                )
{
    UNREFERENCED_PARAMETER(uiVersion);

	PROPID   propIDs[] = { PROPID_E_LONG_LIVE,
                           PROPID_E_NT4ID,
                           PROPID_E_NAMESTYLE,
                           PROPID_E_CSP_NAME,
                           PROPID_E_VERSION,
                           PROPID_E_S_INTERVAL1,
                           PROPID_E_S_INTERVAL2,
                           PROPID_E_SECURITY };
	const DWORD nProps = sizeof(propIDs) / sizeof(propIDs[0]);
	PROPVARIANT propVariants[ nProps ] ;
	DWORD       iProperty = 0 ;

	propVariants[iProperty].vt = VT_UI4;
	propVariants[iProperty].ulVal = uLongLived ;
	iProperty++ ;

	propVariants[iProperty].vt = VT_CLSID;
	propVariants[iProperty].puuid = pEntGuid ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI1;
	propVariants[iProperty].bVal = bNameStyle ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_LPWSTR;
	propVariants[iProperty].pwszVal = pwszCSPName ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI2;
	propVariants[iProperty].uiVal = DEFAULT_E_VERSION ; //uiVersion
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI2;
	propVariants[iProperty].uiVal = uiInterval1 ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI2;
	propVariants[iProperty].uiVal = uiInterval2 ;
	iProperty++ ;

    ASSERT(pEsd && IsValidSecurityDescriptor(pEsd)) ;
    if (pEsd)
    {
        propVariants[iProperty].vt = VT_BLOB ;
	    propVariants[iProperty].blob.pBlobData = (BYTE*) pEsd ;
    	propVariants[iProperty].blob.cbSize =
                                      GetSecurityDescriptorLength(pEsd) ;
	    iProperty++ ;
    }

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant for enterprise object

    HRESULT hr = DSCoreCreateObject( MQDS_ENTERPRISE,
                                     NULL,
                                     iProperty,
                                     propIDs,
                                     propVariants,
                                     0,        // ex props
                                     NULL,     // ex props
                                     NULL,     // ex props
                                     &requestContext,
                                     NULL,
                                     NULL ) ;

    if ( hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ||
         hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) )
    {
        LogMigrationEvent(MigLog_Warning, MQMig_I_ENT_ALREADY_EXIST) ;
        //
        // if it is MSMQ Enterprise created in the previous time do nothing
        // if it is not, delete it and create enterprise with EntGuid
        //
        PROPID NT4IdProp = PROPID_E_NT4ID;
        PROPVARIANT NT4IdVar;
        NT4IdVar.vt = VT_NULL ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant for enterprise object

        hr = DSCoreGetProps( MQDS_ENTERPRISE,
                             NULL,  // path name
                             pEntGuid,
                             1,
                             &NT4IdProp,
                             &requestContext,
                             &NT4IdVar);

        BOOL fDeleteEnt = TRUE;
        if (SUCCEEDED(hr))
        {
			if (memcmp(pEntGuid, NT4IdVar.puuid, sizeof (GUID)) == 0)
			{
				fDeleteEnt = FALSE;
			}
			delete NT4IdVar.puuid;            
        }

        if (fDeleteEnt)
        {			
            //
            // delete enterprise
            //
            hr = _DeleteEnterprise();
            if (FAILED(hr))
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_CANT_DELETE_ENT, hr) ;
                return hr;
            }

            CDSRequestContext requestContext( e_DoNotImpersonate,
                                        e_ALL_PROTOCOLS);  // not relevant for enterprise object

            hr = DSCoreCreateObject( MQDS_ENTERPRISE,
                                     NULL,
                                     iProperty,
                                     propIDs,
                                     propVariants,
                                     0,        // ex props
                                     NULL,     // ex props
                                     NULL,     // ex props
                                     &requestContext,
                                     NULL,
                                     NULL ) ;			
        }
    }
	
    if (SUCCEEDED(hr))
    {
		//
		// At the first time we have to restore pre-migration site link.
		// At the second and more time we have to check: 
		// if there is site link section in .ini it means that we do not yet
		// restore site link at the previous time. 
		// It means, in any case try to restore pre-migration site link.
		//			
		HRESULT hr1 = _RestoreSiteLink();
        UNREFERENCED_PARAMETER(hr1);
		//
		// We can continue to migration despite on failure in RestoreSiteLink
		// So, we don't check return code hr1.
		//
        LogMigrationEvent(MigLog_Trace, MQMig_I_ENTERPRISE_CREATED) ;
    }
    else
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CREATE_ENT, hr) ;
    }

    return hr ;
}

//-------------------------------------------
//
//  HRESULT MigrateEnterprise()
//
//-------------------------------------------

#define INIT_ENT_COLUMN(_ColName, _ColIndex, _Index)                \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateEnterprise()
{
    HRESULT hr = OpenEntTable() ;
    CHECK_HR(hr) ;

    LONG cAlloc = 9 ;
    LONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_ENT_COLUMN(E_NAME,         iEntNameIndex,   cbColumns) ;
    INIT_ENT_COLUMN(E_LONGLIVE,     iLongLiveIndex,  cbColumns) ;
    INIT_ENT_COLUMN(E_ID,           iEntIDIndex,     cbColumns) ;
    INIT_ENT_COLUMN(E_SECURITY,     iSecIndex,       cbColumns) ;
    INIT_ENT_COLUMN(E_NAMESTYLE,    iNameStyleIndex, cbColumns) ;
    INIT_ENT_COLUMN(E_CSP_NAME,     iCSPNameIndex,   cbColumns) ;
    INIT_ENT_COLUMN(E_VERSION,      iVersionIndex,   cbColumns) ;
    INIT_ENT_COLUMN(E_SINTERVAL1,   iInterval1Index, cbColumns) ;
    INIT_ENT_COLUMN(E_SINTERVAL2,   iInterval2Index, cbColumns) ;

    ASSERT(cbColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hEntTable,
                                       pColumns,
                                       cbColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    ULONG uLongLived = (ULONG) pColumns[ iLongLiveIndex ].nColumnValue ;
    SECURITY_DESCRIPTOR *pEsd =
                (SECURITY_DESCRIPTOR*) pColumns[ iSecIndex ].nColumnValue ;

    LogMigrationEvent(MigLog_Info, MQMig_I_ENT_INFO,
                   (LPTSTR) pColumns[ iEntNameIndex ].nColumnValue,
                                                uLongLived, uLongLived) ;

    if (!g_fReadOnly)
    {
        hr = _CreateMSMQEnterprise(
                    uLongLived,                                        //LONG_LIVE
                    (GUID*) pColumns[ iEntIDIndex ].nColumnValue,      //ID
                    pEsd,                                              //SECURITY
                    (BYTE) pColumns[ iNameStyleIndex ].nColumnValue,   //NAME_STYLE
                    (LPTSTR) pColumns[ iCSPNameIndex ].nColumnValue,   //CSP_NAME
                    (USHORT) pColumns[ iVersionIndex ].nColumnValue,   //VERSION
                    (USHORT) pColumns[ iInterval1Index ].nColumnValue, //INTERVAL1
                    (USHORT) pColumns[ iInterval2Index ].nColumnValue  //INTERVAL2                    
                    ) ;
    }
    MQDBFreeBuf((void*) pColumns[ iEntNameIndex ].nColumnValue) ;
    MQDBFreeBuf((void*) pColumns[ iSecIndex ].nColumnValue) ;
    MQDBFreeBuf((void*) pColumns[ iEntIDIndex ].nColumnValue) ;
    MQDBFreeBuf((void*) pColumns[ iCSPNameIndex ].nColumnValue) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\miggates.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    miggates.cpp

Abstract:

    Migration NT4 SiteGate objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "miggates.tmh"

//+--------------------------------------------------------------
//
//  HRESULT  LookupBegin()
//
//+--------------------------------------------------------------

HRESULT  LookupBegin( MQCOLUMNSET *pColumnSet,
                      HANDLE      *phQuery )
{
	if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

	HRESULT hr = DSCoreLookupBegin( NULL,
                                    NULL,
                                    pColumnSet,
                                    NULL,
                                    &requestContext,
                                    phQuery ) ;
	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  LookupNext()
//
//+--------------------------------------------------------------

HRESULT LookupNext( HANDLE       hQuery,
                    DWORD       *pdwCount,
                    PROPVARIANT  paVariant[] )
{
	if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }   

	HRESULT hr = DSCoreLookupNext ( hQuery,
	                				pdwCount,
                					paVariant ) ;
	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  LookupEnd()
//
//+--------------------------------------------------------------

HRESULT LookupEnd(HANDLE hQuery)
{
	if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }

	HRESULT hr = DSCoreLookupEnd ( hQuery );			
	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  GetFullPathNameByGuid()
//
//+--------------------------------------------------------------

HRESULT GetFullPathNameByGuid ( GUID   MachineId,
                                LPWSTR *lpwcsFullPathName )
{	
	PROPID propID = PROPID_QM_FULL_PATH;
    PROPVARIANT propVariant;

    propVariant.vt = VT_NULL;
	
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

	HRESULT hr = DSCoreGetProps( MQDS_MACHINE,
                                 NULL, //pathname
	            				 &MachineId,
                                 1,
            					 &propID,
                                 &requestContext,
			            		 &propVariant ) ;
	if (SUCCEEDED(hr))
	{
		*lpwcsFullPathName = propVariant.pwszVal;
	}

	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  _AddSiteGatesToSiteLink()
//
//+--------------------------------------------------------------

static HRESULT  _AddSiteGatesToSiteLink (
			GUID *pLinkId,				//link id
			ULONG ulNumOfOldSiteGates,	//number of current site gates
			LPWSTR *lpwcsOldGates,		//current site gates
			ULONG ulNumOfNewGates,		//number of new site gates
			LPWSTR *lpwcsNewSiteGates	//new site gates
			)
{	
	ASSERT( ulNumOfNewGates != 0);

	PROPID propID = PROPID_L_GATES_DN;
    PROPVARIANT propVariant;
	
	propVariant.vt = VT_LPWSTR | VT_VECTOR;
	propVariant.calpwstr.cElems = ulNumOfOldSiteGates + ulNumOfNewGates;
	propVariant.calpwstr.pElems = new LPWSTR[propVariant.calpwstr.cElems];

	ULONG i;
	if (ulNumOfOldSiteGates > 0)
	{
		for (	i=0; i<ulNumOfOldSiteGates; i++)
		{
			propVariant.calpwstr.pElems[i] = new WCHAR [wcslen(lpwcsOldGates[i]) + 1];
			wcscpy (propVariant.calpwstr.pElems[i], lpwcsOldGates[i]);
		}
	}
	
	for (i=0; i<ulNumOfNewGates; i++)
	{
		propVariant.calpwstr.pElems[i + ulNumOfOldSiteGates] =
									new WCHAR [wcslen(lpwcsNewSiteGates[i]) + 1];
		wcscpy (propVariant.calpwstr.pElems[i + ulNumOfOldSiteGates], lpwcsNewSiteGates[i]);
	}
	
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

	HRESULT hr = DSCoreSetObjectProperties( MQDS_SITELINK,
                                            NULL, // pathname
					                    	pLinkId,
                    						1,
					                       &propID,
                                           &propVariant,
                                           &requestContext,
                                            NULL ) ;
	delete [] propVariant.calpwstr.pElems;

	if ((hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS)) &&
         g_fAlreadyExistOK)
    {
        return MQMig_OK ;
    }

	return hr ;
}

//-------------------------------------------------------------------------
//
//  HRESULT  _CopySiteGatesValueToMig()
//
//  Copy the MSMQ SiteGates in the SiteLink object to the "mig" attributes.
//  These attributes mirror the  "normal" msmq attributes in the SiteLink
//  object and are used in the replication service, to enable replication
//  of changes to MSMQ1.0.
//
//-------------------------------------------------------------------------

HRESULT _CopySiteGatesValueToMig()
{
    HRESULT hr = MQMig_OK;

    PLDAP pLdap = NULL ;
    TCHAR *pszDefName = NULL ;

    hr =  InitLDAP(&pLdap, &pszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdap, &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = SITE_LINK_ROOT_LEN + wcslen(pszDefName) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    swprintf(pwszDN, L"%s%s", SITE_LINK_ROOT, pszDefName);

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_LinkCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);

     TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);

    _tcscat(wszFilter, TEXT(")(")) ;
    _tcscat(wszFilter, MQ_L_SITEGATES_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=*))")) ;

    PWSTR rgAttribs[3] = {NULL, NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (MQ_L_SITEGATES_ATTRIBUTE);
    rgAttribs[1] = const_cast<LPWSTR> (MQ_L_FULL_PATH_ATTRIBUTE);

    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 rgAttribs, //ppAttributes,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error,
                           MQMig_E_LDAP_SEARCH_FAILED,
                           pwszDN, wszFilter, ulRes) ;
        return MQMig_E_LDAP_SEARCH_FAILED ;
    }
    ASSERT(pRes) ;

    LogMigrationEvent( MigLog_Info,
                       MQMig_I_LDAP_SEARCH_GATES,
                       pwszDN, wszFilter );

    int iCount = ldap_count_entries(pLdap, pRes) ;

    if (iCount == 0)
    {
        LogMigrationEvent(MigLog_Info, MQMig_I_NO_SITEGATES_RESULTS,
                            pwszDN,wszFilter );
        return MQMig_OK ;
    }

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry && SUCCEEDED(hr))
    {
        WCHAR **ppPath = ldap_get_values( pLdap,
                                          pEntry,
                        const_cast<LPWSTR> (MQ_L_FULL_PATH_ATTRIBUTE) ) ;
        ASSERT(ppPath) ;

        PLDAP_BERVAL *ppVal = ldap_get_values_len( pLdap,
                                                   pEntry,
                       const_cast<LPWSTR> (MQ_L_SITEGATES_ATTRIBUTE) ) ;
        ASSERT(ppVal) ;
        if (ppVal && ppPath)
        {
            hr = ModifyAttribute(
                     *ppPath,
                     const_cast<WCHAR*> (MQ_L_SITEGATES_MIG_ATTRIBUTE),
                     NULL,
                     ppVal
                     );
        }
        int i = ldap_value_free_len( ppVal ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        i = ldap_value_free( ppPath ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    return hr;   
}

//+--------------------------------------
//
//  HRESULT MigrateASiteGate()
//
//+--------------------------------------

HRESULT MigrateASiteGate (
			GUID *pSiteId,	
			GUID *pGatesIds,
			LONG NumOfGates
			)
{
	LONG i;

#ifdef _DEBUG
    unsigned short *lpszGuid ;
	P<TCHAR> lpszAllSiteGates = new TCHAR[40 * NumOfGates];
    lpszAllSiteGates[0] = _T('\0');

	UuidToString( pSiteId, &lpszGuid ) ;
	GUID *pCurGateGuid = pGatesIds;
	for ( i = 0 ; i < NumOfGates ; i++ )
	{
		unsigned short *lpszCurGate;
		UuidToString( pCurGateGuid, &lpszCurGate ) ;
		_tcscat(lpszAllSiteGates, lpszCurGate);
		_tcscat(lpszAllSiteGates, TEXT(" ")) ;
		RpcStringFree( &lpszCurGate );
		pCurGateGuid++;
	}

    LogMigrationEvent(MigLog_Info, MQMig_I_SITEGATES_INFO,
                                lpszGuid, NumOfGates, lpszAllSiteGates ) ;
    RpcStringFree( &lpszGuid ) ;
#endif

    if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }

	HRESULT status;
	
	//
	// Create array of site gates' full path name
	//
	LPWSTR *lpwcsSiteGates = new LPWSTR[ NumOfGates ];
	LPWSTR lpwcsCurSiteGate;
	
	for ( i = 0 ; i < NumOfGates ; i++ )
	{
		//
		// get full machine path name by guid
		//
		lpwcsCurSiteGate = NULL;
		status = GetFullPathNameByGuid(pGatesIds[i], &lpwcsCurSiteGate) ;
		CHECK_HR(status) ;
		lpwcsSiteGates[i] = new WCHAR[wcslen(lpwcsCurSiteGate)+1];
		wcscpy (lpwcsSiteGates[i], lpwcsCurSiteGate);
		delete lpwcsCurSiteGate;

#ifdef _DEBUG
        unsigned short *lpszGuid ;
        UuidToString( &pGatesIds[i], &lpszGuid ) ;
        LogMigrationEvent(MigLog_Info, MQMig_I_SITEGATE_INFO,
                                            lpszGuid, lpwcsSiteGates[i]) ;
		RpcStringFree( &lpszGuid ) ;
#endif
	}
	
	//
    // Lookup the Neighbors Id and Gates of the object Site Link
    //
	LONG cAlloc = 4;
	P<PROPID> columnsetPropertyIDs  = new PROPID[ cAlloc ];
	columnsetPropertyIDs[0] = PROPID_L_NEIGHBOR1;
	columnsetPropertyIDs[1] = PROPID_L_NEIGHBOR2;
	columnsetPropertyIDs[2] = PROPID_L_GATES_DN;
	columnsetPropertyIDs[3] = PROPID_L_ID;

    MQCOLUMNSET columnsetSiteLink;
    columnsetSiteLink.cCol = cAlloc;
    columnsetSiteLink.aCol = columnsetPropertyIDs;

    HANDLE hQuery;
    DWORD dwCount = cAlloc;
	
	status = LookupBegin(&columnsetSiteLink, &hQuery);
	CHECK_HR(status) ;	
	
	P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];

	while (SUCCEEDED(status))
    {
		status = LookupNext( hQuery,
		                     &dwCount,
                              paVariant ) ;
		CHECK_HR(status) ;
		if (dwCount == 0)
		{
			//there is no result
			break;
		}
	
		if (memcmp (pSiteId, paVariant[0].puuid, sizeof(GUID)) == 0 ||
			memcmp (pSiteId, paVariant[1].puuid, sizeof(GUID)) == 0)
		{
			//
			// add site gates to that site link
			//
			status = _AddSiteGatesToSiteLink (
							paVariant[3].puuid,				//link id
							paVariant[2].calpwstr.cElems,	//number of current site gates
							paVariant[2].calpwstr.pElems,	//current site gates
							NumOfGates,						//number of new site gates
							lpwcsSiteGates					//new site gates
							);
			delete [] paVariant[2].calpwstr.pElems;
			delete paVariant[3].puuid;
			CHECK_HR(status) ;
		}
    }

	delete [] lpwcsSiteGates;

	HRESULT status1 = LookupEnd( hQuery ) ;
    UNREFERENCED_PARAMETER(status1);
	
    return MQMig_OK ;
}

//-----------------------------------------
//
//  HRESULT MigrateSiteGates()
//
//-----------------------------------------

HRESULT MigrateSiteGates()
{
	LONG cAlloc = 2 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_ID_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_ID_CTYPE ;
    UINT iGuidIndex = cColumns ;
    cColumns++ ;

	INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_GATES_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_GATES_CTYPE ;
    UINT iGatesIndex = cColumns ;
    cColumns++ ;

    ASSERT(cColumns == cAlloc) ;
	
	CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;

    CHECK_HR(status) ;

    UINT iIndex = 0 ;
	MQDBSTATUS status1 = MQMig_OK;

    while(SUCCEEDED(status))
    {
		WORD  wSize = *((WORD *) pColumns[ iGatesIndex ].nColumnValue ) ;

		if (wSize != 0)
		{
			//
			// site has site gates
			//
			ASSERT ((ULONG)pColumns[ iGatesIndex ].nColumnLength == wSize * sizeof(GUID) + sizeof(WORD));
			WORD *tmp = (WORD *) pColumns[ iGatesIndex ].nColumnValue;
			GUID *ptrGatesGuid = (GUID *)(++tmp);

			status1 = MigrateASiteGate (
						(GUID *) pColumns[ iGuidIndex ].nColumnValue,	//site id
						ptrGatesGuid,									//gates id
						wSize											//number of gates
						);
		}

        for ( LONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

		CHECK_HR(status1) ;

		iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }
	
	if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_SITEGATES_SQL_FAIL, status) ;
        return status ;
    }

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    //
    // copy msmqSiteGates to msmqSiteGatesMig
    //
    HRESULT hr = _CopySiteGatesValueToMig();
	
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\miglinks.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    miglinks.cpp

Abstract:

    Migration NT4 SiteLink objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "miglinks.tmh"

//-----------------------------------------
//
//  HRESULT MigrateSiteLinks()
//
//-----------------------------------------

HRESULT MigrateASiteLink (
            IN GUID     *pLinkId,
            IN GUID     *pNeighbor1Id,
            IN GUID     *pNeighbor2Id,
            IN DWORD    dwCost,
            IN DWORD    dwSiteGateNum,
            IN LPWSTR   lpwcsSiteGates,
            IN UINT     iIndex
            )
{
    DBG_USED(iIndex);
#ifdef _DEBUG    
	unsigned short *lpszNeighbor1 ;
	unsigned short *lpszNeighbor2 ;
    
	UuidToString( pNeighbor1Id, &lpszNeighbor1 ) ;
	UuidToString( pNeighbor2Id, &lpszNeighbor2 ) ;

    LogMigrationEvent(MigLog_Info, MQMig_I_SITELINK_INFO,
							iIndex,
							lpszNeighbor1,
							lpszNeighbor2,
							dwCost ) ;
  
	RpcStringFree( &lpszNeighbor1 ) ;
	RpcStringFree( &lpszNeighbor2 ) ;
#endif
	
	//
    // Prepare the properties for DS call.
    //
    LONG cAlloc = 5;
    P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];
    P<PROPID>      paPropId  = new PROPID[ cAlloc ];
    DWORD          PropIdCount = 0;

    if (pLinkId)
    {
        //
        // Bug 5012.
        // pLinkId may be NULL if site link for connector machine is created
        //
        paPropId[ PropIdCount ] = PROPID_L_ID;		//PropId
        paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
        paVariant[PropIdCount].puuid = pLinkId ;
        PropIdCount++;
    }

    paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR1;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
    paVariant[ PropIdCount ].puuid = pNeighbor1Id;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR2;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
    paVariant[ PropIdCount ].puuid = pNeighbor2Id;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_L_COST;    //PropId
    paVariant[ PropIdCount ].vt = VT_UI4;       //Type
    paVariant[ PropIdCount ].ulVal = dwCost;
    PropIdCount++;
    
    if (dwSiteGateNum)
    {
        ASSERT (lpwcsSiteGates);
        paPropId[ PropIdCount ] = PROPID_L_GATES_DN;
        paVariant[ PropIdCount ].vt = VT_LPWSTR | VT_VECTOR;
        paVariant[ PropIdCount ].calpwstr.cElems = dwSiteGateNum;
        paVariant[ PropIdCount ].calpwstr.pElems = &lpwcsSiteGates;
        PropIdCount++;
    }

    ASSERT((LONG) PropIdCount <= cAlloc) ;

    if (g_fReadOnly)
    {
        //
        // Read-Only mode.
        //
        return MQMig_OK ;
    }

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant 

    HRESULT hr = DSCoreCreateObject ( MQDS_SITELINK,
                                      NULL,
                                      PropIdCount,
                                      paPropId,
                                      paVariant,
                                      0,        // ex props
                                      NULL,     // ex props
                                      NULL,     // ex props
                                      &requestContext,
                                      NULL,
                                      NULL ) ;

	if ((hr == MQDS_E_SITELINK_EXISTS) && g_fAlreadyExistOK)
    {
        hr = MQMig_OK ;
    }
    return hr ;
}

//-----------------------------------------
//
//  HRESULT MigrateSiteLinks()
//
//-----------------------------------------

#define INIT_SITELINK_COLUMN(_ColName, _ColIndex, _Index)           \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateSiteLinks()
{
	HRESULT hr = OpenSiteLinkTable() ;
    CHECK_HR(hr) ;

    ULONG cColumns = 0 ;
	ULONG cAlloc = 4 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_SITELINK_COLUMN(L_ID,			iGuidIndex,			cColumns) ;
	INIT_SITELINK_COLUMN(L_NEIGHBOR1,   iNeighbor1Index,	cColumns) ;
	INIT_SITELINK_COLUMN(L_NEIGHBOR2,   iNeighbor2Index,	cColumns) ;
	INIT_SITELINK_COLUMN(L_COST,		iCostIndex,			cColumns) ;

    ASSERT(cColumns == cAlloc);

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteLinkTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
	if (status == MQDB_E_NO_MORE_DATA)
    {
        LogMigrationEvent(MigLog_Warning, MQMig_I_NO_SITELINKS) ;
        return MQMig_OK ;
    }
    CHECK_HR(status) ;

    UINT iIndex = 0 ;

    while(SUCCEEDED(status))
    {
		//
        // Migrate each site link
		//
		status = MigrateASiteLink (
                        (GUID *) pColumns[ iGuidIndex ].nColumnValue,		//link id
                        (GUID *) pColumns[ iNeighbor1Index ].nColumnValue,	//neighbor1
                        (GUID *) pColumns[ iNeighbor2Index ].nColumnValue,	//neighbor2
                        (DWORD) pColumns[ iCostIndex ].nColumnValue,		//cost
                        0,
                        NULL,
                        iIndex
                        );               

        for ( ULONG i = 0 ; i < cColumns; i++ )
        {
			if (i != iCostIndex)
			{
				MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
			}
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
		CHECK_HR(status) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_SITELINKS_SQL_FAIL, status) ;
        return status ;
    }

    return MQMig_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migloger.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migloger.cpp

Abstract:

    Log errors and other messages of the migration tool.

Author:

    Doron Juster  (DoronJ)  08-Apr-1998

--*/

#include "migrat.h"

#include "migloger.tmh"

extern HINSTANCE  g_hResourceMod;

static LPTSTR  s_szLogFile = NULL ;
static ULONG   s_ulTraceFlags ;
static HANDLE  s_hLogFile = INVALID_HANDLE_VALUE ;

static TCHAR *s_pszPrefix[] = { TEXT("Event: "),
                                TEXT("Error: "),
                                TEXT("Warning: "),
                                TEXT("Trace: "),
                                TEXT("Info: ") } ;

static TCHAR s_pszAnalysisPhase[] = TEXT("Analysis phase");
static TCHAR s_pszMigrationPhase[] = TEXT("Migration phase");

//+--------------------------
//
//  void InitLogging()
//
//+--------------------------

void InitLogging( LPTSTR  szLogFile,
                  ULONG   ulTraceFlags,
				  BOOL	  fReadOnly)
{
    s_szLogFile = szLogFile ;
    s_ulTraceFlags =  ulTraceFlags + 1 ;

    if (s_ulTraceFlags <= MQ_DBGLVL_INFO)
    {
        //
        // Logging enabled.
        // Open the log file
        //
        s_hLogFile = CreateFile( s_szLogFile,
                                 GENERIC_WRITE,
                                 0,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL ) ;
		TCHAR *pszPhase;
		if (fReadOnly)
		{
			pszPhase = s_pszAnalysisPhase;			
		}
		else
		{
			pszPhase = s_pszMigrationPhase;
		}

        //
        // set pointer to the end of file
        //
        if (s_hLogFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwRes = SetFilePointer(
                                 s_hLogFile,          // handle of file
                                 0,  // number of bytes to move file pointer
                                 NULL,
                                 // pointer to high-order DWORD of
                                 // distance to move
                                 FILE_END     // how to move
                                 );
            UNREFERENCED_PARAMETER(dwRes);
            //
            // Write to log file the line at the start and between two phases.
            //
			SYSTEMTIME SystemTime;
			GetLocalTime (&SystemTime);		

			TCHAR szSeparatorLine[128];
			_stprintf (szSeparatorLine,
				TEXT("** Start logging at %d:%d:%d on %d/%d/%d, %s **"),
					SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond,
					SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
					pszPhase);

            DWORD dwSize = (_tcslen(szSeparatorLine) + 4) * 2 ;
            char *szLog = new char[ dwSize ] ;
            wcstombs(szLog, szSeparatorLine, dwSize) ;
            strcat(szLog, "\r\n\r\n") ;

            DWORD dwWritten = 0 ;
            WriteFile( s_hLogFile,
                       szLog,
                       strlen(szLog),
                       &dwWritten,
                       NULL ) ;
        }
    }
}

//+------------------------
//
//  void EndLogging()
//
//+------------------------

void EndLogging()
{
    if (s_hLogFile != INVALID_HANDLE_VALUE)
    {
		//
        // Write to log file the line at the end.
        //
		SYSTEMTIME SystemTime;
		GetLocalTime (&SystemTime);		

		TCHAR szSeparatorLine[128];
		_stprintf (szSeparatorLine,
				TEXT("** End of logging at %d:%d:%d on %d/%d/%d **"),
				SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond,
				SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear);

		DWORD dwSize = (_tcslen(szSeparatorLine) + 4) * 2 ;
        char *szLog = new char[ dwSize ] ;
        wcstombs(szLog, szSeparatorLine, dwSize) ;
        strcat(szLog, "\r\n\r\n") ;

        DWORD dwWritten = 0 ;
        WriteFile( s_hLogFile,
                   szLog,
                   strlen(szLog),
                   &dwWritten,
                   NULL ) ;

		//
		// close handle
		//
        CloseHandle(s_hLogFile) ;
        s_hLogFile = INVALID_HANDLE_VALUE ;
    }
}

//+--------------------------------
//
//  void LogMigrationEvent()
//
//+--------------------------------

void LogMigrationEvent(MigLogLevel eLevel, DWORD dwMsgId, ...)
{
    va_list Args;
    va_list *pArgs = &Args ;
    va_start(Args, dwMsgId);

    TCHAR *tszDisplay = NULL ;
    P<TCHAR> tszMessage = NULL ;
    TCHAR tszBuf[ 1024 ] ;

    DWORD dwMessageSize = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                         g_hResourceMod,
                                         dwMsgId,
                                         0,
                                         tszBuf,
                                         sizeof(tszBuf) / sizeof(TCHAR),
                                         pArgs) ;
    if (dwMessageSize == 0)
    {
        _stprintf(tszBuf,
         TEXT("ERROR: Failed to format message (id- %lut), err- %lut"),
                                                  dwMsgId, GetLastError()) ;
        tszDisplay = tszBuf ;
    }
    else
    {
        DWORD dwLen = _tcslen(tszBuf) ;
        tszBuf[ dwLen - 1 ] = TEXT('\0') ; // remove newline

        dwLen += _tcslen(s_pszPrefix[ eLevel ]) ;
        tszMessage = new TCHAR[ dwLen + 6 ] ;
        _tcscpy(tszMessage, s_pszPrefix[ eLevel ]) ;
        _tcscat(tszMessage, tszBuf) ;
        tszDisplay = tszMessage ;
    }

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_WARNING, TEXT("%ls"), tszDisplay));

    if (((ULONG) eLevel <= s_ulTraceFlags) &&
        (s_hLogFile != INVALID_HANDLE_VALUE))
    {
        //
        // Write to log file.
        //
        DWORD dwSize = ConvertToMultiByteString(tszDisplay, NULL, 0);
        P<char> szLog = new char[dwSize+4];
        size_t rc = ConvertToMultiByteString(tszDisplay, szLog, dwSize);
        DBG_USED(rc);
        ASSERT(rc != (size_t)(-1));
        szLog[dwSize] = '\0';
        strcat(szLog, "\r\n") ;
   
        DWORD dwWritten = 0 ;
        WriteFile( s_hLogFile,
                   szLog,
                   strlen(szLog),
                   &dwWritten,
                   NULL ) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migldap.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migldap.cpp

Abstract:

    Interface with LDAP.

Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "migldap.tmh"

static P<TCHAR> s_tszDefaultName = NULL ;
static P<TCHAR> s_tszSchemaNamingContext = NULL ;

//
// Defaults for replacing site name if original name is not compatible
// with dns (rfc 1035).
//
#define  DEFAULT_SITE_NAME_PREFIX   (TEXT("msmqSite"))
#define  DEFAULT_SITE_NAME_LEN      (_tcslen(DEFAULT_SITE_NAME_PREFIX))

//
// Defaults name for foreign sites. These one replace the foreign CNs
// in MSMQ1.0
//
#define  DEFAULT_FOREIGN_SITE_NAME_PREFIX   (TEXT("msmqForeignSite"))
#define  DEFAULT_FOREIGN_SITE_NAME_LEN      (_tcslen(DEFAULT_FOREIGN_SITE_NAME_PREFIX))

//+----------------------------------------------
//
//   HRESULT  GetSchemaNamingContext()
//
//+----------------------------------------------
HRESULT  GetSchemaNamingContext ( PLDAP pLdap,
                                  TCHAR **ppszSchemaDefName )
{    
    static BOOL s_fAlreadyInit = FALSE ;    

    if (s_fAlreadyInit)
    {        
        *ppszSchemaDefName = s_tszSchemaNamingContext ;

        return MQMig_OK ;
    }

    HRESULT hr = MQMig_OK ;

    LM<LDAPMessage> pRes = NULL ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 NULL,
                                 LDAP_SCOPE_BASE,
                                 L"(objectClass=*)",
                                 NULL,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_QUERY_ROOTDSE ;
        LogMigrationEvent(MigLog_Error, hr, ulRes) ;
        return hr ;
    }
    ASSERT(pRes) ;

    int iCount = ldap_count_entries(pLdap, pRes) ;
    LogMigrationEvent(MigLog_Info, MQMig_I_ROOTDSE_SUCCESS, iCount) ;

    if (iCount == 1)
    {
        LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
        WCHAR **ppValue = ldap_get_values( pLdap,
                                           pEntry,
                                           TEXT("schemaNamingContext")) ;
        if (ppValue && *ppValue)
        {
            ASSERT(s_tszSchemaNamingContext == NULL) ;
            s_tszSchemaNamingContext = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
            _tcscpy(s_tszSchemaNamingContext, *ppValue) ;
            ldap_value_free(ppValue) ;

            LogMigrationEvent(MigLog_Info, MQMig_I_NAME_CONTEXT,
                                                         s_tszSchemaNamingContext) ;
        }
        else
        {
            return MQMig_E_CANT_READ_CONTEXT ;
        }
    }
    else
    {
        return MQMig_E_TOOMANY_ROOTDSE ;
    }

    *ppszSchemaDefName = s_tszSchemaNamingContext ;
    s_fAlreadyInit = TRUE;

    return MQMig_OK ;
}

//+----------------------------------------------
//
//   HRESULT  _GetDefaultNamingContext()
//
//+----------------------------------------------

static HRESULT  _GetDefaultNamingContext( PLDAP pLdap,
                                          TCHAR **ppszDefName )
{
    HRESULT hr = MQMig_OK ;
    LM<LDAPMessage> pRes = NULL ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 NULL,
                                 LDAP_SCOPE_BASE,
                                 L"(objectClass=*)",
                                 NULL,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_QUERY_ROOTDSE ;
        LogMigrationEvent(MigLog_Error, hr, ulRes) ;
        return hr ;
    }
    ASSERT(pRes) ;

    int iCount = ldap_count_entries(pLdap, pRes) ;
    LogMigrationEvent(MigLog_Info, MQMig_I_ROOTDSE_SUCCESS, iCount) ;

    if (iCount == 1)
    {
        LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
        WCHAR **ppValue = ldap_get_values( pLdap,
                                           pEntry,
                                           TEXT("defaultNamingContext")) ;
        if (ppValue && *ppValue)
        {
            ASSERT(*ppszDefName == NULL) ;
            *ppszDefName = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
            _tcscpy(*ppszDefName, *ppValue) ;
            ldap_value_free(ppValue) ;

            LogMigrationEvent(MigLog_Info, MQMig_I_NAME_CONTEXT,
                                                         *ppszDefName) ;
        }
        else
        {
            return MQMig_E_CANT_READ_CONTEXT ;
        }
    }
    else
    {
        return MQMig_E_TOOMANY_ROOTDSE ;
    }

    return MQMig_OK ;
}

//+----------------------------------------------
//
//   HRESULT  InitLDAP() ;
//
//+----------------------------------------------

HRESULT  
InitLDAP( 
	PLDAP *ppLdap,
	TCHAR **ppwszDefName,
	ULONG ulPort
	)
{
    static PLDAP s_pLdap = NULL;
    static PLDAP s_pLdapGC = NULL;

    static BOOL s_fAlreadyInit = FALSE;
    static BOOL s_fAlreadyInitGC = FALSE;

    if (ulPort == LDAP_PORT && s_fAlreadyInit)
    {
        *ppLdap = s_pLdap;
        *ppwszDefName = s_tszDefaultName;

        return MQMig_OK;
    }

    if (ulPort == LDAP_GC_PORT && s_fAlreadyInitGC)
    {
        *ppLdap = s_pLdapGC;
        *ppwszDefName = s_tszDefaultName;

        return MQMig_OK;
    }

    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD dwSize = sizeof(wszComputerName) / sizeof(wszComputerName[0]);
    GetComputerName( 
		wszComputerName,
		&dwSize 
		);

    PLDAP pLdap = NULL;
    if (ulPort == LDAP_PORT)
    {
        pLdap = ldap_init(wszComputerName, LDAP_PORT);
    }
    else
    {
        pLdap = ldap_init(wszComputerName, LDAP_GC_PORT);
    }

    if (!pLdap)
    {
        return MQMig_E_CANT_INIT_LDAP;
    }

    int iLdapVersion;
    int iret = ldap_get_option( 
					pLdap,
					LDAP_OPT_PROTOCOL_VERSION,
					(void*) &iLdapVersion 
					);
    if (iLdapVersion != LDAP_VERSION3)
    {
        iLdapVersion = LDAP_VERSION3;
        iret = ldap_set_option( 
					pLdap,
					LDAP_OPT_PROTOCOL_VERSION,
					(void*) &iLdapVersion 
					);
    }

    iret = ldap_set_option( 
				pLdap,
				LDAP_OPT_AREC_EXCLUSIVE,
				LDAP_OPT_ON  
				);

    ULONG ulRes = ldap_bind_s(pLdap, L"", NULL, LDAP_AUTH_NEGOTIATE);
    LogMigrationEvent(MigLog_Info, MQMig_I_LDAP_INIT,
                             wszComputerName, pLdap->ld_version, ulRes);

    if (ulRes != LDAP_SUCCESS)
    {
        return MQMig_E_CANT_BIND_LDAP;
    }

    if (s_tszDefaultName == NULL)
    {
        HRESULT hr =  _GetDefaultNamingContext( 
							pLdap,
							&s_tszDefaultName 
							);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    *ppLdap = pLdap;
    *ppwszDefName = s_tszDefaultName;

    if (ulPort == LDAP_PORT)
    {
        s_fAlreadyInit = TRUE;
        s_pLdap = pLdap;
    }
    else
    {
        s_fAlreadyInitGC = TRUE;
        s_pLdapGC = pLdap;
    }
    return MQMig_OK;
}

//+----------------------------------------------
//
//  HRESULT CreateSite()
//
//+----------------------------------------------

HRESULT CreateSite( GUID   *pSiteGuid,
                    LPTSTR  pszSiteNameIn,
                    BOOL    fForeign,
                    USHORT  uiInterval1,
                    USHORT  uiInterval2)
{
    PLDAP pLdap = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    P<TCHAR>  pszBuf = NULL ;
    LPTSTR  pszSiteName = NULL ;
    static  DWORD  s_dwSiteNumber = 0 ;
    static  DWORD  s_dwForeignSiteNumber = 0 ;

    BOOL fOk = IsObjectNameValid(pszSiteNameIn);

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    if (fOk)
    {
        pszSiteName = pszSiteNameIn ;
    }
    else
    {
        //
        // an illegal character was found. Replace site name with an
        // internal name.
        //
        if (fForeign)
        {
            s_dwForeignSiteNumber++ ;
            pszBuf = new TCHAR[ DEFAULT_FOREIGN_SITE_NAME_LEN + 20 ] ;
            _stprintf(pszBuf, TEXT("%s%lu"),
                  DEFAULT_FOREIGN_SITE_NAME_PREFIX, s_dwForeignSiteNumber) ;
        }
        else
        {
            s_dwSiteNumber++ ;
            pszBuf = new TCHAR[ DEFAULT_SITE_NAME_LEN + 20 ] ;
            _stprintf(pszBuf, TEXT("%s%lu"),
                                DEFAULT_SITE_NAME_PREFIX, s_dwSiteNumber) ;
        }
        pszSiteName = pszBuf ;

        LogMigrationEvent( MigLog_Event,
                           MQMig_I_SITE_NAME_CHANGED,
                           pszSiteNameIn,
                           pszSiteName ) ;
        //
        // BUG 5211.
        // Save new name in mqseqnum.ini to replicate it later.
        //
        TCHAR *pszFileName = GetIniFileName ();
        //
        // save number of all sites with changed name in .ini
        //
        TCHAR szBuf[10];
        _ltot( s_dwForeignSiteNumber + s_dwSiteNumber, szBuf, 10 );
        BOOL f = WritePrivateProfileString( MIGRATION_CHANGED_NT4SITE_NUM_SECTION,
                                            MIGRATION_CHANGED_NT4SITE_NUM_KEY,
                                            szBuf,
                                            pszFileName ) ;
        ASSERT(f) ;
        
        //
        // save new site name
        //
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), 
			MIGRATION_CHANGED_NT4SITE_KEY, s_dwForeignSiteNumber + s_dwSiteNumber);

        unsigned short *lpszSiteId ;	        
        UuidToString( pSiteGuid, &lpszSiteId ) ;  
        f = WritePrivateProfileString( 
                                MIGRATION_CHANGED_NT4SITE_SECTION,
                                tszKeyName,
                                lpszSiteId,
                                pszFileName ) ;
        RpcStringFree( &lpszSiteId ) ;
        ASSERT(f);

    }

    #define PATH_LEN  1024
    WCHAR  wszPath[ PATH_LEN ] ;

    wcscpy(wszPath, CN_PREFIX) ;
    wcscat(wszPath, pszSiteName) ;
    wcscat(wszPath, LDAP_COMMA) ;
    wcscat(wszPath, SITES_ROOT) ;
    wcscat(wszPath, pwszDefName) ;

    ASSERT(wcslen(wszPath) < PATH_LEN) ;

    #define         cAlloc  8
    PLDAPMod        rgMods[ cAlloc ];
    WCHAR           *ppwszObjectClassVals[2];
    WCHAR           *ppwszCnVals[2];
    WCHAR           *ppwszStubVals[2];
    WCHAR           *ppwszForeignVals[2];
    WCHAR           *ppwszInterval1Vals[2];
    WCHAR           *ppwszInterval2Vals[2];
    PLDAP_BERVAL    pBValsGuid[2];
    LDAP_BERVAL     BValGuid;
    LDAPMod         ModObjectClass;
    LDAPMod         ModCn;
    LDAPMod         ModGuid;
    LDAPMod         ModStub;
    LDAPMod         ModForeign;
    LDAPMod         ModInterval1;
    LDAPMod         ModInterval2;

    DWORD  dwIndex = 0 ;
    rgMods[ dwIndex ] = &ModCn;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModObjectClass;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModStub;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModInterval1;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModInterval2;
    //
    // For debug, always keep the guid the last in the list.
    //
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModGuid;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL ;
    dwIndex++ ;
    ASSERT(dwIndex == (cAlloc-1)) ;

    //
    // objectClass
    //
    ppwszObjectClassVals[0] = TEXT("Site") ;
    ppwszObjectClassVals[1] = NULL ;

    ModObjectClass.mod_op      = LDAP_MOD_ADD ;
    ModObjectClass.mod_type    = L"objectClass" ;
    ModObjectClass.mod_values  = (PWSTR *) ppwszObjectClassVals ;

    //
    // Cn (site name)
    //
    ppwszCnVals[0] = pszSiteName ;
    ppwszCnVals[1] = NULL ;

    ModCn.mod_op      = LDAP_MOD_ADD ;
    ModCn.mod_type    = const_cast<WCHAR*> (MQ_S_NAME_ATTRIBUTE) ;
    ModCn.mod_values  = (PWSTR *) ppwszCnVals ;

    //
    // objectGUID
    //
    pBValsGuid[0] = &BValGuid;
    pBValsGuid[1] = NULL;

    BValGuid.bv_len = sizeof(GUID) ;
    BValGuid.bv_val = (PCHAR) pSiteGuid ;

    ModGuid.mod_op      = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    ModGuid.mod_type    = const_cast<WCHAR*> (MQ_S_ID_ATTRIBUTE) ;
    ModGuid.mod_values  = (PWSTR *)pBValsGuid;

    //
    // stub
    //
    WCHAR wszStub[ 24 ] ;
    _stprintf(wszStub, TEXT("1")) ;

    ppwszStubVals[0] = wszStub ;
    ppwszStubVals[1] = NULL ;

    ModStub.mod_op      = LDAP_MOD_ADD ;
    ModStub.mod_type    = const_cast<WCHAR*> (MQ_S_NT4_STUB_ATTRIBUTE) ;
    ModStub.mod_values  = (PWSTR *) ppwszStubVals ;

    //
    // interval1
    //
    WCHAR wszInterval1[ 24 ];
    _ltow( uiInterval1, wszInterval1, 10 );

    ppwszInterval1Vals[0] = wszInterval1 ;
    ppwszInterval1Vals[1] = NULL ;

    ModInterval1.mod_op      = LDAP_MOD_ADD ;
    ModInterval1.mod_type    = const_cast<WCHAR*> (MQ_S_INTERVAL1) ;
    ModInterval1.mod_values  = (PWSTR *) ppwszInterval1Vals ;

    //
    // interval2
    //
    WCHAR wszInterval2[ 24 ];
    _ltow( uiInterval2, wszInterval2, 10 );

    ppwszInterval2Vals[0] = wszInterval2 ;
    ppwszInterval2Vals[1] = NULL ;

    ModInterval2.mod_op      = LDAP_MOD_ADD ;
    ModInterval2.mod_type    = const_cast<WCHAR*> (MQ_S_INTERVAL2) ;
    ModInterval2.mod_values  = (PWSTR *) ppwszInterval2Vals ;

    if (fForeign)
    {
        //
        // This is a boolean attribute. Specify it as "TRUE", not 1.
        //
        WCHAR wszForeign[ 24 ] ;
        _stprintf(wszForeign, TEXT("TRUE")) ;

        ppwszForeignVals[0] = wszForeign ;
        ppwszForeignVals[1] = NULL ;

        ModForeign.mod_op      = LDAP_MOD_ADD ;
        ModForeign.mod_type    = const_cast<WCHAR*> (MQ_S_FOREIGN_ATTRIBUTE) ;
        ModForeign.mod_values  = (PWSTR *) ppwszForeignVals ;

        dwIndex-- ; // replace the NULL.
        rgMods[ dwIndex ] = &ModForeign;
        dwIndex++ ;
        rgMods[ dwIndex ] = NULL ;
        dwIndex++ ;
        ASSERT(dwIndex == cAlloc) ;
    }   

    //
    // Now, we'll do the write...
    //
    ULONG ulRes = ldap_add_s( pLdap,
                              wszPath,
                              rgMods ) ;
    if ((ulRes == LDAP_ALREADY_EXISTS) && g_fAlreadyExistOK)
    {
        LogMigrationEvent( MigLog_Warning,
                                 MQMig_I_SITE_ALREADY_EXIST, wszPath ) ;
    }
    else if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_CREATE_SITE ;
        LogMigrationEvent(MigLog_Error, hr, wszPath, ulRes) ;
        return hr ;
    }
    else
    {
        LogMigrationEvent(MigLog_Trace, MQMig_I_SITE_CREATED, wszPath) ;
    }

    //
    // Wow, the site was created!
    // So now create the "Servers" container.
    //
    if (fForeign)
    {
        //
        // Foreign sites must not have a servers container. otherwise,
        // routing to foreign machines won't work.
        // So create the servers container only for "real" msmq sites.
        //
        return MQMig_OK ;
    }

    //
    // if we are in the web mode and name of site is changed and 
    // site creation failed with ALREADY_EXISTS it means that we run 
    // already old version of migtool with bug (new name of site was 
    // incorrect if scan database was selected because of static variable init
    // in analyse phase. So we have to get old name to create server object
    // under existed site.   
    // Even we are not in the web mode site name can be changed between the first
    // and second time of migration tool running. So, get the site name according
    // to the site guid
    //
    P<TCHAR> pszName = NULL;

    if (!fOk       &&                   //site name was changed
        ulRes == LDAP_ALREADY_EXISTS    //site was created 
        )
    {
        PROPID propPath = PROPID_S_PATHNAME;
        PROPVARIANT varPath;
        varPath.vt = VT_NULL;
        varPath.pwszVal = NULL ;        

        CDSRequestContext requestContext( e_DoNotImpersonate,
                            e_ALL_PROTOCOLS);         

        HRESULT hr = DSCoreGetProps( 
                        MQDS_SITE,
                        NULL, // pathname
                        pSiteGuid,    //guid
                        1,
                        &propPath,
                        &requestContext,
                        &varPath ) ;
        DBG_USED(hr);
        ASSERT(SUCCEEDED(hr));

        DWORD len = _tcslen(varPath.pwszVal);
        pszName =  new TCHAR [ len + 1];
        _tcscpy (pszName, varPath.pwszVal);
        pszSiteName = pszName;        
        delete varPath.pwszVal;
    }

    wcscpy(wszPath, SERVERS_PREFIX) ;
    wcscat(wszPath, pszSiteName) ;
    wcscat(wszPath, LDAP_COMMA) ;
    wcscat(wszPath, SITES_ROOT) ;
    wcscat(wszPath, pwszDefName) ;

    ASSERT(wcslen(wszPath) < PATH_LEN) ;
    #undef PATH_LEN

    dwIndex = 0 ;
    rgMods[ dwIndex ] = &ModCn;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModObjectClass;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL ;
    dwIndex++ ;
    ASSERT(dwIndex <= cAlloc) ;
    #undef  cAlloc

    //
    // objectClass
    //
    ppwszObjectClassVals[0] = TEXT("serversContainer") ;
    ppwszObjectClassVals[1] = NULL ;

    ModObjectClass.mod_op      = LDAP_MOD_ADD ;
    ModObjectClass.mod_type    = L"objectClass" ;
    ModObjectClass.mod_values  = (PWSTR *) ppwszObjectClassVals ;

    //
    // Cn (site name)
    //
    ppwszCnVals[0] = TEXT("Servers") ;
    ppwszCnVals[1] = NULL ;

    ModCn.mod_op      = LDAP_MOD_ADD ;
    ModCn.mod_type    = TEXT("cn") ;
    ModCn.mod_values  = (PWSTR *) ppwszCnVals ;

    //
    // Now, we'll do the write...
    //
    ulRes = ldap_add_s( pLdap,
                        wszPath,
                        rgMods ) ;
    if ((ulRes == LDAP_ALREADY_EXISTS) && g_fAlreadyExistOK)
    {
        LogMigrationEvent( MigLog_Warning,
                                MQMig_I_SERVERS_ALREADY_EXIST, wszPath ) ;
    }
    else if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_CREATE_SERVERS ;
        LogMigrationEvent(MigLog_Error, hr, wszPath, ulRes) ;
        return hr ;
    }
    else
    {
        LogMigrationEvent(MigLog_Trace, MQMig_I_SERVERS_CREATED, wszPath) ;
    }

    return MQMig_OK ;
}

//+---------------------------------------------------------------
//
//   HRESULT  ReadFirstNT5Usn()
//
//  This one is called when migration is over, to retrieve and
//  register the last USN used in NT5 DS. This value is necessary
//  for future replications to NT4 PSCs.
//
//+-----------------------------------------------------------------

HRESULT  ReadFirstNT5Usn(TCHAR *wszHighestUsn)
{
    PLDAP pLdap = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    LM<LDAPMessage> pRes = NULL ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 NULL,
                                 LDAP_SCOPE_BASE,
                                 L"(objectClass=*)",
                                 NULL,
                                 0,
                                 &pRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_QUERY_ROOTDSE ;
        LogMigrationEvent(MigLog_Error, hr, ulRes) ;
        return hr ;
    }
    ASSERT(pRes) ;

    int iCount = ldap_count_entries(pLdap, pRes) ;
    LogMigrationEvent(MigLog_Info, MQMig_I_ROOTDSE_SUCCESS, iCount) ;

    if (iCount == 1)
    {
        LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
        WCHAR **ppValue = ldap_get_values( pLdap,
                                           pEntry,
                                           TEXT("highestCommittedUSN" )) ;
        if (ppValue && *ppValue)
        {
            wcscpy(wszHighestUsn, *ppValue) ;
            ldap_value_free(ppValue) ;

            LogMigrationEvent(MigLog_Info, MQMig_I_HIGHEST_USN,
                                                         wszHighestUsn) ;
        }
        else
        {
            return MQMig_E_CANT_READ_HIGHESTUSN ;
        }
    }
    else
    {
        return MQMig_E_TOOMANY_ROOTDSE ;
    }

    return MQMig_OK ;
}

//+-----------------------------------------
//
//  HRESULT  _GetUSNChanged
//
//+-----------------------------------------

HRESULT _GetUSNChanged (
                    IN  PLDAP   pLdapGC,
                    IN  TCHAR   *wszFilter,
                    IN  __int64 i64LastUsn,
                    OUT __int64 *pi64MinUsn
                    )
{
    PWSTR rgAttribs[2] = {NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (USNCHANGED_ATTRIBUTE);

    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdapGC,
                                 EMPTY_DEFAULT_CONTEXT,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 rgAttribs, //ppAttributes,
                                 0,
                                 &pRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error,
                           MQMig_E_LDAP_SEARCH_FAILED,
                           EMPTY_DEFAULT_CONTEXT, wszFilter, ulRes) ;
        return MQMig_E_LDAP_SEARCH_FAILED ;
    }
    ASSERT(pRes) ;

    LogMigrationEvent( MigLog_Info,
                       MQMig_I_LDAP_SEARCH,
                       EMPTY_DEFAULT_CONTEXT, wszFilter ) ;

    __int64 i64MinUsn = i64LastUsn;

    int iCount = ldap_count_entries(pLdapGC, pRes) ;
    UNREFERENCED_PARAMETER(iCount);
    
    LDAPMessage *pEntry = ldap_first_entry(pLdapGC, pRes) ;
    __int64 i64CurrentUsn;

    while(pEntry)
    {
        WCHAR **ppUSNChanged = ldap_get_values( pLdapGC,
                                                pEntry,
                        const_cast<LPWSTR> (USNCHANGED_ATTRIBUTE) ) ;
        ASSERT(ppUSNChanged) ;

        _stscanf(*ppUSNChanged, TEXT("%I64d"), &i64CurrentUsn) ;
        if (i64CurrentUsn < i64MinUsn)
        {
            i64MinUsn = i64CurrentUsn;
        }

        int i = ldap_value_free( ppUSNChanged ) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdapGC, pPrevEntry) ;
    }

    *pi64MinUsn = i64MinUsn;

    return MQMig_OK;

}

//+-----------------------------------------
//
//  HRESULT  FindMinMSMQUsn()
//
//+-----------------------------------------

HRESULT FindMinMSMQUsn(TCHAR *wszMinUsn)
{
    PLDAP pLdapGC = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdapGC, &pwszDefName, LDAP_GC_PORT) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    P<WCHAR> pwcsSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdapGC, &pwcsSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    static __int64 i64LastUsn = 0;

    TCHAR wszHighestUsn[ SEQ_NUM_BUF_LEN ] ;
    hr = ReadFirstNT5Usn(wszHighestUsn) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_FIRST_USN, hr) ;
        return hr ;
    }
    _stscanf(wszHighestUsn, TEXT("%I64d"), &i64LastUsn) ;

    __int64 i64CurrentMinUsn;
    __int64 i64MinUsn = i64LastUsn;

    TCHAR  wszFilter[ 512 ] ;
    TCHAR  wszCategoryName[ 256 ];

    TCHAR *arCategoryNames[e_MSMQ_NUMBER_OF_CLASSES] = {
                                const_cast<LPWSTR> (x_ComputerConfigurationCategoryName),
                                const_cast<LPWSTR> (x_QueueCategoryName),
                                const_cast<LPWSTR> (x_ServiceCategoryName),
                                const_cast<LPWSTR> (x_LinkCategoryName),
                                const_cast<LPWSTR> (x_UserCategoryName),
                                const_cast<LPWSTR> (x_SettingsCategoryName),
                                const_cast<LPWSTR> (x_SiteCategoryName),
                                const_cast<LPWSTR> (x_ServerCategoryName),
                                const_cast<LPWSTR> (x_ComputerCategoryName),
                                const_cast<LPWSTR> (x_MQUserCategoryName)
                                };

    for ( DWORD i = e_MSMQ_COMPUTER_CONFIGURATION_CLASS; i < e_MSMQ_NUMBER_OF_CLASSES; i++)
    {
        _stprintf(wszCategoryName, TEXT("%s,%s"), arCategoryNames[i],pwcsSchemaDefName);
        _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;
        _tcscat(wszFilter, wszCategoryName) ;
        _tcscat(wszFilter, TEXT("))")) ;
        hr = _GetUSNChanged (pLdapGC, wszFilter, i64LastUsn, &i64CurrentMinUsn);

        if (i64CurrentMinUsn < i64MinUsn)
        {
            i64MinUsn = i64CurrentMinUsn;
        }
    }

    _stprintf(wszMinUsn, TEXT("%I64d"), i64MinUsn) ;

    return MQMig_OK;
}

//+-----------------------------------------
//
//  HRESULT  CreateMsmqContainer()
//
//+-----------------------------------------

HRESULT  CreateMsmqContainer(TCHAR wszContainerName[])
{
    PLDAP pLdap = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    #define PATH_LEN  1024
    WCHAR  wszPath[ PATH_LEN ] ;

    _tcscpy(wszPath, OU_PREFIX) ;
    _tcscat(wszPath, wszContainerName) ;
    _tcscat(wszPath, LDAP_COMMA) ;
    _tcscat(wszPath, pwszDefName) ;

    ASSERT(wcslen(wszPath) < PATH_LEN) ;

    #define         cAlloc  3
    PLDAPMod        rgMods[ cAlloc ];
    WCHAR           *ppwszObjectClassVals[2];
    WCHAR           *ppwszOuVals[2];
    LDAPMod         ModObjectClass;
    LDAPMod         ModOu;

    DWORD  dwIndex = 0 ;
    rgMods[ dwIndex ] = &ModOu;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModObjectClass;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL ;
    dwIndex++ ;
    ASSERT(dwIndex == cAlloc) ;
    #undef  cAlloc

    //
    // objectClass
    //
    ppwszObjectClassVals[0] = CONTAINER_OBJECT_CLASS;
    ppwszObjectClassVals[1] = NULL ;

    ModObjectClass.mod_op      = LDAP_MOD_ADD ;
    ModObjectClass.mod_type    = TEXT("objectClass") ;
    ModObjectClass.mod_values  = (PWSTR *) ppwszObjectClassVals ;

    //
    // Ou (container name)
    //
    ppwszOuVals[0] = wszContainerName ;
    ppwszOuVals[1] = NULL ;

    ModOu.mod_op      = LDAP_MOD_ADD ;
    ModOu.mod_type    = TEXT("ou") ;
    ModOu.mod_values  = (PWSTR *) ppwszOuVals ;

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    //
    // Now, we'll do the write...
    //
    ULONG ulRes = ldap_add_s( pLdap,
                              wszPath,
                              rgMods ) ;
    if ((ulRes == LDAP_ALREADY_EXISTS) && g_fAlreadyExistOK)
    {
        hr = MQMig_I_CONTAINER_ALREADY_EXIST ;
        LogMigrationEvent(MigLog_Warning, hr, wszPath) ;
    }
    else if (ulRes != LDAP_SUCCESS)
    {
        hr = MQMig_E_CANT_CREATE_CONTNER ;
        LogMigrationEvent(MigLog_Error, hr, wszPath, ulRes) ;
    }
    else
    {
        LogMigrationEvent(MigLog_Info, MQMig_I_CREATE_CONTAINER, wszPath) ;
        hr = MQMig_OK ;
    }

    return hr ;
}

//+-----------------------------
//
// UINT  GetNT5SitesCount()
//
//+-----------------------------

UINT  GetNT5SitesCount()
{
    return 0 ;
}

HRESULT PrepareNT5SitesForReplication()
{
    PLDAP pLdap = NULL ;
    TCHAR *pszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdap, &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    P<WCHAR> pwszDN;
    DWORD dwDNSize = _tcslen(SITES_ROOT) + wcslen(pszDefName);
    pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    swprintf(pwszDN, L"%s%s", SITES_ROOT, pszDefName);  
    
    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_SiteCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);

     TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);
    _tcscat(wszFilter, TEXT("))")) ;

    PWSTR rgAttribs[3] = {NULL, NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (MQ_S_NT4_STUB_ATTRIBUTE);
    rgAttribs[1] = const_cast<LPWSTR> (MQ_S_FULL_NAME_ATTRIBUTE);

    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 rgAttribs, //ppAttributes,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_LDAP_SEARCH_FAILED,
                            pwszDN,wszFilter, ulRes) ;
        return MQMig_E_LDAP_SEARCH_FAILED ;
    }
    ASSERT(pRes) ;

    LogMigrationEvent(MigLog_Info, MQMig_I_LDAP_SEARCH, pwszDN,wszFilter );

    int iCount = ldap_count_entries(pLdap, pRes) ;

    if (iCount == 0)
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_NO_SITES_AVAILABLE,
                            pwszDN,wszFilter );
        return MQMig_E_NO_SITES_AVAILABLE ;
    }

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        WCHAR **ppPath = ldap_get_values( pLdap,
                                          pEntry,
                        const_cast<LPWSTR> (MQ_S_FULL_NAME_ATTRIBUTE) ) ;
        ASSERT(ppPath) ;

        WCHAR **ppStub = ldap_get_values( pLdap,
                                          pEntry,
                       const_cast<LPWSTR> (MQ_S_NT4_STUB_ATTRIBUTE) ) ;

        if ( ppPath &&
             (ppStub == NULL ||                     // this attribute is not defined
              _tcscmp(*ppStub, TEXT("1")) != 0) )   // attribute was defined but not by migtool
                                                    // (migtool set 1 as NT4Stub)
        {
            if (ppStub)
            {
                //
                // it was already modified, the last value is 0 => we have to change it twice
                //
                hr = ModifyAttribute(
                     *ppPath,
                     const_cast<WCHAR*> (MQ_S_NT4_STUB_ATTRIBUTE),
                     L"2"
                     );
            }

            hr = ModifyAttribute(
                 *ppPath,
                 const_cast<WCHAR*> (MQ_S_NT4_STUB_ATTRIBUTE),
                 L"0"
                 );
        }
        int i = ldap_value_free( ppStub ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        i = ldap_value_free( ppPath ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    return MQMig_OK;
}

//+---------------------------------------------------------------------
//
//  HRESULT PrepareNT5MachinesForReplication()
//
//  See migrat.cpp, where this function is called, for explanations.
//
//+---------------------------------------------------------------------

HRESULT PrepareNT5MachinesForReplication()
{
    PLDAP pLdap = NULL ;
    TCHAR *pszDefName = NULL ;

    //
    // Use the LDAP port, not GC. The msmqSetting attributes are not
    // literally in GC.
    //
    HRESULT hr =  InitLDAP(&pLdap, &pszDefName, LDAP_PORT) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdap, &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    P<WCHAR> pwszDN;
    DWORD dwDNSize = _tcslen(SITES_ROOT) + wcslen(pszDefName);
    pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    swprintf(pwszDN, L"%s%s", SITES_ROOT, pszDefName);

    //
    // The search filter looks for servers that are NOT flaged as NT4.
    //
    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_SettingsCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);

     TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);
   
    _tcscat(wszFilter, TEXT(")(!(")) ;
    _tcscat(wszFilter, MQ_SET_NT4_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=1)")) ; // NOT NT4
    _tcscat(wszFilter, TEXT("))")) ;


    PWSTR rgAttribs[3] = {NULL, NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (MQ_SET_FULL_PATH_ATTRIBUTE);
    rgAttribs[1] = const_cast<LPWSTR> (MQ_SET_MIGRATED_ATTRIBUTE);

    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 rgAttribs, //ppAttributes,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error,
                           MQMig_E_LDAP_SEARCH_FAILED,
                           pwszDN,wszFilter, ulRes) ;
        return MQMig_E_LDAP_SEARCH_FAILED ;
    }
    ASSERT(pRes) ;

    int iCount = ldap_count_entries(pLdap, pRes) ;

    if (iCount == 0)
    {
        LogMigrationEvent( MigLog_Error,
                           MQMig_E_NO_SERVERS_AVAIL,
                           pwszDN,wszFilter );
        return MQMig_E_NO_SERVERS_AVAIL ;
    }

    LogMigrationEvent( MigLog_Info,
                       MQMig_I_LDAP_SEARCH_COUNT,
                       pwszDN,wszFilter, iCount );

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        WCHAR **ppPath = ldap_get_values( pLdap,
                                          pEntry,
                        const_cast<LPWSTR> (MQ_SET_FULL_PATH_ATTRIBUTE) ) ;
        ASSERT(ppPath) ;

        WCHAR **ppMigrated = ldap_get_values( pLdap,
                                              pEntry,
                       const_cast<LPWSTR> (MQ_SET_MIGRATED_ATTRIBUTE) ) ;

        if ( ppPath  )
        {
            if (ppMigrated)
            {
                //
                // It was already modified, the last value is TRUE so we
                // have to change it twice. Setting again same value does
                // not increment the usnChanged count.
                //
                hr = ModifyAttribute(
                     *ppPath,
                     const_cast<WCHAR*> (MQ_SET_MIGRATED_ATTRIBUTE),
                     L"FALSE"
                     );
            }

            hr = ModifyAttribute(
                 *ppPath,
                 const_cast<WCHAR*> (MQ_SET_MIGRATED_ATTRIBUTE),
                 L"TRUE"
                 );
        }
        int i = ldap_value_free( ppMigrated ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        i = ldap_value_free( ppPath ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    return MQMig_OK;
}

//+------------------------------
//
//  HRESULT PrepareChangedNT4SiteForReplication()
//
//  See migrat.cpp, where this function is called, for explanations.
//
//+------------------------------

HRESULT PrepareChangedNT4SiteForReplication()
{
    TCHAR *pszFileName = GetIniFileName ();
    ULONG ulSiteNum = GetPrivateProfileInt(
                                MIGRATION_CHANGED_NT4SITE_NUM_SECTION,	// address of section name
                                MIGRATION_CHANGED_NT4SITE_NUM_KEY,      // address of key name
                                0,							    // return value if key name is not found
                                pszFileName					    // address of initialization filename);
                                );

    if (ulSiteNum == 0)
    {
        return MQMig_OK;
    }      

    for (ULONG i=0; i<ulSiteNum; i++)
    {
        //
        // for each such site set property to replicate new name to NT4
        //

        TCHAR szCurSiteId[50];
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_CHANGED_NT4SITE_KEY, i+1);
        DWORD dwRetSize =  GetPrivateProfileString(
                                    MIGRATION_CHANGED_NT4SITE_SECTION ,			// points to section name
                                    tszKeyName,	// points to key name
                                    TEXT(""),                 // points to default string
                                    szCurSiteId,          // points to destination buffer
                                    50,                 // size of destination buffer
                                    pszFileName               // points to initialization filename);
                                    );
        if (_tcscmp(szCurSiteId, TEXT("")) == 0 ||
            dwRetSize == 0)     //low resources
        {                                           
            continue;
        }

        //
        // set PROPID_S_NT4_STUB to 2 and then return it to initial state (1)
        // 
        GUID SiteId = GUID_NULL;
        UuidFromString(&(szCurSiteId[0]), &SiteId);

        PROPID propStub = PROPID_S_NT4_STUB;
        PROPVARIANT varStub;
        varStub.vt = VT_UI2;
        varStub.uiVal = 2 ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                            e_ALL_PROTOCOLS);  

        HRESULT hr = DSCoreSetObjectProperties( 
                        MQDS_SITE,
                        NULL, // pathname
                        &SiteId,    //guid
                        1,
                        &propStub,
                        &varStub,
                        &requestContext,
                        NULL ) ;
        ASSERT(SUCCEEDED(hr)) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_PREPARE_NT4SITE_FOR_REPLICATION,
                            szCurSiteId, hr );
        }

        varStub.uiVal = 1 ; // it is NT4 stub so set this flag to 1
        hr = DSCoreSetObjectProperties( 
                    MQDS_SITE,
                    NULL, // pathname
                    &SiteId,    //guid
                    1,
                    &propStub,
                    &varStub,
                    &requestContext,
                    NULL ) ;   
        ASSERT(SUCCEEDED(hr)) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_PREPARE_NT4SITE_FOR_REPLICATION,
                            szCurSiteId, hr );
        }
        
    }

    //
    // don't check result: remove all these sections from .ini
    //   
    BOOL f = WritePrivateProfileString( 
                            MIGRATION_CHANGED_NT4SITE_SECTION,
                            NULL,
                            NULL,
                            pszFileName ) ;
    ASSERT(f) ;

    f = WritePrivateProfileString( 
                        MIGRATION_CHANGED_NT4SITE_NUM_SECTION,
                        NULL,
                        NULL,
                        pszFileName ) ;
    ASSERT(f) ;
    
    return MQMig_OK;
}

//+------------------------------
//
//  HRESULT ModifyAttribute()
//
//+------------------------------

HRESULT ModifyAttribute(
             WCHAR       wszPath[],
             WCHAR       pAttr[],
             WCHAR       pAttrVal[],
             PLDAP_BERVAL *ppBVals
             )
{
    PLDAP pLdap = NULL ;
    TCHAR *pszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    DWORD           dwIndex = 0 ;
    PLDAPMod        rgMods[2];
    WCHAR           *ppwszAttrVals[2];
    LDAPMod         ModAttr ;

    rgMods[ dwIndex ] = &ModAttr;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL;

    ModAttr.mod_op      = LDAP_MOD_REPLACE ;
    ModAttr.mod_type    = pAttr ;

    if (pAttrVal)
    {
        ppwszAttrVals[0] = pAttrVal ;
        ppwszAttrVals[1] = NULL ;

        ModAttr.mod_values  = (PWSTR *) ppwszAttrVals ;
    }
    else if (ppBVals)
    {
        ModAttr.mod_op |= LDAP_MOD_BVALUES;
        ModAttr.mod_values  = (PWSTR *)ppBVals;
    }
    else
    {
        //
        // delete value from entry
        //
        ModAttr.mod_op = LDAP_MOD_DELETE ; 
        ModAttr.mod_values = NULL;
    }

    //
    // Now, we'll do the write...
    //
    ULONG ulRes = ldap_modify_s( pLdap,
                                 wszPath,
                                 rgMods ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_MODIFY_MIG_ATTRIBUTE, wszPath, ulRes) ;
        return MQMig_E_MODIFY_MIG_ATTRIBUTE;
    }
    else
    {
        LogMigrationEvent( MigLog_Info, MQMig_I_MODIFY_MIG_ATTRIBUTE, wszPath) ;
    }

    return MQMig_OK ;
}

//+------------------------------
//
//  HRESULT QueryDS()
// Queries DS using LDAP paging and calls HandleA<ObjectName> function to 
// modify object attributes.
//
//+------------------------------

HRESULT QueryDS(
			IN	PLDAP			pLdap,
			IN	TCHAR			*pszDN,
			IN  TCHAR			*pszFilter,			
			IN	DWORD			dwObjectType,
            IN  PWSTR           *prgAttribs,
            IN  BOOL            fTouchUser
            )
{
    CLdapPageHandle hPage(pLdap);
	hPage = ldap_search_init_page(
                    pLdap,
					pszDN,                   //pwszDN
					LDAP_SCOPE_SUBTREE,     //scope
					pszFilter,              //search filter
					prgAttribs,              //attribute list
					0,                      //attributes only
					NULL,   	            //ServerControls
					NULL,                   //PLDAPControlW   *ClientControls,
                    0,						//PageTimeLimit,
                    0,                      //TotalSizeLimit
					NULL                    //PLDAPSortKey SortKeys
                    );

	ULONG ulRes;
	HRESULT hr = MQMig_OK;
    
    if (hPage == NULL)
    {
        ulRes = LdapGetLastError();
		hr = MQMig_E_LDAP_SEARCH_INITPAGE_FAILED;
		LogMigrationEvent(MigLog_Error, hr, pszDN, pszFilter, ulRes) ;
        return hr;
    }

    ULONG ulTotalCount;     	
	LM<LDAPMessage> pRes = NULL ;

    ulRes = ldap_get_next_page_s(
                        pLdap,
                        hPage,
                        NULL,						//timeout,
                        RP_DEFAULT_OBJECT_PER_LDAPPAGE,      //ULONG ulPageSize
                        &ulTotalCount,
                        &pRes);

    LogMigrationEvent(MigLog_Info,
						MQMig_I_NEXTPAGE,
						ulRes, pszDN, pszFilter) ;

	ULONG ulPageCount = 0;
	
    while (ulRes == LDAP_SUCCESS)
	{
		ASSERT(pRes);

		ulPageCount++;
        LogMigrationEvent (MigLog_Info, MQMig_I_PAGE_NUMBER, ulPageCount);

        //
        // pass through results on the current page
        //
        int iCount = ldap_count_entries(pLdap, pRes) ;
        LogMigrationEvent(MigLog_Info, MQMig_I_LDAP_PAGE_SEARCH,
                                             iCount, pszDN, pszFilter) ;	   	
		
		LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;		

		while(pEntry)
		{												
			switch(dwObjectType)
			{
			case MQDS_USER:
                if (fTouchUser)
                {
                    hr = TouchAUser (pLdap,
                                     pEntry
                                     );
                }
                else
                {
				    hr = HandleAUser(
							    pLdap,
							    pEntry
							    );
                }
				break;
			
            default:
				ASSERT(0);
				break;
            }

            LDAPMessage *pPrevEntry = pEntry ;
			pEntry = ldap_next_entry(pLdap, pPrevEntry) ;	    			
		}

        ldap_msgfree(pRes) ;
        pRes = NULL ;

		ulRes = ldap_get_next_page_s(
                        pLdap,
                        hPage,
                        NULL,						//timeout,
                        RP_DEFAULT_OBJECT_PER_LDAPPAGE,      //ULONG ulPageSize
                        &ulTotalCount,
                        &pRes);

        LogMigrationEvent(MigLog_Info,
						MQMig_I_NEXTPAGE,
						ulRes, pszDN, pszFilter) ;
	}

	if (ulRes != LDAP_NO_RESULTS_RETURNED)
	{
		hr = MQMig_E_LDAP_GET_NEXTPAGE_FAILED;
		LogMigrationEvent(MigLog_Error,
						hr, pszDN, pszFilter, ulRes ) ; 		
	}	
    return hr;

}

//+------------------------------
//
//  HRESULT PrepareCurrentUserForReplication()
//
//  See migrat.cpp, where this function is called, for explanations.
//
//+------------------------------

HRESULT PrepareCurrentUserForReplication()
{
    HRESULT hr = MQMig_OK;
       
    HANDLE hToken = NULL ;

    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &hToken))    
    {
        hr = GetLastError ();
        LogMigrationEvent(MigLog_Error, MQMig_E_OPEN_PROCESS_TOKEN, hr);						
        return hr;
    }
 
    P<TCHAR> szUserSid;
    hr = GetCurrentUserSid (hToken, &szUserSid);
    CloseHandle (hToken);

    if (FAILED(hr))
    {       					
        return hr;  
    }    
    
    PLDAP pLdapGC = NULL ;
    TCHAR *pszDefName = NULL ;

    hr =  InitLDAP(&pLdapGC, &pszDefName, LDAP_GC_PORT) ;
    if (FAILED(hr))
    {
        return hr ;
    }    

    //
    // we are looking for all users and msmq users in GC,
    // so we need to start from the root
    // => redefine default context to empty string
    //
    pszDefName = EMPTY_DEFAULT_CONTEXT;

    DWORD dwDNSize = wcslen(pszDefName) ;
    P<WCHAR> pwszDN  = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, pszDefName);
    
    TCHAR  wszFilter[ 512 ] ;    
    
    _tcscpy(wszFilter, TEXT("(&("));
    _tcscat(wszFilter, MQ_U_SID_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=")) ;    
    _tcscat(wszFilter, szUserSid);
    _tcscat(wszFilter, TEXT("))"));

    PWSTR rgAttribs[3] = {NULL, NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (MQ_U_DESCRIPTION_ATTRIBUTE);  
    rgAttribs[1] = const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE);

    hr = QueryDS(   pLdapGC,			
                    pwszDN,
                    wszFilter,			
                    MQDS_USER,
                    rgAttribs,
                    TRUE
                );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migqueue.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migqueue.cpp

Abstract:

    Migration NT4 Queue objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include "mqtypes.h"
#include "mqprops.h"

#include "migqueue.tmh"

//-------------------------------------------------
//
//  HRESULT InsertQueueInNT5DS( GUID *pQueueGuid )
//
//-------------------------------------------------
HRESULT InsertQueueInNT5DS(
               IN LPWSTR                pwszQueueName ,
               IN SECURITY_DESCRIPTOR   *pQsd,
               IN GUID                  *pQueueGuid,
               IN LPWSTR                pwszLabel,
               IN GUID                  *pType,
               IN BOOL                  fJournal,
               IN ULONG                 ulQuota,
               IN short                 iBaseP,
               IN DWORD                 dwJQuota,
               IN BOOL                  fAuthn,
               IN DWORD                 dwPrivLevel,
               IN GUID                  *pOwnerGuid,
               IN BOOL                  fTransact,
               IN UINT                  iIndex,
               IN BOOL                  fIsTheSameMachine
               )

{
    DBG_USED(iIndex);
#ifdef _DEBUG
    unsigned short *lpszGuid ;
    UuidToString( pQueueGuid,
                  &lpszGuid ) ;

    LogMigrationEvent(MigLog_Info, MQMig_I_QUEUE_MIGRATED,
                                        iIndex,
                                        pwszQueueName,
                                        pwszLabel,
                                        lpszGuid ) ;
    RpcStringFree( &lpszGuid ) ;
#endif
    if (g_fReadOnly)
    {
        return S_OK;
    }
    //
    // Prepare the properties for DS call.
    //
    LONG cAlloc = 13;
    P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];
    P<PROPID>      paPropId  = new PROPID[ cAlloc ];
    DWORD          PropIdCount = 0;

    paPropId[ PropIdCount ] = PROPID_Q_LABEL;    //PropId
    paVariant[ PropIdCount ].vt = VT_LPWSTR;     //Type
    paVariant[ PropIdCount ].pwszVal = pwszLabel;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_TYPE;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
    paVariant[ PropIdCount ].puuid = pType;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_JOURNAL;
    paVariant[ PropIdCount ].vt = VT_UI1;
    paVariant[ PropIdCount ].bVal = (unsigned char) fJournal;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_QUOTA;
    paVariant[ PropIdCount ].vt = VT_UI4;
    paVariant[ PropIdCount ].ulVal = ulQuota;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_BASEPRIORITY;
    paVariant[ PropIdCount ].vt = VT_I2;
    paVariant[ PropIdCount ].iVal = iBaseP;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_JOURNAL_QUOTA;
    paVariant[ PropIdCount ].vt = VT_UI4;
    paVariant[ PropIdCount ].ulVal = dwJQuota;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_AUTHENTICATE ;
    paVariant[ PropIdCount ].vt = VT_UI1;
    paVariant[ PropIdCount ].bVal = (unsigned char) fAuthn;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_PRIV_LEVEL ;
    paVariant[ PropIdCount ].vt = VT_UI4;
    paVariant[ PropIdCount ].ulVal = dwPrivLevel ;
    PropIdCount++;
    DWORD SetPropIdCount = PropIdCount;

    //
    // all properties below are for create object only!
    //
    paPropId[ PropIdCount ] = PROPID_Q_PATHNAME;    //PropId
    paVariant[ PropIdCount ].vt = VT_LPWSTR;        //Type
    paVariant[PropIdCount].pwszVal = pwszQueueName ;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_MASTERID;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
    paVariant[ PropIdCount ].puuid = pOwnerGuid;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_TRANSACTION ;
    paVariant[ PropIdCount ].vt = VT_UI1;
    paVariant[ PropIdCount ].bVal = (unsigned char) fTransact;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_Q_NT4ID ;
    paVariant[ PropIdCount ].vt = VT_CLSID;
    paVariant[ PropIdCount ].puuid = pQueueGuid ;
    PropIdCount++;

    ASSERT((LONG) PropIdCount <= cAlloc) ;

    ASSERT(pQsd && IsValidSecurityDescriptor(pQsd)) ;
    if (pQsd)
    {
        paPropId[ PropIdCount ] = PROPID_Q_SECURITY ;
        paVariant[ PropIdCount ].vt = VT_BLOB ;
        paVariant[ PropIdCount ].blob.pBlobData = (BYTE*) pQsd ;
        paVariant[ PropIdCount ].blob.cbSize =
                                     GetSecurityDescriptorLength(pQsd) ;
        PropIdCount++;
    }

    ASSERT((LONG) PropIdCount <= cAlloc) ;

    static LPWSTR s_pwszFullPathName = NULL;
    static ULONG  s_ulProvider = 0;

    HRESULT hr = MQMig_OK;
    if (g_dwMyService == SERVICE_PSC)
    {
        //
        // this is PSC, assume that object exist, try to set properties
        //
        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);

        hr = DSCoreSetObjectProperties (  MQDS_QUEUE,
                                          NULL,
                                          pQueueGuid,
                                          SetPropIdCount,
                                          paPropId,
                                          paVariant,
                                          &requestContext,
                                          NULL );
    }

    if ((hr == MQ_ERROR_QUEUE_NOT_FOUND) ||
        (g_dwMyService == SERVICE_PEC))
    {
        if (FAILED(hr))
        {
            //
            // we are here only if this machine is PSC. In that case we have
            // reset flag fIsTheSameMachine since it is possible the next situation:
            // migrate queue1 of PSC succeded
            // queue2 of PSC exists only on PSC (not yet replicated to PEC)
            // it means that Set failed, it is the same machine that was at the
            // previous step but we don't know its full path name
            //
            ASSERT (g_dwMyService == SERVICE_PSC);
            fIsTheSameMachine = FALSE;
        }

        if (fIsTheSameMachine)
        {
            //
            // we can use machine properties we got before
            //
            ASSERT (g_dwMyService == SERVICE_PEC);
            ASSERT (s_pwszFullPathName);
        }
        else
        {
            //
            // we have to get machine properties
            //
            if (s_pwszFullPathName)
            {
                delete s_pwszFullPathName;
                s_pwszFullPathName = NULL;
            }
        }

        hr = DSCoreCreateMigratedObject( MQDS_QUEUE,
                                         pwszQueueName,
                                         PropIdCount,
                                         paPropId,
                                         paVariant,
                                         0,        // ex props
                                         NULL,     // ex props
                                         NULL,     // ex props
                                         NULL,
                                         NULL,
                                         NULL,
                                         fIsTheSameMachine, //use full path name
                                         !fIsTheSameMachine,//return full path name
                                         &s_pwszFullPathName,
                                         &s_ulProvider
                                        );

        if ((hr == MQ_ERROR_QUEUE_EXISTS) && g_fAlreadyExistOK)
        {
            hr = MQMig_OK ;
        }
        if (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM) ||
            hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX) ||
            hr == HRESULT_FROM_WIN32(E_FAIL) ||
            hr == MQ_ERROR_CANNOT_CREATE_ON_GC ||
            hr == MQ_ERROR_ILLEGAL_QUEUE_PATHNAME)
        {
            //
            // Error "ERROR_DS_UNWILLING_TO_PERFORM" can be returned if queue path name
            // or queue label contain illegal symbols (like "+").
            // Error "ERROR_DS_INVALID_DN_SYNTAX" can be returned if queue path name
            // or queue label contain illegal symbols (like ",").
            // Error "E_FAIL" can be returned if queue path name
            // or queue label contain illegal symbols (like """ - quota).
            //
            // In case of PSC instead of all these errors return code is
            // MQ_ERROR_CANNOT_CREATE_ON_GC if msmqConfiguration object is in another
            // domain than PSC domain.
            // Exapmle: PEC and PSC are both DC, PSC's msmqConfiguration object is
            // in the PEC domain under msmqComputers container.
            //


            LogMigrationEvent(MigLog_Event, MQMig_E_ILLEGAL_QUEUENAME, pwszQueueName, hr) ;
            hr = MQMig_E_ILLEGAL_QUEUENAME;
        }
    }

    return hr ;
}

//-------------------------------------------
//
//  HRESULT MigrateQueues()
//
//-------------------------------------------


#define INIT_QUEUE_COLUMN(_ColName, _ColIndex, _Index)              \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateQueues()
{
    UINT cQueues = 0 ;
    HRESULT hr;
    if (g_dwMyService == SERVICE_PSC)
    {
        hr = GetAllQueuesInSiteCount( &g_MySiteGuid,
                                      &cQueues );
    }
    else
    {
        hr =  GetAllQueuesCount(&cQueues ) ;
    }
    CHECK_HR(hr) ;

#ifdef _DEBUG
    LogMigrationEvent(MigLog_Info, MQMig_I_QUEUES_COUNT, cQueues) ;
#endif

    if (cQueues == 0)
    {
        return MQMig_I_NO_QUEUES_AVAIL ;
    }

    LONG cAlloc = 17 ;
    LONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_QUEUE_COLUMN(Q_INSTANCE,      iGuidIndex,      cbColumns) ;
    INIT_QUEUE_COLUMN(Q_TYPE,          iTypeIndex,      cbColumns) ;
    INIT_QUEUE_COLUMN(Q_OWNERID,       iOwnerIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_PATHNAME1,     iName1Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_PATHNAME2,     iName2Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_LABEL,         iLabelIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_JOURNAL,       iJournalIndex,   cbColumns) ;
    INIT_QUEUE_COLUMN(Q_QUOTA,         iQuotaIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_BASEPRIORITY,  iBasePIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_JQUOTA,        iJQuotaIndex,    cbColumns) ;
    INIT_QUEUE_COLUMN(Q_AUTH,          iAuthnIndex,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_PRIVLVL,       iPrivLevelIndex, cbColumns) ;
    INIT_QUEUE_COLUMN(Q_TRAN,          iTransactIndex,  cbColumns) ;
    INIT_QUEUE_COLUMN(Q_SECURITY1,     iSecD1Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_SECURITY2,     iSecD2Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_SECURITY3,     iSecD3Index,     cbColumns) ;
    INIT_QUEUE_COLUMN(Q_QMID,          iQMIDIndex,      cbColumns) ;

    #undef  INIT_QUEUE_COLUMN

    ASSERT(cbColumns == cAlloc) ;

    //
    // Restriction. query by machine guid.
    //
    MQDBCOLUMNSEARCH *pColSearch = NULL ;
    MQDBCOLUMNSEARCH ColSearch[1] ;

    if (g_dwMyService == SERVICE_PSC)
    {
        INIT_COLUMNSEARCH(ColSearch[0]) ;
        ColSearch[0].mqdbColumnVal.lpszColumnName = Q_OWNERID_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = Q_OWNERID_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) &g_MySiteGuid ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
        ColSearch[0].mqdbOp = EQ ;

        pColSearch = ColSearch ;
    }

    MQDBSEARCHORDER ColSort;
    ColSort.lpszColumnName = Q_QMID_COL;
    ColSort.nOrder = ASC;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hQueueTable,
                                       pColumns,
                                       cbColumns,
                                       pColSearch,
                                       NULL,
                                       &ColSort,
                                       1,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    HRESULT hr1 = MQMig_OK;
    HRESULT hrPrev = MQMig_OK;

    GUID PrevId = GUID_NULL;
    GUID CurId = GUID_NULL;
    BOOL fTryToCreate = TRUE;

    while(SUCCEEDED(status))
    {
        if (iIndex >= cQueues)
        {
            status = MQMig_E_TOO_MANY_QUEUES ;
            break ;
        }

        //
        // Migrate each queue.
        //
        //
        // Get one name buffer from both name columns.
        //
        P<BYTE> pwzBuf = NULL ;
        DWORD  dwIndexs[2] = { iName1Index, iName2Index } ;
        HRESULT hr =  BlobFromColumns( pColumns,
                                       dwIndexs,
                                       2,
                                       (BYTE**) &pwzBuf ) ;
        CHECK_HR(hr) ;
        WCHAR *wszQueueName = (WCHAR*) (pwzBuf + sizeof(DWORD)) ;

        DWORD dwSize;
        memcpy (&dwSize, pwzBuf, sizeof(DWORD)) ;
        dwSize = (dwSize / sizeof(TCHAR)) - 1;
        ASSERT (wszQueueName[dwSize] == _T('\0'));
        wszQueueName[dwSize] = _T('\0');

        P<BYTE> pSD = NULL ;
        DWORD  dwSDIndexs[3] = { iSecD1Index, iSecD2Index, iSecD3Index } ;
        hr =  BlobFromColumns( pColumns,
                               dwSDIndexs,
                               3,
                               (BYTE**) &pSD ) ;
        CHECK_HR(hr) ;

        SECURITY_DESCRIPTOR *pQsd =
                         (SECURITY_DESCRIPTOR*) (pSD + sizeof(DWORD)) ;        

        BOOL fIsTheSameMachine = TRUE;
        memcpy (&CurId, (GUID*) pColumns[ iQMIDIndex ].nColumnValue, sizeof(GUID));
        if (memcmp (&CurId, &PrevId, sizeof(GUID)) != 0 )
        {
            //
            // it means we move to the queues on the next machine
            // we have to get all needed properties of this machine
            //
            fIsTheSameMachine = FALSE;
            memcpy (&PrevId, &CurId, sizeof(GUID));

            //
            // verify if machine was not migrated because of invalid name.
            // If machine was not migrated we don't try to create this queue
            //
            if (IsObjectGuidInIniFile (&CurId, MIGRATION_MACHINE_WITH_INVALID_NAME))
            {
                fTryToCreate = FALSE;
            }
            else
            {
                fTryToCreate = TRUE;
            }
        }

        if (FAILED(hrPrev))
        {
            //
            // BUG 5230.
            // if previous create failed we can't use full path name and provider,
            // so reset fIsTheSameMachine flag to try to get these values again.
            //
            // It is very important if we failed to create first queue for specific
            // machine and we are going to create the second etc queue for that machine.
            //
            // BUGBUG: if we already successfully created some queues for specific
            // machine and failed at the previous step only, in general we don't need
            // to reset this flag. It decreases performance. Is it important to handle
            // this case too?
            //
            fIsTheSameMachine = FALSE;
        }

        if (!fTryToCreate)
        {
            hr = MQMig_E_INVALID_MACHINE_NAME;
        }
        else
        {
            ASSERT (MQ_MAX_Q_LABEL_LEN ==
                (((DWORD) pColumns[ iLabelIndex ].nColumnLength) / sizeof(TCHAR)) - 1);

            TCHAR *pszLabel = (WCHAR*) pColumns[ iLabelIndex ].nColumnValue;
            ASSERT (pszLabel[MQ_MAX_Q_LABEL_LEN] == _T('\0'));
            pszLabel[MQ_MAX_Q_LABEL_LEN] = _T('\0');

            hr = InsertQueueInNT5DS(
                        wszQueueName,                                   //Queue Name
                        pQsd,                                           //SecurityDescriptor
                        (GUID*) pColumns[ iGuidIndex ].nColumnValue,    //Queue Guid
                        (WCHAR*) pColumns[ iLabelIndex ].nColumnValue,  //Label
                        (GUID*) pColumns[ iTypeIndex ].nColumnValue,    //Type
                        (UCHAR) pColumns[ iJournalIndex ].nColumnValue, //Journal
                        (ULONG) pColumns[ iQuotaIndex ].nColumnValue,   //Quota
                        (short) pColumns[ iBasePIndex ].nColumnValue,   //BasePriority
                        (ULONG) pColumns[ iJQuotaIndex ].nColumnValue,  //JQuota
                        (UCHAR) pColumns[ iAuthnIndex ].nColumnValue,   //Authentication
                        (ULONG) pColumns[ iPrivLevelIndex ].nColumnValue,   //PrivLevel
                        (GUID*) pColumns[ iOwnerIndex ].nColumnValue,   //OwnerId
                        (UCHAR) pColumns[ iTransactIndex ].nColumnValue,//Transaction
                        iIndex,
                        fIsTheSameMachine
                        ) ;
        }

        hrPrev = hr;

        MQDBFreeBuf((void*) pColumns[ iGuidIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iName1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iName2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iLabelIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iOwnerIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iTypeIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iSecD1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iSecD2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iSecD3Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iQMIDIndex ].nColumnValue) ;

        for ( LONG i = 0 ; i < cbColumns ; i++ )
        {
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        //
        // we have to re-define error before saving hr in hr1 in order to save
        // and return real error (skip all errors those allow to continue).
        //
        if (hr == MQMig_E_ILLEGAL_QUEUENAME ||
            hr == MQMig_E_INVALID_MACHINE_NAME)
        {
            //
            // re-define this error to finish migration process
            //
            hr = MQMig_I_ILLEGAL_QUEUENAME;
        }

        if (FAILED(hr))
        {
            if (hr == MQDS_OBJECT_NOT_FOUND)
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_NON_MIGRATED_MACHINE_QUEUE, wszQueueName, hr) ;
            }
            else
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_QUEUE, wszQueueName, hr) ;
            }
            hr1 = hr;
        }
        g_iQueueCounter ++;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);
    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_QUEUES_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != cQueues)
    {
        //
        // Mismatch in number of queues.
        //
        hr = MQMig_E_FEWER_QUEUES ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, cQueues) ;
        return hr ;
    }

    return hr1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migmachn.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migmachn.cpp

Abstract:

    Migration NT4 Machine objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include <mixmode.h>
#include <lmaccess.h>
#include "resource.h"
#include <dsproto.h>
#include <mqsec.h>

#include "migmachn.tmh"

extern GUID       g_MyMachineGuid  ;

// 
// The order is IMPORTANT. Please save it!
// We get machine properties from SQL database in this order. 
// Then we use these variables as index in the array of properties.
// Don't insert variables between lines with out/in frss. We based on the order.
//
enum enumPropIndex
{
    e_GuidIndex = 0,
    e_Name1Index,
    e_Name2Index,
    e_ServiceIndex,
    e_QuotaIndex,
    e_JQuotaIndex,
    e_OSIndex,
    e_MTypeIndex,
    e_ForeignIndex,
    e_Sign1Index,
    e_Sign2Index,
    e_Encrpt1Index,
    e_Encrpt2Index,
    e_SecD1Index, 
    e_SecD2Index,
    e_SecD3Index,
    e_OutFrs1Index,
    e_OutFrs2Index,
    e_OutFrs3Index, 
    e_InFrs1Index,
    e_InFrs2Index, 
    e_InFrs3Index
};

//+--------------------------------------------------------------
//
//  HRESULT _HandleMachineWithInvalidName
//
//+--------------------------------------------------------------
static HRESULT _HandleMachineWithInvalidName (
                           IN LPWSTR   wszMachineName,
                           IN GUID     *pMachineGuid)
{
    static BOOL s_fShowMessageBox = FALSE;    
    static BOOL s_fMigrate = FALSE;

    if (!s_fShowMessageBox )
    {

        CResString strCaption(IDS_CAPTION);
        CResString strText(IDS_INVALID_MACHINE_NAME);
        int iRet = MessageBox( NULL,
                        strText.Get(),
                        strCaption.Get(),
                        MB_YESNO | MB_ICONWARNING);

        s_fShowMessageBox = TRUE;
        if (iRet == IDYES)
        {
            s_fMigrate = TRUE;
        }
    }
    
    //
    // Bug 5281.
    //    
    if (s_fMigrate)
    {
        //
        // if user chooses to continue with the migration of this machine
        // do not save it in .ini file and return OK.
        // 
        LogMigrationEvent(MigLog_Info, MQMig_I_INVALID_MACHINE_NAME, wszMachineName) ;
        return MQMig_OK;
    }

    //
    // Save this machine name in .ini file to prevent queue migration
    // of this machine later.    
    //
    if (!g_fReadOnly)
    {
        SaveMachineWithInvalidNameInIniFile (wszMachineName, pMachineGuid);   
    }

    LogMigrationEvent(MigLog_Event, MQMig_E_INVALID_MACHINE_NAME, wszMachineName) ;
    return MQMig_E_INVALID_MACHINE_NAME;
}

//+--------------------------------------------------------------
//
//  HRESULT _CreateMachine()
//
//+--------------------------------------------------------------

static HRESULT _CreateMachine( IN GUID                *pOwnerGuid,
                               IN LPWSTR               wszSiteName,
                               IN LPWSTR               wszMachineName,
                               MQDBCOLUMNVAL          *pColumns,                               
                               IN UINT                 iIndex,
                               OUT BOOL               *pfIsConnector)
{    
    DBG_USED(iIndex);
    //
    // get machine guid from pColumns
    //
    GUID *pMachineGuid = (GUID*) pColumns[ e_GuidIndex ].nColumnValue;
       
#ifdef _DEBUG
    unsigned short *lpszGuid ;
    UuidToString( pMachineGuid,
                  &lpszGuid ) ;

    LogMigrationEvent(MigLog_Info, MQMig_I_MACHINE_MIGRATED,
                                     iIndex,
                                     wszMachineName,
                                     lpszGuid) ;
    RpcStringFree( &lpszGuid ) ;
#endif
       
    HRESULT hr = MQMig_OK;

    if (!IsObjectNameValid(wszMachineName))
    {
        //
        // machine name is invalid
        //
        hr = _HandleMachineWithInvalidName (wszMachineName, pMachineGuid);
        if (FAILED(hr))
        {
            return hr ;        
        }
    }

    if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return MQMig_OK ;
    }
    
    BOOL fIsInsertPKey = IsInsertPKey (pMachineGuid);

    #define MAX_MACHINE_PROPS 19   
    PROPID propIDs[ MAX_MACHINE_PROPS ];
    PROPVARIANT propVariants[ sizeof(propIDs) / sizeof(propIDs[0]) ];
    DWORD iProperty =0;   
                   
    //
    // get OS from pColumns
    // 
    DWORD dwOS = (DWORD) pColumns[ e_OSIndex ].nColumnValue;

    propIDs[iProperty] = PROPID_QM_MACHINE_TYPE;
    propVariants[iProperty].vt = VT_LPWSTR;
    if (g_MyMachineGuid == *pMachineGuid)
    {
        //
        // it is local machine, we have to change its type to Windows NT5...
        //
        propVariants[iProperty].pwszVal = OcmFormInstallType(dwOS);
    }
    else
    {
        //
        // it is remote machine, set its type as is.
        //
        propVariants[iProperty].pwszVal = (LPWSTR) pColumns[ e_MTypeIndex ].nColumnValue;
    }
	iProperty++;
                
    propIDs[iProperty] = PROPID_QM_OS;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = dwOS ;
	iProperty++;
          
    propIDs[iProperty] = PROPID_QM_QUOTA;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = (DWORD) pColumns[ e_QuotaIndex].nColumnValue;
	iProperty++;

    propIDs[iProperty] = PROPID_QM_JOURNAL_QUOTA;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = (DWORD) pColumns[ e_JQuotaIndex].nColumnValue;
	iProperty++;
     
    //
    // BUG 5307: handle in/out frss.
    // init out and in frss arrays. There is no more than 3 out/in frss.
    //      
    AP<GUID> pguidOutFRS = NULL;
    AP<GUID> pguidInFRS = NULL;    
    UINT uiFrsCount = 0;    

    //
    // get service and foreign flag from pColumns
    //     
    DWORD dwService = (DWORD) pColumns[ e_ServiceIndex ].nColumnValue ;
    BOOL fForeign = (BOOL)  pColumns[ e_ForeignIndex ].nColumnValue;

    if (dwService == SERVICE_NONE && !fForeign)
    {       
        hr = GetFRSs (pColumns, e_OutFrs1Index, &uiFrsCount, &pguidOutFRS);                 

        propIDs[iProperty] = PROPID_QM_OUTFRS;
        propVariants[iProperty].vt = VT_CLSID | VT_VECTOR ;
        propVariants[iProperty].cauuid.cElems = uiFrsCount ;
        propVariants[iProperty].cauuid.pElems = pguidOutFRS ;
        iProperty++;

        hr = GetFRSs (pColumns, e_InFrs1Index, &uiFrsCount, &pguidInFRS);                 

        propIDs[iProperty] = PROPID_QM_INFRS;
        propVariants[iProperty].vt = VT_CLSID | VT_VECTOR ;
        propVariants[iProperty].cauuid.cElems = uiFrsCount ;
        propVariants[iProperty].cauuid.pElems = pguidInFRS ;
        iProperty++;
    }       
    
    P<BYTE> pSignKey = NULL; 
    P<BYTE> pEncrptKey = NULL; 

    if (fIsInsertPKey)
    {
        //
        // fIsInsertPKey may be set to FALSE in the only case:
        // migration tool run on the PEC not at first time
        // (i.e. PEC machine object already exist in ADS) and
        // current machine pwzMachineName is the PEC machine.        
        //
        // Bug 5328: create computer with all properties including public keys
        //        
        ULONG ulSize = 0;        

        hr = PreparePBKeysForNT5DS( 
                    pColumns,
                    e_Sign1Index,
                    e_Sign2Index,
                    &ulSize,
                    (BYTE **) &pSignKey
                    );

        if (SUCCEEDED(hr))
        {
            propIDs[iProperty] = PROPID_QM_SIGN_PKS;
            propVariants[iProperty].vt = VT_BLOB;
            propVariants[iProperty].blob.pBlobData = pSignKey ;
            propVariants[iProperty].blob.cbSize = ulSize ;
            iProperty++;
        }
        else if (hr != MQMig_E_EMPTY_BLOB)        
        {
            //
            // I don't change the logic:
            // in the previous version if returned error is MQMig_E_EMPTY_BLOB 
            // we return MQMig_OK but did not set properties.
            // For any other error we return hr as is.
            //
            // return here: we don't create machine without its public key
            //            
            LogMigrationEvent(MigLog_Error, MQMig_E_PREPARE_PKEY, wszMachineName, hr) ;
            return hr;
        }

        ulSize = 0;        

        hr = PreparePBKeysForNT5DS( 
                    pColumns,
                    e_Encrpt1Index,
                    e_Encrpt1Index,
                    &ulSize,
                    (BYTE **) &pEncrptKey
                    );
        
        if (SUCCEEDED(hr))
        {
            propIDs[iProperty] = PROPID_QM_ENCRYPT_PKS,  
            propVariants[iProperty].vt = VT_BLOB;
            propVariants[iProperty].blob.pBlobData = pEncrptKey ;
            propVariants[iProperty].blob.cbSize = ulSize ;
            iProperty++;
        }
        else if (hr != MQMig_E_EMPTY_BLOB)        
        {
            //
            // I don't change the logic:
            // in the previous version if returned error is MQMig_E_EMPTY_BLOB 
            // we return MQMig_OK but did not set properties.
            // For any other error we return hr as is.
            //
            // return here: we don't create machine without its public key
            // 
            LogMigrationEvent(MigLog_Error, MQMig_E_PREPARE_PKEY, wszMachineName, hr) ;  
            return hr;
        }
    }
    
    //
    // we have to set this property too. It is good for foreign machines and solve 
    // connector problem when we run migtool with switch /w.
    //

    DWORD     dwNumSites = 0;    	
    AP<GUID>  pguidSites = NULL ;

    hr = GetAllMachineSites (   pMachineGuid,
                                wszMachineName,
                                pOwnerGuid,
                                fForeign,
                                &dwNumSites,
                                &pguidSites,
                                pfIsConnector) ;
    CHECK_HR(hr) ;
    ASSERT(dwNumSites > 0) ;

    propIDs[iProperty] = PROPID_QM_SITE_IDS;
	propVariants[iProperty].vt = VT_CLSID | VT_VECTOR ;
    propVariants[iProperty].cauuid.cElems = dwNumSites ;
    propVariants[iProperty].cauuid.pElems = pguidSites ;
	iProperty++;
    
    DWORD SetPropIdCount = iProperty;

    //
    // all properties below are for create object only!
    //

    BOOL fWasServerOnCluster = FALSE;
    if (g_fClusterMode &&			    // it is cluster mode
	    dwService == g_dwMyService) 	// current machine is former PEC/PSC on cluster

    {
        //
        // we have to change service to SERVICE_SRV since
        // this local machine will be PEC and former PEC on cluster will be FRS.
        //
        dwService = SERVICE_SRV;
        //
        // we need guid of former PEC for the future purpose (see database.cpp)
        //
        memcpy (&g_FormerPECGuid, pMachineGuid, sizeof(GUID));
        fWasServerOnCluster = TRUE;

        //
        // This fixes the problem of PEC + only ONE PSC. Otherwise, the
        // migration tool won't start the replication service.
        //
        g_iServerCount++;
    }
    propIDs[iProperty] = PROPID_QM_OLDSERVICE;    
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = dwService ;
	iProperty++;
    
    propIDs[iProperty] = PROPID_QM_SERVICE_ROUTING;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = ((dwService == SERVICE_SRV) ||
                                    (dwService == SERVICE_BSC) ||
                                    (dwService == SERVICE_PSC) ||
                                    (dwService == SERVICE_PEC));
	iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DSSERVER;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = ((dwService == SERVICE_PEC) ||
                                    (dwService == SERVICE_BSC) ||
                                    (dwService == SERVICE_PSC));
	iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (dwService != SERVICE_NONE);
	iProperty++;    

    if (fWasServerOnCluster)
    {
        //
        // bug 5423.
        // We try to set properties if we run on PSC. In case of PSC on cluster
        // we have to change all service properties of former PSC on cluster
        // when we run migtool on new installed DC (instead of PSC).
        //
        SetPropIdCount = iProperty;
    }

    propIDs[iProperty] = PROPID_QM_NT4ID ;
    propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = pMachineGuid ;
	iProperty++;
       
    if (fForeign)
    {
        propIDs[iProperty] = PROPID_QM_FOREIGN ;
        propVariants[iProperty].vt = VT_UI1 ;
        propVariants[iProperty].bVal = 1 ;
	    iProperty++;
    }
                                     
    propIDs[iProperty] = PROPID_QM_MASTERID;
	propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = pOwnerGuid ;
	iProperty++;

    //
    // get security descriptor from pColumns
    // 
    P<BYTE> pSD = NULL ;        
    DWORD  dwSDIndexs[3] = { e_SecD1Index, e_SecD2Index, e_SecD3Index } ;
    hr =  BlobFromColumns( pColumns,
                           dwSDIndexs,
                           3,
                           (BYTE**) &pSD ) ;
    CHECK_HR(hr) ;
    SECURITY_DESCRIPTOR *pMsd =
                      (SECURITY_DESCRIPTOR*) (pSD + sizeof(DWORD)) ;

    if (pMsd)
    {
        propIDs[iProperty] = PROPID_QM_SECURITY ;
        propVariants[iProperty].vt = VT_BLOB ;
    	propVariants[iProperty].blob.pBlobData = (BYTE*) pMsd ;
    	propVariants[iProperty].blob.cbSize =
                                     GetSecurityDescriptorLength(pMsd) ;
	    iProperty++ ;
    }   

    ASSERT(iProperty <= MAX_MACHINE_PROPS) ;
    
    if (dwService >= SERVICE_BSC)
    {
        g_iServerCount++;
    }

    hr = CreateMachineObjectInADS (
            dwService,
            fWasServerOnCluster,
            pOwnerGuid,
            pMachineGuid,
            wszSiteName,
            wszMachineName,
            SetPropIdCount,
            iProperty,
            propIDs,
            propVariants
            );

    return hr ;
}


//------------------------------------------------------
//
//  static HRESULT _CreateSiteLinkForConector
//
//  This machine is connector. The routine create site links
//  between original NT4 site and each machine's foreign site.
//
//------------------------------------------------------
static HRESULT _CreateSiteLinkForConnector (
                        IN LPWSTR   wszMachineName,
                        IN GUID     *pOwnerId,
                        IN GUID     *pMachineId
                        )
{    
    TCHAR *pszFileName = GetIniFileName ();

    TCHAR tszSectionName[50];

    _stprintf(tszSectionName, TEXT("%s - %s"), 
        MIGRATION_CONNECTOR_FOREIGNCN_NUM_SECTION, wszMachineName);

    ULONG ulForeignCNCount = GetPrivateProfileInt(
							      tszSectionName,	// address of section name
							      MIGRATION_CONNECTOR_FOREIGNCN_NUM_KEY,    // address of key name
							      0,							// return value if key name is not found
							      pszFileName					// address of initialization filename);
							      );
    if (ulForeignCNCount == 0)
    {
	    LogMigrationEvent(MigLog_Error, MQMig_E_GET_CONNECTOR_FOREIGNCN, 
            pszFileName, wszMachineName) ;        
        return MQMig_E_GET_CONNECTOR_FOREIGNCN;
    }

    //
    // get full machine name
    //
    AP<WCHAR> wszFullPathName = NULL;
    HRESULT hr = GetFullPathNameByGuid ( *pMachineId,
                                         &wszFullPathName );
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_FULLPATHNAME, wszMachineName, hr) ;        
        return hr;
    }

    BOOL fIsCreated = FALSE;

    unsigned short *lpszOwnerId ;	        
    UuidToString( pOwnerId, &lpszOwnerId ) ;  

    for (ULONG ulCount=0; ulCount<ulForeignCNCount; ulCount++)
    {		        				
        //
        // get guid of foreign cn: it is neigbor2 in the site link 
        // neighbor1 is OwnerId.
        //
        GUID Neighbor2Id = GUID_NULL;
        TCHAR szGuid[50];

        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_CONNECTOR_FOREIGNCN_KEY, ulCount + 1);  

        DWORD dwRetSize =  GetPrivateProfileString(
                                  wszMachineName,			// points to section name
                                  tszKeyName,	// points to key name
                                  TEXT(""),                 // points to default string
                                  szGuid,          // points to destination buffer
                                  50,                 // size of destination buffer
                                  pszFileName               // points to initialization filename);
                                  );
        UNREFERENCED_PARAMETER(dwRetSize);

        if (_tcscmp(szGuid, TEXT("")) == 0)
        {			
            LogMigrationEvent(MigLog_Error, MQMig_E_GET_CONNECTOR_FOREIGNCN, 
                pszFileName, wszMachineName) ;  
            hr = MQMig_E_GET_CONNECTOR_FOREIGNCN;
            break;
        }	
        UuidFromString(&(szGuid[0]), &Neighbor2Id);


        //
        // create new site link between NT4 site and current foreign site
        //                 
        hr = MigrateASiteLink (
                    NULL,
                    pOwnerId,     //neighbor1
                    &Neighbor2Id,   //neighbor2
                    1,      //DWORD dwCost, What is the default value?
                    1,      // number of site gate
                    wszFullPathName,    // site gate
                    ulCount 
                    );

        if (SUCCEEDED(hr))
        {
            LogMigrationEvent(MigLog_Event, 
                    MQMig_I_CREATE_SITELINK_FOR_CONNECTOR, 
                    wszMachineName, lpszOwnerId, szGuid) ; 
            fIsCreated = TRUE;
        }
        else            
        {                          
            LogMigrationEvent(MigLog_Error, 
                MQMig_E_CANT_CREATE_SITELINK_FOR_CONNECTOR, 
                wszMachineName, lpszOwnerId, szGuid, hr) ; 
            break;
        }
    }

    //
    // remove these sections from .ini
    //
    BOOL f = WritePrivateProfileString( 
                            tszSectionName,
                            NULL,
                            NULL,
                            pszFileName ) ;
    ASSERT(f) ;

    f = WritePrivateProfileString( 
                        wszMachineName,
                        NULL,
                        NULL,
                        pszFileName ) ;
    ASSERT(f) ;    

    if (fIsCreated)
    {
        //
        // save NT4 site name in .ini file to replicate site gate later 
        // 
        ULONG ulSiteNum = GetPrivateProfileInt(
                                    MIGRATION_CHANGED_NT4SITE_NUM_SECTION,	// address of section name
                                    MIGRATION_CHANGED_NT4SITE_NUM_KEY,      // address of key name
                                    0,							    // return value if key name is not found
                                    pszFileName					    // address of initialization filename);
                                    );

        //
        // save new number of changed NT4 site in .ini file
        //
        ulSiteNum ++;
        TCHAR szBuf[10];
        _ltot( ulSiteNum, szBuf, 10 );
        f = WritePrivateProfileString(  MIGRATION_CHANGED_NT4SITE_NUM_SECTION,
                                        MIGRATION_CHANGED_NT4SITE_NUM_KEY,
                                        szBuf,
                                        pszFileName ) ;
        ASSERT(f) ;

        //
        // save site name in .ini file
        //
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), 
	        MIGRATION_CHANGED_NT4SITE_KEY, ulSiteNum);

        f = WritePrivateProfileString( 
                                MIGRATION_CHANGED_NT4SITE_SECTION,
                                tszKeyName,
                                lpszOwnerId,
                                pszFileName ) ;
        ASSERT(f);
    }

    RpcStringFree( &lpszOwnerId ) ;

    return hr;
}

#define INIT_MACHINE_COLUMN(_ColName, _Index)            \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    _Index++ ;

//-------------------------------------------
//
//  HRESULT MigrateMachines(UINT cMachines)
//
//-------------------------------------------

HRESULT MigrateMachines(IN UINT   cMachines,
                        IN GUID  *pSiteGuid,
                        IN LPWSTR pwszSiteName)
{
    ASSERT(cMachines != 0) ;

    LONG cAlloc = 22 ;
    LONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;                    

    ASSERT(e_GuidIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_QMID,           cbColumns) ;
    
    ASSERT(e_Name1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_NAME1,          cbColumns) ;    

    ASSERT(e_Name2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_NAME2,          cbColumns) ;
    
    ASSERT(e_ServiceIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_SERVICES,       cbColumns) ;    

    ASSERT(e_QuotaIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_QUOTA,          cbColumns) ;
      
    ASSERT(e_JQuotaIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_JQUOTA,         cbColumns) ;

    ASSERT(e_OSIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_OS,             cbColumns) ;

    ASSERT(e_MTypeIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_MTYPE,          cbColumns) ;         

    ASSERT(e_ForeignIndex == cbColumns);
    INIT_MACHINE_COLUMN(M_FOREIGN,        cbColumns) ;

    ASSERT(e_Sign1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SIGNCRT1,       cbColumns) ;

    ASSERT(e_Sign2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SIGNCRT2,       cbColumns) ;

    ASSERT(e_Encrpt1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_ENCRPTCRT1,     cbColumns) ;

    ASSERT(e_Encrpt2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_ENCRPTCRT2,     cbColumns) ;   

    ASSERT(e_SecD1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SECURITY1,      cbColumns) ;

    ASSERT(e_SecD2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SECURITY2,      cbColumns) ;

    ASSERT(e_SecD3Index == cbColumns);
    INIT_MACHINE_COLUMN(M_SECURITY3,      cbColumns) ;    

    //
    // BUGBUG: save this column order for out and in frss!   
    // we based on such order later!
    //        
    ASSERT(e_OutFrs1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_OUTFRS1,        cbColumns) ;

    ASSERT(e_OutFrs2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_OUTFRS2,        cbColumns) ;

    ASSERT(e_OutFrs3Index == cbColumns);
    INIT_MACHINE_COLUMN(M_OUTFRS3,        cbColumns) ;

    ASSERT(e_InFrs1Index == cbColumns);
    INIT_MACHINE_COLUMN(M_INFRS1,         cbColumns) ;

    ASSERT(e_InFrs2Index == cbColumns);
    INIT_MACHINE_COLUMN(M_INFRS2,         cbColumns) ;

    ASSERT(e_InFrs3Index == cbColumns);
    INIT_MACHINE_COLUMN(M_INFRS3,         cbColumns) ;

    #undef  INIT_MACHINE_COLUMN

    //
    // Restriction. query by machine guid.
    //
    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = M_OWNERID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = M_OWNERID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cbColumns == cAlloc) ;

    //
    // We need sorting since we have to migrate servers and only then clients. 
    // The order is important because of Out/In FRS.
    // When Out/InFRS is created for client code replaces machine guid by 
    // full DN name. It means that if for specific server msmqConfiguration 
    // does not yet exist and we try to migrate client with this server 
    // that is defined as its Out/InFRS, we failed with MACHINE_NOT_FOUND    
    //
    MQDBSEARCHORDER ColSort;
    ColSort.lpszColumnName = M_SERVICES_COL;        
    ColSort.nOrder = DESC;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hMachineTable,
                                       pColumns,
                                       cbColumns,
                                       ColSearch,
                                       NULL,
                                       &ColSort,
                                       1,
                                       &hQuery,
							           TRUE ) ;     
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    HRESULT hr1 = MQMig_OK;

    while(SUCCEEDED(status))
    {
        if (iIndex >= cMachines)
        {
            status = MQMig_E_TOO_MANY_MACHINES ;
            break ;
        }

        //
        // Migrate each machine
        //                
        //
        // get machine name from pColumns
        //    
        P<BYTE> pwzBuf = NULL ;       
        DWORD  dwIndexs[2] = { e_Name1Index, e_Name2Index } ;
        HRESULT hr =  BlobFromColumns( pColumns,
                                       dwIndexs,
                                       2,
                                       (BYTE**) &pwzBuf ) ;
        CHECK_HR(hr) ;
        WCHAR *pwzMachineName = (WCHAR*) (pwzBuf + sizeof(DWORD)) ;
        
        BOOL fConnector = FALSE;

        hr = _CreateMachine(
                    pSiteGuid,
                    pwszSiteName,
                    pwzMachineName,
                    pColumns,
                    iIndex,
                    &fConnector
                    ) ;      
        
        if (fConnector)
        {
            //
            // Bug 5012.
            // Connector machine migration
            //      
            
            //
            // we got this error if we tryed to create machine object. In case of Set 
            // (to run mqmig /w or on PSC) it must be succeeded
            //

            if (hr == MQDS_E_COMPUTER_OBJECT_EXISTS ||
                hr == MQ_ERROR_MACHINE_NOT_FOUND)
            {
                //
                // It is possible for connector machine.
                //
                // If connector machine is in the PEC domain, create msmqSetting object
                // under foreign site failed with error MQ_ERROR_MACHINE_NOT_FOUND. 
                // When this error is returned from DSCoreCreateMigratedObject, 
                // _CreateMachine tries to create computer object. 
                // This object already exists and hence _CreateComputerObject returns
                // MQDS_E_COMPUTER_OBJECT_EXISTS.
                //
                // If connector machine is not in the PEC domain, 
                // DSCoreCreateMigratedObject failed with MQ_ERROR_MACHINE_NOT_FOUND.
                // Then _CreateMachine tries to create computer object. It succeeded.
                // Now _CreateMachine calls DSCoreCreateMigratedObject again.
                // It failed with MQ_ERROR_MACHINE_NOT_FOUND (because of foreign site)
                //
                // We have to verify that msmqSetting object was created under 
                // real NT4 site. 
                //
                // Try to touch msmqSetting attribute. If it will be succeeded,
                // it means that msmq Setting object exists.
                //
                hr = ResetSettingFlag(  1,                  //dwNumSites,
                                        pSiteGuid,         //pguidSites,
                                        pwzMachineName,
                                        const_cast<WCHAR*> (MQ_SET_MIGRATED_ATTRIBUTE),
                                        L"FALSE");                
            }
            
            //
            // In any case (even if we failed before) try to complete connector migration.
            //
            // Create site link for connector machine.
            //
            HRESULT hrTmp = _CreateSiteLinkForConnector (
                                    pwzMachineName,
                                    pSiteGuid,
                                    (GUID*) pColumns[ e_GuidIndex ].nColumnValue
                                    );
            if (FAILED(hrTmp))
            {
                hr = hrTmp;
            }
        }

        MQDBFreeBuf((void*) pColumns[ e_GuidIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Name1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Name2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_SecD1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_SecD2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_SecD3Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_MTypeIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Sign1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Sign2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Encrpt1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ e_Encrpt2Index ].nColumnValue) ;

        for ( LONG i = 0 ; i < cbColumns ; i++ )
        {
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        if (!g_fReadOnly && hr == MQMig_E_INVALID_MACHINE_NAME)
        {
            //
            // re-define this error to finish migration process
            //
            hr = MQMig_I_INVALID_MACHINE_NAME;
        }

        if (FAILED(hr))
        {
            if (hr == MQ_ERROR_CANNOT_CREATE_ON_GC)
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_MACHINE_REMOTE_DOMAIN_OFFLINE, pwzMachineName, hr) ;
            }
            else
            {
                LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_MACHINE, pwzMachineName, hr) ;
            }
            hr1 = hr;
        }
        g_iMachineCounter ++;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != cMachines)
    {
        //
        // Mismatch in number of sites.
        //
        HRESULT hr = MQMig_E_FEWER_MACHINES ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, cMachines) ;
        return hr ;
    }   

    return hr1 ;
}

//+---------------------------------------------------
//
//  HRESULT MigrateMachinesInSite(GUID *pSiteGuid)
//
//+---------------------------------------------------

HRESULT MigrateMachinesInSite(GUID *pSiteGuid)
{
    //
    // Enable multiple queries.
    // this is necessary to retrieve CN of foreign machine.
    //
    HRESULT hr = EnableMultipleQueries(TRUE) ;
    ASSERT(SUCCEEDED(hr)) ;

    //
    // get site name from database
    //
    LONG cAlloc = 1 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_NAME_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_NAME_CTYPE ;
    LONG iSiteNameIndex = cColumns ;
    cColumns++ ;

    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = S_ID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = S_ID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT cMachines = 0 ;
    hr =  GetMachinesCount(  pSiteGuid,
                            &cMachines ) ;
    CHECK_HR(hr) ;

    if (cMachines != 0)
    {
        LogMigrationEvent(MigLog_Info, MQMig_I_MACHINES_COUNT,
                  cMachines, pColumns[ iSiteNameIndex ].nColumnValue ) ;

        hr = MigrateMachines( cMachines,
                              pSiteGuid,
                    (WCHAR *) pColumns[ iSiteNameIndex ].nColumnValue ) ;
    }
    else
    {
        //
        // That's legitimate, to have a site without machines.
        // This will happen when running the tool on a PSC, where
        // it already has (in its MQIS database) Windows 2000 sites without
        // MSMQ machine. Or in crash mode.
        //
        LogMigrationEvent(MigLog_Warning, MQMig_I_NO_MACHINES_AVAIL,
                               pColumns[ iSiteNameIndex ].nColumnValue ) ;
    }

    MQDBFreeBuf((void*) pColumns[ iSiteNameIndex ].nColumnValue ) ;
    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    HRESULT hr1 = EnableMultipleQueries(FALSE) ;
    DBG_USED(hr1);
    ASSERT(SUCCEEDED(hr1)) ;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migrat.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migrat.cpp

Abstract:

    Entry point for migration dll.

Author:

    Doron Juster  (DoronJ)  03-Feb-1998

--*/

#include "migrat.h"
#include <mixmode.h>
#include <mqsec.h>

#include "migrat.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migrat.h ===
//
// file: migrat.h
//

#include <_stdh.h>
#include <stdio.h>
#include <tchar.h>
#include <wchar.h>

#include <mqtypes.h>
#include <mqdbmgr.h>
#include <uniansi.h>
#include <mqprops.h>
#include <_mqini.h>

#include "migratui.h"
//#include "resource.h"

#include "mqmigui.h"

#ifndef _NO_SEQNUM_
#include <dscore.h>
#include <seqnum.h>
#endif

#include "..\..\ds\h\mqiscol.h"
#include "..\..\replserv\mq1repl\migrepl.h"
#include "..\..\replserv\mq1repl\rptempl.h"

#ifndef _NO_NT5DS_

#include <wincrypt.h>

#include <winldap.h>
#include <activeds.h>
#include "..\..\ds\h\mqattrib.h"
#include "..\..\ds\h\mqdsname.h"
#endif

#include "mqsymbls.h"

//---------------------------------
//
//  Functions prototypes
//
//---------------------------------

HRESULT MakeMQISDsn(LPSTR lpszServerName, BOOL fMakeAlways = FALSE) ;

HRESULT ConnectToDatabase(BOOL fConnectAlways = FALSE) ;
void    CleanupDatabase() ;

#ifndef _NO_NT5DS_
HRESULT  InitLDAP( PLDAP *ppLdap,
                   TCHAR **ppwszDefName,
                   ULONG ulPort = LDAP_PORT) ;

HRESULT ModifyAttribute(
             WCHAR       wszPath[],
             WCHAR       pAttr[],
             WCHAR       pAttrVal[],
             PLDAP_BERVAL *ppBVal = NULL
             );
#endif

HRESULT OpenEntTable() ;
HRESULT MigrateEnterprise() ;

HRESULT OpenCNsTable() ;
HRESULT OpenMachineCNsTable() ;
HRESULT MigrateCNs() ;

HRESULT EnableMultipleQueries(BOOL fEnable) ;

UINT    GetNT5SitesCount() ;
HRESULT GetSitesCount(UINT *pcSites) ;
HRESULT MigrateSites( IN UINT  cSites,
                      IN GUID *pSitesGuid ) ;

HRESULT GetMachinesCount(IN  GUID *pSiteGuid,
                         OUT UINT *pcMachines) ;

HRESULT MigrateMachines(IN UINT   cMachines,
                        IN GUID  *pSiteGuid,
                        IN LPWSTR wszSiteName) ;

HRESULT GetQueuesCount( IN  GUID *pMachineGuid,
                        OUT UINT *pcQueues ) ;

HRESULT GetAllMachinesCount(UINT *pcMachines);
HRESULT GetAllQueuesCount(UINT *pcQueues);
HRESULT GetAllQueuesInSiteCount( IN  GUID *pSiteGuid,
                                 OUT UINT *pcQueues );

HRESULT GetAllObjectsNumber (IN  GUID *pSiteGuid,
                             IN  BOOL    fPecfPec,
                             OUT UINT *pulAllObjectNumber ) ;

HRESULT MigrateMachinesInSite(IN GUID *pSiteGuid);

HRESULT MigrateQueues() ;

HRESULT MigrateUsers(LPTSTR lpszDcName) ;
HRESULT OpenUsersTable() ;
HRESULT GetUserCount(UINT *pcUsers) ;

HRESULT  BlobFromColumns( MQDBCOLUMNVAL *pColumns,
                          DWORD          adwIndexs[],
                          DWORD          dwIndexSize,
                          BYTE**         ppOutBuf ) ;

TCHAR *GetIniFileName ();

HRESULT GetSiteIdOfPEC (IN LPTSTR pszRemoteMQISName,
                        OUT ULONG *pulService,
                        OUT GUID  *pSiteId);

#ifndef _NO_SEQNUM_
HRESULT  FindLargestSeqNum( GUID    *pMasterId,
                            CSeqNum &snMaxLsn,
                            BOOL    fPec ) ;
#endif

UINT  ReadDebugIntFlag(WCHAR *pwcsDebugFlag, UINT iDefault) ;

LPWSTR OcmFormInstallType( DWORD dwOS) ;

HRESULT  ReadFirstNT5Usn(TCHAR *pszUsn) ;
HRESULT  FindMinMSMQUsn(TCHAR *wszMinUsn) ;

BOOL  MigWriteRegistrySz( LPTSTR  lpszRegName,
                          LPTSTR  lpszValue ) ;

BOOL  MigWriteRegistryDW( LPTSTR  lpszRegName,
                          DWORD   dwValue ) ;

BOOL  MigWriteRegistryGuid( LPTSTR  lpszRegName,
                            GUID    *pGuid ) ;

BOOL  MigReadRegistryGuid( LPTSTR  lpszRegName,
                           GUID    *pGuid ) ;

BOOL  MigReadRegistryDW( LPTSTR  lpszRegName,
                         DWORD   *pdwValue ) ;

BOOL  MigReadRegistrySz( LPTSTR  lpszRegName,
                         LPTSTR  lpszValue,
                         DWORD   dwSize);

BOOL  MigReadRegistrySzErr( LPTSTR  lpszRegName,
                            LPTSTR  lpszValue,
                            DWORD   dwSize,
                            BOOL    fShowError );

HRESULT  UpdateRegistry( IN UINT  cSites,
                         IN GUID *pSitesGuid ) ;

HRESULT  CreateMsmqContainer(TCHAR wszContainerName[]) ;

HRESULT  CreateSite( GUID   *pSiteGuid,
                     LPTSTR  pszSiteName,
                     BOOL    fForeign,
                     USHORT  uiInterval1 = DEFAULT_S_INTERVAL1,
                     USHORT  uiInterval2 = DEFAULT_S_INTERVAL2
                     ) ;

HRESULT OpenSiteLinkTable();

HRESULT MigrateSiteLinks();

HRESULT MigrateASiteLink (
            IN GUID     *pLinkId,
            IN GUID     *pNeighbor1Id,
            IN GUID     *pNeighbor2Id,
            IN DWORD    dwCost,
            IN DWORD    dwSiteGateNum,
            IN LPWSTR   lpwcsSiteGates,
            IN UINT     iIndex
            );

HRESULT MigrateSiteGates();

HRESULT GetFullPathNameByGuid ( GUID   MachineId,
                                LPWSTR *lpwcsFullPathName );

HRESULT LookupBegin(
			MQCOLUMNSET *pColumnSet,
			HANDLE *phQuery
			);
HRESULT LookupNext (
			HANDLE hQuery,
			DWORD *pdwCount,
			PROPVARIANT paVariant[]
			);
HRESULT LookupEnd (HANDLE hQuery) ;

HRESULT GrantAddGuidPermissions() ;

HRESULT RestorePermissions() ;

void InitLogging( LPTSTR  szLogFile,
                  ULONG   ulTraceFlags,
				  BOOL	  fReadOnly) ;

void EndLogging() ;

HRESULT  GetMachineCNs(IN  GUID    *pMachineGuid,
                       OUT DWORD   *pdwNumofCNs,
                       OUT GUID   **pCNGuids ) ;

MQDBSTATUS APIENTRY  MQDBGetTableCount(IN MQDBHANDLE  hTable,
                                       OUT UINT       *puCount,
                         IN MQDBCOLUMNSEARCH  *pWhereColumnSearch = NULL,
                                       IN LONG        cWhere  = 1,
                                       IN MQDBOP      opWhere = AND) ;
HRESULT CheckVersion (
              OUT UINT   *piOldVerServersCount,
              OUT LPTSTR *ppszOldVerServers
              );

HRESULT AnalyzeMachineType (
            IN LPWSTR wszMachineType,
            OUT BOOL  *pfOldVersion
            );

HRESULT PrepareNT5SitesForReplication();
HRESULT PrepareNT5MachinesForReplication();
HRESULT PrepareRegistryForPerfDll();
HRESULT PrepareChangedNT4SiteForReplication();
HRESULT PrepareCurrentUserForReplication();

BOOL
RunProcess(
	IN  const LPTSTR szCommandLine,
    OUT       DWORD  *pdwExitCode
	);

HRESULT ChangeRemoteMQIS ();

DWORD CalHashKey( IN LPCWSTR pwcsPathName );

void BuildServersList(LPTSTR *ppszNonUpdatedServerName, ULONG *pulServerCount);

void RemoveServersFromList(LPTSTR *ppszUpdatedServerName,
                           LPTSTR *ppszNonUpdatedServerName);

BOOL IsObjectNameValid(TCHAR *pszObjectName);

BOOL IsObjectGuidInIniFile(IN GUID      *pObjectGuid,
                           IN LPWSTR    pszSectionName);

HRESULT GetCurrentUserSid ( IN HANDLE    hToken, 
                            OUT TCHAR    **ppUserSid);

HRESULT  GetSchemaNamingContext ( PLDAP pLdap,
                                  TCHAR **ppszSchemaDefName );

HRESULT HandleAUser(PLDAP           pLdap,
                    LDAPMessage     *pEntry);

HRESULT TouchAUser (PLDAP           pLdap,
                    LDAPMessage     *pEntry );

HRESULT QueryDS(
            IN  PLDAP           pLdap,
            IN  TCHAR           *pszDN,
            IN  TCHAR           *pszFilter,			
            IN  DWORD           dwObjectType,
            IN  PWSTR           *rgAttribs,
            IN  BOOL            fTouchUser
            );

BOOL IsInsertPKey (GUID *pMachineGuid);

HRESULT GetFRSs (IN MQDBCOLUMNVAL    *pColumns,
                 IN UINT             uiFirstIndex,
                 OUT UINT            *puiFRSCount, 
                 OUT GUID            **ppguidFRS );

HRESULT PreparePBKeysForNT5DS( 
                   IN MQDBCOLUMNVAL *pColumns,
                   IN UINT           iIndex1,
                   IN UINT           iIndex2,
                   OUT ULONG         *pulSize,
                   OUT BYTE          **ppPKey
                   );

HRESULT  ResetSettingFlag( IN DWORD   dwNumSites,
                           IN GUID*   pguidSites,
                           IN LPWSTR  wszMachineName,
                           IN WCHAR   *wszAttributeName,
                           IN WCHAR   *wszValue);

HRESULT GetAllMachineSites ( IN GUID    *pMachineGuid,
                             IN LPWSTR  wszMachineName,
                             IN GUID    *pOwnerGuid,
                             IN BOOL    fForeign,
                             OUT DWORD  *pdwNumSites,
                             OUT GUID   **ppguidSites,
                             OUT BOOL   *pfIsConnector) ;

HRESULT CreateMachineObjectInADS (
                IN DWORD    dwService,
                IN BOOL     fWasServerOnCluster,
                IN GUID     *pOwnerGuid,
                IN GUID     *pMachineGuid,
                IN LPWSTR   wszSiteName,
                IN LPWSTR   wszMachineName,
                IN DWORD    SetPropIdCount,
                IN DWORD    iProperty,
                IN PROPID   *propIDs,
                IN PROPVARIANT *propVariants
                );

void SaveMachineWithInvalidNameInIniFile (LPWSTR wszMachineName, GUID *pMachineGuid);

#define EMPTY_DEFAULT_CONTEXT       TEXT("")

//+------------------
//
//  Logging
//
//+------------------

//
// enum match values of DBGLVL_* in mqreport.h
//
enum MigLogLevel
{
    MigLog_Event = 0,
    MigLog_Error,
    MigLog_Warning,
    MigLog_Trace,
    MigLog_Info
} ;

void LogMigrationEvent(MigLogLevel eLevel, DWORD dwMsgId, ...) ;


//---------------------------------
//
//  Macros
//
//---------------------------------

#define CHECK_HR(hR)    \
    if (FAILED(hR))     \
    {                   \
        return hR ;     \
    }

//---------------------------------
//
//  Definitions
//
//---------------------------------

#define DSN_NAME  "RemoteMQIS"

//
// from MSMQ1.0 mqis.h
// when a field is composed of two SQL columns, the first 2 bytes of
// the fixed length column is the total length of the data.
// (e.g., PATHNAME1 and PATHNAME2).
//
#define MQIS_LENGTH_PREFIX_LEN  (2)

//---------------------------------
//
//  Global variables
//
//---------------------------------

extern MQDBHANDLE g_hDatabase ;
extern MQDBHANDLE g_hSiteTable ;
extern MQDBHANDLE g_hEntTable ;
extern MQDBHANDLE g_hCNsTable ;
extern MQDBHANDLE g_hMachineTable ;
extern MQDBHANDLE g_hMachineCNsTable ;
extern MQDBHANDLE g_hQueueTable ;
extern MQDBHANDLE g_hUsersTable ;
extern MQDBHANDLE g_hSiteLinkTable ;

extern BOOL  g_fReadOnly ;
extern BOOL  g_fRecoveryMode ;
extern BOOL  g_fClusterMode ;
extern BOOL  g_fWebMode	 ;
extern BOOL  g_fAlreadyExistOK ;

extern DWORD    g_dwMyService ;
extern GUID     g_MySiteGuid  ;
extern GUID     g_MyMachineGuid ;

extern GUID     g_FormerPECGuid ;

extern UINT g_iServerCount ;

extern UINT g_iSiteCounter ;
extern UINT g_iMachineCounter ;
extern UINT g_iQueueCounter ;
extern UINT g_iUserCounter;

//-----------------------------
//
//  Auto delete pointer
//
//-----------------------------

// A helper class for automatically closing a query.
//
class CHQuery
{
public:
    CHQuery() : m_hQuery(NULL) {}
    ~CHQuery() { if (m_hQuery) MQDBCloseQuery(m_hQuery) ; }
    MQDBHANDLE * operator &() { return &m_hQuery ; }
    operator MQDBHANDLE() { return m_hQuery ; }
    CHQuery &operator =(MQDBHANDLE hQuery) { m_hQuery = hQuery; return *this; }

private:
    MQDBHANDLE m_hQuery ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migratui.h ===
//
// file: migratui.h
//

const UINT cwcResBuf = 2048;

extern HINSTANCE g_hResourceMod;

class CResString
{
public:
    CResString() { _awc[ 0 ] = 0; }

    CResString( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
    }

    BOOL Load( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
        return ( 0 != _awc[ 0 ] );
    }

    TCHAR const * Get() { return _awc; }

private:
    TCHAR _awc[ cwcResBuf ];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migrate.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migrat.cpp

Abstract:

    Entry point for migration dll.

Author:

    Doron Juster  (DoronJ)  03-Feb-1998

--*/

#include "migrat.h"
#include <mixmode.h>
#include <mqsec.h>
#include "_mqres.h"

#include "migrate.tmh"

//
// DLL module instance handle
//
HINSTANCE  g_hResourceMod  = MQGetResourceHandle();
BOOL       g_fReadOnly       = TRUE ;
BOOL       g_fAlreadyExistOK = FALSE ;
DWORD      g_dwMyService     = 0 ;
GUID       g_MySiteGuid  ;
GUID       g_MyMachineGuid  ;

GUID	   g_FormerPECGuid   = GUID_NULL ;	//used only in cluster mode

BOOL       g_fRecoveryMode   = FALSE ;
BOOL	   g_fClusterMode    = FALSE ;	
BOOL       g_fWebMode        = FALSE ;

UINT       g_iServerCount    = 0;

//
// for progress bar purposes
//
UINT g_iSiteCounter = 0;
UINT g_iMachineCounter = 0;
UINT g_iQueueCounter = 0;
UINT g_iUserCounter = 0;

//+----------------------------------
//
//  HRESULT _InitializeMigration()
//
//+----------------------------------

static HRESULT _InitializeMigration()
{
    static BOOL s_fInitialized = FALSE;
    if (s_fInitialized)
    {
        return TRUE;
    }

    HRESULT hr = MQMig_OK;

    BOOL f = MigReadRegistryDW( 
				MSMQ_MQS_REGNAME,
				&g_dwMyService 
				);
    if (f)
    {
        if ((g_dwMyService != SERVICE_PSC) &&
            (g_dwMyService != SERVICE_PEC))
        {
            hr = MQMig_E_WRONG_MQS_SERVICE;
            LogMigrationEvent(MigLog_Error, hr, g_dwMyService);
            return hr;
        }
    }
    else
    {
        return  MQMig_E_GET_REG_DWORD;
    }

    f = MigReadRegistryGuid( 
			MSMQ_MQIS_MASTERID_REGNAME,
			&g_MySiteGuid 
			);
    if (!f)
    {
        //
        // may be we are either in recovery or in cluster mode
        //
        f = MigReadRegistryGuid( 
				MIGRATION_MQIS_MASTERID_REGNAME,
				&g_MySiteGuid 
				);
        if (!f)
        {
            return  MQMig_E_GET_REG_GUID;
        }
    }

    f = MigReadRegistryGuid( 
			MSMQ_QMID_REGNAME,
			&g_MyMachineGuid 
			);
    if (!f)
    {
       return  MQMig_E_GET_REG_GUID;
    }

    //
    // Initialize the MQDSCORE dll
    //
    hr = DSCoreInit( 
			TRUE  	// setup
			);

    s_fInitialized = TRUE;
    return hr;
}

//+----------------------------------------------------
//
// static HRESULT _MigrateInternal()
//
//+----------------------------------------------------

static HRESULT _MigrateInternal( LPTSTR  szMQISName,
                                 LPTSTR  szDcName,
                                 BOOL    fReadOnly,
                                 BOOL    fAlreadyExist,
                                 BOOL    fRecoveryMode,
                                 BOOL	 fClusterMode,
                                 BOOL    fWebMode,
                                 BOOL    *pfIsOneServer
								 )
{
    HRESULT hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return hr ;
    }

    g_fReadOnly = fReadOnly ;

    g_fAlreadyExistOK = fAlreadyExist ;

    g_fRecoveryMode = fRecoveryMode ;

    g_fClusterMode = fClusterMode ;

    g_fWebMode = fWebMode ;

    if (!fReadOnly)
    {
        //
        // Read highest USN (the one before starting migration) from DS and
        // save in registry.
        //
        TCHAR wszReplHighestUsn[ SEQ_NUM_BUF_LEN ] ;
        hr = ReadFirstNT5Usn(wszReplHighestUsn) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_GET_FIRST_USN, hr) ;
            return hr ;
        }

        TCHAR wszPrevFirstHighestUsn[ SEQ_NUM_BUF_LEN ] ;
        if (! MigReadRegistrySzErr( FIRST_HIGHESTUSN_MIG_REG,
                                    wszPrevFirstHighestUsn,
                                    SEQ_NUM_BUF_LEN,
                                    FALSE /* fShowError */ ) )
        {
            BOOL f = MigWriteRegistrySz( FIRST_HIGHESTUSN_MIG_REG,
                                         wszReplHighestUsn ) ;
            if (!f)
            {
               return  MQMig_E_UNKNOWN ;
            }
        }
    }

    char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
    ConvertToMultiByteString(szMQISName,
                             szDSNServerName,
                 (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
    lstrcpy(szDSNServerName, szMQISName) ;
#endif

    hr =  MakeMQISDsn(szDSNServerName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szMQISName, hr) ;
        return hr ;
    }

    hr =  ConnectToDatabase() ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szMQISName, hr) ;
        return hr ;
    }

    //
    // Grant myself the RESTORE privilege. This is needed to create objects
    // with owner that differ from my process owner.
    //
    hr = MQSec_SetPrivilegeInThread( SE_RESTORE_NAME,
                                     TRUE ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // hr1 record the last error, in case that we continue with the
    // migration process. We'll always try to continue as much as possible.
    // we'll abort migration only if error is so severe such that we can't
    // continue.
    //
    HRESULT hr1 = MQMig_OK;

    //
    // It is important to save order of object migration.
    // 1. Enterprise object: do not continue if failed.
    // 2. CNs object: it is important to save all foreign CN before machine migration
    // 3. Sites: it is mandatory to create site object in ADS before machine migration
    // 4. Machines
    // 5. Queues: can be migrated only when machine object is created.
    // 6. Site links
    // 7. Site Gates: 
    //      only after site link migration; 
    //      only after machine migration: because connector machine set site gate, 
    //      and we have to copy SiteGate to SiteGateMig attribute
    // 8. Users
    //

    if (g_dwMyService == SERVICE_PEC)
    {
        hr = MigrateEnterprise() ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_ENT, hr) ;
            return hr ;
        }        
    }

    //
    // BUG 5012.
    // We have "to migrate" CNs on both PEC and PSC to know all foreign CNs
    // when connector machine is migrated.
    // On PEC we write all CNs to .ini file and create foreign sites
    // On PSC we only write all CNs to .ini file.
    //
    hr = MigrateCNs();
    if (FAILED(hr))
    {
        ASSERT(0);
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_CNS, hr) ;
        hr1 = hr;
    }

    //
    // BUG 5321.
    // We have to create this container on both PEC and PSC if they are in
    // different domain.
    // To make life easier we can try to create the container always. If PEC 
    // and PSC are in the same domain, the creation on PSC returned warning.
    // 
    // If creation failed on PEC we have to return immediately (as it was before)
    // If creation failed on PSC we can continue. In the worth case we don't fix this bug:
    // - migrated PEC is offline
    // - setup computers (Win9x) against PSC
    // - migrate PSC. All new computers will not be migrated.
    //
    // Create a default container for computers objects which are
    // not in the DS at present (for exmaple: Win9x computers, or
    // computers from other NT4 domains). We always create this container
    // during migration even if not needed now. We can't later create
    // this container from the replication service (if it need to create
    // it) if the replication service run under the LocalSystem
    // account. So create it now, for any case.
    //
    hr = CreateMsmqContainer(MIG_DEFAULT_COMPUTERS_CONTAINER) ;
    
    if (FAILED(hr))    
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CREATE_CONTAINER,
                                        MIG_DEFAULT_COMPUTERS_CONTAINER,       
                                        hr) ;                
        //
        // BUGBUG: return, if failed on PSC?
        //
        return hr ;        
    }   

    UINT cSites = 0 ;
    hr = GetSitesCount(&cSites) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SITES_COUNT, hr) ;
        return hr ;
    }
    LogMigrationEvent(MigLog_Info, MQMig_I_SITES_COUNT, cSites) ;

    P<GUID> pSiteGuid = new GUID[ cSites ] ;
    if (g_dwMyService == SERVICE_PEC)
    {
        hr =  MigrateSites(cSites, pSiteGuid) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_SITES, hr) ;
            hr1 = hr;
        }
    }
    else
    {
        cSites = 1;
        memcpy(&pSiteGuid[0], &g_MySiteGuid, sizeof(GUID));
        g_iSiteCounter++;
    }
	
    for (UINT i=0; i<cSites; i++)
    {
        hr = MigrateMachinesInSite(&pSiteGuid[i]);
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_MACHINES, hr) ;
            hr1 = hr;
        }
    }

    if (g_iServerCount == 1)
    {
        *pfIsOneServer = TRUE;
    }
    else
    {
        *pfIsOneServer = FALSE;
    }

    hr = MigrateQueues();
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_QUEUES, hr) ;
        hr1 = hr;
    }

    if (g_dwMyService == SERVICE_PEC)
    {
	    hr = MigrateSiteLinks();
	    if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_SITELINKS, hr) ;
            hr1 = hr;
        }
	
	    hr = MigrateSiteGates();
	    if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_SITEGATES, hr) ;
            hr1 = hr;
        }
		
		hr =  MigrateUsers(szDcName) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MIGRATE_USERS, hr) ;
            hr1 = hr;
        }
    	
    }

    hr = UpdateRegistry(cSites, pSiteGuid) ;  

    //
    // that's it ! migration of MQIS is done.
    //
    if (SUCCEEDED(hr))
    {
        BOOL f = MigWriteRegistryDW( FIRST_TIME_REG,
                                     1 ) ;
        DBG_USED(f);
        ASSERT(f) ;
    }

    if (fReadOnly)
    {
        return hr1;
    }

    //
    // not read-only mode
    //
    if (g_fClusterMode)
    {
        LONG cAlloc = 2;
        P<PROPVARIANT> propVar = new PROPVARIANT[ cAlloc ];
        P<PROPID>      propIds  = new PROPID[ cAlloc ];
        DWORD          PropIdCount = 0;
        
        //
        // change service of this computer in DS
        //
        propIds[PropIdCount] = PROPID_QM_OLDSERVICE;        
        propVar[PropIdCount].vt = VT_UI4;
        propVar[PropIdCount].ulVal = g_dwMyService ;
        PropIdCount++;

        //
        // change msmqNT4Flags to 0 for msmq setting object. We can do it
        // by setting PROPID_QM_SERVICE_DSSERVER 
        //
        // Bug 5264. We need that flag because BSC and PSC using it to find PEC. 
        // After normal migration we set the flag to 0 while the computer is created.
        // Here, in cluster mode, we have to define it explicitly.
        //
        propIds[PropIdCount] = PROPID_QM_SERVICE_DSSERVER ;        
        propVar[PropIdCount].vt = VT_UI1;
        propVar[PropIdCount].bVal = TRUE ;
        PropIdCount++;
        
        ASSERT((LONG) PropIdCount <= cAlloc) ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                            e_ALL_PROTOCOLS);  

        hr = DSCoreSetObjectProperties( 
                    MQDS_MACHINE,
                    NULL, // pathname
                    &g_MyMachineGuid,
                    PropIdCount,
                    propIds,
                    propVar,
                    &requestContext,
                    NULL ) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_SET_SERVICE, hr) ;
            return hr ;
        }        
        
        if (g_dwMyService == SERVICE_PEC)   //to update remote database only for PEC
        {
            hr = ChangeRemoteMQIS ();
        }
    }

    if (g_dwMyService == SERVICE_PSC)
    {
        return hr1;
    }

    //
    // we are here only if this machine is PEC
    //	

	//
    // Set registry so msmq service, after boot, relax the security
    // of the active directiry, to support nt4 machines.
    // We have to weaken security even if the Enterprise contains
	// only one server (PEC)
	//
    BOOL f = MigWriteRegistryDW( MSMQ_ALLOW_NT4_USERS_REGNAME,
                                 1 ) ;
    DBG_USED(f);
    ASSERT(f) ;

    if (*pfIsOneServer)
    {
        return hr1;
    }

    //
    // there is more than one server in Enterprise
    //

    //
    // prepare existing NT5 sites to be replicated to NT4 World
    // We need to change something for each NT5 site after saving
    // last SN. So, in the first replication we send NT5 sites to NT4.
    //
    hr = PrepareNT5SitesForReplication();

    //
    // BUG 5211.
    // prepare all sites with changed name to be replicated to NT4 World 
    // in order to replicate new name
    // BUG 5012.
    // prepare all sites with connector machine to be replicated to NT4 World
    // in order to replicate site gate
    //
    // We need to change something for each such site after saving
    // last SN. So, in the first replication we send all sites with 
    // new names to NT4.
    //
    hr = PrepareChangedNT4SiteForReplication();

    //
    // If running in crash recovery mode, then it may be possible
    // that there are Windows 2000 msmq servers that were not yet
    // replicated to the MQIS database used for recovery.
    // We need to replicate all these to the NT4 world.
    // So look for all "native" windows 2000 msmq servers and change
    // an attribute in each of them. These will results in
    // replication to nt4 world.
    // We change an unused attribute, mSMQMigrated.
    // This procedure is also necessary in "normal" migration, not
    // only recovery, if we'll allow installation of Windows 2000
    // msmq servers before upgrading the PEC.
    // So do it always !
    //
    hr = PrepareNT5MachinesForReplication();

    //
    // we have to prepare registry to load performance dll for
    // replication service.
    //
    hr = PrepareRegistryForPerfDll();

    //
    // if we are in recovery mode, change HIGHESTUSN_REPL_REG to
    // FIRST_HIGHESTUSN_MIG_REG.
    // So we'll replicate all PEC's object at the first replication cycle
    //
    if (g_fRecoveryMode)
    {
        DWORD dwAfterRecovery = 1;
        BOOL f = MigWriteRegistryDW( AFTER_RECOVERY_MIG_REG, dwAfterRecovery);
        ASSERT (f);

        //
        // we have to replace FirstMigUsn to the minimal MSMQ Usn
        // since we can lost NT5 MSMQ objects that was not replicated
        // to NT4 before crash.
        //
        TCHAR wszMinUsn[ SEQ_NUM_BUF_LEN ] ;
        hr = FindMinMSMQUsn(wszMinUsn) ;
        f = MigWriteRegistrySz( FIRST_HIGHESTUSN_MIG_REG, wszMinUsn ) ;
        ASSERT(f);
    }
   
    if (g_fRecoveryMode || g_fClusterMode)
    {
        //
        // BUG 5051.
        // In these modes we run MSMQ setup before migration tool
        // During setup internal certificate for this server is created.
        // If there was no such user in NT4 MQIS database, the user information
        // is not overwritten by migration tool. So, we have to touch current
        // user to replicate new certificate
        //
        hr = PrepareCurrentUserForReplication();
    }

    return hr1 ;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_MigrateFromMQIS(LPTSTR szMQISName)
//
//  Input parameters:
//      fReadOnly- TRUE if user wants only to read MQIS database.
//          Relevant in debug mode.
//      fAlreadyExist- TRUE if we allow migration to continue if MSMQ
//          objects are already found in NT5 DS. By default, FALSE when
//          migrating the PEC and TRUE afterward, when migrating PSCs.
//
//+--------------------------------------------------------------------

HRESULT  MQMig_MigrateFromMQIS( LPTSTR  szMQISName,
                                LPTSTR  szDcName,
                                BOOL    fReadOnly,
                                BOOL    fAlreadyExist,
                                BOOL    fRecoveryMode,
                                BOOL	fClusterMode,
                                BOOL    fWebMode,
                                LPTSTR  szLogFile,
                                ULONG   ulTraceFlags,
                                BOOL    *pfIsPEC,
                                BOOL    *pfIsOneServer
								)
{
    g_iSiteCounter = 0;
    g_iMachineCounter = 0;
    g_iQueueCounter = 0;
	g_iUserCounter = 0;

    InitLogging( szLogFile, ulTraceFlags, fReadOnly ) ;

    HRESULT hr =  _MigrateInternal( szMQISName,
                                    szDcName,
                                    fReadOnly,
                                    fAlreadyExist,
                                    fRecoveryMode,
                                    fClusterMode,
                                    fWebMode,
                                    pfIsOneServer) ;
    *pfIsPEC = (g_dwMyService == SERVICE_PEC) ;
    CleanupDatabase() ;

    EndLogging() ;

    if (!g_fReadOnly)
    {
        //
        // remove section: MIGRATION_MACHINE_WITH_INVALID_NAME from .ini
        // ???Does we need to leave this section?
        //
        TCHAR *pszFileName = GetIniFileName ();
        BOOL f = WritePrivateProfileString( 
                        MIGRATION_MACHINE_WITH_INVALID_NAME,
                        NULL,
                        NULL,
                        pszFileName ) ;
        DBG_USED(f);
        ASSERT(f) ;
    }

    return hr ;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_CheckMSMQVersionOnServers()
//
//  Input parameters:
//      LPTSTR szMQISName
//
//  Output parameters:
//      piCount- number of all servers with version less than MSMQ SP4
//      ppszServers- list of all servers with version less than MSMQ SP4
//
//+--------------------------------------------------------------------

HRESULT  MQMig_CheckMSMQVersionOfServers( IN  LPTSTR  szMQISName,
                                          IN  BOOL    fIsClusterMode,
                                          OUT UINT   *piCount,
                                          OUT LPTSTR *ppszServers )
{
    HRESULT hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (g_dwMyService == SERVICE_PSC)
    {
        return MQMig_OK;
    }	

    char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
    ConvertToMultiByteString(szMQISName,
                             szDSNServerName,
                 (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
    lstrcpy(szDSNServerName, szMQISName) ;
#endif

    hr = MakeMQISDsn(szDSNServerName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szMQISName, hr) ;
        return hr ;
    }

    hr =  ConnectToDatabase() ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szMQISName, hr) ;
        return hr ;
    }

    g_fClusterMode = fIsClusterMode ;

    hr = CheckVersion (piCount, ppszServers);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CHECK_VERSION, hr) ;
        return hr ;
    }

    return hr;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_GetObjectsCount( LPTSTR  szMQISName,
//                                  UINT   *piSiteCount,
//                                  UINT   *piMachineCount,
//                                  UINT   *piQueueCount )
//
//  Input parameters:
//      LPTSTR szMQISName
//
//  Output parameters:
//      number of all sites in enterprise, if it is PEC; otherwise 1
//      number of all machines in enterprise, if it is PEC;
//       otherwise all machines in this SITE
//      number of all queues in enterprise, if it is PEC;
//       otherwise all queues in this SITE
//
//+--------------------------------------------------------------------

HRESULT  MQMig_GetObjectsCount( IN  LPTSTR  szMQISName,
                                OUT UINT   *piSiteCount,
                                OUT UINT   *piMachineCount,
                                OUT UINT   *piQueueCount,
								OUT UINT   *piUserCount
							   )
{
    HRESULT hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return hr ;
    }

    char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
    ConvertToMultiByteString(szMQISName,
                             szDSNServerName,
                 (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
    lstrcpy(szDSNServerName, szMQISName) ;
#endif

    hr = MakeMQISDsn(szDSNServerName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szMQISName, hr) ;
        return hr ;
    }

    hr =  ConnectToDatabase() ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szMQISName, hr) ;
        return hr ;
    }

    if (g_dwMyService == SERVICE_PSC)
    {
        *piSiteCount = 1;

        hr =  GetMachinesCount(&g_MySiteGuid,
                               piMachineCount) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_COUNT, hr) ;
            return hr ;
        }

        //
        // get all queues in site
        //
        hr = GetAllQueuesInSiteCount( &g_MySiteGuid,
                                      piQueueCount );
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_QUEUES_COUNT, hr) ;
            return hr;
        }

        return MQMig_OK;
    }

    hr = GetSitesCount(piSiteCount) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SITES_COUNT, hr) ;
        return hr ;
    }
    LogMigrationEvent(MigLog_Info, MQMig_I_SITES_COUNT, *piSiteCount) ;

    //
    // get all machines in Enterprise
    //
    hr = GetAllMachinesCount(piMachineCount);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_COUNT, hr) ;
        return hr ;
    }

    //
    // get all queues in Enterprise
    //
    hr = GetAllQueuesCount(piQueueCount);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_QUEUES_COUNT, hr) ;
        return hr;
    }

	hr = GetUserCount(piUserCount);
	if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_USERS_COUNT, hr) ;
        return hr ;
    }
    LogMigrationEvent(MigLog_Info, MQMig_I_USERS_COUNT, *piUserCount) ;

    return MQMig_OK;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_GetAllCounters( UINT   *piSiteCount,
//                                 UINT   *piMachineCount,
//                                 UINT   *piQueueCount,
//								   UINT   *piUserCount )
//
//  Output parameters:
//      current SiteCounter
//      current MachineCounter
//      current QueueCounter
//		current UserCounter
//
//+--------------------------------------------------------------------

HRESULT  MQMig_GetAllCounters( OUT UINT   *piSiteCounter,
                               OUT UINT   *piMachineCounter,
                               OUT UINT   *piQueueCounter,
							   OUT UINT	  *piUserCounter
							 )
{
    *piSiteCounter =    g_iSiteCounter;
    *piMachineCounter = g_iMachineCounter;
    *piQueueCounter =   g_iQueueCounter;
	*piUserCounter =	g_iUserCounter;

    return MQMig_OK;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_SetSiteIdOfPEC( IN  LPTSTR  szRemoteMQISName )
//
//  Function is called in recovery mode only. We have to replace
//  PEC machine 's SiteID we got from setup to its correct NT4 SiteId
//
//+--------------------------------------------------------------------

HRESULT  MQMig_SetSiteIdOfPEC( IN  LPTSTR  szRemoteMQISName,
                               IN  BOOL	   fIsClusterMode,		
                               IN  DWORD   dwInitError,
                               IN  DWORD   dwConnectDatabaseError,
                               IN  DWORD   dwGetSiteIdError,
                               IN  DWORD   dwSetRegistryError,
                               IN  DWORD   dwSetDSError)
{    
    char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
    ConvertToMultiByteString(szRemoteMQISName,
                             szDSNServerName,
                 (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
    lstrcpy(szDSNServerName, szRemoteMQISName) ;
#endif

    HRESULT hr = MakeMQISDsn(szDSNServerName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szRemoteMQISName, hr) ;
        return dwConnectDatabaseError ;
    }

    hr =  ConnectToDatabase() ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szRemoteMQISName, hr) ;
        return dwConnectDatabaseError ;
    }

    ULONG ulService = 0;
    g_fClusterMode = fIsClusterMode;
    
    hr = GetSiteIdOfPEC (szRemoteMQISName, &ulService, &g_MySiteGuid);
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_GET_SITEID, szRemoteMQISName, hr) ;
        return dwGetSiteIdError ;
    }

    //
    // update registry:
    // MasterId entry will be created (it does not exist after setup)
    // SiteId entry will be updated to the correct value
    //
    g_fReadOnly = FALSE;    //we write to registry only if this flag is FALSE
	
    //
    // write MasterId in Migration section to know later that migration tool 
    // added this registry
    //
    BOOL f = MigWriteRegistryGuid( MIGRATION_MQIS_MASTERID_REGNAME,
			                       &g_MySiteGuid ) ;
    if (!f)
    {
        return  dwSetRegistryError ;
    }
   
    if (fIsClusterMode)
    {
        ASSERT (ulService >= SERVICE_PSC);
    }
    else
    {
        ASSERT (ulService==SERVICE_PEC);    //recovery mode
    }
    
    f = MigWriteRegistryDW( MSMQ_MQS_REGNAME,
			                ulService ) ;

    if (fIsClusterMode)
    {
        //
        // in cluster mode we leave site id of this server as we got it after the setup
        // we don't need update DS too (more than that: on this stage we can't
        // change SiteIDs in DS since this site does not exist in DS. It is possible
        // only in recovery mode)
        //
        return MQMig_OK;
    }

    f = MigWriteRegistryGuid( MSMQ_SITEID_REGNAME,
						      &g_MySiteGuid ) ;
    if (!f)
    {
       return  dwSetRegistryError ;
    }	

    //
    // update DS information
    //
    hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return dwInitError ;
    }
    
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                      e_ALL_PROTOCOLS);


    PROPID       SiteIdsProp = PROPID_QM_SITE_IDS;
    PROPVARIANT  SiteIdsVar;
    SiteIdsVar.vt = VT_CLSID|VT_VECTOR;
    SiteIdsVar.cauuid.cElems = 1;
    SiteIdsVar.cauuid.pElems = &g_MySiteGuid;

    hr = DSCoreSetObjectProperties (
                MQDS_MACHINE,
                NULL,             //path name
                &g_MyMachineGuid,	 // guid
                1,
                &SiteIdsProp,
                &SiteIdsVar,
                &requestContext,
                NULL );    

    if (FAILED(hr))
    {
       return dwSetDSError;
    }

    return MQMig_OK;
}

//+--------------------------------------------------------------------
//
//  HRESULT  MQMig_UpdateRemoteMQIS()
//
//  Function is called in update mode only. It means that we ran migration
//  tool to migrate all objects from MQIS database of clustered PEC. 
//  While the clustered PEC was upgraded there were several off-line
//  servers. We are going to update them.
//  We have to update remote MQIS database on specified server (szRemoteMQISName)
//  or on all servers are written in .ini file
//
//+--------------------------------------------------------------------
HRESULT  MQMig_UpdateRemoteMQIS( 
                      IN  DWORD   dwGetRegistryError,
                      IN  DWORD   dwInitError,
                      IN  DWORD   dwUpdateMQISError,  
                      OUT LPTSTR  *ppszUpdatedServerName,
                      OUT LPTSTR  *ppszNonUpdatedServerName
                      )
{
    //
    // first, check if have all needed registry key
    //
    HRESULT hr = _InitializeMigration() ;
    if (FAILED(hr))
    {
        return dwInitError ;
    }
    
    if (g_dwMyService == SERVICE_PSC)
    {
        return MQMig_OK;
    }

    //
    // get guid of former PEC from registry
    //    
    BOOL f = MigReadRegistryGuid( MIGRATION_FORMER_PEC_GUID_REGNAME,
                                  &g_FormerPECGuid ) ;
    if (!f)
    {
       return  dwGetRegistryError ;
    }    
    
    ULONG ulBeforeUpdate = 0;
    BuildServersList(ppszUpdatedServerName, &ulBeforeUpdate);
    hr = ChangeRemoteMQIS ();       

    if (FAILED(hr))
    {        
        ULONG ulAfterUpdate = 0;
        BuildServersList(ppszNonUpdatedServerName, &ulAfterUpdate);
        if (ulBeforeUpdate == ulAfterUpdate)
        {
            //
            // there are no servers which were updated
            //
            delete *ppszUpdatedServerName;
            *ppszUpdatedServerName = NULL;
        }
        else if (ulBeforeUpdate > ulAfterUpdate)
        {
            //
            // several servers (not all) were updated
            //
            RemoveServersFromList(ppszUpdatedServerName, ppszNonUpdatedServerName);
        }
        else
        {
            ASSERT(0);
        }
        return dwUpdateMQISError;
    }    

    return MQMig_OK;
}

//+----------------------------
//
//  Function:   DllMain
//
//-----------------------------

BOOL WINAPI DllMain( IN HANDLE ,
                     IN DWORD  Reason,
                     IN LPVOID Reserved )
{
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )
    {
        case DLL_PROCESS_ATTACH:
        {
            //DisableThreadLibraryCalls( MyModuleHandle );
            break;
        }

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migusers.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    migusers.cpp

Abstract:

    Handle migration of users certificates into active directory.

Author:

    Doron Juster  (DoronJ)

--*/

#include "migrat.h"
#include <mixmode.h>

#include "migusers.tmh"

//+------------------------------
//
//  HRESULT TouchAUser()
//
//  Touch current logged on user to replicate it to nT4 World later
//
//+------------------------------

HRESULT TouchAUser (PLDAP           pLdap,
					LDAPMessage		*pEntry )
{
    WCHAR **ppPath = ldap_get_values( pLdap,
                                      pEntry,
                        const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE) ) ;
    ASSERT(ppPath) ;

    WCHAR **ppDesc = ldap_get_values( pLdap,
                                      pEntry,
                    const_cast<LPWSTR> (MQ_U_DESCRIPTION_ATTRIBUTE) ) ;

    HRESULT hr = MQMig_OK;

    if (ppDesc)
    {
        //
        // description was defined: change it and return to initial value
        //
        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             NULL,
             NULL
             );

        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             *ppDesc,
             NULL
             );

    }
    else
    {
        //
        // description was not set: change to something and reset it
        //
        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             L"MSMQ",
             NULL
             );

        hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DESCRIPTION_ATTRIBUTE),
             NULL,
             NULL
             );
    }

    //
    // delete mig attributes (if they are defined) to replicate
    // all certificates and digests of this user
    // see replserv\rpusers.cpp: we replicate only such digests and certificates
    // which are presented in Digest and Certificate attributes
    // and not presented in mig attributes.
    //
    hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_DIGEST_MIG_ATTRIBUTE),
             NULL,
             NULL
             );

    hr = ModifyAttribute(
             *ppPath,
             const_cast<WCHAR*> (MQ_U_SIGN_CERT_MIG_ATTRIBUTE),
             NULL,
             NULL
             );

    int i = ldap_value_free( ppDesc ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    i = ldap_value_free( ppPath ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    return hr;
}
//-------------------------------------------------------------------------
//
//  HRESULT HandleAUser
//
//  Copy the MSMQ certificates in the specific user object to the "mig" attributes.
//  These attributes mirror the  "normal" msmq attributes in the user
//  object and are used in the replication service, to enable replication
//  of changes to MSMQ1.0.
//
//-------------------------------------------------------------------------

HRESULT HandleAUser(PLDAP           pLdap,
					LDAPMessage		*pEntry )
{
    HRESULT hr = MQMig_OK;

    WCHAR **ppPath = ldap_get_values( pLdap,
                                          pEntry,
                        const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE) ) ;
    ASSERT(ppPath) ;

    PLDAP_BERVAL *ppVal = ldap_get_values_len( pLdap,
                                               pEntry,
                   const_cast<LPWSTR> (MQ_U_DIGEST_ATTRIBUTE) ) ;
    ASSERT(ppVal) ;
    if (ppVal && ppPath)
    {
        hr = ModifyAttribute(
                 *ppPath,
                 const_cast<WCHAR*> (MQ_U_DIGEST_MIG_ATTRIBUTE),
                 NULL,
                 ppVal
                 );
    }
    int i = ldap_value_free_len( ppVal ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    ppVal = ldap_get_values_len( pLdap,
                                 pEntry,
                   const_cast<LPWSTR> (MQ_U_SIGN_CERT_ATTRIBUTE) ) ;
    ASSERT(ppVal) ;
    if (ppVal && ppPath)
    {
        hr = ModifyAttribute(
                 *ppPath,
                 const_cast<WCHAR*> (MQ_U_SIGN_CERT_MIG_ATTRIBUTE),
                 NULL,
                 ppVal
                 );
    }

    i = ldap_value_free_len( ppVal ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    i = ldap_value_free( ppPath ) ;
    ASSERT(i == LDAP_SUCCESS) ;

    return hr;
}

//-------------------------------------------------------------------------
//
//  HRESULT  _CopyUserValuesToMig()
//
//  Copy the MSMQ certificates in the user object to the "mig" attributes.
//  These attributes mirror the  "normal" msmq attributes in the user
//  object and are used in the replication service, to enable replication
//  of changes to MSMQ1.0.
//
//-------------------------------------------------------------------------

HRESULT _CopyUserValuesToMig(BOOL fMSMQUserContainer)
{
    HRESULT hr;

    PLDAP pLdapGC = NULL ;
    TCHAR *pszDefName = NULL ;

    hr =  InitLDAP(&pLdapGC, &pszDefName, LDAP_GC_PORT) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // to get schema naming context we need pLdap opened with LDAP_PORT
    // we can use the same variable pszDefName since then we re-define it
    //
    PLDAP pLdap = NULL;
    hr =  InitLDAP(&pLdap, &pszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdap, &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // we are looking for all users and msmq users in GC,
    // so we need to start from the root
    // => redefine default context to empty string
    //
    pszDefName = EMPTY_DEFAULT_CONTEXT;

    DWORD dwDNSize = wcslen(pszDefName) ;
    P<WCHAR> pwszDN  = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, pszDefName);

    TCHAR *pszCategoryName;
    if (fMSMQUserContainer)
    {
        pszCategoryName = const_cast<LPTSTR> (x_MQUserCategoryName);
    }
    else
    {
        pszCategoryName = const_cast<LPTSTR> (x_UserCategoryName);
    }

    TCHAR wszFullName[256];
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName,pszSchemaDefName);

    TCHAR  wszFilter[ 512 ] ;
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;
    _tcscat(wszFilter, wszFullName);

    _tcscat(wszFilter, TEXT(")(")) ;
    _tcscat(wszFilter, MQ_U_SIGN_CERT_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=*))")) ;

    PWSTR rgAttribs[4] = {NULL, NULL, NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (MQ_U_SIGN_CERT_ATTRIBUTE);
    rgAttribs[1] = const_cast<LPWSTR> (MQ_U_DIGEST_ATTRIBUTE);
    rgAttribs[2] = const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE);

    hr = QueryDS(   pLdapGC,			
                    pwszDN,
                    wszFilter,			
                    MQDS_USER,
                    rgAttribs,
                    FALSE
                );

    return hr;
}

//-------------------------------------------
//
//  HRESULT  _InsertUserInNT5DS()
//
//-------------------------------------------

HRESULT _InsertUserInNT5DS(
			PBYTE pSID,	
			ULONG ulSidLength,
			PBYTE pSignCert,
			ULONG ulSignCertLength,
			GUID* pDigestId,
			GUID* pUserId
			)
{
    PSID pSid = (PSID) pSID ;
    if (!IsValidSid(pSid))
    {
        HRESULT hr = MQMig_E_SID_NOT_VALID ;
        LogMigrationEvent(MigLog_Error, hr) ;
        return hr ;
    }

    DWORD dwSidLen = GetLengthSid(pSid) ;
    if (dwSidLen > ulSidLength)
    {
        HRESULT hr = MQMig_E_SID_LEN ;
        LogMigrationEvent(MigLog_Error, hr) ;
        return hr ;
    }

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

	//
    // Prepare the properties for DS call.
    //
    LONG cAlloc = 4;
    P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];
    P<PROPID>      paPropId  = new PROPID[ cAlloc ];
    DWORD          PropIdCount = 0;

    paPropId[ PropIdCount ] = PROPID_U_ID;		//PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
    paVariant[PropIdCount].puuid = pUserId ;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_U_SID;			//PropId
    paVariant[ PropIdCount ].vt = VT_BLOB;          //Type
	paVariant[ PropIdCount ].blob.cbSize = dwSidLen ;
	paVariant[ PropIdCount ].blob.pBlobData = pSID;
    PropIdCount++;

	paPropId[ PropIdCount ] = PROPID_U_SIGN_CERT;   //PropId
    paVariant[ PropIdCount ].vt = VT_BLOB;          //Type
	paVariant[ PropIdCount ].blob.cbSize = ulSignCertLength;
	paVariant[ PropIdCount ].blob.pBlobData = pSignCert;
    PropIdCount++;

	paPropId[ PropIdCount ] = PROPID_U_DIGEST;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;       //Type
    paVariant[ PropIdCount ].puuid = pDigestId;
    PropIdCount++;

	ASSERT((LONG) PropIdCount == cAlloc) ;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

	HRESULT hr = DSCoreCreateObject( MQDS_USER,
            						 NULL,
			            			 PropIdCount,
						             paPropId,
            						 paVariant,
                                     0,
                                     NULL,
                                     NULL,
                                     &requestContext,
                                     NULL,
                                     NULL ) ;

    if (g_fAlreadyExistOK)
    {
        if ((hr == MQDS_CREATE_ERROR)                               ||
            (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))        ||
            (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)) ||    //BUGBUG alexdad to throw away after transition
            (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS)))
        {
            //
            // For user object, the mqdscore library return MQDS_CREATE_ERROR
            // if the record (certificate) already exist in the DS.
            // In this case, this is OK.
            //
            hr = MQMig_OK ;
        }
    }

	return hr;
}

//-------------------------------------------
//
//  HRESULT MigrateUsers()
//
//-------------------------------------------

#define INIT_USER_COLUMN(_ColName, _ColIndex, _Index)               \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateUsers(LPTSTR lpszDcName)
{
    HRESULT hr = OpenUsersTable() ;
    CHECK_HR(hr) ;

    ULONG cColumns = 0 ;
	ULONG cAlloc = 4 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_USER_COLUMN(U_SID,			iSIDIndex,			cColumns) ;
	INIT_USER_COLUMN(U_DIGEST,		iDigestIndex,		cColumns) ;
	INIT_USER_COLUMN(U_SIGN_CERT,	iSignCertIndex,		cColumns) ;
	INIT_USER_COLUMN(U_ID,			iIdIndex,			cColumns) ;

    ASSERT(cColumns == cAlloc);

    MQDBHANDLE hQuery = NULL ;
    MQDBSTATUS status = MQDBOpenQuery( g_hUsersTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    if (status == MQDB_E_NO_MORE_DATA)
    {
        LogMigrationEvent(MigLog_Warning, MQMig_I_NO_USERS) ;
        return MQMig_OK ;
    }
    CHECK_HR(status) ;
    
    DWORD dwErr = 0 ;
    HRESULT hr1 = MQMig_OK;

    while(SUCCEEDED(status))
    {
#ifdef _DEBUG
        UINT iIndex = g_iUserCounter ;
        static BOOL s_fIniRead = FALSE ;
        static BOOL s_fPrint = FALSE ;

        if (!s_fIniRead)
        {
            s_fPrint = (UINT)  ReadDebugIntFlag(TEXT("PrintUsers"), 1) ;
            s_fIniRead = TRUE ;
        }

        if (s_fPrint)
        {
            TCHAR  szUserName[ 512 ] = {TEXT('\0')} ;
            DWORD  cUser = sizeof(szUserName) / sizeof(szUserName[0]) ;
            TCHAR  szDomainName[ 512 ] = {TEXT('\0')} ;
            DWORD  cDomain = sizeof(szDomainName) / sizeof(szDomainName[0]) ;
            SID_NAME_USE  se ;

            BOOL f = LookupAccountSid(
                            lpszDcName,
                            (PSID) pColumns[ iSIDIndex ].nColumnValue,
                            szUserName,
                            &cUser,
                            szDomainName,
                            &cDomain,
                            &se ) ;
            if (!f)
            {
                dwErr = GetLastError() ;
                szUserName[0] = TEXT('\0') ;
                szDomainName[0] = TEXT('\0') ;
            }

            unsigned short *lpszGuid ;
            UuidToString((GUID*) pColumns[ iDigestIndex ].nColumnValue,
                          &lpszGuid ) ;

            LogMigrationEvent( MigLog_Info,
                               MQMig_I_USER_MIGRATED,
                               iIndex,
                               szDomainName,
                               szUserName,
                               lpszGuid ) ;
            RpcStringFree( &lpszGuid ) ;
            iIndex++ ;
        }
#endif
	
		HRESULT hr = _InsertUserInNT5DS(
					        (PBYTE) pColumns[ iSIDIndex ].nColumnValue,			//"SID"
					        pColumns[ iSIDIndex ].nColumnLength,
					        (PBYTE) pColumns[ iSignCertIndex ].nColumnValue,	//"SignCert"
					        pColumns[ iSignCertIndex ].nColumnLength,
					        (GUID*) pColumns[ iDigestIndex ].nColumnValue,		//"Digest"
					        (GUID*) pColumns[ iIdIndex ].nColumnValue			//"UserId"
					        );
        
        if (FAILED (hr))
        {
            //
            // log the error
            //
            TCHAR  szUserName[ 512 ] = {TEXT('\0')} ;
            DWORD  cUser = sizeof(szUserName) / sizeof(szUserName[0]) ;
            TCHAR  szDomainName[ 512 ] = {TEXT('\0')} ;
            DWORD  cDomain = sizeof(szDomainName) / sizeof(szDomainName[0]) ;
            SID_NAME_USE  se ;

            BOOL f = LookupAccountSid(
                            lpszDcName,
                            (PSID) pColumns[ iSIDIndex ].nColumnValue,
                            szUserName,
                            &cUser,
                            szDomainName,
                            &cDomain,
                            &se ) ;
            if (!f)
            {
                dwErr = GetLastError() ;
                szUserName[0] = TEXT('\0') ;
                szDomainName[0] = TEXT('\0') ;
            }

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_REFERRAL))
            {                
                LogMigrationEvent( MigLog_Error,
                                   MQMig_E_USER_REMOTE_DOMAIN_OFFLINE,
                                   szDomainName ) ;
            }
            else
            {
                LogMigrationEvent( MigLog_Error,
                                   MQMig_E_CANT_MIGRATE_USER,
                                   szUserName, szDomainName, hr ) ;
            }

            //
            // save error to return it and continue with the next user
            //
            hr1 = hr ;  
        }

        for ( ULONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
      
		g_iUserCounter++;

        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;
    
    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_USERS_SQL_FAIL, status) ;

        return status ;
    }

    ASSERT(g_iUserCounter != 0) ;

    if (FAILED(hr1))
    {
        return hr1 ;
    }

    //
    // for each created user copy Digest and Certificates to
    // DigestMig and CertificatesMig
    //
    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    hr1 = _CopyUserValuesToMig(FALSE);   //modify user objects
    hr = _CopyUserValuesToMig(TRUE);             //modify mquser objects

    if ((hr1 == MQMig_OK) || (hr == MQMig_OK))
    {
        return MQMig_OK;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migsetup.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migsetup.cpp

Abstract:

    Code which was copied from the setup dll.

Author:

    Doron Juster  (DoronJ)  01-Feb-1998

--*/

#include "migrat.h"
#include <version.h>
#include "resource.h"
#include "..\..\mqutil\resource.h"

#include "migsetup.tmh"

#define MAX_STRING_CHARS  512

//+--------------------------------------------------------------
//
// Function: _FormInstallType
//
// Synopsis: Generates installation type information
//
//+--------------------------------------------------------------

static  TCHAR s_wszVersion[ MAX_STRING_CHARS ];

LPWSTR OcmFormInstallType(DWORD dwOS)
{
    CResString strOS;

    switch (dwOS)
    {
        case MSMQ_OS_NTE:
            strOS.Load(IDS_NTE_LABEL);
            break;
        case MSMQ_OS_NTS:
            strOS.Load(IDS_NTS_LABEL);
            break;
        case MSMQ_OS_NTW:
            strOS.Load(IDS_NTW_LABEL);
            break;
        case MSMQ_OS_95:
            strOS.Load(IDS_WIN95_LABEL);
            break;
        default:
            strOS.Load(IDS_WINNT_LABEL);
    }

    //
    // Determine the platform type
    //
    SYSTEM_INFO infoPlatform;
    GetSystemInfo(&infoPlatform);

    UINT uPlatformID;
    switch(infoPlatform.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_ALPHA: uPlatformID = IDS_ALPHA_LABEL;   break;
    case PROCESSOR_ARCHITECTURE_PPC:   uPlatformID = IDS_PPC_LABEL;     break;
    default:                           uPlatformID = IDS_INTEL_LABEL;   break;
    }

    CResString strPlatform(uPlatformID);

    //
    // Determine the operating system version
    //
    OSVERSIONINFO infoOS;
    infoOS.dwOSVersionInfoSize = sizeof(infoOS);
    GetVersionEx(&infoOS);

    //
    // Form the version string
    //
	CResString strFormat(IDS_VERSION_LABEL);
	_stprintf(s_wszVersion,
              strFormat.Get(),
              strOS.Get(),
              infoOS.dwMajorVersion,
		      infoOS.dwMinorVersion,
              infoOS.dwBuildNumber & 0xFFFF,
			  strPlatform.Get(),
              rmj,
              rmm,
              rup);

    return s_wszVersion;

} //FormInstallType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migutils.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migutils.cpp

Abstract:

    Utility code.

Author:

    Doron Juster  (DoronJ)  08-Mar-1998

--*/

#include "migrat.h"

#include "migutils.tmh"

//
// define the range of legal DNS characters.
//
#define  NUM_DNS_RANGES  4
static const  TCHAR  sx_chDNSLegal[ NUM_DNS_RANGES ][2] =
                                         { TEXT('0'), TEXT('9'),
                                           TEXT('a'), TEXT('z'),
                                           TEXT('A'), TEXT('Z'),
                                           TEXT('-'), TEXT('-') } ;

//-----------------------------
//
//  Auto delete of ADs allocated string
//
class ADsFree {
private:
    WCHAR * m_p;

public:
    ADsFree() : m_p(0)            {}
    ADsFree(WCHAR* p) : m_p(p)    {}
   ~ADsFree()                     {FreeADsStr(m_p);}

    operator WCHAR*() const   { return m_p; }
    WCHAR** operator&()       { return &m_p;}
    WCHAR* operator->() const { return m_p; }
};

//+-------------------------------------------------------------------
//
//  HRESULT  BlobFromColumns()
//
//  Description: combine several SQL columns into one blob buffer.
//      First DWORD in the buffer is the buffer size, in bytes,
//      NOT including the DWORD itself.
//
//+-------------------------------------------------------------------

HRESULT  BlobFromColumns( MQDBCOLUMNVAL *pColumns,
                          DWORD          adwIndexs[],
                          DWORD          dwIndexSize,
                          BYTE**         ppOutBuf )
{
    //
    // First compute total length.
    //
    DWORD dwTotalSize = 0 ;
    for ( DWORD j = 0 ; j < dwIndexSize ; j++ )
    {
        if (pColumns[ adwIndexs[ j ] ].nColumnValue)
        {
            WORD  wSize = *(
                     (WORD *) pColumns[ adwIndexs[ j ] ].nColumnValue ) ;
            ASSERT( (DWORD) wSize <=
                    (DWORD) pColumns[ adwIndexs[ j ] ].nColumnLength ) ;
            dwTotalSize += (DWORD) wSize ;
        }
    }

    if (dwTotalSize == 0)
    {
        //
        // OK, property does not exist.
        //
        return MQMig_E_EMPTY_BLOB ;
    }

    *ppOutBuf = new BYTE[ dwTotalSize + sizeof(DWORD) ] ;

    //
    // return size of buffer.
    //
    DWORD *pSize = (DWORD*) *ppOutBuf ;
    *pSize = dwTotalSize ;

    //
    // Now copy the columns into the buffer.
    //
    BYTE *pOut = *ppOutBuf + sizeof(DWORD) ;

    for ( j = 0 ; j < dwIndexSize ; j++ )
    {
        if (pColumns[ adwIndexs[ j ] ].nColumnValue)
        {
            BYTE *pBuf = ((BYTE *) pColumns[ adwIndexs[ j ] ].nColumnValue)
                                            + MQIS_LENGTH_PREFIX_LEN ;
            WORD  wSize = *(
                     (WORD *) pColumns[ adwIndexs[ j ] ].nColumnValue ) ;

            memcpy( pOut,  pBuf, wSize ) ;

            pOut += wSize ;
        }
    }

    return MQMig_OK ;
}

//+-------------------------------------------------------------------
//
//  TCHAR *GetIniFileName ()
//
//  By default, mqseqnum.ini file is the system directory.
//
//+-------------------------------------------------------------------

TCHAR *GetIniFileName ()
{
    static BOOL   s_fIniRead = FALSE ;
    static TCHAR  s_wszIniName[ MAX_PATH ] = {TEXT('\0')} ;

    if (!s_fIniRead)
    {
        DWORD dw = GetSystemDirectory( s_wszIniName, MAX_PATH ) ;
        if (dw != 0)
        {
            _tcscat( s_wszIniName, TEXT("\\")) ;
            _tcscat( s_wszIniName, SEQ_NUMBERS_FILE_NAME) ;
        }
        else
        {
            ASSERT(dw != 0) ;
        }
        s_fIniRead = TRUE ;
    }

    return s_wszIniName;
}

//+-------------------------------------------------------------------
//
//  HRESULT AnalyzeMachineType (LPWSTR wszMachineType, BOOL *pfOldVersion)
//
//  fOldVersion is TRUE iff old version of MSMQ 1.0 DS Server installed on the machine
//  old version == version with number less than 280
//
//+-------------------------------------------------------------------

#define MSMQ_SP4_VERSION    280
#define MSMQ_STRING         L"MSMQ"
#define BUILD_STRING        L"Build"
#define BLANK_STRING        L" "

HRESULT AnalyzeMachineType (IN LPWSTR wszMachineType,
                            OUT BOOL  *pfOldVersion)
{
    *pfOldVersion = FALSE;
    WCHAR *ptr = wcsstr( wszMachineType, MSMQ_STRING );
    if (ptr == NULL)
    {
        return MQMig_E_WRONG_MACHINE_TYPE;
    }
    ptr = wcsstr( ptr, BUILD_STRING );
    if (ptr == NULL)
    {
        return MQMig_E_WRONG_MACHINE_TYPE;
    }

    ptr += wcslen(BUILD_STRING) + wcslen(BLANK_STRING);
    WCHAR wszVer[10];
    wszVer[0] = L'\0';

    for (UINT i=0; iswdigit(*ptr); ptr++, i++)
    {
        wszVer[i] = *ptr;
    }
    wszVer[i] = L'\0';
    UINT iVer = _wtoi( wszVer );
    if (iVer == 0)
    {
        return MQMig_E_WRONG_MACHINE_TYPE;
    }

    if (iVer < MSMQ_SP4_VERSION)
    {
        *pfOldVersion = TRUE;
    }

    return MQMig_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:  RunProcess
//
//  Synopsis:  Creates and starts a process
//
//+-------------------------------------------------------------------------
BOOL
RunProcess(
	IN  const LPTSTR szCommandLine,
    OUT       DWORD  *pdwExitCode
	)
{
    //
    // Initialize the process and startup structures
    //
    PROCESS_INFORMATION infoProcess;
    STARTUPINFO	infoStartup;
    memset(&infoStartup, 0, sizeof(STARTUPINFO)) ;
    infoStartup.cb = sizeof(STARTUPINFO) ;
    infoStartup.dwFlags = STARTF_USESHOWWINDOW ;
    infoStartup.wShowWindow = SW_MINIMIZE ;

	//
    // Create the process
    //
    BOOL bProcessSucceeded = FALSE;
    BOOL bProcessCompleted = TRUE ;

    if (!CreateProcess( NULL,
                        szCommandLine,
                        NULL,
                        NULL,
                        FALSE,
                        DETACHED_PROCESS,
                        NULL,
                        NULL,
                        &infoStartup,
                        &infoProcess ))
    {
		*pdwExitCode = GetLastError();
        return FALSE;
    }

    //
    // Wait for the process to terminate within the timeout period
    //
    if (WaitForSingleObject(infoProcess.hProcess, INFINITE) != WAIT_OBJECT_0)
    {
       bProcessCompleted =  FALSE ;
    }

    if (!bProcessCompleted)
    {
        *pdwExitCode = GetLastError();
    }
    else
    {
       //
       // Obtain the termination status of the process
       //
       if (!GetExitCodeProcess(infoProcess.hProcess, pdwExitCode))
       {
           *pdwExitCode = GetLastError();
       }

       //
       // No error occurred
       //
       else
       {
           bProcessSucceeded = TRUE;
       }
    }

    //
    // Close the thread and process handles
    //
    CloseHandle(infoProcess.hThread);
    CloseHandle(infoProcess.hProcess);

    return bProcessSucceeded;

} //RunProcess

//+-------------------------
//
//  void StringToSeqNum()
//
//+-------------------------

void StringToSeqNum( IN TCHAR    pszSeqNum[],
                     OUT CSeqNum *psn )
{
    BYTE *pSN = const_cast<BYTE*> (psn->GetPtr()) ;
    DWORD dwSize = psn->GetSerializeSize() ;
    ASSERT(dwSize == 8) ;

    WCHAR wszTmp[3] ;

    for ( DWORD j = 0 ; j < dwSize ; j++ )
    {
        memcpy(wszTmp, &pszSeqNum[ j * 2 ], (2 * sizeof(TCHAR))) ;
        wszTmp[2] = 0 ;

        DWORD dwTmp ;
        _stscanf(wszTmp, TEXT("%2x"), &dwTmp) ;
        *pSN = (BYTE) dwTmp ;
        pSN++ ;
    }
}

/*====================================================

CalHashKey()

Arguments:

Return Value:

=====================================================*/

DWORD CalHashKey( IN LPCWSTR pwcsPathName )
{
    ASSERT( pwcsPathName ) ;

    DWORD   dwHashKey = 0;
    WCHAR * pwcsTmp;

    AP<WCHAR> pwcsUpper = new WCHAR[ lstrlen(pwcsPathName) + 1];
    lstrcpy( pwcsUpper, pwcsPathName);
    CharUpper( pwcsUpper);
    pwcsTmp = pwcsUpper;


    while (*pwcsTmp)
        dwHashKey = (dwHashKey<<5) + dwHashKey + *pwcsTmp++;

    return(dwHashKey);
}

//+-------------------------------------------------------------------------
//
//  Function:  BuildServersList
//
//  Synopsis:  Get all non-updated servers from .ini
//
//+-------------------------------------------------------------------------
void BuildServersList(LPTSTR *ppszServerName, ULONG *pulServerCount)
{
    TCHAR *pszFileName = GetIniFileName ();
    ULONG ulServerNum = GetPrivateProfileInt(
                                MIGRATION_ALLSERVERSNUM_SECTION,	// address of section name
                                MIGRATION_ALLSERVERSNUM_KEY,      // address of key name
                                0,							    // return value if key name is not found
                                pszFileName					    // address of initialization filename);
                                );

    if (ulServerNum == 0)
    {
        return;
    }

    ULONG ulNonUpdatedServers = GetPrivateProfileInt(
                                        MIGRATION_NONUPDATED_SERVERNUM_SECTION,
                                        MIGRATION_ALLSERVERSNUM_KEY,
                                        0,
                                        pszFileName
                                        ) ;
    if (ulNonUpdatedServers == 0)
    {
        return ;
    }

    TCHAR *pszList = new TCHAR[ulNonUpdatedServers * MAX_PATH];
    _tcscpy(pszList, TEXT(""));

    ULONG ulCounter = 0;
    for (ULONG i=0; i<ulServerNum; i++)
    {
        TCHAR szCurServerName[MAX_PATH];
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_ALLSERVERS_NAME_KEY, i+1);
        DWORD dwRetSize =  GetPrivateProfileString(
                                    MIGRATION_ALLSERVERS_SECTION ,			// points to section name
                                    tszKeyName,	// points to key name
                                    TEXT(""),                 // points to default string
                                    szCurServerName,          // points to destination buffer
                                    MAX_PATH,                 // size of destination buffer
                                    pszFileName               // points to initialization filename);
                                    );
        if (_tcscmp(szCurServerName, TEXT("")) == 0 ||
            dwRetSize == 0)     //low resources
        {
            continue;
        }

        _tcscat(pszList, szCurServerName);
        _tcscat(pszList, TEXT("\n"));

        ulCounter++;
    }

    ASSERT(ulCounter == ulNonUpdatedServers);
    *pulServerCount = ulCounter;

    *ppszServerName = pszList;
}

//+-------------------------------------------------------------------------
//
//  Function:  RemoveServersFromList
//
//  Synopsis:  remove non-updated servers from the list of updated servers
//
//+-------------------------------------------------------------------------
void RemoveServersFromList(LPTSTR *ppszUpdatedServerName,
                           LPTSTR *ppszNonUpdatedServerName)
{
    ASSERT(*ppszUpdatedServerName);
    ASSERT(*ppszNonUpdatedServerName);

    TCHAR *pcNextChar = *ppszUpdatedServerName;

    DWORD dwLen = _tcslen(*ppszUpdatedServerName) + 1;
    AP<TCHAR> pszNewServerList = new TCHAR[dwLen];
    _tcscpy(pszNewServerList, TEXT(""));

    while (*pcNextChar != _T('\0'))
    {
        TCHAR *pcEnd = _tcschr( pcNextChar, _T('\n') );
        ASSERT(pcEnd != NULL);

        TCHAR szCurServer[MAX_PATH];
        _tcsncpy(szCurServer, pcNextChar, pcEnd-pcNextChar+1);
        szCurServer[pcEnd-pcNextChar+1] = _T('\0');

        BOOL fFound = FALSE;
        TCHAR *pcNextNonUpd = *ppszNonUpdatedServerName;
        while (*pcNextNonUpd != _T('\0'))
        {
            TCHAR *pcEndNonUpd = _tcschr( pcNextNonUpd, _T('\n') );
            ASSERT(pcEndNonUpd != NULL);

            TCHAR szCurNonUpdServer[MAX_PATH];
            _tcsncpy(szCurNonUpdServer, pcNextNonUpd, pcEndNonUpd-pcNextNonUpd+1);
            szCurNonUpdServer[pcEndNonUpd-pcNextNonUpd+1] = _T('\0');

            if (_tcscmp(szCurNonUpdServer, szCurServer) == 0)
            {
                //
                // we found this server in non-updated list
                //
                fFound = TRUE;
                break;
            }
            pcNextNonUpd = pcEndNonUpd+1;
        }
        if (!fFound)
        {
            //
            // this server was updated
            //
            _tcscat(pszNewServerList,szCurServer);
        }

        pcNextChar = pcEnd + 1;
    }

    _tcscpy(*ppszUpdatedServerName, pszNewServerList);
}

//+-------------------------------------------------------------------------
//
//  Function:  IsObjectNameValid
//
//  Synopsis:  return TRUE if object name (name of site, foreign CN or machine) is valid
//
//+-------------------------------------------------------------------------
BOOL IsObjectNameValid(TCHAR *pszObjectName)
{
    //
    // check if object name (as read from MQIS) is a legal DNS name (as defined
    // in rfc 1035). If not, change it.
    // In MSMQ1.0, any string is a legal object name. In NT5 DS, site/machine name must
    // conform to rfc 1035, containing only letters and digits.
    //
    BOOL fOk = FALSE ;
    DWORD dwLen = _tcslen(pszObjectName) ;

    for ( DWORD j = 0 ; j < dwLen ; j++ )
    {
        fOk = FALSE ;
        TCHAR ch = pszObjectName[j] ;

        //
        // Inner loop on all legal ranges.
        //
        for ( DWORD k = 0 ; k < NUM_DNS_RANGES ; k++ )
        {
            if ((ch >= sx_chDNSLegal[k][0]) && (ch <= sx_chDNSLegal[k][1]))
            {
                fOk = TRUE ;
                break ;
            }
        }

        if (!fOk)
        {
            break ;
        }
    }

    return fOk;
}

//+--------------------------------------------------------------
//
//  HRESULT IsObjectGuidInIniFile
//	Return TRUE if given guid is found under the specific section in .ini file
//
//+--------------------------------------------------------------

BOOL IsObjectGuidInIniFile(IN GUID      *pObjectGuid,
                           IN LPWSTR    pszSectionName)
{
    TCHAR *pszFileName = GetIniFileName ();

    unsigned short *lpszGuid ;
    UuidToString( pObjectGuid, &lpszGuid ) ;

    TCHAR szValue[50];
    DWORD dwRetSize;
    dwRetSize =  GetPrivateProfileString(
                      pszSectionName,     // points to section name
                      lpszGuid,                 // points to key name
                      TEXT(""),                 // points to default string
                      szValue,                  // points to destination buffer
                      50,                       // size of destination buffer
                      pszFileName               // points to initialization filename);
                      );

    RpcStringFree( &lpszGuid ) ;

    if (_tcscmp(szValue, TEXT("")) == 0)
    {
        //
        // the entry does not exist
        //
        return FALSE;
    }

    return TRUE;
}

//+--------------------------------------------------------------
//
//  HRESULT GetCurrentUserSid
//
//+--------------------------------------------------------------

HRESULT GetCurrentUserSid ( IN HANDLE    hToken,
                            OUT TCHAR    **ppszSid)
{
    HRESULT hr = MQMig_OK;

    BYTE rgbBuf[128];
    DWORD dwSize = 0;
    P<BYTE> pBuf;
    TOKEN_USER * pTokenUser = NULL;

    if (GetTokenInformation( hToken,
                             TokenUser,
                             rgbBuf,
                             sizeof(rgbBuf),
                             &dwSize))
    {
        pTokenUser = (TOKEN_USER *) rgbBuf;
    }
    else if (dwSize > sizeof(rgbBuf))
    {
        pBuf = new BYTE [dwSize];
        if (GetTokenInformation( hToken,
                                 TokenUser,
                                 (BYTE *)pBuf,
                                 dwSize,
                                 &dwSize))
        {
            pTokenUser = (TOKEN_USER *)((BYTE *)pBuf);
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            LogMigrationEvent(MigLog_Error, MQMig_E_GET_TOKEN_INFORMATION, hr);						
            return hr;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_TOKEN_INFORMATION, hr);						
        return hr;
    }

    if (!pTokenUser)
    {
        hr = MQMig_E_GET_TOKEN_INFORMATION;
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_TOKEN_INFORMATION, hr);						
        return hr;
    }

    //
    // This is the SID of the user running the process !!!
    //
    SID *pSid = (SID*) pTokenUser->User.Sid ;
    DWORD dwSidLen = GetLengthSid(pSid) ;
    ASSERT (dwSidLen);
    ASSERT (IsValidSid(pSid));

    ADsFree  pwcsSid;
    hr = ADsEncodeBinaryData(
                  (unsigned char *) pSid,
                  dwSidLen,
                  &pwcsSid
                );

    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_ENCODE_BINARY_DATA, hr);
        return hr;
    }

    *ppszSid = new WCHAR[ wcslen( pwcsSid) + 1];
    wcscpy( *ppszSid, pwcsSid);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migreg.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migreg.cpp

Abstract:

    Handle registry.

Author:

    Doron Juster  (DoronJ)  22-Mar-1998

--*/

#include "migrat.h"
#include "mqtypes.h"
#include "_mqreg.h"
#include "..\..\setup\msmqocm\service.h"

#include "migreg.tmh"

//============================================
//
//   BOOL GenerateSubkeyValue()
//
//============================================

BOOL _GenerateSubkeyValue(
                	IN     const BOOL    fWriteToRegistry,
                	IN     const LPCTSTR szEntryName,
                	IN OUT       PTCHAR  szValueName,
                	IN OUT       HKEY    &hRegKey)
{
    //
    // Store the full subkey path and value name
    //
    TCHAR szKeyName[256 * MAX_BYTES_PER_CHAR];
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    if (szValueName)
    {
        _tcscpy(szValueName, _tcsinc(pLastBackslash));
        _tcscpy(pLastBackslash, TEXT(""));
    }

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;
    HRESULT hResult = RegCreateKeyEx( FALCON_REG_POS,
                                      szKeyName,
                                      0,
                                      NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &hRegKey,
                                      &dwDisposition);

	if (hResult != ERROR_SUCCESS && fWriteToRegistry)
	{
        LogMigrationEvent(MigLog_Error, MQMig_E_CREATE_REG,
                                                szKeyName, hResult) ;
		return FALSE;
	}

	return TRUE;
}

//============================================
//
//  _WriteRegistryValue()
//
//============================================

BOOL
_WriteRegistryValue(
    IN const LPCTSTR szEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData)
{
    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
	HKEY hRegKey;

	if (!_GenerateSubkeyValue( TRUE, szEntryName, szValueName, hRegKey))
    {
        return FALSE;
    }

    //
    // Set the requested registry value
    //
    LONG rc = ERROR_SUCCESS ;
    if (!g_fReadOnly)
    {
        rc = RegSetValueEx( hRegKey,
                            szValueName,
                            0,
                            dwValueType,
                            (BYTE *)pValueData,
                            dwNumBytes);
    }
    RegFlushKey(hRegKey);
    RegCloseKey(hRegKey);

    return (rc == ERROR_SUCCESS);
}

//============================================
//
//  _ReadRegistryValue()
//
//============================================

BOOL
_ReadRegistryValue(
    IN const LPCTSTR szEntryName,
    IN       DWORD   *pdwNumBytes,
    IN       DWORD   *pdwValueType,
    IN const PVOID   pValueData)
{
    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
	HKEY hRegKey;

	if (!_GenerateSubkeyValue( TRUE, szEntryName, szValueName, hRegKey))
    {
        return FALSE;
    }

    //
    // Set the requested registry value
    //
    LONG rc = RegQueryValueEx( hRegKey,
                               szValueName,
                               0,
                               pdwValueType,
                               (BYTE *)pValueData,
                               pdwNumBytes );
    RegCloseKey(hRegKey);

    return (rc == ERROR_SUCCESS);
}

//============================================
//
//  BOOL MigWriteRegistrySz()
//
//============================================

BOOL  MigWriteRegistrySz( LPTSTR  lpszRegName,
                          LPTSTR  lpszValue )
{
    if (!_WriteRegistryValue( lpszRegName,
                              (_tcslen(lpszValue) * sizeof(TCHAR)),
		                      REG_SZ,
                              lpszValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_SZ,
                                                lpszRegName, lpszValue) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigWriteRegistryDW()
//
//============================================

BOOL  MigWriteRegistryDW( LPTSTR  lpszRegName,
                          DWORD   dwValue )
{
    if (!_WriteRegistryValue( lpszRegName,
                              sizeof(DWORD),
		                      REG_DWORD,
                              &dwValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_DWORD,
                                                lpszRegName, dwValue) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigWriteRegistryGuid()
//
//============================================

BOOL  MigWriteRegistryGuid( LPTSTR  lpszRegName,
                            GUID    *pGuid )
{
    if (!_WriteRegistryValue( lpszRegName,
                              sizeof(GUID),
		                      REG_BINARY,
                              pGuid ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_GUID, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistryGuid()
//
//  Memory for guid must be allocated by caller.
//
//============================================

BOOL  MigReadRegistryGuid( LPTSTR  lpszRegName,
                           GUID    *pGuid )
{
    DWORD dwSize = sizeof(GUID) ;
    DWORD dwType = REG_BINARY ;

    if (!_ReadRegistryValue( lpszRegName,
                             &dwSize,
		                     &dwType,
                             pGuid ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_REG_GUID, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistryDW()
//
//  Memory for dword must be allocated by caller.
//
//============================================

BOOL  MigReadRegistryDW( LPTSTR  lpszRegName,
                         DWORD   *pdwValue )
{
    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;

    if (!_ReadRegistryValue( lpszRegName,
                             &dwSize,
		                     &dwType,
                             pdwValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_REG_DWORD, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistrySz()
//
//  Memory for string must be allocated by caller.
//
//============================================

BOOL  MigReadRegistrySz( LPTSTR  lpszRegName,
                         LPTSTR  lpszValue,
                         DWORD   dwSize)
{
    DWORD dwType = REG_SZ ;

    if (!_ReadRegistryValue( lpszRegName,
                             &dwSize,
		                     &dwType,
                             lpszValue ))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_REG_SZ, lpszRegName) ;
        return FALSE ;
    }

    return TRUE ;
}

//============================================
//
//  BOOL MigReadRegistrySzErr()
//
//  Memory for string must be allocated by caller.
//
//============================================

BOOL  MigReadRegistrySzErr( LPTSTR  lpszRegName,
                            LPTSTR  lpszValue,
                            DWORD   dwSize,
                            BOOL    fShowError )
{
    BOOL fRead ;

    if ( fShowError )
    {
        fRead = MigReadRegistrySz( lpszRegName,
                                   lpszValue,
                                   dwSize ) ;
    }
    else
    {
        DWORD dwType = REG_SZ ;

        fRead = _ReadRegistryValue( lpszRegName,
                                   &dwSize,
	                               &dwType,
                                    lpszValue ) ;
    }

    return fRead ;
}

//-------------------------------------------------
//
//  HRESULT _WriteSeqNumInINIFile()
//
//-------------------------------------------------

HRESULT _WriteSeqNumInINIFile( GUID   *pSiteGuid,
                               __int64 i64HighestUSN,
                               BOOL    fPec )
{
    CSeqNum snMaxLsn ;
    HRESULT hr =  FindLargestSeqNum( pSiteGuid,
                                     snMaxLsn,
                                     fPec ) ;
    CHECK_HR(hr) ;

    unsigned short *lpszGuid ;
    UuidToString( pSiteGuid,
                  &lpszGuid ) ;

    //
    // in cluster mode we have to add this local machine to remote MQIS database.
    // So, we have to increment uiAllObjectNumber for SiteId = MySiteID
    // and to increment SN for this SiteId. We have to do it only for PEC
    // since only PEC machine we'll add later to all remote MQIS databases.
    //
    UINT uiAllObjectNumber = 0;
    if (g_fClusterMode &&                                       // it is cluster mode
        g_dwMyService == SERVICE_PEC &&                         // this machine is PEC
        memcmp(pSiteGuid, &g_MySiteGuid, sizeof(GUID)) == 0)	// it is my site
    {
        snMaxLsn.Increment() ;
        uiAllObjectNumber ++ ;
    }

    TCHAR tszSeqNum[ SEQ_NUM_BUF_LEN ] ;
    snMaxLsn.GetValueForPrint( tszSeqNum ) ;

    //
    // Write the SeqNumber in the ini file.
    //
    TCHAR *pszFileName = GetIniFileName ();
    BOOL f = WritePrivateProfileString( RECENT_SEQ_NUM_SECTION_IN,
                                        lpszGuid,
                                        tszSeqNum,
                                        pszFileName ) ;
    ASSERT(f) ;

    f = WritePrivateProfileString( RECENT_SEQ_NUM_SECTION_OUT,
                                   lpszGuid,
                                   tszSeqNum,
                                   pszFileName ) ;
    ASSERT(f) ;

    f = WritePrivateProfileString( MIGRATION_SEQ_NUM_SECTION,
                                   lpszGuid,
                                   tszSeqNum,
                                   pszFileName ) ;
    ASSERT(f) ;

    __int64 i64SiteSeqNum = 0 ;
    _stscanf(tszSeqNum, TEXT("%I64x"), &i64SiteSeqNum) ;

    //
    // when pre-migration objects are replicated we have to use as initial
    // SN the SN that we got in SyncRequest. We have to be sure that
    // all MSMQ1.0 objects can be replicated and we have sufficient places
    // from the given SN to the first SN of post-migrated objects. To make this,
    // add to delta number of all objects are belonging to the given Master.
    // So,
    // delta = (MaxSN in SQL of this Master) - (Highest USN in NT5 DS) +
    //         (Number of All Objects of this Master)
    //    
    hr = GetAllObjectsNumber (  pSiteGuid,
                                fPec,
                                &uiAllObjectNumber
                             ) ;
    CHECK_HR(hr) ;
	
    __int64 i64Delta = i64SiteSeqNum - i64HighestUSN + uiAllObjectNumber;
    TCHAR wszDelta[ SEQ_NUM_BUF_LEN ] ;
    _stprintf(wszDelta, TEXT("%I64d"), i64Delta) ;

    f = WritePrivateProfileString( MIGRATION_DELTA_SECTION,
                                   lpszGuid,
                                   wszDelta,
                                   pszFileName ) ;
    ASSERT(f) ;

    RpcStringFree( &lpszGuid ) ;

    return MQMig_OK ;
}

//+-------------------------------
//
//  HRESULT  UpdateRegistry()
//
//  This function is called when migration of objects from MQIS to NT5
//  DS is done, to update several values in local registry and in ini file.
//  These values are later used by the replication service.
//
//+-------------------------------

HRESULT  UpdateRegistry( IN UINT  cSites,
                         IN GUID *pSitesGuid )
{
    //
    // Read present highest USN and write it to registry.
    //
    TCHAR wszReplHighestUsn[ SEQ_NUM_BUF_LEN ] ;
    HRESULT hr = ReadFirstNT5Usn(wszReplHighestUsn) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_FIRST_USN, hr) ;
        return hr ;
    }
    BOOL f = MigWriteRegistrySz( HIGHESTUSN_REPL_REG,
                                 wszReplHighestUsn ) ;
    ASSERT(f) ;

    f = MigWriteRegistrySz( LAST_HIGHESTUSN_MIG_REG,
                                 wszReplHighestUsn ) ;
    ASSERT(f) ;

    //
    // Compute delta values to be used by the replication service.
    //
    __int64 i64HighestUSN = 0 ;
    _stscanf(wszReplHighestUsn, TEXT("%I64u"), &i64HighestUSN) ;
    ASSERT(i64HighestUSN > 0) ;

    for ( UINT j = 0 ; j < cSites ; j++ )
    {
        hr = _WriteSeqNumInINIFile( &pSitesGuid[ j ],
                                    i64HighestUSN,
                                    FALSE ) ;
    }

    if (g_dwMyService == SERVICE_PEC)
    {
        //
        // Find and save the highest seq number of the PEC guid (NULL_GUID) ;
        //
        GUID PecGuid ;
        memset(&PecGuid, 0, sizeof(GUID)) ;

        hr = _WriteSeqNumInINIFile( &PecGuid,
                                    i64HighestUSN,
                                    TRUE ) ;
    }

    //
    // Update site id. During migration, the PSC may change site, to match
    // its IP address. It's necessary to "remember" its old NT4 site id,
    // so replication service can find its BSCs.
    // Also, update PSC present site id (NT5 objectGuid of present site).
    //
    LPTSTR szRegName;
    if (g_fRecoveryMode || g_fClusterMode)
    {
        szRegName = MIGRATION_MQIS_MASTERID_REGNAME ;
    }
    else
    {
        szRegName = MSMQ_MQIS_MASTERID_REGNAME ;
    }
    f = MigWriteRegistryGuid( szRegName,
                              &g_MySiteGuid ) ;    
    ASSERT(f) ;

    if (g_fClusterMode && 
        !g_fReadOnly && 
        g_dwMyService == SERVICE_PEC)
    {
        ASSERT(g_FormerPECGuid != GUID_NULL);
        //
        // save guid of former PEC in registry (only on PEC)
        //
        f = MigWriteRegistryGuid( MIGRATION_FORMER_PEC_GUID_REGNAME,
                                  &g_FormerPECGuid ) ;   
        ASSERT(f) ;
    }

    //
    // Remember old NT4 site.
    //
    f = MigWriteRegistryGuid( MSMQ_NT4_MASTERID_REGNAME,
                              &g_MySiteGuid ) ;
    ASSERT(f) ;

    // [adsrv] Adding server functionality keys
    f = MigWriteRegistryDW(MSMQ_MQS_DSSERVER_REGNAME, TRUE);
    ASSERT(f) ;
    // We assume that migration is called only on old PEC/PSC which is now DC/GC so we surely have DS

    f = MigWriteRegistryDW(MSMQ_MQS_ROUTING_REGNAME, TRUE);
    ASSERT(f) ;
    // We assume that old crazy K2 DS/non-router will be router in NT5

    f = MigWriteRegistryDW(MSMQ_MQS_DEPCLINTS_REGNAME, TRUE);
    ASSERT(f) ;
    // All servers support Dep Clients now.

    return MQMig_OK ;
}

//+----------------------------------------------
//
//  HRESULT SetPerformanceRegistry()
//
//+----------------------------------------------

HRESULT SetPerformanceRegistry(
                    HKEY  hRegKey,
                    LPCTSTR pszValueName,
                    LPCTSTR pszValueData
                    )
{
    DWORD dwValueType = REG_SZ;
    DWORD dwNumBytes = _tcslen(pszValueData) * sizeof(TCHAR);
    HRESULT hr = RegSetValueEx( hRegKey,
                                pszValueName,
                                0,
                                dwValueType,
                                (BYTE *)pszValueData,
                                dwNumBytes);

    if (hr != ERROR_SUCCESS)
	{
        LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_SZ,
                                                pszValueName, pszValueData) ;
		return hr;
	}
    RegFlushKey(hRegKey);
    return MQMig_OK;
}

//+-------------------------------
//
//  HRESULT  PrepareRegistryForPerfDll()
//
//  This function is called when migration of objects from MQIS to NT5
//  DS is done, to update performance values in local registry.
//  These values are later used by the replication service.
//
//+-------------------------------

//
// BUGBUG: all this code (in general) must be performed in the setup in upgrade mode
// to allow clear uninstall. But, if we are in recovery mode, we have to do it here.
//
HRESULT PrepareRegistryForPerfDll()
{
    _TCHAR szPerfKey [255];

    _stprintf (szPerfKey,_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"),
               MQ1SYNC_SERVICE_NAME);

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;
    HKEY  hRegKey;
    HRESULT hr = RegCreateKeyEx(  FALCON_REG_POS,
                                  szPerfKey,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hRegKey,
                                  &dwDisposition);

	if (hr != ERROR_SUCCESS)
	{
        LogMigrationEvent(MigLog_Error, MQMig_E_CREATE_REG,
                                                szPerfKey, hr) ;
		return hr;
	}

    hr = SetPerformanceRegistry(hRegKey, TEXT("Library"), TEXT("mqrperf.dll"));
    if (FAILED(hr))
	{
        return hr;
	}

    hr = SetPerformanceRegistry(hRegKey, TEXT("Open"), TEXT("RPPerfOpen"));
    if (FAILED(hr))
	{
        return hr;
	}

    hr = SetPerformanceRegistry(hRegKey, TEXT("Collect"), TEXT("RPPerfCollect"));
    if (FAILED(hr))
	{
        return hr;
	}

    hr = SetPerformanceRegistry(hRegKey, TEXT("Close"), TEXT("RPPerfClose"));
    if (FAILED(hr))
	{
        return hr;
	}

    RegCloseKey(hRegKey);

    TCHAR szSystemDir[MAX_PATH * MAX_BYTES_PER_CHAR];	
	BOOL f = GetSystemDirectory(szSystemDir, MAX_PATH) ;
    DBG_USED(f);
    ASSERT (f);
    SetCurrentDirectory(szSystemDir);	

    //
    // Load the performance counters
    //	
    DWORD dwErr;
	if (RunProcess(TEXT("lodctr mqrperf.ini"), &dwErr))
    {
        //
    	// Delete the performance counter configuration files
        //
     	TCHAR szFileName[MAX_PATH * MAX_BYTES_PER_CHAR];	
 	    _stprintf(szFileName, TEXT("%s\\mqrperf.ini"), szSystemDir);
	    DeleteFile(szFileName);
 	    _stprintf(szFileName, TEXT("%s\\mqrperf.h"), szSystemDir);
	    DeleteFile(szFileName);

    }
    else
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_LOADPERF, dwErr) ;
		return HRESULT_FROM_WIN32(dwErr);
    }

    return MQMig_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\migsites.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migsites.cpp

Abstract:

    Migration NT4 CN objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "migsites.tmh"

//-------------------------------------------------
//
//  HRESULT _InsertSiteInNT5DS()
//
//-------------------------------------------------

static HRESULT _InsertSiteInNT5DS( GUID   *pSiteGuid,
                                   UINT   iIndex,                                   
                                   BOOL   fMySite = FALSE )
{
    UNREFERENCED_PARAMETER(fMySite);
    //
    // Read site properties from MQIS database.
    //
    LONG cAlloc = 4 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_NAME_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_NAME_CTYPE ;
    LONG iSiteNameIndex = cColumns ;
    cColumns++ ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_PSC_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_PSC_CTYPE ;
    LONG iPSCNameIndex = cColumns ;
    cColumns++ ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_INTREVAL1_COL ; //must be S_INTERVAL, ds\h\mqiscol.h
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_INTREVAL1_CTYPE ;  
    LONG iInterval1Index = cColumns;
    cColumns++ ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_INTERVAL2_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_INTERVAL2_CTYPE ;    
    LONG iInterval2Index = cColumns;
    cColumns++ ;

    MQDBCOLUMNSEARCH ColSearch[2] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = S_ID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = S_ID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    //
    // Create "stub" site in NT5 DS, for compatibility of guids.
    //
    HRESULT hr= CreateSite(
                    pSiteGuid,
                    (LPWSTR) pColumns[ iSiteNameIndex ].nColumnValue,
                    FALSE,    // fForeign   
                    (USHORT) pColumns[ iInterval1Index ].nColumnValue,
                    (USHORT) pColumns[ iInterval2Index ].nColumnValue
                    ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    LogMigrationEvent( MigLog_Info, MQMig_I_SITE_MIGRATED,
                                        iIndex,
                                  pColumns[ iSiteNameIndex ].nColumnValue,
                                  pColumns[ iPSCNameIndex ].nColumnValue ) ;

    MQDBFreeBuf((void*) pColumns[ iPSCNameIndex ].nColumnValue ) ;    
    MQDBFreeBuf((void*) pColumns[ iSiteNameIndex ].nColumnValue ) ;

    return S_OK ;
}

//-----------------------------------------
//
//  HRESULT MigrateSites(UINT cSites)
//
//-----------------------------------------

HRESULT MigrateSites( IN UINT  cSites,
                      IN GUID  *pSiteGuid )
{
    if (cSites == 0)
    {
        return MQMig_E_NO_SITES_AVAILABLE ;
    }

    //
    // Prepare a list of guids of all sites.
    //

    LONG cAlloc = 1 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_ID_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_ID_CTYPE ;
    UINT iGuidIndex = cColumns ;
    cColumns++ ;

    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    while(SUCCEEDED(status))
    {
        if (iIndex >= cSites)
        {
            status = MQMig_E_TOO_MANY_SITES ;
            break ;
        }

        memcpy(&pSiteGuid[ iIndex ],
                (void*) pColumns[ iGuidIndex ].nColumnValue,
                sizeof(GUID) ) ;

        for ( LONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    HRESULT hr = MQMig_E_UNKNOWN ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_SITES_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != cSites)
    {
        //
        // Mismatch in number of sites.
        //
        hr = MQMig_E_FEWER_SITES ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, cSites) ;
        return hr ;
    }

    BOOL fFound = FALSE ;
    
    //
    // This is the first time migration tool is run on this NT5
    // enterprise. Migrating the entire MQIS database into NT5 DS.
    // First migrate the PEC site, then all the other.
    //
    for ( UINT j = 0 ; j < cSites ; j++ )
    {
        if (memcmp(&pSiteGuid[j], &g_MySiteGuid, sizeof(GUID)) == 0)
        {
            if (j != 0)
            {
                pSiteGuid[j] = pSiteGuid[0] ;
                pSiteGuid[0] = g_MySiteGuid ;
            }
            fFound = TRUE ;
            break ;
        }
    }
    if (!fFound)
    {
        hr = MQMig_E_PECSITE_NOT_FOUND ;
        LogMigrationEvent(MigLog_Error, hr) ;
        return hr ;
    }
    
    hr = _InsertSiteInNT5DS( &pSiteGuid[ 0 ], 0, TRUE );

    CHECK_HR(hr) ;
    g_iSiteCounter++;

    //
    // Now migrate all other sites.
    //
    for ( j = 1 ; j < cSites ; j++ )
    {        
        hr = _InsertSiteInNT5DS( &pSiteGuid[ j ], j);                                     

        CHECK_HR(hr) ;
        g_iSiteCounter++;
    }    

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\resource.h ===
#include "..\..\mqutil\res\migtools\mqmigres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\stdafx.cpp ===
//
// file: migrat.cpp
//

#include "migrat.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\mqmigui.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name: mqmigui.h

Abstract:
1. Definition of functions in mqmigrat.dll  that are used by the UI tool.
2. Definition of callback functions in the migration tool that are called
   from mqmigrat.dll.

Author:

    Doron Juster  (DoronJ)   25-Oct-98

--*/

//+---------------------------------------------------------
//
//  Functions in mqmig.exe, called from mqmigrat.dll
//
//+---------------------------------------------------------

UINT  MQMigUI_DisplayMessageBox(
         ULONG ulTextId,
         UINT  ulMsgBoxType = (MB_YESNO | MB_ICONWARNING | MB_TASKMODAL) ) ;

typedef UINT  (*MQMigUI_DisplayMessageBox_ROUTINE) (
         ULONG ulTextId,
         UINT  ulMsgBoxType = (MB_YESNO | MB_ICONWARNING | MB_TASKMODAL) ) ;

//+---------------------------------------------------------
//
//  Functions in mqmigrat.dll, called from mqmig.exe
//
//+---------------------------------------------------------

HRESULT  MQMig_MigrateFromMQIS( LPTSTR  szMQISName,
                                LPTSTR  szDcName,
                                BOOL    fReadOnly,
                                BOOL    fAlreadyExist,
                                BOOL    fRecoveryMode,
                                BOOL	fClusterMode,
                                BOOL    fWebMode,
                                LPTSTR  szLogFile,
                                ULONG   ulTraceFlags,
                                BOOL    *pfIsPEC,
                                BOOL    *pfIsOneServer) ;

typedef HRESULT (*MQMig_MigrateFromMQIS_ROUTINE) (
                             LPWSTR szMQISName,
                             LPWSTR  szDcName,
                             BOOL    fReadOnly,
                             BOOL    fAlreadyExist,
                             BOOL    fRecoveryMode,
                             BOOL    fClusterMode,
                             BOOL    fWebMode,
                             LPWSTR  szLogFile,
                             ULONG   ulTraceFlags,
                             BOOL    *pfIsPEC,
                             BOOL    *pfIsOneServer ) ;

HRESULT  MQMig_CheckMSMQVersionOfServers( IN  LPTSTR  szMQISName,
                                          IN  BOOL    fIsClusterMode,
                                          OUT UINT   *piCount,
                                          OUT LPTSTR *ppszServers ) ;

typedef HRESULT (*MQMig_CheckMSMQVersionOfServers_ROUTINE) (
                                                LPWSTR szMQISName,
                                                BOOL   fIsClusterMode,
                                                UINT   *piCount,
                                                LPWSTR *ppszServers) ;

HRESULT  MQMig_GetObjectsCount( IN  LPTSTR  szMQISName,
                                OUT UINT   *piSiteCount,
                                OUT UINT   *piMachineCount,
                                OUT UINT   *piQueueCount,
                                OUT UINT   *piUserCount	) ;

typedef HRESULT (*MQMig_GetObjectsCount_ROUTINE) (
                                LPWSTR  szMQISName,
                                UINT   *piSiteCount,
                                UINT   *piMachineCount,
                                UINT   *piQueueCount,
                                UINT   *piUserCount) ;

HRESULT  MQMig_GetAllCounters( OUT UINT   *piSiteCounter,
                               OUT UINT   *piMachineCounter,
                               OUT UINT   *piQueueCounter,
                               OUT UINT   *piUserCounter) ;

typedef HRESULT  (*MQMig_GetAllCounters_ROUTINE) (
                               OUT UINT   *piSiteCounter,
                               OUT UINT   *piMachineCounter,
                               OUT UINT   *piQueueCounter,
                               OUT UINT   *piUserCounter) ;

HRESULT  MQMig_SetSiteIdOfPEC( IN  LPTSTR  szRemoteMQISName,
                               IN  BOOL	   fIsClusterMode,
                               IN  DWORD   dwInitError,
                               IN  DWORD   dwConnectDatabaseError,
                               IN  DWORD   dwGetSiteIdError,
                               IN  DWORD   dwSetRegistryError,
                               IN  DWORD   dwSetDSError);

typedef HRESULT (*MQMig_SetSiteIdOfPEC_ROUTINE) ( IN  LPWSTR  szRemoteMQISName,
                                                  IN  BOOL    fIsClusterMode,
												  IN  DWORD   dwInitError,
												  IN  DWORD   dwConnectDatabaseError,
												  IN  DWORD   dwGetSiteIdError,
												  IN  DWORD   dwSetRegistryError,
												  IN  DWORD   dwSetDSError);

HRESULT  MQMig_UpdateRemoteMQIS( 
                      IN  DWORD   dwGetRegistryError,
                      IN  DWORD   dwInitError,
                      IN  DWORD   dwUpdateMQISError, 
                      OUT LPTSTR  *ppszUpdatedServerName,
                      OUT LPTSTR  *ppszNonUpdatedServerName
                      );

typedef HRESULT (*MQMig_UpdateRemoteMQIS_ROUTINE) ( 
                          IN  DWORD   dwGetRegistryError,
                          IN  DWORD   dwInitError,
                          IN  DWORD   dwUpdateMQISError,
                          OUT LPWSTR  *ppszUpdatedServerName,
                          OUT LPWSTR  *ppszNonUpdatedServerName
                          );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\dss.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Dss.cpp

Abstract:
    Mqds service main

Author:
    Ilan Herbst (ilanh) 26-Jun-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "Dssp.h"
#include "Cm.h"
#include "mqutil.h"
#include "Svc.h"

#include "dss.tmh"

extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
{
	try
	{
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

		CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ");
		TrInitialize();
		SvcInitialize(L"MQDS");
	}
	catch(const exception&)
	{
		//
		// Cannot initialize the service, bail-out with an error.
		//
		return -1;
	}

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\migtool\mqmigrat\rpcclistub.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    rpcclistub.cpp

Abstract:
    Rpc client stub function

Author:
    Ilan Herbst (ilanh) 25-July-2000

Environment:
    Platform-independent,

--*/

#include "migrat.h"
#include "mqmacro.h"

#include "rpcclistub.tmh"

HRESULT 
GetRpcClientHandle(
	handle_t * /*phBind*/
	)
{
    ASSERT(("MQMIGRAT dont suppose to call GetRpcClientHandle", 0));
    return MQ_OK;
}

HRESULT 
QMRpcSendMsg(
    IN handle_t /*hBind*/,
    IN LPWSTR /*lpwszDestination*/,
    IN DWORD /*dwSize*/,
    IN const unsigned char * /*pBuffer*/,
    IN DWORD /*dwTimeout*/,
    IN unsigned char /*bAckMode*/,
    IN unsigned char /*bPriority*/,
    IN LPWSTR /*lpwszAdminResp*/
	)
{
    ASSERT(("MQMIGRAT dont suppose to call QMRpcSendMsg", 0));
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\dssp.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Dss.h

Abstract:
    Mqdssvc private functions.

Author:
    Ilan Herbst (ilanh) 26-Jun-2000

--*/

#ifndef _MQDSSVC_DSSP_H_
#define _MQDSSVC_DSSP_H_

#include "tr.h"
#include <mqexception.h>


const TraceIdEntry Mqdssvc = L"MQDS";

void MainDSInit(void);

BOOL IsLocalSystem(void);


#endif // _MQDSSVC_DSSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\dssinit.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    DssInit.cpp

Abstract:
    The functions in this file based on functions from qm\qmds.cpp
	they are taking care of dcpromo\dcunpromo
	and topology recognition.

Author:
    Ilan Herbst (ilanh) 11-July-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "topology.h"
#include <dsrole.h>
#include "safeboot.h"
#include "ds.h"
#include "mqsocket.h"
#include "mqprops.h"
#include "_mqdef.h"
#include "mqutil.h"
#include "ex.h"
#include "dssp.h"
#include "svc.h"
#include "cm.h"
#include "ad.h"

#include "dssinit.tmh"

AP<WCHAR> g_szMachineName = NULL;
AP<WCHAR> g_szComputerDnsName = NULL;

//
// Registry Keys
//
const LPCWSTR xMqdssvcRootKey = L"Parameters\\Mqdssvc";
const LPCWSTR xMachineCache = L"Parameters\\MachineCache";
const LPCWSTR xParameters = L"Parameters";

//
// MachineCache values
//
const LPCWSTR xMQS_DsServer = L"MQS_DsServer";
const LPCWSTR xMQS = L"MQS";

//
// Parameters values
//
const LPCWSTR xWorkGroup = L"Workgroup";
const LPCWSTR xAllowNT4 = L"AllowNt4Users";
const LPCWSTR xDisableWeakenSecurity = L"DisableWeakenSecurity";

//
// Mqdssvc values
//
const LPCWSTR xDummyException = L"DummyException";
const LPCWSTR xStopBeforeInit = L"StopBeforeInit";


static
void
AllowNT4users(
	void
	)
/*++

Routine Description:
	Check if need to call DSRelaxSecurity.
	This call should be done once (after setup update the registry key).
	If the registry exist and its value is TRUE we delete this registry.	

Arguments:
	None.

Returned Value:
	None

--*/
{
	//
	//  ISSUE-2000/07/28-ilanh
	//	MSMQ_ALLOW_NT4_USERS_REGNAME was previously used name. keep it ?
    //
	DWORD AllowNT4 = 0;
	const RegEntry xAllowNT4Entry(xParameters, xAllowNT4);
	CmQueryValue(xAllowNT4Entry, &AllowNT4);

    if(!AllowNT4)
		return;

	//
	// This set the attribute mSMQNameStyle to TRUE in msmq services
	//
    HRESULT hr = DSRelaxSecurity(AllowNT4);
    if (FAILED(hr))
    {
		TrERROR(Mqdssvc, "DSRelaxSecurity failed hr = 0x%x", hr);
		throw bad_hresult(hr);
    }

	TrTRACE(Mqdssvc, "DSRelaxSecurity completed");

	//
	// This operation should be done once after setup update that value.
    //
	CmDeleteValue(xAllowNT4Entry);
}


static
void
DisableWeakenSecurity(
	void
	)
/*++

Routine Description:
	Check if need to call DSRelaxSecurity. in order to DisableWeakenSecurity
	This call should be done once (after the user create this reg key).
	If the registry exist and its value is TRUE we delete this registry.	

Arguments:
	None.

Returned Value:
	None

--*/
{
	DWORD DisableWeakenSecurity = 0;
	const RegEntry xDisableWeakenSecurityEntry(xParameters, xDisableWeakenSecurity);
	CmQueryValue(xDisableWeakenSecurityEntry, &DisableWeakenSecurity);

    if(!DisableWeakenSecurity)
		return;

	//
	// This set the attribute mSMQNameStyle to FALSE in msmq services
	//
    HRESULT hr = DSRelaxSecurity(0);
    if (FAILED(hr))
    {
		TrERROR(Mqdssvc, "DisableWeakenSecurity, DSRelaxSecurity failed hr = 0x%x", hr);
		throw bad_hresult(hr);
    }

	TrTRACE(Mqdssvc, "DSRelaxSecurity(0) completed");

	//
	// This operation should be done once after the user create this reg value
    //
	CmDeleteValue(xDisableWeakenSecurityEntry);
}


static
bool 
IsThisServerDomainController(
	void
	)
/*++

Routine Description:
	Check if we are a domain controller.
	the check is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	TRUE for Domain Controller, FALSE otherwise

--*/
{
    static bool  s_fIsDc = false;
    static bool  s_fAlreadyAsked = false;

    if (s_fAlreadyAsked)
    {
        return s_fIsDc;
    }

    BYTE *pBuf = NULL;

    DWORD dwRole = DsRoleGetPrimaryDomainInformation(
						NULL,
						DsRolePrimaryDomainInfoBasic,
						&pBuf 
						);

    if (dwRole == ERROR_SUCCESS)
    {
        s_fAlreadyAsked = true;

        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pRole =
                           (DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pBuf;

        s_fIsDc = !!(pRole->Flags & DSROLE_PRIMARY_DS_RUNNING);

        DsRoleFreeMemory(pRole);
    }

	TrTRACE(Mqdssvc, "Domain Controller status = %d", s_fIsDc);

    return s_fIsDc;
}


static
bool
IsSafeMode(
	void
    )
/*++

Routine Description:
    Determines if the server is booted in safe mode or not where
    safe mode == directory service repair.

    based on nt\private\ds\src\util\ntdsutil\util.cxx

Parameters:
    None.

Return Values:

    TRUE if in safe mode, FALSE otherwise.

--*/
{
    static bool  s_fIsSafeMode = false;
    static bool  s_fAlreadyAsked = false;

    if (s_fAlreadyAsked)
    {
        return s_fIsSafeMode;
    }

    DWORD   cbData;
    WCHAR   data[100];
    WCHAR  * key = L"%SAFEBOOT_OPTION%";

    cbData = ExpandEnvironmentStrings(key, data, TABLE_SIZE(data));

    if ( cbData
         && (cbData <= sizeof(data))
         && !_wcsicmp(data, SAFEBOOT_DSREPAIR_STR_W) )
    {
        s_fIsSafeMode = true;
    }

    s_fAlreadyAsked = true;

	TrTRACE(Mqdssvc, "SafeMode status = %d", s_fIsSafeMode);
    
	return(s_fIsSafeMode);
}


bool
IsDsServer(
	void
	)
/*++

Routine Description:
	Retrieve Machine service type from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	TRUE for DsServer, FALSE otherwise

--*/
{
	static bool s_fDsServerInitialize = false;
	static bool s_fIsDsServer = false;

    if (s_fDsServerInitialize)
		return s_fIsDsServer;

	DWORD dwDef = 0xfffe;
	DWORD dwMQSDsServer;
	const RegEntry xMQS_DsServerEntry(xMachineCache, xMQS_DsServer, dwDef);
	CmQueryValue(xMQS_DsServerEntry, &dwMQSDsServer);

	if (dwMQSDsServer == dwDef)
	{
		TrERROR(Mqdssvc, "Failed to get MSMQ_MQS_DSSERVER from registry");

		return s_fIsDsServer;
	}

	s_fIsDsServer = (dwMQSDsServer != 0);
	s_fDsServerInitialize = true;

	TrTRACE(Mqdssvc, "DS Server registry status = %d", s_fIsDsServer);

	return s_fIsDsServer;
}


bool
IsWorkGroupMode(
	void
	)
/*++

Routine Description:
	Retrieve WorkGroupMode from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	TRUE for WorkGroupMode, FALSE otherwise

--*/
{
	static bool s_fWorkGroupModeInitialize = false;
	static bool s_fWorkGroupMode = false;

    if (s_fWorkGroupModeInitialize)
		return s_fWorkGroupMode;

	DWORD dwWorkGroupMode;
	const RegEntry xWorkGroupEntry(xParameters, xWorkGroup);
	CmQueryValue(xWorkGroupEntry, &dwWorkGroupMode);

	s_fWorkGroupMode = (dwWorkGroupMode != 0);
	s_fWorkGroupModeInitialize = true;

	TrTRACE(Mqdssvc, "WorkGroupMode registry status = %d", s_fWorkGroupMode);

	return s_fWorkGroupMode;
}


static
void  
UpdateDSFunctionalityDCUnpromo(
	void
	)
/*++

Routine Description:
	There are 2 possible ways to get here:
    1) DC unpromo was performed	on w2k (and not SafeMode).
    2) BSC/PSC/PEC upgrade, when dcpromo was not perform.
	   the DSServer registry is on. the registry is written in the upgrade 
	   according to MSMQ_MQS_REGNAME value.

	after dcunpromo. That's exactly like the case of upgrade
    from nt4 and boot before dcpromo. So reuse same code.

	we update the active directory, reseting our ds flag in the
    msmqConfiguration object and msmqSetting object. and resetting
	the ds settings in the registry.

Arguments:
	None.

Returned Value:
	None

--*/
{
	ASSERT(!IsThisServerDomainController());

	//
	// First update in DS.
	// We are not DS Server can not use DS api
	// need to use for this case only the AD api.
	//
	PROPID prop[1] = {PROPID_QM_SERVICE_DSSERVER};
	MQPROPVARIANT var[1];
	var[0].vt = VT_UI1;
	var[0].bVal = false;

	HRESULT hr = ADSetObjectPropertiesGuid(
					eMACHINE,
					NULL,  // pwcsDomainController
					false, // fServerName
					GetQMGuid(),
					1,
					prop,
					var
					);
	//
    // make sure we use only one property here. There is special
    // code in mqads (wrterq.cpp) to support this special setting,
    // so always use this property alone, and do not add it to
    // others.
    //
    ASSERT((sizeof(prop) / sizeof(prop[0])) == 1);

	//
	// ISSUE-2000/08/03-ilanh 
	// currently we will surely fail, since we don't have permissions to
	// set the bit in MSMQ Settings in the AD. (only service on DC has the permission).
	// in the past we used mqdssrv on the DC did the job, now we try to go directly to the AD
	// and don't have enough permissions.
	// The correct solution is to give permissions to the machine account. 
	//
	// ISSUE-2000/08/03-ilanh 
	// Need to look carefully on all upgrade senarios from NT4 clients.
    // And see all limitations we have.
    // a NT4 BSC will return MQ_ERROR or ACCESS_DENIED when calling
    // ADSetObjectPropertiesGuid. In that case, look for the ex-PEC. For all
    // other failures, just return. (the code that handle this was in
	// qm\qmds.cpp\UpdateQMSettingInformation().
	// we need to decide if we want that code (there are bizare situations when we need
	// to load mqdscli in AD enviroment ....)
	//
	// The reason we get MQ_ERROR if working in MQIS enviroment is because we try to reset 
	// PROPID_QM_SERVICE_DSSERVER property which does not exist.
	// We get MQ_ERROR_ACCESS_DENIED because we are not a service that runs on DC
	// so we don't have permissions to do 
    //

	if (FAILED(hr))
    {
		//
		// ISSUE-2000/08/03-ilanh need to check for no ds
		//
		TrERROR(Mqdssvc, "Failed to update server functionality (dcunprom) in DS, hr = 0x%x", hr);
		REPORT_CATEGORY(MQDS_DCUNPROMO_UPDATE_FAIL, CATEGORY_MQDS);
		return;
	}

	TrTRACE(Mqdssvc, "DCUnpromo clear PROPID_QM_SERVICE_DSSERVER in AD");

    //
    // change MQS_DsServer value to 0: this server is not DS server
    //
    DWORD  dwType = REG_DWORD;
    DWORD  dwValue = false;
    DWORD  dwSize = sizeof(dwValue);
    DWORD dwErr = SetFalconKeyValue( 
						MSMQ_MQS_DSSERVER_REGNAME,
						&dwType,
						&dwValue,
						&dwSize
						);

	//
	// Not fatal, the service is not register at the DS as DS server.
	// if we failed to update MQS_DSSERVER registry. 
	// next time we boot, it will trigger again DsFunctionalityChange and we repeat those operations again.
	//
    if (dwErr != ERROR_SUCCESS)
    {
		TrWARNING(Mqdssvc, "DCUnpromo: Could not set MQS_DsServer in registry. Error: %lut", dwErr);
    }
	else
	{
		TrTRACE(Mqdssvc, "DCUnpromo clear MSMQ_MQS_DSSERVER_REGNAME");
	}

    dwErr = DeleteFalconKeyValue(MSMQ_DS_SERVER_REGNAME);
    if (dwErr != ERROR_SUCCESS)
    {
		TrWARNING(Mqdssvc, "DCUnpromo: Could not delete MSMQ_DS_SERVER_REGNAME registry value. Error: %lut", dwErr);
    }		
	else
	{
		TrTRACE(Mqdssvc, "DCUnpromo clear MSMQ_DS_SERVER_REGNAME");
	}

    dwErr = DeleteFalconKeyValue(MSMQ_DS_CURRENT_SERVER_REGNAME);
    if (dwErr != ERROR_SUCCESS)
    {
		TrWARNING(Mqdssvc, "DCUnpromo: Could not delete MSMQ_DS_CURRENT_SERVER_REGNAME registry value. Error: %lut", dwErr);
    }		
	else
	{
		TrTRACE(Mqdssvc, "DCUnpromo clear MSMQ_DS_CURRENT_SERVER_REGNAME");
	}
}


static
void  
UpdateDSFunctionalityDCPromo(
	void
	)
/*++

Routine Description:
	Perform updates regarding DS Server dcpromo.
	Write to DS that we are DS Server, update registry values
	If failed the function throw bad_hresult()

Arguments:
	None.

Returned Value:
	None

--*/
{
	PROPID prop[1] = {PROPID_QM_SERVICE_DSSERVER};
    MQPROPVARIANT var[1];
    var[0].vt = VT_UI1;
    var[0].bVal = true;

    HRESULT hr = DSSetObjectPropertiesGuid( 
					MQDS_MACHINE,
					GetQMGuid(),
					1,
					prop,
					var
					);
	//
    // make sure we use only one property here. There is special
    // code in mqads (wrterq.cpp) to support this special setting,
    // so always use this property alone, and do not add it to
    // others.
    //
    ASSERT((sizeof(prop) / sizeof(prop[0])) == 1);

    if (FAILED(hr))
    {
		TrERROR(Mqdssvc, "Failed to update server functionality (dcpromo) in DS, hr = 0x%x", hr);
        REPORT_CATEGORY(MQDS_DCPROMO_UPDATE_FAIL, CATEGORY_MQDS);
		throw bad_hresult(hr);
	}

	TrTRACE(Mqdssvc, "DCPromo set PROPID_QM_SERVICE_DSSERVER in AD");

    //
    // Change list of DS Servers in registry to include
    // only our own name. We're a DS, aren't we ?
    //
    LPWSTR lpszMyMachineName = g_szMachineName;
    
	if (g_szComputerDnsName)
    {
        lpszMyMachineName = g_szComputerDnsName;
    }

    P<WCHAR> wszList = new WCHAR[wcslen(lpszMyMachineName) + 5];
    wcscpy(wszList, L"10");
    wcscat(wszList, lpszMyMachineName);

    DWORD dwSize = (wcslen(wszList) + 1) * sizeof(WCHAR);
    DWORD dwType = REG_SZ;

    LONG rc = SetFalconKeyValue( 
					MSMQ_DS_SERVER_REGNAME,
					&dwType,
					 wszList,
					&dwSize
					);

	TrTRACE(Mqdssvc, "DCPromo Set MSMQ_DS_SERVER_REGNAME = %ls", wszList);

    rc = SetFalconKeyValue( 
			MSMQ_DS_CURRENT_SERVER_REGNAME,
			&dwType,
			wszList,
			&dwSize
			);

	TrTRACE(Mqdssvc, "DCPromo Set MSMQ_DS_CURRENT_SERVER_REGNAME = %ls", wszList);

    //
    //  Update the registry with new service functionality ( only
    //  if succeeded to update ds ). Make this update after all
    //  the above were done, in order to "implementation" a
    //  transaction semantic on this change of functinoality.
    //  If we crash somewhere before this point, then after boot
    //  the DS flag in registry is still 0 and we'll perform this
    //  code again.
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    DWORD  dwVal = true;

    rc = SetFalconKeyValue( 
			MSMQ_MQS_DSSERVER_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);

	//
	// Not fatal, the service is register at the DS as DS server.
	// if we failed to update MQS_DSSERVER registry. 
	// next time we boot, it will trigger again DsFunctionalityChange and we repeat those operations again.
	//
    if (rc != ERROR_SUCCESS)
    {
		TrWARNING(Mqdssvc, "Failed to set MSMQ_MQS_DSSERVER_REGNAME hr = 0x%x", rc);
    }
	else
	{
		TrTRACE(Mqdssvc, "DCPromo set MSMQ_MQS_DSSERVER_REGNAME");
	}
}



const 
GUID*
GetQMGuid(
	void
	)
/*++

Routine Description:
	Retrieve QM Guid from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	pointer to QM GUID, or pointer to GUID_NULL if failed.

--*/
{
	static bool s_fQmGuidInitialize = false;
	static GUID s_QmGuid = GUID_NULL;

    if (s_fQmGuidInitialize)
		return &s_QmGuid;

    DWORD dwValueType = REG_BINARY;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue(
					MSMQ_QMID_REGNAME,
					&dwValueType,
					&s_QmGuid,
					&dwValueSize
					);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(Mqdssvc, "Failed to get QMID from registry");

        ASSERT(("BUGBUG: Failed to read QM GUID from registry!", 0));
        return &s_QmGuid;
    }

	s_fQmGuidInitialize = true;

    ASSERT((dwValueType == REG_BINARY) && (dwValueSize == sizeof(GUID)));

    return &s_QmGuid;
}


static
void 
ServerTopologyRecognitionInit( 
	void
	)
/*++

Routine Description:
    Initialize the Topology recognition Server
	and create the thread to listen to client topology recognition requests.
	If failed the function throw bad_hresult()

Arguments:
	None.

Returned Value:
	None

--*/
{
	//
	// This must be first initialization
	//
	ASSERT(g_pServerTopologyRecognition == NULL);

    g_pServerTopologyRecognition = new CServerTopologyRecognition();

    //
    // Check status of IP.
    //
    HRESULT hr = g_pServerTopologyRecognition->Learn();
    if (FAILED(hr))
    {
		TrERROR(Mqdssvc, "ServerTopologyRecognition->Learn failed, hr = 0x%x", hr);
		throw bad_hresult(hr);
    }
    
    //
    // After Learn we are always resolved.
    //

	TrTRACE(Mqdssvc, "ServerTopologyRecognitionInit: Successfully Server address resolution");

    //
    // Server starts listening to broadcasts from client.
    // At this phase it can return correct responses even if it
    // didn't yet update the DS.
    //
    DWORD dwThreadId;
    HANDLE hThread = CreateThread( 
						NULL,
						0,
						ServerRecognitionThread,
						g_pServerTopologyRecognition,
						0,
						&dwThreadId
						);

    if (hThread == NULL)
    {
		TrERROR(Mqdssvc, "ServerRecognitionThread failed");
		throw bad_hresult(MQ_ERROR_INSUFFICIENT_RESOURCES);
	}
    else
    {
		TrTRACE(Mqdssvc, "ServerRecognitionThread created successfully");
        CloseHandle(hThread);
    }
}


void 
InitComputerNameAndDns(
	void
	)
/*++

Routine Description:
    Initialize g_szMachineName and g_szComputerDnsName
	If failed the function throw bad_hresult()

Arguments:
    None.

Returned Value:
    None.

--*/
{
	//
    // Retrieve name of the machine (Always UNICODE)
    //
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    g_szMachineName = new WCHAR[dwSize];

    HRESULT hr = GetComputerNameInternal(g_szMachineName, &dwSize);
    if(FAILED(hr))
    {
		TrERROR(Mqdssvc, "Failed to get machine name hr = 0x%x", hr);
		throw bad_hresult(hr);
    }

	TrTRACE(Mqdssvc, "ComputerName = %ls", g_szMachineName);

	//
	// Retrieve the DNS name of this computer (in unicode).
	// Clustered QM does not have DNS name.
	//

	//
	// Get ComputerDns Size, ignore the returned error
	// 
	dwSize = 0;
	GetComputerDnsNameInternal(NULL, &dwSize);

	g_szComputerDnsName = new WCHAR[dwSize];

	hr = GetComputerDnsNameInternal(g_szComputerDnsName, &dwSize);
	if(FAILED(hr))
	{
		//
		//	this can be a valid situation, where a computer doesn't
		//	have DNS name.
		//	ISSUE-2000/08/03-ilanh - is this really valid situation.
		//
		TrWARNING(Mqdssvc, "Cannot retrieve computer DNS name hr = 0x%x", hr);
		g_szComputerDnsName.free();
	}

	TrTRACE(Mqdssvc, "ComputerDnsName = %ls", g_szComputerDnsName);
}


void 
CheckExit( 
	void
	)
/*++

Routine Description:
    Check Exit conditions from mqdssvc service.
	the possible situations the service should exit are:
		workgroup mode
		SafeMode
		the service is running as LocalUser

	If failed the function throw bad_hresult()

Arguments:
    None.

Returned Value:
	None.    

--*/
{
	//
	// Check exit condition - workgroup or SafeMode
	//
	// ISSUE-2000/07/25-ilanh is this the correct way to handle workgroup mode
	// we need new event for this one
	//
	if(IsWorkGroupMode())
	{
		TrERROR(Mqdssvc, "MainDsInit, mqdssvc can not run in workgroup mode");
        REPORT_CATEGORY(EVENT_WARN_MQDS_NOT_DC, CATEGORY_MQDS);

		//
		// This situation can not be workgroup mode and we are DC!!
		//
		ASSERT(!IsThisServerDomainController());
		throw bad_hresult(EVENT_WARN_MQDS_NOT_DC);
	}

	if (IsSafeMode())
    {
		//
        //  In DS safe mode we don't want to change any thing in the DS
        //  so exit here
		//
		TrERROR(Mqdssvc, "MainDsInit, we are in safe mode");
		throw bad_hresult(MQ_ERROR_UNSUPPORTED_OPERATION);
    }

	if(!IsLocalSystem())
	{
		TrERROR(Mqdssvc, "DS Service not run as local system");
        REPORT_CATEGORY(MQDS_NOT_RUN_AS_LOCAL_SYSTEM, CATEGORY_MQDS);
	}

#ifdef _DEBUG
	//
	// Dummy Exception
	//
	DWORD fDummyException = 0;
	const RegEntry xDummyExceptionEntry(xMqdssvcRootKey, xDummyException);
	CmQueryValue(xDummyExceptionEntry, &fDummyException);
	if(fDummyException)
	{
		TrERROR(Mqdssvc, "Dummy execption to check exit");
		throw bad_hresult(MQ_ERROR_NO_DS);
	}
#endif
}


void 
MainDSInit( 
	void
	)
/*++

Routine Description:
    Main ds Initialize routine.
	this routine check for changed in ds functionality.
	if ds changed was detected and we are not in safe mode
	perform the update.
	start the Thread to listen to clients topology recognition requests.
	If failed the function throw bad_hresult()

Arguments:
    None.

Returned Value:
	TRUE if initialization ok, FALSE otherwise.    

--*/
{

#ifdef _DEBUG
	DWORD fStopBeforeInit = 0;
	const RegEntry xStopBeforeInitEntry(xMqdssvcRootKey, xStopBeforeInit);
	CmQueryValue(xStopBeforeInitEntry, &fStopBeforeInit);
	if(fStopBeforeInit)
	{
		//
		// to debug init report SERVICE_RUNNING and cause ASSERT
		//
		SvcReportState(SERVICE_RUNNING);
		ASSERT(("Assert before start of mqdssvc init", 0));
	}
#endif

	//
	// Check workgroup, SafeMode, running as LocalSystem
	//
	CheckExit(); 

    //
    // Max time for next progress report
    //
    const DWORD xTimeToNextReport = 3000;

	SvcReportProgress(xTimeToNextReport);

	//
	// initialize g_szMachineName, g_szComputerDnsName
	//
    InitComputerNameAndDns();
	
    //
    //  Check if the server have changed the "DS functionality"
    //  ( i.e. was DCpromo or DCunpromo performed)
    //
    bool fIsDC = IsThisServerDomainController();

	//
	// No need to be cluster aware.
	// The Ds service can run only on the default QM machine according to shaik
	//

	if(fIsDC)
	{
		SvcReportProgress(xTimeToNextReport);

		//
		// ISSUE-2000/07/27-ilanh we should depend on kds service here at runtime
		// KDC_STARTED_EVENT - BUG 4349
		// This dependency must be done after handling dcpromo/dcunpromo
		// and before making any DS operation.
		//

		//
		// Init Ds, RPC
		//
		HRESULT hr = DSInit(
						NULL,  /* pfnLookDS */
						NULL,  /* pGetServers */
						FALSE, /* fReserved */
						FALSE, /* fSetupMode */
						FALSE, /* fQMDll */
						NULL,  /* pNoServerAuth */
						NULL   /* szServerName */
						);

		if(FAILED(hr))
		{
			TrERROR(Mqdssvc, "MainDsInit, DsInit failed 0x%x", hr);
			throw bad_hresult(hr);
		}

		TrTRACE(Mqdssvc, "DSInit completed succesfully");

		SvcReportProgress(xTimeToNextReport);
	}

	if (fIsDC && !IsDsServer())
    {
        //
        // dcpromom was performed. We're now a domain controller.
		//
        UpdateDSFunctionalityDCPromo();
		TrTRACE(Mqdssvc, "MainDsInit: Server functionality has changed, now supports DS");
    }
    else if (!fIsDC && IsDsServer())
    {
        //
		//  There are 2 possible ways to get here:
        //  1) DC unpromo was performed	on w2k (and not SafeMode).
        //  2) BSC/PSC/PEC upgrade, when dcpromo was not perform.
		//	   the DSServer registry is on. the registry is written in the upgrade 
		//     according to MSMQ_MQS_REGNAME value.
        //
        // after dcunpromo. That's exactly like the case of upgrade
        // from nt4 and boot before dcpromo. So reuse same code.
        //
        UpdateDSFunctionalityDCUnpromo();
		TrTRACE(Mqdssvc, "MainDsInit: Server functionality has changed, now doesn't supports DS");
    }

	//
	// fIsDC == FALSE we should exit here!
	// The service runs only on DC
	//
	if(!fIsDC)
	{
		//
		// event not DS server
		//
		TrERROR(Mqdssvc, "MainDsInit, we are not DC");
		REPORT_CATEGORY(EVENT_WARN_MQDS_NOT_DC, CATEGORY_MQDS);
		throw bad_hresult(MQ_ERROR_NO_DS);
	}

	//
	// Check for registry value to allow NT4 users
	// Relax Security if we allow NT4 users
	//
	AllowNT4users();

	//
	// Check if the user want to disable the weaken security
	//
	DisableWeakenSecurity();

	ServerTopologyRecognitionInit(); 

	SvcReportProgress(xTimeToNextReport);

    REPORT_CATEGORY(MQDS_INITILIZATION_SUCCEEDED, CATEGORY_MQDS);
	TrTRACE(Mqdssvc, "MainDsInit completed successfully");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\dsssecutl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dsssecutl.cpp

Abstract:

    Various QM security related functions.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include "dsssecutl.h"
#include <mqsec.h>
#include <mqcrypt.h>
#include "mqutil.h"
#include <mqlog.h>
#include <dssp.h>
#include <tr.h>
#include <dsproto.h>

#include "dsssecutl.tmh"

static WCHAR *s_FN=L"dsssecutl";



static 
VOID 
GetLocalSystemSid(
	OUT PSID* ppLocalSystemSid
	)
/*++

Routine Description:
    Get LocalSystem Sid.
	If failed the function throw bad_win32_error()

Arguments:
    ppLocalSystemSid - pointer to PSID.

Returned Value:
	None.    

--*/
{
    //
    // Get LocalSystem Sid
    //
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
    BOOL fSuccess = AllocateAndInitializeSid( 
						&NtAuth,
						1,
						SECURITY_LOCAL_SYSTEM_RID,
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						ppLocalSystemSid
						);

	if(!fSuccess)
    {
        DWORD gle = GetLastError();
		TrERROR(Mqdssvc, "AllocateAndInitializeSid for local system failed, error = 0x%x", gle);
		throw bad_win32_error(gle);
    }
}


static
VOID 
GetTokenSid( 
	IN  HANDLE hToken,
	OUT PSID*  ppSid
	)
/*++

Routine Description:
    Get Sid from Token Handle.
	The function allocate the *ppSid which need to be free by the calling function.
	If failed the function throw bad_win32_error()

Arguments:
	hToken - handle to Token.
    ppSid - pointer to PSID.

Returned Value:
	None.    

--*/
{

	//
	// Get TokenInformation Length
	//
    DWORD dwTokenLen = 0;
    GetTokenInformation(
		hToken, 
		TokenUser, 
		NULL, 
		0, 
		&dwTokenLen
		);

	//
	// It is ok to failed with this error because we only get the desired length
	//
	ASSERT(("failed in GetTokenInformation", GetLastError() == ERROR_INSUFFICIENT_BUFFER));

	//
	// bug in mqsec regarding P<char> insteadof AP<char>
	// mqsec\imprsont.cpp\_GetThreadUserSid()
	//
	AP<char> pTokenInfo = new char[dwTokenLen];

    BOOL fSuccess = GetTokenInformation( 
						hToken,
						TokenUser,
						pTokenInfo,
						dwTokenLen,
						&dwTokenLen 
						);

	if(!fSuccess)
	{
        DWORD gle = GetLastError();
		TrERROR(Mqdssvc, "GetTokenSid: GetTokenInformation failed, error = 0x%x", gle);
		throw bad_win32_error(gle);
    }

	//
	// Get the Sid from TokenInfo
	//
    PSID pOwner = ((TOKEN_USER*)(char*)pTokenInfo)->User.Sid;

	ASSERT(IsValidSid(pOwner));

    DWORD dwSidLen = GetLengthSid(pOwner);
    *ppSid = (PSID) new BYTE[dwSidLen];
    fSuccess = CopySid(dwSidLen, *ppSid, pOwner);
	if(!fSuccess)
	{
        DWORD gle = GetLastError();
 		TrERROR(Mqdssvc, "GetTokenSid: CopySid failed, error = 0x%x", gle);
		throw bad_win32_error(gle);
    }
}


static
VOID 
GetProcessSid( 
	OUT PSID* ppSid 
	)
/*++

Routine Description:
    Get process Sid.
	If failed the function throw bad_win32_error()

Arguments:
    ppSid - pointer to PSID.

Returned Value:
	None.    

--*/
{
	//
	// Get handle to process token
	//
	HANDLE hProcessToken = NULL;
    BOOL fSuccess = OpenProcessToken(
						GetCurrentProcess(),
						TOKEN_QUERY,
						&hProcessToken
						);
	if(!fSuccess)
	{
        DWORD gle = GetLastError();
		TrERROR(Mqdssvc, "GetTokenSid: GetTokenInformation failed, error = 0x%x", gle);
		throw bad_win32_error(gle);
	}
    
    ASSERT(hProcessToken);

	GetTokenSid( 
		hProcessToken,
		ppSid
		);
}


BOOL IsLocalSystem(void)
/*++

Routine Description:
    Check if the process is local system.

Arguments:
	None.    

Returned Value:
	TRUE for if the process is Local System, FALSE otherwise

--*/
{

	try
	{
		//
		// Get LocalSystem sid
		//
		CPSID pLocalSystemSid;
		GetLocalSystemSid(&pLocalSystemSid);

		//
		// can i use P<SID> seems mistake (that what mqsec is using)
		// see P<SID> in mqsec\imprsont.cpp
		//
		//
		// Get process sid
		//
		AP<BYTE> pProcessSid;
		GetProcessSid(reinterpret_cast<PSID*>(&pProcessSid));

		//
		// Compare
		//
		BOOL fLocalSystem = FALSE;
		if (pProcessSid && pLocalSystemSid)
		{
			fLocalSystem = EqualSid(pLocalSystemSid, pProcessSid);
		}
		return fLocalSystem;
	}
    catch (const bad_win32_error& exp)
    {
        TrERROR(Mqdssvc, "could not verify if process is local system = 0x%x", exp.error());
		return FALSE;
    }

}


/***************************************************************************

Function:
    SignProperties

Description:
    Sign the challenge and the properties.

***************************************************************************/

STATIC
HRESULT
SignProperties(
    HCRYPTPROV  hProv,
    BYTE        *pbChallenge,
    DWORD       dwChallengeSize,
    DWORD       cp,
    PROPID      *aPropId,
    PROPVARIANT *aPropVar,
    BYTE        *pbSignature,
    DWORD       *pdwSignatureSize
	)
{
    HRESULT hr;
    CHCryptHash hHash;

    //
    // Create a hash object and hash the challenge.
    //
    if (!CryptCreateHash(hProv, CALG_MD5, NULL, 0, &hHash) ||
        !CryptHashData(hHash, pbChallenge, dwChallengeSize, 0))
    {
        LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 260);
    }

    if (cp)
    {
        //
        // Hash the properties.
        //
        hr = HashProperties(hHash, cp, aPropId, aPropVar);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 270);
        }
    }

    //
    // Sign it all.
    //
    if (!CryptSignHashA(
            hHash,
            AT_SIGNATURE,
            NULL,
            0,
            pbSignature,
            pdwSignatureSize
			))
    {
        DWORD dwerr = GetLastError();
        if (dwerr == ERROR_MORE_DATA)
        {
            return LogHR(MQ_ERROR_USER_BUFFER_TOO_SMALL, s_FN, 280);
        }
        else
        {
            LogNTStatus(dwerr, s_FN, 290);
            return MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
    }

    return(MQ_OK);
}


/***************************************************************************

Function:
    SignQMSetProps

Description:
    This is the callback function that the DS calls to sign the challenge
    and the properties. This way we let the QM to set it's own machnie's
    properties.

***************************************************************************/

HRESULT
SignQMSetProps(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR dwContext,
    OUT    BYTE    *pbSignature,
    IN OUT DWORD   *pdwSignatureSize,
    IN     DWORD   dwSignatureMaxSize
	)
{

    struct DSQMSetMachinePropertiesStruct *s =
        (struct DSQMSetMachinePropertiesStruct *)dwContext;
    DWORD cp = s->cp;
    PROPID *aPropId = s->aProp;
    PROPVARIANT *aPropVar = s->apVar;

    *pdwSignatureSize = dwSignatureMaxSize;

    //
    // challenge is always signed with base provider.
    //
    HCRYPTPROV hProvQM = NULL;
    HRESULT hr = MQSec_AcquireCryptoProvider( 
					eBaseProvider,
					&hProvQM 
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 310);
    }

    ASSERT(hProvQM);
    hr = SignProperties(
            hProvQM,
            pbChallenge,
            dwChallengeSize,
            cp,
            aPropId,
            aPropVar,
            pbSignature,
            pdwSignatureSize
			);

    return LogHR(hr, s_FN, 320);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\dssutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dssutil.cpp

Abstract:

    mq ds service utilities

Author:

    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include "dssutil.h"
#include "topology.h"
#include "mqsocket.h"
#include <wsnwlink.h>
#include "mqprops.h"
#include "mqutil.h"
#include "ds.h"
#include "mqmacro.h"

#include "dssutil.tmh"

extern AP<WCHAR> g_szMachineName;


/*======================================================

Function:         GetDsServerList

Description:      This routine gets the list of ds
                  servers from the DS

========================================================*/

DWORD g_dwDefaultTimeToQueue = MSMQ_DEFAULT_LONG_LIVE;

DWORD 
GetDsServerList(
	OUT WCHAR *pwcsServerList,
	IN  DWORD dwLen
	)
{

#define MAX_NO_OF_PROPS 21

    //
    //  Get the names of all the servers that
    //  belong to the site
    //

    ASSERT (dwLen >= MAX_REG_DSSERVER_LEN);

    HRESULT       hr = MQ_OK;
    HANDLE        hQuery;
    DWORD         dwProps = MAX_NO_OF_PROPS;
    PROPVARIANT   result[MAX_NO_OF_PROPS];
    PROPVARIANT*  pvar;
    CRestriction  Restriction;
    GUID          guidSite;
    DWORD         index = 0;

    GUID          guidEnterprise;

   guidSite = g_pServerTopologyRecognition->GetSite();
   guidEnterprise = g_pServerTopologyRecognition->GetEnterprise();

    //
    // Get the default Time-To-Queue from MQIS
    //
    PROPID      aProp[1];
    PROPVARIANT aVar[1];

    aProp[0] = PROPID_E_LONG_LIVE;
    aVar[0].vt = VT_UI4;

    hr = DSGetObjectPropertiesGuid( 
				MQDS_ENTERPRISE,
				&guidEnterprise,
				1,
				aProp,
				aVar
				);

    if (FAILED(hr))
    {
       return 0;
    }

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;

    LONG rc = SetFalconKeyValue( 
					MSMQ_LONG_LIVE_REGNAME,
					&dwType,
					(PVOID) &aVar[0].ulVal,
					&dwSize 
					);

	DBG_USED(rc);
	ASSERT(("SetFalconKeyValue for MSMQ_LONG_LIVE_REGNAME failded", rc == ERROR_SUCCESS));

    g_dwDefaultTimeToQueue = aVar[0].ulVal;

    //
    // DS server only
    //
    Restriction.AddRestriction(
					SERVICE_SRV,                 // [adsrv] old request - DS will interpret
					PROPID_QM_SERVICE,
					PRGT,
					0
					);

    //
    // In  this machine's Site
    //
    Restriction.AddRestriction(
					&guidSite,
					PROPID_QM_SITE_ID,
					PREQ,
					1
					);

	//
	//	First assume NT5 DS server, and ask for the DNS names
	//	of the DS servers
	//
    CColumns      Colset;
    Colset.Add(PROPID_QM_PATHNAME_DNS);
	Colset.Add(PROPID_QM_PATHNAME);

    DWORD   lenw;

    // This search request will be recognized and specially simulated by DS
    hr = DSLookupBegin(
			0,
			Restriction.CastToStruct(),
			Colset.CastToStruct(),
			0,
			&hQuery
			);

	if(FAILED(hr))
	{
		//
		// Possibly the DS server is not NT5, try without PROPID_QM_PATHNAME_DNS
		//

		CColumns      ColsetNT4;
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		ColsetNT4.Add(PROPID_QM_PATHNAME);
		hr = DSLookupBegin(
				0,
				Restriction.CastToStruct(),
				ColsetNT4.CastToStruct(),
				0,
				&hQuery
				);
	}

    if(FAILED(hr))
        return 0;

    BOOL fAlwaysLast = FALSE;
    BOOL fForceFirst = FALSE;

    while(SUCCEEDED(hr = DSLookupNext(hQuery, &dwProps, result)))
    {
        //
        //  No more results to retrieve
        //
        if (!dwProps)
            break;

        pvar = result;

        for (DWORD i = 0; i < (dwProps/2); i++, pvar+=2)
        {
            //
            //  Add the server name to the list
            //  For load balancing, write sometimes at the
            //  beginning of the string, sometimes at the end. Like
            //  that we will have  BSCs and PSC in a random order
            //
            WCHAR * p;
			WCHAR * pwszVal;
			AP<WCHAR> pCleanup1;
			AP<WCHAR> pCleanup2 = (pvar+1)->pwszVal;

			if ( pvar->vt != VT_EMPTY)
			{
				//
				// there may be cases where server will not have DNS name
				// ( migration)
				//
				pwszVal = pvar->pwszVal;
				pCleanup1 = pwszVal;
			}
			else
			{
				pwszVal = (pvar+1)->pwszVal;
			}
            lenw = wcslen( pwszVal);

            if ( index + lenw + 4 <  MAX_REG_DSSERVER_LEN)
            {
               if (!_wcsicmp(g_szMachineName, pwszVal))
               {
                  //
                  // Our machine should be first on the list.
                  //
                  ASSERT(!fForceFirst) ;
                  fForceFirst = TRUE ;
               }
               if(index == 0)
               {
                  //
                  // Write the 1st string
                  //
                  p = &pwcsServerList[0];
                  if (fForceFirst)
                  {
                     //
                     // From now on write all server at the end
                     // of the list is our machine remain the
                     // first in the list.
                     //
                     fAlwaysLast = TRUE;
                  }
               }
               else if (fAlwaysLast ||
                         ((rand() > (RAND_MAX / 2)) && !fForceFirst))
               {
                  //
                  // Write at the end of the string
                  //
                  pwcsServerList[index] = DS_SERVER_SEPERATOR_SIGN;
                  index ++;
                  p = &pwcsServerList[index];
               }
               else
               {
                  if (fForceFirst)
                  {
                     //
                     // From now on write all server at the end
                     // of the list is our machine remain the
                     // first in the list.
                     //
                     fAlwaysLast = TRUE;
                  }

                  //
                  // Write at the beginning of the string
                  //
                  DWORD dwSize = lenw                   +
                                 2 /* protocol flags */ +
                                 1 /* Separator    */ ;
                  //
                  // Must use memmove because buffers overlap.
                  //
                  memmove( 
						&pwcsServerList[dwSize],
						&pwcsServerList[0],
						index * sizeof(WCHAR)
						);

                  pwcsServerList[dwSize - 1] = DS_SERVER_SEPERATOR_SIGN;
                  p = &pwcsServerList[0];
                  index++;
               }

               //
               // Mark only IP as supported protocol
               //
               *p++ = TEXT('1');
               *p++ = TEXT('0');

               memcpy(p, pwszVal, lenw * sizeof(WCHAR));
               index += lenw + 2;

            }
        }
    }
    pwcsServerList[ index] = '\0';
    //
    // close the query handle
    //
    hr = DSLookupEnd(hQuery);

    return((index) ? index+1 : 0);
}


/*====================================================

IsDSAddressExist

Arguments:

Return Value:


=====================================================*/
BOOLEAN 
IsDSAddressExist(
	const CAddressList* AddressList,
	TA_ADDRESS*     ptr,
	DWORD AddressLen
	)
{
    POSITION        pos, prevpos;
    TA_ADDRESS*     pAddr;

    if (AddressList)
    {
        pos = AddressList->GetHeadPosition();
        while(pos != NULL)
        {
            prevpos = pos;
            pAddr = AddressList->GetNext(pos);

            if (memcmp(&(ptr->Address), &(pAddr->Address), AddressLen) == 0)
            {
                //
                // Same IP address
                //
               return TRUE;
            }
        }
    }

    return FALSE;
}


/*====================================================

IsDSAddressExistRemove

Arguments:

Return Value:


=====================================================*/
BOOL 
IsDSAddressExistRemove( 
	IN const TA_ADDRESS*     ptr,
	IN DWORD AddressLen,
	IN OUT CAddressList* AddressList
	)
{
    POSITION        pos, prevpos;
    TA_ADDRESS*     pAddr;
    BOOLEAN         rc = FALSE;

    pos = AddressList->GetHeadPosition();
    while(pos != NULL)
    {
        prevpos = pos;
        pAddr = AddressList->GetNext(pos);

        if (memcmp(&(ptr->Address), &(pAddr->Address), AddressLen) == 0)
        {
            //
            // Same address
            //
           AddressList->RemoveAt(prevpos);
           delete pAddr;
           rc = TRUE;
        }
    }

    return rc;
}


/*====================================================

SetAsUnknownIPAddress

Arguments:

Return Value:

=====================================================*/

void SetAsUnknownIPAddress(IN OUT TA_ADDRESS * pAddr)
{
    pAddr->AddressType = IP_ADDRESS_TYPE;
    pAddr->AddressLength = IP_ADDRESS_LEN;
    memset(pAddr->Address, 0, IP_ADDRESS_LEN);
}


/*====================================================

GetIPAddresses

Arguments:

Return Value:


=====================================================*/
CAddressList* GetIPAddresses(void)
{
    CAddressList* plIPAddresses = new CAddressList;

    //
    // Check if TCP/IP is installed and enabled
    //
    char szHostName[MQSOCK_MAX_COMPUTERNAME_LENGTH];
    DWORD dwSize = sizeof( szHostName);

    //
    //  Just checking if socket is initialized
    //
    if (gethostname(szHostName, dwSize) != SOCKET_ERROR)
    {
        GetMachineIPAddresses(szHostName,plIPAddresses);
    }

    return plIPAddresses;
}


/*====================================================

Function: void GetMachineIPAddresses()

Arguments:

Return Value:

=====================================================*/

void 
GetMachineIPAddresses(
	IN const char * szHostName,
	OUT CAddressList* plIPAddresses
	)
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, 
		L"QM: GetMachineIPAddresses for %hs", 
		szHostName
		));
	
    TA_ADDRESS * pAddr;
    //
    // Obtain the IP information for the machine
    //
    PHOSTENT pHostEntry = gethostbyname(szHostName);

    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
	    DBGMSG((DBGMOD_ROUTING, DBGLVL_WARNING, 
			L"QM: gethostbyname found no IP addresses for %hs", 
			szHostName
			));
        return;
    }

    //
    // Add each IP address to the list of IP addresses
    //
    for (DWORD uAddressNum = 0;
         pHostEntry->h_addr_list[uAddressNum] != NULL;
         uAddressNum++)
    {
        //
        // Keep the TA_ADDRESS format of local IP address
        //
        pAddr = (TA_ADDRESS *)new char [IP_ADDRESS_LEN + TA_ADDRESS_SIZE];
        pAddr->AddressLength = IP_ADDRESS_LEN;
        pAddr->AddressType = IP_ADDRESS_TYPE;
        memcpy( &(pAddr->Address), pHostEntry->h_addr_list[uAddressNum], IP_ADDRESS_LEN);

	    DBGMSG((DBGMOD_ROUTING, DBGLVL_TRACE, 
    	      L"QM: gethostbyname found IP address %hs ",
        	  inet_ntoa(*(struct in_addr *)pHostEntry->h_addr_list[uAddressNum])));

        plIPAddresses->AddTail(pAddr);
    }
}


void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"QM Error: %s/%d, HR: 0x%x",
                     wszFileName,
                     usPoint,
                     hr)) ;
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"QM Error: %s/%d, NTStatus: 0x%x",
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"QM Error: %s/%d, Point",
                     wszFileName,
                     dwLine)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\dssutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dssutil.h

Abstract:

    Mq ds service utilities interface

Author:

    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef _MQDSSVC_DSSUTIL_
#define _MQDSSVC_DSSUTIL_

#include "_ta.h"

const 
GUID*
GetQMGuid(
	void
	);

extern DWORD GetDsServerList(OUT WCHAR *pwcsServerList,IN DWORD dwLen);

class CAddressList : public CList<TA_ADDRESS*, TA_ADDRESS*&> {/**/};

extern BOOLEAN IsDSAddressExist(const CAddressList* AddressList,
                                TA_ADDRESS*     ptr,
                                DWORD AddressLen);

extern BOOL IsDSAddressExistRemove(IN const TA_ADDRESS*     ptr,
                                   IN DWORD AddressLen,
                                   IN OUT CAddressList* AddressList);

extern void SetAsUnknownIPAddress(IN OUT TA_ADDRESS * ptr);

extern CAddressList* GetIPAddresses(void);

extern void GetMachineIPAddresses(IN const char * szHostName,
                                  OUT CAddressList* plIPAddresses);

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);
void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint);
void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine);

#endif //_MQDSSVC_DSSUTIL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\dsssecutl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    dsssecutl.h

    mq ds service security related stuff.

Author:

    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef _MQDSSVC_DSSSECUTL_H_
#define _MQDSSVC_DSSSECUTL_H_


//---------------------------------------------------------
//
//  class CPSID	- Auto class for PSID
//
//---------------------------------------------------------
class CPSID {
public:
    CPSID(PSID h = 0) : m_h(h)		{}
   ~CPSID()							{ if (m_h != 0) FreeSid(m_h); }

    PSID* operator &()				{ return &m_h; }
    operator PSID() const			{ return m_h; }
    PSID detach()					{ PSID h = m_h; m_h = 0; return h; }

private:
    CPSID(const CPSID&);
    CPSID& operator=(const CPSID&);

private:
	PSID m_h;
};


HRESULT
SignQMSetProps(
    IN     BYTE    *pbChallenge,
    IN     DWORD   dwChallengeSize,
    IN     DWORD_PTR dwContext,
    OUT    BYTE    *pbSignature,
    OUT    DWORD   *pdwSignatureSize,
    IN     DWORD   dwSignatureMaxSize
    );

#endif // _MQDSSVC_DSSSECUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\stdh.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file used for precompilation.

Author:

    Ilan Herbst  (ilanh)  26-Jun-2000

Environment:

    Platform-independent

Revision History:

--*/


#ifndef _MQDSSVC_STDH_H_
#define _MQDSSVC_STDH_H_

#include <_Stdh.h>

#include "mqtypes.h"

#endif // _MQDSSVC_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\service.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Service.cpp

Abstract:
    Service control entry points to the Mqdssvc

Author:
    Ilan Herbst (ilanh) 26-Jun-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "Dssp.h"
#include "Svc.h"
#include "ds.h"

#include "service.tmh"

static
VOID
ApppExit(
    VOID
    ) throw()
{
    SvcReportState(SERVICE_STOPPED);
	Sleep(1000);
    exit(-1);

} // ApppExit


VOID
AppRun(
	LPCWSTR /*ServiceName*/
	)
/*++

Routine Description:
    Stub implementation for application Run function. It should immidiatly
	report it state and enable the controls it accepts.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
	try
	{
		MainDSInit();
	}
    catch (const bad_win32_error& exp)
    {
        TrERROR(Mqdssvc, "Failed to initialize service, win32_api_error = 0x%x", exp.error());
        ApppExit();
    }
	catch (const bad_hresult& exp)
	{
		TrERROR(Mqdssvc, "Failed to initialize service, error = 0x%x", exp.error());
        ApppExit();
	}
    catch (const bad_alloc&)
    {
        TrERROR(Mqdssvc, "Failed to initialize service, insufficient resources");
        ApppExit();
    }
    catch (const exception& exp)
    {
        TrERROR(Mqdssvc, "Failed to initialize service, what = %s", exp.what());
        ASSERT(("Need to know the real reason for failure here!", 0));
        ApppExit();
    }

	SvcReportState(SERVICE_RUNNING);
    SvcEnableControls(
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_SHUTDOWN
		);

	Sleep(INFINITE);
}


VOID
AppStop(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Stop function. It should immidiatly
	report it state back, and take the procedure to stop the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_STOP_PENDING);
	DSTerminate();
	SvcReportState(SERVICE_STOPPED);
}


VOID
AppPause(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Pause function. MSDS service does
    not implement pause control.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(("MQDS Service unexpectedly got Pause control from SCM", 0));
}


VOID
AppContinue(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Continue function. MSDS service does
    not implement continue control.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(("MQDS Service unexpectedly got Continue control from SCM", 0));
}


VOID
AppShutdown(
	VOID
	)
{
	AppStop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topoldat.cpp ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

    topoldat.cpp

Abstract:

    Implementation of cached data class for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/


#include "stdh.h"
#include "dssutil.h"
#include "dsssecutl.h"
#include "topoldat.h"
#include "ds.h"
#include "mqprops.h"
#include "mqutil.h"
#include <mqlog.h>

#include "topoldat.tmh"

static WCHAR *s_FN=L"topoldat";

extern AP<WCHAR> g_szMachineName;
extern AP<WCHAR> g_szComputerDnsName;

bool CTopologyData::LoadFromRegistry()
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CTopologyData::LoadFromRegistry"));


    DWORD dwSize = sizeof(GUID);
    DWORD dwType = REG_BINARY;

    LONG rc = GetFalconKeyValue(
                    MSMQ_ENTERPRISEID_REGNAME,
                    &dwType,
                    &m_guidEnterprise,
                    &dwSize
                    );
    if (rc != ERROR_SUCCESS)
    {
        REPORT_WITH_STRINGS_AND_CATEGORY((
            CATEGORY_MQDS,
            REGISTRY_FAILURE,
            1,
            L"CTopologyData::Load() - EnterpriseId"
            ));
        LogIllegalPoint(s_FN, 10);
        return false;
    }

    ASSERT(dwSize == sizeof(GUID)) ;
    ASSERT(dwType == REG_BINARY) ;

    return true;
}


/*============================================================

HRESULT CServerTopologyData::Load()

Description:  Load last known topology of a server from MQIS database.

=============================================================*/

HRESULT CServerTopologyData::Load()
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, L"QM: CTopologyData::Load"));
    
    if(!LoadFromRegistry())
    {
       return LogHR(REGISTRY_FAILURE, s_FN, 150);
    }

    PROPID      propId[3];
    PROPVARIANT var[3];
    DWORD nProp = 3;

    propId[0] = PROPID_QM_ADDRESS;
    var[0].vt = VT_NULL;
    propId[1] = PROPID_QM_CNS;
    var[1].vt = VT_NULL;
    propId[2] = PROPID_QM_SITE_ID;
    var[2].vt = VT_NULL;

    HRESULT hr = DSGetObjectPropertiesGuid( 
			        MQDS_MACHINE,
			        GetQMGuid(),
			        nProp,
			        propId,
			        var 
			        );

	if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    m_cbAddress = var[0].blob.cbSize;
    delete [] m_blobAddress;
    m_blobAddress = var[0].blob.pBlobData;
    m_nCNs = var[1].cauuid.cElems;
    delete [] m_aguidCNs;
    m_aguidCNs = var[1].cauuid.pElems;
    m_guidSite =  *var[2].puuid;
    delete var[2].puuid;

    return(MQ_OK);
}


//+------------------------------------------------------------
//
//  HRESULT  CServerTopologyData::FindOrphanDsAddress()
//
//  Find a DS address that do not appear in the hardware list.
//
//+------------------------------------------------------------

HRESULT  CServerTopologyData::FindOrphanDsAddress(
                                     IN  CAddressList  *pAddressList,
                                     IN  DWORD          dwAddressLen,
                                     IN  DWORD          dwAddressType,
                                     OUT TA_ADDRESS   **pUnfoundAddress,
                                     OUT BOOL          *pfResolved )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, L"QM: CTopologyData::FindOrphanDsAddress"));
    
    TA_ADDRESS* unFoundAddress = NULL;
    TA_ADDRESS* ptr = NULL ;

    for ( DWORD len = 0;
         (*pfResolved && (len < m_cbAddress));
         len += TA_ADDRESS_SIZE + ptr->AddressLength )
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        if (ptr->AddressType == dwAddressType)
        {
            ASSERT (ptr->AddressLength == dwAddressLen) ;

            if ( ! IsDSAddressExist( pAddressList,
                                     ptr,
                                     dwAddressLen ))
            {
                //
                // DS Address was not found in hardware list.
                // Remember this unfound DS address.
                //
                if (unFoundAddress == NULL)
                {
                    //
                    // First Address that was not found
                    //
                    unFoundAddress = ptr;
                }
                else if (memcmp( &(ptr->Address),
                                 &(unFoundAddress->Address),
                                 dwAddressLen ) == 0)
                {
                    //
                    // Same address that already was not found.
                    // Note: win2k servers can return same address with
                    // several CNs. so same address can appear multiple
                    // times in the list returned from DS.
                    //
                }
                else
                {
                    //
                    // Two addresses changed.
                    // We can't recover from this situation.
                    //
                    *pfResolved = FALSE ;
                }
            }
        }
    }

    *pUnfoundAddress = unFoundAddress ;

    return MQ_OK ;
}

//+--------------------------------------------------------
//
//  HRESULT  CServerTopologyData::MatchOneAddress()
//
//+--------------------------------------------------------

HRESULT  CServerTopologyData::MatchOneAddress(
                                 IN  CAddressList  *pAddressList,
                                 IN  TA_ADDRESS    *pUnfoundAddressIn,
                                 IN  DWORD          dwAddressLen,
                                 IN  DWORD          dwAddressType,
                                 OUT BOOL          *pfResolved )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, L"QM: CTopologyData::MatchOneAddress"));
    
    if (pUnfoundAddressIn == NULL)
    {
        return MQ_OK ;
    }

    //
    // Matching is done in-place, and pUnfoundAddressIn is also a pointer
    // to same in-place buffer. So to avoid overwrites, copy it to a
    // different buffer and use that other buffer.
    //
    DWORD dwSize = TA_ADDRESS_SIZE + pUnfoundAddressIn->AddressLength ;
    P<TA_ADDRESS> pUnfoundAddress = (TA_ADDRESS*) new BYTE[ dwSize ] ;
    memcpy(pUnfoundAddress, pUnfoundAddressIn, dwSize) ;

    if (pAddressList->GetCount() == 1)
    {
        BOOL fChanged = FALSE ;

        //
        // We have one "orphan" DS address (that was not found in the
        // hardware list) and one "orphan" hardware address (that was not
        // found in the Ds list). So make a match...
        //
        POSITION pos = pAddressList->GetHeadPosition();
        ASSERT (pos != NULL);
        TA_ADDRESS *pAddr = pAddressList->GetNext(pos);
        TA_ADDRESS *ptr = NULL ;

        for ( DWORD len = 0;
              len < m_cbAddress ;
              len += TA_ADDRESS_SIZE + ptr->AddressLength )
        {
            ptr = (TA_ADDRESS*) (m_blobAddress + len);

            if (ptr->AddressType == dwAddressType)
            {
                ASSERT (ptr->AddressLength == dwAddressLen) ;

                if (memcmp( &(pUnfoundAddress->Address),
                            &(ptr->Address),
                            dwAddressLen ) == 0)
                {
                    memcpy( &(ptr->Address),
                            &(pAddr->Address),
                            dwAddressLen );
                    fChanged = TRUE ;
                }
            }
        }
        //
        // Assert that a match indeed happen...
        //
        ASSERT(fChanged) ;
    }
    else
    {
        //
        // We can reach here in one of two cases:
        // 1. The hardware list is empty, i.e., all hardware addresses were
        //    found in the DS list, while there is one (and only one) DS
        //    address that was not found in the hardware list.
        // 2. There are several candidate hardware addresses to replace
        //    the unfound address. We don't know which one to use.
        // In both cases, calling function will log an event and do nothing
        // more. In theory, we could handle case 1 too, but that means to
        // develop new code that didn't exist in msmq1.0. Too costly and
        // risky so late in the game (before rc2 of rtm)...
        //
        *pfResolved = FALSE ;
    }

    return MQ_OK ;
}

/*=================================================================

HRESULT  CServerTopologyData::CompareUpdateServerAddress()

Arguments:   IN OUT CAddressList  *pIPAddressList
             List of network addresses on local server, retieved using
             winsock apis.

Return Value:

===================================================================*/

HRESULT  CServerTopologyData::CompareUpdateServerAddress(
                                    IN OUT CAddressList  *pIPAddressList,
                                    OUT    BOOL          *pfResolved )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, L"QM: CTopologyData::CompareUpdateServerAddress"));
    
    //
    // By default, on Windows 2000 our addresses are aleays resolved.
    //
    *pfResolved = TRUE ;

    {
		//
		// remove IP loopback address
		//
        AP<char> ptrAddr = new char [TA_ADDRESS_SIZE + IP_ADDRESS_LEN];

        TA_ADDRESS *pAddr = (TA_ADDRESS *) (char*)ptrAddr;
        pAddr->AddressLength = IP_ADDRESS_LEN;
        pAddr->AddressType = IP_ADDRESS_TYPE;
		DWORD dwLoopBack = INADDR_LOOPBACK;
        memcpy( &(pAddr->Address), &dwLoopBack, IP_ADDRESS_LEN);

        IsDSAddressExistRemove(pAddr, IP_ADDRESS_LEN, pIPAddressList) ;
	}

    //
    // Now compare our addresses, as known by our ds server, with the
    // addresses that were retreived from local hardware. If only one
    // address changed, then "fix" the list and update the DS. If more
    // addresses changed, log an event.
    //
    TA_ADDRESS* unFoundIPAddress = NULL;

    HRESULT hr = FindOrphanDsAddress( pIPAddressList,
                                      IP_ADDRESS_LEN,
                                      IP_ADDRESS_TYPE,
                                     &unFoundIPAddress,
                                      pfResolved ) ;
    ASSERT(SUCCEEDED(hr)) ;

    if (!(*pfResolved))
    {
	    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, L"CompareUpdateServerAddress: Resolved IP address"));
        return MQ_OK ;
    }


    //
    // Here we know that only one DS address was not found in hardware list.
    // Now remove from hardware list all those addresses that appear in DS
    // list. These addresses are OK.
    //
    TA_ADDRESS* ptr = NULL ;

    for ( DWORD len = 0;
          len < m_cbAddress ;
          len += TA_ADDRESS_SIZE + ptr->AddressLength )
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        switch(ptr->AddressType)
        {
        case IP_ADDRESS_TYPE:
            ASSERT (ptr->AddressLength == IP_ADDRESS_LEN);

            IsDSAddressExistRemove( ptr,
                                    IP_ADDRESS_LEN,
                                    pIPAddressList ) ;
            break;

        case FOREIGN_ADDRESS_TYPE:
        default:
            break;

        } // case
    } // for

    //
    // Now see if we can resolve the changed address. i.e., if only one
    // DS address was not found in the hardware list, and one hardware
    // address was not found in the DS list, then replace the obsolete
    // DS address with the one left in the hardware list.
    //
    hr = MatchOneAddress( pIPAddressList,
                          unFoundIPAddress,
                          IP_ADDRESS_LEN,
                          IP_ADDRESS_TYPE,
                          pfResolved ) ;
    ASSERT(SUCCEEDED(hr)) ;

    return MQ_OK ;
}

//+------------------------------------------------------
//
//  void CServerTopologyData::GetAddressesSorted()
//
//+------------------------------------------------------

void CServerTopologyData::GetAddressesSorted(
                                 OUT IPADDRESS ** paIPAddress,
                                 OUT GUID **  paguidIPCN,
                                 OUT DWORD *  pnIP
								 ) const
{
     DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO, L"CServerTopologyData::GetAddressesSorted"));
     
    *paIPAddress = 0;
    *paguidIPCN = 0;
    *pnIP = 0;

    DWORD nIP = 0;
    BOOL fSingleIPCN=TRUE;
    GUID guidIP;
    DWORD iSrc = 0;

    TA_ADDRESS* ptr;

    for (DWORD len = 0; len < m_cbAddress && iSrc < m_nCNs; len += TA_ADDRESS_SIZE + ptr->AddressLength,iSrc++)
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        switch(ptr->AddressType)
        {
        case IP_ADDRESS_TYPE:
        case IP_RAS_ADDRESS_TYPE:
            ASSERT(ptr->AddressLength == IP_ADDRESS_LEN);
            if (nIP == 0)
            {
                guidIP = m_aguidCNs[iSrc];
            }
            else
            {
                fSingleIPCN = fSingleIPCN && guidIP == m_aguidCNs[iSrc];
            }
            nIP++;
            break;

        case FOREIGN_ADDRESS_TYPE:
            ASSERT(ptr->AddressLength == FOREIGN_ADDRESS_LEN);
            break;
        default:
            ASSERT(0);
        }      // case
    } // for

    if (nIP > 0 && fSingleIPCN)
    {
        //
        // BUGBUG: workaround for beta 2 - we have a limit of only one CN in the same protocol
		// for servers with RAS.
		// we listen on address 0, in order to avoid implementation of RAS notifications.
		// The server replies to RAS Falcon client broadcasts only
		// if it has only one CN in the same protocol
        //
        nIP = 1;
    }

    if (nIP > 0)
    {
        *paIPAddress  = new IPADDRESS[nIP];
        *paguidIPCN   = new GUID [nIP];
    }

    iSrc = 0;
    DWORD iIP = 0;

    for (len = 0; len < m_cbAddress && iSrc < m_nCNs; len += TA_ADDRESS_SIZE + ptr->AddressLength, iSrc++)
    {
        ptr = (TA_ADDRESS*) (m_blobAddress + len);

        switch(ptr->AddressType)
        {
        case IP_ADDRESS_TYPE:
        case IP_RAS_ADDRESS_TYPE:
			if (iIP < nIP)
			{
				if (fSingleIPCN)
				{
	                (*paIPAddress)[iIP] = INADDR_ANY;
				}
				else
				{
					memcpy(&(*paIPAddress)[iIP],ptr->Address,sizeof(IPADDRESS));
				}
				(*paguidIPCN)[iIP] = m_aguidCNs[iSrc];
				iIP++;
			}
            break;

        case FOREIGN_ADDRESS_TYPE:
            break;

        default:
            ASSERT(0);
        }      // case
    } // for

    *pnIP         = nIP;
}


bool
CServerTopologyData::GetDSServers(
    OUT unsigned char ** pblobDSServers,
    OUT DWORD * pcbDSServers
    ) const
{
    //
    // PSC, BSC get from DS, also FRS and RAS service that failed to get from registry
    //
    AP<WCHAR> pwcsServerList = new WCHAR[MAX_REG_DSSERVER_LEN];

    DWORD   len = GetDsServerList(pwcsServerList,MAX_REG_DSSERVER_LEN);

    //
    //  Write into registry, if succeeded to retrieve any servers
    //
    if ( len)
    {
        *pcbDSServers = len * sizeof(WCHAR);
        *pblobDSServers = (unsigned char*)pwcsServerList.detach();
        return true;
    }
    LogIllegalPoint(s_FN, 180);
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topology.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    recogniz.h

Abstract:

  Include file for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef __TOPOLOGY_H__
#define __TOPOLOGY_H__

#include "topoldat.h"
#include "topolsoc.h"
#include "topolpkt.h"
#include "cs.h"

DWORD WINAPI ServerRecognitionThread(LPVOID Param);

//***********************************************************
//
//   base class  CTopologyRecognition
//
//***********************************************************

class CTopologyRecognition
{
public:
    CTopologyRecognition();
    ~CTopologyRecognition();

protected:
    void ReleaseAddressLists(CAddressList * pIPAddressList);
};


inline CTopologyRecognition::CTopologyRecognition()
{
}

inline CTopologyRecognition::~CTopologyRecognition()
{
}

//*******************************************************************
//
//  class  CServerTopologyRecognition : public CTopologyRecognition
//
//*******************************************************************

class CServerTopologyRecognition : public CTopologyRecognition
{
public:
    CServerTopologyRecognition();

    ~CServerTopologyRecognition();


    HRESULT Learn();
    const GUID& GetSite() const;

    void ServerThread() const;

    const GUID& GetEnterprise() const;

private:

    CServerTopologyData m_Data;
};


inline CServerTopologyRecognition::CServerTopologyRecognition()
{
}

inline CServerTopologyRecognition::~CServerTopologyRecognition()
{
}

inline const GUID& CServerTopologyRecognition::GetSite() const
{
    return(m_Data.GetSite()) ;
}


inline const GUID& CServerTopologyRecognition::GetEnterprise() const
{
    return(m_Data.GetEnterprise()) ;
}

extern CServerTopologyRecognition  *g_pServerTopologyRecognition ;

#endif // __TOPOLOGY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topolpkt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topology.cpp

Abstract:

    Implementation of Automatic recognition Packets

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/


#include "stdh.h"
#include "topolpkt.h"
#include "ds.h"
#include "mqsymbls.h"
#include "mqprops.h"
#include <mqlog.h>

#include "topolpkt.tmh"

static WCHAR *s_FN=L"topolpkt";

static
bool
IsValidSite(
    const GUID& id
    )
{
    if (id == GUID_NULL)
        return false;

    PROPID prop[] = {
                PROPID_S_FOREIGN,
                };

    MQPROPVARIANT var[TABLE_SIZE(prop)] = {{VT_NULL,0,0,0,0}};

	HRESULT hr = DSGetObjectPropertiesGuid(
						MQDS_SITE,				
						&id,
						TABLE_SIZE(prop),
						prop,
						var
						);

	return (SUCCEEDED(hr));
}

bool
CTopologyClientRequest::Parse(
    IN const char * bufrecv,
    IN DWORD cbrecv,
    IN const GUID& guidEnterprise,
    IN const GUID& guidMySite,
    OUT GUID * pguidRequest,
    OUT BOOL * pfOtherSite
    )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CTopologyClientRequest::Parse"));
    
    //
    // check that received from a Falcon machine
    //
    DWORD cbMin = GetMinSize();

    if (cbrecv < cbMin)
    {
        LogIllegalPoint(s_FN, 10);
        return false;
    }

    const CTopologyClientRequest *pRequest = (const CTopologyClientRequest *) bufrecv;

    if (!pRequest->m_Header.Verify(QM_RECOGNIZE_CLIENT_REQUEST,guidEnterprise))
    {
        LogIllegalPoint(s_FN, 20);
        return false;
    }

    //
    //  Is the client site a known site in this server enterprise ?
    //  Since in Win2k we removed the verification of enterprise-id, let's
    //  verify that the client "old" site belongs to this enterprise.
    //
    //  NT4 mobile clients provide a correct site-guid only on the first call,
    //  afterward they send GUID_NULL as the site guid.
    //  Therefore if a NT4 client sends a GUID_NULL, we will verify its
    //  enterprise id.
    //  Win2k clients always send the site id, so win2k servers never
    //  check enterprise id for them.
    //
    if ( !IsValidSite(pRequest->m_guidSite))
    {
        if (pRequest->m_guidSite != GUID_NULL)
        {
            LogIllegalPoint(s_FN, 30);
            return false;
        }

        if ( guidEnterprise != *pRequest->m_Header.GetEnterpriseId() )
        {
            LogIllegalPoint(s_FN, 40);
            return false;
        }
    }

    *pguidRequest = pRequest->m_guidRequest;
    *pfOtherSite = pRequest->m_guidSite != guidMySite;

    return true;
}


bool
CTopologyServerReply::Parse(
    IN const char * bufrecv,
    IN DWORD cbrecv,
    IN const GUID& guidRequest,
    OUT DWORD * pnCN,
    OUT const GUID** paguidCN,
    OUT GUID* pguidSite,
    OUT DWORD* pcbDSServers,
    OUT const char** pblobDSServers
    )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CTopologyServerReply::Parse"));

    //
    // check that received from a Falcon machine
    //
    if (cbrecv < CTopologyServerReply::GetSize(0))
    {
        LogIllegalPoint(s_FN, 70);
        return false;
    }

    const CTopologyServerReply * pReply = (const CTopologyServerReply*)bufrecv;

    if (!pReply->m_Header.Verify(QM_RECOGNIZE_SERVER_REPLY,guidRequest))
    {
        LogIllegalPoint(s_FN, 80);
        return false;
    }

    DWORD nCN = pReply->m_nCN;
	ASSERT(("CN number must be 1", nCN == 1));

    if (nCN == 0)
    {
		ASSERT(("CN number is zero", 0));
        LogIllegalPoint(s_FN, 90);
        return false;
    }
    *pcbDSServers = pReply->m_cbDSServers;

    if (cbrecv < CTopologyServerReply::GetSize(*pcbDSServers))
    {
        LogIllegalPoint(s_FN, 100);
        return false;
    }

	*pnCN = nCN;


    *paguidCN = pReply->m_aguidCN;

    if (*pcbDSServers != 0)
    {
        *pguidSite = pReply->m_aguidCN[nCN];

        *pblobDSServers = (const char*)&(pReply->m_aguidCN[nCN+1]);
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topolsoc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topolsoc.h

Abstract:

  Include file sockets for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef __TOPOLSOC_H__
#define __TOPOLSOC_H__

#include <winsock.h>
#include "mqsymbls.h"
#include "_mqdef.h"

typedef DWORD   IPADDRESS;

class CTopologySocket
{
public:
    CTopologySocket();
    ~CTopologySocket();

    SOCKET GetSocket() const;

protected:
    bool CreateIPSocket(IN BOOL fbroad, IN IPADDRESS IPAddress);
private:
    SOCKET m_socket;
};


inline CTopologySocket::CTopologySocket():
                                    m_socket(INVALID_SOCKET)
{
}

inline CTopologySocket::~CTopologySocket()
{
    if (m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
    }
}

inline SOCKET CTopologySocket::GetSocket() const
{
    return(m_socket);
}

class CTopologyServerSocket : public CTopologySocket
{
public:
    CTopologyServerSocket();
    ~CTopologyServerSocket();

    bool
    ServerRecognitionReply(
        IN const char *bufsend,
        IN DWORD cbsend,
        IN const SOCKADDR& hto
        ) const;

    virtual DWORD GetCN(OUT GUID* pGuidCN) const =0;
};

inline CTopologyServerSocket::CTopologyServerSocket()
{
}

inline CTopologyServerSocket::~CTopologyServerSocket()
{
}

class CTopologyServerIPSocket : public CTopologyServerSocket
{
public:
    CTopologyServerIPSocket();
    ~CTopologyServerIPSocket();

    bool Create(IN IPADDRESS IPAddress, IN const GUID& guidCN);

    DWORD GetCN(OUT GUID* pGuidCN) const;

private:
    GUID m_guidCN;
};

inline CTopologyServerIPSocket::CTopologyServerIPSocket()
{
    memset(&m_guidCN,0,sizeof(GUID));
}

inline CTopologyServerIPSocket::~CTopologyServerIPSocket()
{
}

inline
bool
CTopologyServerIPSocket::Create(
    IN IPADDRESS IPAddress,
    IN const GUID & guidCN
    )
{
    m_guidCN = guidCN;
    return(CTopologySocket::CreateIPSocket(FALSE,IPAddress));
}

inline DWORD CTopologyServerIPSocket::GetCN(
                               OUT GUID* pGuidCN) const
{
    *pGuidCN = m_guidCN;
    return(1);
}


class CTopologyArrayServerSockets
{
public:
    CTopologyArrayServerSockets();
    ~CTopologyArrayServerSockets();

    bool
    CreateIPServerSockets(
        DWORD  nSock,
        const IPADDRESS aIPAddresses[],
        const GUID aguidCNs[]
        );

    bool
    ServerRecognitionReceive(
        OUT char *bufrecv,
        IN DWORD cbbuf,
        OUT DWORD *pcbrecv,
        OUT const CTopologyServerSocket **ppSocket,
        OUT SOCKADDR *phFrom
        );

private:

    const CTopologyServerSocket * GetSocketAt(IN DWORD n) const;

    DWORD m_nIPSock;
    CTopologyServerIPSocket* m_aServerIPSock;
};

inline CTopologyArrayServerSockets::CTopologyArrayServerSockets() :
                            m_nIPSock(0),
                            m_aServerIPSock(NULL)
{
}

inline CTopologyArrayServerSockets::~CTopologyArrayServerSockets()
{
    delete [] m_aServerIPSock;
}


inline const CTopologyServerSocket * CTopologyArrayServerSockets::GetSocketAt(IN DWORD n) const
{
    ASSERT(("support only IP", n < m_nIPSock));
    return(&m_aServerIPSock[n]);
}

#endif	// __TOPOLSOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topology.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topology.cpp

Abstract:

    Implementation of Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include "topolpkt.h"
#include "topology.h"
#include "mqsymbls.h"
#include <mqlog.h>

#include "topology.tmh"

CServerTopologyRecognition*  g_pServerTopologyRecognition = NULL;

static WCHAR *s_FN=L"topology";

/*====================================================

void CTopologyRecognition::ReleaseAddressLists()

Arguments:

Return Value:


=====================================================*/
void CTopologyRecognition::ReleaseAddressLists(CAddressList * pIPAddressList)
{
    POSITION        pos;
    TA_ADDRESS*     pAddr;
    pos = pIPAddressList->GetHeadPosition();
    while(pos != NULL)
    {
        pAddr = pIPAddressList->GetNext(pos);
        delete []pAddr;
    }
}

//+=========================================================================
//
//  CServerTopologyRecognition::Learn()
//
//  Description:
//    On MSMQ1.0 (NT4), we assumed that server have fix addresses.
//    If more than one network address changed at boot then an event was
//    issued and initialization was not completed until administrator
//    used mqxplore to assign CNs to new addresses (or remove CNs).
//    The MQIS kept the old addresses and this function compared them to
//    new machine addresses at boot. If nothing changed (or only one
//    address changed) then initialization completed OK.
//
//    On Windows 2000, the DS do not keep machine addresses anymore and
//    we don't assume that server has fix address. We also do not have
//    CNs anymore. Server can change/add/remove addresses at will.
//    However, in mixed mode, to be compatible with MSMQ1.0 servers, we
//    must replicate address changes of servers to the NT4 world.
//    So, at boot we check if there is any change in our local addresses.
//    If there is a change we touch the msmqConfiguration object in the DS
//    (by re-setting its quota value). This causes the replication service
//    that run on the ex-PEC machine to replicate the changes to NT4.
//
//    There are two ways to check for change in addresses:
//    1. read our own address from NT4 MQIS server, and compare to local
//       network  addresses that are retrieve from hardware.
//    2. read cached addresses from registry (these ones are saved by the
//       msmq service after boot) and compare to hardware.
//    We use both methods as we may query either a NT4 MQIS server or a
//    win2k ds server.
//
//    The above theory is Ok as long as local server is not owned by a
//    NT4 PSC. If it is owned by a NT4 PSC, then tough luck. The PSC store
//    addresses and CNs and local server must update the PSC with correct
//    data. So we must use msmq1.0 style code to handle change in one address.
//    what happen if more than one address changed ? that's really bad.
//    With msmq1.0, we used local mqxplore. Now we'll have to log an event
//    that tell user to use mqxplore on the PSC to update the addresses
//    and CNs of local server. In any case, local server continue to run
//    as usual. See below in the code.
//
//  Return Value:
//
//+=========================================================================

HRESULT CServerTopologyRecognition::Learn()
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CServerTopologyRecognition::Learn"));

    //
    // Retrieve machine addresses and CNs.
    //
    HRESULT rc = m_Data.Load();
    if (FAILED(rc))
    {
        return LogHR(rc, s_FN, 110);
    }

    //
    // Retrieve Current machine address
    //
    P<CAddressList> pIPAddressList;

    pIPAddressList = GetIPAddresses();

    BOOL fResolved = FALSE;
    try
    {
        rc = m_Data.CompareUpdateServerAddress(pIPAddressList, &fResolved);
    }
    catch(...)
    {
        //
        // the reason for this try/catch is that this code was added
        // quite late in the game, before win2k rtm. It has too many loops
        // that depend on the proper structure of data. Anything can fail
        // and gpf. We don't have the time to test all possible scenario.
        // So to be on the safe side, catch any exception and consider them
        // as "everything is just fine"...
        //
        LogIllegalPoint(s_FN, 130);

        rc = MQ_OK ;
        fResolved = TRUE ;
    }

    LogHR(rc, s_FN, 120);
    if (SUCCEEDED(rc))
    {
        if(!fResolved)
        {
            REPORT_CATEGORY(DS_ADDRESS_NOT_RESOLVED, CATEGORY_MQDS);
        }
    }

    //
    // We're always resolved, even if several addresses changed and
    // an event is logged. there is nothing more we can do, and win2k
    // admin tool can not be used to resolve addresses. So let's go on
    // and do the best we can.
    // Actually, this server can communicate with the outside world.
    // The outside world may have problems communicating with us.
    //
    ReleaseAddressLists(pIPAddressList) ;

    return rc ;
}


/*====================================================

ServerRecognitionThread

Arguments:

Return Value:

=====================================================*/

DWORD WINAPI ServerRecognitionThread(LPVOID Param)
{

    const CServerTopologyRecognition * pServerTopologyRecognition = (CServerTopologyRecognition *) Param;

    for(;;)
    {
        try
        {
            pServerTopologyRecognition->ServerThread();
            REPORT_CATEGORY(RECOGNITION_SERVER_FAIL, CATEGORY_MQDS);
            LogIllegalPoint(s_FN, 30);
            return 1;
        }
        catch(const bad_alloc&)
        {
            LogIllegalPoint(s_FN, 83);
        }
    }

    return 0;
}

/*====================================================

CServerTopologyRecognition::ServerThread

Arguments:

Return Value:

=====================================================*/

void CServerTopologyRecognition::ServerThread() const
{
    for(;;)
    {

        //
        // Retrieve Current machine address
        //

        AP<IPADDRESS> aIPAddress;
        AP<GUID> aIPCN;
        DWORD nIP = 0;
        m_Data.GetAddressesSorted(&aIPAddress,&aIPCN,&nIP);
        DWORD nSock = nIP;
        if (nSock == 0)
        {
            DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("ServerRecognitionThread: does not have any address")));
	    	LogIllegalPoint(s_FN, 23);
            return;
        }


        CTopologyArrayServerSockets ServerSockets;

        if(!ServerSockets.CreateIPServerSockets(nIP,aIPAddress,aIPCN))
        {
	    	LogIllegalPoint(s_FN, 24);
            return;
        }

        SOCKADDR hFrom;
        DWORD cbRecv;

        AP<unsigned char> blobDSServers;
        DWORD cbDSServers = 0;

        const GUID& rguidEnterprise = m_Data.GetEnterprise();
        const GUID& rguidSite = m_Data.GetSite();

        if(!m_Data.GetDSServers(&blobDSServers, &cbDSServers))
        {
	    	LogIllegalPoint(s_FN, 26);
            return;
        }

        DWORD cbSend;
        AP<char> bufSend = CTopologyServerReply::AllocBuffer(cbDSServers,&cbSend);

#ifdef _DEBUG
#undef new
#endif
        CTopologyServerReply * pReply =
            new (bufSend) CTopologyServerReply();
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

        DWORD cbMaxRecv = CTopologyClientRequest::GetMaxSize();
        AP<char> bufRecv = new char[cbMaxRecv];

        BOOL fOtherSite;

        const CTopologyServerSocket * pSocket;

        P<GUID> pGuidCN = new GUID;
        GUID guidRequest;

        for(;;)
        {
            if(!ServerSockets.ServerRecognitionReceive(bufRecv,cbMaxRecv,&cbRecv,&pSocket,&hFrom))
            {
                //
                // cannot receive, rebuild sockets
                //
		    	LogIllegalPoint(s_FN, 27);
                break;
            }

            bool fParsed = CTopologyClientRequest::Parse( bufRecv,
                                                    cbRecv,
                                                    rguidEnterprise,
                                                    rguidSite,
                                                    &guidRequest,
                                                    &fOtherSite
												    ) ;
            if(!fParsed)
            {
		    	LogIllegalPoint(s_FN, 28);
                continue;
            }

			//
			// We "know" GetCN will return one CN. ilanh 02-August-2000
			// 
            pSocket->GetCN(pGuidCN);

            pReply->SetSpecificInfo(
                                guidRequest,
                                pGuidCN,
                                fOtherSite,
                                cbDSServers,
                                rguidSite,
                                (const char*) (unsigned char*)blobDSServers,
                                &cbSend
								);

            if(!pSocket->ServerRecognitionReply(bufSend,cbSend,hFrom))
            {
                //
                // cannot send, rebuild sockets
                //
		    	LogIllegalPoint(s_FN, 29);
                break;
            }

        }
    }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topolpkt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topology.cpp

Abstract:

    Include file of Automatic recognition Packets

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/


#ifndef __TOPOLPKT_H__
#define __TOPOLPKT_H__

#include "dssutil.h"

#define QM_RECOGNIZE_VERSION         0

#define QM_RECOGNIZE_CLIENT_REQUEST    1
#define QM_RECOGNIZE_SERVER_REPLY      2

//
// CTopologyPacketHeader
//

#pragma pack(push, 4)

class CTopologyPacketHeader
{
    public:
        CTopologyPacketHeader(IN unsigned char ucType);
        CTopologyPacketHeader(IN unsigned char ucType,
                              IN const GUID& guidIdentifier);
        ~CTopologyPacketHeader();

        void SetIdentifier(IN const GUID& guid);

        BOOL Verify(IN unsigned char ucType,
                    IN const GUID& guid) const;
        const GUID * GetEnterpriseId() const { return &m_guidIdentifier;};


    private:
        unsigned char  m_ucVersion;
        unsigned char  m_ucType;
        unsigned short m_usReserved;
        GUID           m_guidIdentifier;
};
#pragma pack(pop)

inline CTopologyPacketHeader::CTopologyPacketHeader(IN unsigned char ucType):
                        m_ucVersion(QM_RECOGNIZE_VERSION),
                        m_ucType(ucType),
                        m_usReserved(0)
{
    memset(&m_guidIdentifier,0,sizeof(GUID));
}

inline CTopologyPacketHeader::CTopologyPacketHeader(IN unsigned char ucType,
                                             IN const GUID& guidIdentifier):
                        m_ucVersion(QM_RECOGNIZE_VERSION),
                        m_ucType(ucType),
                        m_usReserved(0),
                        m_guidIdentifier(guidIdentifier)
{
}

inline CTopologyPacketHeader::~CTopologyPacketHeader()
{
}

inline void CTopologyPacketHeader::SetIdentifier(IN const GUID& guid)
{
    m_guidIdentifier = guid;
}


inline BOOL CTopologyPacketHeader::Verify(IN unsigned char ucType,
                                   IN const GUID& guid) const
{
    switch( ucType)
    {
    case QM_RECOGNIZE_CLIENT_REQUEST:
        //
        //  check version ( ignore enterprise)
        //
        return(
                 m_ucVersion == QM_RECOGNIZE_VERSION &&
                 m_ucType == ucType 
              );
        break;  
    case QM_RECOGNIZE_SERVER_REPLY:
        //
        // check version, sending enterprise and type
        //
        return(
                 m_ucVersion == QM_RECOGNIZE_VERSION &&
                 m_ucType == ucType &&
                 m_guidIdentifier == guid
              );
        break;
    default:
        ASSERT(0);
        return( FALSE);
        break;

    }
}


//
// CTopologyClientRequest
//

#pragma pack(push, 4)

class CTopologyClientRequest
{
public:
    CTopologyClientRequest(IN const GUID& guidEnterprise,
                           IN const GUID& guidSite);

    ~CTopologyClientRequest();

    const char * GetBuffer(OUT DWORD *pcbIPBuf);

    const GUID& GenerateIdentifier();

    static DWORD GetMaxSize();

    static
    bool
    Parse(
        IN const char * bufrecv,
        IN DWORD cbrecv,
        IN const GUID& guidEnterprise,
        IN const GUID& guidMySite,
        OUT GUID * pguidRequest,
        OUT BOOL * pfOtherSite
        );

private:

    static DWORD GetMinSize();

    CTopologyPacketHeader  m_Header;
    GUID                   m_guidRequest;
    GUID                   m_guidSite;
};
#pragma pack(pop)


inline CTopologyClientRequest::CTopologyClientRequest(IN const GUID& guidEnterprise,
                                                      IN const GUID& guidSite):
                               m_Header(QM_RECOGNIZE_CLIENT_REQUEST,guidEnterprise),
                               m_guidSite(guidSite)
{
    memset(&m_guidRequest,0,sizeof(GUID));
}

inline CTopologyClientRequest::~CTopologyClientRequest()
{
}

inline const char * CTopologyClientRequest::GetBuffer(OUT DWORD *pcbIPBuf)
{
    *pcbIPBuf =  GetMinSize();
    return ((const char *) this);
}

inline const GUID& CTopologyClientRequest::GenerateIdentifier()
{
    UuidCreate(&m_guidRequest);
    return (m_guidRequest);
}

inline DWORD CTopologyClientRequest::GetMaxSize()
{
    return (sizeof(CTopologyClientRequest));
}

inline DWORD CTopologyClientRequest::GetMinSize()
{
    return (sizeof(CTopologyClientRequest));
}

//
// CTopologyServerReply
//

#pragma pack(push, 4)

class CTopologyServerReply
{
public:
    CTopologyServerReply();
    ~CTopologyServerReply();

    static char* AllocBuffer(IN DWORD cbDSServers,
                             OUT DWORD *pcbBuf);

    void SetSpecificInfo(IN const GUID& guidRequest,
                         IN const GUID* pGuidCN,
                         IN BOOL fOtherSite,
                         IN DWORD  cbDSServers,
                         IN const GUID& guidSite,
                         IN const char* blobDSServers,
                         OUT DWORD *pcbsend);

    static
    bool
    Parse(
        IN const char * bufrecv,
        IN DWORD cbrecv,
        IN const GUID& guidRequest,
        OUT DWORD * pnCN,
        OUT const GUID** paguidCN,
        OUT GUID* pguidSite,
        OUT DWORD* pcbDSServers,
        OUT const char** pblobDSServers
        );

private:
    static DWORD GetSize(IN DWORD cbDSServers);

	//
	// Don't touch or rearrange this structure.
	// This is the ServerReply structure that need to be compatible for msmq1.0
	// and msmq2.0 clients requests. ilanh 10-Aug-2000
	//
    CTopologyPacketHeader  m_Header;
    DWORD          m_nCN;
    DWORD          m_maskCN;
    DWORD          m_cbDSServers;
    GUID           m_aguidCN[1];           
    //GUID           m_guidSite;           // site right after CNs if cbDSservers > 0
    //char*          m_blobDSServers;      // DSServer only if cbDSServers > 0
};
#pragma pack(pop)

inline CTopologyServerReply::CTopologyServerReply():
                             m_Header(QM_RECOGNIZE_SERVER_REPLY),
                             m_nCN(0),
                             m_maskCN(0),                                 
                             m_cbDSServers(0)
{
    memset(&m_aguidCN,0,sizeof(m_aguidCN));
}

inline DWORD CTopologyServerReply::GetSize(IN DWORD cbDSServers)
{
    //
	// We are using the information that 
	// CTopologyServerIPSocket::GetCN return always 1 CN so we "know" we have only 1 site.
	// Some more cleanups need to do regarding this ilanh 2-August-2000
	//
	DWORD size = sizeof(CTopologyServerReply);
    if (cbDSServers)
    {
        size+= sizeof(GUID) + cbDSServers;
    }
    return(size);

}

inline char* CTopologyServerReply::AllocBuffer(
                                IN DWORD cbDSServers,
                                OUT DWORD *pcbBuf)
{
    //
    //
    //
    *pcbBuf = GetSize(cbDSServers);

    return new char[*pcbBuf];
}


inline void CTopologyServerReply::SetSpecificInfo(
                                IN const GUID& guidRequest,
                                IN const GUID* pGuidCN,
                                IN BOOL fOtherSite,
                                IN DWORD  cbDSServers,
                                IN const GUID& guidSite,
                                IN const char* blobDSServers,
                                OUT DWORD *pcbsend)
{
    //
    // write CN
    //
    m_Header.SetIdentifier(guidRequest);

    //
	// We are using the information that 
	// CTopologyServerIPSocket::GetCN return always 1 CN
	// Some more cleanups need to do regarding this ilanh 2-August-2000
	//
	m_nCN = 1;
    memcpy(m_aguidCN,pGuidCN,sizeof(GUID));
    
    //
    // expose site info if needed
    //
    if (fOtherSite)
    {
        m_cbDSServers = cbDSServers ;
        //
        // guid Site is after the last CN
        //
        m_aguidCN[m_nCN] = guidSite;
        //
        // DSServers are after the Site
        //
        memcpy(&m_aguidCN[m_nCN+1],blobDSServers,cbDSServers);
    }
    else
    {
         m_cbDSServers = 0;
    }

    *pcbsend = GetSize(m_cbDSServers);

}



#endif	// __TOPOLPKT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topoldat.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topoldat.h

Abstract:

  Include file for cached data class for Automatic recognition of site and CNs

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#ifndef __TOPOLDAT_H__
#define __TOPOLDAT_H__

#include "dssutil.h"
typedef DWORD   IPADDRESS;

//***********************************************************
//
//   base class  CTopologyData
//
//***********************************************************

class CTopologyData
{
    public:
        CTopologyData();
        ~CTopologyData();

        bool LoadFromRegistry();

        const GUID& GetEnterprise() const;
        const GUID& GetSite() const;

        BOOL GetAddresses(OUT DWORD                * pcbAddress,
                          OUT const unsigned char ** pblobAddress,
                          OUT DWORD                * pnCNs,
                          OUT const GUID          ** paguidCNs ) const;

    protected:

        DWORD           m_cbAddress;
        unsigned char * m_blobAddress;
        DWORD           m_nCNs;
        GUID *          m_aguidCNs;
        GUID            m_guidEnterprise;
        GUID            m_guidSite;
};


inline CTopologyData::CTopologyData():
                                m_cbAddress(0),
                                m_blobAddress(NULL),
                                m_nCNs(0),
                                m_aguidCNs(NULL)
{
    memset(&m_guidEnterprise,0,sizeof(GUID));
    memset(&m_guidSite,0,sizeof(GUID));
}

inline CTopologyData::~CTopologyData()
{
    delete [] m_blobAddress;
    delete [] m_aguidCNs;
}

inline const GUID& CTopologyData::GetEnterprise() const
{
    return(m_guidEnterprise);
}

inline const GUID& CTopologyData::GetSite() const
{
    return(m_guidSite);
}

inline  BOOL CTopologyData::GetAddresses(
                               OUT DWORD * pcbAddress,
                               OUT const unsigned char ** pblobAddress,
                               OUT DWORD         * pnCNs,
                               OUT const GUID **         paguidCNs) const
{
    if (m_cbAddress > 0 && m_blobAddress != NULL
        && m_nCNs   > 0 && m_aguidCNs != NULL)
    {

        *pcbAddress = m_cbAddress;
        *pblobAddress = m_blobAddress;
        *pnCNs = m_nCNs;
        *paguidCNs = m_aguidCNs;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


//***********************************************************
//
//   class CServerTopologyData : public CTopologyData
//
//***********************************************************

class CServerTopologyData : public CTopologyData
{
    public:
        CServerTopologyData();
        ~CServerTopologyData();

        HRESULT Load();

        HRESULT CompareUpdateServerAddress(
                                    IN OUT CAddressList  *pIPAddressList,
                                    OUT    BOOL          *pfResolved ) ;

        bool
        GetDSServers(
            OUT unsigned char ** pblobDSServers,
            OUT DWORD * pcbDSServers
            ) const;

        void GetAddressesSorted( OUT IPADDRESS ** paIPAddress,
                                 OUT GUID **  paguidIPCN,
                                 OUT DWORD *  pnIP
								 ) const;

    private:

        HRESULT MatchOneAddress( IN  CAddressList  *pAddressList,
                                 IN  TA_ADDRESS    *pUnfoundAddress,
                                 IN  DWORD          dwAddressLen,
                                 IN  DWORD          dwAddressType,
                                 OUT BOOL          *pfResolved ) ;

        HRESULT FindOrphanDsAddress( IN  CAddressList  *pAddressList,
                                     IN  DWORD          dwAddressLen,
                                     IN  DWORD          dwAddressType,
                                     OUT TA_ADDRESS   **pUnfoundAddress,
                                     OUT BOOL          *pfResolved ) ;

};


inline CServerTopologyData::CServerTopologyData()
{
}

inline CServerTopologyData::~CServerTopologyData()
{
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqdssvc\topolsoc.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    topolsoc.cpp

Abstract:

  Implementation of sockets for Automatic recognition

Author:

    Lior Moshaiov (LiorM)
    Ilan Herbst   (ilanh)   9-July-2000 

--*/

#include "stdh.h"
#include <winsock.h>
#include <nspapi.h>
#include <wsnwlink.h>
#include "topolsoc.h"
#include "mqutil.h"
#include <mqlog.h>
#include "cm.h"

#include "topolsoc.tmh"

static WCHAR *s_FN=L"topolsoc";

const LPCWSTR xParameters = L"Parameters";
const LPCWSTR xMsmqIpPort = L"MsmqIpPort";


bool
CTopologySocket::CreateIPSocket(
    IN BOOL fbroad,
    IN IPADDRESS IPAddress
    )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CTopologySocket::CreateIPSocket"));
   
    int rc;

    if (m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
    }

    m_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (m_socket == INVALID_SOCKET)
    {
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("CN recognition: failed to create IP socket")));
        LogIllegalPoint(s_FN, 10);
        return false;
    }

    BOOL exclusive = TRUE;
    rc = setsockopt( m_socket, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&exclusive, sizeof(exclusive));
    if (rc != 0)
    {
        rc = WSAGetLastError();
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("CN recognition: setsocketopt SO_EXCLUSIVEADDRUSE failed rc = %d for IP socket"),rc));
        LogNTStatus(rc, s_FN, 20);
        return false;
    }
    if (fbroad)
    {
        rc = setsockopt( m_socket, SOL_SOCKET, SO_BROADCAST, (char *)&exclusive, sizeof(exclusive));
        if (rc != 0)
        {
            rc = WSAGetLastError();
            DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
              TEXT("CN recognition: setsocketopt SO_BROADCAST failed rc = %d for IP socket"),rc));
            LogNTStatus(rc, s_FN, 30);
            return false; 
        }
    }

    //
    // Keep the TA_ADDRESS format of local IP address
    //
    SOCKADDR_IN local_sin;  // Local socket - internet style

    local_sin.sin_family = AF_INET;


    //
    // read IP port from registry.
    //
	DWORD  dwIPPort = 0 ;
    DWORD dwDef = FALCON_DEFAULT_IP_PORT;
	const RegEntry xMsmqIpPortEntry(xParameters, xMsmqIpPort, dwDef);
	CmQueryValue(xMsmqIpPortEntry, &dwIPPort);

    ASSERT(("IP Port was not found", dwIPPort));
    local_sin.sin_port = htons(DWORD_TO_WORD(dwIPPort));  // Convert to network ordering

    //
    //  Bind to IP address
    //
    memcpy(&local_sin.sin_addr.s_addr,&IPAddress,IP_ADDRESS_LEN);

    rc = bind( m_socket, (struct sockaddr FAR *) &local_sin, sizeof(local_sin));
    if (rc != 0)
    {
        rc = WSAGetLastError();
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("CN recognition: bind failed rc = %d for IP socket"),rc));
        LogNTStatus(rc, s_FN, 40);
        return false;
    }

    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  
       L"Topology socket (broadcast=%d) has been bound to port %d, IP %hs", 
       fbroad, dwIPPort, inet_ntoa(local_sin.sin_addr)));

    return true;
}


bool
CTopologyArrayServerSockets::CreateIPServerSockets(
    DWORD  nSock,
    const IPADDRESS aIPAddresses[],
    const GUID aguidCNs[]
    )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CTopologyArrayServerSockets::CreateIPServerSockets"));

    if (nSock ==0)
    {
        return(MQ_OK);
    }

    m_nIPSock = nSock;
    m_aServerIPSock = new CTopologyServerIPSocket[m_nIPSock];

    for (DWORD i=0; i< nSock ; i++)
    {
        if(!m_aServerIPSock[i].Create(aIPAddresses[i],aguidCNs[i]))
        {
            DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("CN recognition: failed in IP socket num %d"),i));
            LogIllegalPoint(s_FN, 82);
            return false;
        }
    }
    return true;

}


bool
CTopologyArrayServerSockets::ServerRecognitionReceive(
    OUT char *bufrecv,
    IN DWORD cbbuf,
    OUT DWORD *pcbrecv,
    OUT const CTopologyServerSocket **ppSocket,
    OUT SOCKADDR *phFrom
    )
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CTopologyArrayServerSockets::ServerRecognitionReceive"));

    fd_set sockset;

    DWORD nSock = m_nIPSock;

    FD_ZERO(&sockset);
    for(DWORD i=0;i<nSock;i++)
    {
        FD_SET((GetSocketAt(i))->GetSocket(),&sockset);
    }

    int rc = select(0,&sockset,NULL,NULL,NULL);
    if (rc == SOCKET_ERROR)
    {
        rc = WSAGetLastError();
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
              TEXT("Server broadcast listen: select failed rc = %d"),rc)) ;
        LogNTStatus(rc, s_FN, 90);
        return false;
    }

    BOOL found=FALSE;
    for(i=0;i<nSock;i++)
    {
        if (FD_ISSET((GetSocketAt(i))->GetSocket(),&sockset))
        {
            DBGMSG((DBGMOD_ROUTING,DBGLVL_INFO,TEXT("Server broadcast listen: received on index %d"),i));
            *ppSocket = GetSocketAt(i);
            found = TRUE;
            break;
        }

    }

    if (!found)
    {
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("Server broadcast listen: select returned with no sockets")));
        LogIllegalPoint(s_FN, 100);
        return false;
    }


    int fromlen = sizeof(SOCKADDR);

    *pcbrecv = recvfrom((*ppSocket)->GetSocket(),bufrecv,cbbuf,0,phFrom,&fromlen);
    if (*pcbrecv == SOCKET_ERROR)
    {
        rc = WSAGetLastError();
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("Server broadcast listen: recvfrom failed, rc = %d"),i));
        LogNTStatus(rc, s_FN, 110);
        return false;
    }
    DBGMSG((DBGMOD_ROUTING,DBGLVL_INFO,TEXT("Server broadcast listen: recvfrom returned with %d bytes"),*pcbrecv));

    return true;
}

bool
CTopologyServerSocket::ServerRecognitionReply(
    IN const char *bufsend,
    IN DWORD cbsend,
    IN const SOCKADDR& hto
    ) const
{
    DBGMSG((DBGMOD_ROUTING, DBGLVL_INFO,  L"QM: CTopologyServerSocket::ServerRecognitionReply"));

    int rc = sendto(GetSocket(),bufsend,cbsend,0,(PSOCKADDR)&hto,sizeof(SOCKADDR));
    if (rc == SOCKET_ERROR)
    {
        rc = WSAGetLastError();
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("Server broadcast listen: sendto failed, rc = %d"),rc));
        LogNTStatus(rc, s_FN, 120);
        return false;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqise\ise2qm_c_.c ===
#pragma warning(push, 3)
#include <ise2qm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqise\test\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:
...review details in all files
--*/


#pragma once

#ifndef __STDH_H
#define __STDH_H

#include <libpch.h>

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqise\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqise.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqise\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:
...review details in all files
--*/


#pragma once

#ifndef __STDH_H
#define __STDH_H

#include <libpch.h>

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqise\test\ise2qm_s_.c ===
#pragma warning(push, 3)
#include <ise2qm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqise\mqise.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    mqise.cpp

Abstract:
    MSMQ ISAPI extension

	Forwards http requests from IIS to the QM through RPC interface

Author:
    Nir Aides (niraides) 03-May-2000

--*/



#include "stdh.h"

#include <httpext.h>
#include <_mqini.h>
#include <buffer.h>
#include <bufutl.h>
#include "ise2qm.h"
#include <mqcast.h>
#include <mqexception.h>
#include <autoreln.h>
#include <Aclapi.h>
#include <autohandle.h>


#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include "_registr.h"
#include "_mqrpc.h"

#include "mqise.tmh"

using namespace std;



//
// Globals and constants
//
const TraceIdEntry MQISE = L"ISAPI Extension";

const int MAX_STR_LEN = 4096;

LPCSTR HTTP_STATUS_SERVER_ERROR_STR = "500 Internal server error";
LPCSTR HTTP_STATUS_DENIED_STR = "401 Unauthorized";

static WCHAR* s_pszStringBinding = NULL;

static bool s_fInitialized = false;
	

static void InitRPC()
{
	ASSERT(s_fInitialized == false);

    AP<WCHAR> QmLocalEp;
    READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);
    ComposeLocalEndPoint(wzEndpoint, &QmLocalEp);

    RPC_STATUS status  = RpcStringBindingCompose(
				            NULL,							     //unsigned char *ObjUuid
                            RPC_LOCAL_PROTOCOL,				    //unsigned char *ProtSeq
                            NULL,							   //unsigned char *NetworkAddr
                            QmLocalEp,			              //unsigned char *EndPoint
                            NULL,							 //unsigned char *Options
                            &s_pszStringBinding 			//unsigned char **StringBinding
                            );

    if (status != RPC_S_OK)
        throw exception();

    status = RpcBindingFromStringBinding(
				s_pszStringBinding,	 //unsigned char *StringBinding
                &ISE2QM_IfHandle);	//RPC_BINDING_HANDLE *Binding

    if (status != RPC_S_OK)
	{
		RpcStringFree(&s_pszStringBinding);
        throw exception();
	}

    //
    // Windows bug 608356
    // add mutual authentication with local msmq service.
    //
    status = mqrpcSetLocalRpcMutualAuth(&ISE2QM_IfHandle);

    if (status != RPC_S_OK)
    {
        mqrpcUnbindQMService( &ISE2QM_IfHandle, &s_pszStringBinding );

        ISE2QM_IfHandle = NULL ;
        s_pszStringBinding = NULL ;

        throw exception();
    }

	s_fInitialized = true;
	return;
}



BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO* pVer)
/*++
Routine Description:
    This function is called only once when the DLL is loaded into memory
--*/
{
	//
	// Create the extension version string.
	//
	pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

	//
	// Copy description string into HSE_VERSION_INFO structure.
	//
	const char xDescription[] = "MSMQ ISAPI extension";
	C_ASSERT(HSE_MAX_EXT_DLL_NAME_LEN > STRLEN(xDescription));

	strcpy(pVer->lpszExtensionDesc, xDescription);

	try
	{
		InitRPC();
		return TRUE;
	}
	catch(const exception&)
	{
		return FALSE;
	}
}



BOOL WINAPI TerminateExtension(DWORD /*dwFlags*/ )
{
	if(!s_fInitialized)
		return TRUE;

    RpcStringFree(&s_pszStringBinding);
    RpcBindingFree(&ISE2QM_IfHandle);

    return TRUE;
}



static
void
GetHTTPBody(
    EXTENSION_CONTROL_BLOCK *pECB,
	CPreAllocatedResizeBuffer<BYTE>& Buffer
    )
/*++
Routine Description:
    Builds message body buffer.

	Normally, message bodies smaller than 64KB are allready pointed to by
	the pECB. Bigger Message bodies need to be read from the IIS chunk by
	chunk into a buffer allocated here.

Arguments:
	
Returned Value:

--*/
{
	//
	// Copy body from pECB structure to Buffer
	//

	Buffer.append(pECB->lpbData, pECB->cbAvailable);

	const DWORD xHTTPBodySizeMaxValue = 10485760;  // 10MB = 10 * 1024 * 1024
	if(pECB->cbTotalBytes > xHTTPBodySizeMaxValue)
	{
		//
		// Requested HTTPBody is greater than the maximum allowed 10MB
		//
		TrERROR(mqise, "Requested HTTP Body %d is greater than the maximum buffer allowed %d", pECB->cbTotalBytes, xHTTPBodySizeMaxValue);
		throw exception("Requested HTTP Body is greater than xHTTPBodySizeMaxValue");
	}

	//
	// If there is more data to be read go on reading it from IIS server.
	//
	for(;Buffer.size() < pECB->cbTotalBytes;)
	{
		DWORD RemainsToRead = static_cast<DWORD>(pECB->cbTotalBytes - Buffer.size());
		DWORD ReadSize = min(RemainsToRead, 16384);

		if(ReadSize > Buffer.capacity() - Buffer.size())
		{
			//
			// Need to grow buffer to make space for next read.
			// Max grow buffer is xHTTPBodySizeMaxValue (10MB)
			//
			DWORD ReserveSize = min(numeric_cast<DWORD>(Buffer.capacity() * 2 + ReadSize), xHTTPBodySizeMaxValue);
			Buffer.reserve(ReserveSize);
			ASSERT(Buffer.capacity() - Buffer.size() >= ReadSize);
		}

		//
		// Read another message body chunk. usually ~2KB long
		// NOTE: IIS timeouts after 60 sec. For information, refer to:
		// mk:@MSITStore:\\hai-dds-01\msdn\MSDN\IISRef.chm::/asp/isre235g.htm
		//
		if(!pECB->ReadClient(pECB->ConnID, (LPVOID)Buffer.end(), &ReadSize))
		{
			throw exception("ReadClient() failed, in GetBody()");
		}

		//
		// ReadSize now holds number of bytes actually read.
		//
		Buffer.resize(Buffer.size() + ReadSize);
		ASSERT(Buffer.size() <= xHTTPBodySizeMaxValue);
	}

	//
	// Pad last four bytes of the buffer with zero. It is needed
	// for the QM parsing not to fail. four bytes padding and not two
	// are needed because we don't have currently solution to the problem
	// that the end of the buffer might be not alligned on WCHAR bouderies.
	//

	const BYTE xPadding[4] = {0, 0, 0, 0};

	Buffer.append(xPadding, sizeof(xPadding));

	return;
}




static
void
AppendVariable(
	EXTENSION_CONTROL_BLOCK* pECB,
	const char* VariableName,
	CPreAllocatedResizeBuffer<char>& Buffer
	)
{
	LPVOID pBuffer = Buffer.begin() + Buffer.size();
	DWORD BufferSize = numeric_cast<DWORD>(Buffer.capacity() - Buffer.size());

	BOOL fResult = pECB->GetServerVariable(
							pECB->ConnID,
							(LPSTR) VariableName,
							pBuffer,
							&BufferSize
							);
	if(fResult)
	{
		Buffer.resize(Buffer.size() + BufferSize - 1);
		return;
	}

	if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		throw exception("GetServerVariable() failed, in AppendVariable()");
	}
	
	Buffer.reserve(Buffer.capacity() * 2);
	AppendVariable(pECB, VariableName, Buffer);
}



static
void
GetHTTPHeader(
	EXTENSION_CONTROL_BLOCK* pECB,
	CPreAllocatedResizeBuffer<char>& Buffer
	)
{
	UtlSprintfAppend(&Buffer, "%s ", pECB->lpszMethod);
	AppendVariable(pECB, "URL", Buffer);
	UtlSprintfAppend(&Buffer, " HTTP/1.1\r\n");
	AppendVariable(pECB, "ALL_RAW", Buffer);
	UtlSprintfAppend(&Buffer, "\r\n");
}



BOOL SendResponse(EXTENSION_CONTROL_BLOCK* pECB, LPCSTR szStatus, BOOL fKeepConn)
{
	//
	//  Populate SendHeaderExInfo struct
	//

	HSE_SEND_HEADER_EX_INFO  SendHeaderExInfo;

	LPCSTR szHeader = "Content-Length: 0\r\n\r\n";

	SendHeaderExInfo.pszStatus = szStatus;
	SendHeaderExInfo.cchStatus = strlen(szStatus);
	SendHeaderExInfo.pszHeader = szHeader;
	SendHeaderExInfo.cchHeader = strlen(szHeader);
	SendHeaderExInfo.fKeepConn = fKeepConn;

	return pECB->ServerSupportFunction(
					pECB->ConnID,						    //HCONN ConnID
					HSE_REQ_SEND_RESPONSE_HEADER_EX,	   //DWORD dwHSERRequest
					&SendHeaderExInfo,					  //LPVOID lpvBuffer
					NULL,								 //LPDWORD lpdwSize
					NULL);								//LPDWORD lpdwDataType
}



static LPSTR RPCToServer(LPCSTR Headers, size_t BufferSize, PBYTE Buffer)
{
	DWORD BSize = static_cast<DWORD>(BufferSize);

	__try
	{
		return R_ProcessHTTPRequest(Headers, BSize, Buffer);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
//		TrERROR(MQISE, "Runtime reported exception %ld", RpcExceptionCode());
		throw exception("Failed RPC in RPCToServer()");
	}
}


static
void
GetPhysicalDirectoryName(
	EXTENSION_CONTROL_BLOCK* pECB,
	LPSTR pPhysicalDirectoryName,
	DWORD BufferLen
	)
/*++
Routine Description:
	Get Physical Directory Name.
	In case of failure throw bad_win32_error.

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK
	pPhysicalDirectoryName - PhysicalDirectory buffer to be filled
	BufferLen - PhysicalDirectory buffer length

Returned Value:
	Physical Directory Name unicode string

--*/
{
	//
	// ISSUE-2001/05/23-ilanh
	// using APPL_PHYSICAL_PATH is expensive compare to APPL_MD_PATH.
	//
	// Get Physical Directory Name (ansi)
	//
    DWORD dwBufLen = BufferLen;
    BOOL fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"APPL_PHYSICAL_PATH",
						pPhysicalDirectoryName,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(mqise, "GetServerVariable(APPL_PHYSICAL_PATH) failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
	}

	ASSERT(dwBufLen <= BufferLen);

	TrTRACE(mqise, "APPL_PHYSICAL_PATH = %hs", pPhysicalDirectoryName);
}


static
bool
IsHttps(
	EXTENSION_CONTROL_BLOCK* pECB
	)
/*++
Routine Description:
	Check if the request arrived from https port or http port.

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK

Returned Value:
	true if https port, false otherwise

--*/
{
	char Answer[100];
    DWORD dwBufLen = 100;
    BOOL fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"HTTPS",
						Answer,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(mqise, "GetServerVariable(HTTPS) failed, gle = 0x%x", gle);
		return false;
	}

	ASSERT(dwBufLen <= 100);

	if(_stricmp(Answer, "on") == 0)
	{
		TrTRACE(mqise, "https request");
		return true;
	}

	TrTRACE(mqise, "http request");
	return false;
}


static
void
TraceAuthInfo(
	EXTENSION_CONTROL_BLOCK* pECB
	)
/*++
Routine Description:
	Trace authentication information.
	AUTH_TYPE, AUTH_USER

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK

Returned Value:
	None

--*/
{
	char AuthType[100];
    DWORD dwBufLen = 100;
    BOOL fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"AUTH_TYPE",
						AuthType,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(mqise, "GetServerVariable(AUTH_TYPE) failed, gle = 0x%x", gle);
		return;
	}

	ASSERT(dwBufLen <= 100);

	char AuthUser[100];
    dwBufLen = 100;
    fSuccess = pECB->GetServerVariable(
						pECB->ConnID,
						"AUTH_USER",
						AuthUser,
						&dwBufLen
						);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(mqise, "GetServerVariable(AUTH_USER) failed, gle = 0x%x", gle);
		return;
	}

	ASSERT(dwBufLen <= 100);

	TrTRACE(mqise, "AUTH_USER = %hs, AUTH_TYPE = %hs", AuthUser, AuthType);
}


static
void
GetDirectorySecurityDescriptor(
	LPSTR DirectoryName,
	CAutoLocalFreePtr& pSD
	)
/*++
Routine Description:
	Get the security descriptor for the directory.
	In case of failure throw bad_win32_error.

Arguments:
	DirectoryName - Directoy name
	pSD - [out] auto free pointer to the security descriptor
Returned Value:
	None

--*/
{
    PACL pDacl = NULL;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;

    SECURITY_INFORMATION  SeInfo = OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION;

    //
    // Obtain owner and present DACL.
    //
    DWORD rc = GetNamedSecurityInfoA(
						DirectoryName,
						SE_FILE_OBJECT,
						SeInfo,
						&pOwnerSid,
						&pGroupSid,
						&pDacl,
						NULL,
						reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pSD)
						);

    if (rc != ERROR_SUCCESS)
    {
		TrERROR(mqise, "GetNamedSecurityInfo failed, rc = 0x%x", rc);
		throw bad_win32_error(rc);
    }

	ASSERT((pSD != NULL) && IsValidSecurityDescriptor(pSD));
	ASSERT((pOwnerSid != NULL) && IsValidSid(pOwnerSid));
	ASSERT((pGroupSid != NULL) && IsValidSid(pGroupSid));
	ASSERT((pDacl != NULL) && IsValidAcl(pDacl));
}


static
void
GetThreadToken(
	CHandle& hAccessToken
	)
/*++
Routine Description:
	Get thread token.
	In case of failure throw bad_win32_error.

Arguments:
	hAccessToken - auto close handle

Returned Value:
	None

--*/
{
   if (!OpenThreadToken(
			GetCurrentThread(),
			TOKEN_QUERY,
			TRUE,  // OpenAsSelf
			&hAccessToken
			))
    {
		DWORD gle = GetLastError();
		TrERROR(mqise, "OpenThreadToken failed, gle = 0x%x", gle);
		throw bad_win32_error(gle);
    }
}


static GENERIC_MAPPING s_FileGenericMapping = {
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};

static
void
VerifyWritePermission(
    PSECURITY_DESCRIPTOR pSD,
	HANDLE hAccessToken
	)
/*++
Routine Description:
	Verify if the thread has write file permissions.
	In case of failure or access denied throw bad_win32_error.

Arguments:
	pSD - PSECURITY_DESCRIPTOR
	hAccessToken - Thread Access Token

Returned Value:
	None

--*/
{
	//
	// Access Check for Write File
	//
    DWORD dwDesiredAccess = ACTRL_FILE_WRITE;
    DWORD dwGrantedAccess = 0;
    BOOL  fAccessStatus = FALSE;

    char ps_buff[sizeof(PRIVILEGE_SET) + ((2 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))];
    PPRIVILEGE_SET ps = reinterpret_cast<PPRIVILEGE_SET>(ps_buff);
    DWORD dwPrivilegeSetLength = sizeof(ps_buff);

    BOOL fSuccess = AccessCheck(
							pSD,
							hAccessToken,
							dwDesiredAccess,
							&s_FileGenericMapping,
							ps,
							&dwPrivilegeSetLength,
							&dwGrantedAccess,
							&fAccessStatus
							);

	if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(mqise, "AccessCheck failed, gle = 0x%x, status = %d", gle, fAccessStatus);
		throw bad_win32_error(gle);
	}

	if(!AreAllAccessesGranted(dwGrantedAccess, dwDesiredAccess))
	{
		TrERROR(mqise, "Access was denied, desired access = 0x%x, grant access = 0x%x", dwDesiredAccess, dwGrantedAccess);
		throw bad_win32_error(ERROR_ACCESS_DENIED);
	}
}


static
void
CheckAccessAllowed(
	EXTENSION_CONTROL_BLOCK* pECB
	)
/*++
Routine Description:
	Check if the thread user has write file permission to the
	Physical Directory.
	normal termination means the user have permissions.
	In case of failure or access denied throw bad_win32_error.

Arguments:
	pECB - EXTENSION_CONTROL_BLOCK

Returned Value:
	None

--*/
{
	if(WPP_LEVEL_COMPID_ENABLED(rsTrace, mqise))
	{
		WCHAR  UserName[1000];
		DWORD size = 1000;
		GetUserName(UserName,  &size);
		TrTRACE(mqise, "the user for the currect request = %ls", UserName);
		TraceAuthInfo(pECB);
	}

	char pPhysicalDirectoryName[MAX_PATH];
	GetPhysicalDirectoryName(pECB, pPhysicalDirectoryName, MAX_PATH);

	//
	// ISSUE-2001/05/22-ilanh reading the Security Descriptor everytime
	// Should consider cache it for Physical Directory name and refresh it from time to time
	// or when getting notifications of Physical Directory changes.
	//
	CAutoLocalFreePtr pSD;
	GetDirectorySecurityDescriptor(pPhysicalDirectoryName, pSD);

	//
	// Get access Token
	//
	CHandle hAccessToken;
	GetThreadToken(hAccessToken);

	VerifyWritePermission(pSD, hAccessToken);
}

	
DWORD WINAPI HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB)
/*++
Routine Description:
    Main extension routine.

Arguments:
    Control block generated by IIS.

Returned Value:

--*/
{

	if(IsHttps(pECB))
	{
		try
		{
			//
			// For https perform access check on the physical directory.
			//
			CheckAccessAllowed(pECB);
			TrTRACE(mqise, "Access granted");
		}
		catch (const bad_win32_error& e)
		{
			if(WPP_LEVEL_COMPID_ENABLED(rsError, mqise))
			{
				WCHAR  UserName[1000];
				DWORD size = 1000;
				GetUserName(UserName,  &size);
				TrERROR(mqise, "user = %ls denied access, bad_win32_error exception, error = 0x%x", UserName, e.error());
			}

			if(!SendResponse(pECB, HTTP_STATUS_DENIED_STR, FALSE))
				return HSE_STATUS_ERROR;

			return HSE_STATUS_SUCCESS;
		}
	}

	try
	{
		CStaticResizeBuffer<char, 2048> Headers;
		GetHTTPHeader(pECB, *Headers.get());

		CStaticResizeBuffer<BYTE, 8096> Buffer;
		GetHTTPBody(pECB, *Buffer.get());

		TrTRACE(mqise, "HTTP Body size = %d", numeric_cast<DWORD>(Buffer.size()));

		AP<char> Status = RPCToServer(Headers.begin(), Buffer.size(), Buffer.begin());

		BOOL fKeepConnection = atoi(Status) < 500 ? TRUE : FALSE;

		if(!SendResponse(pECB, Status, fKeepConnection))
			return HSE_STATUS_ERROR;
	}
	catch(const exception&)
	{
		if(!SendResponse(pECB, HTTP_STATUS_SERVER_ERROR_STR, FALSE))
			return HSE_STATUS_ERROR;
	}

	return HSE_STATUS_SUCCESS;
}


BOOL WINAPI DllMain(HMODULE /*hMod*/, DWORD Reason, LPVOID /*pReserved*/)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return TRUE;
}


//
//-------------- MIDL allocate and free implementations ----------------
//


extern "C" void __RPC_FAR* __RPC_USER midl_user_allocate(size_t len)
{
	#pragma PUSH_NEW
	#undef new

	return new_nothrow char[len];

	#pragma POP_NEW
}



extern "C" void __RPC_USER midl_user_free(void __RPC_FAR* ptr)
{
    delete [] ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqise\test\rpcserver.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    RPCServer.cpp

Abstract:
    MSMQ ISAPI extension Server

	Acts as an RPC server for the MSMQ ISAPI extension.
	You can use it for debugging, instead of the QM RPC server.
	It dumps all request forwarded by the extension, to the console.

	Simply execute it.

Author:
    Nir Aides (niraides) 03-May-2000

--*/



#include "stdh.h"

#include "ise2qm.h"
#include <new>
#include <_mqini.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

#include "_registr.h"
#include "_mqrpc.h"


 
LPCSTR HTTP_STATUS_OK_STR = "200 OK";



LPSTR R_ProcessHTTPRequest( 
    /* [in] */ LPCSTR Headers,
    DWORD BufferSize,
    /* [size_is][in] */ BYTE __RPC_FAR Buffer[  ])
{
	printf("<HEADERS>%s</HEADERS>\n",Headers);
	printf("<BUFFER_SIZE>%d</BUFFER_SIZE>", BufferSize);
	printf("<BUFFER>%.*s</BUFFER>", BufferSize, (char*)Buffer);

	LPSTR Status = (char*)midl_user_allocate(strlen(HTTP_STATUS_OK_STR) + 1);
	if(Status == NULL)
	{
		printf("R_ProcessHTTPRequest() Failed memory allocation.\n",Headers);
		throw std::bad_alloc();
	}

	strcpy(Status, HTTP_STATUS_OK_STR);

	return Status;
}



INT __cdecl main()
{
    RPC_STATUS status = RPC_S_OK;

    unsigned int cMinCalls = 1;
    unsigned int cMaxCalls = 20;
    unsigned int fDontWait = FALSE;
 
    AP<WCHAR> QmLocalEp;
    READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);
    ComposeLocalEndPoint(wzEndpoint, &QmLocalEp);

    status = RpcServerUseProtseqEp(
				RPC_LOCAL_PROTOCOL,		   //unsigned char *Protseq
                cMaxCalls,				  //unsigned int MaxCalls
                QmLocalEp,				 //unsigned char *Endpoint
                NULL);					//void *SecurityDescriptor
 
    if(status != RPC_S_OK) 
    {
        return status;
    }
 
    status = RpcServerRegisterIf2(
				ISE2QM_v1_0_s_ifspec,		      //RPC_IF_HANDLE IfSpec 
                NULL,							     //UUID *MgrTypeUuid   
                NULL,							    //RPC_MGR_EPV *MgrEpv 
				0,								   //unsigned int Flags
				RPC_C_PROTSEQ_MAX_REQS_DEFAULT,	  //unsigned int MaxCalls
				-1,								 //unsigned int MaxRpcSize
				NULL							//RPC_IF_CALLBACK_FN *IfCallbackFn
				);
 
    if(status != RPC_S_OK) 
    {
        return status;
    }
 
    status = RpcServerListen(
				cMinCalls,	  //unsigned int MinimumCallThreads
				cMaxCalls,	 //unsigned int MaxCalls
                fDontWait);	//unsigned int DontWait
 
    if(status != RPC_S_OK) 
    {
        return status;
    }
 
   status = RpcMgmtStopServerListening(NULL);
 
    if (status != RPC_S_OK) 
    {
       exit(status);
    }
 
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
 
    if (status != RPC_S_OK) 
    {
       exit(status);
    }

	return RPC_S_OK;
}
 


//
//-------------- MIDL allocate and free implementations ----------------
//

void __RPC_FAR* __RPC_USER midl_user_allocate(size_t len)
{
    return malloc(len);
}
 


void __RPC_USER midl_user_free(void __RPC_FAR* ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\perfcomn.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    perfcomn.cpp

Abstract:

    Defines common functions between the performance DLL and the performance application.

Prototype : perfctr.h

Author:

    Gadi Ittah (t-gadii)

--*/


#include "stdh.h"
#include <winperf.h>
#include "perfctr.h"
#include <align.h>




/*====================================================

MapObjects 

Description :Maps objects on to shared memory.
			 The functions updateds the objects postion in the pObjectDefs array

Arguments:
		   BYTE * pSharedMemBase 		 - pointer to start of shared memory 	   
		   DWORD dwObjectCount 	 		 - number of objects
		   PerfObjectDef * pObjects 	 - pointer to object array
		   PerfObjectInfo * pObjectDefs) - pointer to object defeinitions array

Return Value: void

=====================================================*/

void MapObjects (BYTE * pSharedMemBase,DWORD dwObjectCount,PerfObjectDef * pObjects,PerfObjectInfo * pObjectDefs)
{
	DWORD dwMemSize = 0;	

	for (unsigned i=0;i<dwObjectCount;i++)
	{
		//
        // Align object on pointer boundaries to avoid alignment faults.
        //
        pSharedMemBase = (BYTE*)ROUND_UP_POINTER(pSharedMemBase + dwMemSize, ALIGN_LPVOID);

		pObjectDefs[i].pSharedMem = pSharedMemBase;
		pObjectDefs[i].dwNumOfInstances =0;

		// calc postion of next object
		dwMemSize = pObjects[i].dwMaxInstances*INSTANCE_SIZE(pObjects[i].dwNumOfCounters)+OBJECT_DEFINITION_SIZE(pObjects[i].dwNumOfCounters);

		// if this object dosn't have instances then it has a counter block
		if (pObjects[i].dwMaxInstances == 0)
			dwMemSize += COUNTER_BLOCK_SIZE(pObjects[i].dwNumOfCounters);		
	
	}
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility


Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\perfutil.cpp ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.


Revision History:

--*/
//
//  include files
//
#include "stdh.h"
#include <string.h>
#include <winperf.h>
#include "perfutil.h"



#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

extern	LPTSTR pszPerfApp;

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events

                              // initialized in Open... routines

DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string
    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted
    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimiter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\perfexpr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name     :perfexpr.c



Abstract        :Defines the DLL's exportable functions. These functions are called by the registery when the
             performance moniter requests.



Prototype       :

Author:

    Gadi Ittah (t-gadii)

--*/


//
//  Include Files
//


#include "stdh.h"
#include <string.h>
#include <winperf.h>
#include "perfutil.h"
#include "perfdata.h"
typedef LONG HRESULT;
#include "_registr.h"


// The follwoing global variables must be setup in this header file
PerfObjectDef * pObjects        = ObjectArray;  // A pointer to the objects array
WCHAR g_szPerfApp[128];
                                            // written in the registery


PerfObjectInfo * pObjectDefs = NULL;
HANDLE hSharedMem;
BYTE * pSharedMemBase;
BOOL   fInitOK = FALSE;

DWORD dwOpenCount;
#define DECL_C extern "C"

/*====================================================

PerfOpen

Routine Description:

    This routine will open and map the memory used by the application to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (the application)

Return Value:

    None.

=====================================================*/

DECL_C DWORD APIENTRY
    PerfOpen(
    LPWSTR
    )

/*++


--*/

{
    LONG status;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {

        pObjectDefs = new PerfObjectInfo [dwPerfObjectsCount];

        hSharedMem = OpenFileMapping(FILE_MAP_READ,FALSE, L"Global\\MSMQ");


    if (hSharedMem == NULL)
    {
        //
        // Bug Bug Error should be written to event log
        //

        // this is fatal, if we can't get data then there's no
        // point in continuing.
        status = GetLastError(); // return error
        goto OpenExitPoint;
    }


        //
        // Map the shared memory
        //
        pSharedMemBase = (PBYTE)MapViewOfFile(hSharedMem,FILE_MAP_READ,0,0,0);

        if (!pSharedMemBase)
    {
        //
        // Bug Bug Error should be written to event log
        //


        // this is fatal, if we can't get data then there's no
        // point in continuing.
        status = GetLastError(); // return error
        goto OpenExitPoint;
    }

        MapObjects (pSharedMemBase,dwPerfObjectsCount,pObjects,pObjectDefs);

    fInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}



/*====================================================



Description :helper function for copying an object to the performance monitors buuffer


Arguments       :
                IN      PPERF_OBJECT_TYPE pPerfObject - Pointer to object to copy
                IN OUT  PVOID & pDestBuffer     - Pointer to destination buffer returns the address of
                                              the destination for the next object to place in buffer.
                IN      long maxInstances       - The maximum number of instances the object has

Return Value:

=====================================================*/



DWORD CopyObjectToBuffer (IN PPERF_OBJECT_TYPE pPerfObject,IN OUT PVOID & pDestBuffer,IN long maxInstances,IN DWORD dwSpaceLeft)
{
    //
    // if GetCounters hasn't been called for the object then it isn't valid yet
    //

    if (pPerfObject->TotalByteLength == PERF_INVALID)
      return 0;

    PVOID pSourceBuffer;

    PPERF_OBJECT_TYPE pDestObject = (PPERF_OBJECT_TYPE)pDestBuffer;

    pSourceBuffer = (PVOID)pPerfObject;

    DWORD dwBytesToCopy = OBJECT_DEFINITION_SIZE(pPerfObject->NumCounters);

    if(dwSpaceLeft<dwBytesToCopy)
    {
        return (DWORD)-1;
    }

    dwSpaceLeft-=dwBytesToCopy;

    //
    // copy object defeinitions
    //
    memcpy (pDestBuffer,pSourceBuffer,dwBytesToCopy);
    pDestObject->TotalByteLength =dwBytesToCopy;

    pDestObject->NumInstances = 0;

    pSourceBuffer = (BYTE *) pSourceBuffer+dwBytesToCopy;
    pDestBuffer=(BYTE *)pDestBuffer+dwBytesToCopy;

    //
    //check all of objects possibale insatances and copy the valid ones to the dest buffer
    //

    for (LONG j=0;j<maxInstances;j++)
    {

        dwBytesToCopy = INSTANCE_SIZE(pPerfObject->NumCounters);

        //
        // We copy each instance that is valid
        //

        if (*(DWORD*)pSourceBuffer == PERF_VALID)
        {

            if(dwSpaceLeft<dwBytesToCopy)
            return (DWORD)-1;
            dwSpaceLeft-=dwBytesToCopy;

            memcpy(pDestBuffer,pSourceBuffer,dwBytesToCopy);

            ((PPERF_INSTANCE_DEFINITION)pDestBuffer)->ByteLength = INSTANCE_NAME_LEN_IN_BYTES+sizeof(PERF_INSTANCE_DEFINITION);
            pDestBuffer=(BYTE*)pDestBuffer+dwBytesToCopy;
            pDestObject->NumInstances++;
            pDestObject->TotalByteLength +=dwBytesToCopy;
        }
        pSourceBuffer=(BYTE*)pSourceBuffer+dwBytesToCopy;
    }


    if (pDestObject->NumInstances == 0)
    {

        //
        // If the object has no instances the standart is top place -1 in the NumIstances field
        //
        pDestObject->NumInstances = -1;


        //
        // if there are no instances we just follow the object with a PERF_COUNTER_BLOCK
        // and the data for the counters
        //

        dwBytesToCopy = COUNTER_BLOCK_SIZE(pPerfObject->NumCounters);

        if(dwSpaceLeft<dwBytesToCopy)
        {
            return (DWORD)-1;
        }

        dwSpaceLeft-=dwBytesToCopy;

        memcpy(pDestBuffer,pSourceBuffer,dwBytesToCopy);

        pDestBuffer     =(BYTE*)pDestBuffer+dwBytesToCopy;
        pSourceBuffer   =(BYTE*)pSourceBuffer+dwBytesToCopy;
        pDestObject->TotalByteLength +=dwBytesToCopy;
    }

	DWORD Padding = ROUND_UP_COUNT(pDestObject->TotalByteLength, ALIGN_QUAD) - pDestObject->TotalByteLength; 

	if(dwSpaceLeft < Padding)
		return (DWORD)-1;

	dwSpaceLeft -= Padding;
	pDestBuffer = (BYTE*)pDestBuffer + Padding;
	pDestObject->TotalByteLength += Padding;

    return pDestObject->TotalByteLength;
}



/*++

Routine Description:

    This routine will return the data for the counters.

Arguments:

   IN       LPWSTR   lpValueName
     pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
     IN: pointer to the address of the buffer to receive the completed
        PerfDataBlock and subordinate structures. This routine will
        append its data to the buffer starting at the point referenced
        by *lppData.
     OUT: points to the first byte after the data structure added by this
        routine. This routine updated the value at lppdata after appending
        its data.

   IN OUT   LPDWORD  lpcbTotalBytes
     IN: the address of the DWORD that tells the size in bytes of the
        buffer referenced by the lppData argument
     OUT: the number of bytes added by this routine is written to the
        DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
     IN: the address of the DWORD to receive the number of objects added
        by this routine
     OUT: the number of objects added by this routine is written to the
        DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
     any error conditions encountered are reported to the event log if
     event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
     also reported to the event log.
--*/


DECL_C DWORD APIENTRY
    PerfCollect(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)

{

    PVOID   pDestBuffer;// pointer used when copying the data structers to the buffer
    DWORD   i                  ;// loop control variable
    //
    // before doing anything else, see if data is valid Open went OK
    //
    if (!fInitOK)
    {
        //
        // unable to continue because open failed.
        //
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //

    DWORD dwQueryType;

    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        //
        // this routine does not service requests for data from
        // Non-NT computers
        //
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }


    DWORD dwSpaceNeeded = 0;

    //
    // Session and DS perf objects are not always mapped
    //
    DWORD dwMappedObjects = 0;

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    pDestBuffer = *lppData;


    if ((dwQueryType == QUERY_GLOBAL) || (dwQueryType == QUERY_COSTLY))
    {
    DWORD dwSpaceLeft = *lpcbTotalBytes;

    for (i=0;i<dwPerfObjectsCount;i++)
        {
            PPERF_OBJECT_TYPE pPerfObject = (PPERF_OBJECT_TYPE) pObjectDefs[i].pSharedMem;

        DWORD retVal = CopyObjectToBuffer (pPerfObject,pDestBuffer,pObjects[i].dwMaxInstances,dwSpaceLeft);

        if (retVal == (DWORD)-1)
        {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        if (retVal != 0)
        {
            //
            // Session and DS perf objects are not always mapped
            //
            ++dwMappedObjects;
        }

        dwSpaceNeeded+=retVal;
        dwSpaceLeft-=retVal;

        if ( *lpcbTotalBytes < dwSpaceNeeded )
        {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
            }
        }
    }


    if (dwQueryType == QUERY_ITEMS)
    {

        DWORD dwSpaceLeft = *lpcbTotalBytes;

        BOOL fAtLeastOne = FALSE;// a flag set to true if at least one of the objects requested
                                 // belongs to the application
        PPERF_OBJECT_TYPE pPerfObject;

        for (i=0;i<dwPerfObjectsCount;i++)
        {
            pPerfObject = (PPERF_OBJECT_TYPE) pObjectDefs[i].pSharedMem;

            if (IsNumberInUnicodeList (pPerfObject->ObjectNameTitleIndex, lpValueName))
            {
                fAtLeastOne = TRUE;

                DWORD retVal = CopyObjectToBuffer (pPerfObject,pDestBuffer,pObjects[i].dwMaxInstances,dwSpaceLeft);

                if (retVal == (DWORD)-1)
                {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    return ERROR_MORE_DATA;
                }

                if (retVal != 0)
                {
                    //
                    // Session and DS perf objects are not always mapped
                    //
                    ++dwMappedObjects;
                }

                dwSpaceNeeded+=retVal;
                dwSpaceLeft-=retVal;

                if ( *lpcbTotalBytes < dwSpaceNeeded )
                {
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    return ERROR_MORE_DATA;
                }
            }
        }

        if (!fAtLeastOne)
        {
            // request received for data object not provided by this application
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }


    // update arguments for return

    *lpcbTotalBytes = DWORD_PTR_TO_DWORD((PBYTE) pDestBuffer - (PBYTE) *lppData);

    *lppData = pDestBuffer;


    *lpNumObjectTypes = dwMappedObjects;




    return ERROR_SUCCESS;
}




/*++

Routine Description:

    This routine closes the open handles to the performance counters

Arguments:

    None.

Return Value:
    ERROR_SUCCESS

--*/

DECL_C DWORD APIENTRY PerfClose()


{
    if (!(--dwOpenCount)) { // when this is the last thread...

        UnmapViewOfFile (pSharedMemBase);
    CloseHandle(hSharedMem);


        delete pObjectDefs;
        pObjectDefs = NULL;

    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:
    precompiled header for msmq performance library

Author:
    Gadi Ittac (t-gadii) 27-Jun-96

--*/

#ifndef __STDH_H__
#define __STDH_H__


#include <_stdh.h>

#endif // __STDH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\perfdata.cpp ===
//*********************************************************************
//*
//* perfdata.cpp
//*
//*********************************************************************


#include "stdh.h"
#include "perfdata.h"
#include "qmperf.h"

//
// QM General Counters
//
PerfCounterDef QMCountersArray[] =
{
    {NUMSESSIONS,				NUMSESSIONS,				0, PERF_COUNTER_RAWCOUNT},
    {NUMIPSESSIONS,				NUMIPSESSIONS,				0, PERF_COUNTER_RAWCOUNT},
	{NUM_OUTGOING_HTTP_SESSIONS,NUM_OUTGOING_HTTP_SESSIONS, 0, PERF_COUNTER_RAWCOUNT},
	{NUM_INCOMING_PGM_SESSIONS, NUM_INCOMING_PGM_SESSIONS,	0, PERF_COUNTER_RAWCOUNT},
	{NUM_OUTGOING_PGM_SESSIONS, NUM_OUTGOING_PGM_SESSIONS,	0, PERF_COUNTER_RAWCOUNT},

    {NUMINQMPACKETS,       NUMINQMPACKETS      ,0,PERF_COUNTER_COUNTER},
    {TOTALINQMPACKETS,     TOTALINQMPACKETS    ,0,PERF_COUNTER_RAWCOUNT},
    {NUMOUTQMPACKETS,      NUMOUTQMPACKETS     ,0,PERF_COUNTER_COUNTER},
    {TOTALOUTQMPACKETS,    TOTALOUTQMPACKETS   ,0,PERF_COUNTER_RAWCOUNT},

    {TOTALPACKETSINQUEUES, TOTALPACKETSINQUEUES, (DWORD)-2, PERF_COUNTER_RAWCOUNT},
    {TOTALBYTESINQUEUES,   TOTALBYTESINQUEUES  , (DWORD)-4, PERF_COUNTER_RAWCOUNT}
};


//
// Counters per active sessions
//
PerfCounterDef  SessionCountersArray[] =
{
    {NUMSESSINPACKETS,      NUMSESSINPACKETS,   0,  PERF_COUNTER_COUNTER},
    {NUMSESSOUTPACKETS,     NUMSESSOUTPACKETS,  0,  PERF_COUNTER_COUNTER},
    {NUMSESSINBYTES,        NUMSESSINBYTES,     0,  PERF_COUNTER_COUNTER},
    {NUMSESSOUTBYTES,       NUMSESSOUTBYTES,    0,  PERF_COUNTER_COUNTER},
    {TOTALSESSINPACKETS,    TOTALSESSINPACKETS, 0,  PERF_COUNTER_RAWCOUNT},
    {TOTALSESSOUTPACKETS,   TOTALSESSOUTPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {TOTALSESSINBYTES,      TOTALSESSINBYTES,   0,  PERF_COUNTER_RAWCOUNT},
    {TOTALSESSOUTBYTES,     TOTALSESSOUTBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};


//
// Counters per active sessions
//
PerfCounterDef  InHttpCountersArray[] =
{
    {IN_HTTP_NUMSESSINPACKETS,      IN_HTTP_NUMSESSINPACKETS,   0,  PERF_COUNTER_COUNTER},
    {IN_HTTP_NUMSESSINBYTES,        IN_HTTP_NUMSESSINBYTES,     0,  PERF_COUNTER_COUNTER},
    {IN_HTTP_TOTALSESSINPACKETS,    IN_HTTP_TOTALSESSINPACKETS, 0,  PERF_COUNTER_RAWCOUNT},
    {IN_HTTP_TOTALSESSINBYTES,      IN_HTTP_TOTALSESSINBYTES,   0,  PERF_COUNTER_RAWCOUNT},
};


//
// Counters per active Outgoing HTTP sessions
//
PerfCounterDef  OutHttpSessionCountersArray[] =
{
    {OUT_HTTP_NUMSESSOUTPACKETS,     OUT_HTTP_NUMSESSOUTPACKETS,  0,  PERF_COUNTER_COUNTER},
    {OUT_HTTP_NUMSESSOUTBYTES,       OUT_HTTP_NUMSESSOUTBYTES,    0,  PERF_COUNTER_COUNTER},
    {OUT_HTTP_TOTALSESSOUTPACKETS,   OUT_HTTP_TOTALSESSOUTPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {OUT_HTTP_TOTALSESSOUTBYTES,     OUT_HTTP_TOTALSESSOUTBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};

//
// Counters per active Outgoing Multicast sessions
//
PerfCounterDef  OutPgmSessionCountersArray[] =
{
    {OUT_PGM_NUMSESSOUTPACKETS,     OUT_PGM_NUMSESSOUTPACKETS,  0,  PERF_COUNTER_COUNTER},
    {OUT_PGM_NUMSESSOUTBYTES,       OUT_PGM_NUMSESSOUTBYTES,    0,  PERF_COUNTER_COUNTER},
    {OUT_PGM_TOTALSESSOUTPACKETS,   OUT_PGM_TOTALSESSOUTPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {OUT_PGM_TOTALSESSOUTBYTES,     OUT_PGM_TOTALSESSOUTBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};


//
// Counters per active Outgoing Multicast sessions
//
PerfCounterDef  InPgmSessionCountersArray[] =
{
    {IN_PGM_NUMSESSINPACKETS,     IN_PGM_NUMSESSINPACKETS,  0,  PERF_COUNTER_COUNTER},
    {IN_PGM_NUMSESSINBYTES,       IN_PGM_NUMSESSINBYTES,    0,  PERF_COUNTER_COUNTER},
    {IN_PGM_TOTALSESSINPACKETS,   IN_PGM_TOTALSESSINPACKETS,0,  PERF_COUNTER_RAWCOUNT},
    {IN_PGM_TOTALSESSINBYTES,     IN_PGM_TOTALSESSINBYTES,  0,  PERF_COUNTER_RAWCOUNT}
};


//
// Counters per queue
//
PerfCounterDef  QueueCountersArray[] =
{
    {TOTALQUEUEINPACKETS,     TOTALQUEUEINPACKETS,     0,         PERF_COUNTER_RAWCOUNT},
    {TOTALQUEUEINBYTES,       TOTALQUEUEINBYTES,       (DWORD)-2, PERF_COUNTER_RAWCOUNT},
    {TOTALJOURNALINPACKETS,   TOTALJOURNALINPACKETS,   0,         PERF_COUNTER_RAWCOUNT},
    {TOTALJOURNALINBYTES,     TOTALJOURNALINBYTES,     (DWORD)-2, PERF_COUNTER_RAWCOUNT}
};

//
// DS Counters
//
PerfCounterDef  DSCountersArray[] =
{
    {NUMOFSYNCREQUESTS       ,NUMOFSYNCREQUESTS       ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFSYNCREPLIES        ,NUMOFSYNCREPLIES        ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFREPLREQRECV        ,NUMOFREPLREQRECV        ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFREPLREQSENT        ,NUMOFREPLREQSENT        ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFACCESSTOSRVR       ,NUMOFACCESSTOSRVR       ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFWRITEREQSENT       ,NUMOFWRITEREQSENT       ,0,  PERF_COUNTER_RAWCOUNT},
    {NUMOFERRRETURNEDTOAPP   ,NUMOFERRRETURNEDTOAPP   ,0,  PERF_COUNTER_RAWCOUNT}
};



/*Set up the object array*/
PerfObjectDef ObjectArray [] =
{
    {PERF_QM_OBJECT,				0                      ,QMOBJ,					QMOBJ,					QMCountersArray        ,sizeof (QMCountersArray)/sizeof (PerfCounterDef)},
    {PERF_QUEUE_OBJECT,				MAX_MONITORED_QUEUES   ,QUEUEOBJ,				QUEUEOBJ,				QueueCountersArray     ,sizeof (QueueCountersArray)/sizeof (PerfCounterDef)},
    {PERF_SESSION_OBJECT,			MAX_MONITORED_SESSIONS ,SESSIONOBJ,				SESSIONOBJ,				SessionCountersArray   ,sizeof (SessionCountersArray)/sizeof (PerfCounterDef)},
	{PERF_IN_HTTP_OBJECT,			0,						IN_HTTP_OBJ,            IN_HTTP_OBJ,            InHttpCountersArray,    sizeof (InHttpCountersArray)/sizeof(PerfCounterDef)},
	{PERF_OUT_HTTP_SESSION_OBJECT,	MAX_MONITORED_SESSIONS, OUT_HTTP_SESSION_OBJ,	OUT_HTTP_SESSION_OBJ,	OutHttpSessionCountersArray, sizeof (OutHttpSessionCountersArray)/sizeof (PerfCounterDef) },
	{PERF_OUT_PGM_SESSION_OBJECT,	MAX_MONITORED_SESSIONS, OUT_PGM_SESSION_OBJ,	OUT_PGM_SESSION_OBJ,	OutPgmSessionCountersArray, sizeof (OutPgmSessionCountersArray)/sizeof (PerfCounterDef) },
	{PERF_IN_PGM_SESSION_OBJECT,	MAX_MONITORED_SESSIONS, IN_PGM_SESSION_OBJ,		IN_PGM_SESSION_OBJ,		InPgmSessionCountersArray, sizeof (InPgmSessionCountersArray)/sizeof (PerfCounterDef) },
    {PERF_DS_OBJECT,				0                      ,DSOBJ,					DSOBJ,					DSCountersArray        ,sizeof (DSCountersArray)/sizeof (PerfCounterDef)}
};



DWORD dwPerfObjectsCount = sizeof(ObjectArray) / sizeof(ObjectArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqperf.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqperf\perfutil.h ===
//In the next file, PERFUTIL.H, are some useful declarations we have found handy for performance data 
//collection DLLs:
 
//__________________________________________________________________

 
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

 
    This file supports routines used to parse and create Performance Monitor Data 
    Structures. It actually supports Performance Object types with multiple instances
 

Revision History:

--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// 
//  Utility macro.  This is used to reserve a DWORD multiple of bytes for Unicode strings 
//  embedded in the definitional data, viz., object instance names. 
//
 
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
 

//    (assumes dword is 4 bytes long and pointer is a dword in size)
 
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))
 

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
 
extern WCHAR  NULL_STRING[];
 

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;




#endif  //_PERFUTIL_H_
 
//__________________________________________________________________
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\stdh_sec.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: stdh_sec.h

Abstract: Generic header file for mqsec.dll

Author: Doron Juster  (DoronJ)  03-Jun-1998

--*/

#ifndef __SEC_STDH_H
#define __SEC_STDH_H

#include <_stdh.h>
#include <rpc.h>
#include <autorel.h>

#include <wincrypt.h>

#include <mqprops.h>

#include <mqsec.h>
#include <mqcert.h>
#include <mqreport.h>
#include <mqlog.h>

//+----------------------------
//
//  Logging and debugging
//
//+----------------------------

#ifdef _DEBUG

#define DBG_SEC_SHOW_IMPERSONATED_SID  0x00000001
 //
 // Setting this bit in the DebugFlags word will retrieve the impersonated
 // sid after each call to RpcImpersonateClient().
 //

extern DWORD  g_dwMqSecDebugFlags ;

#endif


extern void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine);
extern void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgDWORD(DWORD dw, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);

inline DWORD LogDWORD(DWORD dw, PWCHAR pwszFileName, USHORT usPoint)
{
    if (dw != ERROR_SUCCESS)
    {
        LogMsgDWORD(dw, pwszFileName, usPoint);
    }
    return dw;
}

#endif // __SEC_STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\acssctrl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: acssctrl.h

Abstract:

    main header for access control code.

Author:

    Doron Juster  (DoronJ)  26-May-1998

--*/

#include <autorel.h>
#include "actempl.h"
#include "rightsg.h"
#include "..\inc\permit.h"

//
// constants.
//
#define  MQSEC_MAX_ACL_SIZE  (0x0fff0)

//
// This is the necessary mask to enable an extended right ACE.
//
#define MSMQ_EXTENDED_RIGHT_MASK  RIGHT_DS_CONTROL_ACCESS

//
// Tables to map permission righrs.
//
extern struct RIGHTSMAP  *g_psExtendRightsMap5to4[];
extern DWORD              g_pdwExtendRightsSize5to4[];
extern DWORD             *g_padwRightsMap5to4[ ];
extern DWORD              g_dwFullControlNT4[ ];
extern DWORD             *g_padwRightsMap4to5[ ];

extern GUID               g_guidCreateQueue;

//
// Well known sids and user tokens.
//
extern PSID   g_pSidOfGuest;
extern PSID   g_pWorldSid;
extern PSID   g_pAnonymSid;
extern PSID   g_pSystemSid;
extern PSID   g_pPreW2kCompatibleAccessSid;

extern BOOL   g_fDomainController;

#ifdef MQ_SUPPORT_ANONYMOUS

extern HANDLE g_hAnonymousToken;

#endif

//
// Internal functions.
//
void InitializeGenericMapping();

DWORD 
GetAccessToken( 
	OUT HANDLE *phAccessToken,
	IN  BOOL    fImpersonate,
	IN  DWORD   dwAccessType = TOKEN_QUERY,
	IN  BOOL    fThreadTokenOnly = FALSE 
	);

PGENERIC_MAPPING  GetObjectGenericMapping(DWORD dwObjectType);

HRESULT 
SetSpecificPrivilegeInAccessToken( 
	HANDLE  hAccessToken,
	LPCTSTR lpwcsPrivType,
	BOOL    bEnabled 
	);

void  
GetpSidAndObj( 
	IN  ACCESS_ALLOWED_ACE*   pAce,
	OUT PSID                 *ppSid,
	OUT BOOL                 *pfObj,
	OUT GUID                **ppguidObj = NULL 
	);

void InitializeGuestSid();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\acsschck.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: acsschck.cpp

Abstract:
    Code to checkk access permission.

Author:
    Doron Juster (DoronJ)  27-Oct-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include "mqnames.h"

#include "acsschck.tmh"

static WCHAR *s_FN=L"acssctrl/acsschck";

#define OBJECT_TYPE_NAME_MAX_LENGTH 32

//+--------------------------------------------------------------------------
//
//   HRESULT _ReplaceSidWithSystem()
//
//  Output parameteres:
//    pfReplaced- set to TRUE if a ACE was indeed replaced. Otherwise, FALSE.
//
//+--------------------------------------------------------------------------

STATIC HRESULT _ReplaceSidWithSystem(
                                IN OUT SECURITY_DESCRIPTOR  *pNewSD,
                                IN     SECURITY_DESCRIPTOR  *pOldSD,
                                IN     PSID                  pMachineSid,
                                OUT    ACL                 **ppSysDacl,
                                OUT    BOOL                 *pfReplaced )
{
    *pfReplaced = FALSE ;
    if (!g_pSystemSid)
    {
        //
        // system SID not available.
        //
        return LogHR(MQSec_E_UNKNOWN, s_FN, 10);
    }

    BOOL fReplaced = FALSE ;
    BOOL bPresent ;
    BOOL bDefaulted ;
    ACL  *pOldAcl = NULL ;

    BOOL bRet = GetSecurityDescriptorDacl( pOldSD,
                                          &bPresent,
                                          &pOldAcl,
                                          &bDefaulted ) ;
    ASSERT(bRet) ;
    if (!pOldAcl || !bPresent)
    {
        //
        // It's OK to have a security descriptor without a DACL.
        //
        return MQSec_OK ;
    }
	else if (pOldAcl->AclRevision != ACL_REVISION)
    {
        //
        // we expect to get a DACL with  NT4 format.
        //
	    ASSERT(pOldAcl->AclRevision == ACL_REVISION) ;
        return LogHR(MQSec_E_WRONG_DACL_VERSION, s_FN, 20);
    }

    //
    // size of SYSTEM acl is not longer than original acl, as the
    // length of system SID is shorter then machine account sid.
    //
    ASSERT(GetLengthSid(g_pSystemSid) <= GetLengthSid(pMachineSid)) ;

    DWORD dwAclSize = (pOldAcl)->AclSize ;
    *ppSysDacl = (PACL) new BYTE[ dwAclSize ] ;
    bRet = InitializeAcl(*ppSysDacl, dwAclSize, ACL_REVISION) ;

    DWORD dwNumberOfACEs = (DWORD) pOldAcl->AceCount ;
    for ( DWORD i = 0 ; i < dwNumberOfACEs ; i++ )
    {
        PSID pSidTmp ;
        ACCESS_ALLOWED_ACE *pAce ;

        if (GetAce(pOldAcl, i, (LPVOID* )&(pAce)) == FALSE)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while replacing SID with System SID. %!winerr!"), i, GetLastError()));
            return MQSec_E_SDCONVERT_GETACE ;
        }
        else if (EqualSid((PSID) &(pAce->SidStart), pMachineSid))
        {
            pSidTmp = g_pSystemSid ;
            fReplaced = TRUE ;
        }
        else
        {
            pSidTmp = &(pAce->SidStart) ;
        }

        if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            bRet = AddAccessAllowedAce( *ppSysDacl,
                                         ACL_REVISION,
                                         pAce->Mask,
                                         pSidTmp ) ;
        }
        else
        {
            ASSERT(pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) ;

            bRet = AddAccessDeniedAceEx( *ppSysDacl,
                                          ACL_REVISION,
                                          0,
                                          pAce->Mask,
                                          pSidTmp ) ;
        }
        ASSERT(bRet) ;
    }

    if (fReplaced)
    {
        bRet = SetSecurityDescriptorDacl( pNewSD,
                                          TRUE, // dacl present
                                          *ppSysDacl,
                                          FALSE ) ;
        ASSERT(bRet) ;
    }

    *pfReplaced = fReplaced ;
    return MQ_OK ;
}

//+---------------------------------------------------------
//
//  LPCWSTR  _GetAuditObjectTypeName(DWORD dwObjectType)
//
//+---------------------------------------------------------

static LPCWSTR _GetAuditObjectTypeName(DWORD dwObjectType)
{
    switch (dwObjectType)
    {
        case MQDS_QUEUE:
            return L"Queue";

        case MQDS_MACHINE:
            return L"msmqConfiguration";

        case MQDS_CN:
            return L"Foreign queue";

        default:
            ASSERT(0);
            return NULL;
    }
}

//+-----------------------------------
//
//  BOOL  MQSec_CanGenerateAudit()
//
//+-----------------------------------

inline BOOL operator==(const LUID& a, const LUID& b)
{
    return ((a.LowPart == b.LowPart) && (a.HighPart == b.HighPart));
}

BOOL APIENTRY  MQSec_CanGenerateAudit()
{
    static BOOL s_bInitialized = FALSE;
    static BOOL s_bCanGenerateAudits = FALSE ;

    if (s_bInitialized)
    {
        return s_bCanGenerateAudits ;
    }
    s_bInitialized = TRUE ;

    CAutoCloseHandle hProcessToken;
    //
    // Enable the SE_AUDIT privilege that allows the QM to write audits to
    // the events log.
    //
    BOOL bRet = OpenProcessToken( GetCurrentProcess(),
                                 (TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES),
                                 &hProcessToken ) ;
    if (bRet)
    {
        HRESULT hr = SetSpecificPrivilegeInAccessToken( hProcessToken,
                                                        SE_AUDIT_NAME,
                                                        TRUE ) ;
        if (SUCCEEDED(hr))
        {
            s_bCanGenerateAudits = TRUE ;
        }
    }
    else
    {
        DWORD gle = GetLastError() ;
		TrERROR(mqsec, "MQSec_CanGenerateAudit() fail to open process token, err- %!winerr!", gle);
    }

    if (s_bCanGenerateAudits)
    {
        DWORD             dwLen;
        TOKEN_PRIVILEGES *TokenPrivs;
        LUID              luidPrivilegeLUID;

        s_bCanGenerateAudits = FALSE ;

        if (LookupPrivilegeValue(NULL, SE_AUDIT_NAME, &luidPrivilegeLUID))
        {
            GetTokenInformation( hProcessToken,
                                 TokenPrivileges,
                                 NULL,
                                 0,
                                 &dwLen ) ;
            AP<char> TokenPrivs_buff = new char[dwLen];
            TokenPrivs = (TOKEN_PRIVILEGES *)(char *)TokenPrivs_buff;
            GetTokenInformation( hProcessToken,
                                 TokenPrivileges,
                                (PVOID)TokenPrivs,
                                 dwLen,
                                 &dwLen);
            for (DWORD i = 0; i < TokenPrivs->PrivilegeCount ; i++)
            {
                if (TokenPrivs->Privileges[i].Luid == luidPrivilegeLUID)
                {
                    s_bCanGenerateAudits =
                        (TokenPrivs->Privileges[i].Attributes &
                         SE_PRIVILEGE_ENABLED) != 0 ;
                    break;
                }
            }
        }
    }

    if (!s_bCanGenerateAudits)
    {
        REPORT_CATEGORY(QM_CANNOT_GENERATE_AUDITS, CATEGORY_KERNEL);
    }

    return s_bCanGenerateAudits ;
}

//+----------------------------
//
//  DWORD GetAccessToken()
//
//+----------------------------

DWORD
GetAccessToken(
	OUT HANDLE *phAccessToken,
	IN  BOOL    fImpersonate,
	IN  DWORD   dwAccessType,
	IN  BOOL    fThreadTokenOnly
	)
{
    P<CImpersonate> pImpersonate = NULL;

    if (fImpersonate)
    {
        pImpersonate = new CImpersonate(TRUE, TRUE);
        ASSERT(pImpersonate->GetImpersonationStatus() == 0);
    }

    if (!OpenThreadToken(
			GetCurrentThread(),
			dwAccessType,
			TRUE,  // OpenAsSelf, use process security context for doing access check.
			phAccessToken
			))
    {
		DWORD dwErr = GetLastError();
        if (dwErr == ERROR_NO_TOKEN)
        {
            if (fThreadTokenOnly)
            {
                //
                // We're interested only in thread token (for doing client
                // access check). If token not available then it's a failure.
                //
                *phAccessToken = NULL; // To be on the safe side.
                return LogDWORD(dwErr, s_FN, 40);
            }

            //
            // The process has only one main thread. IN this case we should
            // open the process token.
            //
            ASSERT(!fImpersonate);
            if (!OpenProcessToken(
					GetCurrentProcess(),
					dwAccessType,
					phAccessToken
					))
            {
				dwErr = GetLastError();
                *phAccessToken = NULL; // To be on the safe side.
                return LogDWORD(dwErr, s_FN, 50);
            }
        }
        else
        {
            *phAccessToken = NULL; // To be on the safe side.
            return LogDWORD(dwErr, s_FN, 60);
        }
    }

    return ERROR_SUCCESS;
}

//+------------------------------------
//
//  HRESULT  _DoAccessCheck()
//
//+------------------------------------

STATIC HRESULT  _DoAccessCheck( IN  SECURITY_DESCRIPTOR *pSD,
                                IN  DWORD                dwObjectType,
                                IN  LPCWSTR              pwszObjectName,
                                IN  DWORD                dwDesiredAccess,
                                IN  LPVOID               pId,
                                IN  HANDLE               hAccessToken )
{
    DWORD dwGrantedAccess = 0 ;
    BOOL  fAccessStatus = FALSE ;
    BOOL  fCheck = FALSE ;

	if (!MQSec_CanGenerateAudit() || !pwszObjectName)
    {
        char ps_buff[ sizeof(PRIVILEGE_SET) +
                     ((2 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES)) ] ;
        PPRIVILEGE_SET ps = (PPRIVILEGE_SET)ps_buff;
        DWORD dwPrivilegeSetLength = sizeof(ps_buff);

        fCheck = AccessCheck( pSD,
                              hAccessToken,
                              dwDesiredAccess,
                              GetObjectGenericMapping( dwObjectType ),
                              ps,
                             &dwPrivilegeSetLength,
                             &dwGrantedAccess,
                             &fAccessStatus );
    }
    else
    {
        BOOL bAuditGenerated ;
        BOOL bCreate = FALSE ;

        switch (dwObjectType)
        {
            case MQDS_QUEUE:
            case MQDS_CN:
                bCreate = FALSE;
                break;

            case MQDS_MACHINE:
                bCreate = (dwDesiredAccess & MQSEC_CREATE_QUEUE) != 0;
                break;

            default:
                ASSERT(0);
                break;
        }

        LPCWSTR pAuditSubsystemName = L"MSMQ";

        fCheck = AccessCheckAndAuditAlarm(
              pAuditSubsystemName,
              pId,
              const_cast<LPWSTR>(_GetAuditObjectTypeName(dwObjectType)),
              const_cast<LPWSTR>(pwszObjectName),
              pSD,
              dwDesiredAccess,
              GetObjectGenericMapping(dwObjectType),
              bCreate,
             &dwGrantedAccess,
             &fAccessStatus,
             &bAuditGenerated);
        ASSERT(fCheck);

        fCheck = ObjectCloseAuditAlarm(pAuditSubsystemName, pId, bAuditGenerated);
    }

    ASSERT(fCheck);
    HRESULT hr = MQSec_OK ;

    if ( fAccessStatus &&
         AreAllAccessesGranted(dwGrantedAccess, dwDesiredAccess) )
    {
        //
        // Access granted.
        //
    }
    else
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            hr = MQ_ERROR_PRIVILEGE_NOT_HELD ;
        }
        else
        {
            hr = MQ_ERROR_ACCESS_DENIED ;
        }
    }

    return LogHR(hr, s_FN, 80);
}

//+------------------------------------------------------------------------
//
//  HRESULT  MQSec_AccessCheck()
//
//  Perform access check for the runnig thread. The access token is
//  retreived from the thread token.
//
//+------------------------------------------------------------------------

HRESULT
APIENTRY
MQSec_AccessCheck(
	IN  SECURITY_DESCRIPTOR *pSD,
	IN  DWORD                dwObjectType,
	IN  LPCWSTR              pwszObjectName,
	IN  DWORD                dwDesiredAccess,
	IN  LPVOID               pId,
	IN  BOOL                 fImpAsClient,
	IN  BOOL                 fImpersonate
	)
{
    //
    // Bug 8567. AV due to NULL pSD.
    // Let's log this. At present we have no idea why pSD is null.
    // fix is below, when doing access check for service account.
    //
    if (pSD == NULL)
    {
        ASSERT(pSD) ;
		TrERROR(mqsec, "MQSec_AccessCheck() got NULL pSecurityDescriptor");
    }

    P<CImpersonate> pImpersonate = NULL;
    if (fImpersonate)
    {
        pImpersonate = new CImpersonate(fImpAsClient, fImpersonate);
        if (pImpersonate->GetImpersonationStatus() != 0)
        {
            return LogHR(MQ_ERROR_CANNOT_IMPERSONATE_CLIENT, s_FN, 90);
        }
    }

    CAutoCloseHandle hAccessToken = NULL;

    DWORD rc = GetAccessToken(
					&hAccessToken,
					FALSE,
					TOKEN_QUERY,
					TRUE
					);

    if (rc != ERROR_SUCCESS)
    {
        //
        // Return this error for backward compatibility.
        //
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 100);
    }

    HRESULT hr =  _DoAccessCheck(
						pSD,
						dwObjectType,
						pwszObjectName,
						dwDesiredAccess,
						pId,
						hAccessToken
						);

    if ( FAILED(hr)     &&
         (pSD != NULL)  &&
         pImpersonate->IsImpersonatedAsSystem() )
    {
        //
        // In all ACEs with the machine account sid, replace sid with
        // SYSTEM sid and try again. This is a workaround to problems in
        // Widnows 2000 where rpc call from service to service may be
        // interpreted as machine account sid or as SYSTEM sid. This depends
        // on either it's local rpc or tcp/ip and on using Kerberos.
        //
        PSID pMachineSid = MQSec_GetLocalMachineSid(FALSE, NULL);
        if (!pMachineSid)
        {
            //
            // Machine SID not available. Quit.
            //
            return LogHR(hr, s_FN, 110);
        }
        ASSERT(IsValidSid(pMachineSid));

        SECURITY_DESCRIPTOR sd;
        BOOL f = InitializeSecurityDescriptor(
						&sd,
						SECURITY_DESCRIPTOR_REVISION
						);
        ASSERT(f);

        //
        // use e_DoNotCopyControlBits at present, to be compatible with
        // previous code.
        //
        f = MQSec_CopySecurityDescriptor(
				&sd,
				pSD,
				(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION),
				e_DoNotCopyControlBits
				);
        if (!f)
        {
            ASSERT(f) ;
            DWORD gle = GetLastError() ;
    		TrERROR(mqsec, "MQSec_AccessCheck() fail to copy security descriptor, err- %!winerr!", gle) ;
            return MQ_ERROR_ACCESS_DENIED ;
        }

        BOOL fReplaced = FALSE;
        P<ACL> pSysDacl = NULL;

        HRESULT hr1 = _ReplaceSidWithSystem(
							&sd,
							pSD,
							pMachineSid,
							&pSysDacl,
							&fReplaced
							);

        if (SUCCEEDED(hr1) && fReplaced)
        {
            //
            // OK, try again, with new security desctiptor that replaced
            // the machine account sid with the well-known SYSTEM sid.
            //
            hr =  _DoAccessCheck(
						&sd,
						dwObjectType,
						pwszObjectName,
						dwDesiredAccess,
						pId,
						hAccessToken
						);
        }
    }

    return LogHR(hr, s_FN, 120);
}


//+------------------------------------------------------------------------
//
//  HRESULT  MQSec_AccessCheckForSelf()
//
//  Perform access check for the runnig thread. The access token is
//  retreived from the thread token.
//
//+------------------------------------------------------------------------

HRESULT
APIENTRY
MQSec_AccessCheckForSelf(
	IN  SECURITY_DESCRIPTOR *pSD,
	IN  DWORD                dwObjectType,
	IN  PSID                 pSelfSid,
	IN  DWORD                dwDesiredAccess,
	IN  BOOL                 fImpersonate
	)
{
    if (dwObjectType != MQDS_COMPUTER)
    {
        //
        // Not supported. this function is clled only to check
        // access rights for join-domain.
        //
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 130);
    }

    P<CImpersonate> pImpersonate = NULL;
    if (fImpersonate)
    {
        pImpersonate = new CImpersonate(fImpersonate, fImpersonate);
        if (pImpersonate->GetImpersonationStatus() != 0)
        {
            return LogHR(MQ_ERROR_CANNOT_IMPERSONATE_CLIENT, s_FN, 140);
        }
    }

    CAutoCloseHandle hAccessToken = NULL;

    DWORD rc = GetAccessToken(
					&hAccessToken,
					FALSE,
					TOKEN_QUERY,
					TRUE
					);

    if (rc != ERROR_SUCCESS)
    {
        //
        // Return this error for backward compatibility.
        //
        return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 150);
    }

    char ps_buff[sizeof(PRIVILEGE_SET) +
                    ((2 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES))];
    PPRIVILEGE_SET ps = (PPRIVILEGE_SET)ps_buff;
    DWORD dwPrivilegeSetLength = sizeof(ps_buff);

    DWORD dwGrantedAccess = 0;
    DWORD fAccessStatus = 1;

    //
    // this is the guid of msmqConfiguration class.
    // Hardcoded here, to save the effort of querying schema.
    // taken from schemaIDGUID attribute of CN=MSMQ-Configuration object
    // in schema naming context.
    //
    BYTE  guidMsmqConfiguration[sizeof(GUID)] = {
			0x44,
			0xc3,
			0x0d,
			0x9a,
			0x00,
			0xc1,
			0xd1,
			0x11,
			0xbb,
			0xc5,
			0x00,
			0x80,
			0xc7,
			0x66,
			0x70,
			0xc0
			};

    OBJECT_TYPE_LIST objType = {
						ACCESS_OBJECT_GUID,
						0,
						(GUID*) guidMsmqConfiguration
						};

    BOOL fSuccess = AccessCheckByTypeResultList(
						pSD,
						pSelfSid,
						hAccessToken,
						dwDesiredAccess,
						&objType,
						1,
						GetObjectGenericMapping(dwObjectType),
						ps,
						&dwPrivilegeSetLength,
						&dwGrantedAccess,
						&fAccessStatus
						);
    ASSERT(fSuccess);
	DBG_USED(fSuccess);

    HRESULT hr = MQSec_OK;

    if ((fAccessStatus == 0) &&
         AreAllAccessesGranted(dwGrantedAccess, dwDesiredAccess))
    {
        //
        // Access granted.
        // for this api, fAccessStatus being 0 mean success. see msdn.
        //
    }
    else
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            hr = MQ_ERROR_PRIVILEGE_NOT_HELD;
        }
        else
        {
            hr = MQ_ERROR_ACCESS_DENIED;
        }
    }

    return LogHR(hr, s_FN, 160);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\actempl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: actmepl.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Erez Haba    (erezh)   11-Mar-96
    Doron Juster (DoronJ)  30-June-98

Revision History:
--*/

#ifndef _ACTEMPL_H
#define _ACTEMPL_H

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

//-------------------------------------
//
//  Auto relese array of pointerss.
//
//-------------------------------------

template<class T>
class aPtrs
{
private:
    T       **m_p ;
    DWORD     m_dwSize ;

public:
    aPtrs(T **p, DWORD dwSize) :
                 m_p(p),
                 m_dwSize(dwSize)
    {
        ASSERT(m_dwSize > 0) ;
        for ( DWORD j = 0  ; j < m_dwSize ; j++ )
        {
            m_p[j] = NULL ;
        }
    }

    ~aPtrs()
    {
        for ( DWORD j = 0  ; j < m_dwSize ; j++ )
        {
            if (m_p[j])
            {
                delete m_p[j] ;
            }
        }

        ASSERT(m_p) ;
        delete m_p ;
    }
};

#endif // _ACTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\acssinit.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: acssinit.cpp

Abstract:
    Initialize the access control library.

Author:
    Doron Juster (DoronJ)  30-Jun-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include "mqnames.h"
#include <_registr.h>
#include <cs.h>

#include "acssinit.tmh"

static WCHAR *s_FN=L"acssctrl/acssinit";

//
// The lm* header files are needed for the net api that are used to
// construct the guest sid.
//
#include <lmaccess.h>
#include <lmserver.h>
#include <LMAPIBUF.H>
#include <lmerr.h>

static BYTE s_abGuestUserBuff[128];
PSID   g_pSidOfGuest = NULL;
PSID   g_pWorldSid = NULL;
PSID   g_pAnonymSid = NULL;
PSID   g_pSystemSid = NULL; // LocalSystem sid.
PSID   g_pPreW2kCompatibleAccessSid = NULL;

//
// This is the SID of the computer account, as defined in Active Directory.
// The MQQM.DLL cache it in local registry.
//
PSID   g_pLocalMachineSid = NULL;
DWORD  g_dwLocalMachineSidLen = 0;

//
// This is the SID of the account that run the MSMQ service (or replication
// service, or migration tool). By default (for the services), that's the
// LocalSystem account, but administrator may change it to any other account.
//
PSID   g_pProcessSid = NULL;

BOOL g_fDomainController = FALSE;


//+------------------------------------------
//
//  PSID  MQSec_GetAnonymousSid()
//
//  See above for meaning of "UnknownUser".
//
//+------------------------------------------

PSID  MQSec_GetAnonymousSid()
{
    ASSERT(g_pAnonymSid && IsValidSid(g_pAnonymSid));
    return g_pAnonymSid;
}

//+------------------------------------------
//
//  PSID  MQSec_GetLocalSystemSid()
//
//+------------------------------------------

PSID MQSec_GetLocalSystemSid()
{
    ASSERT((g_pSystemSid != NULL) && IsValidSid(g_pSystemSid));
    return g_pSystemSid;
}

//+----------------------------------------------------------------------
//
//  void InitializeGuestSid()
//
// Construct well-known-sid for Guest User on the local computer
//
//  1) Obtain the sid for the local machine's domain
//  2) append DOMAIN_USER_RID_GUEST to the domain sid in GuestUser sid.
//
//+----------------------------------------------------------------------

static CCriticalSection s_csGuestSid;

void InitializeGuestSid()
{
    static BOOL s_fAlreadyInitialized = FALSE;
    if (s_fAlreadyInitialized)
    {
        return;
    }

    CS Lock(s_csGuestSid);

    if (s_fAlreadyInitialized)
    {
        return;
    }

    ASSERT(!g_pSidOfGuest);

    BOOL bRet;
    USER_MODALS_INFO_2 * pUsrModals2 =  NULL;
    NET_API_STATUS NetStatus;

    NetStatus = NetUserModalsGet(
					NULL,   // local computer
					2,      // get level 2 information
					(LPBYTE *) &pUsrModals2
					);

    if (NetStatus == NERR_Success)
    {
        PSID pDomainSid = pUsrModals2->usrmod2_domain_id;
        PSID_IDENTIFIER_AUTHORITY pSidAuth;

        pSidAuth = GetSidIdentifierAuthority(pDomainSid);

        UCHAR nSubAuth = *GetSidSubAuthorityCount(pDomainSid);
        if (nSubAuth < 8)
        {
            DWORD adwSubAuth[8];
            UCHAR i;

            for (i = 0; i < nSubAuth; i++)
            {
                adwSubAuth[i] = *GetSidSubAuthority(pDomainSid, (DWORD)i);
            }
            adwSubAuth[i] = DOMAIN_USER_RID_GUEST;

            PSID pGuestSid;

            if (AllocateAndInitializeSid(
					pSidAuth,
					nSubAuth + 1,
					adwSubAuth[0],
					adwSubAuth[1],
					adwSubAuth[2],
					adwSubAuth[3],
					adwSubAuth[4],
					adwSubAuth[5],
					adwSubAuth[6],
					adwSubAuth[7],
					&pGuestSid
					))
            {
                g_pSidOfGuest = (PSID)s_abGuestUserBuff;
                bRet = CopySid(
							sizeof(s_abGuestUserBuff),
							g_pSidOfGuest,
							pGuestSid
							);
                ASSERT(bRet);
                FreeSid(pGuestSid);
            }
        }
        else
        {
            //
            //  There is no Win32 way to set a SID value with
            //  more than 8 sub-authorities. We will munge around
            //  on our own. Pretty dangerous thing to do :-(
            //
            g_pSidOfGuest = (PSID)s_abGuestUserBuff;
            bRet = CopySid(
						sizeof(s_abGuestUserBuff) - sizeof(DWORD),
						g_pSidOfGuest,
						pDomainSid
						);
            ASSERT(bRet);
            DWORD dwLenSid = GetLengthSid(g_pSidOfGuest);

            //
            // Increment the number of sub authorities
            //
            nSubAuth++;
            *((UCHAR *) g_pSidOfGuest + 1) = nSubAuth;

            //
            // Store the new sub authority (Domain User Rid for Guest).
            //
            *((ULONG *) ((BYTE *) g_pSidOfGuest + dwLenSid)) =
                                                 DOMAIN_USER_RID_GUEST;
        }

        NetApiBufferFree((LPVOID)pUsrModals2);
        pUsrModals2 = NULL;
    }
    else
    {
        g_pSidOfGuest = NULL;
        bRet = FALSE;

        LogHR(HRESULT_FROM_WIN32(NetStatus), s_FN, 40);
    }

#ifdef _DEBUG
    if (!g_pSidOfGuest)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR,
                TEXT("Faield to build the SID of the guest account. ")
                TEXT("NetUserModalsGet(2) returned %d"), NetStatus));
    }
    else
    {
        //
        // Compare the guest SID that we got with the one that
        // LookupAccountName returns. We can do it only on English
        // machines.
        //
        if (PRIMARYLANGID(GetSystemDefaultLangID()) == LANG_ENGLISH)
        {
            char abGuestSid_buff[128];
            PSID pGuestSid = (PSID)abGuestSid_buff;
            DWORD dwSidLen = sizeof(abGuestSid_buff);
            WCHAR szRefDomain[128];
            DWORD dwRefDomainLen = sizeof(szRefDomain) / sizeof(WCHAR);
            SID_NAME_USE eUse;

            BOOL bRetDbg = LookupAccountName(
								NULL,
								L"Guest",
								pGuestSid,
								&dwSidLen,
								szRefDomain,
								&dwRefDomainLen,
								&eUse
								);
            if (!bRetDbg              ||
                (eUse != SidTypeUser) ||
                !EqualSid(pGuestSid, g_pSidOfGuest))
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
                          "MQSEC: InitializeGuestSid(), Bad guest SID")));
            }
        }

        DWORD dwLen = GetLengthSid(g_pSidOfGuest);
        ASSERT(dwLen <= sizeof(s_abGuestUserBuff));
    }
#endif

    s_fAlreadyInitialized = TRUE;
}

//+---------------------------------
//
//   BOOL _InitWellKnownSIDs()
//
//+---------------------------------

static BOOL _InitWellKnownSIDs()
{
    BOOL bRet = TRUE;

    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
    //
    // Anonymous logon SID.
    //
    bRet = AllocateAndInitializeSid(
				&NtAuth,
				1,
				SECURITY_ANONYMOUS_LOGON_RID,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pAnonymSid
				);
    ASSERT(bRet);

    //
    // Initialize the LocalSystem account.
    //
    bRet = AllocateAndInitializeSid(
				&NtAuth,
				1,
				SECURITY_LOCAL_SYSTEM_RID,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pSystemSid
				);

    ASSERT(bRet);

    //
    // Initialize Pre windows 2000 compatible access SID
    //
    bRet = AllocateAndInitializeSid(
				&NtAuth,
				2,
				SECURITY_BUILTIN_DOMAIN_RID,
				DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pPreW2kCompatibleAccessSid
				);

    ASSERT(bRet);

    //
    // Initialize the process sid.
    //
    DWORD dwLen = 0;
    CAutoCloseHandle hUserToken;

    if (GetAccessToken(&hUserToken, FALSE) == ERROR_SUCCESS)
    {
        //
        // Get the SID from the access token.
        //
        GetTokenInformation(hUserToken, TokenUser, NULL, 0, &dwLen);
        DWORD dwErr = GetLastError();
        if ((dwErr == ERROR_INSUFFICIENT_BUFFER) || (dwLen > 0))
        {
            P<BYTE> pBuf = new BYTE[dwLen];
            bRet = GetTokenInformation(
						hUserToken,
						TokenUser,
						pBuf,
						dwLen,
						&dwLen
						);

            ASSERT(bRet);
            BYTE *pTokenUser = pBuf;
            PSID pSid = (PSID) (((TOKEN_USER*) pTokenUser)->User.Sid);
            dwLen = GetLengthSid(pSid);
            g_pProcessSid = (PSID) new BYTE[dwLen];
            bRet = CopySid(dwLen, g_pProcessSid, pSid);
            ASSERT(bRet);

#ifdef _DEBUG
            ASSERT(IsValidSid(g_pProcessSid));

            BOOL fSystemSid = MQSec_IsSystemSid(g_pProcessSid);
            if (fSystemSid)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, TEXT(
                     "_InitWellKnownSid(): processSID is LocalSystem")));
            }
#endif
        }
    }
    ASSERT(g_pProcessSid);

    if (!g_pProcessSid)
    {
        //
        // We can't get sid from thread/process token.
        // Initialize as LocalSystem (the default).
        //
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, TEXT(
               "_InitWellKnownSid(): failed to initialize ProcessSid")));
        dwLen = GetLengthSid(g_pSystemSid);
        g_pProcessSid = (PSID) new BYTE[dwLen] ;
        bRet = CopySid(dwLen, g_pProcessSid, g_pSystemSid);
        ASSERT(bRet);
    }

    //
    // Initialize World (everyone) SID
    //
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    bRet = AllocateAndInitializeSid(
				&WorldAuth,
				1,
				SECURITY_WORLD_RID,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				&g_pWorldSid
				);

    ASSERT(bRet);

    return LogBOOL(bRet, s_FN, 10);
}

//+-------------------------------------------------
//
//  PSID  MQSec_GetProcessSid()
//
//+-------------------------------------------------

PSID APIENTRY  MQSec_GetProcessSid()
{
    return  g_pProcessSid;
}

//+-------------------------------------------------
//
//  PSID  MQSec_GetWorldSid()
//
//+-------------------------------------------------

PSID APIENTRY  MQSec_GetWorldSid()
{
    return  g_pWorldSid;
}

//+-----------------------------------------------------------------------
//
//   PSID MQSec_GetLocalMachineSid()
//
//  Input:
//      fAllocate- When TRUE, allocate the buffer. Otherwise, just return
//                 the cached global pointer.
//
//+------------------------------------------------------------------------

PSID
APIENTRY
MQSec_GetLocalMachineSid(
	IN  BOOL    fAllocate,
	OUT DWORD  *pdwSize
	)
{
    static BOOL s_fAlreadyRead = FALSE;

    if (!s_fAlreadyRead)
    {
		PSID pLocalMachineSid = NULL;
        DWORD  dwSize = 0 ;
        DWORD  dwType = REG_BINARY;

        LONG rc = GetFalconKeyValue(
						MACHINE_ACCOUNT_REGNAME,
						&dwType,
						pLocalMachineSid,
						&dwSize
						);
        if (dwSize > 0)
        {
            pLocalMachineSid = new BYTE[dwSize];

            rc = GetFalconKeyValue(
					MACHINE_ACCOUNT_REGNAME,
					&dwType,
					pLocalMachineSid,
					&dwSize
					);

            if (rc != ERROR_SUCCESS)
            {
                delete[] reinterpret_cast<BYTE*>(pLocalMachineSid);
                pLocalMachineSid = NULL;
                dwSize = 0;
            }
        }

		if(NULL != InterlockedCompareExchangePointer(
						reinterpret_cast<PVOID*>(&g_pLocalMachineSid),
						pLocalMachineSid,
						NULL
						))
		{
			//
			// The exchange was not performed
			//
			ASSERT(pLocalMachineSid != NULL);
			delete[] reinterpret_cast<BYTE*>(pLocalMachineSid);
		}
		else
		{
			//
			// The exchange was done
			// Only the thread that perform the assignment should assign the size.
			//
			ASSERT(g_pLocalMachineSid == pLocalMachineSid);
			g_dwLocalMachineSidLen = dwSize;

		}

        s_fAlreadyRead = TRUE;
    }

    PSID pSid = g_pLocalMachineSid;

    if (fAllocate && g_dwLocalMachineSidLen)
    {
        pSid = (PSID) new BYTE[g_dwLocalMachineSidLen];
        memcpy(pSid, g_pLocalMachineSid, g_dwLocalMachineSidLen);
    }
    if (pdwSize)
    {
        *pdwSize = g_dwLocalMachineSidLen;
    }

    return pSid;
}

//+-----------------------------------------
//
//   BOOL _InitDomainControllerFlag()
//
//+-----------------------------------------

STATIC BOOL _InitDomainControllerFlag()
{
    //
    // See if we're running on a domain or backup domain controller.
    //
    PSERVER_INFO_101 pServerInfo;

    NET_API_STATUS NetStatus = NetServerGetInfo( NULL,
                                                 101,
                                                 (LPBYTE*)&pServerInfo );
    if (NetStatus == NERR_Success)
    {
        g_fDomainController =
            (pServerInfo->sv101_type &
             (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL)) != 0;

        NetStatus = NetApiBufferFree(pServerInfo);
        ASSERT(NetStatus == NERR_Success);
    }
    else
    {
        //
        // NetServerGetInfo may fail if the server service is not started.
        // If the server service is not started on a domain controller, all
        // objects will be created as if a local user created them. This is
        // a limitation because we can not decide whether this computer is
        // a domain controller without the server service.
        //
        g_fDomainController = FALSE;
    }

    return TRUE ;
}

//+------------------------------------
//
//  void  _FreeSecurityResources()
//
//+------------------------------------

void  _FreeSecurityResources()
{
    if (g_pAnonymSid)
    {
        FreeSid(g_pAnonymSid);
        g_pAnonymSid = NULL;
    }

    if (g_pWorldSid)
    {
        FreeSid(g_pWorldSid);
        g_pWorldSid = NULL;
    }

    if (g_pSystemSid)
    {
        FreeSid(g_pSystemSid);
        g_pSystemSid = NULL;
    }

	if (g_pPreW2kCompatibleAccessSid)
	{
        FreeSid(g_pPreW2kCompatibleAccessSid);
        g_pPreW2kCompatibleAccessSid = NULL;
	}

    if (g_pProcessSid)
    {
        delete g_pProcessSid;
        g_pProcessSid = NULL;
    }

    if (g_pLocalMachineSid)
    {
        delete g_pLocalMachineSid;
        g_pLocalMachineSid = NULL;
    }
}

/***********************************************************
*
* AccessControlDllMain
*
************************************************************/

BOOL
WINAPI
AccessControlDllMain (
	HMODULE hMod,
	DWORD fdwReason,
	LPVOID lpvReserved
	)
{
    BOOL bRet = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        bRet = _InitWellKnownSIDs();
        ASSERT(bRet) ;

        bRet = _InitDomainControllerFlag();
        ASSERT(bRet) ;

        InitializeGenericMapping();

        //
        // For backward compatibility.
        // On MSMQ1.0, loading and initialization of mqutil.dll (that
        // included this code) always succeeded.
        //
        bRet = TRUE;
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        _FreeSecurityResources();
    }
    else if (fdwReason == DLL_THREAD_ATTACH)
    {
    }
    else if (fdwReason == DLL_THREAD_DETACH)
    {
    }

	return LogBOOL(bRet, s_FN, 20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\imprsont.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: imprsont.cpp

Abstract:
    Code to handle impersonation and access tokens.
    First version taken from mqutil\secutils.cpp

Author:
    Doron Juster (DoronJ)  01-Jul-1998

Revision History:

--*/

#include <stdh_sec.h>
#include <rpcdce.h>
#include "acssctrl.h"

#include "imprsont.tmh"

#ifdef _DEBUG

DWORD  g_dwMqSecDebugFlags = 0 ;

#endif

HRESULT 
GetThreadUserSid( 
	LPBYTE *pUserSid,
	DWORD *pdwUserSidLen 
	); // from mqutil.dll

static WCHAR *s_FN=L"acssctrl/imprsont";

//+------------------------------------
//
//  HRESULT _GetThreadUserSid()
//
//+------------------------------------

HRESULT 
_GetThreadUserSid( 
	IN  HANDLE hToken,
	OUT PSID  *ppSid,
	OUT DWORD *pdwSidLen 
	)
{
    DWORD dwTokenLen = 0;

    GetTokenInformation(hToken, TokenUser, NULL, 0, &dwTokenLen);
    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        AP<char> ptu = new char[dwTokenLen];
        BOOL bRet = GetTokenInformation( 
						hToken,
						TokenUser,
						ptu,
						dwTokenLen,
						&dwTokenLen 
						);
        ASSERT(bRet);
        if (!bRet)
        {
            return LogHR(MQSec_E_FAIL_GETTOKENINFO, s_FN, 10);
        }
        PSID pOwner = ((TOKEN_USER*)(char*)ptu)->User.Sid;

        DWORD dwSidLen = GetLengthSid(pOwner);
        *ppSid = (PSID) new BYTE[dwSidLen];
        bRet = CopySid(dwSidLen, *ppSid, pOwner);
        ASSERT(bRet);
        if (!bRet)
        {
            delete *ppSid;
            *ppSid = NULL;
            return LogHR(MQSec_E_UNKNOWN, s_FN, 20);
        }

        if (pdwSidLen)
        {
            *pdwSidLen = dwSidLen;
        }
    }
    else
    {
        return LogHR(MQSec_E_FAIL_GETTOKENINFO, s_FN, 30);
    }

    return MQSec_OK;
}

//+-------------------------
//
//  CImpersonate class
//
//+-------------------------

//
// CImpersonate constructor.
//
// Parameters:
//      fClient - Set to TRUE when the client is an RPC client.
//      fImpersonate - Set to TRUE if impersonation is required upon object
//          construction.
//
CImpersonate::CImpersonate(BOOL fClient, BOOL fImpersonate)
{
    m_fClient = fClient;
    m_fImpersonating = fImpersonate;
    m_hAccessTokenHandle = NULL;
    m_dwStatus = 0;
    m_fImpersonateAnonymous = false;

    if (m_fImpersonating)
    {
        Impersonate(m_fImpersonating);
    }
}

//
// CImpersonate distructor.
//
CImpersonate::~CImpersonate()
{
    if (m_fImpersonating)
    {
        Impersonate(FALSE); // Revert to self.
    }

    ASSERT(m_hAccessTokenHandle == NULL);
    ASSERT(!m_fImpersonateAnonymous);
}

//
// Impersonate the client or revert to self.
//
BOOL CImpersonate::Impersonate(BOOL fImpersonate)
{
    m_fImpersonating = fImpersonate;

    if (m_fClient)
    {
        if (m_fImpersonating)
        {
            m_dwStatus = RpcImpersonateClient(NULL);

#ifdef _DEBUG
            if ((g_dwMqSecDebugFlags & DBG_SEC_SHOW_IMPERSONATED_SID) ==
                                             DBG_SEC_SHOW_IMPERSONATED_SID)
            {
                AP<BYTE> pSid;
                BOOL f = GetThreadSid(&pSid);
				ASSERT(f);
            }
#endif

#if 0
//
//            Leave this code commented out. We can't know when Anonymous
//            will be broken again and we'll have to change implementation
//            to use the Guest account.
//
//            if (m_dwStatus == RPC_S_OK)
//            {
//                //
//                // Check if thread was impersonated as anonymous.
//                // Anonymous logon can not access the DS. So if we're
//                // anonymous, revert and impersonate again as guest.
//                //
//                BOOL fAnonym = IsImpersonatedAsAnonymous();
//                if (fAnonym)
//                {
//                    m_dwStatus = RpcRevertToSelf();
//
//                    ASSERT(m_hAccessTokenHandle);
//                    if (m_hAccessTokenHandle)
//                    {
//                        CloseHandle(m_hAccessTokenHandle);
//                        m_hAccessTokenHandle = NULL;
//                    }
//
//                    //
//                    // Set an error, so code below will try the
//                    // Guest impersonation.
//                    //
//                    m_dwStatus = RPC_S_CANNOT_SUPPORT;
//                }
//            }
#endif

            if (m_dwStatus != RPC_S_OK)
            {
				//
				// Try to impersonate the Guest user
				//
				BOOL fI = ImpersonateAnonymousToken(GetCurrentThread());
				if (fI)
				{
					m_fImpersonateAnonymous = true;
					m_dwStatus = RPC_S_OK;
				}
				else
				{
					m_dwStatus = GetLastError();
					if (m_dwStatus == 0)
					{
						m_dwStatus = RPC_S_CANNOT_SUPPORT;
					}
				}
            }
        }
        else
        {
            if (m_fImpersonateAnonymous)
            {
               BOOL f = RevertToSelf();
               if (f)
               {
                  m_dwStatus = RPC_S_OK;
               }
               else
               {
                  m_dwStatus = GetLastError();
                  if (m_dwStatus == 0)
                  {
                     m_dwStatus = RPC_S_CANNOT_SUPPORT;
                  }
               }
			   m_fImpersonateAnonymous = false;
            }
            else
            {
               m_dwStatus = RpcRevertToSelf();
            }
        }
    }
    else
    {
        m_dwStatus = 0;

        if (m_fImpersonating)
        {
            if (!ImpersonateSelf(SecurityIdentification))
            {
                m_dwStatus = GetLastError();
            }
        }
        else
        {
            if (!RevertToSelf())
            {
                m_dwStatus = GetLastError();
            }
        }
    }

    if (!m_fImpersonating && (m_hAccessTokenHandle != NULL))
    {
        CloseHandle(m_hAccessTokenHandle);
        m_hAccessTokenHandle = NULL;
    }

    LogRPCStatus(m_dwStatus, s_FN, 50);
    return(m_dwStatus == 0);
}

//
// Get the client's impersonation token.
//
HANDLE 
CImpersonate::GetAccessToken( 
	IN DWORD dwAccessType,
	IN BOOL  fThreadTokenOnly 
	)
{
    ASSERT(m_fImpersonating);

    if (m_hAccessTokenHandle == NULL)
    {
        if (::GetAccessToken( 
					&m_hAccessTokenHandle,
					!m_fClient,
					dwAccessType,
					fThreadTokenOnly 
					) != ERROR_SUCCESS)
        {
            LogIllegalPoint(s_FN, 60);
            return(NULL);
        }
    }
    ASSERT(m_hAccessTokenHandle != NULL);

    return m_hAccessTokenHandle;
}

//+-------------------------------------------------------
//
//  BOOL CImpersonate::GetThreadSid( OUT BYTE **ppSid )
//
//  the caller must free the buffer allocated here for the sid.
//
//+-------------------------------------------------------

BOOL CImpersonate::GetThreadSid(OUT BYTE **ppSid)
{
    *ppSid = NULL;

    BOOL bRet = FALSE;
    HANDLE hAccess = GetAccessToken( 
						TOKEN_QUERY,
						TRUE   // thread only
						);
    if (hAccess)
    {
        HRESULT hr = _GetThreadUserSid( 
							hAccess,
							(PSID*) ppSid,
							NULL 
							);

        bRet = SUCCEEDED(hr);
        LogHR(hr, s_FN, 70);
    }

    return LogBOOL(bRet, s_FN, 80);
}

//+-------------------------------------------------------
//
//  BOOL CImpersonate::IsImpersonateAsSystem()
//
// Check if thread is impersoanted as SYSTEM user.
// Return TRUE for the SYSTEM case.
// In cases of error, we return FALSE by default.
//
//+-------------------------------------------------------

BOOL CImpersonate::IsImpersonatedAsSystem()
{
    AP<BYTE> pTokenSid;
    BOOL fGet = GetThreadSid(&pTokenSid);

    if (fGet)
    {
        ASSERT(pTokenSid);
        if (pTokenSid && g_pSystemSid)
        {
            BOOL bRet = EqualSid(pTokenSid, g_pSystemSid);
            return bRet;
        }
    }

    return LogBOOL(FALSE, s_FN, 90);
}

//+-------------------------------------------------------
//
//  BOOL CImpersonate::IsImpersonateAsAnonymous()
//
// Check if thread is impersoanted as ANONYMOUS user.
// Return TRUE for the anonymous case.
// In cases of error, we return FALSE by default.
//
//+-------------------------------------------------------

BOOL CImpersonate::IsImpersonatedAsAnonymous()
{
    ASSERT(0);

#if 0
//    AP<BYTE> pTokenSid;
//    BOOL fGet = GetThreadSid(&pTokenSid);
//
//    if (fGet)
//    {
//        ASSERT(pTokenSid);
//        if (pTokenSid && g_pAnonymSid)
//        {
//            return (EqualSid(pTokenSid, g_pAnonymSid));
//        }
//    }
#endif

    return FALSE;
}

//
// Get impersonation status. Acording to the return value of this method it is
// possible to tell whether the impersonation was successful.
//
DWORD CImpersonate::GetImpersonationStatus()
{
    return(m_dwStatus);
}

//+-------------------------------------------------
//
//  HRESULT  MQSec_GetImpersonationObject()
//
//+-------------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetImpersonationObject(
	IN  BOOL           fClient,
	IN  BOOL           fImpersonate,
	OUT CImpersonate **ppImpersonate 
	)
{
    CImpersonate *pImp = new CImpersonate(fClient, fImpersonate);
    *ppImpersonate = pImp;
    return MQSec_OK;
}

//+---------------------------------------
//
//  HRESULT MQSec_GetUserType()
//
//+---------------------------------------

HRESULT 
APIENTRY  
MQSec_GetUserType( 
	IN  PSID pSid,
	OUT BOOL *pfLocalUser,
	OUT BOOL *pfLocalSystem 
	)
{
    ASSERT(pfLocalUser);
    *pfLocalUser = FALSE;

    HRESULT hr = MQSec_OK;
    AP<BYTE> pSid1;
    DWORD dwSidLen;

    if (!pSid)
    {
        //
        // get the SID of the thread user.
        //
        hr = GetThreadUserSid(&pSid1, &dwSidLen);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 100);
        }
        pSid = pSid1;
    }
    ASSERT(IsValidSid(pSid));

    if (pfLocalSystem)
    {
        *pfLocalSystem = MQSec_IsSystemSid(pSid);
        if (*pfLocalSystem)
        {
            //
            // The local system account (on Win2000) is a perfectly
            // legitimate authenticated domain user.
            //
            return LogHR(hr, s_FN, 110);
        }
        *pfLocalSystem = FALSE;
    }

    *pfLocalUser = MQSec_IsAnonymusSid(pSid);
    if (*pfLocalUser)
    {
        //
        // The anonymous logon user is a local user.
        //
        return LogHR(hr, s_FN, 120);
    }

    //
    // Check if guest account.
    //
    if (!g_fDomainController)
    {
        //
        // On non-domain controllers, any user that has the same SID
        // prefix as the guest account, is a local user.
        //
        InitializeGuestSid();

        PSID_IDENTIFIER_AUTHORITY pSidAuth;
        SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;
        pSidAuth = GetSidIdentifierAuthority(pSid);

        *pfLocalUser = ((memcmp(pSidAuth, &NtSecAuth, sizeof(SID_IDENTIFIER_AUTHORITY)) != 0) ||
						(g_pSidOfGuest && EqualPrefixSid(pSid, g_pSidOfGuest)));
    }
    else
    {
        //
        // On domain and backup domain controllers a local user, in our
        // case can only be the guest user.
        //
        *pfLocalUser = MQSec_IsGuestSid(pSid);
    }

    return LogHR(hr, s_FN, 130);

}

//+--------------------------------------------------
//
//  BOOL  MQSec_IsGuestSid()
//
//+--------------------------------------------------

BOOL APIENTRY MQSec_IsGuestSid(IN  PSID  pSid)
{
    InitializeGuestSid();

    BOOL fGuest = g_pSidOfGuest && EqualSid(g_pSidOfGuest, pSid);

    return fGuest;
}

//+--------------------------------------------------
//
//  BOOL   MQSec_IsSystemSid()
//
//+--------------------------------------------------

BOOL APIENTRY MQSec_IsSystemSid(IN  PSID  pSid)
{
    BOOL fSystem = g_pSystemSid && EqualSid(g_pSystemSid, pSid);

    return fSystem;
}

//+--------------------------------------------------
//
//  BOOL   MQSec_IsAnonymusSid()
//
//+--------------------------------------------------

BOOL APIENTRY MQSec_IsAnonymusSid(IN  PSID  pSid)
{
    BOOL fAnonymus = g_pAnonymSid && EqualSid(g_pAnonymSid, pSid);

    return fAnonymus;
}

//+----------------------------------------------------
//
//  HRESULT  MQSec_IsUnAuthenticatedUser()
//
//+----------------------------------------------------

HRESULT 
APIENTRY  
MQSec_IsUnAuthenticatedUser(
	OUT BOOL *pfGuestOrAnonymousUser 
	)
{
    AP<BYTE> pbSid;

    CImpersonate Impersonate(TRUE, TRUE);

    HRESULT hr = MQSec_GetThreadUserSid(TRUE, (PSID *) &pbSid, NULL);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    *pfGuestOrAnonymousUser =
                MQSec_IsGuestSid( pbSid ) ||
               (g_pAnonymSid && EqualSid(g_pAnonymSid, (PSID)pbSid));

    return MQSec_OK;
}

//+---------------------------------------------------------------------
//
//  HRESULT  MQSec_GetThreadUserSid()
//
//  Get SID of client that called this server thread. This function
//  shoud be called only by RPC server threads. It impersonate the
//  client by calling RpcImpersonateClient().
//
//  Caller must free the buffer that is allocated here for the SId.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetThreadUserSid(
	IN  BOOL        fImpersonate,         
	OUT PSID  *     ppSid,
	OUT DWORD *     pdwSidLen 
	)
{
    *ppSid = NULL;

    CAutoCloseHandle hUserToken;
    DWORD rc =  GetAccessToken( 
					&hUserToken,
					fImpersonate,
					TOKEN_QUERY,
					TRUE  //   fThreadTokenOnly
					); 

    if (rc != ERROR_SUCCESS)
    {
        HRESULT hr1 = HRESULT_FROM_WIN32(rc);
        return LogHR(hr1, s_FN, 170);
    }

    HRESULT hr = _GetThreadUserSid( 
						hUserToken,
						ppSid,
						pdwSidLen 
						);

    return LogHR(hr, s_FN, 180);
}

//+---------------------------------------------------------------------
//
//  HRESULT  MQSec_GetProcessUserSid()
//
//  Caller must free the buffer that is allocated here for the SId.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetProcessUserSid( 
	OUT PSID  *ppSid,
	OUT DWORD *pdwSidLen 
	)
{
    *ppSid = NULL;

    CAutoCloseHandle hUserToken;
    DWORD rc = GetAccessToken( 
					&hUserToken,
					FALSE,    // fImpersonate
					TOKEN_QUERY,
					FALSE		// fThreadTokenOnly 
					); 

    if (rc != ERROR_SUCCESS)
    {
        return LogHR(MQSec_E_UNKNOWN, s_FN, 190);
    }

    HRESULT hr = _GetThreadUserSid( 
						hUserToken,
						ppSid,
						pdwSidLen 
						);

    return LogHR(hr, s_FN, 200);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\privilge.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: privilge.cpp

Abstract:
    Handle process and thread privileges.

Author:
    Doron Juster (DoronJ)  08-Jun-1998

Revision History:

--*/

#include <stdh_sec.h>

#include "privilge.tmh"

static WCHAR *s_FN=L"acssctrl/privilge";

//+-------------------------------------------------------------------
//
// Function:   SetSpecificPrivilegeInAccessToken()
//
// Description:
//      Enable/Disable a security privilege in the access token.
//
// Parameters:
//      hAccessToken - the access token on which the function should operate.
//          The token should be opened with the TOKEN_ADJUST_PRIVILEGES flag.
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//          disabled.
//
//+-------------------------------------------------------------------

HRESULT SetSpecificPrivilegeInAccessToken( HANDLE  hAccessToken,
                                           LPCTSTR lpwcsPrivType,
                                           BOOL    bEnabled )
{
    DWORD             dwErr = 0 ;
    HRESULT           hr = MQSec_OK ;
    LUID              luidPrivilegeLUID;
    TOKEN_PRIVILEGES  tpTokenPrivilege;

    if (!LookupPrivilegeValue( NULL,
                               lpwcsPrivType,
                               &luidPrivilegeLUID) )
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to lookup privilege value. %!winerr!"), GetLastError()));
        return MQSec_E_LOOKUP_PRIV ;
    }

    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes =
                                      bEnabled ? SE_PRIVILEGE_ENABLED : 0 ;

    if (!AdjustTokenPrivileges( hAccessToken,
                                FALSE,         // Do not disable all
                                &tpTokenPrivilege,
                                0,
                                NULL,           // Ignore previous info
                                NULL ))         // Ignore previous info
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to adjust token privileges. %!winerr!"), GetLastError()));
        return MQSec_E_ADJUST_TOKEN;
    }
    else
    {
        dwErr = GetLastError() ;
        ASSERT((dwErr == ERROR_SUCCESS) ||
               (dwErr == ERROR_NOT_ALL_ASSIGNED)) ;
    }

    return LogHR(hr, s_FN, 30);
}


//+-------------------------------------------------------------------
//
// Function:  MQSec_SetPrivilegeInThread()
//
// Description:
//      Enable/Disable a security privilege in the access token of the
//      current thread.
//
// Parameters:
//      lpwcsPrivType - the privilege type.
//      bEnabled - Indicates whether the privilige should be enabled or
//                 disabled.
//
//+-------------------------------------------------------------------

HRESULT APIENTRY  MQSec_SetPrivilegeInThread( LPCTSTR lpwcsPrivType,
                                              BOOL    bEnabled )
{
    HRESULT hr = MQSec_OK ;
    HANDLE  hAccessToken = NULL ;

    BOOL bRet = OpenThreadToken( GetCurrentThread(),
                                 TOKEN_ADJUST_PRIVILEGES,
                                 TRUE,
                                 &hAccessToken ) ;
    if (!bRet)
    {
        DWORD gle = GetLastError();
        if (gle == ERROR_NO_TOKEN)
        {
            bRet = OpenProcessToken( GetCurrentProcess(),
                                     TOKEN_ADJUST_PRIVILEGES,
                                     &hAccessToken ) ;
            if(!bRet)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to open current process token. %!winerr!"), GetLastError()));
            }
        }
        else
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to open thread token. %!winerr!"), gle));
        }
    }
    ASSERT(bRet);

    if (bRet)
    {
        hr = SetSpecificPrivilegeInAccessToken( hAccessToken,
                                                lpwcsPrivType,
                                                bEnabled );
        CloseHandle(hAccessToken) ;
        hAccessToken = NULL ;
    }
    else
    {
        hr = MQSec_E_OPEN_TOKEN ;
    }

    ASSERT(hAccessToken == NULL) ;
    return LogHR(hr, s_FN, 40);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\secd5to4.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: secd5to4.cpp

Abstract:
    Conversion of NT5 security descriptor to NT4 format.

Author:
    Doron Juster (DoronJ)  24-May-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include <mqnames.h>

#include "secd5to4.tmh"

static WCHAR *s_FN=L"acssctrl/secd5to4";

//+----------------------------
//
//  void GetpSidAndObj()
//
//+----------------------------

void  
GetpSidAndObj( 
	IN  ACCESS_ALLOWED_ACE*   pAce,
	OUT PSID                 *ppSid,
	OUT BOOL                 *pfObj,
	OUT GUID                **ppguidObj 
	)
{
	ACCESS_ALLOWED_OBJECT_ACE* pObjAce = (ACCESS_ALLOWED_OBJECT_ACE*) pAce;

    BOOL fObj = ((pAce->Header.AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) ||
                 (pAce->Header.AceType == ACCESS_DENIED_OBJECT_ACE_TYPE)  ||
                 (pAce->Header.AceType == SYSTEM_AUDIT_OBJECT_ACE_TYPE));

    *ppSid = NULL;
    *pfObj = fObj;

    if (fObj)
    {
        if (pObjAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            //
            // "inherited" guid is present.
            //
            if (pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT)
            {
                //
                // Both guids are present.
                // ACE Structure contain spaces for both guids.
                //
                *ppSid = (PSID) &(pObjAce->SidStart);
            }
            else
            {
                //
                // Only one guid presented. structure is shorter.
                //
                *ppSid = (PSID) &(pObjAce->InheritedObjectType);
            }
        }
        else if (pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            //
            // In this case, the structure is shorter, and sid start
            // at the "Inherited" member. April98 MSDN is wrong about
            // this structure.
            //
            *ppSid = (PSID) &(pObjAce->InheritedObjectType);
        }
        else
        {
            //
            // Structure even shorter. no guid is present.
            //
            ASSERT(pObjAce->Flags == 0);
            *ppSid = (PSID) &(pObjAce->ObjectType);
        }

        if ((pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT) && ppguidObj)
        {
            *ppguidObj = &(pObjAce->ObjectType);
        }
    }
    else
    {
        *ppSid = (PSID) &(pAce->SidStart);
    }
}

//+---------------------------------------
//
//  DWORD _MapNt5RightsToNt4Ace()
//
//+---------------------------------------

static 
DWORD 
_MapNt5RightsToNt4Ace( 
	IN DWORD               dwObjectType,
	IN BOOL                fObj,
	IN ACCESS_ALLOWED_ACE* pAce,
	IN DWORD               dwPrevMask 
	)
{
    if (dwPrevMask == g_dwFullControlNT4[dwObjectType])
    {
        //
        // already full control. Ignore.
        //
        return dwPrevMask;
    }

    DWORD dwMask = dwPrevMask;

    if (fObj)
    {
        struct RIGHTSMAP  *psMap = g_psExtendRightsMap5to4[dwObjectType];
        DWORD dwSize =  g_pdwExtendRightsSize5to4[dwObjectType];

        if (psMap)
        {
            BOOL fFound = FALSE;
            ACCESS_ALLOWED_OBJECT_ACE* pObjAce = (ACCESS_ALLOWED_OBJECT_ACE*) pAce;
            GUID *pGuid = &(pObjAce->ObjectType);

            if ((pObjAce->Mask & MSMQ_EXTENDED_RIGHT_MASK) == MSMQ_EXTENDED_RIGHT_MASK)
            {
                //
                // This is an extended right object ace. It may be relevant.
                //
                ASSERT(pObjAce->Flags & ACE_OBJECT_TYPE_PRESENT);

                for (DWORD j = 0; j < dwSize; j++)
                {
                    if (memcmp( 
							pGuid,
							&(psMap[j].guidRight),
							sizeof(GUID)
							) == 0)
                    {
                        dwMask |= psMap[j].dwPermission5to4;
                        fFound = TRUE;
                        break;
                    }
                }
            }

            if (!fFound                          &&
                 (dwObjectType == MQDS_MACHINE)  &&
                 (memcmp(pGuid, &g_guidCreateQueue, sizeof(GUID)) == 0))
            {
                //
                // Handle the special case where the DACL doesn't have the
                // "CreateAllChild" bit turned on, but rather it has
                // "CreatemSMQQueue" guid present.
                //
                if (pObjAce->Mask & RIGHT_DS_CREATE_CHILD)
                {
                    dwMask |= MQSEC_CREATE_QUEUE;
                }
            }
        }
        else
        {
            //
            // Only queue and machine objects can have extended rights.
            //
            ASSERT((dwObjectType != MQDS_QUEUE) && (dwObjectType != MQDS_MACHINE));
        }
    }
    else
    {
        //
        // Map the DS specific rights to MSMQ specific rights
        //
        DWORD dwDSRights = pAce->Mask;
        ASSERT(dwDSRights != 0);

        if (dwDSRights == GENERIC_ALL_MAPPING)
        {
            //
            // Full control.
            // Don't look for other allow aces for this sid.
            //
            return  g_dwFullControlNT4[dwObjectType];
        }

        DWORD  *pdwMap = g_padwRightsMap5to4[dwObjectType];
        ASSERT(pdwMap);

        for (DWORD j = 0; j < NUMOF_ADS_SPECIFIC_RIGHTS; j++)
        {
            DWORD dwRight =  dwDSRights & 0x01;
            if (dwRight)
            {
                dwMask |= pdwMap[j];
            }
            dwDSRights >>= 1;
        }

        //
        // Copy the standard rights.
        //
        dwDSRights = pAce->Mask;
        DWORD dwStandard = dwDSRights & STANDARD_RIGHTS_ALL;
        dwMask |= dwStandard;

        if (dwObjectType == MQDS_SITE)
        {
            //
            // the single NT5 DS right CreateChild is mapped to three
            // MSMQ1.0 rights: createFRS, createBSC and createMachine.
            // The translation table contain only the createMachine right.
            // Add all the others.
            //
            if (dwMask & MQSEC_CREATE_MACHINE)
            {
                dwMask |= (MQSEC_CREATE_FRS | MQSEC_CREATE_BSC | MQSEC_CREATE_MACHINE);
            }
        }
    }

    return dwMask;
}

//+----------------------------
//
//  BOOL  _IsNewNt5Sid()
//
//+----------------------------

static 
BOOL  
_IsNewNt5Sid( 
	ACCESS_ALLOWED_ACE*   pAce,
	SID                 **ppSids,
	DWORD                *pdwNumofSids 
	)
{
    BOOL fObj;
    PSID pSid = NULL;

    GetpSidAndObj( 
		pAce,
		&pSid,
		&fObj 
		);

    ASSERT(pSid && IsValidSid(pSid));

    BOOL fFound = FALSE ;
    for (DWORD j = 0; j < *pdwNumofSids; j++)
    {
        PSID pSidOld = ppSids[j];

        if (EqualSid(pSid, pSidOld))
        {
            fFound = TRUE;
            break ;
        }
    }

    if (!fFound)
    {
        //
        // New sid.
        //
        DWORD dwSize = GetLengthSid(pSid);
        ASSERT(dwSize) ;

        SID *pNewSid = (SID*) new BYTE[dwSize];
        BOOL f = CopySid(dwSize, pNewSid, pSid);
		DBG_USED(f);
        ASSERT(f);

        DWORD dwIndex = *pdwNumofSids;
        ppSids[dwIndex] = pNewSid;
        *pdwNumofSids = dwIndex + 1;
    }

    return !fFound;
}

//+-------------------------------
//
//  void _SetNt4AuditMasks()
//
//+-------------------------------

inline 
static 
void 
_SetNt4AuditMasks( 
	IN  SYSTEM_AUDIT_ACE *pAce,
	IN  DWORD             dwObjectType,
	IN  BOOL              fObj,
	OUT ACCESS_MASK      *pdwFail,
	OUT ACCESS_MASK      *pdwSuccess 
	)
{
    BYTE bFlags = pAce->Header.AceFlags;

    if (bFlags & FAILED_ACCESS_ACE_FLAG)
    {
        *pdwFail = _MapNt5RightsToNt4Ace(  
						dwObjectType,
						fObj,
						(ACCESS_ALLOWED_ACE*) pAce,
						*pdwFail 
						);
    }

    if (bFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
    {
        *pdwSuccess = _MapNt5RightsToNt4Ace(  
							dwObjectType,
							fObj,
							(ACCESS_ALLOWED_ACE*) pAce,
							*pdwSuccess 
							);
    }
}

//+---------------------------------------------
//
//  static HRESULT _ConvertSaclToNT4Format()
//
//+---------------------------------------------

static 
HRESULT 
_ConvertSaclToNT4Format( 
	IN  DWORD   dwObjectType,
	IN  PACL    pAcl5,
	OUT DWORD  *pdwAcl4Len,
	OUT PACL   *ppAcl4 
	)
{
    ASSERT(IsValidAcl(pAcl5));

    DWORD dwAclSize = (DWORD) pAcl5->AclSize;
	DWORD dwNumberOfACEs = (DWORD) pAcl5->AceCount;
	if (dwNumberOfACEs == 0)
    {
        //
        // SACL without ACEs. nothing to convert.
        //
        *pdwAcl4Len = 0;
        *ppAcl4 = NULL;
        return MQSec_OK;
    }

    *pdwAcl4Len = dwAclSize;
    *ppAcl4 = (PACL) new BYTE[*pdwAcl4Len];
    BOOL f = InitializeAcl(*ppAcl4, *pdwAcl4Len, ACL_REVISION);
    ASSERT(f);

    //
    // First, group aces by SID, then by audit type (fail or success).
    //
    // We build an array of SIDs that we handled up to now. We combine
    // aces of same sid into one ace. This operation does not change the
    // semantic of the acl, just make it more efficient.
    //
    SID  **ppSids5 = (SID**) new PSID[dwNumberOfACEs];
    aPtrs<SID> apSids(ppSids5, dwNumberOfACEs);
    DWORD dwNumSids = 0;

    DWORD i = 0;

    do
    {
	    SYSTEM_AUDIT_ACE *pAce;
        if (GetAce(pAcl5, i, (LPVOID* )&(pAce)) == FALSE)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while converting SACL from NT5 form. %!winerr!"), i, GetLastError()));
            return MQSec_E_SDCONVERT_GETACE ;
        }

        if (!_IsNewNt5Sid( 
				(ACCESS_ALLOWED_ACE*) pAce,
				ppSids5,
				&dwNumSids 
				))
        {
            i++;
            continue;
        }

        //
        // First ace in the group. Now look for contigous aces with same sid.
        //
        BOOL fObj;
        PSID pSid = NULL;

        GetpSidAndObj( 
			(ACCESS_ALLOWED_ACE*) pAce,
			&pSid,
			&fObj 
			);

        ASSERT(pSid && IsValidSid(pSid));

        ACCESS_MASK  dwMaskFail = 0;
        ACCESS_MASK  dwMaskSuccess = 0;
        _SetNt4AuditMasks( 
			pAce,
			dwObjectType,
			fObj,
			&dwMaskFail,
			&dwMaskSuccess 
			);

        i++;
        DWORD j = i;

        while (j < dwNumberOfACEs)
        {
            if (GetAce(pAcl5, j, (LPVOID* )&(pAce)) == FALSE)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while looking for next ACE in NT4 format. %!winerr!"), i, GetLastError()));
                return MQSec_E_SDCONVERT_GETACE ;
            }

            PSID pPresentSid = NULL;

            GetpSidAndObj( 
				(ACCESS_ALLOWED_ACE*) pAce,
				&pPresentSid,
				&fObj 
				);

            ASSERT(pPresentSid && IsValidSid(pPresentSid));

            if (EqualSid(pSid, pPresentSid))
            {
                _SetNt4AuditMasks( 
					pAce,
					dwObjectType,
					fObj,
					&dwMaskFail,
					&dwMaskSuccess 
					);
            }
            j++;
        }

        //
        // Now we have a group of aces of same SID, and we have the masks.
        //
        if (dwMaskSuccess != 0)
        {
            if (dwMaskSuccess != 0)
            {
                BOOL f = AddAuditAccessAce( 
							*ppAcl4,
							ACL_REVISION,
							dwMaskSuccess,
							pSid,
							TRUE,     // success
							(dwMaskFail == dwMaskSuccess) 
							);
				DBG_USED(f);
				ASSERT(f);
            }
        }

        if ((dwMaskFail != 0) && (dwMaskFail != dwMaskSuccess))
        {
            f = AddAuditAccessAce( 
					*ppAcl4,
					ACL_REVISION,
					dwMaskFail,
					pSid,
					FALSE,     // success
					TRUE		// failure
					);
			ASSERT(f);
        }
    }
    while (i < dwNumberOfACEs);

    return MQSec_OK;
}

//+---------------------------------------
//
//  HRESULT _ConvertGroupOfNt5DaclAces()
//
//  convert a group of ACEs, all of them having same type.
//
//+---------------------------------------

static 
HRESULT 
_ConvertGroupOfNt5DaclAces( 
	DWORD  dwObjectType,
	PACL   pInAcl5,
	DWORD  iFirst,
	DWORD  iLast,
	BOOL   fAllow,
	PACL   pOutAcl4 
	)
{
	DWORD   dwNumberOfACEs = iLast - iFirst + 1;
    DWORD   i = iFirst;

    //
    // We build an array of SIDs that we handled up to now. We combine
    // aces of same sid into one ace. This operation does not change the
    // semantic of the acl, just make it more efficient.
    //
    SID  **ppSids5 = (SID**) new PSID[dwNumberOfACEs];
    aPtrs<SID> apSids(ppSids5, dwNumberOfACEs);
    DWORD    dwNumSids = 0;

    do
    {
	    ACCESS_ALLOWED_ACE *pAce;
        if (GetAce(pInAcl5, i, (LPVOID* )&(pAce)) == FALSE)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while combining same SID NT5 ACEs. %!winerr!"), i, GetLastError()));
            return MQSec_E_SDCONVERT_GETACE ;
        }

        if (!_IsNewNt5Sid( 
				pAce,
				ppSids5,
				&dwNumSids 
				))
        {
            i++;
            continue;
        }

        //
        // this ace start a group of aces for a given sid.
        // on MSMQ1.0 we don't support inheritance of ace, so just OR the
        // masks of all  aces of this sid and create a NT5 ace.
        //
        PSID pSid = NULL;
        BOOL fObj = FALSE;
        GetpSidAndObj( 
			pAce,
			&pSid,
			&fObj 
			);

        ASSERT(pSid && IsValidSid(pSid));

        DWORD dwMSMQRights = _MapNt5RightsToNt4Ace( 
									dwObjectType,
									fObj,
									pAce,
									0 
									);
        i++;
        DWORD j = i;

        while (j <= iLast)
        {
            if (GetAce(pInAcl5, j, (LPVOID* )&(pAce)) == FALSE)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while looking for next NT5 ACE in a group. %!winerr!"), i, GetLastError()));
                return MQSec_E_SDCONVERT_GETACE ;
            }

            PSID pPresentSid = NULL;
            GetpSidAndObj( 
				pAce,
				&pPresentSid,
				&fObj 
				);

            ASSERT(pPresentSid && IsValidSid(pPresentSid));

            if (EqualSid(pSid, pPresentSid))
            {
                dwMSMQRights = _MapNt5RightsToNt4Ace( 
									dwObjectType,
									fObj,
									pAce,
									dwMSMQRights 
									);
            }
            j++;
        }

        BOOL f = FALSE;
        if (dwMSMQRights == 0)
        {
            //
            // Ignore. this is probably the result of access bits or
            // extended rights which are not supported on MSMQ1.0
            // don't add ACE with null access mask. It's meaningless
            // in MSMQ1.0
            //
            f = TRUE;
        }
        else if (fAllow)
        {
            f = AddAccessAllowedAce( 
					pOutAcl4,
					ACL_REVISION,
					dwMSMQRights,
					pSid 
					);
        }
        else
        {
            f = AddAccessDeniedAceEx( 
					pOutAcl4,
					ACL_REVISION,
					0,
					dwMSMQRights,
					pSid 
					);
        }
#ifdef _DEBUG
        DWORD dwErr = GetLastError();
        ASSERT(f);
        if (!f)
        {
            LogNTStatus(dwErr, s_FN, 45);
        }
#endif
    }
    while (i <= iLast);

    return MQSec_OK;
}

//+---------------------------------------------
//
//  static HRESULT _ConvertDaclToNT4Format()
//
//+---------------------------------------------

static 
HRESULT 
_ConvertDaclToNT4Format( 
	IN  DWORD   dwObjectType,
	IN  PACL    pAcl5,
	OUT DWORD  *pdwAcl4Len,
	OUT PACL   *ppAcl4 
	)
{
    ASSERT(IsValidAcl(pAcl5));
    HRESULT hr = MQSec_OK;

    DWORD dwAclSize = (DWORD) pAcl5->AclSize;
	DWORD dwNumberOfACEs = (DWORD) pAcl5->AceCount;

    //
    // See if we're running in the context of the replication service.
    // If so, then add an ALLOW_ACE for the enterprise object and let
    // everyone register certificate. This is a workaround for bug 5054,
    // to allow users in NT4 sites to register certifiates after PEc
    // migrated to Win2k. Otherwise, the NT4 MQIS servers will reject such
    // request and won't forward write-requests to the PEC.
    // Reason for the bug- we don't have a "register certificate" bit in the
    // security descriptor of the msmqService object, so there is nothing
    // we can translate to NT4 format. Anyway, mixed-mode msmq must relax
    // security, so this is just another aspect of this relaxation. There is
    // no security hole here, as MQIS servers do perform all necessary
    // validations of the certificate before issuing the write request.
    // Even in NT4, the "create user" bit was quite meaningless.
    //
    static BOOL s_fInReplService = FALSE;
    static BOOL s_fCheckReplService = TRUE;

    if (s_fCheckReplService)
    {
        HMODULE  hMq = GetModuleHandle(MQ1REPL_DLL_NAME);
        if (hMq)
        {
            s_fInReplService = TRUE;
        }
        s_fCheckReplService = FALSE;
    }

    if (s_fInReplService && (dwObjectType == MQDS_ENTERPRISE))
    {
        dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(MQSec_GetWorldSid()));
    }

    //
    // The size of NT4 format can't be larger than the size of NT5.
    // In worst case, when all ACEs are added to NT4 ACL, NT5
    // OBJECT_ACEs are converted to NT4 ACEs which are smaller.
    // So allocating same size is safe, although may waste some memory.
    // The alternative is to scan the NT5 acl before starting conversion
    // and calculating the required size.
    //
    *pdwAcl4Len = dwAclSize;
    *ppAcl4 = (PACL) new BYTE[*pdwAcl4Len];
    BOOL f = InitializeAcl(*ppAcl4, *pdwAcl4Len, ACL_REVISION);
    ASSERT(f);

    //
    // We're not assuming that the input acl is canonical. So we'll handle
    // groups of identical aces (i.e., aces of same type) at a time. Each
    // group will be converted to canonical NT5 format. So if input is
    // canonical, output will be canonical too.
    //
    DWORD i = 0;

    do
    {
        //
        // first ace in the group.
        //
	    ACCESS_ALLOWED_ACE *pAce;
        if (GetAce(pAcl5, i, (LPVOID* )&(pAce)) == FALSE)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while looking for first NT5 ACE to convert. %!winerr!"), i, GetLastError()));
            return MQSec_E_SDCONVERT_GETACE ;
        }

        //
        // First verify it's an effective ACE. We don't take into account
        // INHRIT_ONLY aces. See ACE_HEADER documentation in MSDN.
        //
        if (pAce->Header.AceFlags & INHERIT_ONLY_ACE)
        {
            i++;
            continue;
        }

        DWORD iFirst = i;
        DWORD iLast = i;
        BOOL fAllow =
                ((pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                 (pAce->Header.AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE));
        i++;

        //
        // now look for other aces with same type.
        //
        while (i < dwNumberOfACEs)
        {
            if (GetAce(pAcl5, i, (LPVOID* )&(pAce)) == FALSE)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while looking for other NT5 ACEs with same type. %!winerr!"), i, GetLastError()));
                return MQSec_E_SDCONVERT_GETACE ;
            }

            if (pAce->Header.AceFlags & INHERIT_ONLY_ACE)
            {
                //
                // This ACE is not an effective one for this object.
                // End of present group.
                //
                break;
            }

            BOOL fPresentAllow =
                ((pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                 (pAce->Header.AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE));

            if (fAllow == fPresentAllow)
            {
                iLast = i;
                i++;
            }
            else
            {
                break;
            }
        }

        //
        // Handle all aces from iFirst to iLast.
        //
        hr = _ConvertGroupOfNt5DaclAces( 
					dwObjectType,
					pAcl5,
					iFirst,
					iLast,
					fAllow,
					*ppAcl4 
					);
    }
    while (i < dwNumberOfACEs);

    if (s_fInReplService && (dwObjectType == MQDS_ENTERPRISE))
    {
        f = AddAccessAllowedAce( 
				*ppAcl4,
				ACL_REVISION,
				MQSEC_CREATE_USER,
				MQSec_GetWorldSid() 
				);
        ASSERT(f);
    }

    return MQSec_OK;
}

//+-----------------------------------------------------------------
//
//  BOOL _AlreadyNT4Format()
//
//  check if security descriptor is already in NT4 format. We're
//  checking the dacl revision. if it's ACL_REVISION then it's NT4.
//  NT5 DS must use the ACL_REVISION_DS.
//
//+-----------------------------------------------------------------

static BOOL _AlreadyNT4Format(IN  SECURITY_DESCRIPTOR  *pSD5)
{
    BOOL  bPresent;
    BOOL  bDefaulted;
    PACL  pAcl5;

    BOOL bRet = GetSecurityDescriptorDacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					);
    if (!bPresent)
    {
        //
        // dacl not present. Try the sacl.
        //
        bRet = GetSecurityDescriptorSacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					);
    }

    if (bPresent && pAcl5)
    {
        //
        // If the input is indeed in nt4 format, then it's legal to
        // have a "present" DACL that is NULL. So if acl is not null, we'll
        // check the version, but if it's null, then it's already in
        // nt4 format.
        //
	    return (pAcl5->AclRevision == ACL_REVISION);
    }

    //
    // If both dacl and sacl are not present, or are present as NULL, then
    // consider the SD as being in NT4 format and don't do anything with it.
    //
    return TRUE;
}

//+-----------------------------------------------------------------
//
//  HRESULT MQSec_ConvertSDToNT4Format()
//
//  Description: Convert a security descriptor from NT5 format to NT4
//      compatiblae format.
//
//+-----------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_ConvertSDToNT4Format(
	IN  DWORD                 dwObjectType,
	IN  SECURITY_DESCRIPTOR  *pSD5,
	OUT DWORD                *pdwSD4Len,
	OUT SECURITY_DESCRIPTOR **ppSD4,
	IN  SECURITY_INFORMATION  sInfo 
	)
{
    if (!pSD5 || !ppSD4)
    {
        ASSERT(0);
        return LogHR(MQSec_E_NULL_SD, s_FN, 80);
    }

    HRESULT hr = MQSec_OK;
    *ppSD4 = NULL;

    if (!IsValidSecurityDescriptor(pSD5))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't convert an invalid NT5 Security Descriptor")));
        ASSERT(0);
        return MQSec_E_SD_NOT_VALID;
    }

    //
    // Make sure input descriptor is self-relative.
    //
    DWORD dwRevision = 0;
    SECURITY_DESCRIPTOR_CONTROL sdC;
    BOOL f = GetSecurityDescriptorControl(pSD5, &sdC, &dwRevision);
	DBG_USED(f);
    ASSERT(f);

    if (!(sdC & SE_SELF_RELATIVE))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't convert a non self-relative NT5 Security Descriptor")));
        return MQSec_E_NOT_SELF_RELATIVE;
    }
    else if (_AlreadyNT4Format(pSD5))
    {
        return LogHR(MQSec_I_SD_CONV_NOT_NEEDED, s_FN, 110);
    }

    if ((dwObjectType != MQDS_QUEUE)   &&
        (dwObjectType != MQDS_MACHINE) &&
        (dwObjectType != MQDS_CN)      &&
        (dwObjectType != MQDS_SITE)    &&
        (dwObjectType != MQDS_ENTERPRISE))
    {
        //
        // BUGBUG Temporary.
        //
        return LogHR(MQSec_I_SD_CONV_NOT_NEEDED, s_FN, 120);
    }

    SECURITY_DESCRIPTOR sd;

    BOOL bRet = InitializeSecurityDescriptor( 
					&sd,
					SECURITY_DESCRIPTOR_REVISION 
					);
    if (!bRet)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't initialize security descriptor while converting from NT5 to NT4 format. %!winerr!"), GetLastError()));
        return MQSec_E_INIT_SD;
    }

    //
    // Handle owner.
    //
    PSID pOwner = NULL;
    if (sInfo & OWNER_SECURITY_INFORMATION)
    {
        BOOL bOwnerDefaulted;

        bRet = GetSecurityDescriptorOwner( 
					pSD5,
					&pOwner,
					&bOwnerDefaulted 
					);

        ASSERT(bRet && pOwner);
        ASSERT(IsValidSid(pOwner));

        //
        // BUGBUG
        // If this is a local user, set the owner to be the anonymous
        // logon user.
        //
        bRet = SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted);
        ASSERT(bRet);
    }

    //
    // Handle group
    //
    PSID pGroup = NULL;
    if (sInfo & GROUP_SECURITY_INFORMATION)
    {
        BOOL bGroupDefaulted;

        bRet = GetSecurityDescriptorGroup( 
					pSD5,
					&pGroup,
					&bGroupDefaulted 
					);

        ASSERT(bRet && pGroup);
        ASSERT(IsValidSid(pGroup));

        bRet = SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted);
        ASSERT(bRet);
    }

    //
    // Handle SACL
    //
    BOOL   bPresent = FALSE;
    BOOL   bDefaulted = FALSE;
    PACL   pAcl5;
    DWORD  dwAclLen;
    P<ACL> pSacl4 = NULL;

    if (sInfo & SACL_SECURITY_INFORMATION)
    {
        bRet = GetSecurityDescriptorSacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					);
        ASSERT(bRet);

        hr = MQSec_OK;
        if (bPresent)
        {
            if (pAcl5)
            {
                //
                // It's legal to have NULL Sacl. No need to convert it.
                //
                hr = _ConvertSaclToNT4Format( 
							dwObjectType,
							pAcl5,
							&dwAclLen,
							&pSacl4 
							);

                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 140);
                }
                if (pSacl4)
                {
                    ASSERT(IsValidAcl(pSacl4));
                }
                else
                {
                    //
                    // that's OK. sometimes there is a SACL wihtout any
                    // ACEs. let's convert it to no-SACL.
                    //
                    ASSERT(dwAclLen == 0);
                    bPresent = FALSE;
                }
            }
            else
            {
                //
                // that's kind of bug in NT. Flag is set but sacl is null.
                // trying to set this SecurityDescriptor with this value will
                // fail, with error 0x13 from ldap.
                // Reset the present flag.
                //
                bPresent = FALSE;
            }
        }
        bRet = SetSecurityDescriptorSacl( 
					&sd,
					bPresent,
					pSacl4,
					bDefaulted
					);
        ASSERT(bRet);
    }

    //
    // Handle DACL
    //
    //
    // BUGBUG. Workaround for beta2. Send to NT4 a SD with NUL DACL,
    // which mean full control to everyone.
    //
    P<ACL> pDacl4 = NULL;
    if (sInfo & DACL_SECURITY_INFORMATION)
    {
        bRet = GetSecurityDescriptorDacl( 
					pSD5,
					&bPresent,
					&pAcl5,
					&bDefaulted 
					);
        ASSERT(bRet);

        hr = MQSec_OK;
        if (bPresent)
        {
            hr = _ConvertDaclToNT4Format( 
						dwObjectType,
						pAcl5,
						&dwAclLen,
						&pDacl4 
						);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 150);
            }
            ASSERT(IsValidAcl(pDacl4));
        }
        bRet = SetSecurityDescriptorDacl( 
					&sd,
					bPresent,
					pDacl4,
					bDefaulted
					);
        ASSERT(bRet);
    }

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwLen = 0;
    bRet = MakeSelfRelativeSD(&sd, NULL, &dwLen);
    DWORD dwErr = GetLastError();
    if (!bRet && (dwErr == ERROR_INSUFFICIENT_BUFFER))
    {
        *ppSD4 = (SECURITY_DESCRIPTOR*) new char[dwLen];
        bRet = MakeSelfRelativeSD(&sd, *ppSD4, &dwLen);
        ASSERT(bRet);
    }
    else
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't get the SD length required to convert NT4 SD to self relative. %!winerr!"), dwErr));
        return MQSec_E_MAKESELF_GETLEN;
    }

    *pdwSD4Len = dwLen;
    return MQSec_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\_mqutil.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: _mqutil.h

Abstract:
    temporary file which define stuff from mqutil.dll.
    Will be removed when all security related code from mqutil
    move to mqsec.dll

Author:
    Doron Juster (DoronJ)  30-Jun-1998

Revision History:

--*/

HRESULT
IsLocalUser(
    PSID pSid,
    BOOL *pfLocalUser
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\certget.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certget.cpp

Abstract:
    Implement the "get" methods, for retrieving data from a certificate.

Author:
    Doron Juster (DoronJ)  14-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "certget.tmh"

static WCHAR *s_FN=L"certifct/certget";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetIssuer()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetIssuer( OUT LPWSTR *ppszLocality,
                                      OUT LPWSTR *ppszOrg,
                                      OUT LPWSTR *ppszOrgUnit,
                                      OUT LPWSTR *ppszCommon ) const
{
    P<CERT_NAME_INFO> pNameInfo = NULL ;
    HRESULT hr = GetIssuerInfo( &pNameInfo ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10) ;
    }

    hr = GetNames( pNameInfo,
                   ppszLocality,
                   ppszOrg,
                   ppszOrgUnit,
                   ppszCommon ) ;

    return LogHR(hr, s_FN, 20) ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetIssuerInfo()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetIssuerInfo(
                             OUT CERT_NAME_INFO **ppNameInfo ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 30) ;
    }
    ASSERT(!m_fCreatedInternally) ;

    BYTE   *pBuf = NULL ;
    DWORD   dwBufSize = 0 ;
    HRESULT hr = _DecodeName( m_pCertContext->pCertInfo->Issuer.pbData,
                              m_pCertContext->pCertInfo->Issuer.cbData,
                              &pBuf,
                              &dwBufSize ) ;
    if (FAILED(hr))
    {
        delete pBuf ;
        return LogHR(hr, s_FN, 40) ;
    }
    ASSERT(pBuf && dwBufSize) ;

    *ppNameInfo = (CERT_NAME_INFO*) pBuf ;

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetSubject()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetSubject( OUT LPWSTR *ppszLocality,
                                       OUT LPWSTR *ppszOrg,
                                       OUT LPWSTR *ppszOrgUnit,
                                       OUT LPWSTR *ppszCommon ) const
{
    P<CERT_NAME_INFO> pNameInfo = NULL ;
    HRESULT hr = GetSubjectInfo( &pNameInfo ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50) ;
    }

    hr = GetNames( pNameInfo,
                   ppszLocality,
                   ppszOrg,
                   ppszOrgUnit,
                   ppszCommon ) ;

    return LogHR(hr, s_FN, 60) ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetSubjectInfo()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetSubjectInfo(
                                 OUT CERT_NAME_INFO **ppNameInfo ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 70) ;
    }
    ASSERT(!m_fCreatedInternally) ;

    BYTE   *pBuf = NULL ;
    DWORD   dwBufSize = 0 ;
    HRESULT hr = _DecodeName( m_pCertContext->pCertInfo->Subject.pbData,
                              m_pCertContext->pCertInfo->Subject.cbData,
                              &pBuf,
                              &dwBufSize ) ;
    if (FAILED(hr))
    {
        delete pBuf ;
        return LogHR(hr, s_FN, 80) ;
    }
    ASSERT(pBuf && dwBufSize) ;

    *ppNameInfo = (CERT_NAME_INFO*) pBuf ;

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetNames()
//
//  Description: Get a name component[s] from a CERT_NAME_INFO buffer.
//
//+-----------------------------------------------------------------------

#define  GET_A_NAME(ppBuf, point)           \
    if (ppBuf && !(*ppBuf))                 \
    {                                       \
        hr = _GetAName( prgRDN, ppBuf ) ;   \
        if (FAILED(hr))                     \
        {                                   \
            return LogHR(hr, s_FN, point) ; \
        }                                   \
    }

HRESULT CMQSigCertificate::GetNames( IN  CERT_NAME_INFO *pNameInfo,
                                     OUT LPWSTR          *ppszLocality,
                                     OUT LPWSTR          *ppszOrg,
                                     OUT LPWSTR          *ppszOrgUnit,
                                     OUT LPWSTR          *ppszCommon,
                                     OUT LPWSTR      *ppEmailAddress ) const
{
    HRESULT hr = MQ_OK ;
    DWORD dwc =  pNameInfo->cRDN ;
    CERT_RDN *prgRDN = pNameInfo->rgRDN ;
    P<WCHAR>  pEmailName = NULL ;
    LPWSTR   *ppEmailName = &pEmailName ;

    for ( ; dwc > 0 ; )
    {

        CERT_RDN_ATTR  *prgRDNAttr = prgRDN->rgRDNAttr ;

        if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_ORGANIZATION_NAME) == 0)
        {
            GET_A_NAME(ppszOrg, 90) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId,
                          szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
        {
            GET_A_NAME(ppszOrgUnit, 100) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_LOCALITY_NAME) == 0)
        {
            GET_A_NAME(ppszLocality, 110) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_COMMON_NAME) == 0)
        {
            GET_A_NAME(ppszCommon, 120) ;
        }
        else if (lstrcmpiA(prgRDNAttr->pszObjId, szOID_RSA_emailAddr) == 0)
        {
            GET_A_NAME(ppEmailName, 130) ;
        }

        prgRDN++ ;
        dwc-- ;
    }

    if (ppszCommon && *ppszCommon && !ppEmailAddress && pEmailName)
    {
        //
        // Append the email address to the common name.
        //
        DWORD dwSize = lstrlen(pEmailName) + lstrlen(*ppszCommon) + 12 ;
        WCHAR *pBuf = new WCHAR[ dwSize ] ;
        lstrcpy(pBuf, *ppszCommon) ;
        lstrcat(pBuf, L", Email=") ;
        lstrcat(pBuf, pEmailName) ;

        delete *ppszCommon ;
        *ppszCommon = pBuf ;
    }

    if (ppEmailAddress)
    {
        *ppEmailAddress = pEmailName.detach();
    }

    return LogHR(hr, s_FN, 100) ;
}

#undef  GET_A_NAME

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetValidity()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetValidity( OUT FILETIME *pftNotBefore,
                                        OUT FILETIME *pftNotAfter ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 150) ;
    }
    ASSERT(!m_fCreatedInternally) ;

    if (pftNotBefore)
    {
        *pftNotBefore = m_pCertContext->pCertInfo->NotBefore ;
    }

    if (pftNotAfter)
    {
        *pftNotAfter = m_pCertContext->pCertInfo->NotAfter ;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetValidity()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetPublicKey( IN  HCRYPTPROV hProv,
                                         OUT HCRYPTKEY  *phKey ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 160) ;
    }
    if (!hProv || !phKey)
    {
        return  LogHR(MQSec_E_INVALID_PARAMETER, s_FN, 170) ;
    }

    CERT_PUBLIC_KEY_INFO *pPubKey =
                     &(m_pCertContext->pCertInfo->SubjectPublicKeyInfo) ;

    BOOL fImp =  CryptImportPublicKeyInfo( hProv,
                                           MY_ENCODING_TYPE,
                                           pPubKey,
                                           phKey ) ;
    if (!fImp)
    {
        return LogHR(MQSec_E_CAN_NOT_GET_KEY, s_FN, 180) ;
    }

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\secd4to5.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: secd4to5.cpp

Abstract:
    Conversion of NT4 security descriptor to NT5 DS format.

Author:
    Doron Juster (DoronJ)  01-Jun-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"

#include "secd4to5.tmh"

static WCHAR *s_FN=L"acssctrl/secd4to5";

//
// Make the "mandatory" permissions for localSystem differ from "full
// control", so by default the mandatory aces do not grant the right to read
// messages. Do so by reseting the "all extended rights" bit.
//
#define MANDATORY_ACE_PERMISSIONS   \
                       (GENERIC_ALL_MAPPING & (~RIGHT_DS_CONTROL_ACCESS))

#define MANDATORY_COMPUTER_ACE_PERMISSIONS   \
                      (RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY)

//+-----------------------------------------
//
//  BOOL  _ShrinkAcl(ACL **ppAcl5)
//
//+-----------------------------------------

static
BOOL  
_ShrinkAcl(
	ACL **ppAcl5, 
	DWORD *pdwSize
	)
{
    //
    // compute size of ACL.
    //
    DWORD dwNewSize = sizeof(ACL);
    DWORD dwNumberOfACEs = (DWORD) (*ppAcl5)->AceCount;
    for (DWORD i = 0; i < dwNumberOfACEs; i++)
    {
        ACCESS_ALLOWED_ACE *pAce;
        if (GetAce(*ppAcl5, i, (LPVOID* )&(pAce)) == FALSE)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get NT5 ACE (index=%lu) while shrinking ACL. %!winerr!"), i, GetLastError()));
            return FALSE;
        }
        dwNewSize += pAce->Header.AceSize;
    }
    ASSERT(dwNewSize <= (*ppAcl5)->AclSize);

    PACL pAcl = (PACL) new BYTE[dwNewSize];
    memcpy(pAcl, *ppAcl5, dwNewSize);
    delete *ppAcl5;

    *ppAcl5 = pAcl;
    *pdwSize = dwNewSize;
    (*ppAcl5)->AclSize = (WORD) dwNewSize;
    ASSERT(IsValidAcl(*ppAcl5));

    return TRUE;
}

//+----------------------------------------------------------------
//
//  BOOL _CheckForMandatoryACEs()
//
//  Check if mandatory ACEs are included in the DACL.
//  Return TRUE if all mandatory ACEs are already included in the
//  ACL, FALSE if any of them is missing.
//
// Paramaters:
//    IN  GUID *pProperty - guid of the CN property.
//
//+----------------------------------------------------------------

static
BOOL 
_CheckForMandatoryACEs( 
	IN  PACL  pAcl,
	IN  PSID  pComputerSid,
	IN  GUID *pProperty,
	OUT BOOL *pfDenied,
	OUT BOOL *pfSystem,
	OUT BOOL *pfComputer 
	)
{
    BOOL  fSkipDeny = FALSE;
	DWORD dwNumberOfACEs = (DWORD) pAcl->AceCount;
    DWORD i = 0;

    do
    {
	    ACCESS_ALLOWED_ACE *pAce;
        if (GetAce(pAcl, i, (LPVOID* )&(pAce)) == FALSE)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while looking for mandatory ACEs. %!winerr!"), i, GetLastError()));
            return FALSE;
        }

        BOOL fObj;
        PSID pSid = NULL;
        GUID *pObjType = NULL;

        GetpSidAndObj( 
			pAce,
			&pSid,
			&fObj,
			&pObjType 
			);

        ASSERT(pSid && IsValidSid(pSid));

        BOOL fObjDeny = (pAce->Header.AceType == ACCESS_DENIED_OBJECT_ACE_TYPE);

        if (!fObjDeny)
        {
            //
            // The mandatory "deny" ace must appear before any "allow" ace.
            // So don't look for the mandatory deny ace anymore.
            //
            fSkipDeny = TRUE;
        }

        //
        // Check for Access-Deny, Write-CN
        //
        if (!fSkipDeny     &&
            !(*pfDenied)   &&
             fObjDeny      &&
             pObjType      &&
             EqualSid(pSid, g_pWorldSid))
        {
            if ((memcmp(pObjType, pProperty, sizeof(GUID)) == 0) &&
                (pAce->Mask & RIGHT_DS_WRITE_PROPERTY))
            {
                //
                // OK, "everyone" sid, same property, and WriteProp is
                // included in the access mask of this deny ace.
                //
                *pfDenied = TRUE;
            }
        }

        //
        // Check for LocalSystem full-control
        //
        if (!(*pfSystem)  &&
             (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE))
        {
            if (((pAce->Mask & MANDATORY_ACE_PERMISSIONS) ==
                                          MANDATORY_ACE_PERMISSIONS) &&
                 EqualSid(pSid, g_pSystemSid))
            {
                *pfSystem = TRUE;
            }
        }

        //
        // Check for Computer ACE
        //
        if (!(*pfComputer)  &&
             (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE))
        {
            if (((pAce->Mask & MANDATORY_COMPUTER_ACE_PERMISSIONS) ==
                                    MANDATORY_COMPUTER_ACE_PERMISSIONS) &&
                 EqualSid(pSid, pComputerSid))
            {
                *pfComputer = TRUE;
            }
        }

        i++;
    }
    while (i < dwNumberOfACEs);

    BOOL bRet = *pfSystem && *pfDenied && *pfComputer;
    return LogBOOL(bRet, s_FN, 30);
}

//+-------------------------------------------------
//
//  HRESULT _AddMandatoryAllowACEs()
//
//+-------------------------------------------------

static
HRESULT 
_AddMandatoryAllowACEs( 
	IN  DWORD   dwObjectType,
	IN  PSID    pComputerSid,
	IN  PACL    pAcl5,
	IN  BOOL    fSystemAce,
	IN  BOOL    fComputerAce 
	)
{
    if (!fSystemAce)
    {
        BOOL f = AddAccessAllowedAce( 
					pAcl5,
					ACL_REVISION_DS,
					MANDATORY_ACE_PERMISSIONS,
					g_pSystemSid 
					);
		DBG_USED(f);
        ASSERT(f);
    }

    if (!fComputerAce)
    {
        ASSERT(pComputerSid && IsValidSid(pComputerSid));

        BOOL f = AddAccessAllowedAce( 
					pAcl5,
					ACL_REVISION_DS,
					MANDATORY_COMPUTER_ACE_PERMISSIONS,
					pComputerSid 
					);
		DBG_USED(f);
        ASSERT(f);
    }

    return MQSec_OK;
}

//+------------------------------------------------------------------------
//
//   HRESULT _AddMandatoryDenyACEs()
//
//  Each DACL of MSMQ object must have two (or three) ACEs:
//  1. Deny Write CN for everyone.  All of MSMQ code depend on certain names
//     of objects, for example, the CN of the machine object must be "msmq".
//     We deny everyone the permission to set the "cn".
//  2. Allow LocalSystem account full control. This is necessary for the
//     replication service (in mixed mode) and for the MSMQ service itself
//     that must update objects attributes in special cases.
//  3. Allow the computer account to read and change properties of the
//     msmqConfiguration object.
//
//  This function first check for the presence of these aces. If not already
//  present, then we add here the deny ace. The allow aces will be added
//  after the dacl is converted. This is necessary for keeping the dacl
//  in the canonical form. Otherwise, access checl may fail and user may
//  get misleading warnings when displaying the object security in mmc.
//
//  Please note that you can use the DC mmc to change these permissions,
//  but that's your responsibility. We can't deny you the permission to
//  destroy your system, although we make it a little more difficult, and
//  set the proper defaults.
//
//  This function allocates the DACL and add the mandatory deny ACEs.
//
//+------------------------------------------------------------------------

static
HRESULT
_AddMandatoryDenyACEs( 
	IN  DWORD   dwObjectType,
	IN  PSID    pComputerSid,
	IN  PACL    pAcl4,
	OUT DWORD  *pdwAcl5Len,
	OUT PACL   *ppAcl5,
	OUT BOOL   *pfAlreadyNT5,
	OUT BOOL   *pfOnlyCopy,
	OUT BOOL   *pfSystemAce,
	OUT BOOL   *pfComputerAce 
	)
{
    *pfOnlyCopy = FALSE;

    //
    // When going from NT4 format to NT5, the ACL size grow because of the
    // object ACEs. so first allocate the maximum possible (64K), then,
    // after building the DACL we'll shrink it.
    //
    *pdwAcl5Len = MQSEC_MAX_ACL_SIZE;

    //
    // BUGBUG- is there an header file with the guid definitions ?
    // This is the guid of the CN property.
    //
    PTSTR  pwszCnGuid = {L"bf96793f-0de6-11d0-a285-00aa003049e2"};
    GUID   guidCN;
    RPC_STATUS status = UuidFromString(pwszCnGuid, &guidCN);
	DBG_USED(status);
    ASSERT(status == RPC_S_OK);

    if (pAcl4)
    {
        ASSERT(IsValidAcl(pAcl4));
    	*pfAlreadyNT5 =  (pAcl4->AclRevision == ACL_REVISION_DS);
    }

    BOOL fDeniedAce = FALSE;
    ASSERT(!(*pfSystemAce));
    ASSERT(!(*pfComputerAce));

    if (!pComputerSid)
    {
        //
        // If we don't have a computer sid, then don't look for it.
        // that's the reason for the TRUE value here.
        //
        *pfComputerAce = TRUE;
    }
    else
    {
        ASSERT(dwObjectType == MQDS_MACHINE);
    }

	if (*pfAlreadyNT5 && pAcl4)
    {
        BOOL fAllPresent = _CheckForMandatoryACEs( 
								pAcl4,
								pComputerSid,
								&guidCN,
								&fDeniedAce,
								pfSystemAce,
								pfComputerAce 
								);
        if (fAllPresent)
        {
            //
            // we're just copying old ACL into new buffer. No change
            // in size.
            //
            *pdwAcl5Len = pAcl4->AclSize;
            *pfOnlyCopy = TRUE;
        }
    }

    *ppAcl5 = (PACL) new BYTE[*pdwAcl5Len];
    BOOL f = InitializeAcl(*ppAcl5, *pdwAcl5Len, ACL_REVISION_DS);
    ASSERT(f);

    if (!fDeniedAce)
    {
        ASSERT(!(*pfOnlyCopy));

        f = AddAccessDeniedObjectAce( 
				*ppAcl5,
				ACL_REVISION_DS,
				0,
				RIGHT_DS_WRITE_PROPERTY,
				&guidCN,
				NULL,
				g_pWorldSid
				);

        ASSERT(f);
    }

	if (*pfAlreadyNT5 && pAcl4)
    {
        //
        // OK, now copy all ACEs from old DACL to new one.
        //
        PVOID  pACE5 = NULL;
        f = FindFirstFreeAce( *ppAcl5, &pACE5);
        ASSERT(f);

        DWORD dwCopySize = pAcl4->AclSize - sizeof(ACL);
        BYTE *pACE4 = ((BYTE*) pAcl4) + sizeof(ACL);
        memcpy(pACE5, pACE4, dwCopySize);

        //
        // Update the ACL header.
        //
        ASSERT(((*ppAcl5)->AceCount) <= 1);
        (*ppAcl5)->AceCount = (*ppAcl5)->AceCount + pAcl4->AceCount;

#ifdef _DEBUG
        if (*pfOnlyCopy)
        {
            //
            // nothing changed in the ACL. Assert new one is same as old one.
            //
            ASSERT(memcmp(pAcl4, *ppAcl5, pAcl4->AclSize) == 0);
        }
#endif
    }

    return MQSec_OK;
}

//+----------------------------
//
//  BOOL  _IsNewNt4Sid()
//
//+----------------------------

static
BOOL  
_IsNewNt4Sid( 
	ACCESS_ALLOWED_ACE*   pAce,
	SID                 **ppSids,
	DWORD                *pdwNumofSids 
	)
{
    PSID pSid = (PSID) &(pAce->SidStart);
    ASSERT(IsValidSid(pSid));

    BOOL fFound = FALSE;
    for (DWORD j = 0; j < *pdwNumofSids; j++)
    {
        PSID pSidOld = ppSids[j];

        if (EqualSid(pSid, pSidOld))
        {
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        //
        // New sid.
        //
        DWORD dwSize = GetLengthSid(pSid);
        ASSERT(dwSize);

        SID *pNewSid = (SID*) new BYTE[dwSize];
        BOOL f = CopySid(dwSize, pNewSid, pSid);
		DBG_USED(f);
        ASSERT(f);

        DWORD dwIndex = *pdwNumofSids;
        ppSids[dwIndex] = pNewSid;
        *pdwNumofSids = dwIndex + 1;
    }

    return !fFound;
}

//+---------------------------------------------
//
//  static DWORD  _MapNt4RightsToNt5Ace()
//
//+---------------------------------------------

static
DWORD 
_MapNt4RightsToNt5Ace( 
	IN DWORD  dwObjectType,
	IN DWORD  dwMSMQRights 
	)
{
    if (dwMSMQRights == 0)
    {
        return 0;
    }

    DWORD dwMask = 0;

    if ((dwMSMQRights & g_dwFullControlNT4[ dwObjectType ]) ==
                                      g_dwFullControlNT4[ dwObjectType ])
    {
        //
        // map incoming bits to "full control". Ignore bits that are not
        // relevnat to MSMQ. When using msmq1.0 mqxplore, we can be sure
        // that nt4 format "full control" is indeed what we expect. But we
        // can't be sure for user code or nt5 ui. So to be on the safe side,
        // we just ignore extra bits that have no meaning for msmq.
        //
        dwMask = GENERIC_ALL_MAPPING;
    }
    else
    {
        //
        // Handle MSMQ1.0 specific rights which map to DS specific rights.
        //
        DWORD  *pdwMap = g_padwRightsMap4to5[dwObjectType];
        ASSERT(pdwMap);

        DWORD dwRightsIn =  dwMSMQRights;

        for (DWORD j = 0; j < NUMOF_MSMQ_SPECIFIC_RIGHTS; j++)
        {
            DWORD dwRight =  dwMSMQRights & 0x01;
            if (dwRight)
            {
                dwMask |= pdwMap[j];
            }
            dwMSMQRights >>= 1;
        }

        //
        // Copy the standard rights.
        //
        dwMSMQRights = dwRightsIn;
        DWORD dwStandard = dwMSMQRights & STANDARD_RIGHTS_ALL;
        dwMask |= dwStandard;
    }

    return dwMask;
}

//+--------------------------------
//
//  _BuildNt5ObjAce()
//
//+--------------------------------

static
HRESULT
_BuildNt5ObjAce( 
	DWORD  dwObjectType,
	BYTE   bType,
	BOOL   fSuccess,
	BOOL   fFail,
	PSID   pSid,
	DWORD  dwMSMQRights,
	PACL   pAcl5 
	)
{
    if (dwMSMQRights == g_dwFullControlNT4[dwObjectType])
    {
        //
        // for full-control ace, object aces are not needed.
        //
        return MQSec_OK;
    }

    DWORD dwErr = 0;
    DWORD dwMask = MSMQ_EXTENDED_RIGHT_MASK;

    struct RIGHTSMAP  *psMap = g_psExtendRightsMap5to4[dwObjectType];
    DWORD dwSize = g_pdwExtendRightsSize5to4[dwObjectType];

	//
	// The user can supply 0 rights. this is strange but acceptable
	//
//    ASSERT(dwMSMQRights != 0);
    DWORD dwMSMQBit = 0x01;

    for (DWORD j = 0; j < NUMOF_MSMQ_SPECIFIC_RIGHTS; j++)
    {
        DWORD dwRight =  dwMSMQRights & 0x01;
        if (dwRight)
        {
            for (DWORD k = 0; k < dwSize; k++)
            {
                if (psMap[k].dwPermission4to5 == dwMSMQBit)
                {
                    GUID *pRight = &(psMap[k].guidRight);

                    SetLastError(0);
                    BOOL f = FALSE;
                    if (bType == ACCESS_ALLOWED_ACE_TYPE)
                    {
                        ASSERT(!fFail && !fSuccess);
                        f = AddAccessAllowedObjectAce( 
								pAcl5,
								ACL_REVISION_DS,
								0,
								dwMask,
								pRight,
								NULL,
								pSid 
								);
                    }
                    else if (bType == ACCESS_DENIED_ACE_TYPE)
                    {
                        ASSERT(!fFail && !fSuccess);
                        f = AddAccessDeniedObjectAce( 
								pAcl5,
								ACL_REVISION_DS,
								0,
								dwMask,
								pRight,
								NULL,
								pSid 
								);
                    }
                    else if (bType == SYSTEM_AUDIT_ACE_TYPE)
                    {
                        ASSERT(fFail || fSuccess);
                        f = AddAuditAccessObjectAce( 
								pAcl5,
								ACL_REVISION_DS,
								0,
								dwMask,
								pRight,
								NULL,
								pSid,
								fSuccess,
								fFail 
								);
                    }
                    else
                    {
                        ASSERT(0);
                    }
                    dwErr = GetLastError();
                    ASSERT(f);
                    if (!f)
                    {
                        LogNTStatus(dwErr, s_FN, 25);
                    }
                }
            }
        }

        dwMSMQRights >>= 1;
        dwMSMQBit <<= 1;
    }

    return MQSec_OK;
}

//+-------------------------------
//
//  void _SetAuditMasks()
//
//+-------------------------------

inline 
static
void 
_SetAuditMasks( 
	IN  SYSTEM_AUDIT_ACE *pAce,
	OUT ACCESS_MASK      *pdwFail,
	OUT ACCESS_MASK      *pdwSuccess 
	)
{
    BYTE bFlags = pAce->Header.AceFlags;

    if (bFlags & FAILED_ACCESS_ACE_FLAG)
    {
        *pdwFail = *pdwFail | pAce->Mask;
    }

    if (bFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
    {
        *pdwSuccess = *pdwSuccess | pAce->Mask;
    }
}

//+---------------------------------------------
//
//  static HRESULT _ConvertSaclToNT5Format()
//
//+---------------------------------------------

static
HRESULT 
_ConvertSaclToNT5Format( 
	IN  DWORD   dwObjectType,
	IN  PACL    pAcl4,
	OUT DWORD  *pdwAcl5Len,
	OUT PACL   *ppAcl5,
	OUT BOOL   *pfAlreadyNt5 
	)
{
    ASSERT(IsValidAcl(pAcl4));
    HRESULT hr = MQSec_OK;

	BOOL fAlreadyNT5 =  (pAcl4->AclRevision == ACL_REVISION_DS);
    *pfAlreadyNt5 = fAlreadyNT5;
    DWORD dwAclSize = (DWORD) pAcl4->AclSize;

	if (fAlreadyNT5)
    {
        //
        // Just copy the SACL to a new buffer.
        //
        *pdwAcl5Len = dwAclSize;
        *ppAcl5 = (PACL) new BYTE[*pdwAcl5Len];
        memcpy(*ppAcl5, pAcl4, *pdwAcl5Len);
        return MQSec_OK;
    }

    //
    // Allocate large buffer. We'll later shrink it.
    //
    *pdwAcl5Len = MQSEC_MAX_ACL_SIZE;
    *ppAcl5 = (PACL) new BYTE[*pdwAcl5Len];
    BOOL f = InitializeAcl(*ppAcl5, *pdwAcl5Len, ACL_REVISION_DS);
    ASSERT(f);

    //
    // First, group aces by SID, then by audit type (fail or success).
    //
    // We build an array of SIDs that we handled up to now. We combine
    // aces of same sid into one ace. This operation does not change the
    // semantic of the acl, just make it more efficient.
    //
	DWORD dwNumberOfACEs = (DWORD) pAcl4->AceCount;
    SID  **ppSids4 = (SID**) new PSID[dwNumberOfACEs];
    aPtrs<SID> apSids(ppSids4, dwNumberOfACEs);
    DWORD    dwNumSids = 0;

    DWORD i = 0;
    DWORD iFirst = i;

    do
    {
	    SYSTEM_AUDIT_ACE *pAce;
        if (GetAce(pAcl4, i, (LPVOID* )&(pAce)) == FALSE)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while converting SACL from NT4 format. %!winerr!"), i, GetLastError()));
            return MQSec_E_SDCONVERT_GETACE ;
        }

        if (!_IsNewNt4Sid( 
				(ACCESS_ALLOWED_ACE*) pAce,
				ppSids4,
				&dwNumSids 
				))
        {
            i++;
            continue;
        }

        //
        // First ace in the group. Now look for contigous aces with same sid.
        //
        iFirst = i;
        DWORD iLast = i;
        PSID pSid = (PSID) &(pAce->SidStart);

        ACCESS_MASK  dwMaskFail = 0;
        ACCESS_MASK  dwMaskSuccess = 0;
        _SetAuditMasks(pAce, &dwMaskFail, &dwMaskSuccess);

        i++;
        while (i < dwNumberOfACEs)
        {
            if (GetAce(pAcl4, i, (LPVOID* )&(pAce)) == FALSE)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while looking for contigues ACE in the group. %!winerr!"), i, GetLastError()));
                return MQSec_E_SDCONVERT_GETACE ;
            }

            PSID pPresentSid = (PSID) &(pAce->SidStart);
            if (EqualSid(pSid, pPresentSid))
            {
                _SetAuditMasks(pAce, &dwMaskFail, &dwMaskSuccess);
                iLast = i;
                i++;
            }
            else
            {
                break;
            }
        }

        //
        // Now we have a group of aces of same SID, and we have the masks.
        //
        BOOL fBuildObjAce = FALSE;
        do
        {
            if (fBuildObjAce)
            {
                if (dwMaskSuccess != 0)
                {
                    hr = _BuildNt5ObjAce( 
							dwObjectType,
							SYSTEM_AUDIT_ACE_TYPE,
							TRUE,
							(dwMaskFail == dwMaskSuccess),
							pSid,
							dwMaskSuccess,
							*ppAcl5 
							);
                }

                if ((dwMaskFail != 0) && (dwMaskFail != dwMaskSuccess))
                {
                    hr = _BuildNt5ObjAce( 
							dwObjectType,
							SYSTEM_AUDIT_ACE_TYPE,
							FALSE,    // success
							TRUE,     // failure
							pSid,
							dwMaskFail,
							*ppAcl5 
							);
                }
            }
            else
            {
                DWORD dwMask = 0;

                if (dwMaskSuccess != 0)
                {
                    dwMask = _MapNt4RightsToNt5Ace(
								dwObjectType,
								dwMaskSuccess 
								);
                    if (dwMask != 0)
                    {
                        BOOL f = AddAuditAccessAce( 
									*ppAcl5,
									ACL_REVISION_DS,
									dwMask,
									pSid,
									TRUE,     // success
									(dwMaskFail == dwMaskSuccess) 
									);

						DBG_USED(f);
						ASSERT(f);
                    }
                }

                if ((dwMaskFail != 0) && (dwMaskFail != dwMaskSuccess))
                {
                    dwMask = _MapNt4RightsToNt5Ace( 
									dwObjectType,
									dwMaskFail 
									);

                    if (dwMask != 0)
                    {
                        f = AddAuditAccessAce( 
								*ppAcl5,
								ACL_REVISION_DS,
								dwMask,
								pSid,
								FALSE,     // success
								TRUE		// failure
								);   
                    }
                }
            }

            fBuildObjAce = !fBuildObjAce;
        }
        while (fBuildObjAce);
    }
    while (i < dwNumberOfACEs);

    BOOL fShrink = _ShrinkAcl(ppAcl5, pdwAcl5Len);
	DBG_USED(fShrink);
    ASSERT(fShrink);

    return MQSec_OK;
}

//+--------------------------------
//
//  _BuildNt5Ace()
//
//+---------------------------------------------------------------------

static
HRESULT 
_BuildNt5Ace( 
	DWORD  dwObjectType,
	BYTE   bType,
	PSID   pSid,
	DWORD  dwMSMQRights,
	PACL   pAcl5 
	)
{
    DWORD dwMask = _MapNt4RightsToNt5Ace( 
						dwObjectType,
						dwMSMQRights 
						);

    if (dwMask != 0)
    {
        //
        // Add MSMQ2.0 (NT5 DS) ACE.
        //
        BOOL f = FALSE;
        if (bType == ACCESS_ALLOWED_ACE_TYPE)
        {
            f = AddAccessAllowedAce( 
					pAcl5,
					ACL_REVISION_DS,
					dwMask,
					pSid 
					);
        }
        else if (bType == ACCESS_DENIED_ACE_TYPE)
        {
            f = AddAccessDeniedAce( 
					pAcl5,
					ACL_REVISION_DS,
					dwMask,
					pSid
					);
        }
        else
        {
            ASSERT(0);
        }
        ASSERT(f);
        return MQSec_OK;
    }
    else
    {
        return LogHR(MQSec_E_CANT_MAP_NT5_RIGHTS, s_FN, 70);
    }
}

//+---------------------------------------
//
//  HRESULT _ConvertGroupOfDaclAces()
//
//  convert a group of ACEs, all of them having same type.
//
//+---------------------------------------

static
HRESULT 
_ConvertGroupOfDaclAces( 
	DWORD  dwObjectType,
	PACL   pAcl4,
	DWORD  iFirst,
	DWORD  iLast,
	PACL   pAcl5 
	)
{
    HRESULT hr = MQSec_OK;
	DWORD   dwNumberOfACEs = iLast - iFirst + 1;

    BOOL fBuildObjAce = FALSE;

    //
    // for each type (allow, deny, audit), the canonical form on NT5 is
    // first to put all ace then all object aces. So we have two phases:
    // one for ace, then the loop run again for obj aces.
    //

    do
    {
        //
        // We build an array of SIDs that we handled up to now. We combine
        // aces of same sid into one ace. This operation does not change the
        // semantic of the acl, just make it more efficient.
        //
        SID  **ppSids4 = (SID**) new PSID[dwNumberOfACEs];
        aPtrs<SID> apSids(ppSids4, dwNumberOfACEs);
        DWORD    dwNumSids = 0;

        DWORD i = iFirst;

        do
        {
	        ACCESS_ALLOWED_ACE *pAce;
            if (GetAce(pAcl4, i, (LPVOID* )&(pAce)) == FALSE)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while combining same SID. %!winerr!"), i, GetLastError()));
                return MQSec_E_SDCONVERT_GETACE;
            }

            if (!_IsNewNt4Sid( 
					pAce,
					ppSids4,
					&dwNumSids 
					))
            {
                i++;
                continue;
            }

            //
            // this ace start a group of aces for a given sid.
            // on MSMQ1.0 we don't support inheritance of ace, so just OR the
            // masks of all  aces of this sid and create a NT5 ace.
            //
            BYTE bType = pAce->Header.AceType;
            PSID pSid = (PSID) &(pAce->SidStart);
            DWORD dwMSMQRights = pAce->Mask;

            DWORD j = i++;

            while (j <= iLast)
            {
                if (GetAce(pAcl4, j, (LPVOID* )&(pAce)) == FALSE)
                {
                    DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while calculating NT5 ACE rights. %!winerr!"), i, GetLastError()));
                    return MQSec_E_SDCONVERT_GETACE;
                }

                PSID pPresentSid = (PSID) &(pAce->SidStart);
                if (EqualSid(pSid, pPresentSid))
                {
                    dwMSMQRights |= pAce->Mask;
                }
                j++;
            }

            if (fBuildObjAce)
            {
                hr = _BuildNt5ObjAce( 
							dwObjectType,
							bType,
							FALSE,
							FALSE,
							pSid,
							dwMSMQRights,
							pAcl5 
							);
            }
            else
            {
                hr = _BuildNt5Ace( 
							dwObjectType,
							bType,
							pSid,
							dwMSMQRights,
							pAcl5 
							);
            }
        }
        while (i <= iLast);

        fBuildObjAce = !fBuildObjAce;
    }
    while (fBuildObjAce);

    return MQSec_OK;
}

//+-----------------------------------------------------------------------
//
//  static HRESULT _ConvertDaclToNT5Format()
//
//  Parameters:
//      pfAlreadyNt5 - on input: status of SACL (TRUE if SACL is in nt5
//          format, FALSE otherwise).
//                     on return- status of DACL.
//
//+-----------------------------------------------------------------------

static
HRESULT 
_ConvertDaclToNT5Format( 
	IN  DWORD     dwObjectType,
	IN  PSID      pComputerSid,
	IN  PACL      pAcl4,
	OUT DWORD    *pdwAcl5Len,
	OUT PACL     *ppAcl5,
	IN OUT BOOL  *pfAlreadyNt5 
	)
{
    if (!pAcl4)
    {
        //
        // On NT4, NULL DACL mean full control to everyone.
        // From MSDN, AccessCheck():
        //    If the security descriptor's DACL is NULL, the AccessStatus
        //    parameter returns TRUE indicating that the client has the requested
        //    access
        //
        // Because the DACL is NULL, we don't have the revision flag, that
        // can tell us if caller meant NT4 format or NT5/DS format. So,
        // for backward compatibility, we'll translate this to full control
        // to everyone.
        // However, if SACL was Nt5 format then we don't add the full-control
        // ace. We assume the caller want nt5 semantic.
        //
    }

    HRESULT hr = MQSec_OK;

    BOOL fShrink ;
	BOOL fAlreadyNT5 = *pfAlreadyNt5;
    BOOL fOnlyCopy;
    BOOL fSystemAce = FALSE;
    BOOL fComputerAce = FALSE;

    hr = _AddMandatoryDenyACEs( 
				dwObjectType,
				pComputerSid,
				pAcl4,
				pdwAcl5Len,
				ppAcl5,
				&fAlreadyNT5,
				&fOnlyCopy,
				&fSystemAce,
				&fComputerAce 
				);

    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

	if (fAlreadyNT5)
    {
        *pfAlreadyNt5 = TRUE;
        if (!fOnlyCopy)
        {
            hr = _AddMandatoryAllowACEs( 
						dwObjectType,
						pComputerSid,
						*ppAcl5,
						fSystemAce,
						fComputerAce 
						);
            ASSERT(SUCCEEDED(hr));

            fShrink = _ShrinkAcl(ppAcl5, pdwAcl5Len);
            ASSERT(fShrink);
        }
        ASSERT(IsValidAcl(*ppAcl5));
        return MQSec_OK;
    }
    *pfAlreadyNt5 = FALSE;

    DWORD dwNumberOfACEs = 0;

    if (pAcl4)
    {
        //
        // We're not assuming that the input acl is canonical. So we'll
        // handle groups of identical aces (i.e., aces of same type) at a
        // time. Each group will be converted to canonical NT5 format. So
        // if input is canonical, output will be canonical too.
        //
    	dwNumberOfACEs = (DWORD) pAcl4->AceCount;
    }
    else
    {
        ASSERT(*pfAlreadyNt5 == FALSE);

        //
        // NULL DACL. Transform into full control to everyone and anonymous.
		//

		//
		// everyone full control
        //
        BOOL f = AddAccessAllowedAce( 
					*ppAcl5,
					ACL_REVISION_DS,
					GENERIC_ALL_MAPPING,
					g_pWorldSid 
					);

		DBG_USED(f);
		ASSERT(f);

		//
		// Anonymous full control
		//
        f = AddAccessAllowedAce( 
					*ppAcl5,
					ACL_REVISION_DS,
					GENERIC_ALL_MAPPING,
					g_pAnonymSid
					);

        ASSERT(f);
    }

    if (dwNumberOfACEs != 0)
    {
        DWORD i = 0;

        do
        {
            //
            // first ace in the group.
            //
	        ACCESS_ALLOWED_ACE *pAce;
            if (GetAce(pAcl4, i, (LPVOID* )&(pAce)) == FALSE)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while converting DACL from NT4 format. %!winerr!"), i, GetLastError()));
                return MQSec_E_SDCONVERT_GETACE;
            }

            DWORD iFirst = i;
            DWORD iLast = i;
            BYTE bType = pAce->Header.AceType;
            i++;

            //
            // now look for other aces with same type.
            //
            while (i < dwNumberOfACEs)
            {
                if (GetAce(pAcl4, i, (LPVOID* )&(pAce)) == FALSE)
                {
                    DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get ACE (index=%lu) while looking for other ACEs with same type. %!winerr!"), i, GetLastError()));
                    return MQSec_E_SDCONVERT_GETACE ;
                }
                if (bType == pAce->Header.AceType)
                {
                    iLast = i;
                    i++;
                }
                else
                {
                    break;
                }
            }

            //
            // Handle all aces from iFirst to iLast.
            //
            hr = _ConvertGroupOfDaclAces( 
						dwObjectType,
						pAcl4,
						iFirst,
						iLast,
						*ppAcl5 
						);
        }
        while (i < dwNumberOfACEs);
    }

    hr = _AddMandatoryAllowACEs( 
				dwObjectType,
				pComputerSid,
				*ppAcl5,
				fSystemAce,
				fComputerAce 
				);

    ASSERT(SUCCEEDED(hr));

    fShrink = _ShrinkAcl(ppAcl5, pdwAcl5Len);
    ASSERT(fShrink);

    return MQSec_OK;
}

//+-----------------------------------------------------------------
//
//  HRESULT MQSec_ConvertSDToNT5Format()
//
//  Description: Convert a security descriptor from NT4 format to NT5
//      compatiblae format. Then add an DENIED_OBJECT_ACE, to deny
//      everyone the permission to change the "cn" attribute.
//      If security descriptor is already in NT5 format, then just add
//      the DENIED ace.
//
//  Parameters:
//      eUnDefaultDacl- When "e_MakeDaclNonDefaulted", the DaclDefaulted
//          flag will be set to FALSE. This is necessary when using
//          IDirectoryObject->CreateDSObject(). Otherwise, LDAP server will
//          ignore our dacl.
//      pComputerSid- SID of computer object. This sid must have read/write
//          rights on the msmqConfiguration object, in order for the msmq
//          service on that computer to boot correctly.
//
//+-----------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_ConvertSDToNT5Format(
	IN  DWORD                 dwObjectType,
	IN  SECURITY_DESCRIPTOR  *pSD4,
	OUT DWORD                *pdwSD5Len,
	OUT SECURITY_DESCRIPTOR **ppSD5,
	IN  enum  enumDaclDefault eUnDefaultDacl,
	IN  PSID                  pComputerSid 
	)
{
    HRESULT hr = MQSec_OK;

    if (!pSD4)
    {
        ASSERT(0) ;
        return LogHR(MQSec_E_NULL_SD, s_FN, 130);
    }
    else if (!IsValidSecurityDescriptor(pSD4))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't convert an invalid NT4 Security Descriptor")));
        ASSERT(0);
        return MQSec_E_SD_NOT_VALID;
    }

    //
    // Make sure input descriptor is self-relative.
    //
    DWORD dwRevision = 0;
    SECURITY_DESCRIPTOR_CONTROL sdC;
    BOOL f = GetSecurityDescriptorControl(pSD4, &sdC, &dwRevision);
	DBG_USED(f);
    ASSERT(f);

    if (!(sdC & SE_SELF_RELATIVE))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't convert a non self-relative NT4 Security Descriptor")));
        return MQSec_E_NOT_SELF_RELATIVE;
    }

    if (eUnDefaultDacl == e_MakeDaclNonDefaulted)
    {
        //
        // Mark the DACL as non-defaulted. that's a hack, not supported
        // by Win32 api.
        //
        ASSERT(pSD4->Control == sdC);
        sdC &= ~SE_DACL_DEFAULTED;
        pSD4->Control = sdC;
    }

    if ((dwObjectType != MQDS_QUEUE)   &&
        (dwObjectType != MQDS_MACHINE) &&
        (dwObjectType != MQDS_MQUSER)  &&
        (dwObjectType != MQDS_SITE)    &&
        (dwObjectType != MQDS_CN)      &&
        (dwObjectType != MQDS_ENTERPRISE))
    {
        //
        // BUGBUG Temporary.
        //
        return LogHR(MQSec_I_SD_CONV_NOT_NEEDED, s_FN, 160);
    }

    DWORD   dwErr = 0;
    SECURITY_DESCRIPTOR sd;

    BOOL bRet = InitializeSecurityDescriptor( 
					&sd,
					SECURITY_DESCRIPTOR_REVISION 
					);
    if (!bRet)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't initialize security descriptor while converting from NT4 to NT5 format. %!winerr!"), GetLastError()));
        return MQSec_E_INIT_SD;
    }

    //
    // Handle owner.
    //
    PSID pOwner = NULL;
    BOOL bOwnerDefaulted;

    bRet = GetSecurityDescriptorOwner( 
				pSD4,
				&pOwner,
				&bOwnerDefaulted 
				);
    if (bRet && pOwner)
    {
        ASSERT(IsValidSid(pOwner));

        //
        // BUGBUG
        // If this is a local user, set the owner to be the anonymous
        // logon user.
        //
        bRet = SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted);
        ASSERT(bRet);
    }
    else
    {
        //
        // that's legitimate. When fixing 5286, we remove the owner component
        // from the security descriptor, unless caller supply his own
        // descriptor. We let the active directory server to add the owner
        // by itself.
        //
        ASSERT(bRet);
    }

    //
    // Handle group
    //
    PSID pGroup = NULL;
    BOOL bGroupDefaulted;

    bRet = GetSecurityDescriptorGroup( 
				pSD4,
				&pGroup,
				&bGroupDefaulted 
				);

    if (bRet && pGroup)
    {
        ASSERT(IsValidSid(pGroup));

        bRet = SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted);
        ASSERT(bRet);
    }
    else
    {
        ASSERT(bRet) ;
        ASSERT((dwObjectType == MQDS_MQUSER) ||
               (dwObjectType == MQDS_QUEUE) ||
               (dwObjectType == MQDS_SITE) ||
               (dwObjectType == MQDS_MACHINE));
    }

    //
    // Handle SACL
    //
    BOOL  bPresent;
    BOOL  bDefaulted;
    DWORD dwAclLen;
    PACL  pAcl4;
    P<ACL> pDacl5 = NULL;
    P<ACL> pSacl5 = NULL;
    BOOL fSaclAlreadyNt5 = FALSE;

    bRet = GetSecurityDescriptorSacl( 
				pSD4,
				&bPresent,
				&pAcl4,
				&bDefaulted 
				);

    ASSERT(bRet);

    hr = MQSec_OK;
    if (bPresent)
    {
        if (pAcl4)
        {
	        DWORD dwNumberOfACEs = (DWORD) pAcl4->AceCount;
        	if (dwNumberOfACEs == 0)
            {
                //
                // this may happen in mmc, when you "protect" the
                // sacl and remove inherited ACE. If sacl remain without
                // aces, then we get here. So actually, we don't have
                // any sacl.
                //
                bPresent = FALSE;
            }
            else
            {
                hr = _ConvertSaclToNT5Format( 
							dwObjectType,
							pAcl4,
							&dwAclLen,
							&pSacl5,
							&fSaclAlreadyNt5 
							);

                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 180);
                }
                ASSERT(IsValidAcl(pSacl5));
            }
        }
        else
        {
            //
            // See secd5to4.cpp for explanation.
            //
            bPresent = FALSE;
        }
    }

    bRet = SetSecurityDescriptorSacl( 
				&sd,
				bPresent,
				pSacl5,
				bDefaulted
				);

    ASSERT(bRet);

    //
    // Handle inheritance. If descriptor was in Nt4 format, then enable
    // inheritance by default.
    //
    if (fSaclAlreadyNt5 || (sdC & SE_SACL_PROTECTED))
    {
        //
        // Propagate the control word from input descriptor.
        // The mmc always return sacl with nt4 version, so check the
        // protected flag too. this flag is specific to win2k.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask =  SE_SACL_AUTO_INHERIT_REQ |
                                              SE_SACL_AUTO_INHERITED   |
                                              SE_SACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = sdC & scMask;

        SetSecurityDescriptorControl(&sd, scMask, scSet);
    }
    else
    {
        //
        // sacl was nt4. Enable inheritance.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask = SE_SACL_AUTO_INHERIT_REQ | SE_SACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = SE_SACL_AUTO_INHERIT_REQ;

        SetSecurityDescriptorControl(&sd, scMask, scSet);
    }

    //
    // Handle DACL
    //
    //
    bRet = GetSecurityDescriptorDacl( 
				pSD4,
				&bPresent,
				&pAcl4,
				&bDefaulted 
				);

    ASSERT(bRet);

    hr = MQSec_OK;
    BOOL fDaclAlreadyNt5 = fSaclAlreadyNt5;

    if (bPresent)
    {
        hr = _ConvertDaclToNT5Format( 
				dwObjectType,
				pComputerSid,
				pAcl4,
				&dwAclLen,
				&pDacl5,
				&fDaclAlreadyNt5 
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 190);
        }
    }

    bRet = SetSecurityDescriptorDacl(
				&sd,
				bPresent,
				pDacl5,
				bDefaulted
				);

    ASSERT(bRet);

    //
    // Handle inheritance. If descriptor was in Nt4 format, then enable
    // inheritance by default.
    //
    if (fDaclAlreadyNt5)
    {
        //
        // Propagate the control word from input descriptor.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask =  SE_DACL_AUTO_INHERIT_REQ |
                                              SE_DACL_AUTO_INHERITED   |
                                              SE_DACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = sdC & scMask;

        SetSecurityDescriptorControl(&sd, scMask, scSet);
    }
    else
    {
        //
        // dacl was nt4. Enable inheritance.
        //
        SECURITY_DESCRIPTOR_CONTROL scMask = SE_DACL_AUTO_INHERIT_REQ | SE_DACL_PROTECTED;
        SECURITY_DESCRIPTOR_CONTROL scSet = SE_DACL_AUTO_INHERIT_REQ;

        SetSecurityDescriptorControl(&sd, scMask, scSet);
    }

    //
    // Convert the descriptor to a self relative format.
    //
    DWORD dwLen = 0;
    bRet = MakeSelfRelativeSD(&sd, NULL, &dwLen);
    dwErr = GetLastError();
    if (!bRet && (dwErr == ERROR_INSUFFICIENT_BUFFER))
    {
        *ppSD5 = (SECURITY_DESCRIPTOR*)new char[dwLen];
        bRet = MakeSelfRelativeSD(&sd, *ppSD5, &dwLen);
        ASSERT(bRet);
    }
    else
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't get the SD length required to convert NT5 SD to self relative. %!winerr!"), dwErr));
        return MQSec_E_MAKESELF_GETLEN;
    }

    *pdwSD5Len = dwLen;
    return MQSec_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\certifct.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: certifct.h

Abstract:

    main header for certificates handling code.

Author:

    Doron Juster  (DoronJ)  25-May-1998

--*/

//+-------------------------------------------
//
//  Internal functions.
//
//+-------------------------------------------

BOOL _CryptAcquireVerContext( HCRYPTPROV *phProv ) ;

HRESULT _CloneCertFromStore ( OUT CMQSigCertificate **ppCert,
                              HCERTSTORE              hStore,
                              IN  LONG                iCertIndex ) ;

//+-------------------------------------------

#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

#define ASSERT_CERT_INFO                \
    ASSERT(m_pCertInfo) ;               \
    if (!m_pCertInfo)                   \
    {                                   \
        return MQSec_E_INVALID_CALL ;   \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\rightsg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rightsg.h

Abstract:
    map NT5 rights guids to MSMQ1.0 permission bits.

Author:
    Doron Juster (DoronJ)  25-May-1998

Revision History:

--*/

//
// Map between extended rights guids (on NT5) to MSMQ1.0 specific rights.
//

struct RIGHTSMAP
{
    GUID  guidRight ;        // guid of NT5 DS extended right.
    DWORD dwPermission5to4 ; // NT5 guid is converted to this permission bits.
    DWORD dwPermission4to5 ; // MSMQ1.0 bit is converted to this extended right.
} ;

#if 0

Site
Following access right should be attached to "Site" object. it should be appear in the advance section.

Open Connector Queue
Entry name: msmq-Open-Conector
RightsGuid: b4e60130-df3f-11d1-9c86-006008764d0e
Display Name: Open Connector Queue
AppliesTo: bf967ab3-0de6-11d0-a285-00aa003049e2

#endif

//
// Map between DS specific rights and MSMQ1.0 specific rights. There
// are eight DS specific properties so all arrays size is 8.
// The index to this array is the DS specific right. The value in array
// is the MSMQ specific right. Separate maps for each MSMQ object.
// Value of 0 means there is no mapping.
//
//	ADS_RIGHT_DS_CREATE_CHILD	= 0x1,
//	ADS_RIGHT_DS_DELETE_CHILD	= 0x2,
//	ADS_RIGHT_ACTRL_DS_LIST  	= 0x4,
//	ADS_RIGHT_DS_SELF           = 0x8,
//	ADS_RIGHT_DS_READ_PROP      = 0x10,
//	ADS_RIGHT_DS_WRITE_PROP     = 0x20,
//	ADS_RIGHT_DS_DELETE_TREE	= 0x40,
//	ADS_RIGHT_DS_LIST_OBJECT	= 0x80
//	ADS_RIGHT_DS_CONTROL_ACCESS	= 0x100
//
// On Windows 2000, the "RIGHT_DS_CONTROL_ACCESS" bit in an ACE that is not
// OBJ-ACE mean that the sid has all the extended rights. So give it the
// proper msmq extended rights.
//
#define  QUEUE_EXTENDED_RIGHTS  ( MQSEC_DELETE_MESSAGE                 | \
                                  MQSEC_PEEK_MESSAGE                   | \
                                  MQSEC_WRITE_MESSAGE                  | \
                                  MQSEC_DELETE_JOURNAL_MESSAGE )

#define  MACHINE_EXTENDED_RIGHTS  ( MQSEC_DELETE_DEADLETTER_MESSAGE    | \
                                    MQSEC_PEEK_DEADLETTER_MESSAGE      | \
                                    MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE | \
                                    MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE )

#define  NUMOF_ADS_SPECIFIC_RIGHTS    9
#define  NUMOF_MSMQ_SPECIFIC_RIGHTS   8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\stdh_acs.cpp ===
//++
//
// Copyright (c) 1997-1999 Microsoft Coroporation
//
// Module Name  : stdh_acs.h
//
// Abstract     : Security related definitions
//
// History:  Doron Juster (DoronJ), Created
//
//--

#include <stdh_sec.h>
#include "acssctrl.h"

#include "stdh_acs.tmh"

GUID  g_guidCreateQueue =
  { 0x9a0dc343, 0xc100, 0x11d1,
                   { 0xbb, 0xc5, 0x00, 0x80, 0xc7, 0x66, 0x70, 0xc0 }} ;

//
// Map between NT5 DS extended rights and MSMQ1.0 specific rights.
// An extended right is a GUID which represent one MSMQ1.0 specific right.
//

struct RIGHTSMAP  sMachineRightsMap5to4[] = {

  { 0x4b6e08c0, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_DEADLETTER_MESSAGE,
    MQSEC_DELETE_DEADLETTER_MESSAGE },

  { 0x4b6e08c1, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_PEEK_DEADLETTER_MESSAGE,
    MQSEC_PEEK_DEADLETTER_MESSAGE },

  { 0x4b6e08c2, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE,
    MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE },

  { 0x4b6e08c3, 0xdf3c, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE,
    MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE }

                                 } ;

struct RIGHTSMAP  sQueueRightsMap5to4[] = {

  { 0x06bd3200, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_MESSAGE,
    MQSEC_DELETE_MESSAGE },

  { 0x06bd3201, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_PEEK_MESSAGE,
    MQSEC_PEEK_MESSAGE },

  { 0x06bd3202, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_WRITE_MESSAGE,
    MQSEC_WRITE_MESSAGE },

  { 0x06bd3203, 0xdf3e, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_RECEIVE_JOURNAL_MESSAGE,
    MQSEC_DELETE_JOURNAL_MESSAGE }

                                      } ;

struct RIGHTSMAP  sCnRightsMap5to4[] = {

  { 0xb4e60130, 0xdf3f, 0x11d1,
                   { 0x9c, 0x86, 0x00, 0x60, 0x08, 0x76, 0x4d, 0x0e },
    MQSEC_CN_OPEN_CONNECTOR,
    MQSEC_CN_OPEN_CONNECTOR }

    } ;

struct RIGHTSMAP  *g_psExtendRightsMap5to4[] = {
                                     NULL,
                                     sQueueRightsMap5to4,   // queue
                                     sMachineRightsMap5to4, // machine
                                     sCnRightsMap5to4,      // site
                                     NULL,                  // delete obj
                                     sCnRightsMap5to4,      // cn
                                     NULL,                  // enterprise
                                     NULL,                  // user
                                     NULL } ;               // site link

DWORD  g_pdwExtendRightsSize5to4[] = {
                                     0,
           sizeof(sQueueRightsMap5to4) /  sizeof(sQueueRightsMap5to4[0]),
           sizeof(sMachineRightsMap5to4) / sizeof(sMachineRightsMap5to4[0]),
           sizeof(sCnRightsMap5to4) / sizeof(sCnRightsMap5to4[0]),   // site
                                     0,                  // delete obj
          sizeof(sCnRightsMap5to4) / sizeof(sCnRightsMap5to4[0]),   // cn
                                     0,                  // enterprise
                                     0,                  // user
                                     0 } ;               // site link

//
// Map between NT5 DS specific rights and MSMQ1.0 specific rights.
// Index in this table is the NT5 DS specific right. See defintions of
// DS specific rights in permit.h
//

static DWORD  s_adwQueueRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_QUEUE_PROPERTIES,
                                      MQSEC_SET_QUEUE_PROPERTIES,
                                      0,
                                      0,
                                      QUEUE_EXTENDED_RIGHTS } ;

static DWORD  s_adwMachineRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      MQSEC_CREATE_QUEUE,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_MACHINE_PROPERTIES,
                                      MQSEC_SET_MACHINE_PROPERTIES,
                                      0,
                                      0,
                                      MACHINE_EXTENDED_RIGHTS } ;

static DWORD  s_adwEntRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_ENTERPRISE_PROPERTIES,
                                      MQSEC_SET_ENTERPRISE_PROPERTIES,
                                      0,
                                      0,
                                      0 } ;

static DWORD  s_adwSiteRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      MQSEC_CREATE_MACHINE,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_SITE_PROPERTIES,
                                      MQSEC_SET_SITE_PROPERTIES,
                                      0,
                                      0,
                                      0 } ;

static DWORD  s_adwCnRightsMap5to4[ NUMOF_ADS_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      MQSEC_GET_CN_PROPERTIES,
                                      MQSEC_SET_CN_PROPERTIES,
                                      0,
                                      0,
                                      0 } ;

DWORD  *g_padwRightsMap5to4[ ] = {
                              NULL,
                              s_adwQueueRightsMap5to4,   // queue
                              s_adwMachineRightsMap5to4, // machine
                              s_adwSiteRightsMap5to4,    // site
                              NULL,                      // delete obj
                              s_adwCnRightsMap5to4,      // cn
                              s_adwEntRightsMap5to4,     // enterprise
                              NULL,                      // user
                              NULL } ;                   // site link

//
// hold the "full control" bits for every object type in MSMQ1.0
//

DWORD  g_dwFullControlNT4[ ] = {
                              0,
                              MQSEC_QUEUE_GENERIC_ALL,       // queue
                              MQSEC_MACHINE_GENERIC_ALL,     // machine
                              MQSEC_SITE_GENERIC_ALL,        // site
                              0,                             // delete obj
                              MQSEC_CN_GENERIC_ALL,          // cn
                              MQSEC_ENTERPRISE_GENERIC_ALL,  // enterprise
                              0,                             // user
                              0 } ;                          // site link

//
// Map between NT4 MSMQ1.0 specific rights and NT5 DS specific rughts.
// Index in this table is the MSMQ1.0 specific right. See defintions of
// MSMQ specific rights in mqsec.h
//

static DWORD  s_adwQueueRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

static DWORD  s_adwMachineRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      RIGHT_DS_CREATE_CHILD,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY | RIGHT_DS_LIST_CONTENTS,
                                      0,
                                      0 } ;

static DWORD  s_adwEntRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

static DWORD  s_adwSiteRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      RIGHT_DS_CREATE_CHILD,
                                      RIGHT_DS_CREATE_CHILD,
                                      RIGHT_DS_CREATE_CHILD,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

static DWORD  s_adwCnRightsMap4to5[ NUMOF_MSMQ_SPECIFIC_RIGHTS ] = {
                                      0,
                                      0,
                                      0,
                                      0,
                                      RIGHT_DS_WRITE_PROPERTY,
                                      RIGHT_DS_READ_PROPERTY,
                                      0,
                                      0 } ;

DWORD  *g_padwRightsMap4to5[ ] = {
                              NULL,
                              s_adwQueueRightsMap4to5,   // queue
                              s_adwMachineRightsMap4to5, // machine
                              s_adwSiteRightsMap4to5,    // site
                              NULL,                      // delete obj
                              s_adwCnRightsMap4to5,      // cn
                              s_adwEntRightsMap4to5,     // enterprise
                              NULL,                      // user
                              NULL } ;                   // site link
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\acssctrl\secdscrp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: secdscrp.cpp

Abstract:
    Code to handle operations on security descriptor.
    First version taken from mqutil\secutils.cpp

Author:
    Doron Juster (DoronJ)  01-Jul-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "acssctrl.h"
#include <mqdsdef.h>
#include "..\inc\permit.h"
#include <mqsec.h>
#include <tr.h>

#include "secdscrp.tmh"

static WCHAR *s_FN=L"acssctrl/secdscrp";

const TraceIdEntry SecDscrp = L"MQSEC SECDSCRPT";

//
// Generic mappings of the various objects.
//
static GENERIC_MAPPING g_QueueGenericMapping;
static GENERIC_MAPPING g_MachineGenericMapping;
static GENERIC_MAPPING g_SiteGenericMapping;
static GENERIC_MAPPING g_CNGenericMapping;
static GENERIC_MAPPING g_EnterpriseGenericMapping;

//
// The computer generic mapping is used to check if user can create the
// msmqConfiguration object. this is part of setup and "join domain", and
// it solve bug 6294 and avoid the need for the "add-guid" permission.
//
static GENERIC_MAPPING g_ComputerGenericMapping;

//+----------------------------------------------------------------
//
// Function:   GetObjectGenericMapping()
//
// Description:
//      Get a pointer to the generic mapping of a certain object type.
//
// Parameter:
//      dwObjectType - The type of the object.
//
// Return Value:
//      A pointer to a GENERIC_MAPPING structure.
//
//+----------------------------------------------------------------

PGENERIC_MAPPING
GetObjectGenericMapping(
	DWORD dwObjectType
	)
{
    switch(dwObjectType)
    {
		case MQDS_QUEUE:
			return(&g_QueueGenericMapping);

		case MQDS_MACHINE:
		case MQDS_MSMQ10_MACHINE:
			return(&g_MachineGenericMapping);

		case MQDS_SITE:
			return(&g_SiteGenericMapping);

		case MQDS_CN:
			return(&g_CNGenericMapping);

		case MQDS_ENTERPRISE:
			return(&g_EnterpriseGenericMapping);

		case MQDS_COMPUTER:
			return(&g_ComputerGenericMapping);
    }

    ASSERT(FALSE);
    return(NULL);
}

//+--------------------------------------
//
//  void InitializeGenericMapping()
//
//+--------------------------------------

void InitializeGenericMapping()
{
    g_QueueGenericMapping.GenericRead = MQSEC_QUEUE_GENERIC_READ;
    g_QueueGenericMapping.GenericWrite = MQSEC_QUEUE_GENERIC_WRITE;
    g_QueueGenericMapping.GenericExecute = MQSEC_QUEUE_GENERIC_EXECUTE;
    g_QueueGenericMapping.GenericAll = MQSEC_QUEUE_GENERIC_ALL;

    g_MachineGenericMapping.GenericRead = MQSEC_MACHINE_GENERIC_READ;
    g_MachineGenericMapping.GenericWrite = MQSEC_MACHINE_GENERIC_WRITE;
    g_MachineGenericMapping.GenericExecute = MQSEC_MACHINE_GENERIC_EXECUTE;
    g_MachineGenericMapping.GenericAll = MQSEC_MACHINE_GENERIC_ALL;

    g_SiteGenericMapping.GenericRead = MQSEC_SITE_GENERIC_READ;
    g_SiteGenericMapping.GenericWrite = MQSEC_SITE_GENERIC_WRITE;
    g_SiteGenericMapping.GenericExecute = MQSEC_SITE_GENERIC_EXECUTE;
    g_SiteGenericMapping.GenericAll = MQSEC_SITE_GENERIC_ALL;

    g_CNGenericMapping.GenericRead = MQSEC_CN_GENERIC_READ;
    g_CNGenericMapping.GenericWrite = MQSEC_CN_GENERIC_WRITE;
    g_CNGenericMapping.GenericExecute = MQSEC_CN_GENERIC_EXECUTE;
    g_CNGenericMapping.GenericAll = MQSEC_CN_GENERIC_ALL;

    g_EnterpriseGenericMapping.GenericRead = MQSEC_ENTERPRISE_GENERIC_READ;
    g_EnterpriseGenericMapping.GenericWrite = MQSEC_ENTERPRISE_GENERIC_WRITE;
    g_EnterpriseGenericMapping.GenericExecute = MQSEC_ENTERPRISE_GENERIC_EXECUTE;
    g_EnterpriseGenericMapping.GenericAll = MQSEC_ENTERPRISE_GENERIC_ALL;

    g_ComputerGenericMapping.GenericRead = GENERIC_READ_MAPPING;
    g_ComputerGenericMapping.GenericWrite = GENERIC_WRITE_MAPPING;
    g_ComputerGenericMapping.GenericExecute = GENERIC_EXECUTE_MAPPING;
    g_ComputerGenericMapping.GenericAll = GENERIC_ALL_MAPPING;

}

//+-------------------------------------------------------------
//
//  HRESULT  MQSec_MakeSelfRelative()
//
//  Convert a security descriptor into self relative format.
//
//+-------------------------------------------------------------

HRESULT
APIENTRY
MQSec_MakeSelfRelative(
    IN  PSECURITY_DESCRIPTOR   pIn,
    OUT PSECURITY_DESCRIPTOR  *ppOut,
    OUT DWORD                 *pdwSize
	)
{
    HRESULT hr = MQSec_OK;
    DWORD dwLen = 0;
    BOOL fSucc = MakeSelfRelativeSD(
		            pIn,
		            NULL,
		            &dwLen
		            );

    DWORD dwErr = GetLastError();
    if (!fSucc && (dwErr == ERROR_INSUFFICIENT_BUFFER))
    {
        *ppOut = (PSECURITY_DESCRIPTOR) new char[dwLen];
        BOOL bRet = MakeSelfRelativeSD(pIn, *ppOut, &dwLen);

        ASSERT(bRet);
        if (!bRet)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to convert security descriptor to self-relative format. %!winerr!"), GetLastError()));
            return MQSec_E_CANT_SELF_RELATIVE;
        }
    }
    else
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't get the SD length required to convert SD to self-relative. %!winerr!"), dwErr));
        return MQSec_E_MAKESELF_GETLEN;
    }

    if (pdwSize)
    {
        *pdwSize = dwLen;
    }
    return LogHR(hr, s_FN, 30);
}

//+----------------------------------------------------------------------
//
// Function: MQSec_GetDefaultSecDescriptor()
//
// Description: Create a default security descriptor.
//
// Parameters:
//      dwObjectType - The type of the object (MSDS_QUEUE, ...).
//      ppSecurityDescriptor - A pointer to a buffer that receives the
//          pointer to the created security descriptor.
//      fImpersonate - Should be set to TRUE, when the function should be
//          called on behalf of an RPC call.
//      pInSecurityDescriptor - An optional parameter. Any specified part
//          of this parameter is put in the resulted security descriptor.
//      seInfoToRemove - Specify the components that the caller does not
//          want to be included in the output security descriptor.
//        Note: at present only owner, group and DACL are handled.
//
// Comments:
//      At present we create a descriptor with NT4 format. The MSMQ service
//      convert it to NT5 format before inserting in the NT5 DS.
//
//      If fImpersonate is set to true, the security descriptor will be
//      created acording to the user that originated the call via RPC
//
//      It is the responsibility of the calling code to free the allocated
//      memory for the security descriptor using delete.
//
//      CAUTION: If you change implementation here to use mqutil's registry
//      routines, make sure all clients of this routine are not broken,
//      especially in mqclus.dll (where registry access should be
//      synchronized).   (ShaiK, 20-Apr-1999)
//
//+----------------------------------------------------------------------

HRESULT
APIENTRY
MQSec_GetDefaultSecDescriptor(
	IN  DWORD                 dwObjectType,
	OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
	IN  BOOL                  fImpersonate,
	IN  PSECURITY_DESCRIPTOR  pInSecurityDescriptor,
	IN  SECURITY_INFORMATION  seInfoToRemove,
	IN  enum  enumDaclType    eDaclType
	)
{
    HRESULT hr = MQSec_OK;

    DWORD dwLen;
    BOOL bRet;
    SECURITY_DESCRIPTOR sd;
    BOOL bDefaulted;
    AP<char> ptu;
    AP<char> ptg;
    AP<char> DACL_buff;
    CAutoCloseHandle hUserToken;

    if (GetAccessToken(&hUserToken, fImpersonate) != ERROR_SUCCESS)
    {
        return  LogHR(MQSec_E_UNKNOWN, s_FN, 40);
    }

    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    PSID pOwner = NULL;
    PSID pGroup = NULL;
    BOOL bDaclPresent = FALSE;
    BOOL bOwnerDefaulted = FALSE;
    BOOL bGroupDefaulted = FALSE;

    if (pInSecurityDescriptor)
    {
        ASSERT(IsValidSecurityDescriptor(pInSecurityDescriptor));

        DWORD dwRevision;
        SECURITY_DESCRIPTOR_CONTROL sdcSrc;

        bRet = GetSecurityDescriptorControl(
					pInSecurityDescriptor,
					&sdcSrc,
					&dwRevision
					);
        ASSERT(bRet);

        //
        // Retrieve the values from the passed security descriptor.
        //
        PACL pDacl;
        PACL pSacl;

        bRet = GetSecurityDescriptorOwner(
					pInSecurityDescriptor,
					&pOwner,
					&bOwnerDefaulted
					);
        ASSERT(bRet);

        bRet = GetSecurityDescriptorGroup(
					pInSecurityDescriptor,
					&pGroup,
					&bGroupDefaulted
					);
        ASSERT(bRet);

        bRet = GetSecurityDescriptorDacl(
					pInSecurityDescriptor,
					&bDaclPresent,
					&pDacl,
					&bDefaulted
					);
        ASSERT(bRet);
        if (bDaclPresent)
        {
            //
            // In case a DACL exist, put it now in the result descriptor.
            //
            bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, bDefaulted);
            ASSERT(bRet);

            if (eDaclType == e_UseDefDaclAndCopyControl)
            {
                SECURITY_DESCRIPTOR_CONTROL scMask =
                                              SE_DACL_AUTO_INHERIT_REQ |
                                              SE_DACL_AUTO_INHERITED   |
                                              SE_DACL_PROTECTED;

                SECURITY_DESCRIPTOR_CONTROL sdc = sdcSrc & scMask;

                SetSecurityDescriptorControl(
					&sd,
					scMask,
					sdc
					);
            }
        }

        //
        // Pass the SACL as it is to the result descriptor.
        //
        BOOL bPresent = FALSE;
        bRet = GetSecurityDescriptorSacl(
					pInSecurityDescriptor,
					&bPresent,
					&pSacl,
					&bDefaulted
					);
        ASSERT(bRet);
        bRet = SetSecurityDescriptorSacl(&sd, bPresent, pSacl, bDefaulted);
        ASSERT(bRet);

        if (bPresent && (eDaclType == e_UseDefDaclAndCopyControl))
        {
            SECURITY_DESCRIPTOR_CONTROL scMask =
                                          SE_SACL_AUTO_INHERIT_REQ |
                                          SE_SACL_AUTO_INHERITED   |
                                          SE_SACL_PROTECTED;

            SECURITY_DESCRIPTOR_CONTROL sdc = sdcSrc & scMask;

            SetSecurityDescriptorControl(
				&sd,
				scMask,
				sdc
				);
        }
    }

    if (pOwner == NULL)
    {
        // Set the owner SID from the access token as the descriptor's owner SID.
        GetTokenInformation(hUserToken, TokenUser, NULL, 0, &dwLen);
        DWORD gle = GetLastError();
        if (gle == ERROR_INSUFFICIENT_BUFFER)
        {
            ptu = new char[dwLen];
            bRet = GetTokenInformation(hUserToken, TokenUser, ptu, dwLen, &dwLen);
            ASSERT(bRet);
            pOwner = ((TOKEN_USER*)(char*)ptu)->User.Sid;
        }
        else
        {
            DBGMSG((DBGMOD_ALL, DBGLVL_ERROR, TEXT(
             "MQSec_GetDefaultSecDescriptor(): Failed to GetTokenInformation(TokenUser), error: %d"), gle));
            LogNTStatus(gle, s_FN, 50);
            return MQSec_E_UNKNOWN;
        }
        bOwnerDefaulted = TRUE;
    }

    BOOL fIncludeGroup = TRUE;
    if ((seInfoToRemove & GROUP_SECURITY_INFORMATION) ==
                                               GROUP_SECURITY_INFORMATION)
    {
        fIncludeGroup = FALSE;
    }

    if ((pGroup == NULL) && fIncludeGroup)
    {
        // Set the primary group SID from the access token as the descriptor's
        // primary group SID.
        GetTokenInformation(hUserToken, TokenPrimaryGroup, NULL, 0, &dwLen);
        DWORD gle = GetLastError();
        if (gle == ERROR_INSUFFICIENT_BUFFER)
        {
            ptg = new char[dwLen];
            bRet = GetTokenInformation(hUserToken, TokenPrimaryGroup, ptg, dwLen, &dwLen);
            ASSERT(bRet);
            pGroup = ((TOKEN_PRIMARY_GROUP*)(char*)ptg)->PrimaryGroup;
        }
        else
        {
            DBGMSG((DBGMOD_ALL,DBGLVL_ERROR,TEXT("GetDefaultSecurityDescriptor(): Failed to GetTokenInformation(TokenPrimaryGroup), error: %d"), gle));
            LogNTStatus(gle, s_FN, 60);
            return MQSec_E_UNKNOWN;
        }
        bGroupDefaulted = TRUE;
    }

    //
    // If this is a local user, set the owner to be the guest user.
    // On MSMQ1.0, it was the anonymous user. On Windows 2000, anonymous
    // account was removed. So use the guest, exactly as does the file system.
    //
    BOOL fLocalUser = FALSE;

    hr = MQSec_GetUserType(pOwner, &fLocalUser, NULL);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    else if (fLocalUser)
    {
        pOwner = MQSec_GetAnonymousSid();
        bOwnerDefaulted = TRUE;
    }

    ASSERT(IsValidSid(pOwner));
    if ((seInfoToRemove & OWNER_SECURITY_INFORMATION) ==
                                               OWNER_SECURITY_INFORMATION)
    {
        //
        // Do not include owner in output default security descriptor.
        //
    }
    else
    {
        bRet = SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted);
        ASSERT(bRet);
    }

    if (fIncludeGroup)
    {
        ASSERT(IsValidSid(pGroup));
        bRet = SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted);
        ASSERT(bRet);
    }

    BOOL fIncludeDacl = TRUE ;

    if ((dwObjectType == MQDS_SITELINK) ||
        (dwObjectType == MQDS_COMPUTER))
    {
        //
        // For these objects types, we need only the owner. So don't waste
        // time to compute a DACL.
        //
        ASSERT(0);
        fIncludeDacl = FALSE;
    }
    else if ((seInfoToRemove & DACL_SECURITY_INFORMATION) ==
                                               DACL_SECURITY_INFORMATION)
    {
        //
        // don't include DACL.
        //
        fIncludeDacl = FALSE;
    }

    if (!bDaclPresent && fIncludeDacl)
    {
        PACL pDacl = NULL;

        //
        // If owner is the "Unkonwn user", or the Guest account, then grant
        // everyone full control on the object. "Guest" is not a "real"
        // owner, just a place-holder for any unauthenticated user.
        // If guest account is disabled, then the unknown user is
        // impersonated as the anonymous token.
        // We're creating here a NT4 format DACL, so full control to
        // everyone is just a NULL DACL.
        //
        BOOL fGrantEveryoneFull = FALSE;

        if (eDaclType == e_GrantFullControlToEveryone)
        {
            fGrantEveryoneFull = TRUE;
        }
        else if (MQSec_IsGuestSid( pOwner ))
        {
            fGrantEveryoneFull = TRUE;
        }
        else if (fLocalUser)
        {
            fGrantEveryoneFull = TRUE;
        }

        if (!fGrantEveryoneFull)
        {

            DWORD dwAclRevision = ACL_REVISION;
            DWORD dwWorldAccess = 0;
            DWORD dwOwnerAccess = 0;
            DWORD dwAnonymousAccess = 0;

            switch (dwObjectType)
            {
				case MQDS_QUEUE:
					dwWorldAccess = MQSEC_QUEUE_GENERIC_WRITE;
					dwOwnerAccess = GetObjectGenericMapping(dwObjectType)->GenericAll;
					dwAnonymousAccess = MQSEC_WRITE_MESSAGE;
					break;

				case MQDS_SITE:
					dwWorldAccess = MQSEC_SITE_GENERIC_READ;
					dwOwnerAccess = GetObjectGenericMapping(dwObjectType)->GenericAll;
					break;

				case MQDS_CN:
					//
					// This function is called from the replication service
					// to create a defualt descriptor for CNs. That's done
					// when replicating CNs to NT4 world.
					//
					dwWorldAccess = MQSEC_CN_GENERIC_READ;
					dwOwnerAccess = GetObjectGenericMapping(dwObjectType)->GenericAll;
					break;

				case MQDS_MQUSER:
					//
					// these are DS rights, not msmq.
					//
					dwWorldAccess = GENERIC_READ_MAPPING;
					dwOwnerAccess = GENERIC_READ_MAPPING   |
									 RIGHT_DS_SELF_WRITE    |
									 RIGHT_DS_WRITE_PROPERTY;
					dwAclRevision = ACL_REVISION_DS;
					break;

				default:
					break;
            }

            ASSERT(dwWorldAccess != 0);
            ASSERT(dwOwnerAccess != 0);

			//
			// Create and set the default DACL.
			// Allocate and initialize the DACL
			//

			DWORD dwAclSize = sizeof(ACL)                                +
							  (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
							  GetLengthSid(g_pWorldSid)                          +
							  GetLengthSid(g_pPreW2kCompatibleAccessSid)         +
							  GetLengthSid(pOwner);

			
			if (dwAnonymousAccess != 0)
			{
				ASSERT(dwObjectType == MQDS_QUEUE);

				dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
							 GetLengthSid(MQSec_GetAnonymousSid());
			}

            DACL_buff = new char[dwAclSize];
            pDacl = (PACL)(char*)DACL_buff;

            InitializeAcl(pDacl, dwAclSize, dwAclRevision);

            BOOL fAdd = AddAccessAllowedAce(
							pDacl,
							dwAclRevision,
							dwWorldAccess,
							g_pWorldSid
							);
            ASSERT(fAdd);

			//
			// Add pre w2k compatible access with the same permissions as everyone
			//
            fAdd = AddAccessAllowedAce(
							pDacl,
							dwAclRevision,
							dwWorldAccess,
							g_pPreW2kCompatibleAccessSid
							);
            ASSERT(fAdd);

			if (dwAnonymousAccess != 0)
			{
				PSID pAnonymousSid = MQSec_GetAnonymousSid();
				ASSERT((pAnonymousSid != NULL) && IsValidSid(pAnonymousSid));
				fAdd = AddAccessAllowedAce(
								pDacl,
								dwAclRevision,
								dwAnonymousAccess,
								pAnonymousSid
								);
				ASSERT(fAdd);
			}

            //
            // Add the owner with full control.
            //
            fAdd = AddAccessAllowedAce(
						pDacl,
						dwAclRevision,
						dwOwnerAccess,
						pOwner
						);
            ASSERT(fAdd);
        }

		//
		// dacl should not be defaulted !
        // Otherwise, calling IDirectoryObject->CreateDSObject() will ignore
        // the dacl we provide and will insert some default.
		//
        bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        ASSERT(bRet);
    }

    //
    // Convert the descriptor to a self relative format.
    //
    dwLen = 0;
    hr = MQSec_MakeSelfRelative(
			(PSECURITY_DESCRIPTOR) &sd,
			ppSecurityDescriptor,
			&dwLen
			);

    return LogHR(hr, s_FN, 80);
}

/***************************************************************************

Function:

    MQSec_CopySecurityDescriptor

Parameters:

    pDstSecurityDescriptor - Destination security descriptor.

    pSrcSecurityDescriptor - Source security descriptor.

    RequestedInformation - Indicates what parts of the source security
        descriptor should be copied to the destination security descriptor.

    eCopyControlBits - indicate whether or not control bits are copied too.

Description:
    The destination security descriptor should be an absolute security
    descriptor. The component in the destination security descriptor are
    being overwriten.

***************************************************************************/

BOOL
APIENTRY
MQSec_CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR  pDstSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR  pSrcSecurityDescriptor,
    IN SECURITY_INFORMATION  RequestedInformation,
    IN enum  enumCopyControl eCopyControlBits
	)
{
    PACL  pAcl;
    BOOL  bPresent;
    BOOL  bDefaulted;
    BOOL  bRet;
    PSID  pSid;
    DWORD dwRevision;

    if (pSrcSecurityDescriptor == NULL)
    {
        //
        // Bug 8567.
        // I have no idea why source Security descriptor is NULL, but
        // better return error than AV...
        //
		TrERROR(mqsec, "MQSec_CopySecurityDescriptor() got NULL source SD") ;
        return FALSE ;
    }

#ifdef _DEBUG
    SECURITY_DESCRIPTOR_CONTROL sdc;

    //
    // Verify that the destination security descriptor answers to all
    // requirements.
    //
    bRet = GetSecurityDescriptorControl(pDstSecurityDescriptor, &sdc, &dwRevision);
    ASSERT(bRet);
    ASSERT(!(sdc & SE_SELF_RELATIVE));
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
#endif

    SECURITY_DESCRIPTOR_CONTROL sdcSrc ;
    bRet = GetSecurityDescriptorControl(
				pSrcSecurityDescriptor,
				&sdcSrc,
				&dwRevision
				);
    ASSERT(bRet);

    // Copy the owner SID
    if (RequestedInformation & OWNER_SECURITY_INFORMATION)
    {
        bRet = GetSecurityDescriptorOwner(
					pSrcSecurityDescriptor,
					&pSid,
					&bDefaulted
					);
        ASSERT(bRet);

        bRet = SetSecurityDescriptorOwner(
					pDstSecurityDescriptor,
					pSid,
					bDefaulted
					);
        ASSERT(bRet);
    }

    // Copy the primary group SID.
    if (RequestedInformation & GROUP_SECURITY_INFORMATION)
    {
        bRet = GetSecurityDescriptorGroup(
					pSrcSecurityDescriptor,
					&pSid,
					&bDefaulted
					);
        ASSERT(bRet);

        bRet = SetSecurityDescriptorGroup(
					pDstSecurityDescriptor,
					pSid,
					bDefaulted
					);
        ASSERT(bRet);
    }

    // Copy the DACL.
    if (RequestedInformation & DACL_SECURITY_INFORMATION)
    {
        bRet = GetSecurityDescriptorDacl(
					pSrcSecurityDescriptor,
					&bPresent,
					&pAcl,
					&bDefaulted
					);
        ASSERT(bRet);

        bRet = SetSecurityDescriptorDacl(
					pDstSecurityDescriptor,
					bPresent,
					pAcl,
					bDefaulted
					);
        ASSERT(bRet);

        if (eCopyControlBits == e_DoCopyControlBits)
        {
            SECURITY_DESCRIPTOR_CONTROL scMask =
                                              SE_DACL_AUTO_INHERIT_REQ |
                                              SE_DACL_AUTO_INHERITED   |
                                              SE_DACL_PROTECTED;

            SECURITY_DESCRIPTOR_CONTROL sdc = sdcSrc & scMask;

            SetSecurityDescriptorControl(
				pDstSecurityDescriptor,
				scMask,
				sdc
				);
        }
    }

    // Copy the SACL.
    if (RequestedInformation & SACL_SECURITY_INFORMATION)
    {
        bRet = GetSecurityDescriptorSacl(
					pSrcSecurityDescriptor,
					&bPresent,
					&pAcl,
					&bDefaulted
					);
        ASSERT(bRet);

        bRet = SetSecurityDescriptorSacl(
					pDstSecurityDescriptor,
					bPresent,
					pAcl,
					bDefaulted
					);
        ASSERT(bRet);

        if (eCopyControlBits == e_DoCopyControlBits)
        {
            SECURITY_DESCRIPTOR_CONTROL scMask =
                                              SE_SACL_AUTO_INHERIT_REQ |
                                              SE_SACL_AUTO_INHERITED   |
                                              SE_SACL_PROTECTED;

            SECURITY_DESCRIPTOR_CONTROL sdc = sdcSrc & scMask;

            SetSecurityDescriptorControl(
				pDstSecurityDescriptor,
				scMask,
				sdc
				);
        }
    }

    return(TRUE);
}


bool
APIENTRY
MQSec_MakeAbsoluteSD(
    PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
	CAbsSecurityDsecripror* pAbsSecDescriptor
	)
/*++
Routine Description:
	Convert Security descriptor to Absolute format

Arguments:
	pObjSecurityDescriptor - self relative security descriptor
	pAbsSecDescriptor - structure of AP<> for absolute security descriptor.

Returned Value:
	true - success, false - failure

--*/
{

#ifdef _DEBUG
    //
    // Verify that the input security descriptor answers to all requirements.
    //
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;
    BOOL fSuccess1 = GetSecurityDescriptorControl(pObjSecurityDescriptor, &sdc, &dwRevision);

    ASSERT(fSuccess1);
    ASSERT(sdc & SE_SELF_RELATIVE);
    ASSERT(dwRevision == SECURITY_DESCRIPTOR_REVISION);
#endif

    //
    // Convert present object descriptor to absolute format. This is
    // necessary for the "set" api which manipulate a security descriptor
    //
    DWORD dwObjAbsSDSize = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;
    DWORD dwOwnerSize = 0;
    DWORD dwPrimaryGroupSize = 0;

    BOOL fSuccess = MakeAbsoluteSD(
						pObjSecurityDescriptor,
						NULL,
						&dwObjAbsSDSize,
						NULL,
						&dwDaclSize,
						NULL,
						&dwSaclSize,
						NULL,
						&dwOwnerSize,
						NULL,
						&dwPrimaryGroupSize
						);

    ASSERT(!fSuccess && (GetLastError() == ERROR_INSUFFICIENT_BUFFER));
    ASSERT(dwObjAbsSDSize != 0);

    //
    // Allocate the buffers for the absolute security descriptor.
    //
    pAbsSecDescriptor->m_pObjAbsSecDescriptor = new char[dwObjAbsSDSize];
    pAbsSecDescriptor->m_pOwner = new char[dwOwnerSize];
    pAbsSecDescriptor->m_pPrimaryGroup = new char[dwPrimaryGroupSize];
    if (dwDaclSize)
    {
        pAbsSecDescriptor->m_pDacl = new char[dwDaclSize];
    }
    if (dwSaclSize)
    {
        pAbsSecDescriptor->m_pSacl = new char[dwSaclSize];
    }

    //
    // Create the absolute descriptor.
    //
    fSuccess = MakeAbsoluteSD(
                    pObjSecurityDescriptor,
                    reinterpret_cast<PSECURITY_DESCRIPTOR>(pAbsSecDescriptor->m_pObjAbsSecDescriptor.get()),
                    &dwObjAbsSDSize,
                    reinterpret_cast<PACL>(pAbsSecDescriptor->m_pDacl.get()),
                    &dwDaclSize,
                    reinterpret_cast<PACL>(pAbsSecDescriptor->m_pSacl.get()),
                    &dwSaclSize,
                    reinterpret_cast<PSID>(pAbsSecDescriptor->m_pOwner.get()),
                    &dwOwnerSize,
                    reinterpret_cast<PSID>(pAbsSecDescriptor->m_pPrimaryGroup.get()),
                    &dwPrimaryGroupSize
					);

    if(!fSuccess)
	{
		DWORD gle = GetLastError();
		TrERROR(SecDscrp, "MakeAbsoluteSD() failed, gle = 0x%x", gle);
	    ASSERT(("MakeAbsoluteSD failed", 0));
		return false;
	}
	return true;
}


bool
APIENTRY
MQSec_SetSecurityDescriptorDacl(
    IN  PACL pNewDacl,
    IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
    OUT AP<BYTE>&  pSecurityDescriptor
	)
/*++
Routine Description:
	Set new DACL in pObjSecurityDescriptor.

Arguments:
    pNewDacl - the new DACL
	pObjSecurityDescriptor - object security descriptor.
    pSecurityDescriptor - output result. This is combination of the new DACL
        with unchanged ones from "pObj" in self-relative format.

Returned Value:
	true - success, false - failure

--*/
{
    //
    // Create the absolute descriptor.
    //
	CAbsSecurityDsecripror AbsSecDsecripror;
	if(!MQSec_MakeAbsoluteSD(
			pObjSecurityDescriptor,
			&AbsSecDsecripror
			))
	{
		TrERROR(SecDscrp, "MQSec_MakeAbsoluteSD() failed");
		return false;
	}

    SECURITY_DESCRIPTOR sd;
    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
	{
		DWORD gle = GetLastError();
		TrERROR(SecDscrp, "InitializeSecurityDescriptor() failed, gle = 0x%x", gle);
	    ASSERT(("InitializeSecurityDescriptor failed", 0));
		return false;
	}

    if(!SetSecurityDescriptorDacl(&sd, TRUE, pNewDacl, FALSE))
	{
		DWORD gle = GetLastError();
		TrERROR(SecDscrp, "SetSecurityDescriptorDacl() failed, gle = 0x%x", gle);
	    ASSERT(("SetSecurityDescriptorDacl failed", 0));
		return false;
	}

    //
    // Now copy new components to old descriptor, replacing old components.
    //
    if(!MQSec_CopySecurityDescriptor(
				reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),	// dst
				&sd,							// src
				DACL_SECURITY_INFORMATION,
				e_DoNotCopyControlBits
				))
	{
		TrERROR(SecDscrp, "MQSec_CopySecurityDescriptor() failed");
	    ASSERT(("MQSec_CopySecurityDescriptor failed", 0));
		return false;
	}

    //
    // Return a self relative descriptor.
    //
    DWORD dwLen = 0;
    HRESULT hr = MQSec_MakeSelfRelative(
						reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
						reinterpret_cast<PSECURITY_DESCRIPTOR*>(&pSecurityDescriptor),
						&dwLen
						);
	if(FAILED(hr))
	{
		TrERROR(SecDscrp, "MQSec_MakeSelfRelative() failed, hr = 0x%x", hr);
	    ASSERT(("MQSec_MakeSelfRelative failed", 0));
		return false;
	}

	return true;
}

//+------------------------------------------------------------------------
//
//  HRESULT APIENTRY  MQSec_MergeSecurityDescriptors()
//
//  Change the security descriptor of an object.
//  Caller must free the returned descriptor, using "delete".
//
//  Parameters:
//      dwObjectType - object type (Queue, Machine, etc...)
//      SecurityInformation - bits field that indicates which security
//          components are included in the input descriptor.
//      pInSecurityDescriptor - Input descriptor. The relevant components
//          from this one are copied to the output descriptor.
//      pObjSecurityDescriptor - Old object descriptor. Its relevant
//          components (those indicated by "SecurityInformation" are
//          replaced with those from "pInSecurityDescriptor". The other
//          components are copied as-is to the output.
//      ppSecurityDescriptor - output result. This is combination of new
//          components from "pIn" with unchanged ones from "pObj".
//          in self-relative format.
//
//  Notes: Input descriptor can be null, or components can be null and
//      marked for insetion (by turning on the relevant bits in
//       "SecurityInformation"). In those cases we use default values.
//
//+------------------------------------------------------------------------

HRESULT
APIENTRY
MQSec_MergeSecurityDescriptors(
                        IN  DWORD                  dwObjectType,
                        IN  SECURITY_INFORMATION   SecurityInformation,
                        IN  PSECURITY_DESCRIPTOR   pInSecurityDescriptor,
                        IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
                        OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor )
{
    //
    // Convert present object descriptor to absolute format. This is
    // necessary for the "set" api which manipulate a security descriptor
    //
	CAbsSecurityDsecripror AbsSecDsecripror;
	bool fSuccess = MQSec_MakeAbsoluteSD(
						pObjSecurityDescriptor,
						&AbsSecDsecripror
						);

	DBG_USED(fSuccess);
	ASSERT(fSuccess);

    //
    // Now take default components, for those which are not supplied by
    // input descriptor.
    //
    AP<char> pDefaultSecurityDescriptor ;
    SECURITY_DESCRIPTOR *pInputSD =
                             (SECURITY_DESCRIPTOR *) pInSecurityDescriptor ;

    HRESULT hr = MQSec_OK;
    if (dwObjectType == MQDS_QUEUE)
    {
        //
        // Security descriptor of queue can be provided by caller of
        // MQSetQueueSecurity(). to be compatible with msmq1.0, and
        // with spec, we create the default.
        // For all other types of objects, we expect mmc (or other admin
        // tools) to provide relevant components of the security descriptor,
        // without blank fields that need defaults.
        //
        hr =  MQSec_GetDefaultSecDescriptor( dwObjectType,
                        (PSECURITY_DESCRIPTOR*) &pDefaultSecurityDescriptor,
                                         TRUE, // fImpersonate
                                         pInSecurityDescriptor,
                                         0,  // seInfoToRemove
                                         e_UseDefDaclAndCopyControl ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1100) ;
        }

        char *pTmp= pDefaultSecurityDescriptor ;
        pInputSD = (SECURITY_DESCRIPTOR *) pTmp ;
    }

    //
    // Now copy new components to old descriptor, replacing old components.
    //
    BOOL bRet = MQSec_CopySecurityDescriptor(
					reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()), //dst
					pInputSD,               // src
					SecurityInformation,
					e_DoCopyControlBits
					);
	DBG_USED(bRet);
    ASSERT(bRet);

    //
    // Return a self relative descriptor.
    //
    DWORD dwLen = 0 ;
    hr = MQSec_MakeSelfRelative(
				reinterpret_cast<PSECURITY_DESCRIPTOR>(AbsSecDsecripror.m_pObjAbsSecDescriptor.get()),
				ppSecurityDescriptor,
				&dwLen
				);

    return LogHR(hr, s_FN, 90);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\certpriv.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certpriv.cpp

Abstract:
    Implement the private methods of class  CMQSigCertificate

Author:
    Doron Juster (DoronJ)  11-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "certpriv.tmh"

static WCHAR *s_FN=L"certifct/certpriv";

HRESULT  SetKeyContainerSecurity( HCRYPTPROV hProv ) ;

//+-----------------------------------------------------------------------
//
//   HRESULT CMQSigCertificate::_Create()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::_Create(IN PCCERT_CONTEXT  pCertContext)
{
    if (!pCertContext)
    {
        //
        // Object for creating new certificate
        //
        m_fCreatedInternally = TRUE ;
        m_pCertInfo = new CERT_INFO ;
        memset(m_pCertInfo, 0, sizeof(CERT_INFO)) ;

        //
        // Initialize version and serial number
        //
        m_pCertInfo->dwVersion = CERT_V3 ;

        m_dwSerNum =  0xaaa55a55 ;
        m_pCertInfo->SerialNumber.pbData = (BYTE*) &m_dwSerNum ;
        m_pCertInfo->SerialNumber.cbData = sizeof(m_dwSerNum);

        //
        // Initialize the signing algorithm. At present we use a predefine
        // one. Caller can't change it.
        //
        memset(&m_SignAlgID, 0, sizeof(m_SignAlgID)) ;
        m_pCertInfo->SignatureAlgorithm.pszObjId = szOID_RSA_MD5 ;
        m_pCertInfo->SignatureAlgorithm.Parameters = m_SignAlgID ;
    }
    else
    {
        //
        // Object for extracting data from existing certificate
        //
        m_pCertContext = pCertContext ;

        m_pEncodedCertBuf = m_pCertContext->pbCertEncoded ;
        m_dwCertBufSize   = m_pCertContext->cbCertEncoded ;

        m_pCertInfoRO = m_pCertContext->pCertInfo ;

        ASSERT(m_dwCertBufSize) ;
        ASSERT(m_pEncodedCertBuf) ;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_InitCryptProviderRead()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::_InitCryptProviderRead()
{
    if (m_hProvRead)
    {
        return MQ_OK ;
    }

    if (!_CryptAcquireVerContext( &m_hProvRead ))
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 190) ;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_InitCryptProviderCreate()
//
//  Init the crypto provider, and create public/private key pair if
//  necessray. These are the keys for internal certificate.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::_InitCryptProviderCreate( IN BOOL fCreate,
                                                     IN BOOL fMachine )
{
    if (m_hProvCreate)
    {
        return MQSec_OK ;
    }

    HRESULT hr = MQSec_OK ;
    DWORD   dwMachineFlag = 0 ;
    BOOL    fContainerCreated = FALSE ;

    LPSTR lpszContainerName = MSMQ_INTCRT_KEY_CONTAINER_A ;
    if (fMachine)
    {
        lpszContainerName = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_A ;
        dwMachineFlag = CRYPT_MACHINE_KEYSET ;
    }

    if (fCreate)
    {
        //
        // Delete present keys container, so it will be created later.
        // Don't check for returned error. not relevant. Following code
        // will do the error checking.
        //
        CryptAcquireContextA( &m_hProvCreate,
                               lpszContainerName,
                               MS_DEF_PROV_A,
                               PROV_RSA_FULL,
                               (CRYPT_DELETEKEYSET | dwMachineFlag) ) ;
    }

    if (!CryptAcquireContextA(&m_hProvCreate,
                               lpszContainerName,
                               MS_DEF_PROV_A,
                               PROV_RSA_FULL,
                               dwMachineFlag ))
    {
        switch(GetLastError())
        {
        case NTE_KEYSET_ENTRY_BAD:
            //
            // Delete the bat key container.
            //
            if (!CryptAcquireContextA(&m_hProvCreate,
                                      lpszContainerName,
                                      MS_DEF_PROV_A,
                                      PROV_RSA_FULL,
                                    (CRYPT_DELETEKEYSET | dwMachineFlag) ))
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to aquire crypto context when deleting bad keyset entry (container=%hs). %!winerr!"), lpszContainerName, GetLastError()));
                return MQSec_E_DEL_BAD_KEY_CONTNR;
            }
            //
            // Fall through
            //
        case NTE_BAD_KEYSET:
            //
            // Create the key container.
            //
            if (!CryptAcquireContextA(&m_hProvCreate,
                                      lpszContainerName,
                                      MS_DEF_PROV_A,
                                      PROV_RSA_FULL,
                                      (CRYPT_NEWKEYSET | dwMachineFlag) ))
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to aquire crypto context when creating new keyset entry (container=%hs). %!winerr!"), lpszContainerName, GetLastError()));
                return MQSec_E_CREATE_KEYSET;
            }
            fContainerCreated = TRUE ;
            break;

        default:
            return LogHR(MQ_ERROR, s_FN, 40) ;
        }
    }

    if (fContainerCreated && fMachine)
    {
        //
        // Secure the keys container.
        // Same as done for encryption key.
        //
        hr = SetKeyContainerSecurity( m_hProvCreate ) ;
        ASSERT(SUCCEEDED(hr)) ;
    }

    return LogHR(hr, s_FN, 50) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\certput.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certput.cpp

Abstract:
    Implement the "put" methods of class  CMQSigCertificate.
    Used for creating a certificate.

Author:
    Doron Juster (DoronJ)  11-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include <uniansi.h>

#include "certput.tmh"

static WCHAR *s_FN=L"certifct/certput";


//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutIssuerA( )
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutIssuer( LPWSTR lpszLocality,
									  LPWSTR lpszOrg,
									  LPWSTR lpszOrgUnit,
									  LPWSTR lpszDomain,
									  LPWSTR lpszUser,
									  LPWSTR lpszMachine )
{
    ASSERT_CERT_INFO ;
    ASSERT(m_pCertInfo->Issuer.cbData == 0) ;

    DWORD  cbIssuerNameEncoded = 0 ;
    BYTE   *pbIssuerNameEncoded = NULL;

    HRESULT hr = _EncodeName( lpszLocality,
                              lpszOrg,
                              lpszOrgUnit,
                              lpszDomain,
                              lpszUser,
                              lpszMachine,
                              &pbIssuerNameEncoded,
                              &cbIssuerNameEncoded) ;
    if (SUCCEEDED(hr))
    {
        m_pCertInfo->Issuer.cbData = cbIssuerNameEncoded;
        m_pCertInfo->Issuer.pbData = pbIssuerNameEncoded;
    }

    return LogHR(hr, s_FN, 10) ;
}


//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutSubjectA()
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutSubject( LPWSTR lpszLocality,
                                       LPWSTR lpszOrg,
                                       LPWSTR lpszOrgUnit,
                                       LPWSTR lpszDomain,
                                       LPWSTR lpszUser,
                                       LPWSTR lpszMachine )
{
    ASSERT_CERT_INFO ;
    ASSERT(m_pCertInfo->Subject.cbData == 0) ;

    DWORD  cbSubjectNameEncoded = 0 ;
    BYTE   *pbSubjectNameEncoded = NULL;

    HRESULT hr = _EncodeName( lpszLocality,
                              lpszOrg,
                              lpszOrgUnit,
                              lpszDomain,
                              lpszUser,
                              lpszMachine,
                              &pbSubjectNameEncoded,
                              &cbSubjectNameEncoded) ;
    if (SUCCEEDED(hr))
    {
        m_pCertInfo->Subject.cbData = cbSubjectNameEncoded;
        m_pCertInfo->Subject.pbData = pbSubjectNameEncoded;
    }

    return LogHR(hr, s_FN, 30) ;
}


//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutValidity( WORD wYears )
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutValidity( WORD wYears )
{
    ASSERT_CERT_INFO ;

    SYSTEMTIME  sysTime ;
    GetSystemTime(&sysTime) ;

    FILETIME  ftNotBefore ;
    BOOL fTime = SystemTimeToFileTime( &sysTime,
                                       &ftNotBefore ) ;
    if (!fTime)
    {
        return LogHR(MQSec_E_UNKNOWN, s_FN, 50) ;
    }
    m_pCertInfo->NotBefore = ftNotBefore ;

    sysTime.wYear = sysTime.wYear + wYears;

    //
    //  If current date is 29 Feb, change to 28 Feb
    //  To overcome leap year problem
    //
    if ( sysTime.wMonth == 2 &&
         sysTime.wDay == 29 )
    {
        sysTime.wDay = 28;
    }

    FILETIME  ftNotAfter ;
    fTime = SystemTimeToFileTime( &sysTime,
                                  &ftNotAfter ) ;
    if (!fTime)
    {
        return LogHR(MQSec_E_UNKNOWN, s_FN, 55) ;
    }
    m_pCertInfo->NotAfter = ftNotAfter ;

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::PutPublicKey()
//
//  Input:
//      fMachine- if TRUE, created the private key in the context of the
//                machine, not under the context of a user.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::PutPublicKey( IN  BOOL  fRenew,
                                         IN  BOOL  fMachine,
                                         OUT BOOL *pfCreate )
{
    ASSERT_CERT_INFO ;
    BOOL  fRet ;

    if (pfCreate)
    {
        *pfCreate = FALSE ;
    }

    HRESULT hr = _InitCryptProviderCreate( fRenew,
                                           fMachine ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60) ;
    }

    BOOL fGenKey = fRenew ;
    CHCryptKey hKey;

    if (!fGenKey)
    {
        //
        // First, try to get existing keys.
        //
        if (!CryptGetUserKey(m_hProvCreate, AT_SIGNATURE, &hKey))
        {
            if (GetLastError() != NTE_NO_KEY)
            {
                LogNTStatus(GetLastError(), s_FN, 70) ;
                return MQSec_E_PUTKEY_GET_USER;
            }
            fGenKey = TRUE ;
        }
    }

    if (fGenKey)
    {
        fRet = CryptGenKey( m_hProvCreate,
                            AT_SIGNATURE,
                            CRYPT_EXPORTABLE,
                            &hKey ) ;
        if (!fRet)
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to generate crypto key. %!winerr!"), GetLastError()));
            return MQSec_E_PUTKEY_GEN_USER;
        }

        if (pfCreate)
        {
            *pfCreate = TRUE ;
        }
    }

    //
    // Call CryptExportPublicKeyInfo to get the size of the returned
    // information.
    //
    DWORD    cbPublicKeyInfo = 0 ;

    BOOL fReturn = CryptExportPublicKeyInfo(
                      m_hProvCreate,         // Provider handle
                      AT_SIGNATURE,          // Key spec
                      MY_ENCODING_TYPE,      // Encoding type
                      NULL,                  // pbPublicKeyInfo
                      &cbPublicKeyInfo);     // Size of PublicKeyInfo

    if (!fReturn || (cbPublicKeyInfo < sizeof(CERT_PUBLIC_KEY_INFO)))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get required length to export public key. %!winerr!"), GetLastError()));
        return MQSec_E_EXPORT_PUB_FIRST;
    }

    CERT_PUBLIC_KEY_INFO *pBuf =
                (CERT_PUBLIC_KEY_INFO *) new BYTE[ cbPublicKeyInfo ] ;
    if (m_pPublicKeyInfo)
    {
        delete m_pPublicKeyInfo.detach() ;
    }
    m_pPublicKeyInfo = pBuf ; // auto delete pointer.

    //
    // Call CryptExportPublicKeyInfo to get pbPublicKeyInfo.
    //
    fReturn = CryptExportPublicKeyInfo(
                      m_hProvCreate,         // Provider handle
                      AT_SIGNATURE,          // Key spec
                      MY_ENCODING_TYPE,      // Encoding type
                      pBuf,                  // pbPublicKeyInfo
                      &cbPublicKeyInfo);     // Size of PublicKeyInfo
    if (!fReturn)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to export signature public key. %!winerr!"), GetLastError()));
        return MQSec_E_EXPORT_PUB_SECOND;
    }

    m_pCertInfo->SubjectPublicKeyInfo = *pBuf ;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_INFO, _T("Successfully exported signature public key. size=%u"), cbPublicKeyInfo));
    return MQSec_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\certutil.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certutil.cpp

Abstract:
    General Utility functions.

Author:
    Doron Juster (DoronJ)  17-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "cs.h"

#include "certutil.tmh"

static WCHAR *s_FN=L"certifct/certutil";

//+-------------------------------------------------------------------
//
//   BOOL _CryptAcquireVerContext( HCRYPTPROV *phProv )
//
//+-------------------------------------------------------------------

static CCriticalSection s_csAcquireContext;
static CHCryptProv s_hVerProv;

BOOL _CryptAcquireVerContext(HCRYPTPROV *phProv)
{

    if (s_hVerProv)
    {
        *phProv = s_hVerProv;
        return TRUE;
    }

    *phProv = NULL;

    CS Lock(s_csAcquireContext);

    if (!s_hVerProv)
    {
        if (!CryptAcquireContextA( 
				&s_hVerProv,
				NULL,
				MS_DEF_PROV_A,
				PROV_RSA_FULL,
				CRYPT_VERIFYCONTEXT
				))
        {
            return LogBOOL(FALSE, s_FN, 10);
        }
	}

    *phProv = s_hVerProv;
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  HRESULT _CloneCertFromStore ()
//
//+-------------------------------------------------------------------

HRESULT _CloneCertFromStore ( OUT CMQSigCertificate **ppCert,
                              HCERTSTORE              hStore,
                              IN  LONG                iCertIndex )
{
    LONG iCert = 0 ;
    PCCERT_CONTEXT pCertContext;
    PCCERT_CONTEXT pPrevCertContext;

    pCertContext = CertEnumCertificatesInStore(hStore, NULL);
    while (pCertContext)
    {
        if (iCert == iCertIndex)
        {
            R<CMQSigCertificate> pCert = NULL ;
            HRESULT hr = MQSigCreateCertificate(
                                     &pCert.ref(),
                                     NULL,
                                     pCertContext->pbCertEncoded,
                                     pCertContext->cbCertEncoded ) ;

            CertFreeCertificateContext(pCertContext) ;

            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 20) ;
            }

            *ppCert = pCert.detach();
            return MQSec_OK ;
        }
        //
        // Get next certificate
        //
        pPrevCertContext = pCertContext,
        pCertContext = CertEnumCertificatesInStore( hStore,
                                                    pPrevCertContext ) ;
        iCert++ ;
    }

    return  LogHR(MQSec_E_CERT_NOT_FOUND, s_FN, 30) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\cmqstore.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    cmqstore.cpp

Abstract:
    Implement the methods of class  CMQSigCertStore

Author:
    Doron Juster (DoronJ)  15-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "cmqstore.tmh"

static WCHAR *s_FN=L"certifct/cmqstore";

extern DWORD  g_cOpenCertStore ;

//+---------------------------------------------------------
//
//  constructor and destructor
//
//+---------------------------------------------------------

CMQSigCertStore::CMQSigCertStore() :
            m_hStore(NULL),
            m_hProv(NULL),
            m_hKeyStoreReg(NULL)
{
}

CMQSigCertStore::~CMQSigCertStore()
{
    if (m_hStore)
    {
        CertCloseStore(m_hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }
    if (m_hKeyStoreReg)
    {
        RegCloseKey(m_hKeyStoreReg) ;
    }
}

//+---------------------------------------------------------
//
//  HRESULT CMQSigCertStore::Release()
//
//+---------------------------------------------------------

HRESULT CMQSigCertStore::Release()
{
    g_cOpenCertStore-- ;
    delete this ;
    return MQ_OK ;
}

//+--------------------------------------------------------------------
//
//  HRESULT CMQSigCertStore::_Open()
//
//  Input:
//      fMachine- TRUE if opening the store of LocalSystem services.
//
//+--------------------------------------------------------------------

HRESULT CMQSigCertStore::_Open( IN  LPSTR      lpszRegRoot,
                                IN  struct MQSigOpenCertParams *pParams )
{
    LONG lRegError;

    REGSAM  rAccess = KEY_READ ;
    if (pParams->bWriteAccess)
    {
        rAccess |= KEY_WRITE ;
    }

    HKEY hRootRegKey = HKEY_CURRENT_USER ;
    if (pParams->hCurrentUser)
    {
        ASSERT(!(pParams->bMachineStore)) ;

        hRootRegKey = pParams->hCurrentUser ;
    }
    else if (pParams->bMachineStore)
    {
        hRootRegKey = HKEY_LOCAL_MACHINE ;
    }

    lRegError = RegOpenKeyExA(hRootRegKey,
                              lpszRegRoot,
                              0,
                              rAccess,
                              &m_hKeyStoreReg);
    if (lRegError != ERROR_SUCCESS)
    {
        if (pParams->bCreate)
        {
            //
            // Try to create the key.
            //
            DWORD dwDisposition ;
            lRegError = RegCreateKeyExA( hRootRegKey,
                                         lpszRegRoot,
                                         0L,
                                         "",
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_READ | KEY_WRITE,
                                         NULL,
                                         &m_hKeyStoreReg,
                                         &dwDisposition);
            if (lRegError != ERROR_SUCCESS)
            {
                DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to create user certificate store in registry (%hs). %!winerr!"), lpszRegRoot, lRegError));
                return MQ_ERROR_CANNOT_CREATE_CERT_STORE;
            }
        }
        else
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to open user certificate store in registry (%hs). %!winerr!"), lpszRegRoot, lRegError));
            return MQ_ERROR_CANNOT_OPEN_CERT_STORE;
        }
    }

    ASSERT(m_hKeyStoreReg) ;

    HRESULT hr = _InitCryptProvider() ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30) ;
    }

    DWORD dwStoreFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG ;
    if (!pParams->bWriteAccess)
    {
        //
        // Read only access to the certificate store.
        //
        dwStoreFlags |= CERT_STORE_READONLY_FLAG ;
    }
    m_hStore = CertOpenStore(CERT_STORE_PROV_REG,
                             X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                             m_hProv,
                             dwStoreFlags,
                             m_hKeyStoreReg);
    if (!m_hStore)
    {
        LogNTStatus(GetLastError(), s_FN, 40) ;
        return MQSec_E_CANT_OPEN_STORE;
    }
    return MQSec_OK ;
}

//+---------------------------------------------------------
//
//  HRESULT CMQSigCertStore::_InitCryptProvider()
//
//+---------------------------------------------------------

HRESULT CMQSigCertStore::_InitCryptProvider()
{
    if (!_CryptAcquireVerContext( &m_hProv ))
    {
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 50) ;
    }

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\decdname.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    decdname.cpp

Abstract:
    Implement the methods for decoding names

Author:
    Doron Juster (DoronJ)  08-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "uniansi.h"

#include "decdname.tmh"

static WCHAR *s_FN=L"certifct/decdname";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_DecodeName()
//
//  Description: Decode a CERT_NAME_BLOB into a CERT_NAME_INFO.
//
//  Paramters:  BYTE  *pEncodedName - Buffer holding a CERT_NAME_BLOB.
//              DWORD dwEncodedSize - size of blob in  CERT_NAME_BLOB
//
//              BYTE  **pBuf - Pointer to result CERT_NAME_INFO.
//                  Memory for this buffer is allocated in this method.
//              DWORD *pdwBufSize - Pointer to recieve size of buffer
//                  for CERT_NAME_INFO.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::_DecodeName( IN  BYTE  *pEncodedName,
                                        IN  DWORD dwEncodedSize,
                                        OUT BYTE  **pBuf,
                                        OUT DWORD *pdwBufSize ) const
{
    BOOL fDecode = CryptDecodeObject( MY_ENCODING_TYPE,
                                      X509_NAME,
                                      pEncodedName,
                                      dwEncodedSize,
                                      0,
                                      NULL,
                                      pdwBufSize ) ;
    if (!fDecode || (*pdwBufSize == 0))
    {
        LogNTStatus(GetLastError(), s_FN, 10) ;
        return MQSec_E_DCD_RDNNAME_FIRST;
    }

    *pBuf = new BYTE[ *pdwBufSize ] ;
    if (*pBuf == NULL)
    {
        return  LogHR(MQSec_E_NO_MEMORY, s_FN, 20) ;
    }

    fDecode = CryptDecodeObject( MY_ENCODING_TYPE,
                                 X509_NAME,
                                 pEncodedName,
                                 dwEncodedSize,
                                 0,
                                 *pBuf,
                                 pdwBufSize ) ;
    if (!fDecode)
    {
        delete *pBuf ;
        *pdwBufSize = 0 ;

        LogNTStatus(GetLastError(), s_FN, 30) ;
        return MQSec_E_DCD_RDNNAME_SECOND;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_GetAName()
//
//  Description: Get a name component from a CERT_RDN buffer.
//               Buffer for the name is allocated here.
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::_GetAName( 
	IN  CERT_RDN  *prgRDN,
	OUT LPWSTR     *ppszName 
	) const
{
    ASSERT(!(*ppszName));

    if (prgRDN->cRDNAttr != 1)
    {
        return  LogHR(MQSec_E_UNSUPPORT_RDNNAME, s_FN, 40);
    }

    CERT_RDN_ATTR  *prgRDNAttr = prgRDN->rgRDNAttr;
    CERT_RDN_VALUE_BLOB  Value = prgRDNAttr->Value;

    AP<WCHAR> pTmpName;
    if ((lstrcmpiA( prgRDNAttr->pszObjId, szOID_RSA_emailAddr ) == 0) &&
        (prgRDNAttr->dwValueType == CERT_RDN_IA5_STRING))
    {
        //
        // Special case for email address. it's ansi.
        //
		AP<char> pTmpAnsiName;
		DWORD dwSize = Value.cbData + 2;

		pTmpAnsiName = new char[dwSize];
		memset(pTmpAnsiName, 0, dwSize);
        memcpy(pTmpAnsiName, (char*) Value.pbData, Value.cbData) ;

		pTmpName = new WCHAR[dwSize];
		MultiByteToWideChar(CP_ACP, 0, pTmpAnsiName, -1, pTmpName, dwSize);
    }
	else
	{
		//
		// Get required buffer length
		//
		DWORD dwSize = CertRDNValueToStr(
							prgRDNAttr->dwValueType, 
							&Value, 
							NULL, 
							0
							);

		pTmpName = new WCHAR[dwSize];

		CertRDNValueToStr(
				prgRDNAttr->dwValueType, 
				&Value, 
				pTmpName.get(), 
				dwSize
				);
	}

    TrTRACE(mqsec, "CMQSigCertificate::_GetAName, Name = %ls, ValueType = %d", pTmpName.get(), prgRDNAttr->dwValueType);
    *ppszName = pTmpName.detach();

    return LogHR(MQ_OK, s_FN, 60);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\encdname.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    encdname.cpp

Abstract:
    Implement the methods for encoding names

Author:
    Doron Juster (DoronJ)  08-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "uniansi.h"

#include "encdname.tmh"

static WCHAR *s_FN=L"certifct/encdname";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_EncodeName()
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::_EncodeName( 
	LPWSTR  lpszLocality,
	LPWSTR  lpszOrg,
	LPWSTR  lpszOrgUnit,
	LPWSTR  lpszDomain,
	LPWSTR  lpszUser,
	LPWSTR  lpszMachine,
	BYTE   **ppBuf,
	DWORD  *pdwBufSize 
	)
{
    int  cAttr = 0;

    P<CERT_RDN_ATTR> rgNameAttr = (CERT_RDN_ATTR*) new CERT_RDN_ATTR[4];

    rgNameAttr[cAttr].pszObjId = szOID_LOCALITY_NAME;
    rgNameAttr[cAttr].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr].Value.cbData = lstrlen(lpszLocality)*sizeof(WCHAR);
    rgNameAttr[cAttr].Value.pbData = (BYTE*) lpszLocality;

    cAttr++ ;
    rgNameAttr[cAttr].pszObjId = szOID_ORGANIZATION_NAME;
    rgNameAttr[cAttr].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr].Value.cbData = lstrlen(lpszOrg)*sizeof(WCHAR);
    rgNameAttr[cAttr].Value.pbData = (BYTE*) lpszOrg;

    cAttr++ ;
    rgNameAttr[cAttr].pszObjId = szOID_ORGANIZATIONAL_UNIT_NAME;
    rgNameAttr[cAttr].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr].Value.cbData = lstrlen(lpszOrgUnit)*sizeof(WCHAR);
    rgNameAttr[cAttr].Value.pbData = (BYTE*) lpszOrgUnit;

    WCHAR szCNBuf[MAX_PATH * 4];
    wsprintf(szCNBuf, L"%s\\%s, %s", lpszDomain, lpszUser, lpszMachine);

    cAttr++ ;
    rgNameAttr[cAttr ].pszObjId = szOID_COMMON_NAME;
    rgNameAttr[cAttr ].dwValueType = CERT_RDN_UNICODE_STRING;
    rgNameAttr[cAttr ].Value.cbData = lstrlen(szCNBuf)*sizeof(WCHAR);
    rgNameAttr[cAttr ].Value.pbData = (BYTE*) szCNBuf;

    cAttr++;
    ASSERT(cAttr == 4);
    HRESULT hr2 = _EncodeNameRDN( 
						rgNameAttr,
						cAttr,
						ppBuf,
						pdwBufSize 
						);

    return LogHR(hr2, s_FN, 10);
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::_EncodeNameRDN()
//
//+-----------------------------------------------------------------------

HRESULT 
CMQSigCertificate::_EncodeNameRDN( 
	CERT_RDN_ATTR *rgNameAttr,
	DWORD         cbRDNs,
	BYTE          **ppBuf,
	DWORD         *pdwBufSize 
	)
{
    //---------------------------------------------------------------
    // Declare and initialize a CERT_RDN array.
    //---------------------------------------------------------------
    P<CERT_RDN> pCertRdn = (CERT_RDN*) new CERT_RDN[cbRDNs];
    for (DWORD j = 0; j < cbRDNs; j++)
    {
        pCertRdn[j].cRDNAttr = 1;
        pCertRdn[j].rgRDNAttr = &rgNameAttr[j];
    }

    //---------------------------------------------------------------
    // Declare and initialize a CERT_NAME_INFO structure.
    //---------------------------------------------------------------
    CERT_NAME_INFO Name = {cbRDNs, pCertRdn};

    //---------------------------------------------------------------
    // Step 5.  Call CryptEncodeObject to get an encoded BYTE string.
    //---------------------------------------------------------------
    *pdwBufSize = 0;

    CryptEncodeObject(
		MY_ENCODING_TYPE,     // Encoding type
		X509_NAME,            // Struct type
		&Name,                // Address of CERT_NAME_INFO struct.
		NULL,                 // pbEncoded
		pdwBufSize			  // pbEncoded size
		);       

    if (0 == *pdwBufSize)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get the size required for object encoding. %!winerr!"), GetLastError()));
        return MQSec_E_ENC_RDNNAME_FIRST;
    }

    *ppBuf = (BYTE*) new BYTE[*pdwBufSize];
    if (*ppBuf == NULL)
    {
        return LogHR(MQSec_E_NO_MEMORY, s_FN, 30);
    }

    if(!CryptEncodeObject(
            MY_ENCODING_TYPE,    // Encoding type
            X509_NAME,           // Struct type
            &Name,               // Address of CERT_NAME_INFO struct.
            *ppBuf,              // Buffer for encoded name.
            pdwBufSize			 // pbEncoded size
			))        
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to encode object. %!winerr!"), GetLastError()));
        return MQSec_E_ENC_RDNNAME_SECOND;
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\certvlid.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    certvlid.cpp

Abstract:
    Implement the "valid" methods, for verifying the validity of the
    certificate.

Author:
    Doron Juster (DoronJ)  16-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "certvlid.tmh"

static WCHAR *s_FN=L"certifct/certvlid";

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetIssuer()
//
//  Description: Verify the time validity of the certificate, relative
//      to "pTime". If pTime is NULL the verify relative to current time.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::IsTimeValid(IN FILETIME *pTime) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 10) ;
    }

    LONG iVer = CertVerifyTimeValidity( pTime,
                                        m_pCertContext->pCertInfo ) ;
    if (iVer < 0)
    {
        return  LogHR(MQSec_E_CERT_NOT_VALID_YET, s_FN, 20) ;
    }
    else if (iVer > 0)
    {
        return  LogHR(MQSec_E_CERT_EXPIRED, s_FN, 30) ;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::IsCertificateValid()
//
//  Description: Verify that this certificate is valid, i.e., it's signed
//       by "pIssuerCert" and both certificates (this one and the issuer
//       one) are valid regarding times.
//       if "pTime" is null then validity is relative to current time.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::IsCertificateValid(
                             IN CMQSigCertificate *pIssuerCert,
                             IN DWORD              dwFlagsIn,
                             IN FILETIME          *pTime,
                             IN BOOL               fIgnoreNotBefore ) const
{
    if (!m_pCertContext)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 40) ;
    }

    HRESULT hr ;

    if (pTime)
    {
        hr = IsTimeValid(pTime) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 50) ;
        }
        hr = pIssuerCert->IsTimeValid(pTime) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60) ;
        }
    }

    PCCERT_CONTEXT pIssuerContext = pIssuerCert->m_pCertContext ;
    if (!pIssuerContext)
    {
        return LogHR(MQSec_E_INVALID_PARAMETER, s_FN, 70) ;
    }

    DWORD dwFlags = dwFlagsIn ;
    BOOL fValid = CertVerifySubjectCertificateContext( m_pCertContext,
                                                       pIssuerContext,
                                                       &dwFlags ) ;
    if (!fValid)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to verify certificate. Flags=0x%x %!winerr!"), dwFlagsIn, GetLastError()));
        return MQSec_E_CANT_VALIDATE;
    }
    else if (dwFlags == 0)
    {
        return MQ_OK ;
    }
    else if (dwFlags & CERT_STORE_SIGNATURE_FLAG)
    {
        return  LogHR(MQSec_E_CERT_NOT_SIGNED, s_FN, 85) ;
    }
    else if (dwFlags & CERT_STORE_TIME_VALIDITY_FLAG)
    {
        if (fIgnoreNotBefore)
        {
            //
            // Now check only times. If NotBefore is violated, then ignore
            // and return Ok. The common case for this scenario is internal
            // certificate. If clock of client is advanced relative to
            // server, then trying to renew an internal certificate will
            // fail on NotBefore. We ignore this.
            //
            hr = IsTimeValid() ;
            if (SUCCEEDED(hr) || (hr == MQSec_E_CERT_NOT_VALID_YET))
            {
                return MQ_OK ;
            }
        }
        return  LogHR(MQSec_E_CERT_TIME_NOTVALID, s_FN, 90) ;
    }
    else if (dwFlags & CERT_STORE_NO_CRL_FLAG)
    {
        //
        // Issuer doesn't have a CRL in store. That's OK.
        //
        return MQ_OK ;
    }
    else if (dwFlags & CERT_STORE_REVOCATION_FLAG)
    {
        return LogHR(MQSec_E_CERT_REVOCED, s_FN, 100) ;
    }

    ASSERT(0) ;
    return LogHR(MQSec_E_UNKNOWN, s_FN, 110) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\cmqcert.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    cmqcert.cpp

Abstract:
    Implement the methods of class  CMQSigCertificate

Author:
    Doron Juster (DoronJ)  04-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"

#include "cmqcert.tmh"

static WCHAR *s_FN=L"certifct/cmqcert";

extern DWORD  g_cOpenCert ;

//+---------------------------------------------------------
//
//  constructor and destructor
//
//+---------------------------------------------------------

CMQSigCertificate::CMQSigCertificate() :
            m_fCreatedInternally(FALSE),
            m_fDeleted(FALSE),
            m_fKeepContext(FALSE),
            m_pEncodedCertBuf(NULL),
            m_pCertContext(NULL),
            m_hProvCreate(NULL),
            m_hProvRead(NULL),
            m_pPublicKeyInfo(NULL),
            m_pCertInfoRO(NULL),
            m_dwCertBufSize(0)
{
    m_pCertInfo = NULL ;
}

CMQSigCertificate::~CMQSigCertificate()
{
    if (m_fCreatedInternally)
    {
        ASSERT(!m_pCertContext) ;
        if (m_pEncodedCertBuf)
        {
            ASSERT(m_dwCertBufSize > 0) ;
            delete m_pEncodedCertBuf ;
            m_pEncodedCertBuf = NULL ;
        }
    }
    else if (m_pCertContext)
    {
        ASSERT(m_pEncodedCertBuf) ;
        CertFreeCertificateContext(m_pCertContext) ;
    }
    else
    {
        ASSERT(m_fDeleted || m_fKeepContext) ;
    }
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::EncodeCert()
//
//   This method sign and encode the certificate. The result is a buffer,
//   allocated here and returned in "ppCertBuf", which holds the encoded
//   certificate.
//   Both input pointers are optional. The encoded buffer is always kept
//   in the object and can be retieved later by calling "GetCertBlob".
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::EncodeCert( IN BOOL     fMachine,
                                       OUT BYTE  **ppCertBuf,
                                       OUT DWORD  *pdwSize )
{
    ASSERT_CERT_INFO ;

    HRESULT hr = _InitCryptProviderCreate(FALSE, fMachine) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10) ;
    }

    CRYPT_OBJID_BLOB Parameters;
    memset(&Parameters, 0, sizeof(Parameters));

    CRYPT_ALGORITHM_IDENTIFIER SigAlg;
    SigAlg.pszObjId = szOID_RSA_MD5RSA ;
    SigAlg.Parameters = Parameters;

    //
    // Call CryptSignAndEncodeCertificate to get the size of the
    // returned blob.
    //
    ASSERT(m_hProvCreate) ;
    BOOL fReturn = CryptSignAndEncodeCertificate(
              m_hProvCreate,                   // Crypto provider
              AT_SIGNATURE,                    // Key spec.
              MY_ENCODING_TYPE,                // Encoding type
              X509_CERT_TO_BE_SIGNED,          // Struct type
              m_pCertInfo,                     // Struct info
              &SigAlg,                         // Signature algorithm
              NULL,                            // Not used
              NULL,                            // pbSignedEncodedCertReq
              &m_dwCertBufSize) ;              // Size of cert blob
    if (!fReturn)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get the size for signed and encoded certificate. %!winerr!"), GetLastError()));
        return MQSec_E_ENCODE_CERT_FIRST;
    }

    m_pEncodedCertBuf = (BYTE*) new BYTE[ m_dwCertBufSize ] ;

    //
    // Call CryptSignAndEncodeCertificate to get the
    // returned blob.
    //
    fReturn = CryptSignAndEncodeCertificate(
              m_hProvCreate,                  // Crypto provider
              AT_SIGNATURE,                   // Key spec.
              MY_ENCODING_TYPE,               // Encoding type
              X509_CERT_TO_BE_SIGNED,         // Struct type
              m_pCertInfo,                    // Struct info
              &SigAlg,                        // Signature algorithm
              NULL,                           // Not used
              m_pEncodedCertBuf,              // buffer
              &m_dwCertBufSize) ;             // Size of cert blob
    if (!fReturn)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to signed and encoded certificate. %!winerr!"), GetLastError()));
        return MQSec_E_ENCODE_CERT_SECOND;
    }

    if (ppCertBuf)
    {
        *ppCertBuf = m_pEncodedCertBuf ;
    }
    if (pdwSize)
    {
        *pdwSize = m_dwCertBufSize ;
    }

    m_pCertInfoRO = m_pCertInfo ;

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::AddToStore( HCERTSTORE hStore )
//
//  Description:  Add the certificate to a store
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::AddToStore( IN HCERTSTORE hStore ) const
{
    if (!m_pEncodedCertBuf)
    {
        return LogHR(MQSec_E_INVALID_CALL, s_FN, 40) ;
    }

    BOOL fAdd =  CertAddEncodedCertificateToStore( hStore,
                                                   MY_ENCODING_TYPE,
                                                   m_pEncodedCertBuf,
                                                   m_dwCertBufSize,
                                                   CERT_STORE_ADD_NEW,
                                                   NULL ) ;
    if (!fAdd)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed add encoded crtificate to the store. %!winerr!"), GetLastError()));
        return MQSec_E_CAN_NOT_ADD;
    }

    return MQSec_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::DeleteFromStore()
//
//  Description:  Delete the certificate from its store. This method
//      makes the certificate context (m_pCertContext) invalid.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::DeleteFromStore()
{
    if (!m_pCertContext)
    {
        return LogHR(MQSec_E_INVALID_CALL, s_FN, 60) ;
    }

    BOOL fDel =  CertDeleteCertificateFromStore( m_pCertContext ) ;

    m_pCertContext = NULL ;
    m_fDeleted = TRUE ;

    if (!fDel)
    {
        DWORD dwErr = GetLastError() ;
        LogNTStatus(dwErr, s_FN, 65);
        if (dwErr == E_ACCESSDENIED)
        {
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 70) ;
        }
        else
        {
            return LogHR(MQSec_E_CAN_NOT_DELETE, s_FN, 80) ;
        }
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetCertDigest(OUT GUID  *pguidDigest)
//
//  Description:  Compute the digest of the certificate.
//      Use only the "to be signed" portion of the certificate. This is
//      necessary for keeping compatibility with MSMQ 1.0, which used
//      digsig.dll. digsig hashes only the "to be signed" part.
//
//      The encoded certificate, held by "m_pEncodedCertBuf" is already
//      signed so it can not be used for computing the digest. this is
//      why CERT_INFO (m_pCertInfoRO) is encoded again, with flag
//      X509_CERT_TO_BE_SIGNED. The result of this encoding is used to
//      compute the digest.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::GetCertDigest(OUT GUID  *pguidDigest)
{
    HRESULT hr = MQSec_OK ;

    if (!m_pCertInfoRO)
    {
        return  LogHR(MQSec_E_INVALID_CALL, s_FN, 90) ;
    }

    DWORD dwSize = 0 ;
    BOOL fEncode = CryptEncodeObject(
                    MY_ENCODING_TYPE,          // Encoding type
                    X509_CERT_TO_BE_SIGNED,    // Struct type
                    m_pCertInfoRO,             // Address of struct.
                    NULL,                      // pbEncoded
                    &dwSize ) ;                // pbEncoded size
    if ((dwSize == 0) || !fEncode)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get the size for encoding certificate. %!winerr!"), GetLastError()));
        return MQSec_E_ENCODE_HASH_FIRST;
    }

    P<BYTE> pBuf = new BYTE[ dwSize ] ;
    fEncode = CryptEncodeObject(
                    MY_ENCODING_TYPE,          // Encoding type
                    X509_CERT_TO_BE_SIGNED,    // Struct type
                    m_pCertInfoRO,             // Address of struct.
                    pBuf,                      // pbEncoded
                    &dwSize ) ;                // pbEncoded size
    if (!fEncode)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to encode certificate. %!winerr!"), GetLastError()));
        return MQSec_E_ENCODE_HASH_SECOND;
    }

    hr = _InitCryptProviderRead() ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120) ;
    }
    ASSERT(m_hProvRead) ;

    CHCryptHash hHash ;
    BOOL fCreate =  CryptCreateHash( m_hProvRead,
                                     CALG_MD5,
                                     0,
                                     0,
                                     &hHash ) ;
    if (!fCreate)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to create MD5 hash. %!winerr!"), GetLastError()));
        return MQSec_E_CANT_CREATE_HASH;
    }

    BOOL fHash = CryptHashData( hHash,
                                pBuf,
                                dwSize,
                                0 ) ;
    if (!fHash)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to hash data. %!winerr!"), GetLastError()));
        return MQSec_E_CAN_NOT_HASH;
    }

    dwSize = sizeof(GUID) ;
    BOOL fGet = CryptGetHashParam( hHash,
                                   HP_HASHVAL,
                                   (BYTE*) pguidDigest,
                                   &dwSize,
                                   0 ) ;
    if (!fGet)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to get hash value from hash object. %!winerr!"), GetLastError()));
        return MQSec_E_CAN_NOT_GET_HASH;
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//   HRESULT CMQSigCertificate::Release()
//
//  Description:  delete this object. cleanup is done in the destructor.
//
//+-----------------------------------------------------------------------

HRESULT CMQSigCertificate::Release( BOOL fKeepContext )
{
    if (fKeepContext)
    {
        m_fKeepContext = TRUE ;
        m_pCertContext = NULL ;
    }
    g_cOpenCert-- ;
    delete this ;
    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\msgauthn.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
    msgauthn.cpp

Abstract:
    Code for message authentication.

Author:
    Doron Juster (DoronJ)  06-Sep-1999

Revision History:

--*/

#include <stdh_sec.h>

#include "msgauthn.tmh"

static WCHAR *s_FN=L"certifct/msgauthn";

//+-----------------------------------------------
//
//  HRESULT MQSigHashMessageProperties()
//
//  Hash an array of message properties.
//
//+-----------------------------------------------

HRESULT APIENTRY  MQSigHashMessageProperties(
                                 IN HCRYPTHASH           hHash,
                                 IN struct _MsgHashData *pHashData )
{
    for ( ULONG j = 0 ; j < pHashData->cEntries ; j++ )
    {
        if (!CryptHashData( hHash,
                            (pHashData->aEntries[j]).pData,
                            (pHashData->aEntries[j]).dwSize,
                            0 ))
        {
            DWORD dwErr = GetLastError() ;
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
             "In MQSigHashMessageProperties(), CryptHashData(%lut) failed, err- %lxh"),
                                                           j, dwErr)) ;

            return LogHR(dwErr, s_FN, 100) ;
        }
    }

    return MQSec_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypt\packpkey.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: packpkey.cpp

Abstract:
    Pack public key into a DS blob.

Author:
    Doron Juster (DoronJ)  19-Nov-1998
	Ilan Herbst   (ilanh)  08-Jun-2000, MQSec_PackPublicKey

Revision History:

--*/

#include <stdh_sec.h>

#include "packpkey.tmh"

static WCHAR *s_FN=L"encrypt/packpkey";

//+-------------------------------
//
//  HRESULT  _PackAKey()
//
//+-------------------------------

STATIC 
HRESULT  
_PackAKey( 
	IN  BYTE           *pKeyBlob,
	IN  ULONG           ulKeySize,
	IN  LPCWSTR         wszProviderName,
	IN  ULONG           ulProviderType,
	OUT MQDSPUBLICKEY **ppPublicKeyPack 
	)
{
    ULONG ulProvSize = sizeof(WCHAR) * (1 + wcslen(wszProviderName));
    ULONG ulSize = ulProvSize + ulKeySize + SIZEOF_MQDSPUBLICKEY;

    *ppPublicKeyPack = (MQDSPUBLICKEY *) new BYTE[ ulSize ];
    MQDSPUBLICKEY *pPublicKeyPack = *ppPublicKeyPack;

    pPublicKeyPack->ulKeyLen = ulKeySize;
    pPublicKeyPack->ulProviderLen = ulProvSize;
    pPublicKeyPack->ulProviderType = ulProviderType;

    BYTE *pBuf = (BYTE*) (pPublicKeyPack->aBuf);
    wcscpy((WCHAR*) pBuf, wszProviderName);

    pBuf += ulProvSize;
    memcpy(pBuf, pKeyBlob, ulKeySize);

    return MQSec_OK;
}


//+------------------------------------------------------------------------
//
//  HRESULT PackPublicKey()
//
//    pPublicKeyPack- pointer to a strucutre that already contains several
//      keys. A new structure is allocated, the previous one is copied
//      and new key is packed at the end of  the new structure.
//
//+------------------------------------------------------------------------

HRESULT 
PackPublicKey(
	IN      BYTE				*pKeyBlob,
	IN      ULONG				ulKeySize,
	IN      LPCWSTR				wszProviderName,
	IN      ULONG				ulProviderType,
	IN OUT  P<MQDSPUBLICKEYS>&  pPublicKeysPack 
	)
/*++

Routine Description:
	Export the input key into a keyblob and Pack it in the end of the PublicKeysPack structure

Arguments:
	pKeyBlob - pointer to key blob to be add to the keys pack
	ulKeySize - key blob size
	wszProviderName - provider name
	ulProviderType - provider type (base, enhanced)
	pPublicKeysPack - in\out Pointer to Public keys pack, the Key blob will be add 
					  at the end of pPublicKeysPack

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    if ((pKeyBlob == NULL) || (ulKeySize == 0))
    {
        //
        // Nothing to pack.
        //
        return MQSec_OK;
    }

	//
	// Prepare MQDSPUBLICKEY - structure for one key which include 
	// provider name wstring and wstring length, provider type, keyblob and length 
	//
    P<MQDSPUBLICKEY> pPublicKey = NULL;
    HRESULT hr = _PackAKey( 
					pKeyBlob,
					ulKeySize,
					wszProviderName,
					ulProviderType,
					&pPublicKey 
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10);
    }

    //
    // Compute size of new structure.
    //
    ULONG ulSize = 0;
    ULONG ulPrevSize = 0;
    ULONG ulPrevCount = 0;

    if (pPublicKeysPack)
    {
        //
        // Add key to existing structure.
        //
        ASSERT(pPublicKeysPack->ulLen);
        ulPrevSize = pPublicKeysPack->ulLen;
        ulPrevCount = pPublicKeysPack->cNumofKeys;
        ulSize = ulPrevSize;
    }
    else
    {
        //
        // Create new structure.
        //
        ulSize = SIZEOF_MQDSPUBLICKEYS;
        ulPrevSize = ulSize;
    }

	//
	// New keyblob pack size
	//
    ULONG ulKeyPackSize =   pPublicKey->ulKeyLen      +
                            pPublicKey->ulProviderLen +
                            SIZEOF_MQDSPUBLICKEY;
    ulSize += ulKeyPackSize;

    P<BYTE> pTmp = (BYTE *) new BYTE[ ulSize ];
    BYTE *pNewPack = pTmp;

    if (pPublicKeysPack)
    {
		//
		// Copy previous key packs
		//
        memcpy(pNewPack, pPublicKeysPack, pPublicKeysPack->ulLen);
        pNewPack +=  pPublicKeysPack->ulLen;
    }
    else
    {
        pNewPack += SIZEOF_MQDSPUBLICKEYS;
    }

	//
	// Adding the new key pack
	//
    memcpy(pNewPack, pPublicKey, ulKeyPackSize);

	pPublicKeysPack.free();
    pPublicKeysPack = (MQDSPUBLICKEYS *) pTmp.detach();

    pPublicKeysPack->ulLen = ulPrevSize + ulKeyPackSize;
    pPublicKeysPack->cNumofKeys = ulPrevCount + 1;

    return MQSec_OK;
}


//+------------------------------------------------------------------------
//
//  HRESULT MQSec_PackPublicKey()
//
//    pPublicKeyPack- pointer to a strucutre that already contains several
//      keys. A new structure is allocated, the previous one is copied
//      and new key is packed at the end of  the new structure.
//
//+------------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_PackPublicKey(
	IN      BYTE            *pKeyBlob,
	IN      ULONG            ulKeySize,
	IN      LPCWSTR          wszProviderName,
	IN      ULONG            ulProviderType,
	IN OUT  MQDSPUBLICKEYS **ppPublicKeysPack 
	)
/*++

Routine Description:
	Export the input key into a keyblob and Pack it in the end of the PublicKeysPack structure

Arguments:
	pKeyBlob - pointer to key blob to be add to the keys pack
	ulKeySize - key blob size
	wszProviderName - provider name
	ulProviderType - provider type (base, enhanced)
	ppPublicKeysPack - in\out Pointer to Public keys pack, the Key blob will be add 
					   at the end of pPublicKeysPack

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
	ASSERT(ppPublicKeysPack);
	P<MQDSPUBLICKEYS>  pPublicKeysPack = *ppPublicKeysPack;

    HRESULT hr = PackPublicKey( 
					pKeyBlob,
					ulKeySize,
					wszProviderName,
					ulProviderType,
					pPublicKeysPack 
					);

	*ppPublicKeysPack = pPublicKeysPack.detach();

	return hr;
}


//+-----------------------------------------------------------------------
//
//  HRESULT MQSec_UnpackPublicKey()
//
//  Unpack the public key that match the provider requested by caller.
//  The function does NOT allocate the buffer for the public key. It's
//  just set a pointer into the input MQDSPUBLICKEYS structure.
//
//+-----------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_UnpackPublicKey(
	IN  MQDSPUBLICKEYS  *pPublicKeysPack,
	IN  LPCWSTR          wszProviderName,
	IN  ULONG            ulProviderType,
	OUT BYTE           **ppKeyBlob,
	OUT ULONG           *pulKeySize 
	)
{
    ULONG cCount = pPublicKeysPack->cNumofKeys;
    BYTE *pBuf = (BYTE*) pPublicKeysPack->aPublicKeys;

    //
    // The structure is not aligned on 4 byte boundaries, raising
    // alignment fault.
    //
    MQDSPUBLICKEY UNALIGNED *pPublicKey = (MQDSPUBLICKEY *) pBuf;

    for ( ULONG j = 0 ; j < cCount ; j++ )
    {
        BYTE* pKey = (BYTE*) pPublicKey->aBuf;
        LPWSTR wszKeyProv = (WCHAR*) pKey;

        if (lstrcmpi(wszProviderName, wszKeyProv) == 0)
        {
            if (pPublicKey->ulProviderType == ulProviderType)
            {
                pKey += pPublicKey->ulProviderLen;
                *pulKeySize = pPublicKey->ulKeyLen;
                *ppKeyBlob = pKey ;

                return MQSec_OK;
            }
        }

        pBuf =  pKey                      +
                pPublicKey->ulProviderLen +
                pPublicKey->ulKeyLen;

        pPublicKey = (MQDSPUBLICKEY *) pBuf;
    }

    return LogHR(MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST, s_FN, 20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\certifct\mqcert.cpp ===
/*++

Copyright (c) 1997-98 Microsoft Corporation

Module Name:
    mqcert.cpp

Abstract:
    This dll replaces digsig.dll which is obsolete now and will not be
    available on NT5. The main functionality in mqcert.dll is to create
    an internal certificate or read the parameters from an existing
    certificate.

Author:
    Doron Juster (DoronJ)  04-Dec-1997

Revision History:

--*/

#include <stdh_sec.h>
#include "certifct.h"
#include "autorel.h"

#include "mqcert.tmh"

static WCHAR *s_FN=L"certifct/mqcert";

DWORD  g_cOpenCert = 0 ; // count number of opened certificates.
DWORD  g_cOpenCertStore = 0 ; // count number of opened certificates.

//+-----------------------------------------------------------------------
//
//  MQSigCreateCertificate()
//
//  Descruption: Create a certificate object.
//
//   *  if "pCertContext" and pCertBlob are NULL then a new (and empty)
//      certificate is created. the caller then use the certificate object
//      (returned in "ppCert") to fill the certificate and encode it.
//   *  if "pCertContext" is not NULL then a certificate object is created
//      which encapsulate the existing certificate (represented by the
//      certificate context). The object can then be used to retrieve
//      certificate parameters.
//        Note: when object is released, the certificate context is released
//              too.
//   *  if "pCertBlob" is not NULL then a certificate context is build from
//      the encoded blob and the code handle it as above (when pCertContext
//      is not NULL).
//
//+-----------------------------------------------------------------------

HRESULT APIENTRY
MQSigCreateCertificate( OUT CMQSigCertificate **ppCert,
                        IN  PCCERT_CONTEXT      pCertContext,
                        IN  PBYTE               pCertBlob,
                        IN  DWORD               dwCertSize )
{
    if (!ppCert)
    {
        return  LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 40) ;
    }
    *ppCert = NULL ;

    if (pCertContext && pCertBlob)
    {
        //
        // Only one of them can be non-null.
        //
        return  LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 50) ;
    }

    if (pCertBlob)
    {
        //
        // Create the Context
        //
        pCertContext = CertCreateCertificateContext( MY_ENCODING_TYPE,
                                                     pCertBlob,
                                                     dwCertSize ) ;
        if (!pCertContext)
        {
			//
			// Better error can be MQ_ERROR_INVALID_CERTIFICATE_BLOB. ilanh 10-Aug-2000
			//
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to create certificate context from encoded certificate. %!winerr!"), GetLastError()));
            return MQ_ERROR_INVALID_CERTIFICATE;
        }
    }

    P<CMQSigCertificate> pTmpCert = new CMQSigCertificate ;
    g_cOpenCert++ ;

    HRESULT hr = pTmpCert->_Create(pCertContext) ;

    if (SUCCEEDED(hr))
    {
        *ppCert = pTmpCert.detach();
    }

    return  LogHR(hr, s_FN, 70) ;
}

//+-----------------------------------------------------------------------
//
//   MQSigOpenUserCertStore()
//
//  Input:
//      fMachine- TRUE if opening the store of LocalSystem services.
//
//+-----------------------------------------------------------------------

HRESULT APIENTRY
MQSigOpenUserCertStore( OUT CMQSigCertStore **ppStore,
                        IN  LPSTR             lpszRegRoot,
                        IN  struct MQSigOpenCertParams *pParams )
{
    *ppStore = NULL ;

    if ((pParams->bCreate && !pParams->bWriteAccess) || !lpszRegRoot)
    {
        return  LogHR(MQSec_E_INVALID_PARAMETER, s_FN, 80) ;
    }

    R<CMQSigCertStore> pTmpStore = new  CMQSigCertStore ;
    g_cOpenCertStore++ ;

    HRESULT hr = pTmpStore->_Open( lpszRegRoot,
                                   pParams ) ;
    if (SUCCEEDED(hr))
    {
        *ppStore = pTmpStore.detach();
    }

    return LogHR(hr, s_FN, 90) ;
}

//+-----------------------------------------------------------------------
//
//   MQSigCloneCertFromReg()
//
//  description: This function clones a certificate which is in a store.
//      It's used only for registry bases, non-system, certificates stores.
//      The output CMQSigCertificate object can be used without having
//      to keep the store opened.
//      Note: when enumerating certificate contexts in a store, if you
//          want to use one of the certificates you must keep the store
//          open, otherwise the certificate memory is no longer valid.
//          This function overcome this limitation by allocating new
//          memory for the certificate it return.
//      Note: We don't use CertDuplicateCertificateContext because that api
//          does not allocate new memory. It just increment reference count
//          so the store must be kept open.
//
//+-----------------------------------------------------------------------

HRESULT APIENTRY
MQSigCloneCertFromReg( OUT CMQSigCertificate **ppCert,
                 const IN  LPSTR               lpszRegRoot,
                 const IN  LONG                iCertIndex )
{
    *ppCert = NULL ;

    struct MQSigOpenCertParams sStoreParams ;
    memset(&sStoreParams, 0, sizeof(sStoreParams)) ;
    R<CMQSigCertStore> pStore = NULL ;

    HRESULT hr = MQSigOpenUserCertStore(&pStore.ref(),
                                         lpszRegRoot,
                                        &sStoreParams ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100) ;
    }
    HCERTSTORE hStore = pStore->GetHandle() ;

    hr = _CloneCertFromStore ( ppCert,
                               hStore,
                               iCertIndex ) ;
    return LogHR(hr, s_FN, 110) ;
}

//+-----------------------------------------------------------------------
//
//   MQSigCloneCertFromSysStore()
//
//  description: This function clones a certificate which is in a system
//      store. See description of "MQSigCloneCertFromReg()" for more
//      comments and notes.
//
//+-----------------------------------------------------------------------

HRESULT APIENTRY
MQSigCloneCertFromSysStore( OUT CMQSigCertificate **ppCert,
                      const IN  LPSTR               lpszProtocol,
                      const IN  LONG                iCertIndex )
{
    HRESULT hr = MQSec_OK ;

    *ppCert = NULL ;

    HCRYPTPROV hProv ;
    if (!_CryptAcquireVerContext( &hProv ))
    {
        return  LogHR(MQSec_E_CANT_ACQUIRE_CTX, s_FN, 120) ;
    }

    CHCertStore  hSysStore =  CertOpenSystemStoreA( hProv,
                                                    lpszProtocol ) ;
    if (!hSysStore)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to open system certificate store for %hs. %!winerr!"), lpszProtocol, GetLastError()));
        return MQSec_E_CANT_OPEN_SYSSTORE;
    }

    hr = _CloneCertFromStore( ppCert,
                              hSysStore,
                              iCertIndex ) ;
    return LogHR(hr, s_FN, 140) ;
}

/***********************************************************
*
* CertDllMain
*
************************************************************/

BOOL WINAPI CertDllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved)
{
   if (fdwReason == DLL_PROCESS_ATTACH)
   {
   }
   else if (fdwReason == DLL_PROCESS_DETACH)
   {
        ASSERT(g_cOpenCert == 0) ;
        ASSERT(g_cOpenCertStore == 0) ;
   }
   else if (fdwReason == DLL_THREAD_ATTACH)
   {
   }
   else if (fdwReason == DLL_THREAD_DETACH)
   {
   }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypt\encrypt.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: encrypt.h

Abstract:

Author:
    Doron Juster (DoronJ)  19-Nov-1998
    Ilan Herbst  (ilanh)   10-June-2000

Revision History:

--*/

#ifndef _ENCRYPT_H_
#define _ENCRYPT_H_


HRESULT  
GetProviderProperties( 
	IN  enum   enumProvider  eProvider,
	OUT WCHAR **ppwszContainerName,
	OUT WCHAR **ppwszProviderName,
	OUT DWORD  *pdwProviderType 
	);


HRESULT  
SetKeyContainerSecurity( 
	HCRYPTPROV hProv 
	);


HRESULT 
PackPublicKey(
	IN      BYTE				*pKeyBlob,
	IN      ULONG				ulKeySize,
	IN      LPCWSTR				wszProviderName,
	IN      ULONG				ulProviderType,
	IN OUT  P<MQDSPUBLICKEYS>&  pPublicKeysPack 
	);

#endif // _ENCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypt\enhprov.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: enhprov.cpp

Abstract:
    Retreive the parameters of the enhanced provider.
    At present, we support only the Microsoft base provider and Microsoft
    enhanced provider for encryption.
    To give some flexibility to customer, the parameters of the enhanced
    provider can be read from registry.

Author:
    Doron Juster (DoronJ)  19-Nov-1998

Revision History:

--*/

#include <stdh_sec.h>
#include "encrypt.H"
#include <_registr.h>
#include <cs.h>

#include "enhprov.tmh"

static WCHAR *s_FN=L"encrypt/enhprov";

static  CHCryptProv  s_hProvQM_40   = NULL ;
static  CHCryptProv  s_hProvQM_128  = NULL ;

//+--------------------------------------
//
//  HRESULT  GetProviderProperties()
//
//+--------------------------------------

HRESULT  GetProviderProperties( IN  enum   enumProvider  eProvider,
                                OUT WCHAR **ppwszContainerName,
                                OUT WCHAR **ppwszProviderName,
                                OUT DWORD  *pdwProviderType )
{
    HRESULT hr = MQSec_GetCryptoProvProperty( eProvider,
                                              eProvName,
                                              ppwszProviderName,
                                              NULL ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10) ;
    }

    if (ppwszContainerName)
    {
        hr = MQSec_GetCryptoProvProperty( eProvider,
                                          eContainerName,
                                          ppwszContainerName,
                                          NULL ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 20) ;
        }
    }

    hr = MQSec_GetCryptoProvProperty( eProvider,
                                      eProvType,
                                      NULL,
                                      pdwProviderType ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30) ;
    }

    return MQSec_OK ;
}

//+-----------------------------------------------
//
//  HRESULT MQSec_AcquireCryptoProvider()
//
//+-----------------------------------------------

static CCriticalSection s_csAcquireProvider;

HRESULT 
APIENTRY  
MQSec_AcquireCryptoProvider(
	IN  enum enumProvider  eProvider,
	OUT HCRYPTPROV        *phProv 
	)
{
    static BOOL     s_fInitialized_40  = FALSE;
    static HRESULT  s_hrBase = MQSec_OK;

    static BOOL     s_fInitialized_128 = FALSE;
    static HRESULT  s_hrEnh = MQSec_OK;

    switch (eProvider)
    {
        case eEnhancedProvider:
            if (s_fInitialized_128)
            {
                *phProv = s_hProvQM_128;
                return LogHR(s_hrEnh, s_FN, 70);
            }
            break ;

        case eBaseProvider:
            if (s_fInitialized_40)
            {
                *phProv = s_hProvQM_40;
                return LogHR(s_hrBase, s_FN, 80);
            }
            break ;

        default:
            ASSERT(0) ;
            return  LogHR(MQSec_E_UNKNWON_PROVIDER, s_FN, 90);
    }

    //
    // The critical section guard against the case where two threads try to
    // initialize the crypto provider. If the provider was already
    // initialized, then we don't pay the overhead of the critical section.
    // the "initialized" flags must be set to TRUE after the cached handles
    // get their values at the end of this function.
    //
    CS Lock(s_csAcquireProvider);

    HRESULT  hrDefault = MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;

    if (eProvider == eEnhancedProvider)
    {
        if (s_fInitialized_128)
        {
            *phProv = s_hProvQM_128;
            return LogHR(s_hrEnh, s_FN, 100);
        }
        hrDefault = MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED;
    }
    else
    {
        if (s_fInitialized_40)
        {
            *phProv = s_hProvQM_40;
            return LogHR(s_hrBase, s_FN, 110);
        }
    }

    P<WCHAR> pwszContainerName = NULL;
    P<WCHAR> pwszProviderName = NULL;
    DWORD    dwProviderType ;

    *phProv = NULL;
    HRESULT hr = GetProviderProperties( 
						eProvider,
						&pwszContainerName,
						&pwszProviderName,
						&dwProviderType 
						);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120);
    }

    //
    // Get Falcon's machine key set context.
    //
    HCRYPTPROV hProv = NULL;
    BOOL bRet = CryptAcquireContext( 
					&hProv,
					pwszContainerName,
					pwszProviderName,
					dwProviderType,
					CRYPT_MACHINE_KEYSET 
					);
    DWORD dwErr = GetLastError();
    ASSERT(bRet || (dwErr != NTE_BAD_FLAGS));

    if (!bRet)
    {
        LogHR(dwErr, s_FN, 220);

        if (eProvider != eBaseProvider)
        {
            DBGMSG(((DBGMOD_QM | DBGMOD_SECURITY), DBGLVL_WARNING,
                    TEXT("MQSec_AcquireCryptoProvider: Failed to get MSMQ ")
                    TEXT("machine key set context, error = 0x%x"), dwErr));
        }
        else
        {
            DBGMSG(((DBGMOD_QM | DBGMOD_SECURITY), DBGLVL_ERROR,
                    TEXT("MQSec_AcquireCryptoProvider: Failed to get MSMQ ")
                    TEXT("machine key set context, error = 0x%x"), dwErr));
        }

        if (eProvider == eBaseProvider)
        {
            REPORT_CATEGORY(FAIL_ACQUIRE_CRYPTO_BASE, CATEGORY_KERNEL);
        }

        hr = hrDefault;
    }

    LPWSTR  lpwszRegName = NULL;

    if (eProvider == eEnhancedProvider)
    {
        s_hrEnh = hr;
        s_hProvQM_128 = hProv;
        s_fInitialized_128 = TRUE;
        lpwszRegName = MSMQ_ENH_CONTAINER_FIX_REGNAME;
    }
    else
    {
        s_hrBase = hr;
        s_hProvQM_40 = hProv;
        s_fInitialized_40 = TRUE;
        lpwszRegName = MSMQ_BASE_CONTAINER_FIX_REGNAME;
    }

    //
    // Because of a bug in beta3 and rc1 crypto api, control panel can not
    // renew crypto key. To workaround, on first boot, first time the service
    // acquire the crypto provider, it sets again the container security.
    //
    if (hProv && SUCCEEDED(hr))
    {
        DWORD  dwAlreadyFixed = 0;
        DWORD  dwType = REG_DWORD;
        DWORD  dwSize = sizeof(dwAlreadyFixed);

        LONG rc = GetFalconKeyValue( 
						lpwszRegName,
						&dwType,
						&dwAlreadyFixed,
						&dwSize 
						);

        if ((rc != ERROR_SUCCESS) || (dwAlreadyFixed == 0))
        {
            hr = SetKeyContainerSecurity(hProv);
            ASSERT(SUCCEEDED(hr));

            dwAlreadyFixed = 1;
            dwType = REG_DWORD;
            dwSize = sizeof(dwAlreadyFixed);

            rc = SetFalconKeyValue( 
					lpwszRegName,
					&dwType,
					&dwAlreadyFixed,
					&dwSize 
					);
            ASSERT(rc == ERROR_SUCCESS);
        }
    }

    *phProv = hProv;
    return LogHR(hr, s_FN, 130);
}

//+--------------------------------
//
//  HRESULT _GetProvName()
//
//+--------------------------------

STATIC HRESULT _GetProvName( IN  enum enumProvider    eProvider,
                             OUT LPWSTR              *ppwszStringProp )
{
    HRESULT hr = MQSec_OK ;

    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *ppwszStringProp = new WCHAR[ x_MQ_Encryption_Provider_128_len ] ;
            wcscpy(*ppwszStringProp, x_MQ_Encryption_Provider_128) ;
            break ;

        case eBaseProvider:
        case eForeignBaseProvider:
            *ppwszStringProp = new WCHAR[ x_MQ_Encryption_Provider_40_len ] ;
            wcscpy(*ppwszStringProp, x_MQ_Encryption_Provider_40) ;
            break ;

         default:
            ASSERT(0) ;
            hr = MQSec_E_UNKNWON_PROVIDER ;
            break ;
    }

    return LogHR(hr, s_FN, 140) ;
}

//+-----------------------------------
//
//  HRESULT _GetProvContainerName()
//
//+-----------------------------------

STATIC HRESULT _GetProvContainerName(
                                IN  enum enumProvider    eProvider,
                                OUT LPWSTR              *ppwszStringProp )
{
    //
    // We need to read the value from registry since
    // multiple QMs can live on same machine, each with
    // its own value, stored in its own registry. (ShaiK)
    //

    *ppwszStringProp = new WCHAR[255] ;
    DWORD   cbSize = 255 * sizeof(WCHAR);
    DWORD   dwType = REG_SZ;
    LONG    rc = ERROR_SUCCESS;
    HRESULT hr = MQSec_OK ;

    switch (eProvider)
    {
        case eEnhancedProvider:
            rc = GetFalconKeyValue(
                     MSMQ_CRYPTO128_CONTAINER_REG_NAME,
                     &dwType,
                     *ppwszStringProp,
                     &cbSize,
                     MSMQ_CRYPTO128_DEFAULT_CONTAINER
                     );
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break ;

        case eForeignEnhProvider:
            rc = GetFalconKeyValue(
                      MSMQ_FORGN_ENH_CONTAINER_REGNAME,
                     &dwType,
                     *ppwszStringProp,
                     &cbSize,
                      MSMQ_FORGN_ENH_DEFAULT_CONTAINER
                     );
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break ;

        case eBaseProvider:
            rc = GetFalconKeyValue(
                     MSMQ_CRYPTO40_CONTAINER_REG_NAME,
                     &dwType,
                     *ppwszStringProp,
                     &cbSize,
                     MSMQ_CRYPTO40_DEFAULT_CONTAINER
                     );
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break ;

        case eForeignBaseProvider:
            rc = GetFalconKeyValue(
                      MSMQ_FORGN_BASE_CONTAINER_REGNAME,
                     &dwType,
                     *ppwszStringProp,
                     &cbSize,
                      MSMQ_FORGN_BASE_DEFAULT_CONTAINER
                     );
            ASSERT(("failed to read registry", ERROR_SUCCESS == rc));
            break ;

        default:
            ASSERT(("should not get here!", 0));
            hr = MQSec_E_UNKNWON_PROVIDER ;
            break ;
    }

    return LogHR(hr, s_FN, 150) ;
}

//+--------------------------------
//
//  HRESULT _GetProvType()
//
//+--------------------------------

STATIC HRESULT _GetProvType( IN  enum enumProvider    eProvider,
                             OUT DWORD               *pdwProp )
{
    HRESULT hr = MQSec_OK ;

    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *pdwProp = x_MQ_Encryption_Provider_Type_128 ;
            break ;

        case eBaseProvider:
        case eForeignBaseProvider:
            *pdwProp = x_MQ_Encryption_Provider_Type_40 ;
            break ;

        default:
            ASSERT(0) ;
            hr = MQSec_E_UNKNWON_PROVIDER ;
            break ;
    }

    return LogHR(hr, s_FN, 160) ;
}

//+-----------------------------------
//
//  HRESULT _GetProvSessionKeySize()
//
//+-----------------------------------

STATIC HRESULT _GetProvSessionKeySize( IN  enum enumProvider   eProvider,
                                       OUT DWORD              *pdwProp )
{
    HRESULT hr = MQSec_OK ;

    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *pdwProp = x_MQ_SymmKeySize_128 ;
            break ;

        case eBaseProvider:
        case eForeignBaseProvider:
            *pdwProp = x_MQ_SymmKeySize_40 ;
            break ;

        default:
            ASSERT(0) ;
            hr = MQSec_E_UNKNWON_PROVIDER ;
            break ;
    }

    return LogHR(hr, s_FN, 170) ;
}

//+-----------------------------------
//
//  HRESULT _GetProvBlockSize()
//
//+-----------------------------------

STATIC HRESULT _GetProvBlockSize( IN  enum enumProvider   eProvider,
                                  OUT DWORD              *pdwProp )
{
    HRESULT hr = MQSec_OK ;

    switch (eProvider)
    {
        case eEnhancedProvider:
        case eForeignEnhProvider:
            *pdwProp = x_MQ_Block_Size_128 ;
            break ;

        case eBaseProvider:
        case eForeignBaseProvider:
            *pdwProp = x_MQ_Block_Size_40 ;
            break ;

        default:
            ASSERT(0) ;
            hr = MQSec_E_UNKNWON_PROVIDER ;
            break ;
    }

    return LogHR(hr, s_FN, 180) ;
}

//+--------------------------------------------
//
//  HRESULT  MQSec_GetCryptoProvProperty()
//
//+--------------------------------------------

HRESULT APIENTRY  MQSec_GetCryptoProvProperty(
                                     IN  enum enumProvider     eProvider,
                                     IN  enum enumCryptoProp   eProp,
                                     OUT LPWSTR         *ppwszStringProp,
                                     OUT DWORD          *pdwProp )
{
    HRESULT hr = MQSec_OK ;

    switch (eProp)
    {
        case eProvName:
            hr = _GetProvName( eProvider,
                               ppwszStringProp ) ;
            break ;

        case eProvType:
            hr = _GetProvType( eProvider,
                               pdwProp ) ;
            break ;

        case eSessionKeySize:
            hr = _GetProvSessionKeySize( eProvider,
                                         pdwProp ) ;
            break ;

        case eContainerName:
            hr = _GetProvContainerName( eProvider,
                                        ppwszStringProp ) ;
            break ;

        case eBlockSize:
            hr = _GetProvBlockSize( eProvider,
                                    pdwProp ) ;
            break ;

        default:
            ASSERT(0) ;
            hr = MQSec_E_UNKNWON_CRYPT_PROP ;
            break ;
    }

    return LogHR(hr, s_FN, 190) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypt\pbkeys.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pbkeys.cpp

Abstract:

    Public keys operations.

 1. If the machine key container does not exist, create it, and create
    the key exchange and signature key sets.
 2. If the machine key container exist and the keys should be
    re-generated (fRegenerate == TRUE), re-generate the keys.
 3. Send the key exchange public key to the DS.
 4. Send the signature public key to the DS.

Author:

    Boaz Feldbaum (BoazF)   30-Oct-1996.
    Doron Juster  (DoronJ)  23-Nov-1998, adapt for multiple provider
	Ilan Herbst   (ilanh)   01-Jun-2000, integrate AD lib

--*/

#include <stdh_sec.h>
#include <mqutil.h>
#include <dsproto.h>
#include "encrypt.H"
#include <uniansi.h>
#include "ad.h"

#include "pbkeys.tmh"

static WCHAR *s_FN=L"encrypt/pbkeys";

//
// DsEnv Initialization Control
//
static LONG s_fDsEnvInitialized = FALSE;
static eDsEnvironment s_DsEnv = eUnknown;  


static bool DsEnvIsMqis(void)
/*++

Routine Description:
	check the Ds Enviroment: eAD or eMqis

Arguments:
	None

Returned Value:
	true if the DsEnv is eMqis false if eAD or eUnknown (Workgroup)

--*/
{

	if(!s_fDsEnvInitialized)
	{
		//
		// The s_DsEnv was not initialized, init s_DsEnv
		//
		s_DsEnv = ADGetEnterprise();

		LONG fDsEnvAlreadyInitialized = InterlockedExchange(&s_fDsEnvInitialized, TRUE);

		//
		// The s_DsEnv has *already* been initialized. You should
		// not initialize it more than once. This assertion would be violated
		// if two or more threads initalize it concurently.
		//
		DBG_USED(fDsEnvAlreadyInitialized);
		ASSERT(!fDsEnvAlreadyInitialized);
	}

	if(s_DsEnv == eMqis)
		return true;

	//
	// eAD or eUnknown (WorkGroup)
	// 
	return false;

}


//+-------------------------------------------------------------------
//
//  HRESULT SetKeyContainerSecurity( HCRYPTPROV hProv )
//
// Note: This function is also called when registering an internal
//       certificte for LocalSystem service.
//
//+-------------------------------------------------------------------

HRESULT  SetKeyContainerSecurity( HCRYPTPROV hProv )
{
    //
    // Modify the security of the key container, so that the key container
    // will not be accessible in any way by non-admin users.
    //
    SECURITY_DESCRIPTOR SD;
    PSID pAdminSid;
    P<ACL> pDacl;
    DWORD dwDaclSize;
    SID_IDENTIFIER_AUTHORITY NtSecAuth = SECURITY_NT_AUTHORITY;

    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    AllocateAndInitializeSid(
        &NtSecAuth,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0,
        0,
        0,
        0,
        0,
        0,
        &pAdminSid
		);

    dwDaclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                 GetLengthSid(pAdminSid) - sizeof(DWORD);
 
	pDacl = (PACL)(char*) new BYTE[dwDaclSize];
    InitializeAcl(pDacl, dwDaclSize, ACL_REVISION);
    AddAccessAllowedAce(pDacl, ACL_REVISION, KEY_ALL_ACCESS, pAdminSid);
    SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE);

    if (!CryptSetProvParam(
			hProv,
			PP_KEYSET_SEC_DESCR,
			(BYTE*)&SD,
			DACL_SECURITY_INFORMATION
			))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Can't set the security descriptor of the machine key set. %!winerr!"), GetLastError()));
        FreeSid(pAdminSid);
        return LogHR(MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR, s_FN, 30) ;
    }

    FreeSid(pAdminSid);

    return(MQ_OK);
}

//+---------------------------------------
//
//   HRESULT _ExportAndPackKey()
//
//+---------------------------------------

STATIC 
HRESULT 
_ExportAndPackKey( 
	IN  HCRYPTKEY   hKey,
	IN  WCHAR      *pwszProviderName,
	IN DWORD        dwProviderType,
	IN OUT P<MQDSPUBLICKEYS>&  pPublicKeysPack 
	)
/*++

Routine Description:
	Export the input key into a keyblob and Pack it in the end of the PublicKeysPack structure

Arguments:
	hKey - input key to be exported and packed
	pwszProviderName - provider name
	dwProviderType - provider type (base, enhanced)
	pPublicKeysPack - in\out Pointer to Public keys pack, the hKey blob will be add 
					   add the end of pPublicKeysPack

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    AP<BYTE> pKeyBlob = NULL;
    DWORD   dwKeyLength;
    DWORD   dwErr;

    BOOL bRet = CryptExportKey( 
					hKey,
					NULL,
					PUBLICKEYBLOB,
					0,
					NULL, // key blob
					&dwKeyLength 
					);
    if (!bRet)
    {
        dwErr = GetLastError();
        LogHR(dwErr, s_FN, 40);

        return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
    }

    pKeyBlob = new BYTE[dwKeyLength];

    bRet = CryptExportKey( 
				hKey,
				NULL,
				PUBLICKEYBLOB,
				0,
				pKeyBlob,
				&dwKeyLength 
				);
    if (!bRet)
    {
        dwErr = GetLastError();
        LogHR(dwErr, s_FN, 50);

        return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
    }

    HRESULT hr = PackPublicKey( 
					pKeyBlob,
					dwKeyLength,
					pwszProviderName,
					dwProviderType,
					pPublicKeysPack 
					);

    return LogHR(hr, s_FN, 60);
}


//+------------------------------------
//
//   HRESULT GetPbKeys()
//
//+------------------------------------

STATIC 
HRESULT 
GetPbKeys(
	IN  BOOL          fRegenerate,
	IN  LPCWSTR		  pwszContainerName,
	IN  LPCWSTR		  pwszProviderName,
	IN  DWORD		  dwProviderType,
	IN  HRESULT       hrDefault,
	OUT HCRYPTPROV   *phProv,
	OUT HCRYPTKEY    *phKeyxKey,
	OUT HCRYPTKEY    *phSignKey
	)
/*++

Routine Description:
	Generate or retrieve Public keys for signing and for session key exchange

Arguments:
	fRegenerate - flag for regenerate new keys or just retrieve the existing keys
	pwszContainerName - container name
	pwszProviderName - provider name
	dwProviderType - provider type (base, enhanced)
	hrDefault - default hr return value
	phProv - pointer to crypto provider handle
	phKeyxKey - pointer to exchange key handle 
	phSignKey - pointer to sign key handle

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    //
    // By default, try to create a new keys container.
    //
    BOOL fSuccess = CryptAcquireContext( 
						phProv,
						pwszContainerName,
						pwszProviderName,
						dwProviderType,
						(CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET) 
						);

	HRESULT hr;
    DWORD dwErr = 0;

	if (fSuccess)
    {
        //
        // New container created. Set the container security.
        //
        hr = SetKeyContainerSecurity(*phProv);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 70);
        }

        fRegenerate = TRUE;
    }
	else    
    {
        dwErr = GetLastError();
        
		if (dwErr != NTE_EXISTS)
        {
            LogHR(dwErr, s_FN, 80);
            return hrDefault;
		}
		
		//
		// NTE_EXISTS
        // The key set already exist, so just acquire the CSP context.
        //
        fSuccess = CryptAcquireContext( 
						phProv,
						pwszContainerName,
						pwszProviderName,
						dwProviderType,
						CRYPT_MACHINE_KEYSET 
						);
        if (!fSuccess)
        {
            //
            // Can't open the keys container.
            // We delete previous keys container and create a new one
            // in three cases:
            // 1. The keys got corrupted.
            // 2. We're asked to regenerate the keys themselves. In that
            //    case, old container does not have much value.
            //    This case also happen during setup or upgrade from
            //    nt4/win9x, because of bugs in crypto api that do not
            //    translate correctly the security descriptor of the key
            //    container, when migrating the keys from registry to
            //    file format. See msmq bug 4561, nt bug 359901.
            // 3. Upgrade of cluster. That's probably a CryptoAPI bug,
            //    we just workaround it. msmq bug 4839.
            //
            DWORD dwErr = GetLastError();
            LogHR(dwErr, s_FN, 90);

            if (fRegenerate || (dwErr == NTE_KEYSET_ENTRY_BAD))
            {
                //
                // Delete the bad key container.
                //
                fSuccess = CryptAcquireContext( 
								phProv,
								pwszContainerName,
								pwszProviderName,
								dwProviderType,
								(CRYPT_MACHINE_KEYSET | CRYPT_DELETEKEYSET)
								);
                if (!fSuccess)
                {
                    dwErr = GetLastError();
                    LogHR(dwErr, s_FN, 100);

                    return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
                }

                //
                // Re-create the key container.
                //
                fSuccess = CryptAcquireContext( 
								phProv,
								pwszContainerName,
								pwszProviderName,
								dwProviderType,
								(CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET)
								);
                if (!fSuccess)
                {
                    dwErr = GetLastError();
                    LogHR(dwErr, s_FN, 110);

                    return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
                }

                //
                // Set the container security.
                //
                hr = SetKeyContainerSecurity(*phProv);
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 120);
                }

                //
                // Now we must generate new key sets.
                //
                fRegenerate = TRUE;
            }
            else
            {
                return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 130);
            }
        }

        if (!fRegenerate)
        {
            //
            // Retrieve the key exchange key set.
            //
			fSuccess = CryptGetUserKey(*phProv, AT_KEYEXCHANGE, phKeyxKey);
            if (!fSuccess)
            {
                dwErr = GetLastError();
                LogHR(dwErr, s_FN, 140);
                return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
            }

            //
            // Retrieve the signing key set.
            //
			fSuccess = CryptGetUserKey(*phProv, AT_SIGNATURE, phSignKey);
            if (!fSuccess)
            {
                dwErr = GetLastError();
                LogHR(dwErr, s_FN, 150);
                return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
            }
        }
    }

    if (fRegenerate)
    {
        //
        // Re-generate the key exchange key set.
        //
        fSuccess = CryptGenKey( 
						*phProv,
						AT_KEYEXCHANGE,
						CRYPT_EXPORTABLE,
						phKeyxKey 
						);
        if (!fSuccess)
        {
            dwErr = GetLastError();
            LogHR(dwErr, s_FN, 160);
            return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
        }

        //
        // Re-generate the signing key set.
        //
        fSuccess = CryptGenKey( 
						*phProv,
						AT_SIGNATURE,
						CRYPT_EXPORTABLE,
						phSignKey 
						);
        if (!fSuccess)
        {
            dwErr = GetLastError();
            LogHR(dwErr, s_FN, 170);
            return MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
        }
    }
	return MQSec_OK;
}


//+------------------------------------
//
//   HRESULT _PrepareKeyPacks()
//
//+------------------------------------

STATIC 
HRESULT 
_PrepareKeyPacks(
	IN  BOOL                 fRegenerate,
	IN  enum enumProvider    eProvider,
	IN OUT P<MQDSPUBLICKEYS>&  pPublicKeysPackExch,
	IN OUT P<MQDSPUBLICKEYS>&  pPublicKeysPackSign 
	)
/*++

Routine Description:
	Prepare exchange PublicKeys pack and Signature PublicKeys pack.

Arguments:
	fRegenerate - flag for regenerate new keys or just retrieve the existing keys.
	eProvider - Provider type.
    pPublicKeysPackExch - exchange PublicKeys pack.
	pPublicKeysPackSign - signature PublicKeys pack.

Returned Value:
    MQ_SecOK, if successful, else error code.

--*/
{
    HRESULT hrDefault = MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION;
    if (eProvider != eBaseProvider)
    {
        hrDefault = MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED;
    }

    AP<WCHAR>  pwszProviderName = NULL;
    AP<WCHAR>  pwszContainerName = NULL;
    DWORD     dwProviderType;

    HRESULT hr = GetProviderProperties( 
					eProvider,
					&pwszContainerName,
					&pwszProviderName,
					&dwProviderType 
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    CHCryptProv hProv;
    CHCryptKey  hKeyxKey;
    CHCryptKey  hSignKey;

    hr = GetPbKeys(
			fRegenerate,
			pwszContainerName,
			pwszProviderName,
			dwProviderType,
			hrDefault,
			&hProv,
			&hKeyxKey,
			&hSignKey
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 190);
    }

    //
    // Export key and pack it.
    // On MSMQ1.0, we could have been called for site object (from PSC) and
    // machine object. Only machine object need the key exchange key.
    // On MSMQ2.0, we expect to be called only for machine object.
    //
    hr = _ExportAndPackKey( 
			hKeyxKey,
			pwszProviderName,
			dwProviderType,
			pPublicKeysPackExch 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }

    hr = _ExportAndPackKey( 
			hSignKey,
			pwszProviderName,
			dwProviderType,
			pPublicKeysPackSign 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 210);
    }

    return MQSec_OK;
}


//+----------------------------------------------------------------
//
//  HRESULT PbKeysBlobMQIS()
//
//  This code is taken as is from MSMQ1.0 (mqutil\pbkeys.cpp).
//  It's used when server is msmq1.0 on nt4.
//
//+----------------------------------------------------------------

STATIC 
HRESULT 
PbKeysBlobMQIS(
	IN BOOL fRegenerate,
	IN enum enumProvider eBaseCrypProv,
	OUT BLOB * pblobEncrypt,
	OUT BLOB * pblobSign 
	)
{
    BYTE abSignPbK[1024];
    BYTE abKeyxPbK[1024];
    PMQDS_PublicKey pMQDS_SignPbK = (PMQDS_PublicKey)abSignPbK;
    PMQDS_PublicKey pMQDS_KeyxPbK = (PMQDS_PublicKey)abKeyxPbK;

    //
    // We need to read the keys from registry since multiple
    // QMs can live on same machine, each with its own keys,
    // stored in its own registry. (ShaiK)
    //
    WCHAR wzContainer[255] = {L""};
    DWORD cbSize = sizeof(wzContainer);
    DWORD dwType = REG_SZ;

    LONG rc = GetFalconKeyValue(
                  MSMQ_CRYPTO40_CONTAINER_REG_NAME,
                  &dwType,
                  wzContainer,
                  &cbSize,
                  MSMQ_CRYPTO40_DEFAULT_CONTAINER
                  );

	DBG_USED(rc);
    ASSERT(("failed to read from registry", ERROR_SUCCESS == rc));

    //
    // OK, we're almost safe, lets hope the DS will not go off from now until we
    // update the public keys in it...
    //
	CHCryptProv  hProv;
    CHCryptKey hKeyxKey;
    CHCryptKey hSignKey;

    HRESULT hr = GetPbKeys(
					fRegenerate,
					wzContainer,
					MS_DEF_PROV,
					PROV_RSA_FULL,
					MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION,
					&hProv,
					&hKeyxKey,
					&hSignKey
					);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 320);
    }
	
    //
    // Always machine when calling this function
	// Set the key exchange public key blob, only for a machine object.
    //

	//
    // Get the key exchange public key blob
    //
    pMQDS_KeyxPbK->dwPublikKeyBlobSize = sizeof(abKeyxPbK) - sizeof(DWORD);
    if (!CryptExportKey(
            hKeyxKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            pMQDS_KeyxPbK->abPublicKeyBlob,
            &pMQDS_KeyxPbK->dwPublikKeyBlobSize
			))
    {
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 330);
    }

    //
    // Set the signature public key blob.
    //
    pMQDS_SignPbK->dwPublikKeyBlobSize = sizeof(abSignPbK) - sizeof(DWORD);
    if (!CryptExportKey(
            hSignKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            pMQDS_SignPbK->abPublicKeyBlob,
            &pMQDS_SignPbK->dwPublikKeyBlobSize
			))
    {
        return LogHR(MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION, s_FN, 350);
    }

	AP<BYTE> pTempEncryptBlob = new BYTE[pMQDS_KeyxPbK->dwPublikKeyBlobSize];
    memcpy(pTempEncryptBlob, pMQDS_KeyxPbK->abPublicKeyBlob, pMQDS_KeyxPbK->dwPublikKeyBlobSize);

	AP<BYTE> pTempSignBlob = new BYTE[pMQDS_SignPbK->dwPublikKeyBlobSize];
    memcpy(pTempSignBlob, pMQDS_SignPbK->abPublicKeyBlob, pMQDS_SignPbK->dwPublikKeyBlobSize);

    pblobEncrypt->cbSize = pMQDS_KeyxPbK->dwPublikKeyBlobSize;
    pblobEncrypt->pBlobData = pTempEncryptBlob.detach();

    pblobSign->cbSize = pMQDS_SignPbK->dwPublikKeyBlobSize;
    pblobSign->pBlobData = pTempSignBlob.detach();

    return MQSec_OK;
}


//+----------------------------------------------------------------------
//
//  HRESULT  MQSec_StorePubKeys()
//
//  This function always store four keys in local machine:
//  Key-Exchange and signing for Base provider and similar two keys
//  for enhanced provider.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY 
MQSec_StorePubKeys( 
	IN BOOL fRegenerate,
	IN enum enumProvider eBaseCrypProv,
	IN enum enumProvider eEnhCrypProv,
	OUT BLOB * pblobEncrypt,
	OUT BLOB * pblobSign 
	)
{
    P<MQDSPUBLICKEYS>  pPublicKeysPackExch = NULL;
    P<MQDSPUBLICKEYS>  pPublicKeysPackSign = NULL;

    HRESULT hr = _PrepareKeyPacks( 
					fRegenerate,
					eBaseCrypProv,
					pPublicKeysPackExch,
					pPublicKeysPackSign 
					);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 360);
    }

    hr = _PrepareKeyPacks( 
			fRegenerate,
			eEnhCrypProv,
			pPublicKeysPackExch,
			pPublicKeysPackSign 
			);
	//
    //  ignore error at this stage
    //

	//
	// Encrypt Blob
	//
    MQDSPUBLICKEYS * pBuf   = pPublicKeysPackExch;
    pblobEncrypt->cbSize    = pPublicKeysPackExch->ulLen;
    pblobEncrypt->pBlobData = (BYTE*) pBuf;

	//
	// Sign Blob
	//
    pBuf                    = pPublicKeysPackSign;
    pblobSign->cbSize       = pPublicKeysPackSign->ulLen;
    pblobSign->pBlobData    = (BYTE*) pBuf;

    pPublicKeysPackExch.detach();
    pPublicKeysPackSign.detach();

    return MQSec_OK;

} // MQSec_StorePubKeys

//+----------------------------------------------------------------------
//
//  HRESULT  MQSec_StorePubKeysInDS()
//
//  This function always store four keys in the DS:
//  Key-Exchange and signing for Base provider and similar two keys
//  for enhanced provider.
//
//+----------------------------------------------------------------------

HRESULT 
APIENTRY 
MQSec_StorePubKeysInDS( 
	IN BOOL      fRegenerate,
	IN LPCWSTR   wszObjectName,
	IN DWORD     dwObjectType
	)
{
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwMachineNameSize = sizeof(szMachineName) /sizeof(TCHAR);

    enum enumProvider eBaseCrypProv = eBaseProvider ;
    enum enumProvider eEnhCrypProv = eEnhancedProvider ;

    if (dwObjectType == MQDS_FOREIGN_MACHINE)
    {
        if (wszObjectName == NULL)
        {
            //
            // Name of foreign machine must be provided.
            //
            return LogHR(MQ_ERROR_ILLEGAL_OPERATION, s_FN, 380) ;
        }

        eBaseCrypProv = eForeignBaseProvider ;
        eEnhCrypProv = eForeignEnhProvider ;
        dwObjectType = MQDS_MACHINE ;
    }
    else if (dwObjectType != MQDS_MACHINE)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 390);
    }

	HRESULT hr;
    if (!wszObjectName)
    {
        hr = GetComputerNameInternal(szMachineName, &dwMachineNameSize) ;
        if (FAILED(hr))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 400);
        }
        wszObjectName = szMachineName;
    }
    //
    //  Explicit ADInit call to override the default of downlevel 
    //  notification support.
    //
    //  NOTE - overriding the default is ok because this API is used to 
    //         update either this computer or foreign computers (to which MSMQ
    //         doesn't send notifications).
    //
    hr = ADInit(
            NULL,   // pLookDS
            NULL,   // pGetServers
            false,  // fDSServerFunctionality
            false,  // fSetupMode
            false,  // fQMDll
			false,  // fIgnoreWorkGroup
            NULL,   // pNoServerAuth
            NULL,   // szServerName
            true   // fDisableDownlevelNotifications
            );
    if (FAILED(hr))
    {
        return LogHR(MQ_ERROR, s_FN, 401);
    }

    //
    // First verify that the DS is reachable and that we have access rights
    // to do what we want to do. We don't want to change the keys before we
    // verify this.
    //

    //
    // Read the signature public key from the DS. This way we verify that the
    // DS is available, at least for the moment, and that we have read
    // permissions access rights on the object.
    //
    PROPID propId = PROPID_QM_SIGN_PK;
    PROPVARIANT varKey ;
    varKey.vt = VT_NULL ;

    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,      // pwcsDomainController
				false,	   // fServerName
				wszObjectName,
				1,
				&propId,
				&varKey
				);
	
	if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 410);
    }

    //
    // Write the signature public key in the DS. This way we verify that the
    // DS is still available and that we have write permissions on the object.
    //
    hr = ADSetObjectProperties(
				eMACHINE,
				NULL,		// pwcsDomainController
				false,		// fServerName
				wszObjectName,
				1,
				&propId,
				&varKey
				);
	
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 420);
    }

    //
    // OK, we're almost safe, lets hope the DS will not go off from now until
    // we update the public keys in it...
    //
    BLOB blobEncrypt;
    blobEncrypt.cbSize    = 0;
    blobEncrypt.pBlobData = NULL;

    BLOB blobSign;
    blobSign.cbSize       = 0;
    blobSign.pBlobData    = NULL;

	if(DsEnvIsMqis())
	{
		hr = PbKeysBlobMQIS( 
				fRegenerate,
				eBaseCrypProv,
				&blobEncrypt,
				&blobSign 
				);

	}
	else // eAD
	{
		hr = MQSec_StorePubKeys( 
				fRegenerate,
				eBaseCrypProv,
				eEnhCrypProv,
				&blobEncrypt,
				&blobSign 
				);
	}

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 430);
    }

    AP<BYTE> pCleaner1     = blobEncrypt.pBlobData;
    AP<BYTE> pCleaner2     = blobSign.pBlobData;

    //
    // Write the public keys in the DS.
    //
	propId = PROPID_QM_ENCRYPT_PK;
    varKey.vt = VT_BLOB;
    varKey.blob = blobEncrypt;

    hr = ADSetObjectProperties(
				eMACHINE,
				NULL,		// pwcsDomainController
				false,		// fServerName
				wszObjectName,
				1,
				&propId,
				&varKey
				);
	
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 440);
    }

    propId = PROPID_QM_SIGN_PK;
    varKey.vt = VT_BLOB ;
    varKey.blob = blobSign;

    hr = ADSetObjectProperties(
				eMACHINE,
				NULL,		// pwcsDomainController
				false,		// fServerName
				wszObjectName,
				1,
				&propId,
				&varKey
				);
	
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 450);
    }

    return MQSec_OK ;
}

//+-------------------------------------------------------------------------
//
//  HRESULT  MQSec_GetPubKeysFromDS()
//
//  if caller supply machine guid, then "pfDSGetObjectPropsGuidEx" must be
//  pointer to "DSGetObjectPropsGuidEx". Otherwise, if caller supply machine
//  name, it must be pointer to "DSGetObjectPropsGuidEx".
//
//+-------------------------------------------------------------------------

HRESULT 
APIENTRY  
MQSec_GetPubKeysFromDS(
	IN  const GUID  *pMachineGuid,
	IN  LPCWSTR      lpwszMachineName,
	IN  enum enumProvider     eProvider,
	IN  DWORD        propIdKeys,
	OUT BYTE       **ppPubKeyBlob,
	OUT DWORD       *pdwKeyLength 
	)
{

	//
	// Since all AD* will return PROPID_QM_ENCRYPT_PK unpack
	// assert so if we are called with this prop, change the code
	//
	ASSERT(propIdKeys != PROPID_QM_ENCRYPT_PK);

    if ((eProvider != eBaseProvider) && (DsEnvIsMqis()))
    {
        //
        // msmq1.0 server support only base providers.
        //
        return LogHR(MQ_ERROR_PUBLIC_KEY_NOT_FOUND, s_FN, 460);
    }

    if ((eProvider == eBaseProvider) && (propIdKeys == PROPID_QM_ENCRYPT_PKS) && (DsEnvIsMqis()))
    {
        //
        // msmq1.0 server support only PROPID_QM_ENCRYPT_PK
        //
		propIdKeys = PROPID_QM_ENCRYPT_PK;
    }
    
	P<WCHAR>  pwszProviderName = NULL;
    DWORD     dwProviderType;

    HRESULT hr =  GetProviderProperties( 
						eProvider,
						NULL,
						&pwszProviderName,
						&dwProviderType 
						);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 470);
    }
    ASSERT(pwszProviderName);

    PROPID propId = (PROPID)  propIdKeys;
    PROPVARIANT  varKey;
    varKey.vt = VT_NULL;

    //
    // The Ex queries used below are supported only on Windows 2000. If
    // a Windows 2000 client is served only by NT4 MQIS servers, then the
    // query will fail with error MQ_ERROR_NO_DS. We don't want the mqdscli
    // code to search for all DS servers, looking for a Windows 2000 DC.
    // That's the reason for the FALSE parameter. That means that 128 bit
    // encryption is fully supported only in native mode, i.e., when all
    // DS servers are Windows 2000.
    // Better solutions are to enabled per-thread server lookup (as is
    // enabled in run-time) or lazy query of encryption key. both are
    // expensive in terms of coding and testing.
    // Note that the FALSE flag is effective only if the server is alive and
    // is indeed a NT4 one. If DS servers are not availalbe, then mqdscli
    // wil look for available servers.
    //

    if (pMachineGuid)
    {
        ASSERT(!lpwszMachineName);

        hr = ADGetObjectPropertiesGuid(
				eMACHINE,
				NULL,      // pwcsDomainController
				false,	   // fServerName
				pMachineGuid,
				1,
				&propId,
				&varKey
				);
	
	}
    else if (lpwszMachineName)
    {
        hr = ADGetObjectProperties(
				eMACHINE,
				NULL,      // pwcsDomainController
				false,	   // fServerName
				lpwszMachineName,
				1,
				&propId,
				&varKey
				);
	}
    else
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 480);
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 510);
    }

    if (varKey.blob.pBlobData == NULL)
    {
        return LogHR(MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST, s_FN, 520);
    }

    ASSERT(varKey.vt == VT_BLOB);

	if(DsEnvIsMqis())
	{
		//
		// msmq1.0 treatment
		//
		*ppPubKeyBlob = varKey.blob.pBlobData;
		*pdwKeyLength = varKey.blob.cbSize;
	    return MQSec_OK;
	}

	//
	// msmq2.0 treatment eAD
	// 
	ASSERT(s_DsEnv == eAD);

    P<MQDSPUBLICKEYS> pPublicKeysPack =
                           (MQDSPUBLICKEYS*) varKey.blob.pBlobData;
    ASSERT(pPublicKeysPack->ulLen == varKey.blob.cbSize);
    if ((long) (pPublicKeysPack->ulLen) > (long) (varKey.blob.cbSize))
    {
        //
        // Either blob is corrupted or we read a beta2 format (same as
        // MQIS, key blob without package).
        //
        return  LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 530);
    }

    ULONG ulKeySize;
    BYTE *pKeyBlob = NULL;

    hr = MQSec_UnpackPublicKey( 
			pPublicKeysPack,
			pwszProviderName,
			dwProviderType,
			&pKeyBlob,
			&ulKeySize 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 540);
    }
    ASSERT(pKeyBlob);

    *pdwKeyLength = ulKeySize;
    *ppPubKeyBlob = new BYTE[*pdwKeyLength];
    memcpy(*ppPubKeyBlob, pKeyBlob, *pdwKeyLength);

    return MQSec_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypttest\adsimulate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    AdSimulate.cpp

Abstract:
    simulate Ad lib	functions

Author:
    Ilan Herbst (ilanh) 14-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "mqprops.h"
#include "mqaddef.h"
#include "mq.h"
#include "dsproto.h"
#include "EncryptTestPrivate.h"

#include "adsimulate.tmh"

//
// Those blobs simulate DS content
//
static P<MQDSPUBLICKEYS> s_BlobSign = NULL;
static P<MQDSPUBLICKEYS> s_BlobEncrypt = NULL;


void
InitADBlobs(
	void
	)
/*++

Routine Description:
    Init s_BlobEncrypt and s_BlobSign that simulate the AD content

Arguments:
	None

Returned Value:
    None

--*/
{
    TrTRACE(AdSimulate, "Init AD Blobs");

	//
	// Pack Ex Keys	of const data
	//
    MQDSPUBLICKEYS *pPublicKeysPackExch = NULL;

    HRESULT hr = MQSec_PackPublicKey( 
					(BYTE *)xBaseExKey,
					strlen(xBaseExKey),
					x_MQ_Encryption_Provider_40,
					x_MQ_Encryption_Provider_Type_40,
					&pPublicKeysPackExch 
					);

    if (FAILED(hr))
    {
        TrERROR(AdSimulate, "MQSec_PackPublicKey failed hr = %x", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackExch = pPublicKeysPackExch;
        ASSERT(0);
		return;
    }

    hr = MQSec_PackPublicKey( 
			(BYTE *)xEnhExKey,
			strlen(xEnhExKey),
			x_MQ_Encryption_Provider_128,
			x_MQ_Encryption_Provider_Type_128,
			&pPublicKeysPackExch 
			);

    if (FAILED(hr))
    {
        TrERROR(AdSimulate, "MQSec_PackPublicKey failed hr = %x", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackExch = pPublicKeysPackExch;
        ASSERT(0);
		return;
    }

	//
	// Init s_BlobEncrypt
	//
	s_BlobEncrypt = pPublicKeysPackExch;

	//
	// Pack Sign Keys of const data
	//
    MQDSPUBLICKEYS *pPublicKeysPackSign = NULL;

    hr = MQSec_PackPublicKey( 
			(BYTE *)xBaseSignKey,
			strlen(xBaseSignKey),
			x_MQ_Encryption_Provider_40,
			x_MQ_Encryption_Provider_Type_40,
			&pPublicKeysPackSign 
			);

    if (FAILED(hr))
    {
        TrERROR(AdSimulate, "MQSec_PackPublicKey failed hr = %x", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackSign = pPublicKeysPackSign;
        ASSERT(0);
		return;
    }

	hr = MQSec_PackPublicKey( 
			(BYTE *)xEnhSignKey,
			strlen(xEnhSignKey),
			x_MQ_Encryption_Provider_128,
			x_MQ_Encryption_Provider_Type_128,
			&pPublicKeysPackSign 
			);

    if (FAILED(hr))
    {
        TrERROR(AdSimulate, "MQSec_PackPublicKey failed hr = %x", hr);
	    P<MQDSPUBLICKEYS> pCleanPublicKeysPackSign = pPublicKeysPackSign;
        ASSERT(0);
		return;
    }

	//
	// Init s_BlobSign
	//
	s_BlobSign = pPublicKeysPackSign;
}


void
InitPublicKeysPackFromStaticDS(
	P<MQDSPUBLICKEYS>& pPublicKeysPackExch,
	P<MQDSPUBLICKEYS>& pPublicKeysPackSign
	)
/*++

Routine Description:
    Initialize the P<MQDSPUBLICKEYS> to DS blobs values. 

Arguments:
	pPublicKeysPackExch - OUT P<MQDSPUBLICKEYS> which will get the BlobEncrypt value 
	pPublicKeysPackSign - OUT P<MQDSPUBLICKEYS> which will get the BlobSign value 

Returned Value:
    None

--*/
{
	P<unsigned char> pTmp = new unsigned char[s_BlobEncrypt->ulLen];
	memcpy(pTmp, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
	pPublicKeysPackExch = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
	
	pTmp = new unsigned char[s_BlobEncrypt->ulLen];
	memcpy(pTmp, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
	pPublicKeysPackSign = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
}


eDsEnvironment
ADGetEnterprise( 
	void
	)
/*++
Routine Description:
	Get AD enviroment

Arguments:
	None

Returned Value:
	Meanwhile always eAD

--*/
{
	return eAD;
}


HRESULT
ADInit( 
	IN  QMLookForOnlineDS_ROUTINE /* pLookDS */,
	IN  MQGetMQISServer_ROUTINE /* pGetServers */,
	IN  bool  /* fDSServerFunctionality */,
	IN  bool  /* fSetupMode */,
	IN  bool  /* fQMDll */,
	IN  bool  /* fIgnoreWorkGroup */,
	IN  NoServerAuth_ROUTINE /* pNoServerAuth */,
	IN  LPCWSTR /* szServerName */,
	IN  bool  /* fDisableDownlevelNotifications */
	)
{
	return MQ_OK;
}


HRESULT
ADGetObjectProperties(
	IN  AD_OBJECT               eObject,
	IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,
	IN  LPCWSTR                 /*pwcsObjectName*/,
	IN  const DWORD             cp,
	IN  const PROPID            aProp[],
	IN OUT PROPVARIANT          apVar[]
	)
/*++
Routine Description:
	Get Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	getting the value of those properties from global parameters that simulate AD content 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pwcsObjectName - wstring of object name
	cp - number of props
	aProp - array of PROPID
	apVar - OUT property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK: 
			case PROPID_QM_SIGN_PKS:
                apVar[i].caub.cElems = s_BlobSign->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobSign->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobSign.get(), s_BlobSign->ulLen);
				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
                apVar[i].caub.cElems = s_BlobEncrypt->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobEncrypt->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
				break;

			default:
				TrERROR(AdSimulate, "ADGetObjectProperties simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;
		}
	}

	return MQ_OK;
}


HRESULT
ADGetObjectPropertiesGuid(
	IN  AD_OBJECT               eObject,
	IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,
	IN  const GUID*             /*pguidObject*/,
	IN  const DWORD             cp,
	IN  const PROPID            aProp[],
	IN  OUT PROPVARIANT         apVar[]
	)
/*++
Routine Description:
	Get Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	getting the value of those properties from global parameters that simulate AD content 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pguidObject - pointer to object guid
	cp - number of props
	aProp - array of PROPID
	apVar - OUT property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK: 
			case PROPID_QM_SIGN_PKS:
                apVar[i].caub.cElems = s_BlobSign->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobSign->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobSign.get(), s_BlobSign->ulLen);
				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
                apVar[i].caub.cElems = s_BlobEncrypt->ulLen;
                apVar[i].caub.pElems = new BYTE[s_BlobEncrypt->ulLen];
				apVar[i].vt = VT_BLOB;
		        memcpy(apVar[i].caub.pElems, s_BlobEncrypt.get(), s_BlobEncrypt->ulLen);
				break;

			default:
				TrERROR(AdSimulate, "ADGetObjectPropertiesGuid simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;

		}
	}

	return MQ_OK;
}


HRESULT
ADSetObjectProperties(
    IN  AD_OBJECT               eObject,
    IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,	
    IN  LPCWSTR                 /*pwcsObjectName*/,
    IN  const DWORD             cp,
    IN  const PROPID            aProp[],
    IN  const PROPVARIANT       apVar[]
    )
/*++
Routine Description:
	Set Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	set global parameters that simulate AD content according to the property value 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pwcsObjectName - wstring of object name
	cp - number of props
	aProp - array of PROPID
	apVar - property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		P<BYTE> pTmp = NULL;
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK:	
			case PROPID_QM_SIGN_PKS:
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobSign.free();
				s_BlobSign = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());

				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
				// delete (internal) AP<> glob  
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobEncrypt.free();
				s_BlobEncrypt = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
				break;

			default:
				TrERROR(AdSimulate, "ADSetObjectProperties simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;

		}
	}

	return MQ_OK;
}


HRESULT
ADSetObjectPropertiesGuid(
	IN  AD_OBJECT               eObject,
	IN  LPCWSTR                 /*pwcsDomainController*/,
	IN  bool					/*fServerName*/,	
	IN  const GUID*             /*pguidObject*/,
	IN  const DWORD             cp,
	IN  const PROPID            aProp[],
	IN  const PROPVARIANT       apVar[]
	)
/*++
Routine Description:
	Set Object Properties
	Handle only PROPID_QM_SIGN_PK(S) and PROPID_QM_ENCRYPT_PK(S) properties
	and only eMACHINE object.
	set global parameters that simulate AD content according to the property value 

Arguments:
	eObject - object type
	pwcsDomainController - wstring of Domain Controller
	pguidObject - pointer to object guid
	cp - number of props
	aProp - array of PROPID
	apVar - property values

Returned Value:
	None

--*/
{
	DBG_USED(eObject);

	//
	// Currently handle only eMACHINE objects
	//
	ASSERT(eObject == eMACHINE);

	for(DWORD i = 0; i < cp; i++)
	{

		//
		// Currently handle only PROPID_QM_SIGN_PK(S), PROPID_QM_ENCRYPT_PK(S) properties
		//
		P<BYTE> pTmp = NULL;
		switch(aProp[i])
		{
			case PROPID_QM_SIGN_PK:	
			case PROPID_QM_SIGN_PKS:
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobSign.free();
				s_BlobSign = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
				break;

			case PROPID_QM_ENCRYPT_PK: 
			case PROPID_QM_ENCRYPT_PKS:
				pTmp = new BYTE[apVar[i].blob.cbSize];
		        memcpy(pTmp, apVar[i].blob.pBlobData, apVar[i].blob.cbSize);
				s_BlobEncrypt.free();
				s_BlobEncrypt = reinterpret_cast<MQDSPUBLICKEYS *>(pTmp.detach());
				break;

			default:
				TrERROR(AdSimulate, "ADSetObjectPropertiesGuid simulation dont support this property %d \n", aProp[i]);
				ASSERT(0);
				break;

		}
	}
	
	return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypttest\encrypttest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EncryptTest.cpp

Abstract:
    Encrypt library test

	Check the exported MQSec_* functions in encrypt library

	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /p     test MQSec_PackPublicKey function \n"
	"    /pu    test MQSec_PackPublicKey\\UnPackPublicKey on const data\n"
	"    /u     test MQSec_UnPackPublicKey function \n"
	"    /g     test MQSec_GetPubKeysFromDS function \n"
	"    /s     test MQSec_StorePubKeys function \n"
	"    /sd    test MQSec_StorePubKeysInDS function \n\n"
	"    By default all those test will run once \n"
	"    Examples of default use:\n\n"
	"        EncryptTest \n\n"
	"    specifying a number after the switch will cause \n"
	"    the test functions to run the specified number of times \n"
	"    Examples of use:\n\n"
	"        EncryptTest /p5 /pu7 /g50 /s20 /sd20 /u10 \n\n";

Author:
    Ilan Herbst (ilanh) 13-Jun-00

Environment:
    Platform-independent

--*/

#define _ENCRYPTTEST_CPP_

#include "stdh.h"
#include "EncryptTestPrivate.h"
#include "mqprops.h"

#include "encrypttest.tmh"

//
// Const key values for checking
//
const LPCSTR xBaseExKey = "1000";
const LPCSTR xBaseSignKey = "2000";
const LPCSTR xEnhExKey = "1000000";
const LPCSTR xEnhSignKey = "2000000";

//
// Usage
//
const char xOptionSymbol1 = '-';
const char xOptionSymbol2 = '/';

const char xUsageText[] =
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /p     test MQSec_PackPublicKey function \n"
	"    /pu    test MQSec_PackPublicKey\\UnPackPublicKey on const data\n"
	"    /u     test MQSec_UnPackPublicKey function \n"
	"    /g     test MQSec_GetPubKeysFromDS function \n"
	"    /s     test MQSec_StorePubKeys function \n"
	"    /sd    test MQSec_StorePubKeysInDS function \n\n"
	"    By default all those test will run once \n"
	"    Examples of default use:\n\n"
	"        EncryptTest \n\n"
	"    specifying a number after the switch will cause \n"
	"    the test functions to run the specified number of times \n"
	"    Examples of use:\n\n"
	"        EncryptTest /p5 /pu7 /g50 /s20 /sd20 /u10 \n\n";

inline
void 
DumpUsageText( 
	void 
	)
{
	printf( "%s\n" , xUsageText );
}


//
// Usage data
//
struct CActivation
{
	CActivation(void):
		m_PackCnt(1), 
		m_UnPackCnt(1),
		m_PackUnPackCnt(1),
		m_GetPubKeysCnt(1),
		m_StorePubKeysCnt(1),
		m_StorePubKeysInDSCnt(1),
		m_fErrorneous(false)
	{
	}

	DWORD	m_PackCnt;
	DWORD	m_UnPackCnt;
	DWORD	m_PackUnPackCnt;
	DWORD	m_GetPubKeysCnt;
	DWORD	m_StorePubKeysCnt;
	DWORD   m_StorePubKeysInDSCnt;
	bool    m_fErrorneous;
};


CActivation g_Activation;



void SetActivation( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments.

Arguments:
    main's command line arguments.

Returned Value:

proper command line syntax:
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /p     test MQSec_PackPublicKey function \n"
	"    /pu    test MQSec_PackPublicKey\\UnPackPublicKey on const data\n"
	"    /u     test MQSec_UnPackPublicKey function \n"
	"    /g     test MQSec_GetPubKeysFromDS function \n"
	"    /s     test MQSec_StorePubKeys function \n"
	"    /sd    test MQSec_StorePubKeysInDS function \n\n"
	"    By default all those test will run once \n"
	"    Examples of default use:\n\n"
	"        EncryptTest \n\n"
	"    specifying a number after the switch will cause \n"
	"    the test functions to run the specified number of times \n"
	"    Examples of use:\n\n"
	"        EncryptTest /p5 /pu7 /g50 /s20 /sd20 /u10 \n\n";
--*/
{
	
	if(argc == 1)
	{
		return;
	}

	for(int index = 1; index < argc; index++)
	{
		if((argv[index][0] != xOptionSymbol1) && (argv[index][0] != xOptionSymbol2))	
		{
			g_Activation.m_fErrorneous = true;
			continue;
		}

		//
		// consider argument as option and switch upon its second (sometimes also third) character.
		//
		switch(argv[index][1])
		{
		case 'P':
		case 'p':
			if((argv[index][2] == 'u') || (argv[index][2] == 'U'))
			{
				g_Activation.m_PackUnPackCnt = _ttoi(argv[index] + 3);
				break;
			}
			g_Activation.m_PackCnt = _ttoi(argv[index] + 2);
			break;

		case 'U':
		case 'u':	
			g_Activation.m_UnPackCnt = _ttoi(argv[index] + 2);
			break;

		case 'G':
		case 'g':	
			g_Activation.m_GetPubKeysCnt = _ttoi(argv[index] + 2);
			break;

		case 'S':
		case 's':	
			if((argv[index][2] == 'd') || (argv[index][2] == 'D'))
			{
				g_Activation.m_StorePubKeysInDSCnt = _ttoi(argv[index] + 3);
				break;
			}
			g_Activation.m_StorePubKeysCnt = _ttoi(argv[index] + 2);
			break;

		case 'H':	
		case 'h':
		case '?':
			g_Activation.m_fErrorneous = true;
			break;

		default:
			g_Activation.m_fErrorneous = true;
			return;
		};
	}

	return;
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Encrypt library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
	SetActivation(argc, argv);

	if(g_Activation.m_fErrorneous)
	{
		DumpUsageText();
		return 3;
	}

    TrInitialize();
    TrRegisterComponent(&EncryptTest, 1);
    TrRegisterComponent(&AdSimulate, 1);
    TrRegisterComponent(&MqutilSimulate, 1);

	//
	// Test MQSec_PackPublicKey and MQSec_UnPackPublicKey on known const data
	//
	TestPackUnPack(
		g_Activation.m_PackUnPackCnt
		);

	//
	// Test MQSec_PackPublicKey
	//
	TestMQSec_PackPublicKey(
		(BYTE*)xBaseExKey,
		strlen(xBaseExKey),
		x_MQ_Encryption_Provider_40,
		x_MQ_Encryption_Provider_Type_40,
		g_Activation.m_PackCnt
		);


	//
	// Init AD Blobs that simulate the DS content
	//
	InitADBlobs();

	//
	// Initialize KeyPacks
	//

	P<MQDSPUBLICKEYS> pPublicKeysPackExch = NULL;
	P<MQDSPUBLICKEYS> pPublicKeysPackSign = NULL;

	InitPublicKeysPackFromStaticDS(
		pPublicKeysPackExch, 
		pPublicKeysPackSign
		);

	//
	// Test MQSec_UnPackPublicKey
	//
	TestMQSec_UnPackPublicKey(
		pPublicKeysPackExch,
		x_MQ_Encryption_Provider_40,
		x_MQ_Encryption_Provider_Type_40,
		g_Activation.m_UnPackCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, EnhancedProvider, Encrypt Keys 
	//
	TestMQSec_GetPubKeysFromDS(
		eEnhancedProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, BaseProvider, Encrypt Keys  
	//
	TestMQSec_GetPubKeysFromDS(
		eBaseProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

	//
	// Test MQSec_StorePubKeys, no regenerate 
	//
	TestMQSec_StorePubKeys(
		false, 
		g_Activation.m_StorePubKeysCnt
		);

	//
	// Test MQSec_StorePubKeysInDS, no regenerate 
	//
	TestMQSec_StorePubKeysInDS(
		false, 
		MQDS_MACHINE,
		g_Activation.m_StorePubKeysInDSCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, EnhancedProvider, Encrypt Keys  
	//
	TestMQSec_GetPubKeysFromDS(
		eEnhancedProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

	//
	// Test MQSec_GetPubKeysFromDS, BaseProvider, Encrypt Keys  
	//
	TestMQSec_GetPubKeysFromDS(
		eBaseProvider, 
		PROPID_QM_ENCRYPT_PKS,
		g_Activation.m_GetPubKeysCnt
		);

    return 0;

} // _tmain

#undef _ENCRYPTTEST_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypttest\logsimulate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    LogSimulate.cpp

Abstract:
    simulate Log functions

Author:
    Ilan Herbst (ilanh) 13-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"

#include "logsimulate.tmh"

//+----------------------------
//
//  Logging and debugging
//
//+----------------------------

void 
LogMsgHR(        
	HRESULT /* hr */,        
	LPWSTR /* wszFileName */, 
	USHORT /* point */
	)
/*++

Routine Description:
	Simulate LogMsgHR and do nothing 

--*/
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypttest\stdh.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file used for precompilation.

Author:

    Ilan Herbst  (ilanh)  13-Jun-2000

Environment:

    Platform-independent

Revision History:

--*/


#ifndef _ENCRYPTTEST_STDH_H_
#define _ENCRYPTTEST_STDH_H_

#include <libpch.h>


#endif // _ENCRYPTTEST_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypttest\encrypttestprivate.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EncryptTestPrivate.h

Abstract:
    Encrypt test private functions and variables

Author:
    Ilan Herbst (ilanh) 15-Jun-00

Environment:
    Platform-independent

--*/

#ifndef _ENCRYPTTESTPRIVATE_H_
#define _ENCRYPTTESTPRIVATE_H_

#include "mqsec.h"


//
// Common Declaration
//
const TraceIdEntry EncryptTest = L"Encrypt Test";
const TraceIdEntry AdSimulate = L"Ad Simulate";
const TraceIdEntry MqutilSimulate = L"Mqutil Simulate";

#ifndef _ENCRYPTTEST_CPP_

//
// Const key values for checking
//
extern const LPCSTR xBaseExKey;
extern const LPCSTR xBaseSignKey;
extern const LPCSTR xEnhExKey;
extern const LPCSTR xEnhSignKey;

#endif // _ENCRYPTTEST_CPP_

//
// EncryptTestFunctions
// 

void
TestMQSec_PackPublicKey(
    BYTE	*pKeyBlob,
	ULONG	ulKeySize,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD Num
	);


void
TestMQSec_UnPackPublicKey(
	MQDSPUBLICKEYS  *pPublicKeysPack,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD Num
	);


void
TestPackUnPack(
	DWORD Num
	);


void
TestMQSec_GetPubKeysFromDS(
	enum enumProvider	eProvider,
	DWORD propIdKeys,
	DWORD Num
	);


void
TestMQSec_StorePubKeys(
	BOOL fRegenerate,
	DWORD Num
	);


void
TestMQSec_StorePubKeysInDS(
	BOOL fRegenerate,
	DWORD dwObjectType,
	DWORD Num
	);


//
// AdSimulate functions
//

void
InitADBlobs(
	void
	);


void
InitPublicKeysPackFromStaticDS(
	P<MQDSPUBLICKEYS>& pPublicKeysPackExch,
	P<MQDSPUBLICKEYS>& pPublicKeysPackSign
	);

#endif // _ENCRYPTTESTPRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\secutils\mqseclog.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: mqseclog.cpp

Abstract:

    Log errors and other messages of the security code.

Author:

    Doron Juster  (DoronJ)  24-May-1998

--*/

#include <stdh_sec.h>

#include "mqseclog.tmh"

static WCHAR *s_FN=L"secutils/mqseclog";

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"MQSec Error: %s/%d, HR: 0x%x",
                     wszFileName,
                     usPoint,
                     hr)) ;
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"MQSec Error: %s/%d, NTStatus: 0x%x",
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"MQSec Error: %s/%d, RPCStatus: 0x%x",
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"MQSec Error: %s/%d, BOOL: %x",
                     wszFileName,
                     usPoint,
                     b)) ;
}

void LogMsgDWORD(DWORD dw, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogQM,
                     LOG_QM_ERRORS,
                     L"MQSec Error: %s/%d, DWORD: %x",
                     wszFileName,
                     usPoint,
                     dw)) ;
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogQM,
                         LOG_QM_ERRORS,
                         L"MQSec Error: %s/%d, Point",
                         wszFileName,
                         dwLine)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\inc\permit.h ===
/****************************************************************************
*                            permit.h                                       *
*                                                                           *
*  This file contains all the definition used by the directory service to   *
* implement security, as well the prototypes for the apis exposed.          *
*									    *
* Copyright Microsoft Corp, 1992,1994					    *
****************************************************************************/
#include "accctrl.h"
//
// Define the rights used in the DS
//

#define	RIGHT_DS_CREATE_CHILD	  ACTRL_DS_CREATE_CHILD
#define RIGHT_DS_DELETE_CHILD     ACTRL_DS_DELETE_CHILD
#define RIGHT_DS_DELETE_SELF      DELETE
#define RIGHT_DS_LIST_CONTENTS    ACTRL_DS_LIST
#define RIGHT_DS_SELF_WRITE       ACTRL_DS_SELF
#define RIGHT_DS_READ_PROPERTY    ACTRL_DS_READ_PROP
#define RIGHT_DS_WRITE_PROPERTY   ACTRL_DS_WRITE_PROP
#define RIGHT_DS_DELETE_TREE      ACTRL_DS_DELETE_TREE
#define RIGHT_DS_LIST_OBJECT      ACTRL_DS_LIST_OBJECT
#ifndef ACTRL_DS_CONTROL_ACCESS
#define ACTRL_DS_CONTROL_ACCESS   ACTRL_PERM_9
#endif
#define RIGHT_DS_CONTROL_ACCESS   ACTRL_DS_CONTROL_ACCESS
//
// Define the generic rights
//

// generic read
#define GENERIC_READ_MAPPING     ((STANDARD_RIGHTS_READ)     | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_LIST_OBJECT))

// generic execute
#define GENERIC_EXECUTE_MAPPING  ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (RIGHT_DS_LIST_CONTENTS))
// generic right
#define GENERIC_WRITE_MAPPING    ((STANDARD_RIGHTS_WRITE)    | \
                                  (RIGHT_DS_SELF_WRITE)      | \
				  (RIGHT_DS_WRITE_PROPERTY))
// generic all

#define GENERIC_ALL_MAPPING      ((STANDARD_RIGHTS_REQUIRED) | \
                                  (RIGHT_DS_CREATE_CHILD)    | \
                                  (RIGHT_DS_DELETE_CHILD)    | \
                                  (RIGHT_DS_DELETE_TREE)     | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_WRITE_PROPERTY)  | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_LIST_OBJECT)     | \
                                  (RIGHT_DS_CONTROL_ACCESS)  | \
                                  (RIGHT_DS_SELF_WRITE))

//
// Standard DS generic access rights mapping
//

#define DS_GENERIC_MAPPING {GENERIC_READ_MAPPING,    \
			    GENERIC_WRITE_MAPPING,   \
			    GENERIC_EXECUTE_MAPPING, \
			    GENERIC_ALL_MAPPING}




DWORD
ConvertTextSecurityDescriptor (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pcSDSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypttest\encrypttestfunctions.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EncryptTestFunctions.cpp

Abstract:
    Encrypt test functions

	Check the exported MQSec_* functions in encrypt library

Author:
    Ilan Herbst (ilanh) 15-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "EncryptTestPrivate.h"

#include "encrypttestfunctions.tmh"

bool
CompareKeys(
	const BYTE* pKey, 
	ULONG ulKeySize, 
	const BYTE* pRefKey, 
	ULONG ulRefKeySize
	)
/*++

Routine Description:
    Compare 2 buffers values

Arguments:
    pKey - pointer to first buffer
	ulKeySize - first buffer size
	pRefKey - pointer to second buffer
	ulRefKeySize - second buffer size

Returned Value:
    true if the buffers match, false if not

--*/
{
	//
	// Buffers must have same size 
	//
	if(ulRefKeySize != ulKeySize)
		return(false);

	//
	// comparing each byte in the buffers
	//
	for(DWORD i=0; i < ulKeySize; i++, pKey++, pRefKey++)
	{
		if(*pKey != *pRefKey)
			return(false);
	}
	return(true);
}


void
TestMQSec_PackPublicKey(
    BYTE	*pKeyBlob,
	ULONG	ulKeySize,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD   Num
	)
/*++

Routine Description:
    Test MQSec_PackPublicKey function

Arguments:
    pKeyBlob - Pointer to KeyBlob to pack
	ulKeySize - KeyBlob size
	wszProviderName - wstring of Provider Name
	ulProviderType - Provider Type
	Num - Number of iterations to test the MQSec_PackPublicKey

Returned Value:
    None

--*/
{
    TrTRACE(EncryptTest, "Test MQSec_PackPublicKey iterations = %d", Num);

	//
	// PackKeys structure - this is IN/OUT parameter for the MQSec_PackPublicKey function
	// the NewKey is packed at the end of this structure
	//
    MQDSPUBLICKEYS *pPublicKeysPack = NULL;

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// Pack Key
		//
		HRESULT hr = MQSec_PackPublicKey( 
						pKeyBlob,
						ulKeySize,
						wszProviderName,
						ulProviderType,
						&pPublicKeysPack 
						);
		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_PackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			break;
		}
	}

	delete pPublicKeysPack;
    TrTRACE(EncryptTest, "Test MQSec_PackPublicKey completed iterations = %d", Num);
}


void
TestMQSec_UnPackPublicKey(
	MQDSPUBLICKEYS  *pPublicKeysPack,
	LPCWSTR	wszProviderName,
	ULONG	ulProviderType,
	DWORD   Num
	)
/*++

Routine Description:
    Test MQSec_UnPackPublicKey function

Arguments:
	pPublicKeysPack - pointer to KeysPack structure (MQDSPUBLICKEYS)
	wszProviderName - wstring of Provider Name
	ulProviderType - Provider Type
	Num - Number of iterations to test the MQSec_UnPackPublicKey

Returned Value:
    None

--*/
{
    TrTRACE(EncryptTest, "Test MQSec_UnPackPublicKey iterations = %d", Num);


	for(DWORD i = 0; i < Num; i++)
	{
		ULONG ulKeySize;
		BYTE *pKeyBlob = NULL;

		//
		// UnPack Keys
		//
	    HRESULT hr = MQSec_UnpackPublicKey( 
						pPublicKeysPack,
						wszProviderName,
						ulProviderType,
						&pKeyBlob,
						&ulKeySize 
						);

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_UnpackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			break;
		}
	}

    TrTRACE(EncryptTest, "Test MQSec_UnPackPublicKey completed iterations = %d", Num);
}


void
TestPackUnPack(
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_PackPublicKey and MQSec_UnPackPublicKey functions on known const data.
	this way we are validating that both functions are working correctly as a unit.

Arguments:
	Num - Number of iterations to test

Returned Value:
    None

--*/
{
    TrTRACE(EncryptTest, "Test MQSec_PackPublicKey\\UnpackPublicKey iterations = %d", Num);

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// Pack Ex Keys of known const data
		//

		MQDSPUBLICKEYS *pPublicKeysPackExch = NULL;

		//
		// Pack Ex Key for BaseProvider
		//
		HRESULT hr = MQSec_PackPublicKey( 
						(BYTE *)xBaseExKey,
						strlen(xBaseExKey),
						x_MQ_Encryption_Provider_40,
						x_MQ_Encryption_Provider_Type_40,
						&pPublicKeysPackExch 
						);

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_PackPublicKey failed hr = %x, iteration = %d", hr, i);
			delete pPublicKeysPackExch;
			ASSERT(0);
			return;
		}

		//
		// Pack Ex Key for EnhanceProvider
		//
		hr = MQSec_PackPublicKey( 
				(BYTE *)xEnhExKey,
				strlen(xEnhExKey),
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pPublicKeysPackExch 
				);

		P<MQDSPUBLICKEYS> pCleanPublicKeysPackExch = pPublicKeysPackExch;

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_PackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			return;
		}

		//
		// Init BlobEncrypt
		//
		BLOB BlobEncrypt;
		BlobEncrypt.cbSize = pPublicKeysPackExch->ulLen;
		BlobEncrypt.pBlobData = reinterpret_cast<BYTE *>(pPublicKeysPackExch);

		//
		// Pack Sign Keys of known const data
		//

		MQDSPUBLICKEYS *pPublicKeysPackSign = NULL;

		//
		// Pack Sign Key for BaseProvider
		//
		hr = MQSec_PackPublicKey( 
				(BYTE *)xBaseSignKey,
				strlen(xBaseSignKey),
				x_MQ_Encryption_Provider_40,
				x_MQ_Encryption_Provider_Type_40,
				&pPublicKeysPackSign 
				);

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_PackPublicKey failed hr = %x, iteration = %d", hr, i);
			delete pPublicKeysPackSign;
			ASSERT(0);
			return;
		}

		//
		// Pack Sign Key for EnhancedProvider
		//
		hr = MQSec_PackPublicKey( 
				(BYTE *)xEnhSignKey,
				strlen(xEnhSignKey),
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pPublicKeysPackSign 
				);

		P<MQDSPUBLICKEYS> pCleanPublicKeysPackSign = pPublicKeysPackSign;

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_PackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			return;
		}

		//
		// Init BlobSign
		//
		BLOB BlobSign;
		BlobSign.cbSize = pPublicKeysPackSign->ulLen;
		BlobSign.pBlobData = reinterpret_cast<BYTE *>(pPublicKeysPackSign);

		//
		// Checking UnPack Ex Keys
		//
		MQDSPUBLICKEYS *pPublicKeysPack = reinterpret_cast<MQDSPUBLICKEYS *>(BlobEncrypt.pBlobData);
		ASSERT(pPublicKeysPack->ulLen == BlobEncrypt.cbSize);

		//
		// Checking UnPack Ex Key for EnhancedProvider
		//
		ULONG ulExchEnhKeySize;
		BYTE *pExchEnhKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pExchEnhKeyBlob,
				&ulExchEnhKeySize 
				);

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_UnpackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			return;
		}

		bool KeysEqual = CompareKeys(
							pExchEnhKeyBlob, 
							ulExchEnhKeySize, 
							reinterpret_cast<const BYTE *>(xEnhExKey), 
							strlen(xEnhExKey)
							);

		ASSERT(KeysEqual);

		//
		// Checking UnPack Ex Key for BaseProvider
		//
		ULONG ulExchBaseKeySize;
		BYTE *pExchBaseKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_40,
				x_MQ_Encryption_Provider_Type_40,
				&pExchBaseKeyBlob,
				&ulExchBaseKeySize 
				);


		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_UnpackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			return;
		}

		KeysEqual = CompareKeys(
						pExchBaseKeyBlob, 
						ulExchBaseKeySize, 
						reinterpret_cast<const BYTE *>(xBaseExKey), 
						strlen(xBaseExKey)
						);

		ASSERT(KeysEqual);

		//
		// Checking UnPack Sign Keys
		//
		pPublicKeysPack = reinterpret_cast<MQDSPUBLICKEYS *>(BlobSign.pBlobData);
		ASSERT(pPublicKeysPack->ulLen == BlobSign.cbSize);

		//
		// Checking UnPack Sign Key for EnhancedProvider
		//
		ULONG ulSignEnhKeySize;
		BYTE *pSignEnhKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_128,
				x_MQ_Encryption_Provider_Type_128,
				&pSignEnhKeyBlob,
				&ulSignEnhKeySize 
				);

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_UnpackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			return;
		}

		KeysEqual = CompareKeys(
						pSignEnhKeyBlob, 
						ulSignEnhKeySize, 
						reinterpret_cast<const BYTE *>(xEnhSignKey), 
						strlen(xEnhSignKey)
						);

		ASSERT(KeysEqual);

		//
		// Checking UnPack Sign Key for BaseProvider
		//
		ULONG ulSignBaseKeySize;
		BYTE *pSignBaseKeyBlob = NULL;

		hr = MQSec_UnpackPublicKey( 
				pPublicKeysPack,
				x_MQ_Encryption_Provider_40,
				x_MQ_Encryption_Provider_Type_40,
				&pSignBaseKeyBlob,
				&ulSignBaseKeySize 
				);

		if (FAILED(hr))
		{
			TrERROR(EncryptTest, "MQSec_UnpackPublicKey failed hr = %x, iteration = %d", hr, i);
			ASSERT(0);
			return;
		}

		KeysEqual = CompareKeys(
						pSignBaseKeyBlob, 
						ulSignBaseKeySize, 
						reinterpret_cast<const BYTE *>(xBaseSignKey), 
						strlen(xBaseSignKey)
						);

		ASSERT(KeysEqual);

	} // for(i...)

    TrTRACE(EncryptTest, "Test MQSec_PackPublicKey\\MQSec_UnpackPublicKey completed iterations = %d", Num);
}


void
TestMQSec_GetPubKeysFromDS(
	enum enumProvider	eProvider,
	DWORD propIdKeys,
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_GetPubKeysFromDS function

Arguments:
	eProvider - provider type
	propIdKeys - PROPID to get from the DS
	Num - Number of iterations to test the MQSec_GetPubKeysFromDS

Returned Value:
    None

--*/
{
    TrTRACE(EncryptTest, "Test MQSec_GetPubKeysFromDS eProvider = %d, iterations = %d", eProvider, Num);

	for(DWORD i = 0; i < Num; i++)
	{
//		LPCWSTR ComputerName = L"TempComputer";
		
		LPCWSTR ComputerName = L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
							   L"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
							   L"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
							   L"DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
							   L"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
							   L"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
							   L"GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG"
							   L"HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH";
		//
		// MQSec_GetPubKeysFromDS
		//
		P<BYTE> abPbKey = NULL;
		DWORD dwReqLen = 0;

		HRESULT hr = MQSec_GetPubKeysFromDS( 
						NULL,
						ComputerName,  // false computer name, the AdSimulate dont use this name
						eProvider,
						propIdKeys,
						&abPbKey,
						&dwReqLen 
						);

		if (FAILED(hr))
		{
			ASSERT(0);
			TrERROR(EncryptTest, "MQSec_GetPubKeysFromDS (eProvider = %d) failed, iteration = %d", eProvider, i);
			return;
		}
	} // for(i...)

	TrTRACE(EncryptTest, "MQSec_GetPubKeysFromDS completed ok iterations = %d", Num);

}


void
TestMQSec_StorePubKeys(
	BOOL fRegenerate,
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_StorePubKeys function

Arguments:
	fRegenerate - flag for regenerating new keys or try to retrieve	existing keys
	Num - Number of iterations to test the MQSec_GetPubKeysFromDS

Returned Value:
    None

--*/
{

    TrTRACE(EncryptTest, "Test MQSec_StorePubKeys fRegenerate = %d, iterations = %d", fRegenerate, Num);

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// MQSec_StorePubKeys
		//
		BLOB blobEncrypt;
		blobEncrypt.cbSize    = 0;
		blobEncrypt.pBlobData = NULL;

		BLOB blobSign;
		blobSign.cbSize       = 0;
		blobSign.pBlobData    = NULL;

		HRESULT hr = MQSec_StorePubKeys( 
						fRegenerate,
						eBaseProvider,
						eEnhancedProvider,
						&blobEncrypt,
						&blobSign 
						);

		P<BYTE> pCleaner1 = blobEncrypt.pBlobData;
		P<BYTE> pCleaner2 = blobSign.pBlobData;

		if (FAILED(hr))
		{
			ASSERT(0);
			TrERROR(EncryptTest, "MQSec_StorePubKeys (fRegenerate = %d) failed %x, iteration = %d", 
					fRegenerate, hr, i);
			return;
		}
	} // for(i...)


    TrTRACE(EncryptTest, "MQSec_StorePubKeys completed ok, iterations = %d", Num);
}


void
TestMQSec_StorePubKeysInDS(
	BOOL fRegenerate,
	DWORD dwObjectType,
	DWORD Num
	)
/*++

Routine Description:
    Test MQSec_StorePubKeysInDS function
    every call to MQSec_StorePubKeysInDS allocate a new data blobs in the DS. 
	since those data are globals in our implementation they need to be freed
	and re assigned	to the P<>

Arguments:
	fRegenerate - flag for regenerating new keys or try to retrieve	existing keys
	dwObjectType - Object Type 
	Num - Number of iterations to test the MQSec_GetPubKeysFromDS

Returned Value:
    None

--*/
{
    TrTRACE(EncryptTest, "Test MQSec_StorePubKeysInDS fRegenerate = %d, iterations = %d", fRegenerate, Num);

	for(DWORD i = 0; i < Num; i++)
	{
		//
		// MQSec_StorePubKeysInDS
		//
		HRESULT hr = MQSec_StorePubKeysInDS( 
						fRegenerate,	
						NULL,			// wszObjectName
						dwObjectType
						);


		if (FAILED(hr))
		{
			ASSERT(0);
			TrERROR(EncryptTest, "MQSec_StorePubKeysInDS (fRegenerate = %d) failed %x, iteration = %d", 
					fRegenerate, hr, i);
			return;
		}
	} // for(i...)

		
	TrTRACE(EncryptTest, "MQSec_StorePubKeysInDS completed ok, iterations = %d", Num);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\encrypttest\mqutilsimulate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MqutilSimulate.cpp

Abstract:
    simulate mqutil functions

Author:
    Ilan Herbst (ilanh) 14-Jun-00

Environment:
    Platform-independent

--*/

#include "stdh.h"
#include "mq.h"

#include "mqutilsimulate.tmh"

const TraceIdEntry MqutilSimulate = L"Mqutil Simulate";

#define MQUTIL_EXPORT __declspec(dllexport)

//
// constants
//
#define EVENTLOGID          DWORD
#define DBGLVL              UINT

///////////////////////////////////////////////////////////////////////////
//
// class COutputReport
//
// Description : a class for outputing debug messages and event-log messages
//
///////////////////////////////////////////////////////////////////////////

class COutputReport
{
public:

    COutputReport(void)
	{
	}

#ifdef _DEBUG
    void 
	DebugMsg(
		DWORD dwMdl, 
		DBGLVL uiLvl, 
		WCHAR * Format,
		...
		);
#endif

	//
    // event-log functions (valid in release and debug version)
	//
	void ReportMsg( 
		EVENTLOGID id,
		DWORD   cMemSize  = 0,
		LPVOID  pMemDump  = NULL,
		WORD    cParams   = 0,
		LPCTSTR *pParams  = NULL,
		WORD    wCategory = 0 
		);
};


//
// Declare an Object of the report-class.
//
// Only one object is declared per process. In no other module should there be another declaration of an
// object of this class.
//
__declspec(dllexport) COutputReport Report;


HRESULT
MQUTIL_EXPORT
APIENTRY
GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize
    )
/*++

Routine Description:
	Get Computer name in lower case

Arguments: 
	pwcsMachineName - OUT wstring for computer name
	pcbSize - IN/OUT buffer size

Return Value:
    MQ_OK if normal operation, MQ_ERROR if error 

--*/
{
    if (GetComputerName(pwcsMachineName, pcbSize))
    {
        CharLower(pwcsMachineName);
        return MQ_OK;
    }

    return MQ_ERROR;

}


LONG
MQUTIL_EXPORT
APIENTRY
GetFalconKeyValue(
    LPCTSTR /*pszValueName*/,
    PDWORD  pdwType,
    PVOID   pData,
    PDWORD  pdwSize,
    LPCTSTR pszDefValue
    )
/*++

Routine Description:
	Get FalconKey Value. this function simulate mqutil function and always 
	assign the given default value.

Arguments:
	pszValueName - Value Name string
	pdwType - value type
	pData - OUT the value data
	pdwSize - pData buffer size
	pszDefValue - default value

Return Value:
    MQ_OK if normal operation, MQ_ERROR if error 

--*/
{
    if(pszDefValue)
    {
		if (pdwType && (*pdwType == REG_SZ))
		{
			//
			// Don't use the default if caller buffer was too small for
			// value in registry.
			//
			if ((DWORD) wcslen(pszDefValue) < *pdwSize)
			{
				wcscpy((WCHAR*) pData, pszDefValue);
			}
		}
		if (*pdwType == REG_DWORD)
		{
			*((DWORD *)pData) = *((DWORD *) pszDefValue);
		}
    }
	else 
	{
		//
		// No Default Value
		//
        TrERROR(MqutilSimulate, "Mqutil simulation GetFalconKeyValue dont supported, need DefValue");
		ASSERT(0);
		return MQ_ERROR;
	}

    return MQ_OK;
}


LONG
MQUTIL_EXPORT
APIENTRY
SetFalconKeyValue(
    LPCTSTR /*pszValueName*/,
    PDWORD  /*pdwType*/,
    const VOID * pData,
    PDWORD  pdwSize
    )
/*++

Routine Description:
	Set FalconKey Value. this function simulate mqutil function and do nothing 

Arguments:
	pszValueName - Value Name string
	pdwType - value type
	pData - OUT the value data
	pdwSize - pData buffer size

Return Value:
    ERROR_SUCCESS 

--*/
{
    ASSERT(pData != NULL);
    ASSERT(pdwSize != NULL);

	DBG_USED(pData);
	DBG_USED(pdwSize);

    TrERROR(MqutilSimulate, "Mqutil simulation dont support SetFalconKeyValue");
	ASSERT(0);

    return(ERROR_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
// COutputReport::ReportMsg
//
// ReportMsg function writes to the Event-log of the Windows-NT system.
// The message is passed only if the the level setisfies the current
// debugging level. The paramaters are :
//
// id - identity of the message that is to be displayed in the event-log
//      (ids are listed in the string-table)
// cMemSize - number of memory bytes to be displayed in the event-log (could be 0)
// pMemDump - address of memory to be displayed
// cParams - number of strings to add to this message (could be 0)
// pParams - a list of cParams strings (could be NULL only if cParams is 0)
//

void COutputReport::ReportMsg( EVENTLOGID /*id*/,
                               DWORD      /*cMemSize*/,
                               LPVOID     /*pMemDump*/,
                               WORD       /*cParams*/,
                               LPCTSTR  * /*pParams*/,
                               WORD       /*wCategory*/ )
/*++

Routine Description:
	Simulate COutputReport::ReportMsg and do nothing 

--*/
{
}

#ifdef _DEBUG
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// COutputReport::DebugMsg - UNICODE version
//
// The function receives a formated string representing the debug message along with a flag that represents
// the level of the passed message. If the level setisfies the current debugging level then the message is
// translated into a buffer and passed to the locations matching the current debug locations.
//

void COutputReport::DebugMsg(DWORD /*dwMdl*/, DBGLVL /*uiLvl*/, WCHAR * /*Format*/, ...)
/*++

Routine Description:
	Simulate COutputReport::DebugMsg and do nothing 

--*/
{
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\secutils\mqsemain.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    mqsemain.cpp

Abstract:
    Entry point of mqsec.dll

Author:
    Doron Juster (DoronJ)  24-May-1998

Revision History:

--*/

#include <stdh_sec.h>

#include "mqsemain.tmh"

static WCHAR *s_FN=L"secutils/mqsemain";

/***********************************************************
*
* DllMain
*
************************************************************/

BOOL WINAPI AccessControlDllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved) ;
BOOL WINAPI CertDllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved) ;
BOOL WINAPI MQsspiDllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved) ;

BOOL WINAPI DllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL f = AccessControlDllMain(hMod, fdwReason, lpvReserved) ;
    if (!f)
    {
        return f ;
    }

    f = CertDllMain(hMod, fdwReason, lpvReserved) ;
    if (!f)
    {
        return f ;
    }

    f = MQsspiDllMain(hMod, fdwReason, lpvReserved) ;
    if (!f)
    {
        return f ;
    }

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        WPP_CLEANUP();
    }
    else if (fdwReason == DLL_THREAD_ATTACH)
    {
    }
    else if (fdwReason == DLL_THREAD_DETACH)
    {
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\secutils\stdh_ut.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: stdh_ut.h

Abstract: Generic header file for utility code

Author: Doron Juster  (DoronJ)  24-May-1998

--*/

#ifndef __SEC_STDH_UT_H
#define __SEC_STDH_UT_H

#include <_stdh.h>
#include "..\seclog.h"

#endif // __SEC_STDH_UT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\srvauthn\srvauthn.cpp ===
/*++

Copyright (c) 1997-99  Microsoft Corporation

Module Name:  srvauthn.cpp

Abstract:
   1. Initialization of server authentication (secured comm) on MSMQ servers.
   2. Code to setup and read registry on clients.

Author:

    Doron Juster (DoronJ)   Jun-98

--*/

#include <stdh_sec.h>
#include <mqkeyhlp.h>
#include <_registr.h>
#include "stdh_sa.h"

#include "srvauthn.tmh"

static WCHAR *s_FN=L"srvauthn/srvauthn";

DWORD   g_dwSALastError = 0;

//+--------------------------------------------------------------------
//
//  HRESULT  MQsspi_InitServerAuthntication()
//
//  1. Read digest of server certificate from registry. This was save
//     in registry by control panel.
//  2. Look for server certificate in machine store. Take the one that
//     match the digest read from registry.
//  3. Initialize the schannel provider.
//
//+--------------------------------------------------------------------

HRESULT  MQsspi_InitServerAuthntication()
{
    HRESULT hr = MQSec_OK;

    //
    // Read cert store and digest from registry.
    //
    LPTSTR tszRegName = SRVAUTHN_STORE_NAME_REGNAME;
    TCHAR  tszStore[48];
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = sizeof(tszStore);
    LONG rc = GetFalconKeyValue( 
					tszRegName,
					&dwType,
					(PVOID) tszStore,
					&dwSize 
					);

    if (rc != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to read MSMQ registry key %ls. %!winerr!"), tszRegName, rc));
        return MQSec_E_READ_REG;
    }

    GUID  CertDigest;
    tszRegName = SRVAUTHN_CERT_DIGEST_REGNAME;
    dwType = REG_BINARY;
    dwSize = sizeof(CertDigest);
    rc = GetFalconKeyValue( 
			tszRegName,
			&dwType,
			(PVOID) &CertDigest,
			&dwSize 
			);
    if (rc != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to read MSMQ registry key %ls. %!winerr!"), tszRegName, rc));
        return MQSec_E_READ_REG;
    }

    //
    // Enumerate the certificates. Take the one with the matching digest.
    //
    BOOL fCertFound = FALSE;

    CHCertStore hStore = CertOpenStore( 
							CERT_STORE_PROV_SYSTEM,
							0,
							0,
							CERT_SYSTEM_STORE_LOCAL_MACHINE,
							tszStore 
							);
    if (!hStore)
    {
        g_dwSALastError = GetLastError();
        LogNTStatus(g_dwSALastError, s_FN, 30);
        return MQSec_E_CANT_OPEN_STORE;
    }

    PCCERT_CONTEXT pContext = CertEnumCertificatesInStore( 
									hStore,
									NULL 
									);
    while (pContext)
    {
        CMQSigCertificate *pCert;
        hr = MQSigCreateCertificate( 
				&pCert,
				pContext 
				);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            GUID tmpDigest;
            hr = pCert->GetCertDigest(&tmpDigest);

            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                if (memcmp(&tmpDigest, &CertDigest, sizeof(GUID)) == 0)
                {
                    //
                    // that's our certificate.
                    //
                    hr = InitServerCredHandle(hStore, pContext);
                    if (SUCCEEDED(hr))
                    {
                        DBGMSG((DBGMOD_SECURITY, DBGLVL_INFO, _T("Successfully initialized server authentication credentials. (store=%ls)"), tszStore));
                    }
                    pCert->Release();
                    pContext = NULL; // freed by previous Release().
                    fCertFound = TRUE;
                    break;
                }
            }
        }

        pCert->Release(TRUE); // TRUE for keeping the context.
                               // it's freed by CertEnum...
        PCCERT_CONTEXT pPrecContext = pContext;
        pContext = CertEnumCertificatesInStore( 
						hStore,
						pPrecContext 
						);
    }
    ASSERT(!pContext);

    if (!fCertFound)
    {
        hr = MQSec_E_CERT_NOT_FOUND;
    }
    return LogHR(hr, s_FN, 40);

}

//+------------------------------------------------------------------------
//
//  BOOL  MQsspi_IsSecuredServerConn()
//
//    The function returns TRUE, if the user that run setup configured the
//    machine to do only secured communications with the DS.
//
//+------------------------------------------------------------------------

BOOL MQsspi_IsSecuredServerConn(BOOL fRefresh)
{
    static BOOL s_fGotIt = FALSE;
    static BOOL s_fSecuredServerConn = FALSE;

    if (!s_fGotIt || fRefresh)
    {
        //
        // Get the value from the registry.
        //
        LONG lError;
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);

        lError = GetFalconKeyValue( 
						MSMQ_SECURE_DS_COMMUNICATION_REGNAME,
						&dwType,
						&s_fSecuredServerConn,
						&dwSize,
						NULL 
						);

        if (lError != ERROR_SUCCESS)
        {
            //
            // The value is not found in the registry.
            // Return the hard coded default value.
            //
            s_fSecuredServerConn = MSMQ_DEFAULT_SECURE_DS_COMMUNICATION;
            LogNTStatus(lError, s_FN, 60);
        }

        s_fGotIt = TRUE;
    }

    return s_fSecuredServerConn;
}

//+--------------------------------------------------------------
//
//  BOOL  MQsspi_SetSecuredServerConn( BOOL fSecured )
//
//   The function sets the registry to indicate whether or not
//   secured server connection was requested by user.
//
//+--------------------------------------------------------------

BOOL MQsspi_SetSecuredServerConn(BOOL fSecured)
{
    LONG lError;
    DWORD dwType REG_DWORD;
    DWORD dwSecured = (DWORD) fSecured;
    DWORD dwSize = sizeof(DWORD);

    //
    // Set the value in the registry.
    //
    lError = SetFalconKeyValue( 
					MSMQ_SECURE_DS_COMMUNICATION_REGNAME,
					&dwType,
					&dwSecured,
					&dwSize 
					);

    LogNTStatus(lError, s_FN, 70);
    return(lError == ERROR_SUCCESS);
}

//+----------------------------------------------------------
//
//  void  MQsspi_MigrateSecureCommFlag(void)
//
//  Move flag from its NT4 place to win2000 location.
//
//+----------------------------------------------------------

//
// Name of registry for secured server connection to MQIS. NT4 registry.
//
#define MSMQ_SECURED_SERVER_CONNECTION_REGNAME  \
                                         TEXT("SecuredServerConnection")
#define MSMQ_DEFAULT_SECURED_CONNECTION         0


void  MQsspi_MigrateSecureCommFlag(void)
{
    BOOL  fSecure;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    LONG lError = GetFalconKeyValue(
						MSMQ_SECURED_SERVER_CONNECTION_REGNAME,
						&dwType,
						&fSecure,
						&dwSize,
						NULL
						);
    if (lError != ERROR_SUCCESS)
    {
        //
        // See if flag already migrated to new place.
        //
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);

        lError = GetFalconKeyValue( 
					MSMQ_SECURE_DS_COMMUNICATION_REGNAME,
					&dwType,
					&fSecure,
					&dwSize,
					NULL 
					);
        if (lError == ERROR_SUCCESS)
        {
            //
            // Already migrated.
            //
            LogNTStatus(lError, s_FN, 80);
            return ;
        }

        ASSERT(lError == ERROR_SUCCESS);

        //
        // The value is not found in the registry.
        // Usethe hard coded default value.
        //
        fSecure = MSMQ_DEFAULT_SECURED_CONNECTION;
    }

    BOOL fSet = MQsspi_SetSecuredServerConn(fSecure);
	DBG_USED(fSet);
    ASSERT(fSet);

    lError = DeleteFalconKeyValue(MSMQ_SECURED_SERVER_CONNECTION_REGNAME);
    ASSERT(lError == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\srvauthn\stdh_sa.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    stdh_sa.h

Abstract:

    Standard header file to the srvauthn static library.

Author:

    Doron Juster  (DoronJ)  June-98

--*/


HRESULT
InitServerCredHandle( HCERTSTORE     hStore,
                      PCCERT_CONTEXT pContext ) ;

HRESULT
GetSchannelCaCert( LPCWSTR  szCaRegName,
                   PBYTE    pbCert,
                   DWORD   *pdwCertSize );

HRESULT
GetCertificateNames( LPBYTE pbCertificate,
                     DWORD  cbCertificate,
                     LPSTR  szSubject,
                     DWORD *pdwSubjectLen,
                     LPSTR  szIssuer,
                     DWORD *pdwIssuerLen );

#define CAEnabledRegValueNameA  "Enabled"
#define CAEnabledRegValueName   TEXT(CAEnabledRegValueNameA)
#define CARegKeyA               "CertificationAuthorities"
#define CARegKey                TEXT(CARegKeyA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\srvauthn\configca.cpp ===
/*++

Copyright (c) 1997-98  Microsoft Corporation

Module Name:  configca.cpp

Abstract:  Code to set the list of trusted CA certificates which are used
           by MSMQ clients for server authentication.
           Server certificates are trusted only if issued and signed by
           CA certificates which are enabled by user.

    The code in this file handle both NTEE version of MSMQ1.0 and later
    versions. Whenever the words "old" and "new" are used, "old" refer to
    NTEE version (first released version of MSMQ) and "new" to all other
    versions.

    The NTEE version used first version of cryptoAPI, which came with IE3.02.
    This version of cryptoAPI didn't support certificates store functionality.
    The MSMQ root store (in registry, under
          HKLM\Software\Microsoft\MSMQ\Parameters\CertificationAuthorities)
    kept only the name of CA certificates and a flag indicating if the user
    enabled or disabled the certificate. The certificates blobs themselves
    were kept by SCHANNEL in its own store, in HKLM registry, under
  "System\CurrentControlSet\Control\SecurityProviders\SCHANNEL\CertificationAuthorities"

    All other versions of MSMQ (MSMQ1.0 from NTOP, NT4/SP4 and above, and
    MSMQ2.0 on NT5) require at least cryptoAPI 2.0, which first shipped with
    IE4. This version of cryptoAPI included support for certificates store.
    Now the MSMQ ROOT certificates store, registry based,
    under HKLM\Software\Microsoft\MSMQ\Parameters\CertificationAuthorities,
    is managed by cryptoAPI 2.0 and it holds a "real" copy of each relevant
    CA certificate. Starting with MSMQ2.0, we copy from the system ROOT
    certificates store only those certificates marked for "Server
    authentication". User can run MSMQ control panel applet and chose the
    CA certificates that he trusts.

Author:

    Doron Juster (DoronJ)   Jun-98

--*/

#include <stdh_sec.h>
#include "stdh_sa.h"
#include <_registr.h>
#include <mqcacert.h>

#include "configca.tmh"

static CHCertStore s_hRootStore;

static WCHAR *s_FN=L"srvauthn/configca";

DWORD   g_dwCAConfigLastError = 0 ;

//+-------------------------------------------------------------
//
// Define functions which should be loaded only when called.
//
//+-------------------------------------------------------------

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) \
    DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)

static HINSTANCE g_hinstCrypt32 = NULL;
static HINSTANCE g_hinstWinInet = NULL;

#define ENSURE_LOADED(_hinst, _dll)   (_hinst ? TRUE : ((_hinst = LoadLibrary(L#_dll)) != NULL))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall * _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        if (_pfn##_fn == NULL)      \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
}

#pragma warning(disable:4229 4273)

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertGetEnhancedKeyUsage,
           (IN PCCERT_CONTEXT pCertContext, IN DWORD dwFlags, OUT PCERT_ENHKEY_USAGE pUsage, IN OUT DWORD *pcbUsage),
           (pCertContext, dwFlags, pUsage, pcbUsage));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, ParseX509EncodedCertificateForListBoxEntry,
           (IN LPBYTE  lpCert,IN DWORD  cbCert,OUT LPSTR lpszListBoxEntry,IN LPDWORD lpdwListBoxEntry),
           (lpCert,cbCert,lpszListBoxEntry,lpdwListBoxEntry));

#pragma warning(default:4229 4273)

//+--------------------------------
//
//   _GetCertificateSubject()
//
//+--------------------------------

STATIC  
HRESULT
_GetCertificateSubject( 
	PBYTE   pbCert,
	DWORD   dwCertSize,
	AP<WCHAR>& szSubjectRef
	)
{
    //
    // Get the subject and issuer name.
    //
    CHAR acShortSubject[256];
    AP<CHAR> szLongSubject;
    LPSTR szSubject = acShortSubject;
    DWORD dwSubjectLen = sizeof(acShortSubject) / sizeof(WCHAR);

    CHAR acShortIssuer[256];
    AP<CHAR> szLongIssuer;
    LPSTR szIssuer = acShortIssuer;
    DWORD dwIssuerLen = sizeof(acShortIssuer) / sizeof(WCHAR);

    HRESULT hr = GetCertificateNames(
					pbCert,
					dwCertSize,
					szSubject,
					&dwSubjectLen,
					szIssuer,
					&dwIssuerLen
					);
    if (FAILED(hr))
    {
        if (hr != MQ_ERROR_USER_BUFFER_TOO_SMALL)
        {
            return LogHR(hr, s_FN, 50);
        }

        //
        // One or two buffers are not large enough, allocate large enough
        // buffers and try again.
        //

        if (dwSubjectLen > sizeof(acShortSubject) / sizeof(CHAR))
        {
            szSubject = szLongSubject = new CHAR[dwSubjectLen];
        }

        if (dwIssuerLen > sizeof(acShortIssuer) / sizeof(CHAR))
        {
            szIssuer = szLongIssuer = new CHAR[dwIssuerLen];
        }

        hr = GetCertificateNames(
				pbCert,
				dwCertSize,
				szSubject,
				&dwSubjectLen,
				szIssuer,
				&dwIssuerLen
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }
    }

    //
    // Allocate a buffer for the result and conver the result into a
    // unicode string.
    //
	ASSERT(szSubjectRef == NULL);
	szSubjectRef = new WCHAR[dwSubjectLen+1];
    MultiByteToWideChar(
        CP_ACP,
        0,
        szSubject,
        -1,
        szSubjectRef,
        dwSubjectLen+1
		);

    return(MQ_OK);
}

//+-----------------------------------------------------------------------
//
// Function -
//      GetOldCaConfig
//
// Parameters -
//      hCerts - A handle to ...\MSMQ\Parameters\CertificationAuthorities
//          registry. This is the MSMQ root certificate store.
//      hOldRootStore - An temporary in-memory certificates store that
//           accumulates the old certificates from the MSMQ registry.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      This function converts MSMQ root store (the store of CA self
//      certificates) from proprietary format used by IE3.02 (MSMQ from NTEE)
//      to CryptoAPI2.0 compatible format (used by IE4 and above).
//      With the IE3.02 format, the MSMQ store in registry just keep list of
//      certificate names. Each name was a key, with two values:
//      1. Enabled - wither or not to use this certificate for MSMQ secure
//                   communication.
//      2. Display name.
//      The certificate blob itself was in the SCHANNEL store.
//
//      The function enumerates certificates from the present MSMQ store and
//      copy them to the temporary "hOldRootStore" store.
//      The certificates are inserted in hOldRootStore with all the required
//      properties (friendly name, etc.) already set.
//
//+-----------------------------------------------------------------------

HRESULT
GetOldCaConfig(  HKEY       hCerts,
                 HCERTSTORE hOldRootStore)
{
    HRESULT hr;

    //
    // Get a verification context to the base CSP. Use the ANSI function for
    // Win95 sake.
    //
    CHCryptProv hProv;

    if (!CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        return LogHR(MQ_ERROR, s_FN, 70);
    }

    //
    // Get the number of CAs.
    //

    DWORD nCerts;
    LONG lError;

    lError = RegQueryInfoKeyA(hCerts,
                              NULL,
                              NULL,
                              NULL,
                              &nCerts,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    if (lError != ERROR_SUCCESS)
    {
        LogNTStatus(lError, s_FN, 80);
        return MQ_ERROR;
    }

    //
    // Get each of the old certs and put then in the cert store.
    //
    WCHAR szCARegName[MAX_PATH + 1];
    DWORD dwCaRegNameSize;
    DWORD dwEnabled;
    DWORD dwSize = sizeof(DWORD);
    DWORD iCert;

    for (iCert = 0, dwCaRegNameSize = sizeof(szCARegName);
         (lError = RegEnumKeyEx(hCerts,
                                iCert,
                                szCARegName,
                                &dwCaRegNameSize,
                                NULL,
                                NULL,
                                NULL,
                                NULL)) == ERROR_SUCCESS;
         iCert++, dwCaRegNameSize = sizeof(szCARegName))
    {
        //
        // Open the registry of the CA.
        //
        CAutoCloseRegHandle hCa;

        lError = RegOpenKeyEx(hCerts,
                              szCARegName,
                              0,
                              KEY_QUERY_VALUE,
                              &hCa);
        if (lError != ERROR_SUCCESS)
        {
            LogNTStatus(lError, s_FN, 90);
            return MQ_ERROR;
        }

        //
        // Get the enabled flag.
        //
        DWORD dwType;

        lError = RegQueryValueEx(hCa,
                                 CAEnabledRegValueName,
                                 0,
                                 &dwType,
                                 (PBYTE)&dwEnabled,
                                 &dwSize);
        if (lError != ERROR_SUCCESS)
        {
            //
            // The old store is probably gone. Continue anyway.
            //
            continue;
        }

        //
        // Get the certificate bits.
        //
        DWORD dwCaCertSize;

        if (GetSchannelCaCert(szCARegName, NULL, &dwCaCertSize) != MQ_ERROR_USER_BUFFER_TOO_SMALL)
        {
            continue;
        }

        AP<BYTE> pbCaCert = new BYTE[dwCaCertSize];

        hr = GetSchannelCaCert(szCARegName, pbCaCert, &dwCaCertSize);
        ASSERT(SUCCEEDED(hr));

        //
        // Create a certificate context for the certificate.
        //
        CPCCertContext pCert;

        pCert = CertCreateCertificateContext(
                    X509_ASN_ENCODING,
                    pbCaCert,
                    dwCaCertSize);
        if (!pCert)
        {
            return LogHR(MQ_ERROR, s_FN, 100);
        }

        //
        // Add the friendly name to the certificate context. The firendly name
        // gere is the name of the registry key.
        //
        CRYPT_DATA_BLOB DataBlob;

        DataBlob.pbData = (PBYTE)szCARegName;
        DataBlob.cbData = (wcslen((LPWSTR) szCARegName) + 1) * sizeof(WCHAR);

        if (!CertSetCertificateContextProperty(
                pCert,
                CERT_FRIENDLY_NAME_PROP_ID,
                0,
                &DataBlob))
        {
            return LogHR(MQ_ERROR, s_FN, 110);
        }

        //
        // Add the enabled flag property to the certificate context.
        //
        BOOL fEnabled = dwEnabled != 0;

        DataBlob.pbData = (PBYTE)&fEnabled;
        DataBlob.cbData = sizeof(BOOL);

        if (!CertSetCertificateContextProperty(
                pCert,
                MQ_CA_CERT_ENABLED_PROP_ID,
                0,
                &DataBlob))
        {
            return LogHR(MQ_ERROR, s_FN, 120);
        }

        //
        // Add the subject name property to the certificate context.
        //
        AP<WCHAR> szSubject;

        hr = _GetCertificateSubject(pbCaCert, dwCaCertSize, szSubject);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 130);
        }

        DataBlob.pbData = (PBYTE)szSubject.get();
        DataBlob.cbData = (wcslen(szSubject) + 1) * sizeof(WCHAR);

        if (!CertSetCertificateContextProperty(
                pCert,
                MQ_CA_CERT_SUBJECT_PROP_ID,
                0,
                &DataBlob))
        {
            return LogHR(MQ_ERROR, s_FN, 140);
        }

        //
        // Get the SHA1 hash value of the certificate. This serves as a key for
        // searching the certificate in the store.
        //
        BYTE abHash[64];
        DWORD dwHashSize = sizeof(abHash);

        if (!CryptHashCertificate(
                hProv,
                CALG_SHA1,
                0,
                pbCaCert,
                dwCaCertSize,
                abHash,
                &dwHashSize))
         {
             return LogHR(MQ_ERROR, s_FN, 150);
         }

         //
         // Add the SHA1 hash property to the certificate context.
         //
         CRYPT_HASH_BLOB HashBlob;

         HashBlob.pbData = abHash;
         HashBlob.cbData = dwHashSize;

        if (!CertSetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                0,
                &HashBlob))
        {
            return LogHR(MQ_ERROR, s_FN, 160);
        }

        //
        // Add the certificate to the certificate store.
        //
        if (!CertAddCertificateContextToStore(
                hOldRootStore,
                pCert,
                CERT_STORE_ADD_NEW,
                NULL))
        {
            return LogHR(MQ_ERROR, s_FN, 170);
        }
    }

    //
    // Make sure that we scanned all the CAs.
    //
    if ((lError != ERROR_NO_MORE_ITEMS) || (iCert != nCerts))
    {
        return LogHR(MQ_ERROR, s_FN, 180);
    }

    return(MQ_OK);
}

//+------------------------------------------------------------------------
//
// Function -
//      MergeOldCaConfig
//
// Parameters -
//      hRootStore - A handle to the new certificate store.
//      hOldRootStore - A handle to the temporary in-memory certificates
//          store that holds the old (IE3.02) SCHANNEL CA certificates.
//      hRegRoot - A handle to ...\MSMQ\Parameters\CertificationAuthorities
//          registry.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function adds the old certificates to the new certificates store
//      and deletes the registry entries of the old certificates.
//
//+------------------------------------------------------------------------

HRESULT
MergeOldCaConfig( 
	HCERTSTORE hRootStore,
	HCERTSTORE hOldRootStore,
	HKEY       hRegRoot 
	)
{
    //
    // Enumerate the old certificates.
    //
    PCCERT_CONTEXT pCert = NULL;

    while ((pCert = CertEnumCertificatesInStore(hOldRootStore, pCert)) != NULL)
    {
        //
        // Add the certificate into the new certificate store.
        //
        if (!CertAddCertificateContextToStore(
                hRootStore,
                pCert,
                CERT_STORE_ADD_NEW,
                NULL
				) &&
            (GetLastError() != CRYPT_E_EXISTS))
        {
            return LogHR(MQ_ERROR, s_FN, 190);
        }

        DWORD dwSize;

        //
        // Get the friendly name of the certificate.
        //
        if (!CertGetCertificateContextProperty(
                pCert,
                CERT_FRIENDLY_NAME_PROP_ID,
                NULL,
                &dwSize
				))
        {
            ASSERT(0);
            continue;
        }

        AP<WCHAR> szCaRegName = (LPWSTR) new BYTE[dwSize];
        if (!CertGetCertificateContextProperty(
                pCert,
                CERT_FRIENDLY_NAME_PROP_ID,
                szCaRegName,
                &dwSize
				))
        {
            ASSERT(0);
            continue;
        }

        //
        // get rid of the registry key of the old certificate.
        //
        RegDeleteKey(hRegRoot, szCaRegName);
    }

    return(MQ_OK);
}

//+-------------------------------------------------------------------------
//
// Function -  MergeNewCaConfig()
//
// Parameters -
//      hRootStore - A handle to MSMQ ROOT certificates store.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function enumerates all the certificate in the system ROOT
//      certificate store and adds each certificate to MSMQ ROOT certificate
//      store. Only certificates marked for "Server authentication" are
//      added.
//
//+-------------------------------------------------------------------------

HRESULT
MergeNewCaConfig( 
	HCERTSTORE hRootStore 
	)
{
    HRESULT hr;

    //
    // Get a verification context to the base CSP. Use the ANSI function for
    // Win95 sake.
    //
    CHCryptProv hProv;

    if (!CryptAcquireContextA( 
			&hProv,
			NULL,
			NULL,
			PROV_RSA_FULL,
			CRYPT_VERIFYCONTEXT 
			))
    {
        return LogHR(MQ_ERROR, s_FN, 200);
    }

    //
    // Open the system ROOT certificate store.
    // use the CERT_STORE_NO_CRYPT_RELEASE_FLAG flag, so auto-close of the
    // store handle won't release the provider handle. The provider handle
    // is also auto-released.
    //
    CHCertStore hSysRoot;

    hSysRoot = CertOpenStore(
					CERT_STORE_PROV_SYSTEM,
					(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING),
					hProv,
					(CERT_STORE_READONLY_FLAG        |
					CERT_SYSTEM_STORE_CURRENT_USER   |
					CERT_STORE_NO_CRYPT_RELEASE_FLAG),
					(PVOID)L"ROOT"
					);

    //
    // Enumerate the certificates in the system ROOT certificate store.
    // Find only those marked for server authentication.
    //
    CERT_ENHKEY_USAGE CertUsage;
    LPSTR pUsage = szOID_PKIX_KP_SERVER_AUTH;

    CertUsage.cUsageIdentifier = 1;
    CertUsage.rgpszUsageIdentifier = &pUsage;

    PCCERT_CONTEXT pCert = NULL;
    while ((pCert = CertFindCertificateInStore( 
						hSysRoot,
						(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING),
						CERT_FIND_VALID_ENHKEY_USAGE_FLAG,
						CERT_FIND_ENHKEY_USAGE,
						&CertUsage,
						pCert 
						)) != NULL)
    {
        BOOL fEnabled = TRUE ;
        DWORD dwSize;

        //
        // Get the friendly name property of the certificate.
        //

        AP<WCHAR> szCaName;

        if (!CertGetCertificateContextProperty(
                pCert,
                CERT_FRIENDLY_NAME_PROP_ID,
                NULL,
                &dwSize
				))
        {
            //
            // The certificate does not have a friendly name property in the
            // system ROOT certificate store. So get the friendly name for the
            // certificate from WININET.
            //
            if (ParseX509EncodedCertificateForListBoxEntry(
                    pCert->pbCertEncoded,
                    pCert->cbCertEncoded,
                    NULL,
                    &dwSize
					) == 0)
            {
                //
                // Allocate a buffer and get the name.
                //
                P<CHAR> szMbCaName = new CHAR[dwSize];

                if (ParseX509EncodedCertificateForListBoxEntry(
                        pCert->pbCertEncoded,
                        pCert->cbCertEncoded,
                        szMbCaName,
                        &dwSize
						) != 0)
                {
                    ASSERT(0);
                    continue;
                }

                //
                // Convert the name to UNICODE.
                //
                szCaName = (LPWSTR) new WCHAR[dwSize];

                MultiByteToWideChar(
                    CP_ACP,
                    0,
                    szMbCaName,
                    -1,
                    szCaName,
                    dwSize
					);
            }
            else
            {
                //
                // Failed to get the friendly name also from WININET, discard
                // this certificate.
                //
                continue;
            }
        }
        else
        {
            //
            // Allocate the buffer and get the name.
            //
            szCaName = (LPWSTR) new BYTE[dwSize];
            if (!CertGetCertificateContextProperty(
                    pCert,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    szCaName,
                    &dwSize
					))
            {
                ASSERT(0);
                continue;
            }
        }

        //
        // Get the enhanced key usage.
        // With MSMQ1.0 code, this loop fetched all certificates from the
        // user root store and enabled only those marked with the "server
        // authentication" usage. However, It copied ALL certificates to the
        // MSMQ store. Those not marked  with the "server authentication"
        // usages were disabled. The user could enable them using the
        // MSMQ control panel applet.
        // That's wrong!
        // The user should be able to select only from certificates that are
        // marked for "server authentication". He should not even see those
        // that are explicitely marked only for other usages. So for
        // MSMQ2.0, this loop will copy (and enable) only certificates
        // marked for "server authentication". The CertFindCertificateInStore()
        // api will return only the relevant certificates: those marked for
        // server authentication and those which don't include the usage
        // property (and so are good for all usages, by default).
        //

        // Get the subject name of the certificate.
        //
        AP<WCHAR> szSubject;

        hr = _GetCertificateSubject( 
					pCert->pbCertEncoded,
					pCert->cbCertEncoded,
					szSubject 
					);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 210);
        }

        //
        // Compute the SHA1 hash value of the certificate. It is used for
        // searching the certificate in the certificate store.
        //
        BYTE abHash[64];
        DWORD dwHashSize = sizeof(abHash);

        if (!CryptHashCertificate(
                hProv,
                CALG_SHA1,
                0,
                pCert->pbCertEncoded,
                pCert->cbCertEncoded,
                abHash,
                &dwHashSize
				))
        {
            return LogHR(MQ_ERROR, s_FN, 220);
        }

        //
        // Create a certificate context for the certificate.
        //
        CPCCertContext pNewCert;

        pNewCert = CertCreateCertificateContext(
						X509_ASN_ENCODING,
						pCert->pbCertEncoded,
						pCert->cbCertEncoded
						);
        if (!pNewCert)
        {
            return LogHR(MQ_ERROR, s_FN, 230);
        }

        //
        // Add the friendly name property to the certificate context.
        //
        CRYPT_DATA_BLOB DataBlob;

        DataBlob.pbData = (PBYTE)szCaName.get();
        DataBlob.cbData = (wcslen((LPWSTR) szCaName) + 1) * sizeof(WCHAR);

        if (!CertSetCertificateContextProperty(
                pNewCert,
                CERT_FRIENDLY_NAME_PROP_ID,
                0,
                &DataBlob
				))
        {
            return LogHR(MQ_ERROR, s_FN, 240);
        }

        //
        // Add the enabled flag property to the certificate context.
        //
        DataBlob.pbData = (PBYTE)&fEnabled;
        DataBlob.cbData = sizeof(BOOL);

        if (!CertSetCertificateContextProperty(
                pNewCert,
                MQ_CA_CERT_ENABLED_PROP_ID,
                0,
                &DataBlob
				))
        {
            return LogHR(MQ_ERROR, s_FN, 250);
        }

        //
        // Add the subject name property to the certificate context.
        //
        DataBlob.pbData = (PBYTE)szSubject.get();
        DataBlob.cbData = (wcslen(szSubject) + 1) * sizeof(WCHAR);

        if (!CertSetCertificateContextProperty(
                pNewCert,
                MQ_CA_CERT_SUBJECT_PROP_ID,
                0,
                &DataBlob
				))
        {
            return LogHR(MQ_ERROR, s_FN, 260);
        }

        //
        // Add the SHA1 hash property to the certificate context.
        //
        CRYPT_HASH_BLOB HashBlob;

        HashBlob.pbData = abHash;
        HashBlob.cbData = dwHashSize;

        if (!CertSetCertificateContextProperty(
                pNewCert,
                CERT_SHA1_HASH_PROP_ID,
                0,
                &HashBlob
				))
        {
            return LogHR(MQ_ERROR, s_FN, 270);
        }

        //
        // Add the certificate to MSMQ ROOT certificates store.
        //
        if (!CertAddCertificateContextToStore(
                hRootStore,
                pNewCert,
                CERT_STORE_ADD_NEW,
                NULL
				) &&
            (GetLastError() != CRYPT_E_EXISTS))
        {
            return LogHR(MQ_ERROR, s_FN, 280);
        }
    }

    return(MQ_OK);
}

//+-------------------------------------------------------------------------
//
// Function -
//      _UpdateNewCaConfig
//
// Parameters -
//      hRegRoot - A handle to ...\MSMQ\Parameters\CertificationAuthorities
//         registry. This is the ROOT store of CA certificates used by MSMQ.
//      fOldCertsOnly - If TRUE, do not merge certificates from the system
//          ROOT certificate store.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function builds the MSMQ ROOT certificate store for server
//      authentication. The MSMQ store is build out from the certificates of
//      the old SCHANNEL CA certificates and from the certificates in the
//      system ROOT certificate store of the current user.
//
//+-------------------------------------------------------------------------

STATIC HRESULT
_UpdateNewCaConfig( HKEY hRegRoot,
                    BOOL fOldCertsOnly )
{
    HRESULT hr;
    CHCertStore hOldRootStore;

    //
    // Create a temporary in-memory certificate store that will hold the old
    // SCHANNEL CA certificates.
    //
    hOldRootStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                  NULL,
                                  0,
                                  NULL);
    if (!hOldRootStore)
    {
        return LogHR(MQ_ERROR, s_FN, 300);
    }

    //
    // Get the old SCHANNEL CA certificates into the temporary in-memory
    // certificate store. These are the certificated used by MSMQ1.0 from
    // NTEE. They used proprietary IE3.02 store format.
    //
    hr = GetOldCaConfig(hRegRoot, hOldRootStore);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 310);
    }

    //
    // Open MSMQ ROOT certificate store. This store is in registry.
    //
    CHCertStore hRootStore;

    hRootStore = CertOpenStore(CERT_STORE_PROV_REG,
                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               NULL,
                               0,
                               hRegRoot);

    if (!hRootStore)
    {
        return LogHR(MQ_ERROR, s_FN, 320);
    }

    //
    // Add the old SCHANNEL CA certificates to MSMQ ROOT certificates store
    // and get rid of the registry keys of the old certs.
    //
    hr = MergeOldCaConfig(hRootStore, hOldRootStore, hRegRoot);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 330);
    }

    if (!fOldCertsOnly)
    {
        //
        // Add the certificates from the system ROOT certificates store of
        // the current user to MSMQ ROOT certificates store.
        //
        hr = MergeNewCaConfig(hRootStore);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 340);
        }

        //
        // Close the cached store, because it might had changed.
        //
        if (s_hRootStore)
        {
            CertCloseStore(s_hRootStore, CERT_CLOSE_STORE_FORCE_FLAG);
            s_hRootStore = NULL;
        }
    }

    return(MQ_OK);
}

//+------------------------------------------------------------------------
//
//  HRESULT MQsspi_UpdateCaConfig( BOOL fOldCertsOnly )
//
// Parameters:
//      fOldCertsOnly - if TRUE, then only convert IE3.02 compatible
//          CA certificates to IE4 ("new") format. Otherwise, convert IE3.02
//          and copy system CA certificates (from system ROOT store) to MSMQ
//          store.
//
// Description -
//    On MSMQ1.0, NTEE version:
//      This function copies all the names of CAs that are used by SCHANNEL
//      to Falcon registry. Also if a CA was removed from SCHANNEL, it is
//      also removed from Falcon registry.
//
//+------------------------------------------------------------------------

HRESULT APIENTRY MQsspi_UpdateCaConfig( BOOL fOldCertsOnly )
{
    HRESULT hr = MQ_OK ;
    LONG lError;

    //
    // Get a handle to Falcon registry. Don't close this handle
    // because it is cached in MQUTIL.DLL. If you close this handle,
    // the next time you'll need it, you'll get a closed handle.
    //
    HKEY hMqCaRootKey;

    lError = GetFalconKey(CARegKey, &hMqCaRootKey);
    if (lError != ERROR_SUCCESS)
    {
        LogNTStatus(lError, s_FN, 400);
        return MQ_ERROR;
    }

    //
    // On NT, we can safely assume that we either run on NT5 (which has
    // new version of cryptoAPI, or run on NT4/SP4 that have cryptoAPI
    // from IE5. In both cases, use the "new" code.
    //

    hr = _UpdateNewCaConfig(hMqCaRootKey, fOldCertsOnly);
    return LogHR(hr, s_FN, 410) ;
}

//
// Function -
//      GetNewCaCert
//
// Parameters -
//      pbSha1Hash - The SHA1 hash value of the required certificate.
//      dwSha1HashSize - The size of the SHA1 hash value.
//      pcbCert - The size of the resulted certificate.
//      ppbCert - The resulted certificate.
//
// Return value -
//      If successfull MQ_OK, else error code.
//
// Remarks -
//      The function searches the certificate in MSMQ ROOT certificate store.
//      The certificate is uniquely identified according to it's SHA1 hash
//      value.
//
HRESULT
GetNewCaCert(
    PBYTE pbSha1Hash,
    DWORD dwSha1HashSize,
    DWORD *pcbCert,
    LPBYTE *ppbCert)
{
    //
    // Get a handle to MSMQ ROOT certificate store. Keep it statically in order
    // to improve performance.
    //

    if (!s_hRootStore)
    {
        HKEY hRegRoot;
        LONG lError;

        lError = GetFalconKey(CARegKey, &hRegRoot);
        if (lError != ERROR_SUCCESS)
        {
            return LogHR(MQ_ERROR, s_FN, 450);
        }

        s_hRootStore = CertOpenStore(CERT_STORE_PROV_REG,
                                   X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                   NULL,
                                   CERT_STORE_READONLY_FLAG,
                                   hRegRoot);
        ASSERT(s_hRootStore);
        if (!s_hRootStore)
        {
            LogNTStatus(GetLastError(), s_FN, 460);
            ASSERT(0);
            return MQ_ERROR;
        }
    }

    //
    // Lookup the certificate in the store.
    //

    CPCCertContext pCert;
    CRYPT_HASH_BLOB HashBlob = {dwSha1HashSize, pbSha1Hash};

    pCert = CertFindCertificateInStore(
                s_hRootStore,
                X509_ASN_ENCODING,
                0,
                CERT_FIND_SHA1_HASH,
                &HashBlob,
                NULL);
    if (!pCert)
    {
        LogNTStatus(GetLastError(), s_FN, 470);
        return MQ_ERROR;
    }

    //
    // Allocate the buffer for the result and copy the certificate into the
    // buffer.
    //

    AP<BYTE> pbCert = new BYTE[((PCCERT_CONTEXT)pCert)->cbCertEncoded];

    memcpy(pbCert,
           ((PCCERT_CONTEXT)pCert)->pbCertEncoded,
           ((PCCERT_CONTEXT)pCert)->cbCertEncoded);

    //
    // Pass on the result to the caller.
    //
    *pcbCert = ((PCCERT_CONTEXT)pCert)->cbCertEncoded;
    *ppbCert = pbCert.detach();

    return(MQ_OK);
}

//
// Function -
//      MQGetCaCert
//
// Parameters -
//      wszCaName - The registry name of the CA.
//      pcbCert - The size of the CA's certificate.
//      ppbCert - A pointer to a buffer that receives the address of the
//          buffer of the CA's certificate.
//
// Return value -
//      MQ_OK if successfull, else an error code.
//
// Description -
//      The functions allocates the buffer for the certificate. The calling code
//      is responsible for freeing the buffer.
//

HRESULT
MQsspi_GetCaCert(
    LPCWSTR wszCaName,
    PBYTE pbSha1Hash,
    DWORD dwSha1HashSize,
    DWORD *pcbCert,
    LPBYTE *ppbCert)
{
    HRESULT hr;

    if (pbSha1Hash)
    {
        //
        // The caller uses SHA1 hash, this is the new way ...
        //
        ASSERT(dwSha1HashSize);
        HRESULT hr2 = GetNewCaCert(pbSha1Hash, dwSha1HashSize, pcbCert, ppbCert);
        return LogHR(hr2, s_FN, 500);
    }

    //
    // Just get the size of the certificate.
    //
    hr = GetSchannelCaCert(wszCaName, NULL, pcbCert);
    if (hr != MQ_ERROR_USER_BUFFER_TOO_SMALL)
    {
        return LogHR(MQ_ERROR, s_FN, 510);
    }

    AP<BYTE> pbCert = new BYTE[*pcbCert];

    //
    // Now get the certificate.
    //
    hr = GetSchannelCaCert(wszCaName, pbCert, pcbCert);
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 520);
        return MQ_ERROR;
    }

    //
    // Pass on the result.
    //
    *ppbCert = pbCert.detach();
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\srvauthn\sspi.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sspi.cpp

Abstract:

    Functions that implements the server authentication using SSPI over PCT.

Author:

    Boaz Feldbaum (BoazF) 30-Apr-1997.

--*/

#include <stdh_sec.h>
#include "stdh_sa.h"
#include <mqcrypt.h>
#include <mqtempl.h>
#include <mqkeyhlp.h>
#include <cs.h>

static WCHAR *s_FN=L"srvauthn/sspi.cpp";

extern "C"
{
#include <sspi.h>
//#include <sslsp.h>
}

#include "sspitls.h"
#include "schnlsp.h"

#include "sspi.tmh"

//#define SSL3SP_NAME_A    "Microsoft SSL 3.0"
//#define SP_NAME_A SSL3SP_NAME_A
//#define SP_NAME_A PCTSP_NAME_A

//
// PCT and SSL (the above packages names) are broken and unsupported on
// NT5. Use the "unified" package.
//    "Microsoft Unified Security Protocol Provider"
//
#define SP_NAME_A   UNISP_NAME_A

#ifndef SECPKG_ATTR_REMOTE_CRED
typedef struct _SecPkgContext_RemoteCredenitalInfo
{
    DWORD   cbCertificateChain;     // count of bytes in cert chain buffer.
    PBYTE   pbCertificateChain;     // DER encoded chain of certificates.
    DWORD   cCertificates;
    DWORD   fFlags;
}SecPkgContext_RemoteCredenitalInfo, *PSecPkgContext_RemoteCredenitalInfo;

#define SECPKG_ATTR_REMOTE_CRED  0x51

#define RCRED_STATUS_NOCRED          0x00000000
#define RCRED_CRED_EXISTS            0x00000001
#define RCRED_STATUS_UNKNOWN_ISSUER  0x00000002
#endif

PSecPkgInfoA g_PackageInfo;

//
// Function -
//      InitSecInterface
//
// Parameters -
//      None.
//
// Return value -
//      MQ_OK if successful, else error code.
//
// Description -
//      The function initializes the security interface and retrieves the
//      security package information into a global SecPkgInfo structure.
//

extern "C"
{
typedef VOID (WINAPI *SSLFREECERTIFICATE_FN)(PX509Certificate);
typedef BOOL (WINAPI *SSLCRACKCERTIFICATE_FN)(PUCHAR, DWORD, DWORD, PX509Certificate *);
typedef SECURITY_STATUS (SEC_ENTRY *SEALMESSAGE_FN)(PCtxtHandle, DWORD, PSecBufferDesc, ULONG);
typedef SECURITY_STATUS (SEC_ENTRY *UNSEALMESSAGE_FN)(PCtxtHandle, PSecBufferDesc, ULONG, DWORD*);
}

HINSTANCE g_hSchannelDll = NULL;
SSLFREECERTIFICATE_FN g_pfnSslFreeCertificate;
SSLCRACKCERTIFICATE_FN g_pfnSslCrackCertificate;
SEALMESSAGE_FN g_pfnSealMessage;
UNSEALMESSAGE_FN g_pfnUnsealMessage;

#define SealMessage(a, b, c, d) g_pfnSealMessage(a, b, c ,d)
#define UnsealMessage(a, b ,c ,d) g_pfnUnsealMessage(a, b, c, d)
#define SslCrackCertificate(a, b, c, d) g_pfnSslCrackCertificate(a, b, c, d)
#define SslFreeCertificate(a) g_pfnSslFreeCertificate(a)


HRESULT
InitSecInterface(void)
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        g_hSchannelDll = LoadLibraryA("SCHANNEL.DLL");
        if (g_hSchannelDll == NULL)
        {
            return LogHR(MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 10);
        }

        g_pfnSslFreeCertificate = (SSLFREECERTIFICATE_FN)GetProcAddress(g_hSchannelDll, "SslFreeCertificate");
        g_pfnSslCrackCertificate = (SSLCRACKCERTIFICATE_FN)GetProcAddress(g_hSchannelDll, "SslCrackCertificate");
        g_pfnSealMessage = (SEALMESSAGE_FN)GetProcAddress(g_hSchannelDll, "SealMessage");
        g_pfnUnsealMessage = (UNSEALMESSAGE_FN)GetProcAddress(g_hSchannelDll, "UnsealMessage");
        if (!g_pfnSslFreeCertificate ||
            !g_pfnSslCrackCertificate ||
            !g_pfnSealMessage ||
            !g_pfnUnsealMessage)
        {
            return LogHR(MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 20);
        }

        SECURITY_STATUS SecStatus;

        InitSecurityInterface();

        //
        // Retrieve the packge information (SSPI).
        //
        SecStatus = QuerySecurityPackageInfoA(SP_NAME_A, &g_PackageInfo);
        if (SecStatus != SEC_E_OK)
        {
            LogHR(SecStatus, s_FN, 50);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }

        fInitialized = TRUE;
    }

    return MQ_OK;
}

CredHandle g_hClientCred;
BOOL g_fClientCredIntialized = FALSE;

//
// Function -
//      GetClientCredHandle
//
// Parameters -
//      pvClientCredHandle - A pointer to a buffer that receives the pointer
//          to created client's credentials handle. This is an optional
//          parameter. The cleint credentials handle is also stored in a global
//          variable.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function retrieves a cerdentials handle for the client and stores
//      the handle in a global variable. Optionally, the credentials handle
//      can be passed back to the calling code.
//
HRESULT
GetClientCredHandle(
    LPVOID *pvClientCredHandle)
{
    SECURITY_STATUS SecStatus;

    if (!g_fClientCredIntialized)
    {
        //
        // Initialize the security interface.
        //
        SecStatus = InitSecInterface();
        if (SecStatus != SEC_E_OK)
        {
            LogNTStatus(SecStatus, s_FN, 60);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }

        //
        // Retrieve the client's ceredentials handle (SSPI).
        //
        SCHANNEL_CRED   SchannelCred;
        memset(&SchannelCred, 0, sizeof(SchannelCred));

        SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
        SchannelCred.grbitEnabledProtocols = SP_PROT_PCT1 ;

        SecStatus = AcquireCredentialsHandleA(
                        NULL,
                        SP_NAME_A,
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        &SchannelCred,
                        NULL,
                        NULL,
                        &g_hClientCred,
                        NULL);

        if (SecStatus == SEC_E_OK)
        {
            g_fClientCredIntialized = TRUE;
        }
        else
        {
            LogHR(SecStatus, s_FN, 70);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }
    }

    if (pvClientCredHandle)
    {
        //
        // Pass the deredentials handle to the calling code.
        //
        *pvClientCredHandle = &g_hClientCred;
    }

    return MQ_OK;
}

//
// Function -
//      GetClientCredHandleAndInitSecCtx
//
// Parameters -
//      szServerName - The server name with which to create the context.
//      pvClientCredHandle - A pointer to a buffer that receives the client's
//          credentials handel.
//      pvClientSecurityContext - A pointer to a buffer that receives the
//          client's context handle.
//      bTokenBuffer - A pointer to a token buffer that is filled by this
//          function and should be passed to the server.
//      pdwTokenBufferSize - A pointer to a buffer that indicates the size
//          of the token buffer. On entrance the value is the size of the
//          token buffer. On returns from this function, the value is the
//          number of bytes that were written in the buffer and should be
//          passed to the server.
//
// Return value -
//      SEC_I_CONTINUE_NEEDED if successfull, else an error code.
//
// Description -
//      The function creates a credential and context handles for the client
//      and fills in the initial token buffer to be passed to the server. The
//      token buffer should be large enough to contain the result. The required
//      buffer size can be retrieved by caling GetSizes() (below).
//
HRESULT
GetClientCredHandleAndInitSecCtx(
    LPCWSTR wszServerName,
    LPVOID *pvClientCredHandle,
    LPVOID *pvClientSecurityContext,
    LPBYTE pbTokenBuffer,
    DWORD *pdwTokenBufferSize
	)
{
    DWORD szServerNameLen = wcslen(wszServerName);
    AP<CHAR> szServerName = new CHAR[szServerNameLen + 1];
    wcstombs(szServerName, wszServerName, szServerNameLen + 1);

    SECURITY_STATUS SecStatus;

    //
    // Retrieve the client's credentials handle.
    //
    HRESULT hr = GetClientCredHandle(NULL);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 80);
    }

    LPMQSEC_CLICONTEXT lpCliContext = NULL;
    if (TLS_IS_EMPTY)
    {
       lpCliContext = (LPMQSEC_CLICONTEXT) new MQSEC_CLICONTEXT;
       memset( lpCliContext, 0, sizeof(MQSEC_CLICONTEXT));
       BOOL fFree = TlsSetValue(g_hContextIndex, lpCliContext);
	   DBG_USED(fFree);
       ASSERT(fFree);
    }
    else
    {
       lpCliContext = tls_clictx_data;
    }
    ASSERT(lpCliContext);

    if (tls_ClientCtxIsInitialized)
    {
        //
        // Free the current context handle.
        //
        DeleteSecurityContext(&(lpCliContext->hClientContext));
        lpCliContext->fClientContextInitialized = FALSE;
    }

    //
    // Build the output buffer descriptor.
    //
    SecBufferDesc OutputBufferDescriptor;
    SecBuffer OutputSecurityToken;
    ULONG ContextAttributes;

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = &OutputSecurityToken;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    OutputSecurityToken.BufferType = SECBUFFER_TOKEN;
    OutputSecurityToken.cbBuffer = g_PackageInfo->cbMaxToken;
    OutputSecurityToken.pvBuffer = pbTokenBuffer;

    //
    // Call SSPI. Retrieve the data to be passed to the server.
    //
    SecStatus = InitializeSecurityContextA(
                    &g_hClientCred,
                    NULL,                     // No context handle yet
                    szServerName,             // Target name,
                    NULL,
                    0,                        // Reserved parameter
                    SECURITY_NATIVE_DREP,     // Target data representation
                    NULL,                     // No input buffer
                    0,                        // Reserved parameter
                    &(lpCliContext->hClientContext),  // Receives new context handle
                    &OutputBufferDescriptor,  // Receives output security token
                    &ContextAttributes,       // Receives context attributes
                    NULL                      // Don't receives context expiration time
                    );
    if (SecStatus != SEC_I_CONTINUE_NEEDED)
    {
        LogHR(SecStatus, s_FN, 90);
        return MQDS_E_CANT_INIT_SERVER_AUTH;
    }

    //
    // Pass on the results.
    //
    *pvClientCredHandle = &g_hClientCred;
    *pvClientSecurityContext = &(lpCliContext->hClientContext);
    *pdwTokenBufferSize = OutputSecurityToken.cbBuffer;
    lpCliContext->fClientContextInitialized = TRUE;

    return LogHR(SecStatus, s_FN, 100);
}

//
// Function -
//      ClientInitSecCtx
//
// Parameters -
//      phClientCred - A pointer to the client credentials handle.
//      phClientContext - A pointer to the client context handle.
//      pServerBuff - The buffer that was received from the server.
//      dwServerBuffSize - The size of the buffer that was received from the
//          server.
//      dwMaxClientBuffSize - The size of the cleint buffer.
//      pClientBuff - A pointer to the client buffer.
//      pdwClientBuffSize - The number of bytes that were written into the
//          client buffer.
//
// Return value -
//      SEC_I_CONTINUE_NEEDED if more negotiation with the server is needed.
//      MQ_OK if the negotiation is done. Else an error code.
//
// Description -
//      The function calls SSPI to process the buffer that was received from
//      the server and to get new data to be passed once again to the server.
//
HRESULT
APIENTRY
ClientInitSecCtx(
    LPVOID phClientCred,
    LPVOID phClientContext,
    UCHAR *pServerBuff,
    DWORD dwServerBuffSize,
    DWORD dwMaxClientBuffSize,
    UCHAR *pClientBuff,
    DWORD *pdwClientBuffSize)
{
    SecBufferDesc InputBufferDescriptor;
    SecBuffer InputSecurityToken;
    SecBufferDesc OutputBufferDescriptor;
    SecBuffer OutputSecurityToken;
    ULONG ContextAttributes;

    //
    // Build the input buffer descriptor.
    //

    InputBufferDescriptor.cBuffers = 1;
    InputBufferDescriptor.pBuffers = &InputSecurityToken;
    InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    InputSecurityToken.BufferType = SECBUFFER_TOKEN;
    InputSecurityToken.cbBuffer = dwServerBuffSize;
    InputSecurityToken.pvBuffer = pServerBuff;

    //
    // Build the output buffer descriptor.
    //

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = &OutputSecurityToken;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    OutputSecurityToken.BufferType = SECBUFFER_TOKEN;
    OutputSecurityToken.cbBuffer = dwMaxClientBuffSize;
    OutputSecurityToken.pvBuffer = pClientBuff;

    SECURITY_STATUS SecStat;

    //
    // Call SSPI to process the server's buffer and retrieve new data to be
    // passed to the server, if neccessary.
    //
    SecStat = InitializeSecurityContextA(
                  (CredHandle *)phClientCred,
                  (CtxtHandle *)phClientContext,    // Context handle
                  NULL,                             // No target name.
                  0,
                  0,                                // Reserved parameter
                  SECURITY_NATIVE_DREP,             // Target data representation
                  &InputBufferDescriptor,           // Input buffer
                  0,                                // Reserved parameter
                  (CtxtHandle *)phClientContext,    // Receives new context handle
                  &OutputBufferDescriptor,          // Receives output security token
                  &ContextAttributes,               // Receives context attributes
                  NULL                              // Don't receives context expiration time
                  );

    *pdwClientBuffSize = OutputSecurityToken.cbBuffer;

    return LogHR((HRESULT)SecStat, s_FN, 120);
}

CredHandle g_hServerCred;
BOOL g_fInitServerCredHandle = FALSE;
static CCriticalSection s_csServerCredHandle;

//
// Function -
//      InitServerCredHandle
//
// Parameters -
//      cbPrivateKey - The size of the server's private key in bytes.
//      pPrivateKey - A pointer to the server's private key buffer.
//      cbCertificate - The size of the server's certificate buffer in bytes.
//      pCertificate - A pointer to the server's certificate buffer
//      szPassword - A pointer to the password with which the server's private
//          key is encrypted.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function creates the server's ceredentials handle out from the
//      certificate and the private key.
//
HRESULT
InitServerCredHandle( 
	HCERTSTORE     hStore,
	PCCERT_CONTEXT pContext 
	)
{
    if (g_fInitServerCredHandle)
    {
        return MQ_OK;
    }

    CS Lock(s_csServerCredHandle);

    if (!g_fInitServerCredHandle)
    {
        //
        // Initialize the security interface.
        //
        SECURITY_STATUS SecStatus = InitSecInterface();
        if (SecStatus != SEC_E_OK)
        {
            LogHR(SecStatus, s_FN, 140);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }

        //
        // Fill the credential structure.
        //
        SCHANNEL_CRED   SchannelCred;

        memset(&SchannelCred, 0, sizeof(SchannelCred));

        SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;

        SchannelCred.cCreds = 1;
        SchannelCred.paCred = &pContext;

        SchannelCred.grbitEnabledProtocols = SP_PROT_PCT1;

        //
        // Retrieve the ceredentials handle (SSPI).
        //
        LPSTR lpszPackage = SP_NAME_A ;
        SecStatus = AcquireCredentialsHandleA( 
						NULL,
						lpszPackage,
						SECPKG_CRED_INBOUND,
						NULL,
						&SchannelCred,
						NULL,
						NULL,
						&g_hServerCred,
						NULL
						);

        if (SecStatus == SEC_E_OK)
        {
            g_fInitServerCredHandle = TRUE;
        }
        else
        {
            DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _T("Failed to acquire a handle for user cridentials. %!winerr!"), SecStatus));
        }
    }

    return LogHR(g_fInitServerCredHandle ? MQ_OK : MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 150);
}

//
// Function -
//      ServerAcceptSecCtx
//
// Parameters -
//      fFirst - Indicates whether or not this is the first time the context
//          is to be accepted.
//      pvhServerContext - A pointer to a the server's context handle.
//      pbServerBuffer - A pointer to the server buffer. This buffer is filled
//          by in function. The contents of the buffer should be passed to the
//          client.
//      pdwServerBufferSize - A pointer to a buffer the receives the number of
//          bytes that were written to the server buffer.
//      pbClientBuffer - A buffer that was received from the client.
//      dwClientBufferSize - the size of the buffer that was received from the
//          client.
//
// Return value -
//      SEC_I_CONTINUE_NEEDED if more negotiation with the server is needed.
//      MQ_OK if the negotiation is done. Else an error code.
//
// Description -
//      The function calls SSPI to process the buffer that was received from
//      the client and to get new data to be passed once again to the client.
//
HRESULT
ServerAcceptSecCtx(
    BOOL fFirst,
    LPVOID *pvhServerContext,
    LPBYTE pbServerBuffer,
    DWORD *pdwServerBufferSize,
    LPBYTE pbClientBuffer,
    DWORD dwClientBufferSize)
{
    if (!g_fInitServerCredHandle)
    {
        return LogHR(MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 170);
    }

    SECURITY_STATUS SecStatus;

    SecBufferDesc InputBufferDescriptor;
    SecBuffer InputSecurityToken;
    SecBufferDesc OutputBufferDescriptor;
    SecBuffer OutputSecurityToken;
    ULONG ContextAttributes;
    PCtxtHandle phServerContext = (PCtxtHandle)*pvhServerContext;

    //
    // Build the input buffer descriptor.
    //

    InputBufferDescriptor.cBuffers = 1;
    InputBufferDescriptor.pBuffers = &InputSecurityToken;
    InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    InputSecurityToken.BufferType = SECBUFFER_TOKEN;
    InputSecurityToken.cbBuffer = dwClientBufferSize;
    InputSecurityToken.pvBuffer = pbClientBuffer;

    //
    // Build the output buffer descriptor. We need to allocate a buffer
    // to hold this buffer.
    //

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = &OutputSecurityToken;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    OutputSecurityToken.BufferType = SECBUFFER_TOKEN;
    OutputSecurityToken.cbBuffer = g_PackageInfo->cbMaxToken;
    OutputSecurityToken.pvBuffer = pbServerBuffer;

    if (fFirst)
    {
        //
        // Upon the first call, allocate the context handle.
        //
        phServerContext = new CtxtHandle;
    }

    //
    // Call SSPI to process the client's buffer and retrieve new data to be
    // passed to the client, if neccessary.
    //
    SecStatus = AcceptSecurityContext(
          &g_hServerCred,
          fFirst ? NULL : phServerContext,
          &InputBufferDescriptor,
          0,                        // No context requirements
          SECURITY_NATIVE_DREP,
          phServerContext,          // Receives new context handle
          &OutputBufferDescriptor,  // Receives output security token
          &ContextAttributes,       // Receives context attributes
          NULL                      // Don't receive context expiration time
          );
    LogHR(SecStatus, s_FN, 175);

    HRESULT hr =  ((SecStatus == SEC_E_OK) ||
                   (SecStatus == SEC_I_CONTINUE_NEEDED)) ?
                        SecStatus : MQDS_E_CANT_INIT_SERVER_AUTH;
    if (SUCCEEDED(hr))
    {
        //
        // Pass on the results.
        //
        *pdwServerBufferSize = OutputSecurityToken.cbBuffer;
        if (fFirst)
        {
            *pvhServerContext = phServerContext;
        }
    }

    return LogHR(hr, s_FN, 180);
}

//
// Function -
//      GetSizes
//
// Parameters -
//      pcbMaxToken - A pointer to a buffer that receives the maximun required
//          size for the token buffer. This is an optional parameter.
//      pvhContext - A pointer to a context handle. This is an optional
//          parameter.
//      pcbHeader - A pointer to a buffer that receives the stream header size
//          for the context. This is an optional parameter.
//      cpcbTrailer - A pointer to a buffer that receives the stream trailer
//          size for the context. This is an optional parameter.
//      pcbMaximumMessage - A pointer to a buffer that receives the maximum
//          message size that can be handled in this context. This is an
//          optional parameter.
//      pcBuffers - A pointer t oa buffer that receives the number of buffers
//          that should be passed to SealMessage/UnsealMessage. This is an
//          optional parameter.
//      pcbBlockSize - A pointer to a buffer that receives the block size used
//          in this context. This is an optional parameter.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function retrieves the various required sizes. The maximum token
//      size is per the security package. So no need for a context handle in
//      order to retrieve the maximum token size. For all the other values, it
//      is required to pass a context handle.
//      The function is implemented assuming that first it is called to
//      retrieve only the maximum token size and after that, in a second call,
//      it is called for retreiving the other (context related) values.
//
HRESULT
GetSizes(
    DWORD *pcbMaxToken,
    LPVOID pvhContext,
    DWORD *pcbHeader,
    DWORD *pcbTrailer,
    DWORD *pcbMaximumMessage,
    DWORD *pcBuffers,
    DWORD *pcbBlockSize)
{
    SECURITY_STATUS SecStatus;

    if (!pvhContext)
    {
        //
        // Initialize the security interface.
        //
        SecStatus = InitSecInterface();
        if (SecStatus != SEC_E_OK)
        {
            LogHR(SecStatus, s_FN, 190);
            return MQDS_E_CANT_INIT_SERVER_AUTH;
        }
    }
    else
    {
        //
        // Get the context related values.
        //
        SecPkgContext_StreamSizes ContextStreamSizes;

        SecStatus = QueryContextAttributesA(
            (PCtxtHandle)pvhContext,
            SECPKG_ATTR_STREAM_SIZES,
            &ContextStreamSizes
            );

        if (SecStatus == SEC_E_OK)
        {
            //
            // Pass on the results, as required.
            //
            if (pcbHeader)
            {
                *pcbHeader = ContextStreamSizes.cbHeader;
            }

            if (pcbTrailer)
            {
                *pcbTrailer = ContextStreamSizes.cbTrailer;
            }

            if (pcbMaximumMessage)
            {
                *pcbMaximumMessage = ContextStreamSizes.cbMaximumMessage;
            }

            if (pcBuffers)
            {
                *pcBuffers = ContextStreamSizes.cBuffers;
            }

            if (pcbBlockSize)
            {
                *pcbBlockSize = ContextStreamSizes.cbBlockSize;
            }

        }
    }

    //
    // Pass on the resulted maximum token size, as required.
    //
    if (pcbMaxToken)
    {
        *pcbMaxToken = g_PackageInfo->cbMaxToken;
    }

    return LogHR((HRESULT)SecStatus, s_FN, 200);
}

//+---------------------
//
//  MQsspi_GetNames()
//
//+---------------------

HRESULT
MQsspi_GetNames(
    LPVOID pvhContext,
    LPSTR szServerName,
    DWORD *pdwServerNameLen,
    LPSTR szIssuerName,
    DWORD *pdwIssuerNameLen)
{
    HRESULT hr = MQ_OK;
    SECURITY_STATUS SecStatus;

    //
    // Get the server name.
    //
    SecPkgContext_Names Names;

    SecStatus = QueryContextAttributesA(
        (PCtxtHandle)pvhContext,
        SECPKG_ATTR_NAMES,
        &Names
        );

    DWORD dwBuffLen = *pdwServerNameLen;
    *pdwServerNameLen = strlen((LPCSTR)Names.sUserName);

    if (dwBuffLen < *pdwServerNameLen + 1)
    {
        hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
    }
    else
    {
        strcpy(szServerName, (LPCSTR)Names.sUserName);
    }

    //
    // Free the server name string. This was allocated by SSPI.
    //
    FreeContextBuffer(Names.sUserName);

    //
    // Get the issuer name.
    //
    SecPkgContext_Authority Authority;

    SecStatus = QueryContextAttributesA(
        (PCtxtHandle)pvhContext,
        SECPKG_ATTR_AUTHORITY,
        &Authority
        );

    dwBuffLen = *pdwIssuerNameLen;
    *pdwIssuerNameLen = strlen((LPCSTR)Authority.sAuthorityName);

    if (dwBuffLen < *pdwIssuerNameLen + 1)
    {
        hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
    }
    else
    {
        strcpy(szIssuerName, (LPCSTR)Authority.sAuthorityName);
    }

    //
    // Free the issuer name string. This was allocated by SSPI.
    //
    FreeContextBuffer(Authority.sAuthorityName);

    return LogHR(hr, s_FN, 210);
}

//
// Function -
//      FreeContextHandle
//
// Parameters -
//      pvhContextHandle - A pointer to a context handle.
//
// Return value -
//      None.
//
// Description -
//      The function deletes the context and frees the memory for the context
//      handle.
//
void
FreeContextHandle(
    LPVOID pvhContextHandle)
{
    PCtxtHandle pCtxtHandle = (PCtxtHandle) pvhContextHandle;

    //
    // delete the context.
    //
    DeleteSecurityContext(pCtxtHandle);

    //
    // Free the momery for the context handle.
    //
    delete pCtxtHandle;
}

//
// Function -
//      MQSealBuffer
//
// Parameters -
//      pvhContext - A pointer to a context handle.
//      pbBuffer - A buffer to be sealed.
//      cbSize -  The size of the buffer to be sealed.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function seals the buffer. That is, it signes and decryptes the
//      buffer. The buffer should be constructed as follows:
//
//          |<----------------- cbSize ------------------>|
//          +--------+--------------------------+---------+
//          | Header | Actual data to be sealed | Trailer |
//          +--------+--------------------------+---------+
//
//      The header and trailer are parts of the buffer that are filled by SSPI
//      when sealing the buffer. The sizes of the header and the trailer can
//      be retrieved by calling GetSizes() (above).
//
HRESULT
MQSealBuffer(
    LPVOID pvhContext,
    PBYTE pbBuffer,
    DWORD cbSize)
{
    SECURITY_STATUS SecStatus;

    //
    // Get the header and trailer sizes, and the required number of buffers.
    //
    SecPkgContext_StreamSizes ContextStreamSizes;

    SecStatus = QueryContextAttributesA(
        (PCtxtHandle)pvhContext,
        SECPKG_ATTR_STREAM_SIZES,
        &ContextStreamSizes
        );

    if (SecStatus != SEC_E_OK)
    {
        return LogHR((HRESULT)SecStatus, s_FN, 220);
    }

    ASSERT(cbSize > ContextStreamSizes.cbHeader + ContextStreamSizes.cbTrailer);

    //
    // build the stream buffer descriptor
    //
    SecBufferDesc SecBufferDescriptor;
    AP<SecBuffer> aSecBuffers = new SecBuffer[ContextStreamSizes.cBuffers];

    SecBufferDescriptor.cBuffers = ContextStreamSizes.cBuffers;
    SecBufferDescriptor.pBuffers = aSecBuffers;
    SecBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    //
    // Build the header buffer.
    //
    aSecBuffers[0].BufferType = SECBUFFER_STREAM_HEADER;
    aSecBuffers[0].cbBuffer = ContextStreamSizes.cbHeader;
    aSecBuffers[0].pvBuffer = pbBuffer;

    //
    // Build the data buffer.
    //
    aSecBuffers[1].BufferType = SECBUFFER_DATA;
    aSecBuffers[1].cbBuffer = cbSize - ContextStreamSizes.cbHeader - ContextStreamSizes.cbTrailer;
    aSecBuffers[1].pvBuffer = (PBYTE)aSecBuffers[0].pvBuffer + aSecBuffers[0].cbBuffer;

    //
    // Build the trailer buffer.
    //
    aSecBuffers[2].BufferType = SECBUFFER_STREAM_TRAILER;
    aSecBuffers[2].cbBuffer = ContextStreamSizes.cbTrailer;
    aSecBuffers[2].pvBuffer = (PBYTE)aSecBuffers[1].pvBuffer + aSecBuffers[1].cbBuffer;

    //
    // Build the rest of the buffer as empty buffers.
    //
    for (DWORD i = 3; i < ContextStreamSizes.cBuffers; i++)
    {
        aSecBuffers[i].BufferType = SECBUFFER_EMPTY;
    }

    //
    // Call SSPI to seal the buffer.
    //
    SecStatus = SealMessage((PCtxtHandle)pvhContext, 0, &SecBufferDescriptor, 0);

    return LogHR((HRESULT)SecStatus, s_FN, 230);
}

//
// Function -
//      MQUnsealBuffer
//
// Parameters -
//      pvhContext - A pointer toa context handle.
//      pbBuffer - A pointer to the buffer to be unsealed.
//      cbSize - The size of the buffer to be unsealed.
//      ppbUnsealed - A pointer to a buffer that receives the address of the
//          actual unsealed data.
//
// Return value -
//      MQ_OK if successfull, else error code.
//
// Description -
//      The function unseals the buffer. The unsealed buffer has the following
//      structure:
//          |<---------------- cbSize ---------------->|
//          +--------+-----------------------+---------+
//          | Header | Actual unsealled data | Trailer |
//          +--------+-----------------------+---------+
//                    ^
//                    |-------- *ppbUnsealed
//
//      The header and trailer parts of the unsealled buffer are used by SSPI.
//      The sizes of the header and the trailer can be retrieved by calling
//      GetSizes() (above).
//
HRESULT
MQUnsealBuffer(
    LPVOID pvhContext,
    PBYTE pbBuffer,
    DWORD cbSize,
    PBYTE *ppbUnsealed)
{
    SECURITY_STATUS SecStatus;

    //
    // Get the header and trailer sizes, and the required number of buffers.
    //
    SecPkgContext_StreamSizes ContextStreamSizes;

    SecStatus = QueryContextAttributesA(
        (PCtxtHandle)pvhContext,
        SECPKG_ATTR_STREAM_SIZES,
        &ContextStreamSizes
        );

    if (SecStatus != SEC_E_OK)
    {
        return LogHR((HRESULT)SecStatus, s_FN, 240);
    }

    //
    // Build the buffer descriptor.
    //
    SecBufferDesc SecBufferDescriptor;
    AP<SecBuffer> aSecBuffers = new SecBuffer[ContextStreamSizes.cBuffers];

    SecBufferDescriptor.cBuffers = ContextStreamSizes.cBuffers;
    SecBufferDescriptor.pBuffers = aSecBuffers;
    SecBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    //
    // set the first buffer as the data buffer that contains the sealed data.
    //
    aSecBuffers[0].BufferType = SECBUFFER_DATA;
    aSecBuffers[0].cbBuffer = cbSize;
    aSecBuffers[0].pvBuffer = pbBuffer;

    DWORD i;

    //
    // Build the rest of the buffer as empty buffers.
    //
    for (i = 1; i < ContextStreamSizes.cBuffers; i++)
    {
        aSecBuffers[i].BufferType = SECBUFFER_EMPTY;
    }

    //
    // Call SSPI to unseal the buffer.
    //
    SecStatus = UnsealMessage((PCtxtHandle)pvhContext, &SecBufferDescriptor, 0, NULL);

    if (SecStatus == SEC_E_OK)
    {
        //
        // Find the data buffer (it is not the first one as it used to be
        // before UnsealMessage() was called).
        //
        for (i = 0;
             (i < ContextStreamSizes.cBuffers) && (aSecBuffers[i].BufferType != SECBUFFER_DATA);
             i++);

        ASSERT(i != ContextStreamSizes.cBuffers);

        //
        // Set the pointer to the actual unsealed data.
        //
        *ppbUnsealed = (PBYTE)aSecBuffers[i].pvBuffer;
    }

    return LogHR((HRESULT)SecStatus, s_FN, 250);
}

//
// Function -
//      GetCertificateNames
//
// Parameters -
//      pbCertificate - A pointer to a buffer that contains the certificate.
//      cbCertificate - The size of the certificate.
//      pszSubject - A pointer to a buffer that receives the address of the
//          subject name.
//      pdwSubjectLen - A pointer to a buffer that on entrance contains the
//          size of pszSubject in unicode characters. On return the buffer
//          contains the subject name length in unicode characters.
//      pszIssuer - A pointer to a buffer that receives the address of the
//          issuer name.
//      pdwIssuerLen - A pointer to a buffer that on entrance contains the
//          size of pszIssuer in unicode characters. On return the buffer
//          contains the issuer name length in unicode characters.
//
// Return value -
//      MQ_OK if successful, else an error code.
//
// Description -
//      The function retrieves the issuer and subject names of the certificate.
//      It is important to use this function with the srtings that are returned
//      by SSPI because the setings are not the standard strings that are used
//      by CAPI 2.0.
//
HRESULT
GetCertificateNames(
    LPBYTE pbCertificate,
    DWORD cbCertificate,
    LPSTR szSubject,
    DWORD *pdwSubjectLen,
    LPSTR szIssuer,
    DWORD *pdwIssuerLen)
{
    HRESULT hr;
    PX509Certificate pCert;

    hr = InitSecInterface();
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 260);
    }

    //
    // Call SCHANNEL
    //
    if (!g_pfnSslCrackCertificate(pbCertificate, cbCertificate, 0, &pCert))
    {
        return LogHR(MQ_ERROR_INVALID_CERTIFICATE, s_FN, 270);
    }

    //
    // Pass on the results.
    //

    DWORD dwSubjectLen = *pdwSubjectLen;
    DWORD dwIssuerLen = *pdwIssuerLen;

    *pdwSubjectLen = strlen(pCert->pszSubject);
    *pdwIssuerLen = strlen(pCert->pszIssuer);

    if (dwSubjectLen < *pdwSubjectLen + 1)
    {
        *pdwSubjectLen += 1;
        hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
    }

    if (dwIssuerLen < *pdwIssuerLen + 1)
    {
        *pdwIssuerLen += 1;
        hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
    }

    if (SUCCEEDED(hr))
    {
        strcpy(szSubject, pCert->pszSubject);
        strcpy(szIssuer, pCert->pszIssuer);
    }

    g_pfnSslFreeCertificate(pCert);

    return LogHR(hr, s_FN, 280);
}

//
// The system API QueryContextAttributes trashes the stack when passed the
// SECPKG_ATTR_REMOTE_CRED parameter. I've found a safe way to workaround
// this using the structure below and returning the structure as the return
// value of a wrapped function (CheckContextCredStatusInternal).
//
typedef struct
{
    SecPkgContext_RemoteCredentialInfo RemoteCred;
    SECURITY_STATUS SecStatus;
} SecPkgContext_RemoteCredenitalInfo_1;

SecPkgContext_RemoteCredenitalInfo_1
CheckContextCredStatusInternal(
    PCtxtHandle pContext)
{
    SecPkgContext_RemoteCredenitalInfo_1 RemoteCred_1;

    RemoteCred_1.SecStatus = QueryContextAttributesA(
                                    pContext,
                                    SECPKG_ATTR_REMOTE_CRED,
                                    &RemoteCred_1.RemoteCred);

    return RemoteCred_1;
}

//
// Function -
//      CheckContextCredStatus
//
// Parameters -
//      pvhContext - A pointer to the client's context handle.
//      pbServerCertificate - A pointer to a buffer that receives the
//          server's certificate.
//      cbServerCertificateBuffSize - The size of the buffer for pointed
//          by pbServerCertificate.
//
// Return value -
//      MQ_OK if successful, else error code.
//
// Description -
//      The function returns the server certificate for the passed context
//      handle.
//
//      The system API QueryContextAttributes trashes the stack when passed the
//      SECPKG_ATTR_REMOTE_CRED parameter. I've found a safe way to workaround
//      this using the structure SecPkgContext_RemoteCredenitalInfo_1 below and
//      returning the structure as the return value of a wrapped function
//      (CheckContextCredStatusInternal).
//
HRESULT
CheckContextCredStatus(
    LPVOID pvhContext,
    PBYTE pbServerCertificate,
    DWORD *pcbServerCertificateBuffSize)
{
    SecPkgContext_RemoteCredenitalInfo_1 RemoteCred_1;

    RemoteCred_1 = CheckContextCredStatusInternal((PCtxtHandle)pvhContext);

    if (RemoteCred_1.SecStatus != SEC_E_OK)
    {
        return LogHR(MQDS_E_CANT_INIT_SERVER_AUTH, s_FN, 290);
    }

    DWORD cbServerCertificateBuffSize = *pcbServerCertificateBuffSize;

    *pcbServerCertificateBuffSize = RemoteCred_1.RemoteCred.cbCertificateChain;

    if (RemoteCred_1.RemoteCred.cbCertificateChain > cbServerCertificateBuffSize)
    {
        return LogHR(MQ_ERROR_USER_BUFFER_TOO_SMALL, s_FN, 300);
    }

    memcpy(pbServerCertificate,
           RemoteCred_1.RemoteCred.pbCertificateChain,
           RemoteCred_1.RemoteCred.cbCertificateChain);

    return MQ_OK;
}

#define CACertsRegLocation "System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\"
#define CACertRegValueName "CACert"

HRESULT
GetSchannelCaCert(
    LPCWSTR wszCaRegName,
    PBYTE pbCert,
    DWORD *pdwCertSize)
{
    HRESULT hr;

    DWORD dwCaRegNameLen = wcslen(wszCaRegName);
    AP<CHAR> szCaRegName = new CHAR[dwCaRegNameLen + 1];

    wcstombs(szCaRegName, wszCaRegName, dwCaRegNameLen + 1);

    AP<CHAR> szCaRegLocation = new CHAR[sizeof(CACertsRegLocation) / sizeof(CHAR) +
                                        sizeof(CARegKey) / sizeof(CHAR) +
                                        dwCaRegNameLen];

    strcat(strcpy(szCaRegLocation, CACertsRegLocation CARegKeyA "\\"), szCaRegName);

    //
    // Get a handle to the certification authorities registry of SCHANNEL.
    //

    CAutoCloseRegHandle hCert;
    LONG lError;

    lError = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                         szCaRegLocation,
                         &hCert);
    if (lError != ERROR_SUCCESS)
    {
        LogNTStatus(lError, s_FN, 400);
        return MQ_ERROR;
    }

    DWORD dwType;

    if (!pbCert)
    {
        *pdwCertSize = 0;
    }

    lError = RegQueryValueExA(hCert,
                              CACertRegValueName,
                              0,
                              &dwType,
                              pbCert,
                              pdwCertSize);

    hr = MQ_OK;

    switch (lError)
    {
    case ERROR_MORE_DATA:
        hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
        break;
    case ERROR_SUCCESS:
        if (!pbCert)
        {
            hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
        }
        break;
    case ERROR_FILE_NOT_FOUND:
        hr = MQ_ERROR;
        break;
    default:
        hr = MQ_ERROR_CORRUPTED_SECURITY_DATA;
        break;
    }

    return LogHR(hr, s_FN, 410);

}

//+---------------------------------
//
//  BOOL WINAPI MQsspiDllMain ()
//
//+---------------------------------

BOOL WINAPI
MQsspiDllMain(HMODULE hMod, DWORD ulReason, LPVOID lpvReserved)
{
   BOOL fFree ;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // DLL is attaching to the address space of the current process
        //
        g_hContextIndex = TlsAlloc() ;

        if (g_hContextIndex == UNINIT_TLSINDEX_VALUE)
        {
           return FALSE ;
        }

        //
        // fall thru, put a null in the tls.
        //

    case DLL_THREAD_ATTACH:
        fFree = TlsSetValue( g_hContextIndex, NULL ) ;
        ASSERT(fFree) ;
        break;

    case DLL_PROCESS_DETACH:
        //
        // BUGBUG - We can't delete the security context here because schannel may
        //          do it's cleanup before us and the certificates in the context will
        //          already be deleted. So deleting the securiy context will try to
        //          delete a certificate. This may cause bad thing to happen. So
        //          currently we risk in leaking some memory. Same goes to the credentials
        //          handles.
        //
/*
*        if (g_fClientCredIntialized)
*        {
*            FreeCredentialsHandle(&g_hClientCred);
*        }
*
*        if (g_fClientContextInitialized)
*        {
*            DeleteSecurityContext(&g_hClientContext);
*        }
*        if (g_fInitServerCredHandle)
*        {
*            FreeCredentialsHandle(&g_hServerCred);
*        }
*/
        if (g_hSchannelDll)
        {
            FreeLibrary(g_hSchannelDll);
        }

        //
        //  Free the tls index for the rpc binding handle
        //
        ASSERT(g_hContextIndex != UNINIT_TLSINDEX_VALUE) ;
        if (g_hContextIndex != UNINIT_TLSINDEX_VALUE)
        {
           fFree = TlsFree( g_hContextIndex ) ;
           ASSERT(fFree) ;
        }
        break;

    case DLL_THREAD_DETACH:
        if (!TLS_IS_EMPTY)
        {
           if (tls_ClientCtxIsInitialized)
           {
               DeleteSecurityContext(&(tls_clictx_data->hClientContext)) ;
           }
           delete  tls_clictx_data ;
        }
        break ;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsec\srvauthn\sspitls.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    sspitls.h

Abstract:
    definitions for data kept in tls.

Author:
    Doron Juster  (DoronJ)   22-May-1997   Created

--*/

#ifndef __SSPITLS_H
#define __SSPITLS_H

//
// Each thread has its own client context, for server authentication,
// because each thread can connect to a different MQIS server.
//
// The context is stored in a TLS slot. We can't use
// declspec(thread) because the dll can be dynamically loaded
// (by LoadLibrary()).
//
// This is the index of the slot.
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff
DWORD  g_hContextIndex = UNINIT_TLSINDEX_VALUE ;

typedef struct _MQSEC_CLICONTEXT
{
   CtxtHandle hClientContext;
   BOOL       fClientContextInitialized ;
}
MQSEC_CLICONTEXT, *LPMQSEC_CLICONTEXT ;

#define tls_clictx_data  ((LPMQSEC_CLICONTEXT) TlsGetValue(g_hContextIndex))

#define TLS_IS_EMPTY     (tls_clictx_data == NULL)

#define tls_ClientCtxIsInitialized \
                      (tls_clictx_data->fClientContextInitialized == TRUE)

#endif // __SSPITLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqsvc\svcmain.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcMain.cpp

Abstract:
    MSMQ Service process

Author:
    Erez Haba (erezh) 20-Feb-2001

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <qm.h>


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    MSMQ Service dispatcher

Arguments:
    arc, arv passed on.

Returned Value:
    Zero

--*/
{
    return QMMain(argc, argv);
} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\cancel.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    cancel.cpp

Abstract:

Author:

--*/

#include "stdh.h"
#include "cancel.h"

#include "cancel.tmh"

MQUTIL_EXPORT CCancelRpc	g_CancelRpc;

DWORD
WINAPI
CCancelRpc::CancelThread(
    LPVOID pParam
    )
/*++

Routine Description:

    Thread routine to cancel pending RPC calls

Arguments:

    None

Return Value:

    None

--*/
{
    CCancelRpc* p = static_cast<CCancelRpc*>(pParam);
    p->ProcessEvents();

    ASSERT(("this line should not be reached!", 0));
    return 0;
}



CCancelRpc::CCancelRpc() :
	m_hModule(NULL),
	m_RefCount(0),
	m_fThreadIntializationComplete(false)
{
    //
    // This auto-reset event controls whether the Cancel-rpc thread wakes up
    //
    m_hRpcPendingEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ASSERT(NULL != m_hRpcPendingEvent.operator HANDLE());

	//
    //  When signaled this event tells the worker threads when to
    //  terminate
    //
    m_hTerminateThreadEvent = CreateEvent( NULL, FALSE, FALSE, NULL);
    ASSERT(NULL != m_hTerminateThreadEvent.operator HANDLE());
}


CCancelRpc::~CCancelRpc()
{
}


void
CCancelRpc::Init(
    void
    )
{
	CS lock(m_cs);

	++m_RefCount;
	if(m_RefCount > 1)
		return;

	if(m_hCancelThread != (HANDLE) NULL)
	{
		//
		// There is a scenario when the MQRT dll is shut down and it signals the cancel thread to
		// terminate but before it does the MQRT is loaded again and we may end up trying to
		// create a new cancel thread before the old one exits, so we wait here.
		//
		DWORD res = WaitForSingleObject(m_hCancelThread, INFINITE);
		ASSERT(res == WAIT_OBJECT_0);
		UNREFERENCED_PARAMETER(res);

		HANDLE hThread = m_hCancelThread;
		m_hCancelThread = NULL;
		CloseHandle(hThread);
	}

    //
    //  Read rpc cancel registry timeout
    //
    m_dwRpcCancelTimeout = 0 ;
    DWORD dwCancelTimeout =  FALCON_DEFAULT_RPC_CANCEL_TIMEOUT;
    DWORD  dwSize = sizeof(DWORD);
    DWORD  dwType = REG_DWORD;

    LONG rc = GetFalconKeyValue( FALCON_RPC_CANCEL_TIMEOUT_REGNAME,
                                &dwType,
                                &m_dwRpcCancelTimeout,
                                &dwSize,
                                 (LPCTSTR)&dwCancelTimeout);

    if ((rc != ERROR_SUCCESS) || (m_dwRpcCancelTimeout == 0))
    {
        m_dwRpcCancelTimeout = FALCON_DEFAULT_RPC_CANCEL_TIMEOUT;
    }
    m_dwRpcCancelTimeout *= ( 60 * 1000);    // in millisec
    ASSERT(m_dwRpcCancelTimeout != 0) ;


    WCHAR szModuleName[_MAX_PATH];
    GetModuleFileName(g_hInstance, szModuleName, _MAX_PATH);
    m_hModule = LoadLibrary(szModuleName);

    ASSERT(m_hModule != NULL);

    //
    //  Create Cancel-rpc thread
    //
    DWORD   dwCancelThreadId;
    m_hCancelThread = CreateThread(
                               NULL,
                               0,       // stack size
                               CancelThread,
                               this,
                               0,       // creation flag
                               &dwCancelThreadId
                               );

    if(m_hCancelThread == NULL)
    {
        FreeLibrary(m_hModule);

        //
        // ISSUE-2001/5/9-erezh  Cancel thread failure is not reported
        //
        return;
    }

    //
    // Wait for Cancel thread to complete its initialization
    //
    while(!m_fThreadIntializationComplete)
    {
        Sleep(100);
    }

}//CCancelRpc::Init



void CCancelRpc::ShutDownCancelThread()
{
	CS lock(m_cs);

	--m_RefCount;
	ASSERT(m_RefCount >= 0);
	if(m_RefCount > 0)
		return;

    SetEvent(m_hTerminateThreadEvent);
}



void
CCancelRpc::ProcessEvents(
    void
    )
{
	//
    //  for MQAD operations with ADSI, we need MSMQ thread that
    //  calls CoInitialize and is up and runing as long as
    //  RT & QM are up
    //
    //  To avoid the overhead of additional thread, we are using
    //  cancel thread for this purpose
    //
    HRESULT hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
    UNREFERENCED_PARAMETER(hr);
    ASSERT(SUCCEEDED(hr));

    DWORD dwRpcCancelTimeoutInSec = m_dwRpcCancelTimeout /1000;

    HANDLE hEvents[2];
    hEvents[0] = m_hTerminateThreadEvent;
    hEvents[1] = m_hRpcPendingEvent;
    DWORD dwTimeout = INFINITE;

    m_fThreadIntializationComplete = true;
    for (;;)
    {
        DWORD res = WaitForMultipleObjects(
                        2,
                        hEvents,
                        FALSE,  // wait for any event
                        dwTimeout
                        );
        if ( res == WAIT_OBJECT_0)
        {
            //
            // dec reference to CoInitialize
            //
            CoUninitialize();
			ASSERT(m_hModule != NULL);
			m_fThreadIntializationComplete = false;
            FreeLibraryAndExitThread(m_hModule,0);
            ASSERT(("this line should not be reached!", 0));
        }
        if ( res == WAIT_OBJECT_0+1)
        {
            dwTimeout = m_dwRpcCancelTimeout;
            continue;
        }

        ASSERT(("event[s] abandoned", WAIT_TIMEOUT == res));

        //
        // Timeout. Check for pending RPC.
        //
        if (m_mapOutgoingRpcRequestThreads.IsEmpty())
        {
            //
            // No pending RPC, back to wait state
            //
            dwTimeout = INFINITE;
            continue;
        }

        //
        //  Check to see if there are outgoing calles issued
        //  more than m_dwRpcCancelTimeout ago
        //
        CancelRequests( time( NULL) - dwRpcCancelTimeoutInSec);
    }

}//CCancelRpc::ProcessEvents

void
CCancelRpc::Add(
                IN HANDLE hThread,
                IN time_t	timeCallIssued
                )
{
	CS lock(m_cs);

    BOOL bWasEmpty = m_mapOutgoingRpcRequestThreads.IsEmpty();

	m_mapOutgoingRpcRequestThreads[hThread] = timeCallIssued;

    if (bWasEmpty)
    {
        VERIFY(PulseEvent(m_hRpcPendingEvent));
    }
}


void
CCancelRpc::Remove(
    IN HANDLE hThread
    )
{
	CS lock(m_cs);

	m_mapOutgoingRpcRequestThreads.RemoveKey( hThread);

}


void
CCancelRpc::CancelRequests(
    IN time_t timeIssuedBefore
    )
{
	CS lock(m_cs);
	time_t	timeRequest;
	HANDLE	hThread;

    POSITION pos;
    pos = m_mapOutgoingRpcRequestThreads.GetStartPosition();
    while(pos != NULL)
    {
		m_mapOutgoingRpcRequestThreads.GetNextAssoc(pos,
											hThread, timeRequest);
		if ( timeRequest < timeIssuedBefore)
		{
			//
			//	The request is outgoing more than the desired time,
			//	cancel it
			//
			RPC_STATUS status;
			status = RpcCancelThread( hThread);
			ASSERT( status == RPC_S_OK);

			//
			// Get it out of the map
            // (calling Remove() again for this thread is no-op)
            //
            Remove(hThread);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\psecutil.h ===
//
// psecutil.h
//
// Private security stuff for MQUTIL.DLL
//

HRESULT InitServerSecurity(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\mqutil\register.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
        register.c

Abstract:
        handle registery

Autor:
        Uri Habusha

--*/


//
// NOTE: registry routines in mqutil do not provide
// thread or other synchronization. If you change
// implementation here, carefully verify that
// registry routines in mqutil's clients are not
// broken, especially the wrapper routines in
// mqclus.dll  (ShaiK, 19-Apr-1999)
//


#include "stdh.h"
#include <autorel.h>
#include <uniansi.h>

#include "register.tmh"

void AFXAPI DestructElements(HKEY *phKey, int nCount)
{
    for (; nCount--; phKey++)
    {
        RegCloseKey(*phKey);
    }
}

TCHAR g_tRegKeyName[ 256 ] = {0} ;
BOOL  g_fIniFileExist = FALSE ;
CAutoCloseRegHandle g_hKeyFalcon = NULL ;
static CMap<LPCWSTR, LPCWSTR, HKEY, HKEY&> s_MapName2Handle;
static CCriticalSection s_csMapName2Handle(CCriticalSection::xAllocateSpinCount);

static CCriticalSection s_critRegistry;

// publishes the CS for QM usage
MQUTIL_EXPORT CCriticalSection *GetRegCS()
{
    return &s_critRegistry;
}


/*====================================================

CompareElements  of LPCTSTR

Arguments:

Return Value:

=====================================================*/

BOOL AFXAPI CompareElements(const LPCTSTR* MapName1, const L