rs[1].X;
    corners[3].Y = corners[0].Y;

    xForm.Transform(&corners[0], 4);

    GpPointF topLeft, bottomRight;
    topLeft.X = min(min(corners[0].X, corners[1].X), min(corners[2].X, corners[3].X));
    topLeft.Y = min(min(corners[0].Y, corners[1].Y), min(corners[2].Y, corners[3].Y));
    bottomRight.X = max(max(corners[0].X, corners[1].X), max(corners[2].X, corners[3].X));
    bottomRight.Y = max(max(corners[0].Y, corners[1].Y), max(corners[2].Y, corners[3].Y));

    // Use same rounding convention as DpDriver::DrawImage
    GpRect boundsCap;

    boundsCap.X = GpFix4Ceiling(GpRealToFix4(topLeft.X));
    boundsCap.Y = GpFix4Ceiling(GpRealToFix4(topLeft.Y));
    boundsCap.Width = GpFix4Ceiling(GpRealToFix4(bottomRight.X)) - boundsCap.X;
    boundsCap.Height = GpFix4Ceiling(GpRealToFix4(bottomRight.Y)) - boundsCap.Y;

    // DrawBounds in device space
    GpRect boundsDev(boundsCap.X * ScaleX,
                     boundsCap.Y * ScaleY,
                     boundsCap.Width * ScaleX,
                     boundsCap.Height * ScaleY);

    SetupPrintBanding(context, &boundsCap, &boundsDev);

    // Setup outline path for clipping in world space
    PointF clipPoints[4];
    BYTE clipTypes[4] = {
        PathPointTypeStart,
        PathPointTypeLine,
        PathPointTypeLine,
        PathPointTypeLine | PathPointTypeCloseSubpath
    };

    clipPoints[0] = dstPoints[0];
    clipPoints[1] = dstPoints[1];
    clipPoints[3] = dstPoints[2];

    clipPoints[2].X = clipPoints[1].X + (clipPoints[3].X - clipPoints[0].X);
    clipPoints[2].Y = clipPoints[1].Y + (clipPoints[3].Y - clipPoints[0].Y);

    GpPath clipPath(&clipPoints[0],
                    &clipTypes[0],
                    4,
                    FillModeWinding);

    HDC hdc = NULL;

    if (clipPath.IsValid())
    {
        hdc = context->GetHdc(dstSurface);
    }

    if (hdc != NULL)
    {
        status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                            &BandBoundsDev,
                                            options,
                                            ScaleX,
                                            ScaleY);
        if (status == Ok)
        {
            BOOL isClip = FALSE;
            BOOL usePathClipping = FALSE;

            // Set the visible clip unless it is captured in our mask
            if (SetVisibleClip)
            {
                DriverPrint::SetupClipping(hdc,
                                           context,
                                           drawBounds,
                                           isClip,
                                           usePathClipping,
                                           FALSE);
            }

            ASSERT(NumBands > 0);
            for (Band = 0; Band<NumBands; Band++)
            {
                // Render a square rectangle without any clipping
               scanPrint->SetRenderMode(FALSE, &BandBoundsCap);
               context->InverseOk = FALSE;
               context->WorldToDevice.SetMatrix(&w2dCap[0]);
               context->VisibleClip.DisableComplexClipping(BandBoundsCap);

               status = DpDriver::DrawImage(context, srcSurface, dstSurface,
                                            &boundsCap, imageAttributes, numPoints,
                                            dstPoints, srcRect, flags);

               context->InverseOk = FALSE;
               context->WorldToDevice.SetMatrix(&w2dDev[0]);
               context->VisibleClip.ReEnableComplexClipping();

               if (status != Ok)
                   break;

               if (options & ScanDeviceFlags)
               {
                   context->VisibleClip.SetBandBounds(BandBoundsDev);

                   // Render the original path band at device DPI
                   // outputPath is already transformed into device space
                   scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                   status = DpDriver::DrawImage(context, srcSurface, dstSurface,
                                                &boundsDev, imageAttributes, numPoints,
                                                dstPoints, srcRect, flags);
               }

               if (status == Ok)
               {
                   status = OutputBufferDIB(hdc,
                                            context,
                                            dstSurface,
                                            &BandBoundsCap,
                                            &BandBoundsDev,
                                            &clipPath);
                   if (status != Ok)
                       break;
               }
               else
                   break;

               BandBoundsCap.Y += BandHeightCap;
               BandBoundsDev.Y += BandHeightDev;

               // next band is last band
               if (Band == (NumBands - 2))
               {
#if 0
                   // only blit out the remaining part of draw bounds
                   BandBoundsCap.Height = boundsCap.Y + boundsCap.Height - BandBoundsCap.Y - 1;
                   BandBoundsDev.Height = boundsDev.Y + boundsDev.Height - BandBoundsDev.Y - 1;
                   ASSERT(BandBoundsCap.Height <= BandHeightCap);
                   ASSERT(BandBoundsDev.Height <= BandHeightDev);
                   ASSERT(BandBoundsCap.Height > 0);
                   ASSERT(BandBoundsDev.Height > 0);
#endif
               }
            }

            if (SetVisibleClip)
            {
                DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
            }

            scanPrint->DestroyBufferDIB();
        }

        context->ReleaseHdc(hdc);
    }
    else
    {
        context->InverseOk = FALSE;
        context->WorldToDevice.SetMatrix(&w2dDev[0]);
    }

    EndPrintBanding(context);

    ScaleX = oldScaleX;
    ScaleY = oldScaleY;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws text at a position.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] text       - the typeset text to be drawn
*   [IN] font       - the font to use
*   [IN] fgBrush    - the brush to use for the text
*   [IN] bgBrush    - the brush to use for the background (default = NULL)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   5/22/2k ericvan
*
\**************************************************************************/

GpStatus
DriverPrint::DrawGlyphs
(
    DrawGlyphData *drawGlyphData
)
{
    GpStatus status = GenericError;

    //  Choose appropriate brush behaviour
    switch(drawGlyphData->brush->Type)
    {
    case BrushTypeSolidColor:
        // pass bitmap GlyphPos to SolidText API
        status = SolidText(drawGlyphData->context,
                           drawGlyphData->surface,
                           drawGlyphData->drawBounds,
                           drawGlyphData->brush->SolidColor,
                           drawGlyphData->faceRealization,
                           drawGlyphData->glyphPos,
                           drawGlyphData->count,
                           drawGlyphData->glyphs,
                           drawGlyphData->glyphOrigins,
                           TextRenderingHintSingleBitPerPixelGridFit,
                           drawGlyphData->rightToLeft);
        break;

    case BrushTypeTextureFill:
    case BrushTypeHatchFill:
    case BrushTypePathGradient:
    case BrushTypeLinearGradient:
        // pass path GlyphPos to BrushText API if PostScript (for clipping)
        // otherwise pass bitmap GlyphPos to compose bitmaps
        status = BrushText(drawGlyphData->context,
                           drawGlyphData->surface,
                           drawGlyphData->drawBounds,
                           drawGlyphData->brush,
                           drawGlyphData->glyphPos,
                           drawGlyphData->glyphPathPos,
                           drawGlyphData->count,
                           TextRenderingHintSingleBitPerPixelGridFit);
        break;

    default:
        ASSERT(FALSE);          // Unknown brush type
        break;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Solid Text
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   12/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::SolidText(
        DpContext* context,
        DpBitmap* surface,
        const GpRect* drawBounds,
        GpColor color,
        const GpFaceRealization *faceRealization,
        const GpGlyphPos *glyphPos,
        INT count,
        const UINT16 *glyphs,
        const PointF *glyphOrigins,
        GpTextRenderingHint textMode,
        BOOL rightToLeft
        )
{
    ASSERT(textMode == TextRenderingHintSingleBitPerPixelGridFit);

    GpStatus status = GenericError;

    IsSolid = TRUE;
    SolidColor = color.ToCOLORREF();

    IsOpaque = color.IsOpaque() ||
               (context->CompositingMode == CompositingModeSourceCopy);

    Is01Bitmap = FALSE;

    INT angle;  // Passed from GetTextOutputHdc to GdiText

    HDC gdiHdc = NULL;

    // Try punt to GDI.
    gdiHdc = context->GetTextOutputHdc(faceRealization,
                                       color,
                                       surface,
                                       &angle);

    GpMatrix savedmatrix;
    BOOL AdjustWorldTransform = FALSE;

    if (gdiHdc)
    {
        BOOL isClip;
        BOOL usePathClipping = FALSE;

        BOOL bUseClipEscapes;

        // Win9x and ME PS driver on HP's printer there is a bug to cause
        // we need to use GDI clip region to set up the clip path
        if (DriverType == DriverPostscript)
        {
            if (!Globals::IsNt)
            {
                bUseClipEscapes = UseClipEscapes;
                UseClipEscapes = FALSE;
            }

            if (PostscriptScalerX != 1 || PostscriptScalerY != 1)
            {
                AdjustWorldTransform = TRUE;
                savedmatrix = context->WorldToDevice;
            }
        }

        DriverPrint::SetupClipping(gdiHdc,
                                   context,
                                   drawBounds,
                                   isClip,
                                   usePathClipping,
                                   FALSE);

        status = DpDriver::GdiText(gdiHdc,
                                   angle,
                                   glyphs,
                                   glyphOrigins,
                                   count,
                                   rightToLeft);

        DriverPrint::RestoreClipping(gdiHdc, isClip, usePathClipping);

        if (DriverType == DriverPostscript && !Globals::IsNt)
            UseClipEscapes = bUseClipEscapes;

        context->ReleaseTextOutputHdc(gdiHdc);

        if (status == Ok)
        {
            return Ok;
        }
    }

    EpScanDIB *scanPrint = (EpScanDIB*) surface->Scan;

    // only used for computing band sizes
    GpRect boundsCap(drawBounds->X, drawBounds->Y,
                     drawBounds->Width, drawBounds->Height);
    GpRect boundsDev = *drawBounds;

    if (AdjustWorldTransform)
    {
        boundsDev.X = GpCeiling((REAL)boundsDev.X / PostscriptScalerX);
        boundsDev.Y = GpCeiling((REAL)boundsDev.Y / PostscriptScalerY);
        boundsDev.Width = GpCeiling((REAL)boundsDev.Width / PostscriptScalerX);
        boundsDev.Height = GpCeiling((REAL)boundsDev.Height / PostscriptScalerY);
        context->WorldToDevice.Scale(1.0f/PostscriptScalerX,
            1.0f/PostscriptScalerY,
            MatrixOrderAppend);
    }

    SetupPrintBanding(context, &boundsCap, &boundsDev);

    DWORD options;

    // works for DriverPCL and DriverPostscript
    if (IsOpaque)
    {
        options = ScanDeviceBounds;
    }
    else
    {
        options = ScanDeviceBounds | ScanDeviceAlpha;
    }

    HDC hdc = context->GetHdc(surface);

    if (hdc != NULL)
    {
        status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                            &BandBoundsDev,
                                            options,
                                            ScaleX,
                                            ScaleY);

        if (status == Ok)
        {
            ASSERT(NumBands > 0);
            for (Band = 0; Band<NumBands; Band++)
            {
                context->VisibleClip.SetBandBounds(BandBoundsDev);

                // Render the solid text at device DPI, this generates
                // an alpha channel with only the alpha bits.

                scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                status = DpDriver::SolidText(context, surface, &boundsDev,
                                             color, glyphPos, count,
                                             TextRenderingHintSingleBitPerPixelGridFit,
                                             rightToLeft);
                if (status == Ok)
                {
                    // Don't set clip path here since it is captured in the mask
                    status = OutputBufferDIB(hdc,
                                             context,
                                             surface,
                                             &BandBoundsCap,
                                             &BandBoundsDev,
                                             NULL);
                    if (status != Ok)
                        break;
                }
                else
                    break;

                BandBoundsCap.Y += BandHeightCap;
                BandBoundsDev.Y += BandHeightDev;

     #if 0
                // next band is last band
                if (Band == (NumBands - 2))
                {
                    // only blit out the remaining part of draw bounds
                    BandBoundsCap.Height = boundsCap.Y + boundsCap.Height - BandBoundsCap.Y - 1;
                    BandBoundsDev.Height = boundsDev.Y + boundsDev.Height - BandBoundsDev.Y - 1;
                    ASSERT(BandBoundsCap.Height <= BandHeightCap);
                    ASSERT(BandBoundsDev.Height <= BandHeightDev);
                }
     #endif
            }
            scanPrint->DestroyBufferDIB();
        }

        context->ReleaseHdc(hdc);
    }

    EndPrintBanding(context);

    if (AdjustWorldTransform)
    {
        context->InverseOk = FALSE;
        context->WorldToDevice = savedmatrix;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Brush Text
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::BrushText(
        DpContext*          context,
        DpBitmap*           surface,
        const GpRect*       drawBounds,
        const DpBrush*      brush,
        const GpGlyphPos*   glyphPos,
        const GpGlyphPos*   glyphPathPos,
        INT                 count,
        GpTextRenderingHint textMode
        )
{
   ASSERT(textMode == TextRenderingHintSingleBitPerPixelGridFit);

   // !! Perf. Do context->GetHdc() once at beginning and then not again.

   if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
       return Ok;

   INT oldScaleX = -1;
   INT oldScaleY = -1;

   Is01Bitmap = FALSE;

   GpStatus status = GenericError;

   BOOL SetVisibleClip;
   DWORD options;

   switch (DriverType)
   {
   case DriverPCL:
       SetVisibleClip = FALSE;
       // to ensure we always use mask (XOR-AND-XOR) on PCL, we set ScanDeviceAlpha

       options = ScanCappedBounds | ScanDeviceBounds | ScanDeviceAlpha;

       IsOpaque = FALSE;

       break;

   case DriverPostscript:
      SetVisibleClip = TRUE;
      options = ScanCappedBounds | ScanDeviceZeroOut;
      if (!IsOpaque)
      {
          IsOpaque = TRUE;
      //    options |= ScanCappedOver;
      }
      break;

   default:
       ASSERT(FALSE);
       status = NotImplemented;
       goto Exit;
   }

   {
       EpScanDIB *scanPrint = (EpScanDIB*) surface->Scan;
       REAL w2dDev[6];
       REAL w2dCap[6];

       // To avoid round off errors causing
       GpRect roundedBounds;

       if ((ScaleX == 1) && (ScaleY == 1))
       {
           roundedBounds.X = drawBounds->X;
           roundedBounds.Y = drawBounds->Y;
           roundedBounds.Width = drawBounds->Width;
           roundedBounds.Height = drawBounds->Height;
       }
       else
       {
           // round X,Y to multiple of ScaleX,Y
           roundedBounds.X = (drawBounds->X / ScaleX) * ScaleX;
           roundedBounds.Y = (drawBounds->Y / ScaleY) * ScaleY;

           // adjust width and height to compensate for smaller X,Y.
           roundedBounds.Width = drawBounds->Width + (drawBounds->X % ScaleX);
           roundedBounds.Height = drawBounds->Height + (drawBounds->Y % ScaleY);

           // round width, height to multiple of ScaleX,Y
           roundedBounds.Width += (ScaleX - (roundedBounds.Width % ScaleX));
           roundedBounds.Height += (ScaleY - (roundedBounds.Height % ScaleY));
       }

       // DrawBounds in Capped Space
       GpRect boundsCap(roundedBounds.X / ScaleX,
                        roundedBounds.Y / ScaleY,
                        roundedBounds.Width / ScaleX,
                        roundedBounds.Height / ScaleY);

       if (boundsCap.Width == 0 || boundsCap.Height == 0)
       {
            oldScaleX = ScaleX;
            oldScaleY = ScaleY;

            ScaleX = 1;
            ScaleY = 1;

            boundsCap.X = roundedBounds.X;
            boundsCap.Y = roundedBounds.Y;
            boundsCap.Width = roundedBounds.Width;
            boundsCap.Height = roundedBounds.Height;
       }

       // DrawBounds in Device Space
       GpRect& boundsDev = roundedBounds;

       // Infer a rectangle in world space which under the w2dCap transform
       // covers our bounding box.

       GpPointF dstPts[4];

       dstPts[0].X = TOREAL(roundedBounds.X);
       dstPts[0].Y = TOREAL(roundedBounds.Y);
       dstPts[1].X = TOREAL(roundedBounds.X + roundedBounds.Width);
       dstPts[1].Y = TOREAL(roundedBounds.Y);
       dstPts[2].X = TOREAL(roundedBounds.X);
       dstPts[2].Y = TOREAL(roundedBounds.Y + roundedBounds.Height);
       dstPts[3].X = TOREAL(roundedBounds.X + roundedBounds.Width);
       dstPts[3].Y = TOREAL(roundedBounds.Y + roundedBounds.Height);

       GpMatrix matrix;
       context->GetDeviceToWorld(&matrix);
       matrix.Transform(&dstPts[0], 4);

       GpRectF rectCap;
       rectCap.X = min(min(dstPts[0].X, dstPts[1].X),
                       min(dstPts[2].X, dstPts[3].X));
       rectCap.Y = min(min(dstPts[0].Y, dstPts[1].Y),
                       min(dstPts[2].Y, dstPts[3].Y));
       rectCap.Width = max(max(dstPts[0].X, dstPts[1].X),
                           max(dstPts[2].X, dstPts[3].X)) - rectCap.X;
       rectCap.Height = max(max(dstPts[0].Y, dstPts[1].Y),
                            max(dstPts[2].Y, dstPts[3].Y)) - rectCap.Y;

       SetupPrintBanding(context, &boundsCap, &boundsDev);

       context->WorldToDevice.GetMatrix(&w2dDev[0]);
       context->WorldToDevice.Scale(1.0f/TOREAL(ScaleX),
                                    1.0f/TOREAL(ScaleY),
                                    MatrixOrderAppend);
       context->WorldToDevice.GetMatrix(&w2dCap[0]);
       context->InverseOk = FALSE;

       HDC hdc = context->GetHdc(surface);;

       if (hdc != NULL)
       {
           status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                               &BandBoundsDev,
                                               options,
                                               ScaleX,
                                               ScaleY);

           GlyphClipping = FALSE;
           if (status == Ok)
           {
               BOOL isClip = FALSE;
               BOOL usePathClipping = FALSE;

               // Set the visible clip unless it is captured in our mask
               if (SetVisibleClip)
               {
                   DriverPrint::SetupClipping(hdc, context, drawBounds,
                                              isClip, usePathClipping, FALSE);
               }

               // !! This should be shifted into postscript driver
               if (DriverType == DriverPostscript)
               {
                   DriverPrint::SetupGlyphPathClipping(hdc,
                                                       context,
                                                       glyphPathPos,
                                                       count);
               }

               ASSERT(NumBands > 0);
               for (Band = 0; Band<NumBands; Band++)
               {
                   // Render a square rectangle without any clipping
                   scanPrint->SetRenderMode(FALSE, &BandBoundsCap);
                   context->InverseOk = FALSE;
                   context->WorldToDevice.SetMatrix(&w2dCap[0]);
                   context->VisibleClip.DisableComplexClipping(BandBoundsCap);

                   status = DpDriver::FillRects(context,
                                                surface,
                                                &boundsCap,
                                                1,
                                                &rectCap,
                                                brush);

                   context->InverseOk = FALSE;
                   context->WorldToDevice.SetMatrix(&w2dDev[0]);
                   context->VisibleClip.ReEnableComplexClipping();

                   if (status != Ok)
                       break;

                   context->VisibleClip.SetBandBounds(BandBoundsDev);

                   // Render the original path band at device DPI
                   scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                   status = DpDriver::BrushText(context, surface, &boundsDev,
                                                brush, glyphPos, count,
                                                TextRenderingHintSingleBitPerPixelGridFit);

                   if (status == Ok)
                   {
                       status = OutputBufferDIB(hdc,
                                                context,
                                                surface,
                                                &BandBoundsCap,
                                                &BandBoundsDev,
                                                NULL);

                       if (status != Ok)
                           break;
                   }

                   BandBoundsCap.Y += BandHeightCap;
                   BandBoundsDev.Y += BandHeightDev;

#if 0
                   // next band is last band
                   if (Band == (NumBands - 2))
                   {
                       // only blit out the remaining part of draw bounds
                      BandBoundsCap.Height = boundsCap.Y + boundsCap.Height - BandBoundsCap.Y - 1;
                      BandBoundsDev.Height = boundsDev.Y + boundsDev.Height - BandBoundsDev.Y - 1;
                      ASSERT(BandBoundsCap.Height <= BandHeightCap);
                      ASSERT(BandBoundsDev.Height <= BandHeightDev);
                   }
#endif
               }

               // End scope of clipping for individual glyph characters
               if ((DriverType == DriverPostscript) &&
                   (GlyphClipping))
               {
                   DriverPrint::RestoreEscapeClipping(hdc);
               }

               if (SetVisibleClip)
               {
                   DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
               }

               scanPrint->DestroyBufferDIB();
           }

           context->ReleaseHdc(hdc);
       }
       else
       {
           context->InverseOk = FALSE;
           context->WorldToDevice.SetMatrix(&w2dDev[0]);
       }

       EndPrintBanding(context);
   }

Exit:

   if (oldScaleX != -1)
   {
       ScaleX = oldScaleX;
       ScaleY = oldScaleY;
   }

   RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\dppath.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpPath.cpp
*
* Abstract:
*
*   DpPath engine function implementation
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Create a widen path from an existing path, pen and context.  The context
*   provides the world to transform matrix, and surface dpiX, dpiY
*
* Arguments:
*
*   path, context, pen
*
* Return Value:
*
*   DpPath* - widened path
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/
DpPath*
GpPath::DriverCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen,
    DpContext* context,
    BOOL removeSelfIntersect,
    BOOL regionToPath
    )
{
    const GpPath* gpPath = GpPath::GetPath(path);
    const GpPen* gpPen = GpPen::GetPen(pen);
    
    ASSERT(gpPath->IsValid());
    ASSERT(gpPen->IsValid());
    
    GpPath* widenPath;
    
    GpMatrix IdMatrix;
    
    // We don't flatten by default.  Depending on the device, it may be
    // more efficient to send bezier paths (postscript for instance).
    
    DWORD widenFlags = WidenDontFlatten;
    
    if(removeSelfIntersect)
    {
         widenFlags |= WidenRemoveSelfIntersects;
    }
    
    if(!regionToPath)
    {
         widenFlags |= WidenEmitDoubleInset;
    }
    
    widenPath = gpPath->GetWidenedPath(
        gpPen,
        context ? 
          &(context->WorldToDevice) : 
          &IdMatrix,
        context->GetDpiX(),
        context->GetDpiY(),
        widenFlags
    );
    
    if (widenPath)
       return (DpPath*) widenPath;
    else
       return NULL;
}

VOID
GpPath::DriverDeletePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    delete gpPath;
}

DpPath*
GpPath::DriverClonePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    return (DpPath*)(gpPath->Clone());
}

VOID
GpPath::DriverTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    gpPath->Transform(matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\dppath.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpPath
*
* Abstract:
*
*   A DDI-level path object. Corresponds to a GpPath object.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPPATH_HPP
#define _DPPATH_HPP

//--------------------------------------------------------------------------
// Represent a path
//--------------------------------------------------------------------------

enum WidenFlags
{
    WidenIsAntiAliased          = 0x00000001,
    WidenDontFlatten            = 0x00000002,
    WidenRemoveSelfIntersects   = 0x00000004,
    WidenEmitDoubleInset        = 0x00000008,  // disable region to path
};

class DpPath : public GpObject
{
public:

    enum DpPathFlags        // !!! Rename and move?
    {
        PossiblyNonConvex   = 0x00,
        Convex              = 0x01,
        ConvexRectangle     = 0x03      // Used for Rectangle and Oval.
    };

    ~DpPath() {}

    // Start/end a subpath

    virtual VOID StartFigure()
    {
        IsSubpathActive = FALSE;
        UpdateUid();
    }

    virtual GpStatus CloseFigure();
    virtual GpStatus CloseFigures();

    BOOL HasCurve() const
    {
        return HasBezier;
    }

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagPath);
    }

    BOOL IsConvex() const
    {
        return ((Flags & Convex) != 0);
    }

    INT GetSubpathCount() const
    {
        return SubpathCount;
    }

    virtual GpStatus Flatten(
                DynByteArray* flattenTypes,
                DynPointFArray* flattenPoints,
                const GpMatrix* matrix) const = 0;

    virtual const DpPath*
    GetFlattenedPath(
        GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL,
        BOOL isAntiAliased = TRUE,
        REAL dpiX = 0,
        REAL dpiY = 0,
        BOOL regionToPath = TRUE
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    
    VOID
    Offset(
        REAL dx,
        REAL dy
        );

    GpFillMode GetFillMode() const
    {
        return FillMode;
    }

    VOID SetFillMode(GpFillMode fillMode)
    {
        if (FillMode != fillMode)
        {
            FillMode = fillMode;
            UpdateUid();
        }
    }

    // Get path data

    INT GetPointCount() const
    {
        return Points.GetCount();
    }

    const GpPointF* GetPathPoints() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Points.GetDataBuffer();
    }

    const BYTE* GetPathTypes() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Types.GetDataBuffer();
    }

    static BOOL
    ValidatePathTypes(
        const BYTE* types,
        INT count,
        INT* subpathCount,
        BOOL* hasBezier
        );

    GpStatus GetPathData(GpPathData* pathData);

    GpStatus SetPathData(const GpPathData* pathData);

    virtual ObjectType GetObjectType() const { return ObjectTypePath; }
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual DpPath*
    CreateWidenedPath(
        const DpPen* pen,
        DpContext* context,
        BOOL removeSelfIntersect = FALSE,
        BOOL regionToPath = TRUE
        ) const
    {
        return DpcCreateWidenedPath(
            this, 
            pen, 
            context, 
            removeSelfIntersect,
            regionToPath
        );
    }

    virtual VOID
    DeletePath()
    {
        DpcDeletePath(this);
    }

    virtual DpPath*
    ClonePath()
    {
        return DpcClonePath(this);
    }

    virtual VOID
    Transform(
        GpMatrix* matrix
    )
    {
        DpcTransformPath(this, matrix);
    }
    
    // Debug only.
    
    #if DBG
    void DpPath::DisplayPath() {
        INT size = GetPointCount();
    
        const GpPointF *points = GetPathPoints();
        const BYTE *types = GetPathTypes();
    
        for(int i=0; i<size; i++)
        {
            if((types[i] & PathPointTypePathTypeMask) == PathPointTypeStart)
            {
                WARNING(("Move"));
            }
            if(types[i] & PathPointTypeCloseSubpath)
            {
                WARNING(("Close"));
            }
            WARNING(("points[%d].X = %ff;", i, points[i].X));
            WARNING(("points[%d].Y = %ff;", i, points[i].Y));
        }
    }
    #endif
    
    class SubpathInfo
    {
    public:
        INT StartIndex;
        INT Count;
        BOOL IsClosed;
    };

protected: // GDI+ INTERNAL

    DpPath()
    {
        InitDefaultState(FillModeAlternate);
        SetValid(TRUE);
    }

    DpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    DpPath(const DpPath *path);

    virtual VOID InitDefaultState(GpFillMode fillMode);

    virtual VOID GetSubpathInformation(
        DynArray<SubpathInfo> **info
    ) const = 0;

protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagPath : ObjectTagInvalid);
    }

protected:

    BOOL HasBezier;         // does path have Bezier segments?
    DynArrayIA<BYTE, 16> Types;
    DynArrayIA<GpPointF, 16> Points;
    GpFillMode FillMode;
    DpPathFlags Flags;
    BOOL IsSubpathActive;   // whether there is an active subpath
    INT SubpathCount;       // number of subpaths
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\dynarrayimpl.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This is the class which implements the dynamic array. 
*   It is used by the wrapper template classes DynArray and DynArrayIA.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*  + Fixed a problem in ShrinkToSize that caused elements to potentially
*    be lost.
*  8/16/2000 bhouse
*  + Changed cpacity growth to be exponential
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   DynArrayImpl constructor
*
* Arguments:
*
*   initialAllocation - initial allocation, or NULL
*   allocSize         - size of the initial allocation
*   count             - initial count
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/

DynArrayImpl::DynArrayImpl(
    void *initialAllocation, 
    UINT allocSize,
    UINT count
    )
{
    ASSERT((initialAllocation != NULL) || (allocSize == 0));
    ASSERT(count <= allocSize);

    DataBuffer = InitialAllocation = initialAllocation;
    Capacity = AllocSize = allocSize;
    Count = count;
}

/**************************************************************************\
*
* Function Description:
*
*   Shrink the buffer so that it is just big enough for the items
*   the dynamic array holds.
*
* Arguments:
*
*   eltSize - size of each array element
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/18/1999 agodfrey
*     Added code to reuse the initial allocation.
*
\**************************************************************************/

VOID DynArrayImpl::ShrinkToSize(UINT eltSize) 
{
    ASSERT(Count <= Capacity);

    if (DataBuffer == InitialAllocation)
    {
        // Since we're shrinking, we know that the current data buffer
        // is big enough.
        
        return;
    }

    if (Count <= AllocSize)
    {
        // The buffer will fit into the initial allocation.

        GpMemcpy(InitialAllocation,DataBuffer,Count * eltSize);
        GpFree(DataBuffer);
        DataBuffer = InitialAllocation;
        Capacity = AllocSize;
        return;
    }

    // If we get here, we know that DataBuffer points to dynamic memory,
    // and that Count != 0.
    //
    // The second point is important because GpRealloc(x, 0) returns
    // a pointer to a valid zero-length buffer.

    void *newbuf = GpRealloc(DataBuffer, Count*eltSize);

    if (!newbuf)
    {
        // GpRealloc failed. Keep the current allocation
        
        WARNING(("ShrinkToSize: GpRealloc failed"));
        return;
    }

    DataBuffer = newbuf;
    Capacity = Count;
}

/**************************************************************************\
*
* Function Description:
*
*   Add space for new elements (if necessary). Does not update Count.
*
* Arguments:
*
*   eltSize     - size of each array element
*   newElements - the number of new elements
*   exactSize   - no exponential growth, just add required amount
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   1/18/1999 agodfrey
*
\**************************************************************************/

GpStatus DynArrayImpl::Grow(UINT eltSize, UINT newElements, BOOL exactSize)
{
    UINT newCount = Count + newElements;

    if (newCount <= Capacity)
    {
        return Ok;
    }

    UINT capacityIncrement = newCount - Capacity;
    
    if (!exactSize)
    {
        capacityIncrement = max(capacityIncrement,
                                min(max(Capacity, kMinCapacityGrowth),
                                    kMaxCapacityGrowth));
    };

    UINT newCapacity = Capacity + capacityIncrement;

    void *newbuf;

    if (DataBuffer == InitialAllocation)
    {
        // Do our first dynamic allocation

        newbuf = GpMalloc(newCapacity*eltSize);

        if (newbuf && Count)
        {
            GpMemcpy(newbuf, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        // Reallocate memory

        newbuf = GpRealloc(DataBuffer, newCapacity*eltSize);
    }

    if (!newbuf)
    {
        WARNING(("Grow: alloc failed"));

        // Aid in tracking down memory failure cases not handled properly
#if 0
        ASSERT(FALSE);
#endif
        return OutOfMemory;
    }

    Capacity = newCapacity;
    DataBuffer = newbuf;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Detach the data buffer from the dynamic array.
*   Cannot be used if there is an initial allocation.
*
* Return Value:
*
*   The data buffer
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::DetachData(UINT eltSize)
{
    if(DataBuffer == NULL) 
    {
        return NULL;
    }
    
    void *data = DataBuffer;
    
    if(DataBuffer == InitialAllocation)
    {
        data = GpMalloc(Count*eltSize);

        if (data)
        {
            GpMemcpy(data, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        DataBuffer = NULL;
        Capacity = 0;
    }
    
    Count = 0;
    
    return data;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultiple(UINT eltSize, UINT newElements)
{
    ASSERT(newElements>0);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    void *newSpace = static_cast<BYTE *>(DataBuffer) + Count * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultiple(
    UINT eltSize, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + Count * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements
    )
{
    ASSERT(newElements>0 && index<=Count);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    // NOTE: assume T is a shallow data type, i.e.
    //  it doesn't contain nested references.
    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        (Count - index) * eltSize
        );

    void *newSpace = static_cast<BYTE *>(DataBuffer) + index * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0 && index<=Count);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemmove(
            static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
            static_cast<BYTE *>(DataBuffer) + index * eltSize,
            (Count - index) * eltSize
            );
        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + index * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Deletes multiple items from the array starting at the index'th position.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to delete the elements.
*   numElements - number of elements to delete
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    

GpStatus DynArrayImpl::DeleteMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT numElements
    )
{
    ASSERT(numElements>0 && (index+numElements)<=Count);

    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        static_cast<BYTE *>(DataBuffer) + (index + numElements) * eltSize,
        (Count - (index + numElements)) * eltSize
        );
    Count -= numElements;

    ShrinkToSize(eltSize);

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\dynarrayimpl.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This class contains definitions of functions which can't (or shouldn't)
*   be inlined. We use a separate implementation class because this allows us
*   to avoid the code bloat template classes produce; every instance of the
*   DynArray template can use the same version of each out-of-line member.
*
*   The DynArray data members need to be declared here, because they are
*   used by DynArrayImpl.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*
*  8/16/2000 bhouse
*  + Changed to growth mechanics to be exponential
*
\**************************************************************************/

class DynArrayImpl
{
protected:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - initial number of elements

    DynArrayImpl(void *initialAllocation, UINT allocSize, UINT count = 0);
    
    // Shrink the buffer so that it is just big enough for the items
    // the dynamic array holds.

    VOID ShrinkToSize(UINT eltSize);
    
    // Add space for new elements (if necessary). Does not update Count.
    // eltSize           - size of each element
    // newElements       - number of new elements
    // exactSize         - no exponential growth

    GpStatus Grow(UINT eltSize, UINT newElements, BOOL exactSize = FALSE);

    // Add new, uninitialized elements, and return a pointer to them.
    // eltSize     - size of each element
    // newElements - number of new elements

    void *AddMultiple(UINT eltSize, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // eltSize     - size of each element
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    
    GpStatus AddMultiple(UINT eltSize, UINT newElements, const void *newData);
    
    // Add new, uninitialized elements, and return a pointer to them.
    // All data from index on is shift towards the end of the array to make room.
    // index       - index from which to insert the new elements.
    // eltSize     - size of each element
    // newElements - number of new elements
    // CAUTION! could cause a big performance hit if the array is large!

    void *AddMultipleAt(UINT eltSize, UINT index, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // All data from index on is shift towards the end of the array to make room.
    // eltSize     - size of each element
    // index       - index from which to insert the new elements.
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus AddMultipleAt(UINT eltSize, UINT index, UINT newElements, const void *newData);

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(UINT eltSize, UINT index, UINT numElements);
    
    // Detach the data buffer from the dynamic array.
    // Cannot be used if there is an initial allocation.

    void *DetachData(UINT eltSize);

    // Capacity, StepSize, AllocSize and Count are all measured in elements,
    // not bytes.

    enum {
        kMinCapacityGrowth = 16,
        kMaxCapacityGrowth = 8092
    };

    void *DataBuffer;
    void *InitialAllocation;
    UINT AllocSize;
    UINT Capacity;
    UINT Count;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\flatddi.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   flatddi.cpp
*
* Abstract:
*
*   Flat GDI+ DDI API wrappers
*
* Revision History:
*
*   1/14/2k ericvan
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

DpPath*
WINGDIPAPI
DpcCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen, 
    DpContext* context,
    BOOL removeSelfIntersect,
    BOOL regionToPath
    )
{
    ASSERT(path && pen);
    
    // context can be NULL
    return GpPath::DriverCreateWidenedPath(
        path, 
        pen, 
        context, 
        removeSelfIntersect,
        regionToPath
    );
}

VOID
WINGDIPAPI
DpcDeletePath(
    DpPath* path
    )
{
    ASSERT(path);
    
    GpPath::DriverDeletePath(path);
}

DpPath*
WINGDIPAPI
DpcClonePath(
    DpPath* path
    )
{
    ASSERT(path);

    return GpPath::DriverClonePath(path);
}

VOID
WINGDIPAPI
DpcTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    ASSERT(path);   // matrix can be NULL.

    GpPath::DriverTransformPath(path, matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\path.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   path.cpp
*
* Abstract:
*
*   Implementation of the GpPath and DpPath classes
*
* Revision History:
*
*   12/11/1998 davidx
*       Add path functions.
*
*   12/07/1998 davidx
*       Initial placeholders.
*
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// ReversePath(), CombinePaths(), CalculateGradientArray(), and
// GetMajorAndMinorAxis(), and GetFastAngle are defined in
// PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

BOOL IsRectanglePoints(const GpPointF* points, INT count);
VOID NormalizeAngle(REAL* angle, REAL width, REAL height);

INT NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    );

// Note that this is different from GpPathData.

class MetaPathData : public ObjectData
{
public:
    UINT32      Count;
    INT32       Flags;
};






/**************************************************************************\
*
* Function Description:
*
*   This reverses the path data.
*
* Arguments:
*
*   [IN] count - the number of points.
*   [IN/OUT] points - the data points to be reversed.
*   [IN/OUT] types - the data types to be reversed.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
ReversePath(
    INT count,
    GpPointF* points,
    BYTE* types
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    INT startIndex, endIndex;
    BOOL isClosed;
    BOOL isStartDashMode, isEndDashMode;
    BOOL wasMarkerEnd = FALSE;

    INT i;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
    {
        if((types[startIndex] & PathPointTypeDashMode) != 0)
            isStartDashMode = TRUE;
        else
            isStartDashMode = FALSE;
        if((types[endIndex] & PathPointTypeDashMode) != 0)
            isEndDashMode = TRUE;
        else
            isEndDashMode = FALSE;

        BOOL isMarkerEnd
            = (types[endIndex] & PathPointTypePathMarker) != 0;

        BYTE startType = types[startIndex]; // Save the first type.

        // Shift type points.

        for(i = startIndex + 1; i <= endIndex; i++)
        {
            types[i - 1] = types[i];
        }

        // Clear the close subpapth flag for original type (now at endIndex - 1).

        if(endIndex > 0)
            types[endIndex - 1] &= ~PathPointTypeCloseSubpath;
        
        types[endIndex] = PathPointTypeStart;

        if(isStartDashMode)
            types[startIndex] |= PathPointTypeDashMode;
        else
            types[startIndex] &= ~PathPointTypeDashMode;

        if(isEndDashMode)
            types[endIndex] |= PathPointTypeDashMode;
        else
            types[endIndex] &= ~PathPointTypeDashMode;

        // Add the dash and close flag.

        if(isClosed)
            types[startIndex] |= PathPointTypeCloseSubpath;
        else
            types[startIndex] &= ~PathPointTypeCloseSubpath;

        // Shift the marker flag by 1 from the original position.
        // This means we have to shift by 2 since the types array
        // was shifted by -1.

        for(i = endIndex; i >= startIndex + 2; i--)
        {
            if(types[i - 2] & PathPointTypePathMarker)
                types[i] |= PathPointTypePathMarker;
            else
                types[i] &= ~PathPointTypePathMarker;
        }
        
        // Shift Marker flag from the startIndex.

        if(startType & PathPointTypePathMarker)
            types[startIndex + 1] |= PathPointTypePathMarker;
        else
            types[startIndex + 1] &= ~PathPointTypePathMarker;
        
        // Shift Marker flag from the end of the previous subpath.

        if(wasMarkerEnd)
            types[startIndex] |= PathPointTypePathMarker;
        else
            types[startIndex] &= ~PathPointTypePathMarker;

        wasMarkerEnd = isMarkerEnd;

        // Keep the location of the internal flag.  So we must
        // shift back by 1.

        for(i = endIndex; i >= startIndex + 1; i--)
        {
            if(types[i - 1] & PathPointTypeInternalUse)
                types[i] |= PathPointTypeInternalUse;
            else
                types[i] &= ~PathPointTypeInternalUse;
        }
        if(startType & PathPointTypeInternalUse)
            types[startIndex] |= PathPointTypeInternalUse;
        else
            types[startIndex] &= ~PathPointTypeInternalUse;
    }

    // Reverse the points and types data.

    INT halfCount = count/2;
    for(i = 0; i < halfCount; i++)
    {
        GpPointF tempPt;
        BYTE tempType;

        tempPt = points[count - 1 - i];
        tempType = types[count - 1 - i];
        points[count - 1 - i] = points[i];
        types[count -1 - i] = types[i];
        points[i] = tempPt;
        types[i] = tempType;
    }       
    
#ifdef DEBUG_PATHWIDENER
    DpPathTypeIterator iter2(types, count);

    if(!iter2.IsValid())
    {
        WARNING(("ReversePath: failed."));
        return GenericError;
    }
#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This combines the two data points.  This is a general algorithm.
*   The output buffers (points and types) can be the same as the
*   first input buffers (points1 and types1).  In that case, both
*   buffers must be allocated at least to the array size of
*   count1 + count2.
*
* Arguments:
*
*   [IN] count - the allocated number of points (>= count1 + count2).
*   [OUT] points - the combined data points.
*   [OUT] types - the combined data types.
*   [IN] count1 - the number of points of the first path.
*   [IN] points1 - the first path points.
*   [IN] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*   [IN] connect - TRUE if the second line needs to be connected.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    )
{
    if(!points || !types || count < count1 + count2
        || count1 < 0 || !points1 || !types1
        || count2 < 0 || !points2 || !types2)
        return 0;
    
    // Check if the returning buffers are the same as the
    // first input buffers.

    INT resultCount = 0;
    if(points != points1 || types != types1)
    {
        if(points == points1 || types == types1)
        {
            // The both output buffer must be different.
            // If either of them is the same, don't combine
            // the path.

            return 0;
        }

        if(count1 > 0)
        {
            // Copy the first path.

            DpPathIterator iter1(points1, types1, count1);

            if(!iter1.IsValid())
                return 0;

            resultCount = iter1.Enumerate(points, types, count1);

            if(resultCount <= 0)
                return 0;
        }
    }
    else
    {
        // Both output buffers are the same as the first output
        // buffers.

        resultCount = count1;
    }

    GpStatus status = Ok;
    BOOL path1Closed;

    if(!forward1 && resultCount > 0)
    {
        status = ::ReversePath(resultCount, points, types);
        if(status != Ok)
            return 0;
    }

    if(count2 <= 0)
    {
        // No need to add the second path.

        return resultCount;
    }

    // Regard the empty path as a closed path.

    path1Closed = TRUE;

    if(resultCount > 0)
    {
        // Check the last point of path1.

        if((types[resultCount - 1] & PathPointTypeCloseSubpath))
            path1Closed = TRUE;
        else
            path1Closed = FALSE;
    }

    INT totalCount = 0;
    totalCount += resultCount;

    DpPathIterator iter2(points2, types2, count2);

    if(!iter2.IsValid())
        return 0;

    GpPointF* pts2 = points + resultCount;
    BYTE* typs2 = types + resultCount;

    resultCount = iter2.Enumerate(pts2, typs2, count2);

    if(resultCount <= 0)
        return 0;

    if(!forward2)
    {
        status = ::ReversePath(resultCount, pts2, typs2);
        if(status != Ok)
            return 0;
    }

    // Check if the first subpath of path2 is closed or not.

    BOOL path2Closed;

    DpPathTypeIterator iter3(typs2, resultCount);
    if(!iter3.IsValid())
        return 0;

    INT startIndex, endIndex;
    iter3.NextSubpath(&startIndex, &endIndex, &path2Closed);

    BYTE saveType= typs2[0];

    if(path1Closed || path2Closed)
    {
        typs2[0] = PathPointTypeStart |
            (saveType & ~PathPointTypePathTypeMask);
    }
    else
    {
        // Both paths are opened.

        if(connect)
        {
            typs2[0] = PathPointTypeLine |
                (saveType & ~PathPointTypePathTypeMask);

            // Check if the end point of path1 and the start point of path2
            // are the same.  If so, skip this point.

            if(REALABS(pts2[-1].X - pts2[0].X)
                + REALABS(pts2[-1].Y - pts2[0].Y) < POINTF_EPSILON)
            {
                for(INT i = 0; i < resultCount - 1; i++)
                {
                    pts2[i] = pts2[i + 1];
                    typs2[i] = typs2[i + 1];
                }
                resultCount--;
            }
        }
        else
        {
            typs2[0] = PathPointTypeStart |
                (saveType & ~PathPointTypePathTypeMask);
        }
    }

    totalCount += resultCount;

    return totalCount;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the unit gradient vectors of points as array of
*   (count + 1).  All the memories must be allocated and be checked
*   by the caller.
*
*   The first element of the gradient is from the end point to the
*   the start point.  If the end point is identical to the start point,
*   the previous point is used.
*   The last element of the gradient is from the start point to the end
*   point.  If the start point is identical to the end point, the next
*   point is used.
*   If distances array is not NULL, this returns the distance of each
*   segments.
*
* Arguments:
*
*   [OUT] grad - The gradient array of (count + 1) elements.
*   [OUT] distances - The distance array of (count + 1) elements or NULL.
*   [IN] points - The given points of count elements.
*   [IN] count - The number of given points.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    )
{
    GpPointF* grad1 = grad;
    REAL* distances1 = distances;
    const GpPointF* points1 = points;

    // Go to the starting point of this subpath.

    GpPointF startPt, endPt, lastPt, nextPt;

    startPt = *points1;

    INT i = count - 1;
    BOOL different = FALSE;
    points1 += i;   // Go to the end point.

    while(i > 0 && !different)
    {
        endPt = *points1--;

        if(endPt.X != startPt.X || endPt.Y != startPt.Y)
            different = TRUE;

        i--;
    }

    if(!different)
    {
        // All points are the same.

        WARNING(("Trying to calculate the gradients for degenerate points."));
        return GenericError;
    }

    points1 = points;
    lastPt = endPt;

    i = 0;

    while(i <= count)
    {
        REAL dx, dy, d;

        if(i < count)
            nextPt = *points1++;
        else
            nextPt = startPt;
        
        dx = nextPt.X - lastPt.X;
        dy = nextPt.Y - lastPt.Y;
        d = dx*dx + dy*dy;

        if(d > 0)
        {
            d = REALSQRT(d);
            dx /= d;
            dy /= d;
        }
        grad1->X = dx;
        grad1->Y = dy;

        // Record the distance only when the given distance array is not NULL.

        if(distances)
            *distances1++ = d;

        grad1++;
        lastPt = nextPt;
        i++;
    }

    // Make sure the last gradient is not 0.

    grad1 = grad + count;
    if(grad1->X == 0 && grad1->Y == 0)
    {
        // The start and end point are the same.  Find
        // the next non-zero gradient.

        i = 1;
        grad1 = grad + i;

        while(i < count)
        {
            if(grad1->X != 0 || grad1->Y != 0)
            {
                grad[count] = *grad1;

                if(distances)
                    distances[count] = distances[i];
                break;
            }
            i++;
            grad1++;
        }
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the path data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    INT                 flags      = pointData.GetFlags();

    if (FillMode == FillModeWinding)
    {
        flags |= GDIP_EPRFLAGS_WINDINGFILL;
    }

    MetaPathData    pathData;
    pathData.Count = count;
    pathData.Flags = flags;
    stream->Write(&pathData, sizeof(pathData), NULL);

    stream->Write(pointData.GetData(), pointsSize, NULL);
    stream->Write(Types.GetDataBuffer(), count, NULL);

    // align
    if ((count & 0x03) != 0)
    {
        INT     pad = 0;
        stream->Write(&pad, 4 - (count & 0x03), NULL);
    }

    return Ok;
}

UINT
DpPath::GetDataSize() const
{
    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    UINT                dataSize   = sizeof(MetaPathData) + pointsSize + count;

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the path object from memory.
*
* Arguments:
*
*   [IN] memory - the data that was read from the stream
*   [IN] size   - the size of the memory data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::SetData(
    const BYTE *    dataBuffer,
    UINT            size
    )
{
    Points.Reset();
    Types.Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size >= sizeof(MetaPathData))
    {
        const MetaPathData *    pathData = reinterpret_cast<const MetaPathData *>(dataBuffer);

        if (!pathData->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            return InvalidParameter;
        }

        InitDefaultState(::GetFillMode(pathData->Flags));
        SetValid(TRUE);

        INT     count = pathData->Count;

        if (count > 0)
        {
            UINT        pointDataSize;

            if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
            {
                pointDataSize = count * sizeof(GpPoint16);
            }
            else
            {
                pointDataSize = count * sizeof(GpPointF);
            }

            if (size >= sizeof(MetaPathData) + count + pointDataSize)
            {
                GpPointF *      points = Points.AddMultiple(count);
                BYTE *          types  = Types.AddMultiple(count);
                const BYTE *    typeData;
                const BYTE *    pointData = dataBuffer + sizeof(MetaPathData);

                if ((points != NULL) && (types != NULL))
                {
                    if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
                    {
                        BYTE *  tmp = NULL;

                        ::GetPointsForPlayback(
                                pointData,
                                size - (sizeof(MetaPathData) + count),
                                count,
                                pathData->Flags,
                                sizeof(GpPointF) * count,
                                (BYTE *)points,
                                tmp);
                        typeData = pointData + (count * 4);
                    }
                    else
                    {
                        GpMemcpy(points, pointData, count * sizeof(points[0]));
                        typeData = pointData + (count * sizeof(points[0]));
                    }
                    GpMemcpy(types, typeData, count);

                    if (ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
                    {
                        UpdateUid();
                        return Ok;
                    }
                }
            }
            else
            {
                WARNING(("size is too small"));
            }
        }
    }
    else
    {
        WARNING(("size is too small"));
    }

    SetValid(FALSE);
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a new GpPath object using the specified path data
*
* Arguments:
*
*   [IN] points - Point to an array of path points
*   [IN] types - Specify path point types
*   count - Number of path points
*   fillMode - Path fill mode
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpPath::GpPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    GpFillMode fillMode
    )
{
    SetValid(FALSE);

    // Validate function parameters

    if (count <= 0 ||
        (count > 0 && (!points || !types)) ||
        (fillMode != FillModeAlternate && fillMode != FillModeWinding))
    {
        WARNING(("Invalid path data in GpPath::GpPath"));
        return;
    }

    InitDefaultState(fillMode);

    // Validate path point types

    if (!ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
    {
        WARNING(("Invalid path type information"));
        return;
    }

    // Copy path point and type information

    SetValid(Types.AddMultiple(types, count) == Ok &&
             Points.AddMultiple(points, count) == Ok);

    if(IsValid()) {
        // Make sure the first point is the start type.

        Types.First() = PathPointTypeStart;
    }
}


//--------------------------------
// Constructor for polygon.
//--------------------------------

GpPath::GpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags flags
    ) : DpPath(points, count, stackPoints, stackTypes, stackCount,
            fillMode, flags)
{
    InvalidateCache();
}

//--------------------------------
// Copy constructor.
//--------------------------------

GpPath::GpPath(const GpPath* path) : DpPath(path)
{
    SetValid(path != NULL);

    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Copies the path data.  Points and Types array in pathData
*   must be allocated by the caller.
*
* Arguments:
*
*   [OUT] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::GetPathData(GpPathData* pathData)
{
    if ((!pathData) || (!pathData->Points) || (!pathData->Types) || (pathData->Count < 0))
        return InvalidParameter;

    INT count = GetPointCount();
    const GpPointF* points = GetPathPoints();
    const BYTE* types = GetPathTypes();

    if (pathData->Count >= count)
    {
        if (count > 0)
        {
            GpMemcpy(pathData->Points, points, count*sizeof(GpPointF));
            GpMemcpy(pathData->Types, types, count);
        }

        pathData->Count = count;
        return Ok;
    }
    else
        return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Set a marker at the current location.  You cannot set a marker at the
*   first position.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::SetMarker()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    // Don't set a marker at the first point.

    if(count > 1 && types)
    {
        types[count - 1] |= PathPointTypePathMarker;
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Clears all the markers in the path.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::ClearMarkers()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    BOOL modified = FALSE;

    if(count > 0 && types)
    {
        for(INT i = 0; i < count; i++)
        {
            if(types[i] & PathPointTypePathMarker)
            {
                types[i] &= ~PathPointTypePathMarker;
                modified = TRUE;
            }
        }
    }

    if(modified)
    {
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the path data.
*
* Arguments:
*
*   [IN] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::SetPathData(const GpPathData* pathData)
{
    if(!pathData || pathData->Count <= 0)
        return InvalidParameter;

    INT count = pathData->Count;
    DpPathIterator iter(pathData->Points, pathData->Types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    Points.Reset(FALSE);
    Types.Reset(FALSE);

    GpPointF* points = Points.AddMultiple(count);
    BYTE* types = Types.AddMultiple(count);

    if(points && types)
    {
        INT number, startIndex, endIndex;
        BOOL isClosed = FALSE;

        while(number = iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpMemcpy(
                points,
                pathData->Points + startIndex,
                number*sizeof(GpPointF)
                );
            GpMemcpy(
                types,
                pathData->Types + startIndex,
                number
                );

            points += number;
            types += number;
       }

        SetValid(TRUE);
        HasBezier = iter.HasCurve();
        Flags = PossiblyNonConvex;
        SubpathCount = iter.GetSubpathCount();
        IsSubpathActive = !isClosed;
        UpdateUid();
        return Ok;
    }
    else
        return OutOfMemory;
}

BOOL IsRectanglePoints(
    const GpPointF* points,
    INT count
    )
{
    if(count < 4 || count > 5)
        return FALSE;

    if(count == 5)
    {
        if(points[0].X != points[4].X || points[0].Y != points[4].Y)
            return FALSE;
    }

    if(
        ((points[1].X - points[0].X) != (points[2].X - points[3].X)) ||
        ((points[1].Y - points[0].Y) != (points[2].Y - points[3].Y)) ||
        ((points[2].X - points[1].X) != (points[3].X - points[0].X)) ||
        ((points[2].Y - points[1].Y) != (points[3].Y - points[3].Y))
        )
        return FALSE;
    else
        return TRUE;
}

BOOL
GpPath::IsRectangle() const
{
    if((SubpathCount != 1) || HasBezier)
        return FALSE;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();

    return IsRectanglePoints(points, count);
}


/**************************************************************************\
*
* Function Description:
*
*   Determine if the receiver and path represent the same path
*
* Arguments:
*
*   [IN] path - GpPath to compare
*
* Return Value:
*
*   TRUE if the paths are the same.
*
* Created - 5/27/99 peterost
*
\**************************************************************************/

BOOL GpPath::IsEqual(const GpPath* path) const
{
    if (path == this)
        return TRUE;

    INT    count;

    if (IsValid() == path->IsValid() &&
        (count=GetPointCount()) == path->GetPointCount() &&
        HasBezier == path->HasBezier &&
        FillMode == path->FillMode &&
        Flags == path->Flags &&
        IsSubpathActive == path->IsSubpathActive &&
        SubpathCount == path->SubpathCount)
    {
        BYTE*     types = path->Types.GetDataBuffer();
        BYTE*     mytypes = Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        GpPointF* mypoints = Points.GetDataBuffer();

        for (INT i=0; i<count; i++)
        {
            if (types[i] != mytypes[i] ||
                points[i].X != mypoints[i].X ||
                points[i].Y != mypoints[i].Y)
            {
                return FALSE;
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID
GpPath::InitDefaultState(
    GpFillMode fillMode
    )

{
    DpPath::InitDefaultState(fillMode);
    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Validate path point type information
*
* Arguments:
*
*   [IN] types - Point to an array of path point types
*   count - Number of points
*   subpathCount - Return the number of subpaths
*   hasBezier - Return whether the path has Bezier segments
*   [IN] needsFirstPointToBeStartPoint - TRUE if this data needs to start
*                                       with a StartPoint. (Default is TRUE)
*
* Return Value:
*
*   TRUE if the path point type information is valid
*   FALSE otherwise
*
\**************************************************************************/

BOOL
DpPath::ValidatePathTypes(
    const BYTE* types,
    INT count,
    INT* subpathCount,
    BOOL* hasBezier
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
    {
        WARNING(("Invalid path type information"));
        return FALSE;
    }

    *subpathCount = iter.GetSubpathCount();
    *hasBezier = iter.HasCurve();

    return iter.IsValid();
}

/**************************************************************************\
*
* Function Description:
*
*   Private helper function to add points to a path object
*
* Arguments:
*
*   [IN] points - Specify the points to be added
*   count - Number of points to add
*
* Return Value:
*
*   Point to location in the point type data buffer
*   that corresponds to the *SECOND* path point added.
*
*   The first point type is always handled inside this
*   function:
*
*   1. If either the previous subpath is closed, or addClosedFigure
*      parameter is TRUE, the first point type will be StartPoint.
*
*   2. Otherwise, the previous subpath is open and addClosedFigure
*      parameter is FALSE. We have two separate cases to handle:
*
*      2.1 if the first point to be added is the same as the last
*          point of the open subpath, then the first point is ignored.
*
*      2.2 otherwise, the first point type will be LinePoint.
*
*   NULL if there is an error. In this case, existing path
*   data is not affected.
*
* Note:
*
*   We assume the caller has already obtained a lock
*   on the path object.
*
\**************************************************************************/

BYTE*
GpPath::AddPointHelper(
    const GpPointF* points,
    INT count,
    BOOL addClosedFigure
    )
{
    // If we're adding a closed figure, then make sure
    // there is no more currently active subpath.

    if (addClosedFigure)
        StartFigure();

    INT origCount = GetPointCount();

    BOOL isDifferentPoint = TRUE;

    // Check if the first point is the same as the last point.

    if(IsSubpathActive && origCount > 0)
    {
        GpPointF lastPt = Points.Last();
        if ((REALABS(points->X - lastPt.X) < REAL_EPSILON) &&
            (REALABS(points->Y - lastPt.Y) < REAL_EPSILON) )
        {
            if(count == 1)
                return NULL;

            // case 2.1 above
            // Skip the first point and its type.

            count--;
            points++;
            isDifferentPoint = FALSE;
        }
    }

    // Resize Points and Types

    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if(pointbuf == NULL || typebuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return NULL;
    }

    // Record the type of the first point (Start or Line Point).

    if (!IsSubpathActive)
    {
        // case 1 above

        *typebuf++ = PathPointTypeStart;
        SubpathCount++; // Starting a new subpath.
    }
    else
    {
        // If the first point is different, add a Line type.
        // Otherwise, skip the first point and its type.

        if(isDifferentPoint)
        {
            // case 2.2 above

            *typebuf++ = PathPointTypeLine;
        }
    }

    // Copy path point data

    GpMemcpy(pointbuf, points, count*sizeof(GpPointF));

    // Subpath is active if the added figure is not closed.

    if(!addClosedFigure)
        IsSubpathActive = TRUE;

    // Return the starting location for the new point type data
    // From the second point type.

    return typebuf;
}


/**************************************************************************\
*
* Function Description:
*
*   Add a series of line segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify the line points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddLines(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    // Validate function parameters

    if (points == NULL || count < 1)
        return InvalidParameter;

    InvalidateCache();

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, FALSE);

    if (types == NULL)
    {
        if(count > 1)
            return OutOfMemory;
        else
            return Ok;
    }

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-1);
//    IsSubpathActive = TRUE;   This is set in AddPointHelper. - ikkof
    UpdateUid();

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Add rectangles to the current path object
*
* Arguments:
*
*   [IN] rects - Specify the rectangles to be added
*   count - Number of rectangles
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddRects(
    const GpRectF* rect,
    INT count
    )
{
    if (count < 1 || rect == NULL)
        return InvalidParameter;

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rect++)
    {
        if (rect->IsEmptyArea())
            continue;

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = rect->GetLeft();      // top-left
        points[0].Y = rect->GetTop();
        points[1].X = rect->GetRight();     // top-right
        points[1].Y = rect->GetTop();
        points[2].X = rect->GetRight();     // bottom-right
        points[2].Y = rect->GetBottom();
        points[3].X = rect->GetLeft();      // bottom-left
        points[3].Y = rect->GetBottom();

        if ((status = AddPolygon(points, 4)) != Ok)
            return status;
    }

    return Ok;
}

GpStatus
GpPath::AddRects(
    const RECT*     rects,
    INT             count
    )
{
    if ((count < 1) || (rects == NULL))
    {
        return InvalidParameter;
    }

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rects++)
    {
        if ((rects->left >= rects->right) || (rects->top >= rects->bottom))
        {
            continue;
        }

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = (REAL)rects->left;        // top-left
        points[0].Y = (REAL)rects->top;
        points[1].X = (REAL)rects->right;       // top-right
        points[1].Y = (REAL)rects->top;
        points[2].X = (REAL)rects->right;       // bottom-right
        points[2].Y = (REAL)rects->bottom;
        points[3].X = (REAL)rects->left;        // bottom-left
        points[3].Y = (REAL)rects->bottom;

        if ((status = AddPolygon(points, 4)) != Ok)
        {
            return status;
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add a polygon to the current path object
*
* Arguments:
*
*   [IN] Specify the polygon points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPolygon(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    if (count < 3 || points == NULL)
        return InvalidParameter;

    // Check if the last point is the same as the first point.
    // If so, ignore it.

    if (count > 3 &&
        points[0].X == points[count-1].X &&
        points[0].Y == points[count-1].Y)
    {
        count--;
    }

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, TRUE);

    if (types == NULL)
        return OutOfMemory;

    InvalidateCache();

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-2);
    types[count-2] = PathPointTypeLine | PathPointTypeCloseSubpath;

    UpdateUid();

    return Ok;
}


#define PI          TOREAL(3.1415926535897932)
#define HALF_PI     TOREAL(1.5707963267948966)


/**************************************************************************\
*
* Function Description:
*
*   Convert an angle defined in a box with (width, height) to
*   an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angle.
*
* Arguments:
*
*   [IN/OUT] angle - the angle is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   NONE
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
NormalizeAngle(REAL* angle, REAL width, REAL height)
{
    REAL a = *angle;

    // Set the angle between 0 and 360 degrees.

    a = GpModF(a, 360);

    if(a < 0 || a > 360)
    {
        // The input data may have been too large or loo small
        // to calculate the mode.  In that case, set to 0.

        a = 0;
    }

    if(width != height)
    {
        INT plane = 1;
        REAL b = a;

        if(a <= 90)
            plane = 1;
        else if(a <= 180)
        {
            plane = 2;
            b = 180 - a;
        }
        else if(a <= 270)
        {
            plane = 3;
            b = a - 180;
        }
        else
        {
            plane = 4;
            b = 360 - a;
        }

        b = b*PI/180;   // Convert to radian

        // Get the normalized angle in the plane 1.

        a = TOREAL( atan2(width*sin(b), height*cos(b)) );

        // Adjust to the angle in one of 4 planes.

        switch(plane)
        {
            case 1:
            default:
                break;

            case 2:
                a = PI - a;
                break;

            case 3:
                a = PI + a;
                break;

            case 4:
                a = 2*PI - a;
                break;
        }
    }
    else
    {
        a = a*PI/180;   // Convert to radian.
    }

    *angle = a;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert the start and sweep angles defined in a box with (width, height)
*   to an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angles.
*
* Arguments:
*
*   [IN/OUT] startAngle - it is given in degrees and return it in radian.
*   [IN/OUT] sweepAngle - it is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   INT - +1 if sweeping in clockwise and -1 in counterclockwise.
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    )
{
    REAL a0 = *startAngle;  // The start angle.
    REAL dA = *sweepAngle;
    REAL a1 = a0 + dA;      // The end angle.
    INT sweepSign;

    if(dA > 0)
        sweepSign = 1;
    else
    {
        sweepSign = - 1;
        dA = - dA;  // Convert to a positive sweep angle.
    }

    // Normalize the start and end angle.

    NormalizeAngle(&a0, width, height);
    NormalizeAngle(&a1, width, height);

    if(dA < 360)
    {
        if(sweepSign > 0)
        {
            dA = a1 - a0;
        }
        else
        {
            dA = a0 - a1;
        }
        if(dA < 0)
            dA += 2*PI;
    }
    else
        dA = 2*PI;  // Don't sweep more than once.

    *startAngle = a0;
    *sweepAngle = dA;

    return sweepSign;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert an elliptical arc to a series of Bezier curve segments
*
* Arguments:
*
*   points - Specify a point buffer for returning Bezier control points
*       The array should be able to hold 13 elements or more.
*   rect - Specify the bounding box for the ellipse
*   startAngle - Start angle (in elliptical space and degrees)
*   sweepAngle - Sweep angle
*       positive to sweep clockwise
*       negative to sweep counterclockwise
*
* Return Value:
*
*   Number of Bezier control points generated
*   0 if sweep angle is 0
*   -1 if bounding rectangle is empty
*
\**************************************************************************/

INT
GpPath::GetArcPoints(
    GpPointF* points,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    if (rect.IsEmptyArea())
        return -1;
    else if (sweepAngle == 0)
        return 0;

    // Determine which direction we should sweep
    // and clamp sweep angle to a max of 360 degrees
    // Both start and sweep angles are conveted to radian.

    INT sweepSign = NormalizeArcAngles(
        &startAngle,
        &sweepAngle,
        rect.Width,
        rect.Height);

    // Temporary variables

    REAL dx, dy;
    REAL w2, h2;

    w2 = rect.Width / 2;
    h2 = rect.Height / 2;
    dx = rect.X + w2;
    dy = rect.Y + h2;

    // Determine the number of Bezier segments needed

    int segments, count;
    GpMatrix m;

    segments = (INT) (sweepAngle / HALF_PI);

    if (segments*HALF_PI < sweepAngle)
        segments++;

    if (segments == 0)
        segments = 1;
    else if (segments > 4)
        segments = 4;

    count = segments*3 + 1;

    while (segments--)
    {
        // Compute the Bezier control points in unit-circle space

        REAL A, C, S;
        REAL x, y;

        A = (sweepAngle > HALF_PI) ? HALF_PI/2 : sweepAngle/2;
        C = REALCOS(A);
        S = REALSIN(A);

        x = (4 - C) / 3;
        y = (3 - C) * S / (3 + 3*C);

        if (sweepSign > 0)
        {
            // clockwise sweep

            points[0].X = C;
            points[0].Y = -S;
            points[1].X = x;
            points[1].Y = -y;
            points[2].X = x;
            points[2].Y = y;
            points[3].X = C;
            points[3].Y = S;
        }
        else
        {
            // counterclockwise sweep

            points[0].X = C;
            points[0].Y = S;
            points[1].X = x;
            points[1].Y = y;
            points[2].X = x;
            points[2].Y = -y;
            points[3].X = C;
            points[3].Y = -S;
        }

        // Transform the control points to elliptical space

        m.Reset();
        m.Translate(dx, dy);
        m.Scale(w2, h2);
        REAL theta = (startAngle + sweepSign*A)*180/PI;
        m.Rotate(theta);    // Rotate takes degrees.

        if(segments > 0)
            m.Transform(points, 3);
        else
            m.Transform(points, 4); // Include the last point.

        if(sweepSign > 0)
            startAngle += HALF_PI;
        else
            startAngle -= HALF_PI;
        sweepAngle -= HALF_PI;
        points += 3;
    }

    return count;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical arc to the current path object
*
* Arguments:
*
*   rect - Specify the bounding rectangle for the ellipse
*   startAngle - Starting angle for the arc
*   sweepAngle - Sweep angle for the arc
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddArc(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF points[13];
    INT count;
    BOOL isClosed = FALSE;

    if(sweepAngle >= 360)
    {
        sweepAngle = 360;
        isClosed = TRUE;
    }
    else if(sweepAngle <= - 360)
    {
        sweepAngle = - 360;
        isClosed = TRUE;
    }

    // Convert arc to Bezier curve segments

    count = GetArcPoints(points, rect, startAngle, sweepAngle);

    // Add resulting Bezier curve segment to the path

    GpStatus status = Ok;

    if(count > 0)
    {
        AddBeziers(points, count);
        if(isClosed)
            CloseFigure();
    }
    else if(count < 0)
        status = InvalidParameter;

    InvalidateCache();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an ellipse to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*
* Return Value:
*
*   Status code
*
* History:
*
*   02/22/1999 ikkof
*       Defined an array of a circle with radius 1 and used it.
*
\**************************************************************************/

GpStatus
GpPath::AddEllipse(
    const GpRectF& rect
    )
{
    GpPointF points[13];
    INT count = 13;
    REAL u_cir = 4*(REALSQRT(2.0) - 1)/3;
    GpPointF center;
    REAL    wHalf, hHalf;

    wHalf = rect.Width/2;
    hHalf = rect.Height/2;
    center.X = rect.X + wHalf;
    center.Y = rect.Y + hHalf;

    // 4 Bezier segment of a circle with radius 1.

    points[ 0].X = 1;       points[ 0].Y = 0;
    points[ 1].X = 1;       points[ 1].Y = u_cir;
    points[ 2].X = u_cir;   points[ 2].Y = 1;
    points[ 3].X = 0;       points[ 3].Y = 1;
    points[ 4].X = -u_cir;  points[ 4].Y = 1;
    points[ 5].X = -1;      points[ 5].Y = u_cir;
    points[ 6].X = -1;      points[ 6].Y = 0;
    points[ 7].X = -1;      points[ 7].Y = -u_cir;
    points[ 8].X = -u_cir;  points[ 8].Y = -1;
    points[ 9].X = 0;       points[ 9].Y = -1;
    points[10].X = u_cir;   points[10].Y = -1;
    points[11].X = 1;       points[11].Y = -u_cir;
    points[12].X = 1;       points[12].Y = 0;

    // Scale to the appropriate size.

    for(INT i = 0; i < count; i++)
    {
        points[i].X = points[i].X*wHalf + center.X;
        points[i].Y = points[i].Y*hHalf + center.Y;
    }

    // Add resulting Bezier curve segments to the path

    GpStatus status;

    StartFigure();
    status = AddBeziers(points, count);
    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical pie to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*   startAngle - Specify the starting angle for the pie
*   sweepAngle - Sweep angle for the pie
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPie(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF pt;

    StartFigure();

    // Add the center point.

    pt.X = rect.X + rect.Width/2;
    pt.Y = rect.Y + rect.Height/2;
    GpStatus status = AddLines(&pt, 1);

    // Add the arc points.

    if(status == Ok)
        status = AddArc(rect, startAngle, sweepAngle);

    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add Bezier curve segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify Bezier control points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddBeziers(
    const GpPointF* points,
    INT count
    )
{
    // Number of points must be 3 * N + 1
    if ((!points) || (count < 4) || (count % 3 != 1))
    {
    	return InvalidParameter;
    }

    // Check if the first point is the same as the last point.
    INT firstType;
    INT origCount = GetPointCount();

    if(!IsSubpathActive)
    {
        SubpathCount++; // Starting a new subpath.
        firstType = PathPointTypeStart;
    }
    else
    {
        if(origCount > 0)
        {
            firstType = PathPointTypeLine;
        }
        else
        {
            SubpathCount++;
            firstType = PathPointTypeStart;
        }
    }

    // Resize Points and Types
    GpPointF* pointBuf = Points.AddMultiple(count);
    BYTE* typeBuf = Types.AddMultiple(count);

    if(pointBuf == NULL || typeBuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    GpMemcpy(pointBuf, points, count * sizeof(GpPointF));
    GpMemset(typeBuf, PathPointTypeBezier, count);
    
    if(firstType == PathPointTypeStart)
        typeBuf[0] = PathPointTypeStart;
    else if(firstType == PathPointTypeLine)
        typeBuf[0] = PathPointTypeLine;

    IsSubpathActive = TRUE;
    HasBezier = TRUE;

    InvalidateCache();
    UpdateUid();

    return Ok;
}

GpStatus
GpPath::AddBezier(
    const GpPointF& pt1,
    const GpPointF& pt2,
    const GpPointF& pt3,
    const GpPointF& pt4
    )
{
    GpPointF points[4];

    points[0] = pt1;
    points[1] = pt2;
    points[2] = pt3;
    points[3] = pt4;

    return AddBeziers(points, 4);
}

GpStatus
GpPath::AddBezier(
    REAL x1, REAL y1,
    REAL x2, REAL y2,
    REAL x3, REAL y3,
    REAL x4, REAL y4
    )
{
    GpPointF points[4];

    points[0].X = x1;
    points[0].Y = y1;
    points[1].X = x2;
    points[1].Y = y2;
    points[2].X = x3;
    points[2].Y = y3;
    points[3].X = x4;
    points[3].Y = y4;

    return AddBeziers(points, 4);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a path to the current path object.
*   When connect is TRUE, this combine the end point of the current
*   path and the start point of the given path if both paths are
*   open.
*   If either path is closed, the two paths will not be connected
*   even if connect is set to TRUE.
*
* Arguments:
*
*   [IN] points - Specify a subpath points
*   [IN] types - Specify a subpath control types.
*   [IN] count - Number of points
*   [IN] connect - TRUE if two open paths needs to be connected.
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::AddPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    BOOL connect
    )
{
    GpStatus status = Ok;
    
    if(points == NULL || types == NULL || count <= 0)
    {
        return InvalidParameter;
    }

    INT count1 = GetPointCount();
    INT count2 = count;
    const GpPointF* points2 = points;
    const BYTE* types2 = types;

    INT totalCount = count1 + count2;
    BOOL forward1 = TRUE, forward2 = TRUE;

    status = Points.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    status = Types.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    GpPointF* outPoints = Points.GetDataBuffer();
    BYTE* outTypes = Types.GetDataBuffer();
    const GpPointF* points1 = outPoints;
    const BYTE* types1 = outTypes;

    totalCount = CombinePaths(
        totalCount, 
        outPoints,
        outTypes,
        count1, 
        points1, 
        types1, 
        forward1,
        count2, 
        points2, 
        types2, 
        forward2,
        connect
    );

    if( (totalCount >= count1) &&
        ValidatePathTypes(outTypes, totalCount, &SubpathCount, &HasBezier))
    {
        count2 = totalCount - count1;
        Points.AdjustCount(count2);
        Types.AdjustCount(count2);
        InvalidateCache();
        UpdateUid();

        return Ok;
    }
    else
    {
        return InvalidParameter;
    }
}

GpStatus
GpPath::AddPath(const GpPath* path, BOOL connect)
{
    if(!path)
    {
        return InvalidParameter;
    }

    INT count2 = path->GetPointCount();
    const GpPointF* points2 = path->GetPathPoints();
    const BYTE* types2 = path->GetPathTypes();

    return AddPath(points2, types2, count2, connect);
}

/**************************************************************************\
*
* Function Description:
*
* Reverse the direction of the path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Reverse()
{
    if(!IsValid())
        return InvalidParameter;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();
    BYTE* types = Types.GetDataBuffer();

    GpStatus status = Ok;

    if(count > 1)
        status = ::ReversePath(count, points, types);
    UpdateUid();

    return status;
}

GpStatus
GpPath::GetLastPoint(GpPointF* lastPoint)
{
    INT count = GetPointCount();
    if(count <= 0 || lastPoint == NULL)
        return InvalidParameter;

    GpPointF* points = Points.GetDataBuffer();

    // Return the last point.

    *lastPoint = points[count - 1];

    return Ok;
}

GpPath*
GpPath::GetOpenPath()
{
    BOOL openPath = TRUE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetClosedPath()
{
    BOOL openPath = FALSE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetOpenOrClosedPath(BOOL openPath)
{
    INT startIndex, endIndex;
    BOOL isClosed;
    const GpPointF* points = Points.GetDataBuffer();
    const BYTE* types = Types.GetDataBuffer();

    DpPathIterator iter(points, types, GetPointCount());

    GpPath* path = new GpPath(FillMode);

    if(path)
    {
        INT segmentCount = 0;
        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            if(isClosed != openPath)
            {
//                path->AddSubpath(points + startIndex, types + startIndex,
//                        endIndex - startIndex + 1);

                BOOL connect = FALSE;
                path->AddPath(points + startIndex, types + startIndex,
                        endIndex - startIndex + 1, connect);
                segmentCount++;
            }
        }

        if(segmentCount == 0)
        {
            delete path;
            path = NULL;
        }
    }

    return path;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an open cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*   offset - Index of the first point we're interested in
*   numberOfSegments - Number of curve segments
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define DEFAULT_TENSION 0.5

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count,
    REAL tension,
    INT offset,
    INT numberOfSegments
    )
{
    // Verify input parameters

    if (points == NULL ||
        count < 2 ||
        offset < 0 ||
        offset >= count ||
        numberOfSegments < 1 ||
        numberOfSegments >= count-offset)
    {
        return InvalidParameter;
    }

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        offset,
                        numberOfSegments,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments to the current path

    GpStatus status;

    status = AddBeziers(bezierPoints, bezierCount);
    delete[] bezierPoints;

    return status;
}

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddCurve(points,
                    count,
                    DEFAULT_TENSION,
                    0,
                    count-1);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a closed cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count,
    REAL tension
    )
{
    // Verify input parameters

    if (points == NULL || count <= 2)
        return InvalidParameter;

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        0,
                        count,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments as a closed curve

    GpStatus status;

    StartFigure();
    status = AddBeziers(bezierPoints, bezierCount);
    CloseFigure();

    delete[] bezierPoints;

    InvalidateCache();
    UpdateUid();

    return status;
}

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddClosedCurve(points, count, DEFAULT_TENSION);
}


/**************************************************************************\
*
* Function Description:
*
*   Convert cardinal spline curve points to Bezier curve control points
*
* Arguments:
*
*   [IN] points - Array of spline curve points
*   count - Number of points in the "points" array
*   offset - Specify the index of the first control point in
*       the "points" array that the curve should start from
*   numberOfSegments - Specify the number of curve segments to draw
*   tension - Specify the tension parameter
*   bezierCount - Return the number of Bezier control points
*
* Return Value:
*
*   Pointer to an array of Bezier control points
*   NULL if there is an error
*
* Reference:
*
*   Spline Tutorial Notes
*   Technical Memo No. 77
*   Alvy Ray Smith
*   Presented as tutorial notes at the 1983 SIGGRAPH, July 1983
*   and the SIGGRAPH, July 1984
*
* Notes:
*
*   Support for cardinal spline curves
*
*   Cardinal splines are local interpolating splines, i.e. they
*   pass through their control points and they maintain
*   first-order continuity at their control points.
*
*   a cardinal spline is specified by three parameters:
*       a set of control points P1, ..., Pn
*       tension parameter a
*       close flag
*
*   If n is 1, then the spline degenerates into a single point P1.
*   If n > 1 and the close flag is false, the spline consists of
*   n-1 cubic curve segments. The first curve segment starts from
*   P1 and ends at P2. The last segment starts at Pn-1 and ends at Pn.
*
*   The cubic curve segment from Pi to Pi+1 is determined by
*   4 control points:
*       Pi-1 = (xi-1, yi-1)
*       Pi = (xi, yi)
*       Pi+1 = (xi+1, yi+1)
*       Pi+2 = (xi+2, yi+2)
*
*   The parametric equation is defined as:
*
*       [ X(t) Y(t) ] = [t^3 t^2 t 1] * M * [ xi-1 yi-1 ]
*                                           [ xi   yi   ]
*                                           [ xi+1 yi+1 ]
*                                           [ xi+2 yi+2 ]
*
*   where t ranges from 0 to 1 and M is a 4x4 matrix satisfying
*   the following constraints:
*
*       X(0) = xi               interpolating through control points
*       X(1) = xi+1
*       X'(0) = a(xi+1 - xi-1)  first-order continuity
*       X'(1) = a(xi+2 - xi)
*
*   In the case of segments from P1 to P2 and from Pn-1 to Pn,
*   we replicate the first and last control points, i.e. we
*   define P0 = P1 and Pn+1 = Pn.
*
*   If the close flag is true, we have an additional curve segment
*   from Pn to Pn+1 = P1. For the segments near the beginning and
*   the end of the spline, we wrap around the control points, i.e.
*   P0 = Pn, Pn+1 = P1, and Pn+2 = P2.
*
\**************************************************************************/

GpPointF*
GpPath::ConvertSplineToBezierPoints(
    const GpPointF* points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension,
    INT* bezierCount
    )
{
    BOOL closed;
    GpPointF* bezierPoints;

    ASSERT(count > 1 &&
           offset >= 0 &&
           offset < count &&
           numberOfSegments > 0 &&
           numberOfSegments <= count-offset);

    // Curve is closed if the number of segments is equal to
    // the number of curve points

    closed = (numberOfSegments == count);

    // Allocate memory to hold Bezier control points

    *bezierCount = numberOfSegments*3 + 1;
    bezierPoints = new GpPointF[*bezierCount];

    if (bezierPoints == NULL)
        return NULL;

    // Convert each spline segment to a Bezier segment
    // resulting in 3 additional Bezier points

    GpPointF buffer[4], *q;
    const GpPointF* p;
    REAL a3;

    a3 = tension / 3;
    q = bezierPoints;
    *q = points[offset];

    for (INT index=offset; index < offset+numberOfSegments; index++)
    {
        if (index > 1 && index < count-2)
            p = points + (index-1);
        else
        {
            // Points near the beginning and end of the curve
            // require special attention

            if (closed)
            {
                // If the curve is closed, make sure the control points
                // wrap around the beginning and end of the array.

                buffer[0] = points[(index-1+count) % count];
                buffer[1] = points[index];
                buffer[2] = points[(index+1) % count];
                buffer[3] = points[(index+2) % count];
            }
            else
            {
                // If the curve is not closed, replicate the first
                // and last point in the array.

                buffer[0] = points[(index > 0) ? (index-1) : 0];
                buffer[1] = points[index];
                buffer[2] = points[(index+1 < count) ? (index+1) : (count-1)];
                buffer[3] = points[(index+2 < count) ? (index+2) : (count-1)];
            }

            p = buffer;
        }

        q[1].X = -a3*p[0].X + p[1].X + a3*p[2].X;
        q[1].Y = -a3*p[0].Y + p[1].Y + a3*p[2].Y;
        q[2].X =  a3*p[1].X + p[2].X - a3*p[3].X;
        q[2].Y =  a3*p[1].Y + p[2].Y - a3*p[3].Y;
        q[3] = p[2];

        q += 3;
    }

    return bezierPoints;
}


/**************************************************************************\
*
* Function Description:
*
*   Transform all path points by the specified matrix
*
* Arguments:
*
*   matrix - Transform matrix
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpPath::Transform(
    GpMatrix *matrix
    )
{
    ASSERT(IsValid());

    if(matrix)
    {
        INT count = GetPointCount();
        GpPointF* points = Points.GetDataBuffer();

        matrix->Transform(points, count);
        UpdateUid();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Flattens the control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*
* Return Value:
*
*   Status
*
* Created:
*
*   12/16/1998 ikkof
*       Created it.
*
\**************************************************************************/

// New codes

//#define USE_XBEZIER
//#define USE_WARP

GpStatus
GpPath::Flatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix *matrix
    ) const
{
#ifdef USE_WARP

    GpRectF bounds;

    GetBounds(&bounds);

    GpPointF quad[4];

    quad[0].X = bounds.X;
    quad[0].Y = bounds.Y;
    quad[1].X = bounds.X + bounds.Width;
    quad[1].Y = bounds.Y;
    quad[2].X = bounds.X;
    quad[2].Y = bounds.Y + bounds.Height;
    quad[3].X = bounds.X + bounds.Width;
    quad[3].Y = bounds.Y + bounds.Height;

    // Modify quad.

    quad[0].X += bounds.Width/4;
    quad[1].X -= bounds.Width/4;

    return WarpAndFlatten(matrix, &quad[0], 4,
                bounds, WarpModePerspective);

#else

    ASSERT(matrix);

    FPUStateSaver fpuState;  // Setup the FPU state.

    flattenPoints->Reset(FALSE);
    flattenTypes->Reset(FALSE);
    INT count = Points.GetCount();
    INT i = 0;

#ifdef USE_XBEZIER
    GpXBezier bezier;
#else
    GpCubicBezier bezier;
#endif

    GpPointF *pts = Points.GetDataBuffer();
    BYTE *types = Types.GetDataBuffer();

    INT tempCount;
    INT tempCount0;
    GpPointF *tempPts;
    BYTE *tempTypes;
    GpStatus status = Ok;

    DpPathIterator iter(pts, types, count);

    INT startIndex, endIndex;
    BOOL isClosed;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed) && status == Ok)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;
        INT lastCount0 = flattenTypes->GetCount();


        while(iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
                && status == Ok)
        {
            switch(pathType)
            {
            case PathPointTypeStart:
                break;

            case PathPointTypeBezier:
#ifdef USE_XBEZIER
                if(bezier.SetBeziers(
                    3,
                    &pts[typeStartIndex],
                    typeEndIndex - typeStartIndex + 1) == Ok)
#else
                if(bezier.SetBeziers(
                    &pts[typeStartIndex],
                    typeEndIndex - typeStartIndex + 1) == Ok)
#endif
                {
                    // The flattened the bezier.

                    const INT bezierBufferCount = 32;
                    GpPointF bezierBuffer[bezierBufferCount];
                    DynPointFArray bezierFlattenPts(
                                        &bezierBuffer[0],
                                        bezierBufferCount);

                    bezier.Flatten(&bezierFlattenPts, matrix);
                    tempCount = bezierFlattenPts.GetCount();

                    // Check if there is already the first point.
                    if(!isFirstPoint)
                        tempCount--;    // Don't add the first point.

                    if (tempCount > 0)
                    {

                        if((tempTypes = flattenTypes->AddMultiple(tempCount)) != NULL)
                        {
                            tempPts = bezierFlattenPts.GetDataBuffer();

                            if(!isFirstPoint)
                                tempPts++;  // Skip the first point.

                            flattenPoints->AddMultiple(tempPts, tempCount);
                            GpMemset(tempTypes, PathPointTypeLine, tempCount);
                            if(isFirstPoint)
                                tempTypes[0] = PathPointTypeStart;

                            isFirstPoint = FALSE;
                        }
                        else
                            status = OutOfMemory;

                    }

                }
                else
                    status =InvalidParameter;

                break;

            case PathPointTypeLine:
            default:
                tempCount0 = flattenPoints->GetCount();
                tempCount = typeEndIndex - typeStartIndex + 1;

                if(!isFirstPoint)
                    tempCount--;

                if((tempTypes = flattenTypes->AddMultiple(tempCount)) != NULL)
                {
                    tempPts = &pts[typeStartIndex];
                    if(!isFirstPoint)
                        tempPts++;
                    GpMemset(tempTypes, PathPointTypeLine, tempCount);
                    if(isFirstPoint)
                        tempTypes[0] = PathPointTypeStart;

                    flattenPoints->AddMultiple(
                        tempPts,
                        tempCount);

                    tempPts = flattenPoints->GetDataBuffer();

                    matrix->Transform(
                        tempPts + tempCount0,
                        tempCount);

                    isFirstPoint = FALSE;
                }

                break;
            }
        }

        // This is the end of the current subpath.  Close subpath
        // if necessary.

        if(isClosed)
        {
            BYTE* typeBuff = flattenTypes->GetDataBuffer();
            GpPointF* ptBuff = flattenPoints->GetDataBuffer();
            INT lastCount = flattenTypes->GetCount();
            if(lastCount > lastCount0 + 2)
            {
                // First, find the typical dimension of this path.
                // Here, the first non-zero distance of the original edges
                // is set to be a typical dimension.
                // If the bounds is easily available, we can use it.

                REAL maxError = 0;
                INT k = startIndex;
                while(k < endIndex && maxError <= 0)
                {
                    maxError = REALABS(pts[k + 1].X - pts[k].X)
                        + REALABS(pts[k + 1].Y - pts[k].Y);
                    k++;
                }

                if(maxError > 0)
                {
                    // Set the allowable error for this path to be
                    // POINTF_EPSOLON times the typical dimension of this path.

                    maxError *= POINTF_EPSILON;

                    // Check if the first and last point are within the floating point
                    // error range.

                    if(
                        (REALABS(ptBuff[lastCount - 1].X - ptBuff[lastCount0].X)
                            < maxError) &&
                        (REALABS(ptBuff[lastCount - 1].Y - ptBuff[lastCount0].Y)
                            < maxError)
                    )
                    {
                        // Regard the last point as the same as the first point.

                        lastCount--;
                        flattenTypes->SetCount(lastCount);
                        flattenPoints->SetCount(lastCount);
                    }
                }
            }
            typeBuff[lastCount - 1] |= PathPointTypeCloseSubpath;
        }
    }

    return status;

#endif  // End of USE_WARP
}


/**************************************************************************\
*
* Function Description:
*
* Flattens the control points and transform itself to the flatten path.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*                   When matrix is NULL, the identity matrix is used.
*
* Return Value:
*
*   Status
*
* Created:
*
*   09/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Flatten(
    GpMatrix *matrix
    )
{
    if(!HasBezier)
    {
        if(matrix)
        {
            GpPointF* points = Points.GetDataBuffer();
            INT count = Points.GetCount();
            matrix->Transform(points, count);
        }
        return Ok;
    }

    const INT bufferSize = 32;
    BYTE typesBuffer[bufferSize];
    GpPointF pointsBuffer[bufferSize];

    DynByteArray flattenTypes(&typesBuffer[0], bufferSize);
    DynPointFArray flattenPoints(&pointsBuffer[0], bufferSize);

    GpStatus status = Ok;
    GpMatrix identity;   // Identity matrix

    if(matrix == NULL)
        matrix = &identity; // Use the identity matrix

    status = Flatten(&flattenTypes, &flattenPoints, matrix);

    if(status != Ok)
        return status;

    INT flattenCount = flattenPoints.GetCount();
    Points.Reset(FALSE);
    Types.Reset(FALSE);
    Points.AddMultiple(flattenPoints.GetDataBuffer(), flattenCount);
    Types.AddMultiple(flattenTypes.GetDataBuffer(), flattenCount);
    HasBezier = FALSE;

    InvalidateCache();
    UpdateUid();

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
* Warp and flattens the control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    return xpath.Flatten(flattenTypes, flattenPoints, matrix);
}

/**************************************************************************\
*
* Function Description:
*
* Warps and flattens the control points and transform itself to
* the flatten path.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*                   The identity matrix is used when matrix is NULL.
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlattenSelf(
    GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpMatrix identity;   // Identity matrix

    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    const INT bufferSize = 32;
    BYTE typesBuffer[bufferSize];
    GpPointF pointsBuffer[bufferSize];

    DynByteArray flattenTypes(&typesBuffer[0], bufferSize);
    DynPointFArray flattenPoints(&pointsBuffer[0], bufferSize);

    if(matrix == NULL)
        matrix = &identity; // Use the identity matrix

    GpStatus status = xpath.Flatten(&flattenTypes, &flattenPoints, matrix);

    if(status == Ok)
    {
        INT flattenCount = flattenPoints.GetCount();
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        Points.AddMultiple(flattenPoints.GetDataBuffer(), flattenCount);
        Types.AddMultiple(flattenTypes.GetDataBuffer(), flattenCount);
        HasBezier = FALSE;

        UpdateUid();
        InvalidateCache();
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*  
*   convert a 2 segment closed subpath emitted by the region conversion
*   to a correct winding path.
*
* Arguments:
*
*   [IN] p - the path.
*
* Created:
*
*   09/21/2000 asecchia
*       Created it.
*
\**************************************************************************/

struct PathBound
{
    REAL xmin;
    REAL ymin;
    REAL xmax;
    REAL ymax;
    INT count;
    GpPointF *points;
    BYTE *types;
    bool reverse;
    
    void Init(INT c, GpPointF *p, BYTE *t)
    {
        reverse = false;
        points = p;
        types = t;
        count = c;
    }
};

void ComputeBoundingBox(
    GpPathPointIterator &i, 
    PathBound *p
)
{
    GpPointF *point = i.CurrentItem();
    p->xmax = p->xmin = point->X;
    p->ymax = p->ymin = point->Y;
    
    while(!i.IsDone())
    {
        point = i.CurrentItem();
        if(point->X < p->xmin) { p->xmin = point->X; }
        if(point->X > p->xmax) { p->xmax = point->X; }
        if(point->Y < p->ymin) { p->ymin = point->Y; }
        if(point->Y > p->ymax) { p->ymax = point->Y; }
        i.Next();
    }
}

bool Contains(PathBound &pb1, PathBound &pb2)
{
    return ( 
        (pb1.xmin <= pb2.xmin) &&
        (pb1.ymin <= pb2.ymin) &&
        (pb1.xmax >= pb2.xmax) &&
        (pb1.ymax >= pb2.ymax)     
    );
}

void ConvertRegionOutputToWinding(GpPath **p)
{
    GpPathPointIterator iPoints(
        (GpPointF*)(*p)->GetPathPoints(),
        (BYTE*)(*p)->GetPathTypes(),
        (*p)->GetPointCount()
    );
    
    GpSubpathIterator iSubpath(&iPoints);
    
    GpPointF *points;
    BYTE *types;
    INT count;
    GpPath *ret = new GpPath(FillModeWinding);
    
    // if we're out of memory, simply give them back their path.
    
    if(!ret) { return; }
    
    GpPath *sub;
    DynArray<PathBound> bounds;
    PathBound pb;
    
    // Iterate through all the subpaths culling information for the following
    // algorithm. This is O(n) in the number of points. 
    // The information we need is the starting point for each subpath and
    // the bounding box.
    
    while(!iSubpath.IsDone())
    {
        count = -iSubpath.CurrentIndex();
        points = iSubpath.CurrentItem();
        types = iSubpath.CurrentType();
        iSubpath.Next();
        count += iSubpath.CurrentIndex();
        
        GpPathPointIterator iSubpathPoint( points, types, count );
        
        pb.Init(count, points, types);
        ComputeBoundingBox( iSubpathPoint, &pb );
        bounds.Add(pb);
    }
    
    // Double loop through all the subpaths figuring out the containment 
    // relationships.
    // For every level of containment, flip the reverse bit.
    // E.g. for a subpath that's contained by 5 other rectangles, start at
    // false and apply 5x(!)   !!!!!false == true  which means flip this path.
    // this is O(n^2) in the number of subpaths.
    
    count = bounds.GetCount();
    int i, j;
    
    for(i=1; i<count; i++)
    {
        for(j=i-1; j>=0; j--)
        {
            if(Contains(bounds[i], bounds[j]))
            {
                bounds[j].reverse = !bounds[j].reverse;
                continue;
            }
            
            if(Contains(bounds[j], bounds[i]))
            {
                bounds[i].reverse = !bounds[i].reverse;
            }
        }
    }
    
    // Now reverse all the subpaths that need to be reversed.
    // Accumulate the results into the array.
    
    for(i=0; i<count; i++)
    {
        sub = new GpPath(
            bounds[i].points, 
            bounds[i].types, 
            bounds[i].count
        );
        
        if(bounds[i].reverse)
        {
            sub->Reverse();
        }
        
        ret->AddPath(sub, FALSE);
        
        delete sub;
    }
    
    delete *p;
    *p = ret;
}

/**************************************************************************\
*
* Function Description:
*
* Returns the widened path.
*
* Arguments:
*
*   [IN] pen - the pen.
*   [IN] matrix - Specifies the transform
*   [IN] dpiX - the X-resolution.
*   [IN] dpiY - the Y-resolution.
*
* Return Value:
*
*   path
*
* Created:
*
*   06/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPath(
    const GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags
    ) const
{
    return GetWidenedPathWithDpPen(
        (const_cast<GpPen *>(pen))->GetDevicePen(),
        matrix,
        dpiX,
        dpiY,
        widenFlags
    );
}

 
GpPath*
GpPath::GetWidenedPathWithDpPen(
    const DpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags
    ) const
{
    ASSERT(pen);
    
    BOOL regionToPath = (widenFlags & WidenEmitDoubleInset) == 0;
    
    // Don't pass this flag down to the widener.
    
    widenFlags &= ~WidenEmitDoubleInset;
    
    if ((REALABS(dpiX) < REAL_EPSILON) || 
        (REALABS(dpiY) < REAL_EPSILON)    )
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    if( (pen->PenAlignment != PenAlignmentInset) &&
        (pen->PenAlignment != PenAlignmentOutset)   )
    {
        // Use the standard widening code for non-inset or non-outset pen.

        return GetWidenedPathWithDpPenStandard(
            pen,
            matrix,
            dpiX,
            dpiY,
            widenFlags,
            FALSE          // standard pen
        );
    }
    else
    {
        // Do the Inset Pen.
        
        // Our technique is as follows. See the inset pen spec in the 
        // gdiplus\specs directory.
        // First, inset pen is defined as widening to the inside of the path
        // which only has meaning for closed segments. Behaviour for open 
        // segments is unchanged (center pen).
        // We widen the path at 2x the stroke width using a center pen.
        // For round dash caps, we use a double-round or 'B' cap. We also
        // mirror the compound line pattern across the spine of the path.
        // Then we import the widened path as a region and clip against the
        // original path converted to a region. What's left is a region 
        // which contains the widened inset pen. This is converted to a path
        // and we're done.

        // Copy the pen. Note that this will copy the *pointer* to the Brush
        // but this is ok because the DpPen (insetPen) doesn't have a 
        // destructor and so won't attempt to free any state.
        
        // We will need an insetPen for the closed subpath segments and a
        // centerPen for the open subpath segments.
        
        DpPen insetPen = *pen;
        DpPen centerPen = *pen;
        
        // Use a double width center pen and then clip off the outside creating
        // a single width insetPen.
        
        insetPen.Width *= 2.0f;
        insetPen.PenAlignment = PenAlignmentCenter;
        centerPen.PenAlignment = PenAlignmentCenter;
        
        // Copy the compound array duplicating the compound array in reverse
        // and rescaling back to [0,1] interval (i.e. mirror along the spine).
        
        if( pen->CompoundCount > 0)
        {
            insetPen.CompoundArray = (REAL*)GpMalloc(
               sizeof(REAL)*insetPen.CompoundCount*2
            );
            
            // Check the GpMalloc for out of memory.
            
            if(insetPen.CompoundArray == NULL)
            {
                return NULL;
            }
            
            // Copy the pen->CompoundArray and duplicate it in reverse (mirror).
            // rescale to the interval [0, 1]
            
            for(INT i=0; i<insetPen.CompoundCount; i++)
            {
                // copy and scale range [0, 1] to [0, 0.5]
                
                insetPen.CompoundArray[i] = pen->CompoundArray[i]/2.0f;
                
                // copy and scale range [0, 1] to [0.5, 1] reversed.
                
                insetPen.CompoundArray[insetPen.CompoundCount*2-i-1] = 
                    1.0f - pen->CompoundArray[i]/2.0f;
            }
            
            // we have double the number of entries now.
            
            insetPen.CompoundCount *= 2;
        }

        // This is an optimized codepath used by our strokepath rasterizer in
        // the driver. We simply ask for the double widened inset/outset
        // path and ask the code not to do the region to path clipping because
        // the stroke path code in the driver has a much more efficient way of
        // performing the clipping using the VisibleClip. This saves us from
        // rasterizing the widened path into a region at device resolution.
        
        if(!regionToPath)
        {            
            GpPath *widenedPath = GetWidenedPathWithDpPenStandard(
                &insetPen,
                matrix,
                dpiX,
                dpiY,
                widenFlags,
                TRUE            // Inset/Outset pen?
            );
            
            if(pen->CompoundCount > 0)
            {
                // we allocated a new piece of memory, throw it away.
                // Make sure we're not trying to throw away the original pen
                // CompoundArray - only free the temporary one if we created it.
                
                ASSERT(insetPen.CompoundArray != pen->CompoundArray);
                GpFree(insetPen.CompoundArray);
                insetPen.CompoundArray = NULL;
            }
            
            return widenedPath;
        }


        // Create an iterator to step through each subpath.
        
        GpPathPointIterator pathIterator(
            (GpPointF*)GetPathPoints(),
            (BYTE*)GetPathTypes(),
            GetPointCount()
        );
        
        GpSubpathIterator subPathIterator(
            &pathIterator
        );
        
        // Some temporary variables.
        
        GpPointF *points;
        BYTE *types;
        INT subPathCount;
        GpPath *widenedPath = NULL;
        GpPath *subPath = NULL;
        bool isClosed = false;

        // Accumulate the widened sub paths in this returnPath.
                
        GpPath *returnPath = new GpPath(FillModeWinding);
        
        // loop while there are more subpaths and the returnPath is not NULL
        // This implicitly checks that returnPath was allocated correctly.
        
        while(returnPath && !subPathIterator.IsDone())
        {   
            // Get the data for the current subpath.
                
            points = subPathIterator.CurrentItem();
            types = subPathIterator.CurrentType();
            subPathCount = -subPathIterator.CurrentIndex();
            subPathIterator.Next();
            subPathCount += subPathIterator.CurrentIndex();

            // Create a path object representing the current sub path.
            
            subPath = new GpPath(points, types, subPathCount);
            
            if(!subPath)
            {
                // failed the allocation.
                
                delete returnPath;
                returnPath = NULL;
                break;
            }

            // Is this subpath closed?
            
            isClosed = bool(
                (types[subPathCount-1] & PathPointTypeCloseSubpath) ==
                PathPointTypeCloseSubpath
            );

            // Widen the subPath with the inset pen for closed and
            // center pen for open.
            
            widenedPath = subPath->GetWidenedPathWithDpPenStandard(
                (isClosed) ? &insetPen : &centerPen,
                matrix,
                dpiX,
                dpiY,
                widenFlags,
                isClosed            // Inset/Outset pen?
            );
                    
            // don't need the subPath anymore - we have the widened version.
            
            delete subPath;
            subPath = NULL;
            
            // Check if the widener succeeded.
            
            if(!widenedPath || !widenedPath->IsValid())
            {
                delete widenedPath;
                widenedPath = NULL;
                delete returnPath;
                returnPath = NULL;
                break;
            }
            
            if(isClosed)
            {
                // Region to path.
                
                // The widenedPath has already been transformed by the widener
                // according to the matrix. Use the identity to convert the 
                // widenedPath to a region, but use the matrix to transform the
                // (still untransformed) original matrix to a region.
                
                GpMatrix identityMatrix;
                GpMatrix *scaleMatrix = &identityMatrix;
                
                if(matrix)
                {
                    scaleMatrix = matrix;
                }
                
                DpRegion srcRgn(widenedPath, &identityMatrix);
                DpRegion clipRgn((DpPath*)(this), scaleMatrix);// const and type cast.
        
                // Clip the region
                
                GpStatus clip = Ok;
                
                if(pen->PenAlignment == PenAlignmentInset)
                {
                    // Inset pen is an And operation.
                    
                    clip = srcRgn.And(&clipRgn);
                }
                else
                {
                    ASSERT(pen->PenAlignment == PenAlignmentOutset);
                    
                    // Outset pen is an Exclude operation.
                    
                    clip = srcRgn.Exclude(&clipRgn);
                }
                
                GpPath *clippedPath;
                
                if(clip == Ok)
                {  
                    clippedPath = new GpPath(&srcRgn);
                    
                    ConvertRegionOutputToWinding(&clippedPath);
                    
                    if(!clippedPath)
                    {
                        delete widenedPath;
                        widenedPath = NULL;
                        delete returnPath;
                        returnPath = NULL;
                        break;
                    }
                    
                    // Accumulate the current subpath that we've just clipped
                    // for inset/outset into the final result.
                    
                    returnPath->AddPath(clippedPath, FALSE);
                    
                    delete clippedPath;
                    clippedPath = NULL;
                }
            }
            else
            {
                // Accumulate the center pen widened path for the open
                // subpath segment.
                
                returnPath->AddPath(widenedPath, FALSE);
            }
        
            delete widenedPath;
            widenedPath = NULL;
        }
        
        // clean up.
                
        if(pen->CompoundCount > 0)
        {
            // we allocated a new piece of memory, throw it away.
            // Make sure we're not trying to throw away the original pen
            // CompoundArray - only free the temporary one if we created it.
            
            ASSERT(insetPen.CompoundArray != pen->CompoundArray);
            GpFree(insetPen.CompoundArray);
            insetPen.CompoundArray = NULL;
        }
        
        return returnPath;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   The sweep phase of a mark-sweep path point deletion algorithm
*   This will delete all points marked with PathPointTypeInternalUse.
*
*   If it deletes a start marker, it'll make the next valid point a start
*   point.
* 
*   NOTE:
*   If the algorithm encounters a closed subpath marker it will simply 
*   delete it. Because this algorithm is used for trimming the ends of 
*   open subpath segments (during endcapping), this is the desired behaviour, 
*   but may not be strictly correct for other uses.
*   
*   The points to be deleted are marked by oring in the 
*   PathPointTypeInternalUse flag. This flag is used by the widener as an 
*   internal flag and as a deletion mask for this code. These two usages 
*   do not (and should not) overlap.
*
* Created:
*
*   10/07/2000 asecchia
*       created it.
*
\**************************************************************************/

VOID GpPath::EraseMarkedSegments()
{
    // Get pointers to the source buffers.
    
    GpPointF *dstPoints = Points.GetDataBuffer();
    BYTE *dstTypes =  Types.GetDataBuffer();
    INT count = Points.GetCount();
    
    
    INT delete_count = 0;
    INT i=0;
    GpPointF *srcPoints = dstPoints;
    BYTE *srcTypes = dstTypes;
    
    bool deleted_start_marker = false;
    
    while(i<count)
    {
        // Skip all the points marked for deletion.
        
        if((*srcTypes) & PathPointTypeInternalUse)
        {
            delete_count++;
            
            // if we ever encounter a start marker, keep track of that fact.
            
            deleted_start_marker |= 
                (((*srcTypes) & PathPointTypePathTypeMask) == PathPointTypeStart);
        }
        else
        {
            // If we have deleted some stuff, move the data up.
            
            if(srcTypes!=dstTypes)
            {
                *dstPoints = *srcPoints;
                *dstTypes = *srcTypes;
                
                // if we deleted a start marker in the last deletion run, 
                // make the next non-deleted point a start marker.
                // Note: if the whole subpath is marked for deletion and
                // it's the last subpath, then we won't do this code because
                // we'll terminate the while loop first. This protects against
                // overwriting our buffer.
                
                if(deleted_start_marker)
                {
                    *dstTypes &= ~PathPointTypePathTypeMask;
                    *dstTypes |= PathPointTypeStart;
                }
            }
            
            deleted_start_marker = false;
        
            // increment to the next element.
            
            dstPoints++;
            dstTypes++;
        }
        
        // increment these every iteration through the loop.
        
        srcTypes++;
        srcPoints++;
        i++;
    }
    
    // update the DynArrays so that they reflect the new (deleted) count.
    
    Points.AdjustCount(-delete_count);
    Types.AdjustCount(-delete_count);
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a widened version of the path.
*
* Return
* 
*   GpPath - the widened path. NULL if this routine fails.
*
* Arguments:
*
*   [IN]     pen
*   [IN]     matrix
*   [IN]     dpiX     - the X-resolution.
*   [IN]     dpiY     - the Y-resolution.
*   [IN]     widenFlags
*   [IN]     insetPen - flag specifying if inset pen is being used.
*
*
* Created:
*
*   10/05/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPathWithDpPenStandard(
    const DpPen *pen,
    GpMatrix *matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags,
    BOOL insetPen
    ) const
{
    GpStatus status = Ok;
    
    // This is a const function. We cannot modify 'this' so we clone
    // the path in order to flatten it.
    
    GpPath* path = this->Clone();
    if(path == NULL) { return NULL; }
    path->Flatten();
    
    // Fragment the path if requested.
    // This must be done before widening as dashes and compound lines would
    // render differently otherwise.
    
    if(widenFlags & WidenRemoveSelfIntersects)
    {
        path->RemoveSelfIntersections();
        if(!path->IsValid())
        {
            delete path;
            return NULL;
        }
    }

    // Do all the path decorations before widening. This is to ensure that
    // the decorations have all of the original path information to operate
    // on --- the widening/decoration process is lossy so they have to be
    // performed in the right order.
    
    // First apply the end caps. This decoration must be applied before 
    // dashing the path.
    // Need to loop through all the subpaths, apply the end caps and 
    // fix up the path segments so they don't exit the cap incorrectly.
    // put all the caps in a path for later use. We will apply these caps
    // when we're done widening.
    
    GpPath *caps = NULL;
    
    {    
        // Create an instance of the GpEndCapCreator which will create
        // our endcap aggregate path.
        
        GpEndCapCreator ecc(
            path, 
            const_cast<DpPen*>(pen), 
            matrix, 
            dpiX, dpiY,
            (widenFlags & WidenIsAntiAliased) == WidenIsAntiAliased
        );
        
        // CreateCapPath will mark the points in the path for deletion if 
        // it's necessary to trim the path to fit the cap.
        
        status = ecc.CreateCapPath(&caps);
        if(status != Ok) 
        { 
            return NULL; 
        }
        
        // Remove the points marked for deletion in the cap trimming step.
        
        path->EraseMarkedSegments();
    }
    
    // Apply the dash decorations. Note that this will bounce on an empty path.
    
    GpPath* dashPath = NULL;

    if( (pen) && 
        (pen->DashStyle != DashStyleSolid) &&
        (path->GetPointCount() > 0)
    )
    {
        // the width is artificially expanded by 2 if the pen is inset. 
        // we need to factor this into the dash length and scale by 0.5.
        
        dashPath = path->CreateDashedPath(
            pen, 
            matrix, 
            dpiX, 
            dpiY,
            (insetPen) ? 0.5f : 1.0f
        );
        
        // If we successfully got a dashed version of *path, delete
        // the old one and return the new one.
        
        if(dashPath)
        {
            delete path;
            path = dashPath;
        }
    }
    
    // Only do the widening if we have some points left in our 
    // path after trimming
    
    if(path->GetPointCount() > 0)
    {
        // Create a widener object. Note that if path has no points left, this
        // will bounce immediately with an invalid widener.
    
        GpPathWidener widener(
            path,
            pen,
            matrix,
            insetPen
        );
        
        // We're done with this now.
        
        //delete path;
        //path = NULL;
    
        // Check if we have a valid Widener object.
        
        if(!widener.IsValid()) 
        { 
            status = OutOfMemory; 
        }
    
        // Get the widened path.
    
        if(status == Ok) 
        { 
            GpPath *tmpPath = new GpPath(FillModeWinding);
            status = widener.Widen(tmpPath); 
            delete path;
            path = tmpPath;
        }
    }
    else
    {
        delete path;
        path = caps;
        caps = NULL;
    }

    // paranoid checking the return from the widener.
    
    if((status == Ok) && (path != NULL))
    {
        // Add the endcaps to the widened path. AddPath will bounce a NULL 
        // caps pointer with InvalidParameter. For our purposes that is 
        // considered correctly handled and we continue. 
        
        path->AddPath(caps, FALSE);
        
        // Transform the result to device space.
                                    
        if(path)
        {
            if((widenFlags & WidenDontFlatten))
            {
                path->Transform(matrix);
            }
            else
            {
                path->Flatten(matrix);
            }
        }
    }
    
    // Delete the caps before returning. If we had caps, we've copied them
    // into path, otherwise caps is NULL. Or we failed to widen. Either way
    // we must not leak memory.
    
    delete caps;
    caps = NULL;

    return path;
}

/**************************************************************************\
*
* Function Description:
*
* This widenes itself.
*
* Arguments:
*
*   [IN] pen - the pen.
*   [IN] matrix - Specifies the transform
*   [IN] dpiX - the X-resolution.
*   [IN] dpiY - the Y-resolution.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   09/27/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WidenSelf(
    GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,  // 0 means use the desktop dpi
    REAL dpiY,
    DWORD widenFlags
    )
{
    GpMatrix matrix1;  // Identity matrix

    if(matrix)
        matrix1 = *matrix;

    GpPath* widenedPath = GetWidenedPath(
                            pen,
                            &matrix1,
                            dpiX,
                            dpiY,
                            widenFlags);

    if(widenedPath)
    {
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        INT count = widenedPath->GetPointCount();
        Points.AddMultiple(widenedPath->Points.GetDataBuffer(), count);
        Types.AddMultiple(widenedPath->Types.GetDataBuffer(), count);
        SubpathCount = widenedPath->SubpathCount;
        HasBezier = widenedPath->HasBezier;
        Flags = widenedPath->Flags;
        FillMode = FillModeWinding;
        delete widenedPath;

        GpStatus status = Ok;

        InvalidateCache();
        UpdateUid();

        return status;
    }
    else
        return OutOfMemory;
}

// Get the flattened path.

const DpPath *
GpPath::GetFlattenedPath(
    GpMatrix* matrix,
    DpEnumerationType type,
    const DpPen* pen,
    BOOL isAntiAliased,
    REAL dpiX,
    REAL dpiY,
    BOOL regionToPath
    ) const
{
    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    GpPath* flattenedPath = NULL;

    if(type == Flattened)
    {
        const INT bufferCount = 32;
        BYTE flattenTypesBuffer[bufferCount];
        GpPointF flattenPointsBuffer[bufferCount];

        DynByteArray flattenTypes(&flattenTypesBuffer[0], bufferCount);
        DynPointFArray flattenPoints(&flattenPointsBuffer[0], bufferCount);

        GpStatus status = Ok;
        GpMatrix identity;   // Identity matrix

        if(matrix == NULL)
            matrix = &identity;

        status = Flatten(&flattenTypes, &flattenPoints, matrix);

        flattenedPath = new GpPath(
                            flattenPoints.GetDataBuffer(),
                            flattenTypes.GetDataBuffer(),
                            flattenPoints.GetCount(),
                            GetFillMode());
    }
    else if(type == Widened)
    {
        DWORD widenFlags = 0;
        if(isAntiAliased)
        {
            widenFlags |= WidenIsAntiAliased;
        }
        if(!regionToPath)
        {
            widenFlags |= WidenEmitDoubleInset;
        }
        flattenedPath = GetWidenedPathWithDpPen(
            pen,
            matrix,
            dpiX,
            dpiY,
            widenFlags
        );
    }

    return flattenedPath;
}



/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpMatrix* matrix)
{
    GpMatrix m;

    if(matrix)
        m = *matrix;

    GpRegion rgn(this);

    if(rgn.IsValid())
        return rgn.IsVisible(point, &m, isVisible);

    *isVisible = FALSE;
    return GenericError;
}


/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path outline.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] pen - A pen to draw the outline.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*   [IN] dpiX - x-resolution of the device.
*   [IN] dpiY - y-resolution of the device.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsOutlineVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY
    )
{
    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    // If the given pen is not a solid line,
    // clone the pen and set its dash type to Solid.
    // We do line hit testing in solid lines.

    GpPen* pen1 = NULL;
    if(pen && pen->GetDashStyle() != DashStyleSolid)
    {
        pen1 = pen->Clone();
        if(pen1)
           pen1->SetDashStyle(DashStyleSolid);
    }
    else
        pen1 = pen;

    if(pen1 == NULL)
    {
        *isVisible = FALSE;
        return Ok;
    }

    // Create a widened path in the transformed coordinates.

    GpPath* widenedPath = GetWidenedPath(
                            pen1,
                            matrix,
                            dpiX,
                            dpiY,
                            0          // Use aliased widening.
                            );

    if(pen1 != pen)
        delete pen1;

    GpStatus status = Ok;

    if(widenedPath)
    {
        // Since the widened path is already transformed, we have to
        // transform the given point.

        GpPointF    transformedPoint = *point;
        if(matrix)
            matrix->Transform(&transformedPoint);

        status = widenedPath->IsVisible(&transformedPoint, isVisible, NULL);
        delete widenedPath;
    }
    else
    {
        *isVisible = FALSE;
    }

    return status;
}

// Is the current dash segment a line segment?
// If false it's a space segment.

inline bool IsLineSegment(GpIterator<REAL> &dashIt)
{
    // line segment starts on even indices.

    return bool( !(dashIt.CurrentIndex() & 0x1) );
}

// Emit a line segment if it is not degenerate.
// Return true if emitted, false if degenerate

bool EmitLineSegment(
    GpPathPointIterator &dstPath,
    GpPointF p0,
    GpPointF p1,
    bool isLineStart
)
{
    GpPointF *currentPoint;
    BYTE *currentType;

    if( (REALABS(p0.X-p1.X) < REAL_EPSILON) &&
        (REALABS(p0.Y-p1.Y) < REAL_EPSILON) )
    {
        // Don't emit a line segment if it has zero length.
        return false;
    }

    // If the last emitted line ends at the same point that this next
    // one starts, we don't need a new start record.

    if(isLineStart)
    {
        // start point.
        currentPoint = dstPath.CurrentItem();
        *currentPoint = p0;
        currentType = dstPath.CurrentType();
        *currentType = PathPointTypeStart | PathPointTypeDashMode;

        dstPath.Next();
    }

    // end point.
    currentPoint = dstPath.CurrentItem();
    *currentPoint = p1;
    currentType = dstPath.CurrentType();
    *currentType = PathPointTypeLine | PathPointTypeDashMode;

    dstPath.Next();

    return true;
}

INT
getDashData(
    BYTE* newTypes,
    GpPointF* newPts,
    INT estimateCount,
    REAL dashOffset,
    const REAL* dashArray,
    INT dashCount,
    const BYTE* types,
    const GpPointF* points,
    INT numOfPoints,
    BOOL isClosed,
    const REAL* distances
    )
{
    ASSERT(estimateCount >= numOfPoints);
    ASSERT(types && points);

    // Code assumes first point != last point for closed paths.  If first
    // point == last point, decrease point count
    if (isClosed && numOfPoints &&
        points[0].X == points[numOfPoints-1].X &&
        points[0].Y == points[numOfPoints-1].Y)
    {
        numOfPoints--;
    }


    if(!newTypes || !newPts)
    {
        return 0;
    }

    // Make the iterators.

    GpArrayIterator<GpPointF> pathIterator(
        const_cast<GpPointF*>(points),
        numOfPoints
    );
    GpArrayIterator<REAL> pathBaseDistance(
        const_cast<REAL*>(distances),
        numOfPoints
    );
    
    GpPathPointIterator dstPath(newPts, newTypes, estimateCount);
    
    GpArrayIterator<REAL> dashBaseIterator(
        const_cast<REAL*>(dashArray),
        dashCount
    );

    // Compute the length of the dash

    REAL dashLength = 0.0f;
    while(!dashBaseIterator.IsDone())
    {
        dashLength += *(dashBaseIterator.CurrentItem());
        dashBaseIterator.Next();
    }
    ASSERT(dashLength > -REAL_EPSILON);


    // Do the offset initialization.

    dashBaseIterator.SeekFirst();

    REAL distance = GpModF(dashOffset, dashLength);
    REAL delta;

    // Compute the position in the dash array corresponding to the
    // specified offset.

    while(!dashBaseIterator.IsDone())
    {
        delta = *(dashBaseIterator.CurrentItem());
        if(distance < delta)
        {
            // set to the remaining piece of the dash.
            distance = delta-distance;
            break;
        }
        distance -= delta;
        dashBaseIterator.Next();
    }

    // The dashIterator is now set to point to the correct
    // dash for the first segment.

    // These are circular arrays to repeat the dash pattern.

    GpCircularIterator<REAL> dashIterator(&dashBaseIterator);


    // This is the distance into the current dash segment that we're going
    // to start at.

    REAL currentDashLength = distance;
    REAL currentSegmentLength;

    GpPointF p0, p1;
    GpVector2D sD;     // segment direction.

    // Used to track if we need to emit a segment start record.

    bool emittedPathSegment = false;

    if(isClosed)
    {
        // set up everything off the last item and then point to
        // the first item to start the process.

        pathBaseDistance.SeekFirst();

        pathIterator.SeekLast();
        p0 = *(pathIterator.CurrentItem());

        pathIterator.SeekFirst();
        p1 = *(pathIterator.CurrentItem());

        // get the distance between the first and last points.

        GpVector2D seg = p1-p0;
        currentSegmentLength = seg.Norm();
    }
    else
    {
        // Get the first point in the array.

        p0 = *(pathIterator.CurrentItem());

        // already initialized to the first point, start on the next one.

        pathIterator.Next();
        pathBaseDistance.Next();

        // distance between point n and point n+1 is stored in
        // distance[n+1]. distance[0] is the distance between the first
        // and last points.

        currentSegmentLength = *(pathBaseDistance.CurrentItem());
    }

    // reference the distances as circular so that we can simplify the
    // internal algorithm by not having to check when we query for the
    // next segment in the last iteration of the loop.

    GpCircularIterator<REAL> pathDistance(&pathBaseDistance);

    while( !pathIterator.IsDone() )
    {
        if(currentDashLength > currentSegmentLength)
        {
            // The remaining dash segment length is longer than the remaining
            // path segment length.
            // Finish the path segment.

            // Note that we've moved along the dash segment.

            currentDashLength -= currentSegmentLength;

            p1 = *(pathIterator.CurrentItem());

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment. If we're emitting a series of path
                // segments to complete one dash, we can't have any start
                // records inbetween the segments otherwise we'll end up with
                // spurious endcaps in the middle of the lines.

                emittedPathSegment = EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }
            else
            {
                emittedPathSegment = false;
            }

            p0 = p1;

            // Keep these two in sync.

            pathDistance.Next();
            pathIterator.Next();

            currentSegmentLength = *(pathDistance.CurrentItem());
        }
        else
        {
            // The remaining path segment length is longer than the remaining
            // dash segment length.
            // Finish the dash segment.

            // Compute position between start and end point of the current
            // path segment where we finish with this dash segment.

            ASSERT(REALABS(currentSegmentLength)>REAL_EPSILON);
            sD = *(pathIterator.CurrentItem());
            sD -= p0;
            sD *= currentDashLength/currentSegmentLength;

            // Move along the path segment by the amount left in the
            // dash segment.

            currentSegmentLength -= currentDashLength;

            p1 = p0 + sD;

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment.

                EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }

            p0 = p1;

            // dashIterator is circular, so this should keep wrapping through
            // the dash array.

            dashIterator.Next();

            // Get the new dash length.

            currentDashLength = *(dashIterator.CurrentItem());
            emittedPathSegment = false;
        }
    }
    
    INT size = dstPath.CurrentIndex();

    if(!isClosed)
    {
        // For open line segments, 
        dstPath.SeekLast();
        
        GpPointF *originalPoint = points + numOfPoints - 1;
        GpPointF *dashPoint = dstPath.CurrentItem();
        BYTE *type = dstPath.CurrentType();
        
        
        if( REALABS(originalPoint->X-dashPoint->X) < REAL_EPSILON &&
            REALABS(originalPoint->Y-dashPoint->Y) < REAL_EPSILON )
        {
            // last point == last dashed point, whack out the dashed mode.
            
            *type &= ~PathPointTypeDashMode;
        }
        
        // repoint to the beginning.

        dstPath.SeekFirst();
        originalPoint = points;
        GpPointF *dashPoint = dstPath.CurrentItem();
        type = dstPath.CurrentType();

        if( REALABS(originalPoint->X-dashPoint->X) < REAL_EPSILON &&
            REALABS(originalPoint->Y-dashPoint->Y) < REAL_EPSILON )
        {
            // last point == last dashed point, whack out the dashed mode.
            
            *type &= ~PathPointTypeDashMode;
        }
    }

    // return the number of entries added to the dstPath array.

    return (size);
}

/**************************************************************************\
*
* Function Description:
*
* Creates a dashed path.
*
* Arguments:
*
*   [IN] pen - This pen contains the dash info.
*   [IN] matrix - The transformation where the dash patterns are calculated.
*                   But the dashed path is transformed back to the World
*                   coordinates.
*   [IN] dpiX - x-resolution.
*   [IN] dpiY - y-resolution.
*
* Return Value:
*
*   returns a dashed path.
*
* Created:
*
*   01/27/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpPath*
GpPath::CreateDashedPath(
    const GpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale
    ) const
{
    if(pen == NULL)
        return NULL;

    DpPen* dpPen = ((GpPen* ) pen)->GetDevicePen();

    return CreateDashedPath(dpPen, matrix, dpiX, dpiY, dashScale);
}

/**************************************************************************\
*
* Function Description:
*
* Returns TRUE if the given points have non-horizontal or non-vertical
*   edges.
*
*
* Created:
*
*   04/07/2000 ikkof
*       Created it.
*
\**************************************************************************/

inline
BOOL
hasDiagonalEdges(
    GpPointF* points,
    INT count
    )
{
    if(!points || count <= 1)
        return FALSE;

    GpPointF *curPt, *nextPt;
    curPt = points;
    nextPt = points + 1;

    BOOL foundDiagonal = FALSE;
    INT i = 1;

    while(!foundDiagonal && i < count)
    {
        if((curPt->X == nextPt->X) || (curPt->Y == nextPt->Y))
        {
            // This is either horizontal or vertical edges.
            // Go to the next edge.

            curPt++;
            nextPt++;
            i++;
        }
        else
            foundDiagonal = TRUE;
    }

    return foundDiagonal;
}

GpPath*
GpPath::CreateDashedPath(
    const DpPen* dpPen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale
    ) const
{
    FPUStateSaver::AssertMode();


    GpPointF* points = Points.GetDataBuffer();
    INT numOfPoints = GetPointCount();

    if(dpPen == NULL)
        return NULL;

    if(
        dpPen->DashStyle == DashStyleSolid ||
        dpPen->DashCount == 0 ||
        dpPen->DashArray == NULL
    )
        return NULL;

    REAL penWidth = dpPen->Width;
    GpUnit unit = dpPen->Unit;
    BOOL isWorldUnit = TRUE;

    REAL dashUnit;
    {
        // The minimum pen width 
        REAL minimumPenWidth = 1.0f;
        
        if(REALABS(dashScale-0.5f) < REAL_EPSILON)
        {
            minimumPenWidth = 4.0f;
        }
        
        if(unit != UnitWorld)
        {
            isWorldUnit = FALSE;
            penWidth = ::GetDeviceWidth(penWidth, unit, dpiX);
    
            // Prevent the extremely thin line and dashes.
    
            dashUnit = max(penWidth, minimumPenWidth);
        }
        else
        {
            REAL majorR, minorR;
    
            // Calculate the device width.
    
            ::GetMajorAndMinorAxis(&majorR, &minorR, matrix);
            REAL maxWidth = penWidth*majorR;
            REAL minWidth = penWidth*minorR;
    
            // If the device width becomes less than 1, stretch the penWidth
            // so that the device width becomes 1.
            // If we're doing the inset pen, then the path is scaled up double
            // in size and we need to scale by the inverse.
            // Also, the minimum pen width needs to be 2 not 1 in this case 
            // because we will remove half the line width. dashScale is 1/2 
            // in this case so we divide by it.
    
            dashUnit = penWidth;
            
            if(maxWidth < minimumPenWidth)
            {
                dashUnit = minimumPenWidth/majorR;
            }
        }
    }

    dashUnit *= dashScale;

    GpMatrix mat, invMat;

    if(matrix)
    {
        mat = *matrix;
        invMat = mat;
    }

    if(invMat.IsInvertible())
    {
        invMat.Invert();
    }
    else
    {
        WARNING(("Inverse matrix does not exist."));

        return NULL;
    }

    INT dashCount = dpPen->DashCount;
    REAL* dashArray = (REAL*) GpMalloc(dashCount*sizeof(REAL));
    if(dashArray)
    {
        GpMemcpy(dashArray, dpPen->DashArray, dashCount*sizeof(REAL));

        // Adjust the dash interval according the stroke width.

        for(INT i = 0; i < dashCount; i++)
        {
            dashArray[i] *= dashUnit;
        }
    }
    else
    {
        return NULL;
    }

    GpPath* newPath = Clone();

    if(newPath && newPath->IsValid())
    {
        // Flatten in the resolution given by the matrix.

        newPath->Flatten(&mat);

        if(isWorldUnit)
        {
            // Transform back to the World Unit.
            // When the pen is in WorldUnit, transform the path
            // before detDashData() is called.

            newPath->Transform(&invMat);
        }

        BYTE *types = newPath->Types.GetDataBuffer();
        points = newPath->Points.GetDataBuffer();
        numOfPoints = newPath->GetPointCount();

        GpPointF* grad = (GpPointF*) GpMalloc((numOfPoints + 1)*sizeof(GpPointF));
        REAL* distances = (REAL*) GpMalloc((numOfPoints + 1)*sizeof(REAL));

        if(grad == NULL || distances == NULL)
        {
            GpFree(grad);
            GpFree(dashArray);
            delete newPath;

            return NULL;
        }

        // Calculate the distance of each segment.

        INT i;

        REAL dashLength = 0;

        for(i = 0; i < dashCount; i++)
            dashLength += dashArray[i];

        // Make sure count is an even number.

        if(dashCount & 0x01)
            dashCount ++;

        DynByteArray dashTypes;
        DynPointFArray dashPoints;

        BYTE* newTypes = NULL;
        GpPointF* newPts = NULL;

        DpPathIterator iter(points, types, numOfPoints);

        INT startIndex, endIndex;
        BOOL isClosed;
        REALD totalLength = 0;
        INT totalCount = 0;
        BOOL isSingleSubpath = iter.GetSubpathCount() == 1;

        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpPointF startPt, lastPt, nextPt;
            REAL dx, dy;
            REALD length;
            startPt = points[startIndex];
            lastPt = startPt;

            totalLength = 0;
            INT k = 0;
            INT segmentCount = endIndex - startIndex + 1;

            CalculateGradientArray(grad, distances,
                points + startIndex, segmentCount);

            for(i = 1; i < segmentCount; i++)
                totalLength += distances[i];

            if(isClosed)
                totalLength += distances[0];

            // Estimate the required points.

            INT estimateCount
                = GpCeiling(TOREAL(totalLength*dashCount/dashLength))
                    + numOfPoints;

            // For extra caution, multiply by 2.

            estimateCount <<= 1;

            // Allocate new types and buffers

            if(newTypes)
            {
                BYTE* newTypes1 = (BYTE*) GpRealloc(
                                            newTypes,
                                            estimateCount*sizeof(BYTE));
                if(newTypes1)
                    newTypes = newTypes1;
                else
                    goto cleanUp;
            }
            else
            {
                newTypes = (BYTE*) GpMalloc(estimateCount*sizeof(BYTE));
                if(!newTypes)
                    goto cleanUp;
            }

            if(newPts)
            {
                GpPointF* newPts1 = (GpPointF*) GpRealloc(
                                                newPts,
                                                estimateCount*sizeof(GpPointF));
                if(newPts1)
                    newPts = newPts1;
                else
                    goto cleanUp;
            }
            else
            {
                newPts = (GpPointF*) GpMalloc(estimateCount*sizeof(GpPointF));
                if(!newPts)
                    goto cleanUp;
            }

            AdjustDashArrayForCaps(
                dpPen->DashCap,
                dashUnit,
                dashArray,
                dashCount
            );
 
            // Fix for Whistler Bug 178774
            // Since dash caps are no longer 'inset' when they are rendered,
            // it is possible that on closed paths, the dash caps on the start
            // and end of a closed path will overlap. This offset will leave
            // sufficient space for the two caps. However, this fix is not
            // bullet-proof. It will *always* work if the Dash Offset is 0.
            // However, if it is non-zero, it is possible that the offset
            // will counter-act the adjustment and there will be some dash
            // overlap at the start/end of closed paths. I believe this is
            // acceptable since VISIO 2000, Office 9 and PhotoDraw 2000 v2
            // also have the collision problem.
            // The real solution is to enforce a minimum spacing between the
            // start and end or merge the start/end segments if they collide.

            REAL dashCapOffsetAdjustment = 0.0f;
            if (isClosed)
            {
                dashCapOffsetAdjustment =
                    2.0f * GetDashCapInsetLength(dpPen->DashCap, dashUnit);
            }

            INT newCount = getDashData(
                newTypes,
                newPts,
                estimateCount,
                // Shouldn't the offset be scaled dashUnit instead of penWidth?
                dpPen->DashOffset * penWidth - dashCapOffsetAdjustment,
                dashArray,
                dashCount,
                types + startIndex,
                points + startIndex,
                endIndex - startIndex + 1,
                isClosed,
                distances
            );

            if(newCount)
            {
                newTypes[0] = PathPointTypeStart;
                if(isClosed)
                {
                    newTypes[0] |= PathPointTypeDashMode;
                    newTypes[newCount - 1] |= PathPointTypeDashMode;
                }
                else
                {
                    newTypes[0] &= ~PathPointTypeDashMode;
                    newTypes[newCount - 1] &= ~PathPointTypeDashMode;
                }
                dashTypes.AddMultiple(newTypes, newCount);
                dashPoints.AddMultiple(newPts, newCount);
            }

        }

        totalCount = dashPoints.GetCount();
        if(totalCount > 0)
        {
            GpPathData pathData;
            pathData.Count = totalCount;
            pathData.Types = dashTypes.GetDataBuffer();
            pathData.Points = dashPoints.GetDataBuffer();

            newPath->SetPathData(&pathData);

            if(!isWorldUnit)
            {
                // Transform back to the World Unit.
                // When the pen is in WorldUnit, it is already transformed
                // before detDashData() is called.

                newPath->Transform(&invMat);
            }

        }
        else
        {
            delete newPath;
            newPath = NULL;
        }

        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);

        return newPath;

cleanUp:
        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);
        delete newPath;

        return NULL;
    }
    else
    {
        GpFree(dashArray);

        if(newPath)
            delete newPath;

        return NULL;
    }
}


/**************************************************************************\
*
* Function Description for RemoveSelfIntersections,
*
*   Removes self intersections from the path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   06/16/1999 t-wehunt
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::RemoveSelfIntersections()
{
    PathSelfIntersectRemover corrector;
    DynPointFArray newPoints;  // Array that will hold the new points.
    DynIntArray polyCounts;    // Array that will hold the numPoints for each
                               // new polygon.
    INT numPolys;              // count of new polygons created
    INT numPoints;             // count of new points created
    GpStatus status;           // holds return status of commmands

    Flatten();

    INT       pointCount = Points.GetCount();
    GpPointF *pathPts    = Points.GetDataBuffer();
    BYTE     *pathTypes  = Types.GetDataBuffer();

    if (pointCount == 0)
    {
        return Ok;
    }

    // Add the subpaths to the Path corrector
    INT ptIndex=0; // ptIndex tracks the current index in the array of points.
    INT count=0;   // the size of the current subpath.

    // Init the corrector with the number of points we will be adding.
    if ((status = corrector.Init(pointCount)) != Ok)
    {
        return status;
    }

    while (ptIndex < pointCount)
    {
        if (pathTypes[ptIndex] == PathPointTypeStart && ptIndex != 0)
        {
            // Add the next subpath to the PathCorrector. the start index of the subpath is
            // determined using the current index minus the current subPath size.
            if ((status =
                corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
            {
                return status;
            }
            // set count to 1 since this is the first point in the new subpath
            count = 1;
        } else
        {
            count++;
        }
        ptIndex++;
    }
    // Add the last subpath that is implicitly ended by the last point.
    if (ptIndex != 0)
    {
        // Add the next subpath to the PathCorrector. the start index of the subpath is
        // determined using the current index minus the current subPath size.
        if ((status =
            corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
        {
            return status;
        }
    }

    if ((status = corrector.RemoveSelfIntersects()) != Ok)
    {
        return GenericError;
    }

    if ((status = corrector.GetNewPoints(&newPoints, &polyCounts)) != Ok)
    {
        return OutOfMemory;
    }

    // clear out the old path data so we can replace with the newly corrected one.
    Reset();

    // Now that we have the corrected path, add it back.
    GpPointF *curPoints = newPoints.GetDataBuffer();
    for (INT i=0;i<polyCounts.GetCount();i++)
    {
        if ((status = AddPolygon(curPoints,polyCounts[i])) != Ok)
        {
            // We're not stable if AddPolygon fails.
            SetValid(FALSE);
            return status;
        }

        curPoints += polyCounts[i];
    }

    return Ok;
}


VOID DpPath::InitDefaultState(GpFillMode fillMode)
{
    HasBezier = FALSE;
    FillMode = fillMode;
    Flags = PossiblyNonConvex;
    IsSubpathActive = FALSE;
    SubpathCount = 0;

    Types.Reset(FALSE);     // FALSE - don't free the memory
    Points.Reset(FALSE);    // FALSE - don't free the memory

    SetValid(TRUE);
    UpdateUid();
}

DpPath::DpPath(const DpPath* path)
{
    if(path)
    {
        HasBezier = path->HasBezier;
        FillMode = path->FillMode;
        Flags = path->Flags;
        IsSubpathActive = path->IsSubpathActive;
        SubpathCount = path->SubpathCount;

        BYTE *types = path->Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        INT count = path->GetPointCount();

        SetValid((count == 0) || ((Types.AddMultiple(types, count) == Ok) &&
                                  (Points.AddMultiple(points, count) == Ok)));
    }
    else
        SetValid(FALSE);
}


/**************************************************************************\
*
* Function Description:
*
*   Offset all path points by the specified amount
*
* Arguments:
*
*   dx, dy - Amount to offset along x- and y- direction
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
DpPath::Offset(
    REAL dx,
    REAL dy
    )
{
    ASSERT(IsValid());

    INT count = GetPointCount();
    GpPointF* pts = Points.GetDataBuffer();

    if (count > 0)
    {
        UpdateUid();
    }
    while (count--)
    {
        pts->X += dx;
        pts->Y += dy;
        pts++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Create a driver DpPath class.
*
* Arguments:
*
*   [IN] fillMode - Specify the path fill mode
*
* Return Value:
*
*   IsValid() is FALSE if failure.
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

DpPath::DpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags pathFlags
    ) : Types(stackTypes, stackCount), Points(stackPoints, stackCount)
{
    ASSERT((fillMode == FillModeAlternate) ||
           (fillMode == FillModeWinding));

    InitDefaultState(fillMode);
    Flags = pathFlags;

    // We can call this method with no points, just to set up
    // the stackPoints/stackTypes

    if (count > 0)
    {
        BYTE *types;

        if ((types = Types.AddMultiple(count)) != NULL)
        {
            *types++ = PathPointTypeStart;
            GpMemset(types, PathPointTypeLine, count - 1);
            SetValid(Points.AddMultiple(points, count) == Ok);

            if(IsValid()) 
            {
                IsSubpathActive = TRUE;
                SubpathCount = 1;
            }
        }
        else
        {
            SetValid(FALSE);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Close the currently active subpath in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigure()
{
    ASSERT(IsValid());

    // Check if there is an active subpath

    if (IsSubpathActive)
    {
        // If so, mark the last point as the end of a subpath

        Types.Last() |= PathPointTypeCloseSubpath;
        StartFigure();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Close all open subpaths in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigures()
{
    ASSERT(IsValid());

    // Go through all path points.
    // Notice that the loop index starts from 1 below.

    INT i, count = GetPointCount();
    BYTE* types = Types.GetDataBuffer();

    for (i=1; i < count; i++)
    {
        if (types[i] == PathPointTypeStart)
            types[i-1] |= PathPointTypeCloseSubpath;
    }

    if (count > 1)
        types[count-1] |= PathPointTypeCloseSubpath;

    StartFigure();
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the bounds of a path
*
* Arguments:
*
*   [OUT] bounds - Specify the place to stick the bounds
*   [IN] matrix - Matrix used to transform the bounds
*   [IN] pen - the pen data.
*   [IN] dpiX, dpiY - the resolution of x and y directions.
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::GetBounds(
    GpRect *bounds,
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    GpRectF boundsF;

    FPUStateSaver fpuState;

    GpStatus status = GetBounds(&boundsF, matrix, pen, dpiX, dpiY);

    if(status == Ok)
        status = BoundsFToRect(&boundsF, bounds);

    return status;
}

VOID
GpPath::CalcCacheBounds() const
{

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if(count <= 1)
    {
        ResetCacheBounds();
        return;
    }

    REAL left, right, top, bottom;

    left   = point->X;
    right  = left;
    top    = point->Y;
    bottom = top;

    INT i;
    for (i = 1, point++; i < count; i++, point++)
    {
        if (point->X < left)
        {
            left = point->X;
        }
        else if (point->X > right)
        {
            right = point->X;
        }

        if (point->Y < top)
        {
            top = point->Y;
        }
        else if (point->Y > bottom)
        {
            bottom = point->Y;
        }
    }
    CacheBounds.X = left;
    CacheBounds.Width = right - left;
    CacheBounds.Y = top;
    CacheBounds.Height = bottom - top;

    if(CacheBounds.Width < POINTF_EPSILON && CacheBounds.Height < POINTF_EPSILON)
    {
        ResetCacheBounds();
        return;
    }

    CacheFlags = kCacheBoundsValid;

}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the sharpest angle in a path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/04/2000 asecchia
*       Created it.
*
* Remarks:
*
*   This is an expensive function, if it's ever used in a performance 
*   critical scenario it should be recoded to use the dot product of the
*   segments and perform the angle comparison in the cosine domain.
*   The cost of normalizing the vectors should be cheaper than the 
*   atan algorithm used below.
*
*
\**************************************************************************/

VOID
GpPath::CalcSharpestAngle() const
{
    if(CacheFlags & kSharpestAngleValid)
    {
        return;
    }

    UpdateCacheBounds();

    // Walk the path and find the smallest angle between two 
    // adjacent segments.
    
    GpPathPointIterator pIter(
        (GpPointF*)GetPathPoints(),
        (BYTE*)GetPathTypes(),
        GetPointCount()
    );
    
    GpSubpathIterator pSubpath(&pIter);
    
    GpPointF *points;
    BOOL isClosed;
    
    GpPointF *p0, *p1;
    GpVector2D v;
    REAL lastAngle;
    REAL currAngle;
    REAL minAngle = 2*PI;
    REAL tempAngle;
    bool first = true;
    INT iter, i;
    
    
    while(!pSubpath.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = pSubpath.CurrentIndex();
        points = pSubpath.CurrentItem();
        pSubpath.Next();
        INT elementCount = pSubpath.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pIter.Prev();
        isClosed = (*(pIter.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath;
        pIter.Next();
        
        // Create a GpPointF iterator.
        
        GpArrayIterator<GpPointF> iSubpath(points, elementCount);
        GpCircularIterator<GpPointF> iCirc(&iSubpath);
        
        // Initialize the first point.
        
        p0 = iCirc.CurrentItem();
        iCirc.Next();
        iter = elementCount;
        first = true;
        
        // include the endpoint wrap if it's closed
        
        if(isClosed)
        {
            iter += 2;
        }
        
        for(i = 1; i < iter; i++)
        {
            // Get the current point.
            
            p1 = iCirc.CurrentItem();
            
            // Translate to the origin and compute the angle between this line
            // and the x axis.
            // atan2 returns values in the -PI..PI range.
            
            v = (*p1)-(*p0);
            currAngle = (REAL)atan2(v.Y, v.X);

            // If we have enough data to do an angle computation, work it out.
            // We require two line segments to do a computation (3 end points).
            // If it's closed, we'll loop around the subpath past the beginning
            // again in order to get the right amount of points.
                       
            if( !first )
            {
                // reverse the direction of the last segment by adding PI and
                // compute the difference.
                
                tempAngle = lastAngle + PI;     // range 0 .. 2PI
                
                // Clamp back to the -PI..PI range
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                // Difference
                
                tempAngle = currAngle - tempAngle;
                
                // Clamp back to the -PI..PI range
                // Note that the extremes are tempAngle either -2PI or 2PI
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                if(tempAngle < -PI)
                {
                    tempAngle += 2*PI;
                }
                
                // new minimum angle?
                // We care about angle magnitude - not sign.
                
                if( minAngle > REALABS(tempAngle) )
                {
                    minAngle = REALABS(tempAngle);
                }
                
            }
            
            // iterate
            
            first = false;
            lastAngle = currAngle;
            iCirc.Next();
            p0 = p1;
        }
    }
    
    SharpestAngle = minAngle;
    CacheFlags |= kSharpestAngleValid;
}

GpStatus
GpPath::GetBounds(
    GpRectF *bounds,                // Resulting bounds in device-space
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    ASSERT(IsValid());

    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if ((count == 0) || (point == NULL))
    {
        bounds->X = 0;
        bounds->Y = 0;
        bounds->Width = 0;
        bounds->Height = 0;
    }
    else
    {
        REAL left, right, top, bottom;

        UpdateCacheBounds();

        left = CacheBounds.X;
        right = left + CacheBounds.Width;
        top = CacheBounds.Y;
        bottom = top + CacheBounds.Height;

        TransformBounds(matrix, left, top, right, bottom, bounds);

        if(pen)
        {
            BOOL needsJoinDelta = TRUE, needsCapDelta = TRUE;

            if(count <= 2)
                needsJoinDelta = FALSE;

            // Make a quick check for closure only when the path has
            // only 1 subpath.  When there are multiple subpaths,
            // simply calclate the cap width although all subpaths may
            // be closed.  But the multiple subpath case will be rarer
            // compared with the one subpath case.

            if(SubpathCount == 1 && count > 2)
            {
                if(Types.Last() & PathPointTypeCloseSubpath)
                {
                    // This is closed.

                    needsCapDelta = FALSE;
                }
            }

            REAL delta = 0;
            GpPen* gpPen = GpPen::GetPen(pen);

            if(needsCapDelta)
                delta = gpPen->GetMaximumCapWidth(matrix, dpiX, dpiY);

            if(needsJoinDelta)
            {
                // Since the join might be a miter type, we need to provide the
                // sharpest angle in the path to see how big the join will be.
                // We have the method GetSharpestAngle() that figues this out.
                // But, this is really expensive since you have to iterate over
                // all the points and do some trig. So, lets assume the worst
                // case, which is a really sharp angle (0 rad).
                const REAL sharpestAngle = 0.0f;
                REAL delta1 = gpPen->GetMaximumJoinWidth(
                            sharpestAngle, matrix, dpiX, dpiY);
                if(delta1 > delta)
                    delta = delta1;
            }

            // Only pad the bounds if there is something non-zero to pad
            if (bounds->Width > REAL_EPSILON ||
                bounds->Height > REAL_EPSILON)
            {
                bounds->X -= delta;
                bounds->Y -= delta;
                bounds->Width += 2*delta;
                bounds->Height += 2*delta;
            }

        }
    }

    return Ok;
}

// This code is not used at present and is contributing to our DLL size, so 
// it's removed from compilation. We're keeping this code because we want to 
// revisit it in V2

#if 0
GpPath*
GpPath::GetCombinedPath(
    const GpPath* path,
    CombineMode combineMode,
    BOOL closeAllSubpaths
    )
{
    if(combineMode == CombineModeReplace)
    {
        ASSERTMSG(0, ("CombineModeReplace mode cannot be used."));
        return NULL;    // Replace mode is not allowed.
    }

    return GpPathReconstructor::GetCombinedPath(
                this, path, (PRMode) combineMode, closeAllSubpaths);
}
#endif

/*************************************************\
* AddGlyphPath
* History:
*
*   Sept/23/1999 Xudong Wu [tessiew]
*       Created it.
*
\************************************************/
GpStatus
GpPath::AddGlyphPath(
    GpGlyphPath* glyphPath,
    REAL x,
    REAL y,
    const GpMatrix * matrix
)
{
    ASSERT(IsValid());
    ASSERT(glyphPath->IsValid());

    if (!IsValid() || !glyphPath->IsValid())
        return InvalidParameter;

    INT count = glyphPath->pointCount;

    if (count == 0)  // nothing to add
        return Ok;

    GpPointF* points = (GpPointF*) glyphPath->points;
    BYTE* types = glyphPath->types;

    if (glyphPath->hasBezier)
        HasBezier = TRUE;

    INT origCount = GetPointCount();
    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if (!pointbuf || !typebuf)
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    // apply the font xform

    for (INT i = 0; i < count; i++)
    {
        pointbuf[i] = points[i];
        if (matrix)
            matrix->Transform(pointbuf + i);
        pointbuf[i].X += x;
        pointbuf[i].Y += y;
    }

    GpMemcpy(typebuf, types, count*sizeof(BYTE));
    SubpathCount += glyphPath->curveCount;
    UpdateUid();

    return Ok;
}


/*************************************************\
* AddString()
* History:
*
*   19th Oct 199  dbrown  created
*
\************************************************/
GpStatus
GpPath::AddString(
    const WCHAR          *string,
    INT                   length,
    const GpFontFamily   *family,
    INT                   style,
    REAL                  emSize,
    const RectF          *layoutRect,
    const GpStringFormat *format
)
{
    FPUStateSaver fpuState; // Guarantee initialised FP context
    ASSERT(string && family && layoutRect);

    GpStatus      status;
    GpTextImager *imager;

    status = newTextImager(
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        family,
        style,
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Allow use of simple text imager
    );

    if (status != Ok)
    {
        return status;
    }

    status = imager->AddToPath(this, &PointF(layoutRect->X, layoutRect->Y));
    delete imager;
    UpdateUid();
    return status;
}


// !!! why not convert to a DpRegion and convert it to a path the same way
// as the constructor that takes a DpRegion?
GpPath::GpPath(HRGN hRgn)
{
    ASSERT((hRgn != NULL) && (::GetObjectType(hRgn) == OBJ_REGION));

    InitDefaultState(FillModeWinding);

    ASSERT(IsValid());

    BYTE stackBuffer[1024];

    // If our stack buffer is big enough, get the clipping contents
    // in one gulp:

    RGNDATA *regionBuffer = (RGNDATA*)&stackBuffer[0];
    INT newSize = ::GetRegionData(hRgn, sizeof(stackBuffer), regionBuffer);

    // The spec says that  GetRegionData returns '1' in the event of
    // success, but NT returns the actual number of bytes written if
    // successful, and returns '0' if the buffer wasn't large enough:

    if ((newSize < 1) || (newSize > sizeof(stackBuffer)))
    {
        // Our stack buffer wasn't big enough.  Figure out the required
        // size:

        newSize = ::GetRegionData(hRgn, 0, NULL);
        if (newSize > 1)
        {
            regionBuffer = (RGNDATA*)GpMalloc(newSize);
            if (regionBuffer == NULL)
            {
                SetValid(FALSE);
                return;
            }

            // Initialize to a decent result in the unlikely event of
            // failure of GetRegionData:

            regionBuffer->rdh.nCount = 0;

            ::GetRegionData(hRgn, newSize, regionBuffer);
        }
    }

    // Add the rects from the region to the path

    if(regionBuffer->rdh.nCount > 0)
    {
        if (this->AddRects((RECT*)&(regionBuffer->Buffer[0]),
                           regionBuffer->rdh.nCount) != Ok)
        {
            SetValid(FALSE);
        }
    }

    // Free the temporary buffer if one was allocated:

    if (regionBuffer != (RGNDATA*) &stackBuffer[0])
    {
        GpFree(regionBuffer);
    }
}

// create a path from a GDI+ region
GpPath::GpPath(
    const DpRegion*     region
    )
{
    InitDefaultState(FillModeAlternate);

    if (region == NULL)
    {
        return;
    }

    RegionToPath    convertRegion;
    DynPointArray   pointsArray;

    if (convertRegion.ConvertRegionToPath(region, pointsArray, Types))
    {
        int             count;
        int             i;
        GpPointF *      realPoints;
        GpPoint *       points;

        count  = Types.GetCount();

        if ((count <= 0) || (pointsArray.GetCount() != count) ||
            (!ValidatePathTypes(Types.GetDataBuffer(), count, &SubpathCount, &HasBezier)))
        {
            goto NotValid;
        }
        // else it is valid

        // add all the space for the count in the Points up front
        realPoints = Points.AddMultiple(count);
        if (realPoints == NULL)
        {
            goto NotValid;
        }

        // add the points, converting from int to real
        points = pointsArray.GetDataBuffer();
        i = 0;
        do
        {
            realPoints[i].X = (REAL)points[i].X;
            realPoints[i].Y = (REAL)points[i].Y;
        } while (++i < count);

        SetValid(TRUE);

        // Make sure the first point is the start type.
        ASSERT(Types[0] == PathPointTypeStart);

        return;
    }

NotValid:
    WARNING(("Failed to convert a region to a path"));
    this->Reset();
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Adjust the dash array for dash caps if present.
*
*   Note that unlike line caps, dash caps do not extend the length
*   of the subpath, they are inset. So we shorten the dash segments
*   that draw a line and lengthen the dash segments that are spaces
*   by a factor of 2x the dash unit in order to leave space for the
*   caps that will be added by the widener.
*
*   This fixes Whistler bug #126476.
*
* Arguments:
*
*   [IN] dashCap - dash cap type
*   [IN] dashUnit - dash size - typically the pen width
*   [IN/OUT] dashArray - array containing the dash pattern that is adjusted.
*   [IN] dashCount - count of elements in the dash array
*
* Return Value:
*
*   None.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
\**************************************************************************/

VOID
GpPath::AdjustDashArrayForCaps(
    GpLineCap dashCap,
    REAL dashUnit,
    REAL *dashArray,
    INT dashCount
    ) const
{
    REAL adjustmentLength = 2.0f *
        GetDashCapInsetLength(dashCap, dashUnit);

    if (adjustmentLength > 0.0f)
    {
        const REAL minimumDashValue = dashUnit * 0.001f; // a small number
        for (int i = 0; i < dashCount; i++)
        {
            if (i & 0x1) // index is odd - so this is a space
            {
                // lengthen the spaces
                dashArray[i] += adjustmentLength;
            }
            else // index is even - so this is a line
            {
                // shorten the lines
                dashArray[i] -= adjustmentLength;
                // check if we have made the dash too small
                // (as in the case of 'dots')
                if (dashArray[i] < minimumDashValue)
                {
                    dashArray[i] = minimumDashValue;
                }
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
* Computes the length of the inset required to accomodate a particular
* dash cap type, since dash caps are contained within the dash length.
*
* Arguments:
*
*   [IN] dashCap - dash cap type
*   [IN] dashUnit - pen width
*
* Return Value:
*
*   The amount that a dash needs to be inset on each end in order to
*   accomodate any dash caps.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
\**************************************************************************/

REAL
GpPath::GetDashCapInsetLength(
    GpLineCap dashCap,
    REAL dashUnit
    ) const
{
    REAL insetLength = 0.0f;

	// dash caps can only be flat, round, or triangle
    switch(dashCap)
    {
    case LineCapFlat:
        insetLength = 0.0f;
        break;

    case LineCapRound:
    case LineCapTriangle:
        insetLength = dashUnit * 0.5f;
        break;
   }

   return insetLength;
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a const pointer to the internal SubpathInfoCache. This structure
*   holds the data representing the position and size of each subpath in 
*   the path data structures.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID GpPath::GetSubpathInformation(DynArray<SubpathInfo> **info) const
{
    if((CacheFlags & kSubpathInfoValid) == 0)
    {
        ComputeSubpathInformationCache();
        ASSERT((CacheFlags & kSubpathInfoValid) == kSubpathInfoValid)
    }
    
    *info = &SubpathInfoCache;
}


/**************************************************************************\
*
* Function Description:
*
*   Computes the Subpath information cache and marks it as valid.
*   This code walks the entire path and stores the start and count for
*   each subpath. It also notes if the subpath is closed or open.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/
    
VOID GpPath::ComputeSubpathInformationCache() const
{
    // Get the path data:
    
    GpPointF *points = Points.GetDataBuffer();
    BYTE *types = Types.GetDataBuffer();
    INT count = Points.GetCount();

    // Clear out any old cached subpath state.
    
    SubpathInfoCache.Reset();

    INT i = 0;  // current position in the path.
    INT c = 0;  // current count of the current subpath.

    // <= so that we can implicitly handle the last subpath without
    // duplicating the code for the inner loop.
    
    while(i <= count)
    {
        // i==count means we hit the end - and potentially need to look at
        // the last subpath. Otherwise look at the most recent subpath if 
        // we find a new start marker.
        
        if( ((i==count) || IsStartType(types[i])) && (i != 0))
        {
            // Found a subpath.
            
            SubpathInfo subpathInfo;
            
            subpathInfo.StartIndex = i-c;
            subpathInfo.Count = c;
            subpathInfo.IsClosed = IsClosedType(types[i-1]);
            
            SubpathInfoCache.Add(subpathInfo);
            
            // We're actually on the first point of the next subpath.
            // (or we're about to terminate the loop)
            
            c = 1;
        } 
        else
        {
            c++;
        }
        i++;
    }
    
    // Mark the subpath information cache as valid.
    
    CacheFlags |= kSubpathInfoValid;
}

/**************************************************************************\
*
* Function Description:
*
*   The widener needs to be able to add points one at a time and have it
*   automatically handle the start point. These points are always line segments.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

GpStatus GpPath::AddWidenPoint(const GpPointF &points)
{
    INT origCount = GetPointCount();
    GpStatus statusPoint = Ok;
    GpStatus statusType = Ok;
    
    if(IsSubpathActive)
    {
        // Add the line segment.
        
        BYTE type = PathPointTypeLine;
        statusPoint = Points.Add(points);
        statusType = Types.Add(type);
    }
    else
    {
        // Add the first point and mark the flag.
        
        BYTE type = PathPointTypeStart;
        statusPoint = Points.Add(points);
        statusType = Types.Add(type);
        IsSubpathActive = TRUE;
    }
                     
    // Handle errors.
    
    if( (statusPoint != Ok) ||
        (statusType != Ok) )
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);
        return OutOfMemory;
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\path.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Module Name:
*
*   path.hpp
*
* Abstract:
*
*   Path related declarations
*
* Revision History:
*
*   12/06/1998 davidx
*       Created it.
*
*   06/16/1999 t-wehunt
*       Added RemoveSelfIntersections().
*
\**************************************************************************/

#ifndef _PATH_HPP
#define _PATH_HPP

// This is used by the widener as an internal flag and as a deletion mask for
// the endcap placement code. These two usages do not overlap.

const INT PathPointTypeInternalUse  = 0x40;

/*
// PathPointType is defined in GdiplusEnums.h.
// Internally, we can use 0x40 for the internal use.

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Beizer (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier2    = 2,    // quadratic Beizer
    PathPointTypeBezier3    = 3,    // cubic Bezier
    PathPointTypeBezier4    = 4,    // quartic (4th order) Beizer
    PathPointTypeBezier5    = 5,    // quintic (5th order) Bezier
    PathPointTypeBezier6    = 6     // hexaic (6th order) Bezier
};
*/

class GpGlyphPath;

inline BOOL IsStartType(BYTE type)
{
    return ((type & PathPointTypePathTypeMask) == 
               PathPointTypeStart);
}

inline BOOL IsClosedType(BYTE type)
{
    return ((type & PathPointTypeCloseSubpath) == 
               PathPointTypeCloseSubpath);
}

inline BOOL IsDashType(BYTE type)
{
    return ((type & PathPointTypeDashMode) == 
               PathPointTypeDashMode);
}

class GpPath : public DpPath
{
friend class GpGraphics;
friend class GpPathGradient;

public:

    // Path constructors

    GpPath(GpFillMode fillMode = FillModeAlternate)
    {
        InitDefaultState(fillMode);
        SetValid(TRUE);
    }

    GpPath(const GpPointF* points,
           const BYTE* types,
           INT count,
           GpFillMode fillMode = FillModeAlternate);

    GpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    GpPath(HRGN hRgn);              // create a path from a GDI region handle
    GpPath(const DpRegion* region); // create a path from a GDI+ region

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

    GpPath* Clone() const
    {
        ASSERT(IsValid())

        GpPath* path = new GpPath(this);

        CheckValid(path);
        return path;
    }

    GpStatus Detach(DynPointFArray *points, DynByteArray *types)
    {
        points->ReplaceWith(&Points);
        types->ReplaceWith(&Types);

        InitDefaultState(FillMode);
        return Ok;
    }

    
    GpStatus Reset(GpFillMode fillMode = FillModeAlternate)
    {

        // !!! bhouse We should allow reseting invalid paths

        ASSERT(IsValid());

        InitDefaultState(fillMode);
        return Ok;
    }

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    REAL GetSharpestAngle() const
    {

        if(!(CacheFlags & kSharpestAngleValid))
            CalcSharpestAngle();

        return SharpestAngle;
    }

    // Set a marker at the current location.

    GpStatus SetMarker();

    // Clear all markers.

    GpStatus ClearMarkers();

    // Add lines to the path object

    GpStatus AddLine(const GpPointF& pt1, const GpPointF& pt2)
    {
        GpPointF points[2];

        points[0] = pt1;
        points[1] = pt2;

        return AddLines(points, 2);
    }

    GpStatus AddLine(REAL x1, REAL y1, REAL x2, REAL y2)
    {
        GpPointF points[2];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;

        return AddLines(points, 2);
    }

    GpStatus AddLines(const GpPointF* points, INT count);

    // Add an arc to the path object

    GpStatus AddArc(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddArc(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddArc(rect, startAngle, sweepAngle);
    }

    // Add Bezier curves to the path object

    GpStatus AddBezier(const GpPointF& pt1, const GpPointF& pt2,
                       const GpPointF& pt3, const GpPointF& pt4);
    GpStatus AddBezier(REAL x1, REAL y1, REAL x2, REAL y2,
                       REAL x3, REAL y3, REAL x4, REAL y4);
    GpStatus AddBeziers(const GpPointF* points, INT count);

    // Add cardinal splines to the path object

    GpStatus AddCurve(const GpPointF* points, INT count);
    GpStatus AddCurve(const GpPointF* points, INT count, REAL tension,
                      INT offset, INT numberOfSegments);
    GpStatus AddClosedCurve(const GpPointF* points, INT count);
    GpStatus AddClosedCurve(const GpPointF* points, INT count, REAL tension);

    // Add closed shapes to the path object

    GpStatus AddRects(const GpRectF* rects, INT count);
    GpStatus AddRects(const RECT* rects, INT count);
    GpStatus AddPolygon(const GpPointF* points, INT count);
    GpStatus AddEllipse(const GpRectF& rect);
    GpStatus AddPie(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddRect(const GpRectF& rect)
    {
        return AddRects(&rect, 1);
    }

    GpStatus AddEllipse(REAL x, REAL y, REAL width, REAL height)
    {
        GpRectF rect(x, y, width, height);
        return AddEllipse(rect);
    }

    GpStatus AddPie(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddPie(rect, startAngle, sweepAngle);
    }

    // Add a path to the path object

    GpStatus AddPath(const GpPointF* points, const BYTE* types, INT count,
                        BOOL connect);
    GpStatus AddPath(const GpPath* path, BOOL connect);

    // Reverse the direction of a path.

    GpStatus Reverse();

    GpStatus GetLastPoint(GpPointF* point);


    // Used by the widener.
    
    GpStatus AddWidenPoint(const GpPointF &point);

    // used by font

    GpStatus MoveTo(const GpPointF point);
    GpStatus AddPoints(const GpPointF* points, ULONG count, PathPointType type);
    GpStatus AddGlyphPath(GpGlyphPath *glyphPath, REAL x, REAL y, const GpMatrix * matrix = 0);

    GpStatus AddString(
        const WCHAR          *string,
        INT                   length,
        const GpFontFamily   *family,
        INT                   style,
        REAL                  emSize,
        const RectF          *layoutRect,
        const GpStringFormat *format
    );

    // Get the flatten data.

    virtual GpStatus Flatten(
                DynByteArray* flattenTypes,
                DynPointFArray* flattenPoints,
                const GpMatrix* matrix) const;


    // Flatten this path.
    
    GpStatus Flatten(GpMatrix* matrix = NULL);

    // Get the morph and flatten data.

    GpStatus WarpAndFlatten(
        DynByteArray* flattenTypes,
        DynPointFArray* flattenPoints,
        const GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );

    // Morph and flatten itself.

    GpStatus WarpAndFlattenSelf(
        GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );                  // Morph to the flatten points.

    // Widen the path object

    GpPath*
    GetWidenedPath(
        const GpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased
        ) const;

    GpStatus
    WidenSelf(
        GpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased
        );

    // Get the flattened path.

    virtual const DpPath *
    GetFlattenedPath(
        GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL,
        BOOL isAntiAliased = TRUE,
        REAL dpiX = 0,
        REAL dpiY = 0,
        BOOL regionToPath = TRUE
        ) const;

    // Dreate a dashed path. (override)

    GpPath*
    CreateDashedPath(
        const GpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f
        ) const;

    GpPath*
    CreateDashedPath(
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f
        ) const;

    // Get the open and closed portion of the current path.

    GpPath* GetOpenPath();
    GpPath* GetClosedPath();

    // Determine if the path is empty, i.e. with no points

    BOOL IsEmpty() const
    {
        return GetPointCount() == 0;
    }

    BOOL IsRectangle() const;

    // Determine if path consists of a single polygon/polyline.

    BOOL IsPolygon() const
    {
        return (SubpathCount == 1) && !HasBezier;
    }

    // Return true if the two objects represent identical paths

    BOOL IsEqual(const GpPath* path) const;

    // Transform the path by the specified matrix

    VOID Transform(GpMatrix * matrix);

    VOID SetHasBezier(BOOL _hasBezier)  { HasBezier = _hasBezier; }

    // Hit testing

    GpStatus IsVisible(
        GpPointF* point,
        BOOL* isVisible,
        GpMatrix* matrix = NULL);

    GpStatus IsOutlineVisible(GpPointF* point, BOOL* isVisible, GpPen* pen,
                    GpMatrix* matrix = NULL, REAL dpiX = 0, REAL dpiY = 0);

// This code is not used at present and is contributing to our DLL size, so 
// it's removed from compilation. We're keeping this code because we want to 
// revisit it in V2

#if 0
    // Path reconstruction

    GpPath*
    GetCombinedPath(const GpPath* path, CombineMode combineMode,
        BOOL closeAllSubpaths = FALSE);
#endif

    // DDI entry point handlers for DpPath

    static GpPath* GetPath(const DpPath* path)
    {
        return (GpPath*)(path);
    }

    static DpPath* DriverCreateWidenedPath(
        const DpPath* path,
        const DpPen* pen,
        DpContext* context,
        BOOL removeSelfIntersect,
        BOOL regionToPath
    );
    
    static VOID DriverDeletePath(DpPath* path);

    static DpPath* DriverClonePath(DpPath* path);

    static VOID DriverTransformPath(DpPath* path, GpMatrix* matrix);

    // Remove self intersections from the path.
    GpStatus RemoveSelfIntersections();
    
    // Used for a mark-sweep point deletion algorithm in the path.
    
    VOID EraseMarkedSegments();
    
    virtual VOID GetSubpathInformation(DynArray<SubpathInfo> **info) const;

protected:

    VOID ComputeSubpathInformationCache() const;

    GpPath(const GpPath* path);

    GpPath* GetWidenedPathWithDpPen(
        const DpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased
    ) const;

    GpPath* GetWidenedPathWithDpPenStandard(
        const DpPen* pen,
        GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        DWORD widenFlags = WidenIsAntiAliased,
        BOOL insetPen = FALSE
    ) const;

    BYTE*
    AddPointHelper(
        const GpPointF* points,
        INT count,
        BOOL addClosedFigure
        );

    GpPath*
    GetOpenOrClosedPath(BOOL openPath);

    static GpPointF*
    ConvertSplineToBezierPoints(
        const GpPointF* points,
        INT count,
        INT offset,
        INT numberOfSegments,
        REAL tension,
        INT* bezierCount
        );

    static INT
    GetArcPoints(
        GpPointF* points,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    VOID InitDefaultState(GpFillMode fillMode);

    VOID ResetCacheBounds() const
    {
        CacheFlags = (kCacheBoundsValid | kSharpestAngleValid);
        SharpestAngle = 2;
        CacheBounds.X = 0;
        CacheBounds.Y = 0;
        CacheBounds.Width = 0;
        CacheBounds.Height = 0;
    }

    VOID InvalidateCache() const
    {
        CacheFlags = 0;
    }

    VOID UpdateCacheBounds() const
    {
        if(!(CacheFlags & kCacheBoundsValid))
            CalcCacheBounds();
    }

    VOID CalcCacheBounds() const;
    VOID CalcSharpestAngle() const;

    VOID
    AdjustDashArrayForCaps(
        GpLineCap dashCap,
        REAL dashUnit,
        REAL *dashArray,
        INT dashCount
        ) const;

    REAL
    GetDashCapInsetLength(
        GpLineCap dashCap,
        REAL dashUnit
        ) const;


    // Data Members:
    protected:

    GpLockable Lockable;    // object lock

    enum {
        kCacheBoundsValid = 1,
        kSharpestAngleValid = 2,
        kSubpathInfoValid = 4
    };

    mutable ULONG CacheFlags;
    mutable GpRectF CacheBounds;
    mutable REAL SharpestAngle;
    
    mutable DynArrayIA<SubpathInfo, 16> SubpathInfoCache;
};

class GpPathIterator : public DpPathIterator
{
public:
    GpPathIterator(GpPath* path) : DpPathIterator(path)
    {
    }

    virtual INT GetCount()
    {
        if(IsValid())
            return Count;
        else
            return 0;
    }

    virtual INT GetSubpathCount()
    {
        if(IsValid())
            return SubpathCount;
        else
            return 0;
    }

    // This iterator is not used for the extended path.

    virtual BOOL IsValid() {return (DpPathIterator::IsValid() && !ExtendedPath);}

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

protected:

    GpLockable Lockable;
};

#endif // !_PATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\endcap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   End Cap Creator.
*
* Abstract:
*
*   This module defines a class called GpEndCapCreator. This class is 
*   responsible for constructing a path containing all the custom endcaps
*   and anchor endcaps for a given path. These are correctly transformed
*   and positioned.
*
*   This class is used to create and position all the endcaps for a
*   given path and pen. This class is also responsible for trimming
*   the original path down so that it fits the end caps properly.
*   This class will handle all types of end caps except the base endcaps
*   (round, flat and triangle) which may be used as dash caps.
*   Caps that are handled are CustomCaps and the 3 Anchor caps (round,
*   diamond and arrow). Note that the round anchor cap is distinct from
*   the round base cap.
*
* Created:
*
*   10/09/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

GpEndCapCreator::GpEndCapCreator(
    GpPath *path, 
    DpPen *pen, 
    GpMatrix *m,
    REAL dpi_x, 
    REAL dpi_y,
    bool antialias
)
{
    Path = path;
    Pen = pen;
    if(m) {XForm = *m;}
    XForm.Prepend(pen->Xform);
    DpiX = dpi_x;
    DpiY = dpi_y;
    Antialias = antialias;
    
    StartCap = NULL;
    EndCap = NULL;
    
    switch(Pen->StartCap)
    {
        case LineCapCustom:
        StartCap = static_cast<GpCustomLineCap*>(Pen->CustomStartCap);
        break;
        
        case LineCapArrowAnchor:
        StartCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        StartCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        StartCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;
        
        case LineCapSquareAnchor:
        StartCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };
    
    switch(Pen->EndCap)
    {
        case LineCapCustom:
        EndCap = static_cast<GpCustomLineCap*>(Pen->CustomEndCap);
        break;
        
        case LineCapArrowAnchor:
        EndCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        EndCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        EndCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;

        case LineCapSquareAnchor:
        EndCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };
}

GpEndCapCreator::~GpEndCapCreator()
{
    // If we allocated memory for temporary custom caps, then 
    // throw that memory away.
    
    if(Pen->StartCap != LineCapCustom)
    {
        delete StartCap;
        StartCap = NULL;
    }
    
    if(Pen->EndCap != LineCapCustom)
    {
        delete EndCap;
        EndCap = NULL;
    }
}
    
/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing an ArrowAnchor.
*    This is an equilateral triangle with edge equal to 2. This means
*    that the scaling will create a 2xStrokeWidth cap edge length.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceArrowAnchor()
{
    // the square root of 3
    
    const REAL root3 = 1.732050808f;
    
    // Anti-clockwise definition of an equilateral triangle of side length 2.0f
    // with a vertex on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[3] = {
        GpPointF(0.0f, 0.0f),
        GpPointF(-1.0f, -root3),
        GpPointF(1.0f, -root3)
    };
    
    GpPath arrowAnchor(FillModeWinding);
    arrowAnchor.AddPolygon(points, 3);
    
    // Create the custom line cap. If it fails it will return NULL.
    GpCustomLineCap *cap = new GpCustomLineCap(&arrowAnchor, NULL);
    cap->SetBaseInset(1.0f);
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a DiamondAnchor.
*    This is a square centered on the end point of the path with it's 
*    diagonal along the axis of the spine.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceDiamondAnchor()
{
    // Anti-clockwise definition of a square of diagonal size 2.0f
    // with the center on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[4] = {
        GpPointF(0.0f, 1.0f),
        GpPointF(-1.0f, 0.0f),
        GpPointF(0.0f, -1.0f),
        GpPointF(1.0f, 0.0f)
    };
    
    GpPath diamondAnchor(FillModeWinding);
    diamondAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&diamondAnchor, NULL);
    cap->SetBaseInset(0.0f);
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a SquareAnchor.
*    This is a square that has a 2 unit long diagonal and is centered on 
*    the end point of the path.
*
* Revision History:
*
*   10/17/2000 peterost
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceSquareAnchor()
{    
    const REAL halfRoot2 = 0.7071068f;
    
    const GpPointF points[4] = {
        GpPointF(-halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, halfRoot2),
        GpPointF(-halfRoot2, halfRoot2)
    };
    
    GpPath squareAnchor(FillModeWinding);
    squareAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&squareAnchor, NULL);
    cap->SetBaseInset(0.0f);
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a RoundAnchor.
*    This is a circle centered on the end point of the path.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceRoundAnchor()
{
    // Create the custom line cap. If it fails it will return NULL.
    
    GpPath roundAnchor(FillModeWinding);
    roundAnchor.AddEllipse(-1.0f, -1.0f, 2.0f, 2.0f);
    GpCustomLineCap *cap = new GpCustomLineCap(&roundAnchor, NULL);
    cap->SetBaseInset(0.0f);
    return cap;
}


/**************************************************************************\
*
* Function Description:
*
*   ComputeCapGradient.
*
*   Compute the correct gradient for a line cap of a given length.
*   Work out the direction of the cap from the list of input 
*   points in the path and the length of the cap.
*   Simply put, the direction is the line segment formed by 
*   the end point of the path and the first intersection along the 
*   path with a circle of length "length" and centered at the 
*   first point of the path.
*
* Arguments:
*
*    GpIterator<GpPointF> &pointIterator,
*    BYTE *types,
*    IN  REAL lengthSquared,            length of the cap squared.
*    IN  baseInset,                     amount to draw into the shape.
*    OUT GpVector2D *grad,              output gradient vector
*
*
* Revision History:
*
*   08/23/00 asecchia
*       Created it
*
\**************************************************************************/

void GpEndCapCreator::ComputeCapGradient(
    GpIterator<GpPointF> &pointIterator, 
    BYTE *types,
    IN  REAL lengthSquared,
    IN  REAL baseInset,
    OUT GpVector2D *grad
)
{
    // Start at the beginning of the iterator (end of the list of
    // points if isStartCap is FALSE)
    
    GpPointF *endPoint = pointIterator.CurrentItem();
    GpPointF *curPoint = endPoint;
    INT index;
    bool intersectionFound = false;
    bool priorDeletion = false;
    
    while(!pointIterator.IsDone())
    {
        curPoint = pointIterator.CurrentItem();
        if(lengthSquared < distance_squared(*curPoint, *endPoint))
        {
            intersectionFound = true;
            break;
        }
        
        // Mark this point for deletion by the trimming algorithm.
        
        index = pointIterator.CurrentIndex();
        
        // Check to see if anyone already deleted this segment.
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        priorDeletion = (types[index] & PathPointTypeInternalUse) ==
            PathPointTypeInternalUse;
        
        types[index] |= PathPointTypeInternalUse;
        
        pointIterator.Next();
    }
    
    // Now we have the segment that intersects the base of the arrow.
    // or the last segment.
    
    pointIterator.Prev();
    
    // if we couldn't get the Prev, then we were at the beginning.
    #if DBG
    if(pointIterator.IsDone())
    {
        ONCE(WARNING(("not enough points in array")));
    }
    #endif
    
    // If the intersection was not found we have marked the entire subpath
    // for deletion.
    
    if(intersectionFound && !priorDeletion)
    {
        // We overagressively marked this point for deletion,
        // instead of deleting this point, we're going to move it.
        // Note: we may have found an intersection point in a segment
        // that has already been marked for deletion. Checking priorDeletion
        // here ensures that we don't incorrectly undelete this point.
        
        index = pointIterator.CurrentIndex();
        
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        types[index] &= ~PathPointTypeInternalUse;
    }
    
    GpPointF *prevPoint = pointIterator.CurrentItem();
    GpPointF intersectionPoint;
    
    if(!intersect_circle_line(
        *endPoint,           // center
        lengthSquared,       // radius^2
        *curPoint,           // P0
        *prevPoint,          // P1
        &intersectionPoint
    ))
    {
        // If there is no intersection, then the line segment is likely too 
        // short, so just take the previous point as the intersection.
        // This is our best guess and in this case will give us the slope from
        // the start to end point as the cap direction.
        
        intersectionPoint.X = prevPoint->X;
        intersectionPoint.Y = prevPoint->Y;
    }
    
    // Compute the gradient - and normalize the vector.
    
    *grad = intersectionPoint - *endPoint;
    grad->Normalize();
    
    // Update the point in the path directly.
    GpVector2D v = *prevPoint - intersectionPoint;
    
    *prevPoint = intersectionPoint + (v*(1.0f-baseInset));
}

/**************************************************************************\
*
* Function Description:
*
*   This creates a path containing all the custom end caps for all
*   the open subpaths in the input path.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    caps  -- this is where we put the caps we generate
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/
GpStatus
GpEndCapCreator::CreateCapPath(GpPath **caps)
{
    // Validate our input data.
    
    ASSERT(Pen != NULL);
    ASSERT(Path != NULL);
    ASSERT(caps != NULL);
    ASSERT(*caps == NULL);
    
    // Create our cap path.
    
    *caps = new GpPath(FillModeWinding);
    if(caps==NULL) 
    { 
        return OutOfMemory; 
    }
    
    // Create a path points iterator because our GpPath doesn't know how
    // to iterate over its own data *sigh*
    
    GpPathPointIterator pathIterator(
        const_cast<GpPointF*>(Path->GetPathPoints()),
        const_cast<BYTE*>(Path->GetPathTypes()),
        Path->GetPointCount()
    );
    
    GpSubpathIterator subpathIterator(&pathIterator);
    
    // Loop through all the available subpaths.
    
    while(!subpathIterator.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = subpathIterator.CurrentIndex();
        GpPointF *points = subpathIterator.CurrentItem();
        BYTE *types = subpathIterator.CurrentType();
        subpathIterator.Next();
        INT elementCount = subpathIterator.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pathIterator.Prev();
        
        bool isClosed = 
            ((*(pathIterator.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath);
            
        pathIterator.Next();
        
        // only want to add end caps if this is an open subpath.
        
        if(!isClosed)
        {
            GpPath *startCap = NULL;
            GpPath *endCap = NULL;
        
            // Create the cap using the points and types
            
            GetCapsForSubpath(
                &startCap,
                &endCap,                
                points,
                types,
                elementCount
            );
            
            // Add the cap to our caps path.
            
            (*caps)->AddPath(startCap, FALSE);
            (*caps)->AddPath(endCap, FALSE);
            
            // Clean up the temporary caps for the next iteration.
            
            delete startCap;
            delete endCap;
        }
    }
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*    This takes a pen and sets it up to match the internal Pen, but modified
*    to support stroking the StrokeCap. E.g. the caps are removed to avoid
*    recursive compound capping etc.
*
* Arguments:
*
*   [OUT]    pen       -- this is where we put the pen we generate
*   [IN]     customCap -- input custom cap.
*
* Created:
*
*   10/09/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

VOID GpEndCapCreator::PrepareDpPenForCustomCap(
    DpPen* pen,
    const GpCustomLineCap* customCap
    ) const
{
    ASSERT(pen);

    *pen = *Pen;
    
    pen->StartCap = LineCapFlat;
    pen->EndCap = LineCapFlat;
    pen->Join = LineJoinMiter;
    pen->MiterLimit = 10;
    pen->PenAlignment = PenAlignmentCenter;
    pen->DashStyle = DashStyleSolid;
    pen->DashCap = LineCapFlat;
    pen->DashCount = 0;
    pen->DashOffset = 0;
    pen->DashArray = NULL;
    pen->CompoundCount = 0;
    pen->CompoundArray = NULL;
    pen->CustomEndCap = NULL;
    pen->CustomStartCap = NULL;

    GpLineCap startCap, endCap;
    GpLineJoin lineJoin;

    if(customCap)
    {
        REAL widthScale;

        customCap->GetStrokeCaps(&startCap, &endCap);
        customCap->GetStrokeJoin(&lineJoin);
        customCap->GetWidthScale(&widthScale);

        pen->Width *= widthScale;
        pen->StartCap = startCap;
        pen->EndCap = endCap;
        pen->Join = lineJoin;
    }
}

GpStatus
GpEndCapCreator::SetCustomFillCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;

    startCapPoints->Reset(FALSE);
    startCapTypes->Reset(FALSE);
    endCapPoints->Reset(FALSE);
    endCapTypes->Reset(FALSE);

    INT count;
    GpPointF tangent;
    GpPointF* points;
    BYTE* types;
    REAL width, widthScale;
    
    // Get minimum line width based on the transform currently in effect.
    REAL majorR, minorR, unitScale;
    GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
    unitScale = min(majorR, minorR);

    if(customStartCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customStartCap->GetFillPointCount();
        
        if(count > 0)
        {            
            points = startCapPoints->AddMultiple(count);
            types = startCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                startCapPoints->Reset(FALSE);
                startCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customStartCap->GetWidthScale(&widthScale);
                width = Pen->Width*widthScale;
                
                REAL length = customStartCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customStartCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);

                // Compute the gradient of the cap.
    
                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointIterator,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient           // OUT parameters
                );
                
                tangent.X = -gradient.X;
                tangent.Y = -gradient.Y;

                // Move start point left or right to account for inset
                // pens, if needed.
                GpPointF start;
                switch (Pen->PenAlignment)
                {
                    case PenAlignmentLeft:
                        start.X = startPoint.X + (gradient.Y * width / 2);
                        start.Y = startPoint.Y - (gradient.X * width / 2);
                        break;
                    case PenAlignmentRight:
                        start.X = startPoint.X - (gradient.Y * width / 2);
                        start.Y = startPoint.Y + (gradient.X * width / 2);
                        break;
                    default:
                        start.X = startPoint.X;
                        start.Y = startPoint.Y;
                        break;
                }
                
                customStartCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    start, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }

    if(status == Ok && customEndCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customEndCap->GetFillPointCount();

        if(count > 0)
        {

            points = endCapPoints->AddMultiple(count);
            types = endCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                endCapPoints->Reset(FALSE);
                endCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customEndCap->GetWidthScale(&widthScale);

                width = Pen->Width*widthScale;
                
                REAL length = customEndCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customEndCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);
                
                // Compute the gradient of the cap.

                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                GpReverseIterator<GpPointF> pointReverse(&pointIterator);
                pointReverse.SeekFirst();
    
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointReverse,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient            // OUT parameters
                );
                
                tangent.X = - gradient.X;
                tangent.Y = - gradient.Y;
                
                // Move end point left or right to account for inset
                // pens, if needed.
                GpPointF end;
                switch (Pen->PenAlignment)
                {
                    case PenAlignmentLeft:
                        end.X = endPoint.X - (gradient.Y * width / 2);
                        end.Y = endPoint.Y + (gradient.X * width / 2);
                        break;
                    case PenAlignmentRight:
                        end.X = endPoint.X + (gradient.Y * width / 2);
                        end.Y = endPoint.Y - (gradient.X * width / 2);
                        break;
                    default:
                        end.X = endPoint.X;
                        end.Y = endPoint.Y;
                        break;
                }
                customEndCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    end, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }
    
    return status;
}

GpStatus
GpEndCapCreator::SetCustomStrokeCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;
        
    GpPointF* points = NULL;
    BYTE* types = NULL;

    INT count;
    GpPointF tangent;

    INT startCount = 0;
    INT endCount = 0;

    if(customStartCap)
    {
        startCount = customStartCap->GetStrokePointCount();
    }

    if(customEndCap)
    {
        endCount = customEndCap->GetStrokePointCount();
    }

    INT maxCount = max(startCount, endCount);

    if(maxCount <= 0)
    {
        return Ok;
    }

    points = (GpPointF*) GpMalloc(maxCount*sizeof(GpPointF));
    types = (BYTE*) GpMalloc(maxCount);

    if(!points || !types)
    {
        GpFree(points);
        GpFree(types);

        return OutOfMemory;
    }

    DpPen pen;
    GpPointF* widenedPts;
    INT widenedCount;
    REAL widthScale, width;
    

    if(customStartCap && startCount > 0)
    {
        startCapPoints->Reset(FALSE);
        startCapTypes->Reset(FALSE);
        
        customStartCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customStartCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customStartCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointIterator, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameters
        );
        
        tangent.X = -gradient.X;
        tangent.Y = -gradient.Y;

        customStartCap->GetTransformedStrokeCap(
            points, 
            types, 
            startCount,
            startPoint, 
            tangent, 
            width, 
            width   
        );

        PrepareDpPenForCustomCap(&pen, customStartCap);

        GpPath path(points, types, startCount, FillModeWinding);
        
        if(path.IsValid())
        {        
            GpPath resultPath(FillModeWinding);
            GpPathWidener widener(
                &path,
                &pen, 
                &XForm, 
                FALSE
            );
            widener.Widen(&resultPath);
            resultPath.Detach(startCapPoints, startCapTypes);
        }
    }

    if(customEndCap && endCount > 0)
    {
        endCapPoints->Reset(FALSE);
        endCapTypes->Reset(FALSE);
        
        customEndCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customEndCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customEndCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        GpReverseIterator<GpPointF> pointReverse(&pointIterator);
        pointReverse.SeekFirst();
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointReverse, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameter
        );
        
        tangent.X = - gradient.X;
        tangent.Y = - gradient.Y;
        
        customEndCap->GetTransformedStrokeCap(
            points, 
            types, 
            endCount,
            endPoint, 
            tangent, 
            width, 
            width
        );

        PrepareDpPenForCustomCap(&pen, customEndCap);
        
        GpPath path(points, types, endCount, FillModeWinding);
        
        if(path.IsValid())
        {
            GpPath resultPath(FillModeWinding);
            GpPathWidener widener(
                &path,
                &pen, 
                &XForm, 
                FALSE
            );
            widener.Widen(&resultPath);
            resultPath.Detach(endCapPoints, endCapTypes);
       }
    }

    GpFree(points);
    GpFree(types);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   This creates and returns two GpPaths containing the start and end cap.
*   The two caps are correctly positioned and scaled.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    startCapPath, endCapPath
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/

GpStatus
GpEndCapCreator::GetCapsForSubpath(
    GpPath **startCapPath,
    GpPath **endCapPath,
    GpPointF *centerPoints,
    BYTE *centerTypes,
    INT centerCount
    )
{
    // Validate our input parameters.
    
    ASSERT(startCapPath != NULL);
    ASSERT(endCapPath != NULL);
    ASSERT(*startCapPath == NULL);
    ASSERT(*endCapPath == NULL);

    DynPointFArray startCapPoints;
    DynPointFArray endCapPoints;
    DynByteArray startCapTypes;
    DynByteArray endCapTypes; 
    
    GpPointF startPoint, endPoint;

    startPoint = *(centerPoints);
    endPoint = *(centerPoints + centerCount - 1);
    
    GpStatus status = Ok;

    if(StartCap || EndCap)
    {
        status = SetCustomFillCaps(
            StartCap, 
            EndCap,
            startPoint, 
            endPoint, 
            centerPoints,
            centerTypes,
            centerCount,
            &startCapPoints,
            &endCapPoints,
            &startCapTypes,
            &endCapTypes
        );

        if(status == Ok)
        {
            status = SetCustomStrokeCaps(
                StartCap, 
                EndCap,
                startPoint, 
                endPoint, 
                centerPoints,
                centerTypes,
                centerCount,
                &startCapPoints,
                &endCapPoints,
                &startCapTypes,
                &endCapTypes
            );
        }
    }

    if(startCapPoints.GetCount() > 0)
    {
        *startCapPath = new GpPath(
            startCapPoints.GetDataBuffer(),
            startCapTypes.GetDataBuffer(),
            startCapPoints.GetCount()
        );
        
        if(*startCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(endCapPoints.GetCount() > 0)
    {
        *endCapPath = new GpPath(
            endCapPoints.GetDataBuffer(),
            endCapTypes.GetDataBuffer(),
            endCapPoints.GetCount()
        );
        
        if(*endCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(status != Ok)
    {
        delete *startCapPath;
        delete *endCapPath;
        *startCapPath = NULL;
        *endCapPath = NULL;
        status = OutOfMemory;
    }
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\pen.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Implementation of GpPen class
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Initial placeholders.
*
*   01/06/1999 ikkof
*       Added the implementation of GpGeometricPen.
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

/**************************************************************************\
*
* Function Description:
*
* This converts the given width with the given physical unit to
* the device unit.  You cannot use this function when
* unit is WorldUnit.
*
* Arguments:
*
*   [IN] width  - the width in the given unit.
*   [IN] unit   - the unit of the width (must not be WorldUnit).
*   [IN] dpi    - dots per inch of the device.
*
* Return Value:
*
*   The device width.
*
*   04/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID GpPen::Set(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    if(DevicePen.DashArray)
        GpFree(DevicePen.DashArray);

    if(DevicePen.CompoundArray)
        GpFree(DevicePen.CompoundArray);


    InitDefaultState(penWidth, unit);

    if(Brush)
    {
        SetColor((GpColor *) &color);
    }
    else
    {
        Brush = new GpSolidFill(color);
        DevicePen.Brush = Brush->GetDeviceBrush();
    }

    UpdateUid();
}

GpPen::GpPen(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = new GpSolidFill(color);
    DevicePen.Brush = Brush->GetDeviceBrush();
}

GpPen::GpPen(GpBrush* brush, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = brush->Clone();
    DevicePen.Brush = Brush->GetDeviceBrush();
}

GpPen::GpPen(GpLineTexture* lineTexture, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !!! Needs to be implemented.
    // !!! Remember to change GdipCreatePen3 - it currently just returns
    //     NotImplemented.

    RIP(("GpPen with line texture not implemented"));
    SetValid(FALSE);
}

VOID GpPen::InitDefaultState(REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !! Look at DeviceBrush.Type
    DevicePen.Type = PenTypeSolidColor;
    DevicePen.Width = penWidth;
    DevicePen.Unit = unit;
    DevicePen.StartCap = LineCapFlat;
    DevicePen.EndCap = LineCapFlat;
    DevicePen.Join = LineJoinMiter;
    DevicePen.MiterLimit = 10;    // PS's default miter limit.
    DevicePen.PenAlignment = PenAlignmentCenter;

    DevicePen.DashStyle = DashStyleSolid;
    DevicePen.DashCap = LineCapFlat;
    DevicePen.DashCount = 0;
    DevicePen.DashOffset = 0;
    DevicePen.DashArray = NULL;

    DevicePen.CompoundCount = 0;
    DevicePen.CompoundArray = NULL;

    DevicePen.CustomStartCap = NULL;
    DevicePen.CustomEndCap = NULL;

    DevicePen.Xform.Reset();
    
    SetValid(TRUE);
    UpdateUid();
}

GpPen::GpPen(const GpPen* pen)
{
    GpStatus status = Ok;

    if(pen && pen->IsValid())
    {
        // Copy the base state.
        
        DevicePen = pen->DevicePen;
        
        // Don't copy pointer references to other objects.
        
        Brush = NULL;
        DevicePen.Brush = NULL;
        DevicePen.DashArray = NULL;
        DevicePen.CompoundArray = NULL;
        DevicePen.CustomStartCap = NULL;
        DevicePen.CustomEndCap = NULL;
        
        // Explicitly clone the pointer references to other objects.

        if(pen->Brush)
        {
            Brush = pen->Brush->Clone();
            DevicePen.Brush = Brush->GetDeviceBrush();
        }
        else
        {
            status = GenericError;
        }

        if( status == Ok )
        {   
            if( (pen->DevicePen.DashArray) && 
                (DevicePen.DashCount > 0)
            )
            {
                DevicePen.DashArray = (REAL*) GpMalloc(DevicePen.DashCount*sizeof(REAL));
                if(DevicePen.DashArray)
                {
                    GpMemcpy(DevicePen.DashArray, pen->DevicePen.DashArray, DevicePen.DashCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                // If there is no dash array data, this must be a solid line.
                
                ASSERT(DevicePen.DashStyle == DashStyleSolid);
    
                DevicePen.DashCount = 0;
                DevicePen.DashArray = NULL;
            }
        }

        // Set the compound array if necessary.

        if( status == Ok )
        {
            if( (pen->DevicePen.CompoundArray) && 
                (DevicePen.CompoundCount > 0)
            )
            {
                DevicePen.CompoundArray = (REAL*) GpMalloc(DevicePen.CompoundCount*sizeof(REAL));
                if(DevicePen.CompoundArray)
                {
                    GpMemcpy(DevicePen.CompoundArray, pen->DevicePen.CompoundArray, DevicePen.CompoundCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                DevicePen.CompoundCount = 0;
                DevicePen.CompoundArray = NULL;
            }
        }
        
        // Copy the start custom cap.

        if( status == Ok )
        {
            if( DevicePen.StartCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomStartCap == NULL)
                {
                    WARNING1("CustomStartCap type with NULL pointer");
                    DevicePen.StartCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomStartCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomStartCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }
        
        // Copy the end custom cap.

        if( status == Ok )
        {
            if( DevicePen.EndCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomEndCap == NULL)
                {
                    WARNING1("CustomEndCap type with NULL pointer");
                    DevicePen.EndCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomEndCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomEndCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }

    }
    else
    {
        // Can't make a valid pen from an invalid input pen.
        
        status = GenericError;    
    }
    
    if(status == Ok)
    {
        SetValid(TRUE);
    }
    else
    {
        // Failed cloning the pen.
        
        // Clean up possible memory allocation so we don't leak even under
        // low memory conditions. Note we rely on GpFree and delete handling
        // NULL pointers here.
        
        delete Brush;
        Brush = NULL;                   // InitializeDefaultState() does not set
        DevicePen.Brush = NULL;         // these fields - clear them explicitly.
        
        GpFree(DevicePen.DashArray);
        GpFree(DevicePen.CompoundArray);
        
        delete DevicePen.CustomStartCap;
        delete DevicePen.CustomEndCap;
        
        // Clean the pen.
        
        InitDefaultState(1.0f, UnitWorld);
        
        // This is not a valid object.
        
        SetValid(FALSE);
    }
}

// Clone() return NULL if the cloning fails.

GpPen* GpPen::Clone()
{
    GpPen* clonedPen =  new GpPen(this);

    if(clonedPen && clonedPen->IsValid())
        return clonedPen;
    else
    {
        if(clonedPen)
            delete clonedPen;
        return NULL;
    }
}

GpStatus
GpPen::GetMaximumWidth(
        REAL* width,
        const GpMatrix* matrix) const
{
    if(DevicePen.Unit != UnitWorld)
        return InvalidParameter;

    GpMatrix trans;
    if(matrix)
        trans = *matrix;

    if(!DevicePen.Xform.IsTranslate())
        trans.Prepend(DevicePen.Xform);

    REAL majorR, minorR;

    ::GetMajorAndMinorAxis(&majorR, &minorR, &trans);
    majorR *= DevicePen.Width;
    minorR *= DevicePen.Width;

    if(minorR < 1.42f)   // This is a litte bit larger than sqrt(2).
    {
        minorR = 1.42f;
        majorR = 1.42f;
    }

    *width = majorR;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This function takes a join angle and computes the length of the miter
*   based on this angle and a given miter length limit.
*   This can be scaled by the pen width to give the length of an arbitrary
*   pen miter.
*
*   In this picture, 2a is the angle of the join. The pen width is w and the 
*   desired output is the length of the miter join (l).
*
*   Note that the line labled w is perpendecular to the inside and outside 
*   widended lines. Then the formula is derived as follows:
*
*         sin(a) = w/l   [opposite over hypotenuse on right angled triangle]
*    <=>  l = w/sin(a)
*
*
*                     /|\
*                    /a|a\
*                   /  |  \
*                  /   |   \
*                 /    |l   \
*                /     |     \ <-- right angle
*               /--__  |  __--\
*              /   w --|-- w   \
*             /       / \       \
*            /       /   \       \
*        outside     inside     outside
*
* NOTE: 
*
*   This routine returns the miter length (l) for a pen width w==1.0f. 
*   The caller is responsible for scaling length by the pen width.
*
*   If the length of 1/sin(a) is greater than the miterLimit, the miterLimit
*   is returned. (including infinite length joins).
*                        
* Arguments:
*
*   [IN] angle      - join angle in radians
*   [IN] miterLimit - maximum miter length (not scaled by pen width).
*
* Return Value:
*
*   Pen width independent miter length.
*
*   10/02/2000 asecchia
*       Created it.
*
\**************************************************************************/


REAL GpPen::ComputeMiterLength(
    REAL angle,
    REAL miterLimit
    )
{
    // use the simple miter join formula 
    // length = (penwidth)/sin(angle/2)
    // because we're pen independent, use 1.0 for pen width and rely
    // on the caller to scale by the pen width.
    
    REAL length = (REAL)sin(0.5*angle);
    
    // Check for an infinite miter...
    
    if(REALABS(length) < REAL_EPSILON)
    {
        return miterLimit;
    }
    
    length = 1.0f / length;
    
    return min(miterLimit, length);
}



REAL
GpPen::GetMaximumJoinWidth(
        REAL sharpestAngle,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY) const
{
    REAL delta;

    if ((matrix != NULL) && (DevicePen.IsOnePixelWideSolid(matrix, dpiX)))
    {
        delta = 0.5;
    }
    else
    {
        REAL maximumWidth;
        REAL delta0;

        REAL scale = 1.0;

        switch(DevicePen.PenAlignment)
        {
        case PenAlignmentCenter:
            scale = 0.5f;
            break;

        case PenAlignmentLeft:
        case PenAlignmentRight:
            scale = 1.0f;
            break;

        case PenAlignmentInset:
            scale = 0.0f;
            break;

        case PenAlignmentOutset:
            scale = 1.0f;
            break;
        }

        if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
        {
            delta0 = maximumWidth;
        }
        else
        {
            maximumWidth = ::GetDeviceWidth(
                                DevicePen.Width,
                                DevicePen.Unit,
                                dpiX);
            delta0 = maximumWidth;
        }

        if(DevicePen.Join == LineJoinMiter)
        {
            REAL miterLimit = DevicePen.MiterLimit;

            delta = delta0*miterLimit;

            if(delta > 20)
            {
                delta = ComputeMiterLength(
                    sharpestAngle,
                    miterLimit
                );

                // scale by the pen width.
                
                delta *= delta0;
            }
        }
        else
        {
            delta = delta0;
        }

        delta *= scale;
    }

    return delta;
}

REAL
GpPen::GetMaximumCapWidth(
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY) const
{
    REAL maximumWidth;
    REAL delta0;

    if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
    {
        delta0 = maximumWidth;
    }
    else
    {
        maximumWidth = ::GetDeviceWidth(
                            DevicePen.Width,
                            DevicePen.Unit,
                            dpiX);
        delta0 = maximumWidth;
    }

    REAL delta = delta0;

    GpLineCap startCap = DevicePen.StartCap;
    GpLineCap endCap = DevicePen.EndCap;

    REAL delta1;

    GpCustomLineCap* customCap = NULL;

    if(startCap == LineCapCustom && DevicePen.CustomStartCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomStartCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(startCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 1);
    }
    if(delta < delta1)
        delta = delta1;


    if(endCap == LineCapCustom && DevicePen.CustomEndCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomEndCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(endCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 2);
    }
    if(delta < delta1)
        delta = delta1;

    return delta;
}

VOID
GpPen::SetDashCap(GpDashCap dashCap)
{
    // Note: Internally we use a GpLineCap type to store the dash cap type.
    // So we need to convert between GpLineCap and GpDashCap.
    // However, we should change the internal usage to GpDashCap in v2.
    // - JBronsk
    GpLineCap lineCap = LineCapFlat;
    switch (dashCap)
    {
    case DashCapRound:
    	lineCap = LineCapRound;
    	break;
    case DashCapTriangle:
    	lineCap = LineCapTriangle;
    	break;
    // all others map to LineCapFlat
    }
    
    GpStatus status = SetDashStyleWithDashCap(DevicePen.DashStyle, lineCap);
    if(status == Ok)
    {
        DevicePen.DashCap = lineCap;
    }
}

#ifndef DCR_REMOVE_OLD_197819
VOID
GpPen::SetDashCap(GpLineCap dashCap)
{
    #ifdef DCR_DISABLE_OLD_197819
    WARNING(("DCR: Using disabled functionality 197819"));
    #endif // DCR_DISABLE_OLD_197819
    GpStatus status = SetDashStyleWithDashCap(DevicePen.DashStyle, dashCap);
    if(status == Ok)
        DevicePen.DashCap = dashCap;
}
#endif // DCR_REMOVE_OLD_197819

GpStatus
GpPen::SetDashStyle(
    GpDashStyle dashStyle
    )
{
    return SetDashStyleWithDashCap(dashStyle, DevicePen.DashCap);
}

GpStatus
GpPen::SetDashStyleWithDashCap(
    GpDashStyle dashStyle,
    GpLineCap dashCap
    )
{
    GpStatus status = Ok;
    REAL    style[6];
    INT     count;

    switch(dashStyle)
    {
    case DashStyleSolid:
        count = 0;
        break;

    case DashStyleDash:
        count = 2;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        break;

    case DashStyleDot:
        count = 2;
        style[0] = 1;   // a dot
        style[1] = 1;   // a space
        break;

    case DashStyleDashDot:
        count = 4;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        break;

    case DashStyleDashDotDot:
        count = 6;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        style[4] = 1;   // a dot
        style[5] = 1;   // a space
        break;
    
    case DashStyleCustom:
        
        // We assume that the custom dash has been set at the API.
        // The remaining code in this routine is for initializing an appropriate
        // dash array, which we already have in this case, so we're done.
        
        DevicePen.DashStyle = dashStyle;
        return Ok;

    default:
        // The dash style must be one of the predefined ones.
        status = InvalidParameter;
    }

    if(status != Ok)
    {
        return status;
    }

    if(DevicePen.DashCount < count)
    {
        REAL* newArray = (REAL*) GpMalloc(count*sizeof(REAL));

        if(newArray)
        {
            GpFree(DevicePen.DashArray);
            DevicePen.DashArray = newArray;
        }
        else
        {
            status = OutOfMemory;
        }
    }

    if(status == Ok)
    {
        // initialize the DashArray.
        GpMemcpy(DevicePen.DashArray, &style[0], count*sizeof(REAL));
        DevicePen.DashStyle = dashStyle;
        DevicePen.DashCount = count;
        UpdateUid();
    }

    return status;
}

GpStatus
GpPen::SetDashArray(
    const REAL* dashArray,
    INT count
    )
{
    ASSERT(dashArray && count > 0);

    // Make sure the all elements are positive.
    INT         i = 0;
    GpStatus    status = Ok;

    while(status == Ok && i < count)
    {
        if(dashArray[i++] <= 0)
            status = InvalidParameter;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.DashArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, dashArray, count*sizeof(REAL));

    DevicePen.DashStyle = DashStyleCustom;
    DevicePen.DashArray = newArray;
    DevicePen.DashCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetDashArray(
    REAL* dashArray,
    INT count
    ) const
{
    ASSERT(dashArray != NULL && count <= DevicePen.DashCount);

    GpStatus status = Ok;

    if(dashArray == NULL || count > DevicePen.DashCount)
        return InvalidParameter;

    if(DevicePen.DashArray)
        GpMemcpy(dashArray, DevicePen.DashArray, count*sizeof(REAL));
    else
        status = OutOfMemory;

    return status;
}

GpStatus
GpPen::SetCompoundArray(
    const REAL* compoundArray,
    INT count
    )
{
    ASSERT(compoundArray && count > 0);

    // count must be a positive even number.

    if(compoundArray == NULL || count <= 0 || (count & 0x01))
        return InvalidParameter;

    // Make sure the all elements are monitonically increasing
    // and its values are between 0 and 1.

    GpStatus    status = Ok;
    REAL        lastValue, nextValue;

    lastValue = compoundArray[0];
    if(lastValue < 0.0f || lastValue > 1.0f)
        status = InvalidParameter;

    INT i = 1;

    while(status == Ok && i < count)
    {
        nextValue = compoundArray[i++];
        if(nextValue < lastValue || nextValue > 1.0f)
            status = InvalidParameter;

        lastValue = nextValue;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.CompoundArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, compoundArray, count*sizeof(REAL));

    DevicePen.CompoundArray = newArray;
    DevicePen.CompoundCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetCompoundArray(
    REAL* compoundArray,
    INT count
    )
{
    ASSERT(compoundArray != NULL && count <= DevicePen.CompoundCount);

    if(compoundArray == NULL || count > DevicePen.CompoundCount)
        return InvalidParameter;

    if(DevicePen.CompoundArray && count > 0)
        GpMemcpy(compoundArray, DevicePen.CompoundArray, count*sizeof(REAL));

    return Ok;
}

GpStatus
GpPen::SetCustomStartCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomStartCap = NULL;
    DevicePen.StartCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomStartCap = customCap->Clone();
        DevicePen.StartCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomStartCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomStartCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomStartCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::SetCustomEndCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomEndCap = NULL;
    DevicePen.EndCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomEndCap = customCap->Clone();
        DevicePen.EndCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomEndCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomEndCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomEndCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::MultiplyTransform(const GpMatrix& matrix,
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (matrix.IsInvertible())
    {
        if (order == MatrixOrderPrepend)
        {
            DevicePen.Xform.Prepend(matrix);
        }
        else
        {
            DevicePen.Xform.Append(matrix);
        }
    }
    else
        status = InvalidParameter;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Answer true if the two pen instances are equivalent, meaning they
*   are indistinguishable when rendering.
*
* Arguments:
*
*   [IN] pen - pen to compare this against

* Return Value:
*
*   TRUE if equivalent.
*
* Created:
*
*   6/14/1999 peterost
*
\**************************************************************************/

BOOL
GpPen::IsEqual(
    const GpPen *  pen
    )
    const
{
    ASSERT(pen != NULL);

    if (pen == this)
        return TRUE;

    BOOL isEqual = TRUE;

    if (DevicePen.IsEqual(&pen->DevicePen) &&
        DevicePen.DashStyle == pen->DevicePen.DashStyle &&
        DevicePen.CompoundCount == pen->DevicePen.CompoundCount &&
        Brush->IsEqual(pen->Brush) &&
        DevicePen.Xform.IsEqual(&pen->DevicePen.Xform))
    {
        // We need to check the equality further if the dash style
        // is not a solid line.

        if (DevicePen.DashStyle != DashStyleSolid)
        {
            if(DevicePen.DashStyle != DashStyleCustom)
            {
                // A case of the preset dash pattern.
                // Check only for the offset difference.

                if(DevicePen.DashOffset != pen->DevicePen.DashOffset)
                    isEqual = FALSE;
            }
            else
            {
                if (DevicePen.DashCount == pen->DevicePen.DashCount &&
                    DevicePen.DashOffset == pen->DevicePen.DashOffset &&
                    DevicePen.DashArray != NULL &&
                    pen->DevicePen.DashArray != NULL)
                {
                    INT i = 0;

                    while(i < DevicePen.DashCount && isEqual)
                    {
                        if (DevicePen.DashArray[i] != pen->DevicePen.DashArray[i])
                        {
                            isEqual = FALSE;
                        }
                        i++;
                    }
                }
                else
                {
                    isEqual = FALSE;
                }
            }
        }

        // Check for the compound lines.

        if(isEqual && DevicePen.CompoundCount > 0)
        {
            if(DevicePen.CompoundArray && pen->DevicePen.CompoundArray)
            {
                INT j = 0;

                while(j < DevicePen.CompoundCount && isEqual)
                {
                    if(DevicePen.CompoundArray[j] != pen->DevicePen.CompoundArray[j])
                    {
                        isEqual = FALSE;
                    }
                    j++;
                }
            }
            else
            {
                isEqual = FALSE;
            }
        }
    }
    else
    {
        isEqual = FALSE;
    }

    return isEqual;
}

// For GetData and SetData methods
#define GDIP_PENFLAGS_TRANSFORM             0x00000001
#define GDIP_PENFLAGS_STARTCAP              0x00000002
#define GDIP_PENFLAGS_ENDCAP                0x00000004
#define GDIP_PENFLAGS_JOIN                  0x00000008
#define GDIP_PENFLAGS_MITERLIMIT            0x00000010
#define GDIP_PENFLAGS_DASHSTYLE             0x00000020
#define GDIP_PENFLAGS_DASHCAP               0x00000040
#define GDIP_PENFLAGS_DASHOFFSET            0x00000080
#define GDIP_PENFLAGS_DASHARRAY             0x00000100
#define GDIP_PENFLAGS_NONCENTER             0x00000200
#define GDIP_PENFLAGS_COMPOUNDARRAY         0x00000400
#define GDIP_PENFLAGS_CUSTOMSTARTCAP        0x00000800
#define GDIP_PENFLAGS_CUSTOMENDCAP          0x00001000

class PenData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Unit;
    REAL        Width;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the pen data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::GetData(
    IStream *   stream
    ) const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return Ok;
    }

    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (!DevicePen.Xform.IsIdentity())
    {
        flags |= GDIP_PENFLAGS_TRANSFORM;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_STARTCAP | GDIP_PENFLAGS_CUSTOMSTARTCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_STARTCAP;
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_ENDCAP | GDIP_PENFLAGS_CUSTOMENDCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_ENDCAP;
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        flags |= GDIP_PENFLAGS_JOIN;
    }

    if (DevicePen.MiterLimit != 10)
    {
        flags |= GDIP_PENFLAGS_MITERLIMIT;
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        flags |= GDIP_PENFLAGS_DASHSTYLE;
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        flags |= GDIP_PENFLAGS_DASHCAP;
    }

    if (DevicePen.DashOffset != 0)
    {
        flags |= GDIP_PENFLAGS_DASHOFFSET;
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        flags |= GDIP_PENFLAGS_DASHARRAY;
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        flags |= GDIP_PENFLAGS_NONCENTER;
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        flags |= GDIP_PENFLAGS_COMPOUNDARRAY;
    }

    PenData     penData;
    penData.Type  = DevicePen.Type;
    penData.Flags = flags;
    penData.Unit  = DevicePen.Unit;
    penData.Width = DevicePen.Width;
    stream->Write(&penData, sizeof(penData), NULL);

    if (flags & GDIP_PENFLAGS_TRANSFORM)
    {
        DevicePen.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_PENFLAGS_STARTCAP)
    {
        stream->Write(&DevicePen.StartCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_ENDCAP)
    {
        stream->Write(&DevicePen.EndCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_JOIN)
    {
        stream->Write(&DevicePen.Join, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        stream->Write(&DevicePen.MiterLimit, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        stream->Write(&DevicePen.DashStyle, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHCAP)
    {
        stream->Write(&DevicePen.DashCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        stream->Write(&DevicePen.DashOffset, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHARRAY)
    {
        stream->Write(&DevicePen.DashCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.DashArray, DevicePen.DashCount * sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_NONCENTER)
    {
        stream->Write(&DevicePen.PenAlignment, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        stream->Write(&DevicePen.CompoundCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.CompoundArray, DevicePen.CompoundCount * sizeof(REAL), NULL);
    }

    GpStatus status;

    if (flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        stream->Write(&customStartCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomStartCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    if (flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        stream->Write(&customEndCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomEndCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    status = Brush->GetData(stream);

    return status;
}

UINT
GpPen::GetDataSize() const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return 0;
    }

    UINT        dataSize = sizeof(PenData);

    if (!DevicePen.Xform.IsIdentity())
    {
        dataSize += GDIP_MATRIX_SIZE;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                // startcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customStartCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                // endcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customEndCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.MiterLimit != 10)
    {
        dataSize += sizeof(REAL);
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashOffset != 0)
    {
        dataSize += sizeof(REAL);
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.DashCount * sizeof(REAL));
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        dataSize += sizeof(INT32);
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.CompoundCount * sizeof(REAL));
    }

    dataSize += Brush->GetDataSize();

    return dataSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the pen object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(PenData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const PenData *     penData = reinterpret_cast<const PenData *>(dataBuffer);

    if (!penData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    InitDefaultState(penData->Width, static_cast<GpUnit>(penData->Unit));

    dataBuffer += sizeof(PenData);
    size       -= sizeof(PenData);

    if (penData->Flags & GDIP_PENFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (penData->Flags & GDIP_PENFLAGS_STARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.StartCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_ENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.EndCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_JOIN)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Join = (GpLineJoin) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.MiterLimit = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashStyle((GpDashStyle)((INT32 *)dataBuffer)[0]);
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashOffset = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_NONCENTER)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.PenAlignment = (GpPenAlignment) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        this->SetCompoundArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomStartCap == NULL);
        DevicePen.CustomStartCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomStartCap == NULL) ||
            (DevicePen.CustomStartCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomStartCap->IsValid())
        {
            WARNING(("Failure getting CustomStartCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomEndCap == NULL);
        DevicePen.CustomEndCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomEndCap == NULL) ||
            (DevicePen.CustomEndCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomEndCap->IsValid())
        {
            WARNING(("Failure getting CustomEndCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (Brush != NULL)
    {
        Brush->Dispose();
        Brush = NULL;
    }

    if (size >= sizeof(ObjectTypeData))
    {
        Brush = (GpBrush *)GpObject::Factory(ObjectTypeBrush, (const ObjectData *)dataBuffer, size);
        if (Brush != NULL)
        {
            if ((Brush->SetData(dataBuffer, size) == Ok) && Brush->IsValid())
            {
                DevicePen.Brush = Brush->GetDeviceBrush();
                SetValid(TRUE);
                UpdateUid();
                return Ok;
            }
            Brush->Dispose();
            Brush = NULL;
        }
    }
    WARNING(("Failure getting brush"));

ErrorExit:
    SetValid(FALSE);
    return GenericError;
}

GpStatus
GpPen::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    ASSERT(recolor != NULL);
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypePen;
    }

    if (Brush != NULL)
    {
        Brush->ColorAdjust(recolor, type);
    }

    return Ok;
}

GpStatus
GpPen::GetColor(
    ARGB *argb
    ) const
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        *argb = solidBrush->GetColor().GetValue();

        return Ok;
    }

    return InvalidParameter;
}

GpStatus
GpPen::SetColor(
    GpColor *       color
    )
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        if (solidBrush->GetColor().GetValue() == color->GetValue())
        {
            return Ok;
        }

        // !!! bhouse why do we allocate another brush just to change the
        // pen's color !!!!
    }

    GpSolidFill *newBrush = new GpSolidFill(*color);

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }

    return GenericError;

}

GpStatus
GpPen::SetBrush(
    GpBrush *       brush
    )
{
    // Don't set the brush if it is the same color as the current one,
    // because that makes metafiles unnecessarily large.
    if ((Brush->GetBrushType() == BrushTypeSolidColor) &&
        (brush->GetBrushType() == BrushTypeSolidColor))
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;
        GpSolidFill * newSolidBrush = (GpSolidFill *) brush;

        if(solidBrush->GetColor().GetValue() ==
           newSolidBrush->GetColor().GetValue())
        {
            return Ok;
        }
    }

    GpBrush *   newBrush = brush->Clone();

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }
    return GenericError;
}

GpPenType
GpPen::GetPenType(
    )
{
    GpPenType type = PenTypeUnknown;

    if(Brush)
    {
        switch(Brush->GetBrushType())
        {
        case BrushTypeSolidColor:
            type = PenTypeSolidColor;
            break;

        case BrushTypeHatchFill:
            type = PenTypeHatchFill;
            break;

        case BrushTypeTextureFill:
            type = PenTypeTextureFill;
            break;
/*
        case BrushRectGrad:
            type = PenFillRectGrad;
            break;

        case BrushRadialGrad:
            type = PenFillRadialGrad;
            break;

        case BrushTriangleGrad:
            type = PenFillTriangleGrad;
            break;
*/
        case BrushTypePathGradient:
            type = PenTypePathGradient;
            break;

        case BrushTypeLinearGradient:
            type = PenTypeLinearGradient;
            break;

        default:
            break;
        }
    }

    // We must implement LineTexture case.

    return type;
}

/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a solid
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   12/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWideSolid(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    return this->IsOnePixelWide(worldToDevice, dpiX) && this->IsSimple();
}

/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a one
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   10/6/2000 - peterost - factored out fron IsOnePixelWideSolid
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWide(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    BOOL useOnePixelPath = FALSE;

    const REAL minimumPenWidth = 1.5f;

    // !!![andrewgo] This determination of a single pixel wide line is
    //               unbelievably expensive

    // !!![andrewgo] This width check should be done simply using
    //               the world-to-device transform!  It would be
    //               faster and simpler!

    REAL width = this->Width;
    GpUnit unit = this->Unit;

    if(unit == UnitWorld)
    {
        if(worldToDevice == NULL || worldToDevice->IsTranslate())
        {
            if(width <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else if(worldToDevice->IsTranslateScale())
        {
            REAL m11 = worldToDevice->GetM11();
            REAL m22 = worldToDevice->GetM22();
            REAL maxScale = max(REALABS(m11), REALABS(m22));

            if(width*maxScale <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else
        {
            // This is a general transform.

            REAL majorR, minorR;    // Radii for major and minor axis.

            if(::GetMajorAndMinorAxis(
                &majorR,
                &minorR,
                worldToDevice) == Ok)
            {
                if(width*majorR <= minimumPenWidth)
                    useOnePixelPath = TRUE;
            }
        }
    }
    else
    {
        // Since GDI+ only uses the World Uinit, this code is not called
        // any more.

        width = ::GetDeviceWidth(width, unit, dpiX);
        if(width <= minimumPenWidth)
            useOnePixelPath = TRUE;
    }

    return useOnePixelPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\pathwidener.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.hpp
*
* Abstract:
*
*   Class used for Path widening
*
* Revision History:
*
*   11/24/99 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _PATHWIDENER_HPP
#define _PATHWIDENER_HPP

class GpPathWidener
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPathWidener : ObjectTagInvalid;
    }

public:

    GpPathWidener(
        GpPath *path,
        const DpPen* pen,
        GpMatrix *matrix,
        BOOL doubleCaps = FALSE  // used for inset pens.
    );

    ~GpPathWidener()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    GpStatus Widen(GpPath *path);
    GpStatus Widen(DynPointFArray *points, DynByteArray *types);

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagPathWidener) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid PathWidener");
        }
    #endif

        return (Tag == ObjectTagPathWidener);
    }

protected:
    
    VOID GpPathWidener::ComputeSubpathNormals(
        DynArray<GpVector2D> *normalArray,
        const INT count,
        const BOOL isClosed,
        const GpPointF *points
    );
    
    GpStatus GpPathWidener::ComputeNonDegeneratePoints(
        DynArray<GpPointF> *filteredPoints,
        const GpPath::SubpathInfo &subpath,
        const GpPointF *points
    );
    

protected:

    GpPath *Path;
    const DpPen* Pen;
    GpMatrix XForm;
    REAL StrokeWidth;
    BOOL DoubleCaps;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\geometry.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Geometry: Some 2D geometry helper routines.
*
* Created:
*
*   08/26/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _GEOMETRY_HPP
#define _GEOMETRY_HPP


// return the square of the distance between point 1 and point 2.

inline REAL distance_squared(const GpPointF &p1, const GpPointF &p2)
{
    return ((p1.X-p2.X)*(p1.X-p2.X)+(p1.Y-p2.Y)*(p1.Y-p2.Y));
}

// return the dot product of two points treated as 2-vectors.

inline double dot_product(const GpPointF &a, const GpPointF &b)
{
    return (a.X*b.X + a.Y*b.Y);
}

// Return the intersection of a line specified by p0-p1 along the
// y axis. Returns FALSE if p0-p1 is parallel to the yaxis.
// Only returns intersections between p0 and p1 (inclusive).

BOOL intersect_line_yaxis(
    IN  const GpPointF &p0,
    IN  const GpPointF &p1,
    OUT REAL *length
);

// Return the intersection of a line p0-p1 with the line r0-r1
// The return value

BOOL IntersectLines(
    IN const GpPointF &line1Start,
    IN const GpPointF &line1End,
    IN const GpPointF &line2Start,
    IN const GpPointF &line2End,
    OUT REAL *line1Length,
    OUT REAL *line2Length,
    OUT GpPointF *intersectionPoint
);


INT intersect_circle_line(
    IN  const GpPointF &C,      // center
    IN  REAL radius2,           // radius * radius  (i.e. squared)
    IN  const GpPointF &P0,     // line first point (origin)
    IN  const GpPointF &P1,     // line last point (end)
    OUT GpPointF *intersection  // return intersection point.
);

// Return true if point is inside the polygon defined by poly and count.
// Use the FillModeAlternate (even-odd) rule.

BOOL PointInPolygonAlternate(
    GpPointF point,
    INT count, 
    GpPointF *poly
);

GpStatus GetFastAngle(REAL* angle, const GpPointF& vector);


class GpVector2D : public GpPointF
{
    public:
    GpVector2D()
    {
        X = Y = 0.0f;
    }

    GpVector2D(IN const PointF &point)
    {
        X = point.X;
        Y = point.Y;
    } 
    
    GpVector2D(IN const GpVector2D &vec)
    {
        X = vec.X;
        Y = vec.Y;
    } 

    GpVector2D(IN REAL x, IN REAL y)
    {
        X = x;
        Y = y;
    }

    // Scale.
    
    GpVector2D operator*(REAL k)
    {
        return GpVector2D(X*k, Y*k);
    }
    
    // Dot Product
    
    REAL operator*(IN const GpVector2D &V)
    {
        return (X*V.X+Y*V.Y);
    }
    
   
    VOID operator+=(IN const GpVector2D &V)
    {
        X += V.X;
        Y += V.Y;
    } 
    
    VOID operator-=(IN const GpVector2D &V)
    {
        X -= V.X;
        Y -= V.Y;
    } 
        
    VOID operator*=(IN const REAL k)
    {
        X *= k;
        Y *= k;
    } 

    // Length or Vector Norm of the Vector.
    
    REAL Norm()
    {
        double length = (double)X*X+(double)Y*Y;
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            return 0.0f;
        }
        else
        {
            return (REAL)length;
        }
    }
    
    // Unitize the vector. If it is degenerate, return 0.0f
    
    REAL Normalize()
    {
        double length = (double)X*X+(double)Y*Y;
        
        if( length < 0.0 )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        else
        {
            X /= (REAL)length;
            Y /= (REAL)length;
            return (REAL)length;
        }
    }
    
    friend REAL Determinant(GpVector2D &a, GpVector2D &b);
};
    
inline REAL Determinant(GpVector2D &a, GpVector2D &b)
{
    return (a.X*b.Y-a.Y*b.X);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\pathwidener.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999 - 2000  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.cpp
*
* Abstract:
*
*   Implementation of the GpPathWidener class
*
* Revision History:
*
*   11/23/99 ikkof
*       Created it
*
\**************************************************************************/

#include "precomp.hpp"

// 4*(REALSQRT(2.0) - 1)/3
#define U_CIR ((REAL)(0.552284749))

GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );


/**************************************************************************\
*
* Function Description:
*
*   This calculates the major and minor radius of an oval
*   when the unit cricle is transformed by the given matrix.
*   For further details, see ikkof's notes on Pen Transform.
*
* Arguments:
*
*   [OUT] majorR - the major radius.
*   [OUT] minorR - the minor radius.
*   [IN] matrix - the matrix to transform the unit circle.
*
* Return Value:
*
*   Status
*
*   01/28/00 ikkof
*       Created it
*
\**************************************************************************/

GpStatus
GetMajorAndMinorAxis(REAL* majorR, REAL* minorR, const GpMatrix* matrix)
{
    if(matrix == NULL)
    {
        // Regard this as an identity matrix.
        *majorR = 1;
        *minorR = 1;
        return Ok;
    }

    REAL m11 = matrix->GetM11();
    REAL m12 = matrix->GetM12();
    REAL m21 = matrix->GetM21();
    REAL m22 = matrix->GetM22();

    REAL d1 = ((m11*m11 + m12*m12) - (m21*m21 + m22*m22))/2;
    REAL d2 = m11*m21 + m12*m22;
    REAL D = d1*d1 + d2*d2;
    if(D > 0)
        D = REALSQRT(D);

    REAL r0 = (m11*m11 + m12*m12 + m21*m21 + m22*m22)/2;

    REAL r1 = REALSQRT(r0 + D);
    REAL r2 = REALSQRT(r0 - D);
    
    // They should be positive numbers.  Prevent the floating
    // point underflow.

    if(r1 <= CPLX_EPSILON)
        r1 = CPLX_EPSILON;
    if(r2 <= CPLX_EPSILON)
        r2 = CPLX_EPSILON;

    *majorR = r1;
    *minorR = r2;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor for the GpPathWidener.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

GpPathWidener::GpPathWidener(
    GpPath *path,
    const DpPen* pen,
    GpMatrix *matrix,
    BOOL doubleCaps
    )
{
    // Must call flatten with an appropriate flatten tolerance before widening.
    
    ASSERT(!path->HasCurve());
    
    Path = path;
    Pen = pen;
    DoubleCaps = doubleCaps && Pen->CompoundCount == 0;
    StrokeWidth = Pen->Width;

    // Set to identity.
    
    XForm.Reset();
    
    if(matrix)
    {
        XForm = *matrix;    // Otherwise XForm remains Identity.
    }

    // Apply the pen transform too.
    
    if(!(Pen->Xform.IsIdentity()))
    {
        XForm.Prepend(Pen->Xform);
    }
    
    // Compute the unit scale.
    
    REAL majorR, minorR;
    GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
    REAL unitScale = min(majorR, minorR);

    // Set minimum width to 1.0 (plus a bit for possible precision errors), 
    // so that narrow width pens don't end up leaving gaps in the line.
    // This is the minimum allowable width in device pixels
    
    REAL minDeviceWidth = 1.000001f; 
    
    if(DoubleCaps)
    {
        // Double Caps require wider minimum pens.
        
        minDeviceWidth *= 2.0f;
        
        // Dashes smaller than a pixel are dropping out entirely in inset 
        // pen because of the rasterizer pixel level clipping that is taking
        // place. We increase the minimum width of dashed lines making them
        // roughly 4.0f. This also helps address the weird moire aliasing 
        // effects with the really small dash-dot round lines.
        
        if(Pen->DashStyle != DashStyleSolid)
        {
            minDeviceWidth *= 2.0f;
        }
    }
    
    REAL minWorldWidth = minDeviceWidth/unitScale;
    
    // StrokeWidth is in World coordinates - compare against the minimum
    // world stroke width.
    
    if(StrokeWidth < minWorldWidth)
    {
        StrokeWidth = minWorldWidth;
    }
    
    SetValid(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Computes the Normal vectors for a single subpath. It reuses the 
*   normalArray input DynArray's memory allocation for the values.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID GpPathWidener::ComputeSubpathNormals(
    DynArray<GpVector2D> *normalArray,
    const INT count,
    const BOOL isClosed,
    const GpPointF *points
)
{
    // parameter validation.
    
    ASSERT(points != NULL);
    ASSERT(normalArray != NULL);
    
    // Set the count to zero, but don't free the memory.
    // Then update the count to store enough normals for this subpath, and
    // allocate the memory if required.
    
    normalArray->Reset(FALSE);
    GpVector2D *normals = normalArray->AddMultiple(count);
    
    // Allocation failure or no points.
    
    if(normals == NULL)
    {
        return;
    }
    
    // For each point in the subpath
    // Compute the normal at this point.
    
    INT ptIndex;
    for(ptIndex = 0; ptIndex < count; ptIndex++)
    {
        // Work out the previous point relative to ptIndex
        
        INT ptIndexPrev = ptIndex-1;
        
        // If this is the first point, we need to decide how to process 
        // previous based on the closed status of the path. If it's closed,
        // wrap, otherwise the normal at the first point is meaningless.
        
        if(ptIndexPrev < 0)
        {
            if(isClosed)
            {
                ptIndexPrev = count-1;
            }
            else
            {
                ptIndexPrev = 0;
            }
        }
        
        // Compute the normal at this point by looking at this point and
        // the previous one.
        
        normals[ptIndex] = 
            points[ptIndex]-
            points[ptIndexPrev];
        
        ASSERT(
            ptIndexPrev==ptIndex ||
            REALABS(normals[ptIndex].X) > REAL_EPSILON ||
            REALABS(normals[ptIndex].Y) > REAL_EPSILON
        );
            
        normals[ptIndex].Normalize();
        REAL tmp = normals[ptIndex].X;
        normals[ptIndex].X = normals[ptIndex].Y;
        normals[ptIndex].Y = -tmp;
    }
    
    // Apply the pen transform if there is one.
    
    if(!Pen->Xform.IsIdentity())
    {
        Pen->Xform.VectorTransform(normals, count);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Computes the List of non-degenerate points for a single subpath. It reuses
*   the filteredPoints input DynArray's memory allocation for the values.
*
* History:
*
*   10/23/2000 asecchia
*       Created.
*
\**************************************************************************/

GpStatus GpPathWidener::ComputeNonDegeneratePoints(
    DynArray<GpPointF> *filteredPoints,
    const GpPath::SubpathInfo &subpath,
    const GpPointF *points
)
{
    // parameter validation.
    
    ASSERT(points != NULL);
    ASSERT(filteredPoints != NULL);
    
    // Set the count to zero, but don't free the memory.
    // Then update the count to store enough normals for this subpath, and
    // allocate the memory if required.
    
    filteredPoints->Reset(FALSE);
    
    // nothing to do.
    
    if(subpath.Count == 0)
    {
        return Ok;
    }
    
    // For each point in the subpath decide if we add the point.
    
    const GpPointF *lastPoint = points + subpath.StartIndex;
    if(filteredPoints->Add(points[subpath.StartIndex]) != Ok)
    {
        return OutOfMemory;
    }
    
    INT ptIndex;
    for(ptIndex = subpath.StartIndex+1; 
        ptIndex < subpath.StartIndex+subpath.Count; 
        ptIndex++)
    {
        // !!! we should be using the flattening tolerance for this
        // instead of REAL_EPSILON - it would be much more efficient.
        
        if( REALABS(lastPoint->X-points[ptIndex].X) > REAL_EPSILON ||
            REALABS(lastPoint->Y-points[ptIndex].Y) > REAL_EPSILON )
        {
            if(filteredPoints->Add(points[ptIndex]) != Ok)
            {
                return OutOfMemory;
            }
        }
        
        lastPoint = points + ptIndex;
    }
    
    if(filteredPoints->GetCount() <= 1)
    {
        // If everything degenerated, erase the first point too.
        
        filteredPoints->Reset(FALSE);
    }
    return Ok;
}

/**************************************************************************\
*
* Description:
*
*   Function Pointer to a Join function.
*
* History:
*
*   10/22/2000 asecchia
*       Created.
*
\**************************************************************************/

typedef VOID (*JoinProc)(
    const GpVector2D &,
    const GpVector2D &,
    const GpPointF &,
    const REAL ,
    GpPath *
);

/**************************************************************************\
*
* Function Description:
*
*   Performs an inside join on the input normals and point. The resulting 
*   join point - if any - is added to the path.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID InsideJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const GpPointF &ptCurr,
    const GpPointF &ptNext,
    GpPath *path
)
{
    // Inside join.
    
    REAL t1, t2;          // parametric line lengths for the intersection.                
    GpPointF ptJoin;
    
    if( IntersectLines(
        ptStart + normalCurr,
        ptCurr + normalCurr,
        ptStart + normalNext,
        ptNext + normalNext,
        &t1, &t2, 
        &ptJoin ))
    {
        if( (t1 > (REAL_EPSILON)) &&
            (t2 > (REAL_EPSILON)) &&
            ((t1-1.0f) < (-REAL_EPSILON)) &&
            ((t2-1.0f) < (-REAL_EPSILON)) )
        {
            path->AddWidenPoint(ptJoin);
        } 
        else
        {
            // intersection outside of legal range of the two edge pieces.
            // Add the icky backward loopy thing. If the caller really needs
            // no loops it needs to call the PathSelfIntersectRemover.
            
            path->AddWidenPoint(ptStart+normalCurr);
            path->AddWidenPoint(ptStart+normalNext);
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Performs a bevel join
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID BevelJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const REAL limit,
    GpPath *path
)
{
    // Outside Bevel Join. Simply join the end points of the two input normals.
    
    path->AddWidenPoint(ptStart + normalCurr);
    path->AddWidenPoint(ptStart + normalNext);
}


/**************************************************************************\
*
* Function Description:
*
*   Performs a miter join. 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID MiterJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const REAL limit,
    GpPath *path
)
{
    GpVector2D gradCurr;         // current gradient reversed.
    gradCurr.X = normalCurr.Y;
    gradCurr.Y = -normalCurr.X;
    
    GpVector2D gradNext;         // next gradient.
    gradNext.X = -normalNext.Y;
    gradNext.Y = normalNext.X;
    
    REAL t1, t2;                 // temporary variables.
    GpPointF ptJoin;
    
    // If there is an intersection point and that intersection point is
    // closer to ptStart than the miter limit, then add the miter join
    // point. Otherwise revert to a bevel join.
    
    if( IntersectLines(
        ptStart + normalCurr,
        ptStart + normalCurr + gradCurr,
        ptStart + normalNext,
        ptStart + normalNext + gradNext,
        &t1, &t2, 
        &ptJoin )
        
        &&
    
        // this won't get evaluated if IntersectLines fails.    
        (distance_squared(ptStart, ptJoin) <= (limit*limit))
    )
    {
        path->AddWidenPoint(ptJoin);
    }
    else
    {
        BevelJoin(normalCurr, normalNext, ptStart, limit, path);
    }
}



/**************************************************************************\
*
* Function Description:
*
*   Performs a miter join. 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID RoundJoin(
    const GpVector2D &normalCurr,
    const GpVector2D &normalNext,
    const GpPointF &ptStart,
    const REAL limit,
    GpPath *path
)
{
    // !!! [asecchia] this is a really awful way of adding a round join.
    // we should change this to compute the control points directly or 
    // even better - add a useful 'CurveTo' method on the path.
    
    REAL radius = const_cast<GpVector2D&>(normalCurr).Norm();
    
    GpRectF rect(
        ptStart.X-radius, 
        ptStart.Y-radius, 
        2.0f*radius, 
        2.0f*radius
    );
    
    REAL startAngle = (REAL)atan2(normalCurr.Y, normalCurr.X);
    if(startAngle < 0.0f)
    {
        startAngle += (REAL)(2.0*M_PI);
    }
    
    REAL sweepAngle = (REAL)atan2(normalNext.Y, normalNext.X);
    if(sweepAngle < 0.0f)
    {
        sweepAngle += (REAL)(2.0*M_PI);
    }
    
    sweepAngle -= startAngle;
    
    if(sweepAngle > (REAL)M_PI)
    {
        sweepAngle -= (REAL)(2.0*M_PI);
    }
    
    if(sweepAngle < (REAL)-M_PI)
    {
        sweepAngle += (REAL)(2.0*M_PI);
    }
    
    // Why doesn't this thing use radians??
    
    startAngle = startAngle*180.0f/(REAL)M_PI;
    sweepAngle = sweepAngle*180.0f/(REAL)M_PI;
    
    // This is a really, really inconvenient AddArc interface!
    
    path->AddArc(rect, startAngle, sweepAngle);
}

/**************************************************************************\
*
* Description:
*
*   Function Pointer to a Join function.
*
* History:
*
*   10/22/2000 asecchia
*       Created.
*
\**************************************************************************/

typedef VOID (*CapProc)(
    const GpPointF &,
    const GpPointF &,
    GpPath *
);

/**************************************************************************\
*
* Function Description:
*
*   Performs a Flat Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID FlatCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
)
{
    // Cap the open segment.
    
    path->AddWidenPoint(ptLeft);
    path->AddWidenPoint(ptRight);
}

/**************************************************************************\
*
* Function Description:
*
*   Performs a Flat Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID TriangleCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
)
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    // Cap the open segment.
    
    path->AddWidenPoint(ptLeft);
    
    GpVector2D V = ptRight-ptLeft;
    V *= 0.5;
    
    REAL tmp = V.X;
    V.X = V.Y;
    V.Y = -tmp;
    
    path->AddWidenPoint(V+center);
    path->AddWidenPoint(ptRight);
}


/**************************************************************************\
*
* Function Description:
*
*   Performs a Round Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID RoundCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
    )
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    // Vector from left to right. We scale by 0.5 to optimize the rotation
    // code below.
    
    GpVector2D V = ptRight-ptLeft;
    V *= 0.5f;
    
    // 2 Bezier segments for a half circle with radius 1.

    static const GpPointF capPoints[7] = {
        GpPointF(-1.0f, 0.0f),
        GpPointF(-1.0f, -U_CIR),
        GpPointF(-U_CIR, -1.0f),
        GpPointF(0.0f, -1.0f),
        GpPointF(U_CIR, -1.0f),
        GpPointF(1.0f, -U_CIR),
        GpPointF(1.0f, 0.0f)
    };
    
    
    GpPointF points[7];
    
    // Rotate, scale, and translate the original half circle to the actual 
    // end points we passed in.

    for(INT i = 0; i < 7; i++)
    {
        points[i].X = capPoints[i].X*V.X-capPoints[i].Y*V.Y+center.X;
        points[i].Y = capPoints[i].X*V.Y+capPoints[i].Y*V.X+center.Y;
    }
    
    // !!! the performance of this routine sux. We should be able to add
    // the points into the path directly.
    
    path->AddBeziers(points, 7);
}

/**************************************************************************\
*
* Function Description:
*
*   Performs a Double Round 'B'-shaped Cap 
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID DoubleRoundCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
    )
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    
    RoundCap(ptLeft, center, path);
    RoundCap(center, ptRight, path);
}

/**************************************************************************\
*
* Function Description:
*
*   Performs a Double Triangle Cap 
*
* History:
*
*   10/22/2000 asecchia
*       Created.
*
\**************************************************************************/

VOID DoubleTriangleCap(
    const GpPointF &ptLeft,
    const GpPointF &ptRight,
    GpPath *path
    )
{
    // Compute the midpoint of ptLeft and ptRight.
    
    GpPointF center(
        (ptLeft.X+ptRight.X)*0.5f,
        (ptLeft.Y+ptRight.Y)*0.5f
    );
    
    TriangleCap(ptLeft, center, path);
    TriangleCap(center, ptRight, path);
}



/**************************************************************************\
*
* Function Description:
*
*   Return a CapProc function for the given lineCap and DoubleCaps 
*
* History:
*
*   10/23/2000 asecchia
*       Created.
*
\**************************************************************************/

CapProc GetCapProc(GpLineCap lineCap, BOOL DoubleCaps)
{
    switch(lineCap)
    {
        case LineCapFlat:
        return FlatCap;
        
        case LineCapRound:
        if(DoubleCaps)
        {
            return DoubleRoundCap;
        }
        else
        {
            return RoundCap;
        }
        
        case LineCapTriangle:
        if(DoubleCaps)
        {
            return DoubleTriangleCap;
        }
        else
        {
            return TriangleCap;  
        }
        
        default:
    
        // Invalid cap type for the widener. Use Flat. This will happen for
        // Anchor caps and Custom caps which are handled at a higher level.
        // See GpEndCapCreator.
        
        return FlatCap;
    };
}



/**************************************************************************\
*
* Function Description:
*
*   Takes a (usually empty) path and widens the current spine path into it.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

GpStatus
GpPathWidener::Widen(GpPath *path)
{
    // Can't widen the current path into itself for performance reasons.
    // We'd have to query the path points array every time we added a point.
    
    ASSERT(Path != path);
    
    // Normal array
    
    DynArray<GpVector2D> normalArray;
    DynArray<GpPointF> spinePoints;
    
    // Initialize the subpath information.
    
    DynArray<GpPath::SubpathInfo> *subpathInfo;
    Path->GetSubpathInformation(&subpathInfo);
    
    // Initialize the pointers to the original path data.
    
    const GpPointF *originalPoints = Path->GetPathPoints();
    const BYTE *originalTypes = Path->GetPathTypes();
    
    
    // Initialize the Join function.
    
    JoinProc join;
    
    switch(Pen->Join)
    {
        case LineJoinMiter:
        join = MiterJoin;
        break;
        
        case LineJoinBevel:
        join = BevelJoin;
        break;
        
        case LineJoinRound:
        join = RoundJoin;  
        break;
        
        default:
        // Invalid join type. Use Bevel, but fire an ASSERT to make developers
        // fix this code if they added a Join type.
        
        ONCE(WARNING(("Invalid Join type selected. Defaulting to Bevel")));
        join = BevelJoin;
    };
    
    // Initialize the various cap functions.
    
    CapProc startCap = GetCapProc(Pen->StartCap, DoubleCaps);
    CapProc endCap = GetCapProc(Pen->EndCap, DoubleCaps);
    
    if(Pen->StartCap == LineCapCustom)
    {
        ASSERT(Pen->CustomStartCap);
        GpLineCap tempCap;
        Pen->CustomStartCap->GetBaseCap(&tempCap);
        startCap = GetCapProc(tempCap, DoubleCaps);
    }
    
    if(Pen->EndCap == LineCapCustom)
    {
        ASSERT(Pen->CustomEndCap);
        GpLineCap tempCap;
        Pen->CustomEndCap->GetBaseCap(&tempCap);
        endCap = GetCapProc(tempCap, DoubleCaps);
    }
    
    CapProc dashCap = GetCapProc(Pen->DashCap, DoubleCaps);
    

    // Initialize the compound line data.
        
    ASSERT(Pen->CompoundCount >= 0);
    
    INT compoundCount = Pen->CompoundCount;
    
    if(compoundCount==0)
    {
        compoundCount = 2;
    }
    
    REAL penAlignmentOffset;
    
    switch(Pen->PenAlignment)
    {
        case PenAlignmentLeft:
        penAlignmentOffset = StrokeWidth/2.0f;
        break;
        
        case PenAlignmentRight:
        penAlignmentOffset = -StrokeWidth/2.0f;
        break;
        
        default:
        // Center pen only - handle inset pen at a much higher level.
        
        ASSERT(Pen->PenAlignment == PenAlignmentCenter);
        penAlignmentOffset=0.0f;
    };



    
    // Done initialization, start processing each subpath.
    
    for(INT currentSubpath = 0; 
        currentSubpath < subpathInfo->GetCount(); 
        currentSubpath++)
    {
        // Figure out the subpath record and Normal information.
        
        GpPath::SubpathInfo subpath = (*subpathInfo)[currentSubpath];
        
        // Remove all points that are the same from the subpath.
        // This initializes the spinePoints array.
        
        if( ComputeNonDegeneratePoints(
            &spinePoints, subpath, originalPoints) != Ok)
        {
            return OutOfMemory;
        }
        
        // skip this subpath if there aren't enough points left.
        
        if(spinePoints.GetCount() < 2)
        {
            continue;
        }
        
        // get a convenient pointer to the main spine points - after removing
        // degenerates. Const because we're not going to modify the points.
        
        const GpPointF *spine = spinePoints.GetDataBuffer();
        
        // Calculate the normals to all the points in the spine array.
        // The normals are normal to the edge between two points, so in an open
        // line segment, there is one less normal than there are points in the
        // spine. We handle this by initializing the first normal to (0,0).
        // The normals are all unit vectors and need to be scaled.
        
        ComputeSubpathNormals(
            &normalArray, 
            spinePoints.GetCount(), 
            subpath.IsClosed, 
            spine
        );
        
        GpVector2D *normals = normalArray.GetDataBuffer();
        
        // Loop over all the compound line segments. 
        // If there is no compound line we have set the compoundCount to 2.
        
        for(INT compoundIndex=0; 
            compoundIndex < compoundCount/2; 
            compoundIndex++)
        {
            // Compute the left and right offset.
            
            REAL left;
            REAL right;
            
            if(Pen->CompoundCount != 0)
            {
                // This is a compound line.
                
                ASSERT(Pen->CompoundArray != NULL);
                left = (0.5f-Pen->CompoundArray[compoundIndex*2]) * StrokeWidth;
                right = (0.5f-Pen->CompoundArray[compoundIndex*2+1]) * StrokeWidth;
            }
            else
            {
                // standard non-compound line.
                
                left = StrokeWidth/2.0f;
                right = -left;
            }
            
            left += penAlignmentOffset;
            right += penAlignmentOffset;
            
            INT startIdx = 0;
            INT endIdx = spinePoints.GetCount()-1;
            
            if(!subpath.IsClosed)
            {
                // Adjust the count for the join loop to represent the fact that 
                // we won't join the beginning and end of an open line segment.
                // Note Open line segments skip the first point handling it 
                // in the final cap.
                
                startIdx++;
                endIdx--;
            }
            
            //
            // Widen to the left.
            //
            
            // walk the spine forwards joining each point and emitting the 
            // appropriate set of points for the join.
    
            INT ptIndex;
            for(ptIndex = startIdx; ptIndex <= endIdx; ptIndex++)
            {
                // Modulo arithmetic for the next point.
                
                INT ptIndexNext = ptIndex+1;
                if(ptIndexNext == spinePoints.GetCount())
                {
                    ptIndexNext = 0;
                }
                
                GpVector2D normalCurr = normals[ptIndex]*left;
                GpVector2D normalNext = normals[ptIndexNext]*left;
                
                // Check to see if it's an inside or outside join. If the 
                // determinant of the two normals is negative, it's an outside
                // join - i.e. space between the line segment endpoints that need to 
                // be joined. If it's positive, it's an inside join and the two 
                // line segments overlap.
                
                REAL det = Determinant(normalCurr, normalNext);
                
                if(REALABS(det) < REAL_EPSILON)
                {
                    // This is the case where the angle of curvature for this 
                    // join is so small, we don't care which end point we pick.
                    
                    // REAL_EPSILON is probably too small for this - should 
                    // be about 0.25 of a device pixel or something.
                    
                    path->AddWidenPoint(spine[ptIndex] + normalCurr);
                }
                else
                {
                    // We need to do some work to join the segments.
                    
                    if(det > 0)
                    {
                        // Outside Joins. 
                        
                        join(
                            normalCurr, 
                            normalNext,
                            spine[ptIndex],
                            Pen->MiterLimit*StrokeWidth,
                            path
                        );
                    }
                    else
                    {
                        INT ptIndexPrev = ptIndex-1;
                        if(ptIndexPrev == -1)
                        {
                            ptIndexPrev = spinePoints.GetCount()-1;
                        }
                        
                        InsideJoin(
                            normalCurr,
                            normalNext,
                            spine[ptIndex],
                            spine[ptIndexPrev],
                            spine[ptIndexNext],
                            path
                        );
                    }
                }
            }
            
            // Handle the final point in the spine.
            
            if(subpath.IsClosed)
            {
                // Make a closed subpath out of the left widened points.
                
                path->CloseFigure(); 
            }
            else
            {
                // Cap the open segment.

                CapProc cap = endCap;
                                
                if( IsDashType(
                    originalTypes[subpath.StartIndex+subpath.Count-1]
                    ))
                { 
                    // actually it's a dash cap, not an end cap.
                    
                    cap = dashCap;  
                }
                
                cap(
                    spine[spinePoints.GetCount()-1] + 
                    (normals[spinePoints.GetCount()-1]*left),
                    spine[spinePoints.GetCount()-1] + 
                    (normals[spinePoints.GetCount()-1]*right),
                    path
                );
            }
            
            
            //
            // Widen to the right.
            //
            
            // walk the spine backwards joining each point and emitting the 
            // appropriate set of points for the join.
    
            for(ptIndex = endIdx; ptIndex >= startIdx; ptIndex--)
            {
                // Modulo arithmetic for the next point.
                
                INT ptIndexNext = ptIndex+1;
                if(ptIndexNext == spinePoints.GetCount())
                {
                    ptIndexNext = 0;
                }
                
                GpVector2D normalCurr = normals[ptIndex]*right;
                GpVector2D normalNext = normals[ptIndexNext]*right;
                
                // Check to see if it's an inside or outside join. If the 
                // determinant of the two normals is negative, it's an outside
                // join - i.e. space between the line segment endpoints that need to 
                // be joined. If it's positive, it's an inside join and the two 
                // line segments overlap.
                
                REAL det = Determinant(normalNext, normalCurr);
                
                if(REALABS(det) < REAL_EPSILON)
                {
                    // This is the case where the angle of curvature for this 
                    // join is so small, we don't care which end point we pick.
                    
                    // REAL_EPSILON is probably too small for this - should 
                    // be about 0.25 of a device pixel or something.
                    
                    path->AddWidenPoint(spine[ptIndex] + normalNext);
                }
                else
                {
                    // We need to do some work to join the segments.
                    
                    if(det > 0)
                    {
                        // Outside Joins. 
                        
                        join(
                            normalNext,     // note the order is flipped for  
                            normalCurr,     // the backward traversal.
                            spine[ptIndex],
                            Pen->MiterLimit*StrokeWidth,
                            path
                        );
                    }
                    else
                    {
                        INT ptIndexPrev = ptIndex-1;
                        if(ptIndexPrev == -1)
                        {
                            ptIndexPrev = spinePoints.GetCount()-1;
                        }
                        
                        InsideJoin(
                            normalNext,      // note the order is flipped for 
                            normalCurr,      // the backward traversal.       
                            spine[ptIndex],
                            spine[ptIndexNext],
                            spine[ptIndexPrev],
                            path
                        );
                    }
                }
            }
            
            // Handle the first point in the spine.
            
            if(!subpath.IsClosed)
            {
                // Cap the open segment.
                
                CapProc cap = startCap;
                                
                if(IsDashType(originalTypes[subpath.StartIndex]))
                { 
                    // actually it's a dash cap, not a start cap.
                    
                    cap = dashCap;
                }
                
                cap(
                    spine[0] + (normals[1]*right),
                    spine[0] + (normals[1]*left),
                    path
                );
            }    
            
            // Close the previous contour. For open segments this will close
            // off the widening with the end cap for the first point. For 
            // closed paths, the left widened points have already been closed
            // off, so close off the right widened points.
            
            path->CloseFigure();  
        }
    }
    
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpbrush.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definiton of the DpBrush structure which stores all of the
*   state needed by drivers to render with a brush.
*
* Notes:
*
* History:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*   12/08/1999 bhouse
*       Major overhaul of DpBrush.  No longer used as base class of GpBrush.
*       Moved all driver required state into DpBrush.  Changed to struct.
*
\**************************************************************************/

#ifndef _DPBRUSH_HPP
#define _DPBRUSH_HPP

//--------------------------------------------------------------------------
// Represent brush information
//--------------------------------------------------------------------------

struct DpBrush
{

    GpBrushType         Type;

    GpColor             SolidColor;          // Set if GpBrushType::SolidBrush

    GpMatrix            Xform;                  // brush transform
    GpWrapMode          Wrap;                   // wrap mode
    GpRectF             Rect;

    DpBitmap *          texture;

    ARGB*               PresetColors;        // NON-Premultiplied colors.
    BOOL                UsesPresetColors;
    BOOL                IsGammaCorrected;    // use gamma correction of 2.2
    BOOL                IsAngleScalable;

    DpPath *            Path;

    mutable GpPointF *  PointsPtr;
    GpColor *           ColorsPtr;
    mutable INT         Count;
    mutable BOOL        OneSurroundColor;
    REAL                FocusScaleX;
    REAL                FocusScaleY;

    GpHatchStyle        Style;

    GpColor             Colors[4];
    REAL                Falloffs[3];
    INT                 BlendCounts[3];
    REAL*               BlendFactors[3];
    REAL*               BlendPositions[3];
    GpPointF            Points[3];
    BYTE                Data[8][8];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\ddiplus.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   ddiplus.hpp
*
* Abstract:
*
*   Contains the interface definition for the high-level GDI+ device
*   driver interface.
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*                                 
*   03/11/1999 agodfrey
*       Changed the DDI model. For this version, I'm not using COM, and
*       we'll use the result to decide whether we should be using COM.
\**************************************************************************/

#ifndef _DDIPLUS_HPP
#define _DDIPLUS_HPP

// !! shift this to dpflat.hpp ?? 
// !! do we want to bother with namespaces for driver, they may link to
//    other stuff in GDI, and hence name clashes.

class EpPaletteMap;

template<class T> class EpScanBufferNative;
#define DpScanBuffer EpScanBufferNative<ARGB>

class DpOutputSpan;
class DpClipRegion;
class DpContext;
struct DpBrush;
struct DpPen;
class DpBitmap;
class DpDriver;
class DpRegion;
class DpDevice;
class EpScan;
class DpPath;
class DpCustomLineCap;
struct DpImageAttributes;
class DpCachedBitmap;

#define WINGDIPAPI __stdcall

// The naming convention is Dpc<function><object> for Driver callbacks
DpPath* WINGDIPAPI 
DpcCreateWidenedPath(
        const DpPath* path, 
        const DpPen* pen,
        DpContext* context,
        BOOL outline
        );
    
VOID WINGDIPAPI 
DpcDeletePath(
        DpPath* path
        );

DpPath* WINGDIPAPI
DpcClonePath(
        DpPath* path
        );

VOID WINGDIPAPI
DpcTransformPath(
        DpPath* path,
        GpMatrix* transform
        );

#include "dpregion.hpp"

// Hack: DpContext depends on GpRegion
#include "..\Entry\object.hpp"
#include "..\Entry\region.hpp"
// EndHack

#include "dpbitmap.hpp"
#include "dpbrush.hpp"
#include "dpcontext.hpp"
#include "dpdriver.hpp"
#include "dppath.hpp"
#include "dpcustomlinecap.hpp"
#include "dppen.hpp"
#include "dpscan.hpp"
#include "dppathiterator.hpp"
#include "dpimageattributes.hpp"
#include "dpcachedbitmap.hpp"

#endif // !_DDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpbitmap.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpBitmap
*
* Notes:
*
* Abstract:
*
*   This is a DDI-level surface. Its name should really be 'surface'. 
*   Unlike many other DDI objects, there isn't a one-to-one mapping between
*   a DpBitmap and a GpBitmap. Rather, this is like a GDI surface - it
*   represents any rectangular area to which one can draw.
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPBITMAP_HPP
#define _DPBITMAP_HPP

// DpTransparency:
//   Characterizes the alpha values in a surface. Perf optimizations can
//   take advantage of this knowledge.

enum DpTransparency
{
    TransparencyUnknown, // We know nothing about the alpha values
    TransparencyComplex, // We have alpha values between 0 and 1
    TransparencySimple,  // All alpha values are either 0 or 1
    TransparencyOpaque,  // All alpha values are 1
    TransparencyNearConstant, // we have near constant alpha
    TransparencyNoAlpha  // All pixels are opaque because the surface doesn't
                         // support alpha.
};

// Define PixelFormatID in terms of the PixelFormat enum

typedef PixelFormat PixelFormatID;

// Passthrough compressed bitmaps to driver
class DpCompressedData
{
public:
    DpCompressedData()
    {
        format = 0;
        bufferSize = 0;
        buffer = NULL;
    }

    ~DpCompressedData()
    {
        ASSERT(buffer == NULL);
    }

public:
   INT   format;
   UINT  bufferSize;
   VOID* buffer;
};
  

//--------------------------------------------------------------------------
// Represent surface information
//--------------------------------------------------------------------------

class EpScanBitmap;
struct ImageInfo;

class DpBitmap
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpBitmap : ObjectTagInvalid;
    }

public:
    enum CreationType
    {
        GDI,
        GDIDIBSECTION,
        GPBITMAP,
        D3D
    };

    INT Width;
    INT Height;
    PixelFormatID PixelFormat;  // bits per pixel, pre/post multiplied alpha, etc.
    INT NumBytes;               // Number of bytes
    REAL DpiX;                  // actual horizontal resolution in dots per inch
    REAL DpiY;                  // actual vertical resolution in dots per inch
    UINT Uniqueness;            // Incremented every time it's drawn on

    DpTransparency SurfaceTransparency;

    BYTE MinAlpha;
    BYTE MaxAlpha;

    // The following is true only for RGB format bitmaps:

    ColorPalette* PaletteTable;
    
    // These masks are no longer used for determining the pixel format
    // Use the PixelFormat member above instead.
    // In fact, there's never been any garantee that these fields were
    // set up correctly anyway. They should be removed soon.
    
    INT RedMask;
    INT GreenMask;
    INT BlueMask;
    INT AlphaMask;

    LPDIRECTDRAWSURFACE     DdrawSurface;
    IDirectDrawSurface7 *   DdrawSurface7;
    
    BOOL IsDisplay;             // Is this bitmap associated with a display?
    CreationType Type;

    // short lived, so don't include statically
    DpCompressedData *CompressedData;

public:
    BOOL IsDesktopSurface() const
    {
        return (this == Globals::DesktopSurface);
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpBitmap) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpBitmap");
        }
    #endif

        return (Tag == ObjectTagDpBitmap);
    }

public: // GDI+ INTERNAL

    VOID *Bits;                 // Points to surface bits
    VOID *CompBits;
    INT Delta;                  // Stride in bytes

    // Private data for the software rasterizer.
    
    EpScan *Scan;

public: // GDI+ INTERNAL

    DpBitmap(HDC hdc = NULL)
    {
        SetValid(TRUE);     // set to valid state

        if ((hdc == NULL) ||
            ((DpiX = (REAL)GetDeviceCaps(hdc, LOGPIXELSX)) <= 0.0f) ||
            ((DpiY = (REAL)GetDeviceCaps(hdc, LOGPIXELSY)) <= 0.0f))
        {
            // Assume this is a display surface with the display DPI for now
            IsDisplay = TRUE;
            DpiX = Globals::DesktopDpiX;
            DpiY = Globals::DesktopDpiY;
        }
        else
        {
            IsDisplay = (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY);
        }

        Scan = NULL;
        DdrawSurface = NULL;
        DdrawSurface7 = NULL;
        PaletteTable = NULL;
        CompressedData = NULL;

        SurfaceTransparency = TransparencyUnknown;
    }
    ~DpBitmap();

    VOID InitializeForMetafile(GpDevice *device)
    {
        InitializeForGdiBitmap(device, 0, 0);
    }

    VOID InitializeForGdiBitmap(
        GpDevice *device, 
        INT width, 
        INT height
        );
    
    VOID InitializeForGdiScreen(
        GpDevice *device, 
        INT width, 
        INT height
        );
    
    BOOL InitializeForD3D(
        HDC hdc, 
        INT *width, 
        INT *height, 
        DpDriver** driver
        );
    
    BOOL InitializeForD3D(
        IDirectDrawSurface7* surface, 
        INT *width, 
        INT *height, 
        DpDriver** driver
        );
    
    BOOL InitializeForDibsection(
        HDC hdc, 
        HBITMAP hbitmap, 
        GpDevice *device, 
        DIBSECTION *dib, 
        INT *width, 
        INT *height, 
        DpDriver **driver
        );
    
    VOID InitializeForGdipBitmap(
        INT             width,
        INT             height,
        ImageInfo *     imageInfo,
        EpScanBitmap *  scanBitmap,
        BOOL            isDisplay
        );

    BOOL InitializeForPrinter(GpPrinterDevice *device, INT width, INT height);

    BOOL StandardFormat();
    PixelFormatID GetPixelFormatFromBitDepth(INT bits);

    // Flush any pending rendering to this surface:

    VOID Flush(GpFlushIntention intention);

    REAL GetDpiX() const { return DpiX; }
    REAL GetDpiY() const { return DpiY; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\solidfill.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Engine solid fill routines.
*
* Revision History:
*
*   12/11/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster as a solid color.
*   Is called by the rasterizer.
*
* Arguments:
*
*   [IN] y         - the Y value of the raster being output
*   [IN] leftEdge  - the DDA class of the left edge
*   [IN] rightEdge - the DDA class of the right edge
*
* Return Value:
*
*   GpStatus - Ok
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus
DpOutputSolidColorSpan::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax   // xMax is exclusive
    )
{
    INT width = xMax - xMin;

    FillMemoryInt32(Scan->NextBuffer(xMin, y, width), width, Argb);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a path.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/21/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::FillPath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpBrush *brush
    )
{
    GpStatus status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        noTransparentPixels);

    if (scan.IsValid())
    {
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(path, 
                                   &context->WorldToDevice, 
                                   path->GetFillMode(),
                                   context->AntiAliasMode, 
                                   FALSE,
                                   &output, 
                                   &context->VisibleClip, 
                                   drawBounds);
        }
        else
        {
            DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);
            if (output != NULL)
            {
                status = RasterizePath(path, 
                                       &context->WorldToDevice, 
                                       path->GetFillMode(),
                                       context->AntiAliasMode, 
                                       FALSE,
                                       output, 
                                       &context->VisibleClip, 
                                       drawBounds);
    
                delete output;
            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws a path.  This distributes to the individual pen draw method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to draw to
*   [IN] drawBounds - the surface bounds
*   [IN] path       - the path to stroke
*   [IN] pen        - the pen to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 ikkof
*
\**************************************************************************/

GpStatus
DpDriver::StrokePath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen
    )
{
    GpStatus status = GenericError;

    const DpBrush *brush = pen->Brush;

    REAL dpiX = (context->GetDpiX() > 0) 
              ? (context->GetDpiX())
              : (Globals::DesktopDpiX);

    BOOL isOnePixelWide = pen->IsOnePixelWide(&context->WorldToDevice, dpiX) &&
                          pen->IsCenterNoAnchor();
    BOOL isOnePixelWideOpaque = isOnePixelWide &&
                                (brush->Type == BrushTypeSolidColor) && 
                                (brush->SolidColor.IsOpaque()) &&
                                !(context->AntiAliasMode);
    BOOL isOnePixelWideSolid = isOnePixelWide && 
                                pen->IsSimple();

    // We have a special fast-path for doing single-pixel-wide, 
    // solid color, opaque, aliased lines:

    if (isOnePixelWideOpaque && isOnePixelWideSolid)
    {
        return SolidStrokePathOnePixel(
            context,
            surface,
            drawBounds,
            path,
            pen,
            TRUE
        ); 
    }

    const DpPath* widenedPath;
    const DpPath* allocatedPath;

    GpMatrix *transform;
    GpMatrix identityTransform;

    if (isOnePixelWideSolid)
    {
        // Our RasterizePath code can directly draw a one-pixel-wide solid 
        // line directly:

        widenedPath = path;
        allocatedPath = NULL;
        transform = &context->WorldToDevice;
    }
    else
    {
        // We have to widen  the path before we can give it to the
        // rasterizer.  Generate new path now:

        REAL dpiX = context->GetDpiX();
        REAL dpiY = context->GetDpiY();

        if ((dpiX <= 0) || (dpiY <= 0))
        {
            dpiX = Globals::DesktopDpiX;
            dpiY = Globals::DesktopDpiY;
        }

        BOOL fInsetOutset = 
            (pen->PenAlignment == PenAlignmentInset) ||
            (pen->PenAlignment == PenAlignmentOutset);
            
        // Pass in false for the region to path conversion parameter if we're
        // doing inset pen or outset pen. This will give us back the double 
        // wide path representing the union of the inset and outset pen 
        // widening.
        
        widenedPath = path->GetFlattenedPath(
            isOnePixelWideOpaque ? NULL : &context->WorldToDevice,
            isOnePixelWideOpaque ? Flattened : Widened,
            pen,
            context->AntiAliasMode,
            dpiX,
            dpiY,
            !fInsetOutset
        );

        allocatedPath = widenedPath;
        transform = &identityTransform;

        if (!widenedPath)
        {
            return OutOfMemory;
        }

        // If this line is aliased, opaque and dashed, dash it now and pass the
        // dashed path to the single pixel stroking code.
        
        if (isOnePixelWideOpaque && pen->DashStyle != DashStyleSolid)
        {
            DpPath *dashPath = NULL;
            
            // Hack up a temporary pen. For single pixel wide lines, we don't
            // actually cap the dash segments so we don't want any code in 
            // CreateDashCap mucking about with a non-zero cap length (e.g. 
            // shortening the dash segments by the cap length and making them
            // dissapear).
            
            DpPen tmpPen = *pen;
            tmpPen.DashCap = LineCapFlat;

            dashPath = ((GpPath*)widenedPath)->CreateDashedPath(
                &tmpPen,
                NULL,
                dpiX,
                dpiY,
                1.0f
            );
            
            if (!dashPath)
            {
                delete widenedPath;
                return OutOfMemory;
            }

            Status status = SolidStrokePathOnePixel(
                context,
                surface,
                drawBounds,
                dashPath,
                pen,
                FALSE
            ); 
            
            delete dashPath;
            delete widenedPath;
            
            return status;
        }
    }

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);
    BOOL noTransparentPixels = (!context->AntiAliasMode) && (gpBrush->IsOpaque()); 

    DpScanBuffer scan(surface->Scan, this, context, surface, noTransparentPixels);

    if (scan.IsValid())
    {
        DpClipRegion clip(context->VisibleClip);
        
        if(pen->PenAlignment == PenAlignmentInset)
        {
            // For inset pen we want the intersection of the visible clip
            // and the spine path.
            
            DpRegion spineRegion(
                const_cast<DpPath*>(path), 
                &context->WorldToDevice
            );
            clip.And(&spineRegion);
        }
        
        if(pen->PenAlignment == PenAlignmentOutset)
        {
            // For outset pen we want the intersection of the visible clip
            // and the complement of the spine path.
            
            DpRegion spineRegion(
                const_cast<DpPath*>(path), 
                &context->WorldToDevice
            );
            clip.Exclude(&spineRegion);
        }
        
        if (brush->Type == BrushTypeSolidColor)
        {
            GpColor color(brush->SolidColor.GetValue());    
            DpOutputSolidColorSpan output(color.GetPremultipliedValue(), &scan);

            status = RasterizePath(
                widenedPath, 
                transform, 
                widenedPath->GetFillMode(),
                context->AntiAliasMode, 
                isOnePixelWideSolid,
                &output, 
                &clip,
                drawBounds
            );
        }
        else
        {
            DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);
            if (output != NULL)
            {
                status = RasterizePath(
                    widenedPath, 
                    transform, 
                    widenedPath->GetFillMode(),
                    context->AntiAliasMode, 
                    isOnePixelWideSolid,
                    output, 
                    &clip, 
                    drawBounds
                );
    
                delete output;
            }
        }
    }

    if (allocatedPath)
    {
        delete allocatedPath;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a region.  This distributes to the individual brush fill method.  
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] region     - the region to fill
*   [IN] brush      - the brush to use
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/25/1999 DCurtis
*
\**************************************************************************/

GpStatus
DpDriver::FillRegion(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpRegion *region,
    const DpBrush *brush
    )
{
    GpStatus    status = GenericError;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if (scan.IsValid())
    {
        DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);

        if (output != NULL)
        {
            DpClipRegion *          clipRegion = &(context->VisibleClip);
            GpRect                  clipBounds;
            GpRect *                clipBoundsPointer = NULL;
            DpRegion::Visibility    visibility;
        
            visibility = clipRegion->GetRectVisibility(
                            drawBounds->X,
                            drawBounds->Y,
                            drawBounds->X + drawBounds->Width,
                            drawBounds->Y + drawBounds->Height);

            switch (visibility)
            {
              default:                          // Need to clip
                clipRegion->GetBounds(&clipBounds);
                clipBoundsPointer = &clipBounds;
                clipRegion->InitClipping(output, drawBounds->Y);
                status = region->Fill(clipRegion, clipBoundsPointer);
                break;

              case DpRegion::TotallyVisible:    // No clipping needed
                status = region->Fill(output, clipBoundsPointer);
                break;
            
              case DpRegion::Invisible:
                status = Ok;
                break;
            }

            delete output;
            clipRegion->EndClipping();
        }
    }

    return status;
}

GpStatus
DpDriver::MoveBits(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const GpRect *dstRect,     
    const GpPoint *srcPoint
    )
{
    return(GenericError);
}

GpStatus 
DpDriver::Lock(
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT *stride,                    // [OUT] - Returned stride
    VOID **bits                     // [OUT] - Returned pointer to bits
    )
{
    return(Ok);
}

VOID 
DpDriver::Unlock(
    DpBitmap *surface
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to fill rectangles.
*   This is not limited to filling solid color.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*
*   01/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

// !!![andrewgo] What is this doing in a file called "solidfill.cpp"?

GpStatus
DpDriver::FillRects(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT numRects, 
    const GpRectF *rects,
    const DpBrush *brush
    )
{
    GpStatus    status = Ok;
    GpBrushType type   = brush->Type;

    const GpBrush *gpBrush = GpBrush::GetBrush(brush);

    DpScanBuffer scan(
        surface->Scan,
        this,
        context,
        surface,
        gpBrush->IsOpaque());

    if(!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan * output = DpOutputSpan::Create(brush, &scan, context);

    if(output == NULL)
        return(GenericError);

    DpRegion::Visibility visibility = DpRegion::TotallyVisible;
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y, 
        drawBounds->GetRight(), drawBounds->GetBottom()) != 
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(output, drawBounds->Y);
    }
   
    GpMatrix *worldToDevice = &context->WorldToDevice;
    
    const GpRectF * rect = rects;
    INT y;

    for (INT i = numRects; i != 0; i--, rect++)
    {
        // We have to check for empty rectangles in world space (because
        // after the transform they might have flipped):

        if ((rect->Width > 0) && (rect->Height > 0))
        {
            GpPointF points[4];

            points[0].X = rect->X;
            points[0].Y = rect->Y;
            points[1].X = rect->X + rect->Width;
            points[1].Y = rect->Y + rect->Height;

            // FillRects only ever gets called when a scaling transform:
            // !!![ericvan] printing code calls this to render the brush onto a rectangle,
            //              but the transform in effect may not be TranslateScale
            // !!![andrewgo] Yeah but then isn't the printer case completely
            //               broken when there is an arbitrary transform?!?

            ASSERT(context->IsPrinter ||
                   worldToDevice->IsTranslateScale());
            
            worldToDevice->Transform(points, 2);

            INT left;
            INT right;

            // convert to INT the same way the GDI+ rasterizer does
            // so we get the same rounding error in both places.

            if (points[0].X <= points[1].X)
            {
                left  = RasterizerCeiling(points[0].X);
                right = RasterizerCeiling(points[1].X);     // exclusive
            }
            else
            {
                left  = RasterizerCeiling(points[1].X);
                right = RasterizerCeiling(points[0].X);     // exclusive
            }

            // Since right is exclusive, we don't draw anything
            // if left >= right.

            INT width = right - left;
            INT top;
            INT bottom;

            if (points[0].Y <= points[1].Y)
            {
                top    = RasterizerCeiling(points[0].Y);
                bottom = RasterizerCeiling(points[1].Y);    // exclusive
            }
            else
            {
                top    = RasterizerCeiling(points[1].Y);
                bottom = RasterizerCeiling(points[0].Y);    // exclusive
            }
             
            // Since bottom is exclusive, we don't draw anything
            // if top >= bottom.

            if ((width > 0) && (top < bottom))
            {
                GpRect clippedRect;
                
                if(clipRegion)
                {
                    visibility = 
                            clipRegion->GetRectVisibility(
                                left, top, 
                                right, bottom, &clippedRect);
                }

                switch (visibility)
                {
                case DpRegion::ClippedVisible:
                    left   = clippedRect.X;
                    top    = clippedRect.Y;
                    right  = clippedRect.GetRight();
                    bottom = clippedRect.GetBottom();
                    width  = right - left;
                    // FALLTHRU
        
                case DpRegion::TotallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        output->OutputSpan(y, left, right);
                    }
                    break;
        
                case DpRegion::PartiallyVisible:
                    for (y = top; y < bottom; y++)
                    {
                        clipRegion->OutputSpan(y, left, right);
                    }
                    break;

                case DpRegion::Invisible:
                    break;
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    delete output;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpcachedbitmap.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CachedBitmap driver data structure.
*
* Created:
*
*   04/28/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _DPCACHEDBITMAP_HPP
#define _DPCACHEDBITMAP_HPP

struct EpScanRecord;

//--------------------------------------------------------------------------
// Represent the CachedBitmap information for the driver.
//--------------------------------------------------------------------------

class DpCachedBitmap
{   
    public:

    INT Width;
    INT Height;

    // pointer to the pixel data.

    void *Bits;                // The start of the memory buffer. It might not
                               // be QWORD aligned, so it's not necessarily
                               // equal to RecordStart.
    EpScanRecord *RecordStart; // The first scan record
    EpScanRecord *RecordEnd;   // Just past the last scan record

    // Store the pixel format for the runs of opaque and semitransparent
    // pixels.

    PixelFormat OpaqueFormat;
    PixelFormat SemiTransparentFormat;

    DpCachedBitmap()
    {
        OpaqueFormat = PixelFormat32bppPARGB;
        SemiTransparentFormat = PixelFormat32bppPARGB;
        Bits = NULL;
        Width = 0;
        Height = 0;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpcontext.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpContext - DDI-level device context
*
* Abstract:
*
*   This is the DDI-level portion of the GpGraphics object.
*
* Notes:
*
*
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved it into a separate file for the preliminary DDI.
*
\**************************************************************************/

#ifndef _DPCONTEXT_HPP
#define _DPCONTEXT_HPP

// This enum specifies what we should do about
// the ICM mode on the destination HDC.

enum HdcIcmMode {
    IcmModeOff,     // must turn it off
    IcmModeOn       // must turn it on
};

//--------------------------------------------------------------------------
// Represent context information for the call
//--------------------------------------------------------------------------

class DpContext
{

public:

    static LONG Uniqueness;                  // Used with Id's

    DpContext *          Prev;               // For save/restore (push/pop)
    DpContext *          Next;
    UINT                 Id;                 // For save/restore
    INT                  AntiAliasMode;
    GpTextRenderingHint  TextRenderHint;     // For AntiAlias Text and
    GpCompositingMode    CompositingMode;
    GpCompositingQuality CompositingQuality;
    INT                  RenderingOriginX;   // Origin for halftone/dither matrices
    INT                  RenderingOriginY;
    UINT                 TextContrast;
    InterpolationMode    FilterType;
    PixelOffsetMode      PixelOffset;
    Unit                 PageUnit;
    REAL                 PageScale;
    REAL                 PageMultiplierX;    // combination of PageUnit and PageScale
    REAL                 PageMultiplierY;    // combination of PageUnit and PageScale
    REAL                 ContainerDpiX;      // The Dpi for the current container
    REAL                 ContainerDpiY;      // The Dpi for the current container
    REAL                 MetafileRasterizationLimitDpi;
    GpMatrix             WorldToPage;
    GpMatrix             WorldToDevice;      // includes container transform
    GpMatrix             ContainerToDevice;  // container transform
    mutable GpMatrix     DeviceToWorld;      // lazy inverse of WorldToDevice
    mutable BOOL         InverseOk;          // if DeviceToWorld is up to date
    DpClipRegion         VisibleClip;        // The combination of all clip regions
    DpRegion             ContainerClip;      // For container clipping. Includes the WindowClip
    GpRegion             AppClip;            // The current logical region that
                                             //   defines the current clipping
    HDC                  Hdc;                // If the Graphics was derived from
                                             //   an 'hdc', this is the DC handle.
                                             //   NOTE: We may have changed the
                                             //   state in it
    HWND                 Hwnd;               // Window handle if we know it
    HdcIcmMode           IcmMode;            // Icm Mode for the DC.
    BOOL                 IsEmfPlusHdc;       // If it is an EMF+ metafile HDC or not
    BOOL                 IsPrinter;          // Represents a printer context
    BOOL                 IsDisplay;          // Is this context associated with a display?
                    
    INT                  SaveDc;             // Represents the SaveDC level if the
                                             //   Hdc had a SaveDC done on it since
                                             //   it was given to us
                    
    ColorPalette *       Palette;            // Context palette or NULL for system palette
    EpPaletteMap *       PaletteMap;         // Mapping to Palette or system palette

    HFONT                CurrentHFont;       // GdiPlus has created an hfont and selected
    HFONT                OriginalHFont;      // it into the DC. Before releasing
                                             // the DC, the original font should be
                                             // reselected, and the current font
                                             // deleted.
    const GpFontFace    *Face;               // Font face of currently selected font
    GpMatrix             FontTransform;      // Transform for currently selected font
    INT                  Style;              // Style for currently selected font

    BOOL                 GdiLayered;         // TRUE if GDI layering is enabled
                                             //   on the target. If so, GDI is
                                             //   rendering to the screen is
                                             //   actually redirected to a backing
                                             //   store inaccessible via DCI.
                                             //   GDI must be used for rendering.

public:

    DpContext(
        BOOL            isDisplay
        );

    DpContext(
        DpContext *     prev    // must not be NULL
        );

    ~DpContext();

    // GetHdc() will automatically initialize (to default values) parts of the
    // DC.  It doesn't reset *all* attributes, though!

    HDC
    GetHdc(         // May return NULL if not originally a GDI surface
        DpBitmap *surface
        );

    VOID
    ReleaseHdc(
        HDC hdc,
        DpBitmap *surface = NULL
        );

    VOID
    CleanTheHdc(
        HDC hdc
        );

    // ResetHdc() restores the HDC to the state in which it was given
    // to us:

    VOID ResetHdc(
        VOID
        );

    VOID UpdateWorldToDeviceMatrix()
    {
        GpMatrix::ScaleMatrix(
            WorldToDevice,
            WorldToPage,
            PageMultiplierX,
            PageMultiplierY);

        // GillesK:
        // PixelOffsetModeDefault and PixelOffsetModeHighSpeed are PixelOffsetNone,

        if (PixelOffset == PixelOffsetModeHalf || PixelOffset == PixelOffsetModeHighQuality)
        {
            WorldToDevice.Translate(-0.5f, -0.5f, MatrixOrderAppend);
        }

        if (!ContainerToDevice.IsIdentity())
        {
            GpMatrix::MultiplyMatrix(
                WorldToDevice,
                WorldToDevice,
                ContainerToDevice);
        }
    }

    GpStatus
    GetDeviceToWorld(
        GpMatrix* deviceToWorld
        ) const;

    VOID
    GetPageMultipliers(
        REAL *              pageMultiplierX,
        REAL *              pageMultiplierY,
        GpPageUnit          unit  = UnitDisplay,
        REAL                scale = 1.0f
        ) const;

    VOID
    GetPageMultipliers()
    {
        GetPageMultipliers(&PageMultiplierX, &PageMultiplierY,
                           PageUnit, PageScale);
    }


    // Text optimisation hdc generation

    GpStatus UpdateCurrentHFont(
            BYTE quality,
            const PointF & scale,
            INT angle,
            HDC hdc,
            BOOL sideway,
            BYTE charSet = 0xFF
    );

private:
    VOID DeleteCurrentHFont();

public:
    // successful call to SelectCurrentHFont or GetTextOutputHdc must have
    // matching ReleaseTextOutputHdc call

    GpStatus SelectCurrentHFont(HDC hdc);

    HDC
    GetTextOutputHdc(
        const GpFaceRealization *faceRealization,   // In  - Font face required
        GpColor                 color,           // In  - Required GdiPlus brush effect
        DpBitmap                *surface,           // In
        INT                     *angle              // Out
    );

    
    VOID ReleaseTextOutputHdc(HDC hdc);

    REAL GetDpiX() const { return ContainerDpiX; }
    REAL GetDpiY() const { return ContainerDpiY; }

    // Used only when recording a EMF or EMF+ through GpMetafile class
    VOID
    SetMetafileDownLevelRasterizationLimit(
        UINT                    metafileRasterizationLimitDpi
        );

    // Used only when recording a EMF or EMF+ through GpMetafile class
    UINT
    GetMetafileDownLevelRasterizationLimit() const
    {
        return GpRound(MetafileRasterizationLimitDpi);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpdriver.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpDriver
*
* Abstract:
*
*   Represents the driver interface that a driver will implement.
*   Unfortunately, in this version, the meaning is a bit confused -
*   the member functions are not pure virtual - rather, they implement
*   the software rasterizer.
*
*   The plan is that the software rasterizer will look just like another
*   driver - DpDriver will be abstract, and the software rasterizer will
*   derive a class from DpDriver.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPDRIVER_HPP
#define _DPDRIVER_HPP

// Private data, used by GDI+.

struct DpDriverInternal;

#define DriverDrawImageFlags DWORD

#define DriverDrawImageCachedBackground  0x00000001
#define DriverDrawImageFirstImageBand    0x00000002
#define DriverDrawImageLastImageBand     0x00000004

//--------------------------------------------------------------------------
// Base driver class
//--------------------------------------------------------------------------

class DpDriver
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag                   Tag;    // Keep this as the 1st value in the object!
    struct DpDriverInternal *   Internal;

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpDriver : ObjectTagInvalid;
    }

public:

    BOOL IsLockable;                // TRUE if any surfaces with this
                                    //   driver interface are opaque, meaning
                                    //   that Lock() may not be called
    GpDevice *Device;               // Associated device

public:

    DpDriver();

    DpDriver(GpDevice *device)
    {
        SetValid(TRUE);     // set to valid state
        IsLockable = TRUE;
        Device = device;
        Internal = NULL;
    }

    virtual ~DpDriver();

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpDriver) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpDriver");
        }
    #endif

        return (Tag == ObjectTagDpDriver);
    }

    virtual VOID
    DesktopChangeNotification()
    {
        // do nothing
    }

    virtual VOID
    UpdateSurfacePixelFormat(DpBitmap *surface)
    {
        // do nothing.
        // used primarily by the multimon driver to update the pixel format
        // for the meta surface.
    }

    virtual VOID
    PaletteChangeNotification()
    {
        // do nothing
    }

    virtual VOID
    Flush(
        GpDevice           *device,
        DpBitmap           *surface,
        GpFlushIntention    intention)
    {
        surface->Flush(intention);
    }

    virtual VOID
    SetupClipping(
        HDC                 hdc,
        DpContext *         context,
        const GpRect *      drawBounds,
        BOOL &              isClip,
        BOOL &              usePathClipping,
        BOOL                forceClipping
        );

    virtual VOID
    RestoreClipping(
        HDC                 hdc,
        BOOL                isClip,
        BOOL                usePathClipping
        );

    virtual GpStatus
    StrokePath(
        DpContext *         context,
        DpBitmap *          surface,
        const GpRect *      drawBounds,
        const DpPath *      path,
        const DpPen *       pen
        );

    virtual GpStatus
    FillRects(
        DpContext *         context,
        DpBitmap *          surface,
        const GpRect *      drawBounds,
        INT                 numRects,       // NOTE: You must check for empty
        const GpRectF *     rects,          //       rectangles!
        const DpBrush *     brush
        );

    virtual GpStatus
    FillPath(
        DpContext *         context,
        DpBitmap *          surface,
        const GpRect *      drawBounds,
        const DpPath *      path,
        const DpBrush *     brush
        );

    virtual GpStatus
    FillRegion(
        DpContext *context,
        DpBitmap *surface,
        const GpRect *drawBounds,
        const DpRegion *region,
        const DpBrush *brush
        );

    virtual GpStatus
    SolidText(
        DpContext* context,
        DpBitmap* surface,
        const GpRect* drawBounds,
        GpColor   color,
        const GpGlyphPos *glyphPos,
        INT     count,
        GpTextRenderingHint textMode,
        BOOL rightToLeft
        );

    virtual GpStatus
    GdiText(
        HDC             hdc,
        INT             angle,          // In tenths of a degree
        const UINT16   *glyphs,
        const PointF   *glyphOrigins,
        INT             glyphCount,
        BOOL            rightToLeft,
        UINT16          blankGlyph = 0
    );


    virtual GpStatus
    BrushText(
        DpContext*        context,
        DpBitmap*         surface,
        const GpRect*     drawBounds,
        const DpBrush*    brush,
        const GpGlyphPos *glyphPos,
        INT               count,
        GpTextRenderingHint textMode
        );


    virtual GpStatus
    DrawGlyphs(
        DrawGlyphData *drawGlyphData
        );

    virtual GpStatus
    DrawImage(
        DpContext *         context,
        DpBitmap *          srcSurface,
        DpBitmap *          dstSurface,
        const GpRect *      drawBounds,
        const DpImageAttributes * imgAttributes,
        INT                 numPoints,
        const GpPointF *    dstPoints,
        const GpRectF *     srcRect,
        DriverDrawImageFlags flags
        );

    // Draw the CachedBitmap on the destination bitmap.

    virtual GpStatus
    DrawCachedBitmap(
        DpContext *context,
        DpCachedBitmap *src,
        DpBitmap *dst,
        INT x, INT y            // where to put it on the destination.
    );

    virtual GpStatus
    MoveBits(
        DpContext *context,
        DpBitmap *surface,
        const GpRect *drawBounds,
        const GpRect *dstRect,          // Device coordinates
        const GpPoint *srcPoint         // Device coordinates
        );


    //--------------------------------------------------------------------------
    // Low-level driver functions
    //--------------------------------------------------------------------------

    // !!! We will inevitably be adding more functions in the next version,
    //     which would mean that they would have to be added to the end
    //     of the VTable?
    // !!! Extend the following to represent low-level D3D token primitives

    //--------------------------------------------------------------------------
    // Direct access functions - Required if IsLockable
    //--------------------------------------------------------------------------

    // Lock can return FALSE only in the case of catastrophic failure
    // !!! What do we do about transitional surfaces?

    virtual GpStatus
    Lock(
        DpBitmap *surface,
        const GpRect *drawBounds,
        INT *stride,                    // [OUT] - Returned stride
        VOID **bits                     // [OUT] - Returned pointer to bits
        );

    virtual VOID
    Unlock(
        DpBitmap *surface
        );

protected:

    GpStatus
    SolidStrokePathOnePixel(
        DpContext *context,
        DpBitmap *surface,
        const GpRect *drawBounds,
        const DpPath *path,
        const DpPen *pen,
        BOOL  drawLast
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpimageattributes.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definiton of the DpImageAttributes structure which 
*   stores state needed by drivers for DrawImage.
*
* Notes:
*
* History:
*
*   3/9/2000 asecchia
*       Created it.
*
\**************************************************************************/

#ifndef _DPIMAGEATTRIBUTES_HPP
#define _DPIMAGEATTRIBUTES_HPP

//--------------------------------------------------------------------------
// Represent imageAttributes information
//--------------------------------------------------------------------------

struct DpImageAttributes
{    
    WrapMode wrapMode;    // specifies how to handle edge conditions
    ARGB clampColor;      // edge color for use with WrapModeClamp
    BOOL srcRectClamp;    // Do we clamp to the srcRect (true) or srcBitmap (false)
    BOOL ICMMode;         // TRUE = ICM on, FALSE = no ICM

    
    DpImageAttributes(WrapMode wrap = WrapModeClamp, 
                      ARGB color = (ARGB)0x00000000,
                      BOOL clamp = FALSE,
                      BOOL icmMode = FALSE)
    {
        wrapMode = wrap;
        clampColor = color;
        srcRectClamp = clamp;
        ICMMode = icmMode;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpcustomlinecap.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   CustomLineCap.hpp
*
* Abstract:
*
*   Class used for the custom line caps.
*
* Revision History:
*
*   02/21/00 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _DPCUSTOMLINECAP_HPP
#define _DPCUSTOMLINECAP_HPP

class DpCustomLineCap : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagCustomLineCap : ObjectTagInvalid);
    }

public:
    DpCustomLineCap() {}

    virtual BOOL IsValid() const
    {
        // If the line cap came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return GpObject::IsValid(ObjectTagCustomLineCap);
    }

    INT GetFillPointCount() const
    {
        ASSERT(IsValid());
        ASSERT((FillPath != NULL) && FillPath->IsValid());
        return FillPath->GetPointCount();
    }

    INT GetStrokePointCount() const
    {
        ASSERT(IsValid());
        ASSERT((StrokePath != NULL) && StrokePath->IsValid());
        return StrokePath->GetPointCount();
    }

    const GpPointF * GetFillPoints() const
    {
        ASSERT(IsValid());
        ASSERT((FillPath != NULL) && FillPath->IsValid());
        return FillPath->GetPathPoints();
    }

    const GpPointF * GetStrokePoints() const
    {
        ASSERT(IsValid());
        ASSERT((StrokePath != NULL) && StrokePath->IsValid());
        return StrokePath->GetPathPoints();
    }

    const BYTE * GetFillTypes() const
    {
        ASSERT(IsValid());
        ASSERT((FillPath != NULL) && FillPath->IsValid());
        return FillPath->GetPathTypes();
    }

    const BYTE * GetStrokeTypes() const
    {
        ASSERT(IsValid());
        ASSERT((StrokePath != NULL) && StrokePath->IsValid());
        return StrokePath->GetPathTypes();
    }

    GpStatus SetStrokeCaps(GpLineCap lineCap)
    {
        ASSERT(IsValid());
        return SetStrokeCaps(lineCap, lineCap);
    }

    GpStatus SetStrokeCaps(GpLineCap startCap, GpLineCap endCap)
    {
        ASSERT(IsValid());

        // Allow only non-anchor types of caps.

        GpStatus status = Ok;

        GpLineCap savedStartCap = StrokeStartCap;
        GpLineCap savedEndCap = StrokeEndCap;

        switch(startCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            StrokeStartCap = startCap;
            break;

        default:
            status = InvalidParameter;
            break;
        }

        if(status == Ok)
        {
            switch(endCap)
            {
            case LineCapFlat:
            case LineCapSquare:
            case LineCapRound:
            case LineCapTriangle:
                StrokeEndCap = endCap;
                break;

            default:
                status = InvalidParameter;
                break;
            }
        }

        if(status != Ok)
        {
            // Go back to the original caps.

            StrokeStartCap = savedStartCap;
            StrokeEndCap = savedEndCap;
        }

        return status;
    }

    GpStatus GetStrokeCaps(GpLineCap* startCap, GpLineCap* endCap) const
    {
        ASSERT(IsValid());

        if(startCap)
            *startCap = StrokeStartCap;

        if(endCap)
            *endCap = StrokeEndCap;

        return Ok;
    }

    GpStatus SetBaseCap(GpLineCap lineCap)
    {
        ASSERT(IsValid());

        // Allow only non-anchor types of caps.

        GpStatus status = Ok;

        switch(lineCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            BaseCap = lineCap;
            break;

        default:
            status = InvalidParameter;
            break;
        }

        return status;
    }

    GpStatus GetBaseCap(GpLineCap* baseCap) const
    {
        ASSERT(IsValid());

        if(baseCap)
            *baseCap = BaseCap;

        return Ok;
    }

    GpStatus SetBaseInset(REAL inset)
    {
        ASSERT(IsValid());

        BaseInset = inset;

        return Ok;
    }

    GpStatus GetBaseInset(REAL* inset) const
    {
        ASSERT(IsValid());

        if(inset)
            *inset = BaseInset;

        return Ok;
    }

    GpStatus SetStrokeJoin(GpLineJoin lineJoin)
    {
        ASSERT(IsValid());

        StrokeJoin = lineJoin;
        return Ok;
    }

    GpStatus GetStrokeJoin(GpLineJoin* lineJoin) const
    {
        ASSERT(IsValid());

        if(lineJoin)
        {
            *lineJoin = StrokeJoin;
            return Ok;
        }
        else
            return InvalidParameter;
    }
        
    GpStatus SetStrokeMiterLimit(REAL miterLimit)
    {
        ASSERT(IsValid());

        if(miterLimit > 1)
        {
            StrokeMiterLimit = miterLimit;
            return Ok;
        }
        else
            return InvalidParameter;
    }

    REAL GetStrokeMiterLimit() const
    {
        ASSERT(IsValid());

        return StrokeMiterLimit;
    }
    
    REAL GetStrokeLength() const
    {
        ASSERT(IsValid());

        return StrokeLength;
    }
    REAL GetFillLength() const
    {
        ASSERT(IsValid());

        return FillLength;
    }

    GpStatus SetWidthScale(REAL widthScale)
    {
        ASSERT(IsValid());

        WidthScale = widthScale;

        return Ok;
    }

    GpStatus GetWidthScale(REAL* widthScale) const
    {
        ASSERT(IsValid());

        if(widthScale)
            *widthScale = WidthScale;

        return Ok;
    }

    GpStatus SetFillHotSpot(const GpPointF& hotSpot)
    {
        ASSERT(IsValid());

        FillHotSpot = hotSpot;
        return Ok;
    }

    GpStatus GetFillHotSpot(GpPointF* hotSpot)
    {
        ASSERT(IsValid());

        if(!hotSpot)
            return InvalidParameter;

        *hotSpot = FillHotSpot;
        return Ok;
    }

    GpStatus SetStrokeHotSpot(const GpPointF& hotSpot)
    {
        ASSERT(IsValid());

        StrokeHotSpot = hotSpot;
        return Ok;
    }

    GpStatus GetStrokeHotSpot(GpPointF* hotSpot)
    {
        ASSERT(IsValid());

        if(!hotSpot)
            return InvalidParameter;

        *hotSpot = StrokeHotSpot;
        return Ok;
    }

    virtual BOOL IsEqual(const DpCustomLineCap* customLineCap) const = 0;

    virtual INT GetTransformedFillCap(
            GpPointF* points,
            BYTE* types,
            INT count,
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL mimimumWidth
            ) const = 0;

    virtual INT GetTransformedStrokeCap(
            INT cCapacity,       // In, initial pPoints & pTypes capacity
            GpPointF ** pPoints,    // In/out, may be reallocated here
            BYTE ** pTypes,         // In/out, may be reallocated here
            INT * pCount,           // In/out, may change here if flattened
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL minimumWidth
            ) const = 0;

    virtual REAL GetRadius(
            REAL lineWidth,
            REAL minimumWidth
            ) const = 0;

protected:
    GpLineCap           BaseCap;
    REAL                BaseInset;
    GpPointF            FillHotSpot;
    GpPointF            StrokeHotSpot;
    GpLineCap           StrokeStartCap;
    GpLineCap           StrokeEndCap;
    GpLineJoin          StrokeJoin;
    REAL                StrokeMiterLimit;
    REAL                WidthScale;
    REAL                FillLength;   // Length of the FillCap/StrokeCap from 
    REAL                StrokeLength; // zero along the positive y axis.           
                                      // Used for computing the direction of  
                                      // the cap.                             
    DpPath *            FillPath;
    DpPath *            StrokePath;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dppathiterator.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   dppathiterator.hpp
*
* Abstract:
*
*   Path iterator API
*
* Revision History:
*
*   11/13/99 ikkof
*       Created it
*
\**************************************************************************/

#ifndef _DPPATHITERATOR_HPP
#define _DPPATHITERATOR_HPP

class DpPathTypeIterator
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag               Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPathIterator : ObjectTagInvalid;
    }

public:
    DpPathTypeIterator()
    {
        Initialize();
    }

    DpPathTypeIterator(const BYTE* types, INT count)
    {
        Initialize();
        SetTypes(types, count);
    }

    ~DpPathTypeIterator()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    
    VOID SetTypes(const BYTE* types, INT count);

    virtual INT NextSubpath(INT* startIndex, INT* endIndex, BOOL* isClosed);
    INT NextPathType(BYTE* pathType, INT* startIndex, INT* endIndex);
    virtual INT NextMarker(INT* startIndex, INT* endIndex);

    virtual INT GetCount() {return Count;}
    virtual INT GetSubpathCount() {return SubpathCount;}

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(DpPathTypeIterator, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagPathIterator) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpPathTypeIterator");
        }
    #endif

        return (Tag == ObjectTagPathIterator);
    }
    BOOL HasCurve() {return HasBezier;}
    BOOL IsDashMode(INT index);
    BOOL IsExtendedPath() {return ExtendedPath;}

    VOID Rewind()
    {
        Index = 0;
        SubpathStartIndex = 0;
        SubpathEndIndex = -1;
        TypeStartIndex = 0;
        TypeEndIndex = -1;
        MarkerStartIndex = 0;
        MarkerEndIndex = -1;
    }

    VOID RewindSubpath()
    {
        // Set the start and end index of type to be the starting index of
        // the current subpath.  NextPathType() will start from the
        // beginning of the current subpath.

        TypeStartIndex = SubpathStartIndex;
        TypeEndIndex = -1;  // Indicate that this is the first type
                            // in the current subpath.
    
        // Set the current index to the start index of the subpath.

        Index = SubpathStartIndex;
    }

protected:
//    DpPathTypeIterator(DpPath* path);

    VOID Initialize()
    {
        Types = NULL;
        Count = 0;
        SubpathCount = 0;
        SetValid(TRUE);
        HasBezier = FALSE;
        ExtendedPath = FALSE;

        Rewind();
    }

    BOOL CheckValid();

protected:
    const BYTE* Types;
    INT Count;
    INT SubpathCount;
    BOOL HasBezier;
    BOOL ExtendedPath;

    INT Index;
    INT SubpathStartIndex;
    INT SubpathEndIndex;
    INT TypeStartIndex;
    INT TypeEndIndex;
    INT MarkerStartIndex;
    INT MarkerEndIndex;
};

class DpPathIterator : public DpPathTypeIterator
{
public:
    DpPathIterator()
    {
        Points = NULL;
    }

    DpPathIterator(const GpPointF* points, const BYTE* types, INT count)
    {
        Points = NULL;
        SetData(points, types, count);
    }

    DpPathIterator(const DpPath* path);

    VOID SetData(const GpPointF* points, const BYTE* types, INT count);
    VOID SetData(const DpPath* path);
    virtual INT NextSubpath(INT* startIndex, INT* endIndex, BOOL* isClosed);
    virtual INT NextSubpath(DpPath* path, BOOL* isClosed);
    virtual INT NextMarker(INT* startIndex, INT* endIndex);
    virtual INT NextMarker(DpPath* path);
    INT Enumerate(GpPointF *points, BYTE *types, INT count);
    INT CopyData(GpPointF* points, BYTE* types, INT startIndex, INT endIndex);

protected:
    VOID Initialize()
    {
        DpPathTypeIterator::Initialize();
        Points = NULL;
    }

    INT EnumerateWithinSubpath(GpPointF* points, BYTE* types, INT count);

protected:
    const GpPointF* Points;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dppen.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definiton of the DpPen structure which stores all of the
*   state needed by drivers to render with a pen.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*   12/8/99 bhouse
*       Major overhaul of DpPen.  No longer used as base class of GpPen.
*       Moved all driver required state into DpPen.  Changed to struct.
*
\**************************************************************************/

#ifndef _DPPEN_HPP
#define _DPPEN_HPP

//--------------------------------------------------------------------------
// Represent pen information
//--------------------------------------------------------------------------

struct DpPen
{
    BOOL IsEqual(const DpPen * pen) const
    {
        //!!! what to do about DeviceBrush and DashArray?

        BOOL isEqual =
                Type == pen->Type &&
                Width == pen->Width &&
                Unit == pen->Unit &&
                StartCap == pen->StartCap &&
                EndCap == pen->EndCap &&
                Join == pen->Join &&
                MiterLimit == pen->MiterLimit &&
                PenAlignment == pen->PenAlignment &&
                DashStyle == pen->DashStyle &&
                DashCap == pen->DashCap &&
                DashCount == pen->DashCount &&
                DashOffset == pen->DashOffset;

        if(isEqual)
        {
            if(CustomStartCap || pen->CustomStartCap)
            {
                if(CustomStartCap && pen->CustomStartCap)
                    isEqual = CustomStartCap->IsEqual(pen->CustomStartCap);
                else
                    isEqual = FALSE;    // One of them doesn't have
                                        // a custom cap.
            }
        }

        if(isEqual)
        {
            if(CustomEndCap || pen->CustomEndCap)
            {
                if(CustomEndCap && pen->CustomEndCap)
                    isEqual = CustomEndCap->IsEqual(pen->CustomEndCap);
                else
                    isEqual = FALSE;    // One of them doesn't have
                                        // a custom cap.
            }
        }

        return isEqual;
    }

    // Can the path be rendered using our nominal width pen code?

    BOOL IsOnePixelWideSolid(const GpMatrix *worldToDevice, REAL dpiX) const;
    BOOL IsOnePixelWide(const GpMatrix *worldToDevice, REAL dpiX) const;

    // See if the pen has a non-identity transform.

    BOOL HasTransform() const
    {
        return !Xform.IsIdentity();
    }

    BOOL IsSimple() const
    {
        return (!((DashStyle != DashStyleSolid)  ||
                  (StartCap & LineCapAnchorMask) ||
                  (EndCap & LineCapAnchorMask)   ||
                  (DashCap & LineCapAnchorMask)
                  ));
    }

    BOOL IsCompound() const
    {
        return ((CompoundCount > 0) && (CompoundArray != NULL));
    }

    BOOL IsCenterNoAnchor() const
    {
        return (!((StartCap & LineCapAnchorMask) ||
                  (EndCap & LineCapAnchorMask)   ||
                  (DashCap & LineCapAnchorMask)  
                  ));
    }

    VOID InitDefaults()
    {
        Type           = PenTypeSolidColor;
        Width          = 1;
        Unit           = UnitWorld;
        StartCap       = LineCapFlat;
        EndCap         = LineCapFlat;
        Join           = LineJoinMiter;
        MiterLimit     = 10;    // PS's default miter limit.
        PenAlignment   = PenAlignmentCenter;
        Brush          = NULL;
        DashStyle      = DashStyleSolid;
        DashCap        = LineCapFlat;
        DashCount      = 0;
        DashOffset     = 0;
        DashArray      = NULL;
        CompoundCount  = 0;
        CompoundArray  = NULL;
        CustomStartCap = NULL;
        CustomEndCap   = NULL;
    }

    GpPenType       Type;

    REAL            Width;
    GpUnit          Unit;
    GpLineCap       StartCap;
    GpLineCap       EndCap;
    GpLineJoin      Join;
    REAL            MiterLimit;
    GpPenAlignment  PenAlignment;
    
    const DpBrush * Brush;
    GpMatrix        Xform;

    GpDashStyle     DashStyle;
    GpLineCap       DashCap; // In v2, we should use GpDashCap for this
    INT             DashCount;
    REAL            DashOffset;
    REAL*           DashArray;

    INT             CompoundCount;
    REAL*           CompoundArray;
    DpCustomLineCap* CustomStartCap;
    DpCustomLineCap* CustomEndCap;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpregion.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpRegion.hpp
*
* Abstract:
*
*   DpRegion class operates on scan-converted Y spans of rects
*
* Created:
*
*   12/16/1998 DCurtis
*
\**************************************************************************/

#ifndef _DPREGION_HPP
#define _DPREGION_HPP

// Each Y span consists of 4 values
#define YSPAN_SIZE          4

#define YSPAN_YMIN          0   // minimum Y value (inclusive)
#define YSPAN_YMAX          1   // maximum Y value (exclusive)
#define YSPAN_XOFFSET       2   // offset into XCoords for this span
#define YSPAN_XCOUNT        3   // num XCoords for this span (multiple of 2)

#if 0
// The infinite max and min values are set up to be the greatest
// values that will interop with GDI HRGNs on WinNT successfully (divided by 2).
// We divide those values by 2 so that there is a little room to offset
// the GDI region and still have it work correctly.
// Of course, this won't work on Win9x -- we have to handle Win9x as
// a special case in the GetHRGN code.

#define INFINITE_MAX        0x03FFFFC7      // (0x07ffff8f / 2)
#define INFINITE_MIN        0xFC000038      // (0xF8000070 / 2)
#define INFINITE_SIZE       (INFINITE_MAX - INFINITE_MIN)

#else

// Instead of the above, let's use the largest possible integer value
// that is guaranteed to round trip correctly between float and int,
// but as above, let's leave a little head room so we can offset the region.

#include "float.h"

#define INFINITE_MAX        (1 << (FLT_MANT_DIG - 2))
#define INFINITE_MIN        (-INFINITE_MAX)
#define INFINITE_SIZE       (INFINITE_MAX - INFINITE_MIN)

#endif


class DpComplexRegion
{
public:
    INT             XCoordsCapacity;    // num XCoords (INTs) allocated
    INT             XCoordsCount;       // num XCoords (INTs) used

    INT             YSpansCapacity;     // num YSpans allocated
    INT             NumYSpans;          // NumYSpans used

    INT             YSearchIndex;       // search start index in YSpans

    INT *           XCoords;            // pointer to XCoords
    INT *           YSpans;             // pointer to YSpans
                                        // (XCoords + XCoordsCapacity)
public:
    INT * GetYSpan (INT spanIndex)
    {
        return YSpans + (spanIndex * YSPAN_SIZE);
    }

    VOID ResetSearchIndex()
    {
        YSearchIndex = NumYSpans >> 1;
    }

    BOOL YSpanSearch(INT y, INT ** ySpan, INT * spanIndex);
};

class DpRegionBuilder  : public GpOutputYSpan
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpRegionBuilder : ObjectTagInvalid;
    }

public:
    INT                 XMin;
    INT                 YMin;
    INT                 XMax;
    INT                 YMax;
    DpComplexRegion *   ComplexData;

public:
    DpRegionBuilder(INT ySpans)
    {
        SetValid(InitComplexData(ySpans) == Ok);
    }

    ~DpRegionBuilder()
    {
        GpFree(ComplexData);

        SetValid(FALSE);    // so we don't use a deleted object
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpRegionBuilder) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpRegionBuilder");
        }
    #endif

        return (Tag == ObjectTagDpRegionBuilder);
    }

    virtual GpStatus OutputYSpan(
        INT             yMin,
        INT             yMax,
        INT *           xCoords,    // even number of X coordinates
        INT             numXCoords  // must be a multiple of 2
        );

    GpStatus InitComplexData(INT ySpans);
};

// Forward Declaration for friendliness
class DpClipRegion;

// This class was constructed to optimize for space and speed for the common
// case of the region consisting of a single rectangle.  For that case of a
// simple region, we want the region to be as small and as fast as possible so
// that it is not expensive to have a region associated with every window.
class DpRegion
{
private:
    friend DpClipRegion;
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDpRegion : ObjectTagInvalid;
    }

protected:
    UINT32              Infinite : 1;
    UINT32              Empty    : 1;
    UINT32              Lazy     : 1;
    UINT32              Pad      : 29;

    INT                 XMin;
    INT                 YMin;
    INT                 XMax;       // exclusive
    INT                 YMax;       // exclusive

    DpComplexRegion *   ComplexData;
    mutable INT         Uniqueness;

public:
    enum Visibility
    {
        Invisible                   = 0,
        PartiallyVisible            = 1,
        ClippedVisible              = 2,
        TotallyVisible              = 3,
    };

public:
    DpRegion(BOOL empty = FALSE);       // default is infinite region
    DpRegion(const GpRect * rect);
    DpRegion(INT x, INT y, INT width, INT height);
    DpRegion(const DpPath * path, const GpMatrix * matrix);
    DpRegion(const DpRegion * region, BOOL lazy = FALSE);
    DpRegion(DpRegion & region);        // copy constructor
    DpRegion(const RECT * rects, INT count);
    ~DpRegion()
    {
        FreeData();

        SetValid(FALSE);    // so we don't use a deleted object
    }

    DpRegion &operator=( DpRegion & region );

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDpRegion) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DpRegion");
        }
    #endif

        return (Tag == ObjectTagDpRegion);
    }

    VOID     Set(INT x, INT y, INT width, INT height);
    VOID     Set(GpRect * rect)
    {
        ASSERT (rect != NULL);
        Set(rect->X, rect->Y, rect->Width, rect->Height);
    }
    GpStatus Set(const DpPath * path, const GpMatrix * matrix); // path is in world units
    GpStatus Set(const DpRegion * region, BOOL lazy = FALSE);
    GpStatus Set(const RECT * rects, INT count);
    VOID     SetInfinite();
    VOID     SetEmpty();

    GpStatus Offset(INT xOffset, INT yOffset);

    GpStatus And       (const DpRegion * region);
    GpStatus Or        (const DpRegion * region);
    GpStatus Xor       (const DpRegion * region);
    GpStatus Exclude   (const DpRegion * region);
    GpStatus Complement(const DpRegion * region);

    INT      GetXMin() const        { ASSERT(IsValid()); return XMin; }
    INT      GetYMin() const        { ASSERT(IsValid()); return YMin; }
    INT      GetXMax() const        { ASSERT(IsValid()); return XMax; }
    INT      GetYMax() const        { ASSERT(IsValid()); return YMax; }

    INT      GetUniqueness() const
    {   ASSERT(IsValid());
        if (Uniqueness == 0)
        {
            Uniqueness = GenerateUniqueness();
        }
        return Uniqueness;
    }

    VOID UpdateUID()         { ASSERT(IsValid()); Uniqueness = 0; }

    VOID GetBounds(GpRect * bounds) const
    {
        ASSERT(IsValid());
        ASSERT(bounds != NULL);

        bounds->X      = XMin;
        bounds->Y      = YMin;
        bounds->Width  = XMax - XMin;
        bounds->Height = YMax - YMin;
    }

    VOID GetBounds(GpPointF * topLeft, GpPointF * bottomRight) const
    {
        ASSERT(IsValid());
        ASSERT((topLeft != NULL) && (bottomRight != NULL));

        topLeft->X     = (REAL)XMin;
        topLeft->Y     = (REAL)YMin;
        bottomRight->X = (REAL)XMax;
        bottomRight->Y = (REAL)YMax;
    }

    BOOL IsEqual(DpRegion * region);

    BOOL IsEmpty() const
    {
        ASSERT(IsValid());
        return Empty;
    }

    BOOL IsInfinite() const
    {
        ASSERT(IsValid());
        return Infinite;
    }

    // Empty and Infinite regions are always simple as well.
    BOOL IsSimple() const
    {
        ASSERT(IsValid());
        return (ComplexData == NULL);
    }

    BOOL IsComplex() const
    {
        return !IsSimple();
    }

    Visibility GetRectVisibility(
        INT         xMin,
        INT         yMin,
        INT         xMax,
        INT         yMax,
        GpRect *    rectClipped = NULL
        );

    BOOL RegionVisible (DpRegion * region);
    BOOL RectVisible(INT xMin, INT yMin, INT xMax, INT yMax);
    BOOL RectVisible(GpRect * rect)
    {
        return RectVisible(rect->X, rect->Y,
                           rect->X + rect->Width, rect->Y + rect->Height);
    }
    BOOL RectInside (INT xMin, INT yMin, INT xMax, INT yMax);
    BOOL PointInside(INT x, INT y);

    GpStatus Fill(DpOutputSpan * output, GpRect * clipBounds) const;

    HRGN GetHRgn() const;

    BOOL GetOutlinePoints(DynPointArray& points,
                          DynByteArray& types) const;

    // If rects is NULL, return the number of rects in the region.
    // Otherwise, assume rects is big enough to hold all the region rects
    // and fill them in and return the number of rects filled in.
    INT GetRects(GpRect *  rects) const;
    INT GetRects(GpRectF * rects) const;

protected:
    VOID FreeData()
    {
        if (!Lazy)
        {
            GpFree(ComplexData);
        }
        ComplexData = NULL;
        Lazy        = FALSE;
    }

    GpStatus Set(DpRegionBuilder & regionBuilder);

    // If rects is NULL, return the number of rects in the region.
    // Otherwise, assume rects is big enough to hold all the region rects
    // and fill them in and return the number of rects filled in.
    INT GetRects(RECT * rects, BOOL clampToWin9xSize = FALSE) const;

    GpStatus CompactAndOutput(
        INT                     yMin,
        INT                     yMax,
        INT *                   xCoords,
        INT                     numXCoords,
        DpRegionBuilder *       regionBuilder,
        DynIntArray *           combineCoords
        );

    GpStatus Diff(
        DpRegion *      region1,
        DpRegion *      region2,
        BOOL            set1
        );

    GpStatus XSpansAND (
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

    GpStatus XSpansOR  (
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

    GpStatus XSpansXOR (
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

    GpStatus XSpansDIFF(
        DynIntArray *   combineCoords,
        INT *           xSpan1,
        INT             numXCoords1,
        INT *           xSpan2,
        INT             numXCoords2
        );

private:
    static INT
    GenerateUniqueness(
        )
    {
        LONG_PTR Uid;
        static LONG_PTR gUniqueness = 0 ;

        // Use InterlockedCompareExchangeFunction instead of
        // InterlockedIncrement, because InterlockedIncrement doesn't work
        // the way we need it to on Win9x.

        do
        {
            Uid = gUniqueness;
        } while (CompareExchangeLong_Ptr(&gUniqueness, (Uid + 1), Uid) != Uid);

        return (INT) (Uid + 1);
    }

};

class DpClipRegion : public DpRegion,
                     public DpOutputSpan
{
public:
    enum Direction
    {
        NotEnumerating,
        TopLeftToBottomRight,
        TopRightToBottomLeft,
        BottomLeftToTopRight,
        BottomRightToTopLeft
    };

protected:
    DpOutputSpan *      OutputClippedSpan;
    DpRegion            OriginalRegion;      // The old Region
    BOOL                ComplexClipDisabled; // Did we disable the complexClip

    // enumeration stuff
    Direction           EnumDirection;
    INT                 EnumSpan;

private:
friend class DriverPrint;

    // This is a special method intended for use only by DriverPrint.
    VOID StartBanding()
    {
        ASSERT(IsValid());
        ASSERT(!Empty);     // if clipping is empty, we shouldn't be banding

        ASSERT(ComplexClipDisabled == FALSE); // Unless we are banding we can't
                                              // have ComplexClip disabled
        ASSERT(OriginalRegion.IsEmpty());

        // Save the current information of the ClipRegion into OriginalRegion
        // this is done by setting the complexData to our current complexData
        ASSERT(OriginalRegion.ComplexData == NULL);
        OriginalRegion.ComplexData = ComplexData;
        OriginalRegion.Lazy = Lazy;
        OriginalRegion.Uniqueness = Uniqueness;
        OriginalRegion.Infinite = Infinite;
        OriginalRegion.Empty = Empty;
        OriginalRegion.XMin = XMin;
        OriginalRegion.YMin = YMin;
        OriginalRegion.XMax = XMax;
        OriginalRegion.YMax = YMax;


        // We don't want to both regions to point to the same data
        ComplexData = NULL;
        Lazy = FALSE;

        // Create a lazy region so that we don't copy unless needed
        Set(&OriginalRegion, TRUE);
    }

    // This is a special method intended for use only by DriverPrint.
    VOID EndBanding()
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());
        ASSERT(!ComplexClipDisabled); // Make sure that we don't leave an opened
                                      // DisableComplexClip call

        // Free our Data, we can't be Lazy
        FreeData();
        ASSERT(ComplexData == NULL);
        ComplexData = OriginalRegion.ComplexData;
        Lazy = OriginalRegion.Lazy;
        Uniqueness = OriginalRegion.Uniqueness;
        Infinite = OriginalRegion.Infinite;
        Empty = OriginalRegion.Empty;
        XMin = OriginalRegion.XMin;
        YMin = OriginalRegion.YMin;
        XMax = OriginalRegion.XMax;
        YMax = OriginalRegion.YMax;

        // We don't want to both regions to point to the same data
        OriginalRegion.ComplexData = NULL;
        OriginalRegion.Lazy = FALSE;
		OriginalRegion.SetEmpty();
    }

    // This is a special method intended for use only by DriverPrint.
    // We're relying on DriverPrint to restore the bounds back correctly
    // after it's done with banding (by bracketing the banding with
    // StartBanding and EndBanding calls).

    // This works, even when there is complex clipping, because OutputSpan
    // clips against the bounds before clipping against the complex region.
    VOID SetBandBounds(GpRect & bandBounds, BOOL doIntersect = TRUE)
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());
        ASSERT((bandBounds.Width > 0) && (bandBounds.Height > 0));

        GpRect  intersectedBounds;

        if (!doIntersect)
        {
            // We are coming from DisableComplexClipping. We should not have
            // any ComplexData.
            ASSERT(!Lazy);
            ASSERT(ComplexData == NULL);

            // The reason for not doing the intersection is that sometimes
            // printing using a capped DPI which means that the bandBounds is
            // using a different coordinate system than the original region.
            intersectedBounds = bandBounds;
        }
        else 
        {
            GpRect boundsOriginal(OriginalRegion.XMin, OriginalRegion.YMin,
                                  OriginalRegion.XMax - OriginalRegion.XMin,
                                  OriginalRegion.YMax - OriginalRegion.YMin);
            if (!GpRect::IntersectRect(intersectedBounds, bandBounds, boundsOriginal))
            {
                // intersection is empty
                SetEmpty();
                return;
            }
        }

        // Create a region for our band
        DpRegion newRegion(&intersectedBounds);

        // If we haven't disabled the complex clipping, then restore the original
        // complexRegion and intersect with our current region
        if (!ComplexClipDisabled)
        {
            // Get the original Clipping Region
            Set(&OriginalRegion, TRUE);

            // Intersect with our current band
            And(&newRegion);
        }
        else
        {
            // We've disabled the complexClipping, Set the clipping to our band
            Set(&newRegion);
            ASSERT(ComplexData == NULL);
        }
    }

    // This is a special method intended for use only by DriverPrint.
    // We're relying on DriverPrint to re-enable the complex clipping
    // and to restore the bounds back correctly after it's done with banding
    // (by bracketing the banding with StartBanding and EndBanding calls).
    // Typically, when we disable complex clipping, it's because we are
    // using a capped DPI, which means that the bandBounds is in a different
    // resolution than the original clipping region.
    VOID DisableComplexClipping(GpRect & bandBounds, BOOL doIntersect = FALSE)
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());

        // Make sure that we call ourselves twice in a row
        ASSERT(ComplexClipDisabled == FALSE);

        ComplexClipDisabled = TRUE;

        Set(&bandBounds);
        ASSERT(ComplexData == NULL);
        SetBandBounds(bandBounds, doIntersect);
    }

    // This is a special method intended for use only by DriverPrint.
    VOID ReEnableComplexClipping()
    {
        ASSERT(IsValid());
        ASSERT(!OriginalRegion.IsEmpty());
        ASSERT(ComplexClipDisabled);

        ComplexClipDisabled = FALSE;

        // Set the clipping back to the original state, make in Lazy
        Set(&OriginalRegion, TRUE);
    }

public:
    DpClipRegion(BOOL empty = FALSE) : DpRegion(empty)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(const GpRect * rect) : DpRegion(rect)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(INT x, INT y, INT width, INT height) :
                DpRegion(x, y, width, height)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(const DpPath * path, const GpMatrix * matrix) : DpRegion (path, matrix)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(const DpRegion * region) : DpRegion(region)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }
    DpClipRegion(DpClipRegion & region) : DpRegion(region)
    {
        OutputClippedSpan   = NULL;
        ComplexClipDisabled = FALSE;
#if DBG
        OriginalRegion.SetEmpty();
#endif
    }

    VOID StartEnumeration (
        INT         yMin,
        Direction   direction = TopLeftToBottomRight
        );

    // returns FALSE when done enumerating
    // numRects going in is the number of rects in the buffer and going out
    // is the number of rects that we filled.
    BOOL Enumerate (
        GpRect *    rects,
        INT &       numRects
        );

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    VOID InitClipping(DpOutputSpan * outputClippedSpan, INT yMin);

    // EndClipping is here only for debugging (and the Rasterizer doesn't
    // call it):
    VOID EndClipping() {}

    virtual BOOL IsValid() const { return TRUE; }
};

#endif // _DPREGION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dpscan.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpScan
*
* Abstract:
*
*   Contains the declarations for the scan-interface methods.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*   08/03/2000 asecchia
*       Moved and renamed into the render directory.
*
\**************************************************************************/

#ifndef _DPSCAN_HPP
#define _DPSCAN_HPP

// DpScan moved into the render directory because
// it's specific to the software rasterizer.
// It's also been renamed from DpScan to EpScan.

// If we need to export a scan interface from the drivers
// for access to opaque bitmaps, we should abstract the interface
// from EpScan and place it here - then EpScan should inherit that
// interface from the DDK because the software rasterizer (EpXXX) is 
// a driver.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\ddkinc\dppath.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-2000  Microsoft Corporation
*
* Module Name:
*
*   DpPath
*
* Abstract:
*
*   A DDI-level path object. Corresponds to a GpPath object.
*
* Notes:
*
*
*
* Created:
*
*   12/01/1998 andrewgo
*       Created it.
*   03/24/1999 agodfrey
*       Moved into separate file.
*
\**************************************************************************/

#ifndef _DPPATH_HPP
#define _DPPATH_HPP

//--------------------------------------------------------------------------
// Represent a path
//--------------------------------------------------------------------------


class DpPath : public GpObject
{
public:

    enum DpPathFlags        // !!! Rename and move?
    {
        PossiblyNonConvex   = 0x00,
        Convex              = 0x01,
        ConvexRectangle     = 0x03      // Used for Rectangle and Oval.
    };

    ~DpPath() {}

    // Start/end a subpath

    virtual VOID StartFigure()
    {
        IsSubpathActive = FALSE;
        UpdateUid();
    }

    virtual GpStatus CloseFigure();
    virtual GpStatus CloseFigures();

    BOOL HasCurve() const
    {
        return HasBezier;
    }

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagPath);
    }

    BOOL IsConvex() const
    {
        return ((Flags & Convex) != 0);
    }

    INT GetSubpathCount() const
    {
        return SubpathCount;
    }

    virtual GpStatus Flatten(
        DynByteArray *flattenTypes,
        DynPointFArray *flattenPoints,
        const GpMatrix *matrix = NULL,
        const REAL flatness = FlatnessDefault
    ) const = 0;

    virtual const DpPath*
    GetFlattenedPath(
        const GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const = 0;

    VOID
    Offset(
        REAL dx,
        REAL dy
        );

    GpFillMode GetFillMode() const
    {
        return FillMode;
    }

    VOID SetFillMode(GpFillMode fillMode)
    {
        if (FillMode != fillMode)
        {
            FillMode = fillMode;
            UpdateUid();
        }
    }

    // Get path data

    INT GetPointCount() const
    {
        return Points.GetCount();
    }

    const GpPointF* GetPathPoints() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Points.GetDataBuffer();
    }

    const BYTE* GetPathTypes() const
    {
        // NOTE: We're returning a pointer to our
        // internal buffer here. No copy is made.

        return Types.GetDataBuffer();
    }

    BOOL IsRectangular() const
    {
        const GpPointF *points;
        INT count;

        if (HasCurve() || (GetSubpathCount() != 1)) 
        {
            return FALSE;
        }

        count = GetPointCount();
        points = GetPathPoints();

        if (count > 0 && points != NULL) 
        {
            for (INT i=0; i<count; i++) 
            {
                INT j = (i+1) % count;

                if (REALABS(points[i].X-points[j].X) > REAL_EPSILON &&
                    REALABS(points[i].Y-points[j].Y) > REAL_EPSILON) 
                {
                    // Points are not at 90 degree angles, not rectangular.
                    return FALSE;
                }
            }

            return TRUE;
        }

        return FALSE;
    }
    
    static BOOL
    ValidatePathTypes(
        const BYTE* types,
        INT count,
        INT* subpathCount,
        BOOL* hasBezier
        );

    GpStatus GetPathData(GpPathData* pathData);

    GpStatus SetPathData(const GpPathData* pathData);

    virtual ObjectType GetObjectType() const { return ObjectTypePath; }
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual DpPath*
    CreateWidenedPath(
        const DpPen* pen,
        DpContext* context,
        BOOL outline = FALSE
        ) const
    {
        return DpcCreateWidenedPath(this, pen, context, outline);
    }

    virtual VOID
    DeletePath()
    {
        DpcDeletePath(this);
    }

    virtual DpPath*
    ClonePath()
    {
        return DpcClonePath(this);
    }

    virtual VOID
    Transform(
        GpMatrix* matrix
    )
    {
        DpcTransformPath(this, matrix);
    }
    
    BOOL
    virtual IsRectangle(
        const GpMatrix * matrix,
        GpRectF * transformedBounds
        ) const;

    // Debug only.
    
    #if DBG
    void DisplayPath();
    #endif
    
    class SubpathInfo
    {
    public:
        INT StartIndex;
        INT Count;
        BOOL IsClosed;
    };

protected: // GDI+ INTERNAL

    DpPath()
    {
        InitDefaultState(FillModeAlternate);
        SetValid(TRUE);
    }

    DpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    DpPath(const DpPath *path);

    virtual VOID InitDefaultState(GpFillMode fillMode);

    virtual DynArray<SubpathInfo> *GetSubpathInformation() const = 0;

protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagPath : ObjectTagInvalid);
    }

protected:

    BOOL HasBezier;         // does path have Bezier segments?
    DynArrayIA<BYTE, 16> Types;
    DynArrayIA<GpPointF, 16> Points;
    GpFillMode FillMode;
    DpPathFlags Flags;
    BOOL IsSubpathActive;   // whether there is an active subpath
    INT SubpathCount;       // number of subpaths
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\life\resource.h ===
#define IDS_DESCRIPTION                 1


#define DLG_SCRNSAVECONFIGURE         2003 


#define idsIniFile                    1001
#define idsAppName                    1007

#define ID_SPEED                      1003
#define IDC_RADIOTYPE1                1054
#define IDC_RADIOTYPE2                1055
#define IDC_RADIOTYPE3                1056
#define IDC_RADIOTYPE4                1057
#define IDC_RADIOTYPE5                1058


#define ID_OK                         1011
#define ID_CANCEL                     1012
#define ID_DIR                        1013
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\life\life.hpp ===
#ifndef __GDIPSCSAVE_H
#define __GDIPSCSAVE_H

#include <windows.h>
#include <objbase.h>
#include <scrnsave.h>
#include "resource.h"
#include <gdiplus.h>
#include <shlobj.h>

using namespace Gdiplus;

WCHAR szAppName[APPNAMEBUFFERLEN];

#define SPEED_MIN 0
#define SPEED_MAX 100
#define SPEED_DEF 50

#define TILESIZE_MIN 0
#define TILESIZE_MAX 4
#define TILESIZE_DEF 2

VOID DrawLifeIteration(HDC hdc);
VOID InitLifeMatrix();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sdk\gpinit.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is probably specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects.
*   The ordering is important when apps make global GDI+ objects.
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"
#include "gpinit.h"

GdiplusInitHelper::GdiplusInitHelper() : gpToken(0), Valid(FALSE)
{
    Gdiplus::GdiplusStartupInput sti;
    if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
    {
        Valid = TRUE;
    }
}
    
GdiplusInitHelper::~GdiplusInitHelper()
{
    if (Valid)
    {
        Gdiplus::GdiplusShutdown(gpToken);
    }
}

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sdk\gpinit.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/25/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _GPINIT_H
#define _GPINIT_H

class GdiplusInitHelper
{
public:
    GdiplusInitHelper();
    ~GdiplusInitHelper();
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

extern GdiplusInitHelper gGdiplusInitHelper;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sdk\gpinit.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects
*   (important when apps make global GDI+ objects.)
*
* Notes:
*
*   A test app should include this in *just one* of its .cpp files.
*   It should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
*   We use "#pragma code_seg()", which resets the code segment to "whatever
*   it was when compilation began" (MSDN). In other words, we stomp on whatever
*   the code segment might have been changed to before this file was included.
*   You don't need to worry about this unless you use "#pragma code_seg"
*   yourself, in the file which includes this one.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        Gdiplus::GdiplusStartupInput sti;
        if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
        {
            Valid = TRUE;
        }
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            Gdiplus::GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sdk\sdktest.cpp ===
// sdktest.cpp : Defines the entry point for the application.
//

#include "sdktest.h"

#include "..\gpinit.inc"

#include <stdio.h>

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;                    // current instance
HWND hWndMain = NULL;
TCHAR szTitle[MAX_LOADSTRING];        // The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];// The title bar text

// Foward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK    Settings(HWND, UINT, WPARAM, LPARAM);

UINT_PTR timerID = 0;
int timercount = 0;
BOOL suspend = FALSE;

typedef struct
{
    HDC        hdc;
    HBITMAP    hbmpOffscreen;
    HBITMAP    hbmpOld;
    BITMAPINFO bmi;
    void      *pvBits;
}
OFFSCREENINFO;

OFFSCREENINFO offscreenInfo = { 0 };

void FreeOffscreen()
{
    if (offscreenInfo.hdc)
    {
        SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOld);
        DeleteObject(offscreenInfo.hbmpOffscreen);
        DeleteDC(offscreenInfo.hdc);

        offscreenInfo.hdc = (HDC)NULL;
        offscreenInfo.hbmpOffscreen = (HBITMAP)NULL;
        offscreenInfo.hbmpOld = (HBITMAP)NULL;
        offscreenInfo.bmi.bmiHeader.biWidth = 0;
        offscreenInfo.bmi.bmiHeader.biHeight = 0;
    }
}

void ClearOffscreen()
{
    if (offscreenInfo.hdc)
    {
        PatBlt(
            offscreenInfo.hdc,
            0,
            0,
            offscreenInfo.bmi.bmiHeader.biWidth,
            offscreenInfo.bmi.bmiHeader.biHeight,
            WHITENESS);
    }

    InvalidateRect(hWndMain, NULL, TRUE);
}

HDC GetOffscreen(HDC hDC, int width, int height)
{
    HDC hdcResult = NULL;

    if (width > offscreenInfo.bmi.bmiHeader.biWidth ||
        height > offscreenInfo.bmi.bmiHeader.biHeight ||
        offscreenInfo.hdc == (HDC)NULL)
    {
        FreeOffscreen();

        offscreenInfo.bmi.bmiHeader.biSize = sizeof(offscreenInfo.bmi.bmiHeader);
        offscreenInfo.bmi.bmiHeader.biWidth = width;
        offscreenInfo.bmi.bmiHeader.biHeight = height;
        offscreenInfo.bmi.bmiHeader.biPlanes = 1;
        offscreenInfo.bmi.bmiHeader.biBitCount = 32;
        offscreenInfo.bmi.bmiHeader.biCompression = BI_RGB;
        offscreenInfo.bmi.bmiHeader.biSizeImage = 0;
        offscreenInfo.bmi.bmiHeader.biXPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biYPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biClrUsed = 0;
        offscreenInfo.bmi.bmiHeader.biClrImportant = 0;

        offscreenInfo.hbmpOffscreen = CreateDIBSection(
            hDC,
            &offscreenInfo.bmi,
            DIB_RGB_COLORS,
            &offscreenInfo.pvBits,
            NULL,
            0);

        if (offscreenInfo.hbmpOffscreen)
        {
            offscreenInfo.hdc = CreateCompatibleDC(hDC);

            if (offscreenInfo.hdc)
            {
                offscreenInfo.hbmpOld = (HBITMAP)SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOffscreen);

                ClearOffscreen();
            }
        }
    }

    hdcResult = offscreenInfo.hdc;

    return hdcResult;
}

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    MSG msg;
    HACCEL hAccelTable;

    if (!gGdiplusInitHelper.IsValid())
        return 0;

    // Initialize global strings
    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadString(hInstance, IDC_SDKTEST, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow)) 
    {
        return FALSE;
    }

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_SDKTEST);

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    FreeOffscreen();

    return (int)msg.wParam;
}


//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEX wcex;

    wcex.cbSize = sizeof(WNDCLASSEX); 

    wcex.style            = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = (WNDPROC)WndProc;
    wcex.cbClsExtra        = 0;
    wcex.cbWndExtra        = 0;
    wcex.hInstance        = hInstance;
    wcex.hIcon            = LoadIcon(hInstance, (LPCTSTR)IDI_SDKTEST);
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground    = (HBRUSH)NULL;
    wcex.lpszMenuName    = (LPCSTR)IDC_SDKTEST;
    wcex.lpszClassName    = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

    return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT rectDesktop;
    RECT rectWnd;

    HWND hWndDesktop = GetDesktopWindow();

    GetWindowRect(hWndDesktop, &rectDesktop);

    rectWnd = rectDesktop;

    rectWnd.top += 100;
    rectWnd.left += 100;
    rectWnd.right -= 100;
    rectWnd.bottom -= 100;

    hInst = hInstance; // Store instance handle in our global variable

    hWndMain = CreateWindow(
        szWindowClass,
        szTitle,
        WS_OVERLAPPEDWINDOW,
        rectWnd.left, rectWnd.top,
        rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top,
        NULL,
        NULL,
        hInstance,
        NULL);

    if (!hWndMain)
    {
        return FALSE;
    }

    ShowWindow(hWndMain, nCmdShow);
    UpdateWindow(hWndMain);

    timerID = SetTimer(hWndMain, 1, 10, NULL);

    return TRUE;
}

void DrawGraphics(HWND hWnd, HDC hDC, LPRECT lpRectDraw, LPRECT lpRectBounds)
{
    RECT rectBounds = *lpRectDraw;
    Graphics *gr = NULL;

    gr = new Graphics(hDC);

    gr->ResetTransform();
    gr->SetPageUnit(UnitPixel);

    //===================================================================
    //
    // Insert your SDK code here \|/  \|/  \|/  \|/
    //
    //===================================================================


    //===================================================================
    //
    // Insert your SDK code here /|\  /|\  /|\  /|\
    //
    //===================================================================

    if (lpRectBounds)
    {
        *lpRectBounds = rectBounds;
    }

    delete gr;
}

LRESULT PaintWnd(HWND hWnd, HDC hDC)
{
    RECT rectClient;
    RECT rectDraw;
    
    GetClientRect(hWnd, &rectClient);

    int width  = rectClient.right - rectClient.left;
    int height = rectClient.bottom - rectClient.top;

    // Setup the drawing rectangle relative to the client
    rectDraw.left   = 0;
    rectDraw.top    = 0;
    rectDraw.right  = (rectClient.right - rectClient.left);
    rectDraw.bottom = (rectClient.bottom - rectClient.top);

    // Now draw within this rectangle with GDI+ ...
    {
        // Render everything to an offscreen buffer instead of
        // directly to the display surface...
        HDC hdcOffscreen = NULL;
        int width, height;
        RECT rectOffscreen;

        width = rectDraw.right - rectDraw.left;
        height = rectDraw.bottom - rectDraw.top;

        rectOffscreen.left   = 0;
        rectOffscreen.top    = 0;
        rectOffscreen.right  = width;
        rectOffscreen.bottom = height;

        hdcOffscreen = GetOffscreen(hDC, width, height);

        if (hdcOffscreen)
        {
            DrawGraphics(hWnd, hdcOffscreen, &rectOffscreen, NULL);

            StretchBlt(
                hDC,
                rectDraw.left,
                rectDraw.top,
                width,
                height,
                hdcOffscreen,
                0,
                0,
                width,
                height,
                SRCCOPY);
        }

        ReleaseDC(hWnd, hDC);
    }

    return 0;
}

static RECT rectLast = {0, 0, 0, 0};

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND    - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY    - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message) 
    {
        case WM_WINDOWPOSCHANGED:
        {
            timercount = 0;
            ClearOffscreen();
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
        }
        break;

        case WM_LBUTTONDOWN:
        {
            timercount = 0;
            ClearOffscreen();
        }
        break;

        case WM_RBUTTONDOWN:
        {
        }
        break;

        case WM_TIMER:
        {
        }
        break;

        case WM_COMMAND:
        {
            int wmId, wmEvent;

            wmId    = LOWORD(wParam);
            wmEvent = HIWORD(wParam);

            // Parse the menu selections:
            switch (wmId)
            {
                case IDM_SETTINGS:
                {
                    suspend = TRUE;
                    if (DialogBox(hInst, (LPCTSTR)IDD_SETTINGS, hWnd, (DLGPROC)Settings) == IDOK)
                    {
                        timercount = 0;
                        ClearOffscreen();
                    }

                    InvalidateRect(hWnd, NULL, TRUE);
                    suspend = FALSE;
                }
                break;

                case IDM_ABOUT:
                    DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
                break;

                case IDM_EXIT:
                    DestroyWindow(hWnd);
                break;

                default:
                    lresult = DefWindowProc(hWnd, message, wParam, lParam);
                break;
            }
        }
        break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(hWnd, &ps);

            lresult = PaintWnd(hWnd, hdc);

            EndPaint(hWnd, &ps);
        }
        break;

        case WM_DESTROY:
        {
            PostQuitMessage(0);
        }
        break;

        default:
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
   }

   return lresult;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
            lresult = TRUE;
        break;

        case WM_COMMAND:
        {
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
            {
                EndDialog(hDlg, LOWORD(wParam));
                lresult = TRUE;
            }
        }
        break;
    }

    return lresult;
}

// Message handler for settings dlg
LRESULT CALLBACK Settings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            lresult = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                }
                // break; - fall through so the dialog closes!

                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    lresult = TRUE;
                }
                break;
            }
        }
        break;
    }

    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sdk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sdktest.rc
//
#define IDC_MYICON                      2
#define IDD_TESTBED_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDM_SETTINGS                    106
#define IDI_SDKTEST                     107
#define IDI_SMALL                       108
#define IDC_SDKTEST                     109
#define IDD_SETTINGS                    110
#define IDR_MAINFRAME                   128

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\life\life.cpp ===
/**************************************************************************
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   life.cpp
*
* Abstract:
*
*   Conway's game of Life using GDI+.
*
* Revision History:
*
*   9/12/2000  asecchia - Created it.
*
***************************************************************************/

#include "life.hpp"
#include <math.h>

// This needs to be set on the command line. See the sources file.
// Turning this switch on causes the screen saver to run in a window from
// the command line, making debuggin a lot easier.

#ifdef STANDALONE_DEBUG
HINSTANCE hMainInstance;
HWND ghwndMain;
HBRUSH ghbrWhite;

TCHAR szIniFile[MAXFILELEN];
#else
extern HINSTANCE hMainInstance; /* screen saver instance handle  */ 
#endif

// ASSERT code.

#if DBG

#define ASSERT(a) if(!(a)) { DebugBreak();}

#else
#define ASSERT(a)
#endif

// explicit unreferenced parameter.

#define UNREF(a) (a);

#define CBSIZE 40

class CachedImageArray
{
    CachedBitmap *cbArray[CBSIZE];
    int num;
    
    public:
    CachedImageArray()
    {
        num = 0;
    }
    
    // Cache an entry.
    
    bool Add(CachedBitmap *cb)
    {
        if(num>=CBSIZE)
        {
            return false;
        }
        
        cbArray[num] = cb;
        num++;
        
        return true;
    }
    
    int Size() {return num;}
    
    CachedBitmap *operator[] (int i)
    {
        if( (i<0) || (i>=num) )
        {
            return NULL;
        }
        
        return cbArray[i];
    }
    // Throw everything away.
    
    void Dispose()
    {
        for(int i=0; i<num; i++)
        {
            delete cbArray[i];
        }
        num = 0;
    }
    
    ~CachedImageArray()
    {
        Dispose();
    }
};


/**********************************************************************
*
*  Handle configuration dialog
*
***********************************************************************/


INT *gLifeMatrix=NULL;
INT *gTempMatrix=NULL;
CachedImageArray *CachedImages;
INT gWidth;
INT gHeight;

DWORD gGenerationColor;
INT gSizeX;
INT gSizeY;
INT gGenerations;
INT gCurrentGeneration;
INT currentImage;
INT maxImage;

INT nTileSize;
INT nSpeed;

INT red, green, blue;
INT ri, gi, bi;

HANDLE ghFile;

WCHAR gDirPath[MAX_PATH];




struct OFFSCREENINFO
{
    HDC        hdc;
    HBITMAP    hbmpOffscreen;
    HBITMAP    hbmpOld;
    BITMAPINFO bmi;
    void      *pvBits;
};

OFFSCREENINFO gOffscreenInfo = { 0 };

const int b_heptomino_x = 29;
const int b_heptomino_y = 11;
const char b_heptomino[320] = 
    "00000000000000000100000000000"
    "11000000000000000110000000011"
    "11000000000000000011000000011"
    "00000000000000000110000000000"
    "00000000000000000000000000000"
    "00000000000000000000000000000"
    "00000000000000000000000000000"
    "00000000000000000110000000000"
    "00000000000000000011000000000"
    "00000000000000000110000000000"
    "00000000000000000100000000000";


INT AsciiToUnicodeStr(
    const CHAR* ansiStr,
    WCHAR* unicodeStr,
    INT unicodeSize
)
{
    return( MultiByteToWideChar(
        CP_ACP,
        0,
        ansiStr,
        -1,
        unicodeStr,
        unicodeSize
    ) > 0 );
}

void LoadState()
{
    // Retrieve the application name from the RC file.
    
    LoadStringW(
        hMainInstance, 
        idsAppName, 
        szAppName, 
        40
    );
    
    // Retrieve the .ini file name from the RC file.
    
    LoadStringW(
        hMainInstance, 
        idsIniFile, 
        szIniFile, 
        MAXFILELEN
    ); 
    
    // Retrieve any redraw speed data from the registry.
    
    nSpeed = GetPrivateProfileIntW(
        szAppName, 
        L"Redraw Speed", 
        SPEED_DEF, 
        szIniFile
    ); 
    
    // Only allow defined values.
    
    nSpeed = max(nSpeed, SPEED_MIN);
    nSpeed = min(nSpeed, SPEED_MAX);


    // Retrieve any tile size from the registry.
    
    nTileSize = GetPrivateProfileIntW(
        szAppName, 
        L"Tile Size", 
        TILESIZE_DEF, 
        szIniFile
    ); 
    
    // Only allow defined values.
    
    nTileSize = max(nTileSize, TILESIZE_MIN);
    nTileSize = min(nTileSize, TILESIZE_MAX);


    // Get the directory name. NULL if failed.
    
    GetPrivateProfileStringW(
        szAppName, 
        L"Image Path", 
        L"", 
        gDirPath,
        MAX_PATH,
        szIniFile
    ); 
    
}


void SaveState()
{
    WCHAR szTemp[20];
    
    // Write out the registry setting for the speed.
    
    wsprintf(szTemp, L"%ld", nSpeed); 
    
    WritePrivateProfileStringW(
        szAppName, 
        L"Redraw Speed", 
        szTemp, 
        szIniFile
    ); 

    // Write out the registry setting for the tile size.
    
    wsprintf(szTemp, L"%ld", nTileSize); 
    
    WritePrivateProfileStringW(
        szAppName, 
        L"Tile Size", 
        szTemp, 
        szIniFile
    ); 

    // Set the directory name. NULL if failed.

    WritePrivateProfileStringW(
        szAppName, 
        L"Image Path", 
        gDirPath, 
        szIniFile
    ); 
}

void ClearOffscreenDIB()
{
    if (gOffscreenInfo.hdc)
    {
        PatBlt(
            gOffscreenInfo.hdc,
            0,
            0,
            gOffscreenInfo.bmi.bmiHeader.biWidth,
            gOffscreenInfo.bmi.bmiHeader.biHeight,
            BLACKNESS
        );
    }
}

VOID CreateOffscreenDIB(HDC hdc, INT width, INT height)
{
    gOffscreenInfo.bmi.bmiHeader.biSize = sizeof(gOffscreenInfo.bmi.bmiHeader);
    gOffscreenInfo.bmi.bmiHeader.biWidth = width;
    gOffscreenInfo.bmi.bmiHeader.biHeight = height;
    gOffscreenInfo.bmi.bmiHeader.biPlanes = 1;
    gOffscreenInfo.bmi.bmiHeader.biBitCount = 32;
    gOffscreenInfo.bmi.bmiHeader.biCompression = BI_RGB;

    gOffscreenInfo.hbmpOffscreen = CreateDIBSection(
        hdc,
        &gOffscreenInfo.bmi,
        DIB_RGB_COLORS,
        &gOffscreenInfo.pvBits,
        NULL,
        0
    );

    if (gOffscreenInfo.hbmpOffscreen)
    {
        gOffscreenInfo.hdc = CreateCompatibleDC(hdc);

        if (gOffscreenInfo.hdc)
        {
            gOffscreenInfo.hbmpOld = (HBITMAP)SelectObject(
                gOffscreenInfo.hdc, 
                gOffscreenInfo.hbmpOffscreen
            );

            ClearOffscreenDIB();
        }
    }
}

BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    static HWND hSpeed;  // handle to the speed scrollbar. 
    
    switch(message) 
    { 
        case WM_INITDIALOG: 
        
            // Load the global state.
            
            LoadState();
            
            // Initialize the speed scroll bar
            
            hSpeed = GetDlgItem(hDlg, ID_SPEED); 
            SetScrollRange(hSpeed, SB_CTL, SPEED_MIN, SPEED_MAX, FALSE); 
            SetScrollPos(hSpeed, SB_CTL, nSpeed, TRUE); 
            
            // Initialize the tile size radio buttons
            
            CheckRadioButton(hDlg, IDC_RADIOTYPE1, IDC_RADIOTYPE5, IDC_RADIOTYPE1+(TILESIZE_MAX-nTileSize));

            return TRUE; 
 
        case WM_HSCROLL: 
 
            // Process the speed control scrollbar.
 
            switch (LOWORD(wParam)) 
                { 
                    case SB_PAGEUP: --nSpeed; break; 
                    case SB_LINEUP: --nSpeed; break; 
                    case SB_PAGEDOWN: ++nSpeed; break; 
                    case SB_LINEDOWN: ++nSpeed; break; 
                    case SB_THUMBPOSITION: nSpeed = HIWORD(wParam); break; 
                    case SB_BOTTOM: nSpeed = SPEED_MIN; break; 
                    case SB_TOP: nSpeed = SPEED_MAX; break; 
                    case SB_THUMBTRACK: 
                    case SB_ENDSCROLL: 
                        return TRUE; 
                    break; 
                } 
                
                nSpeed = max(nSpeed, SPEED_MIN);
                nSpeed = min(nSpeed, SPEED_MAX);
                
                SetScrollPos((HWND) lParam, SB_CTL, nSpeed, TRUE); 
            break; 
 
        case WM_COMMAND: 
            switch(LOWORD(wParam)) 
            { 
                case ID_DIR:
                
                    // Do the COM thing for the SHBrowseForFolder dialog.
                    
                    CoInitialize(NULL);
                    
                    IMalloc *piMalloc;
                    if(SUCCEEDED(SHGetMalloc(&piMalloc)))
                    {
                        BROWSEINFOW bi;
                        memset(&bi, 0, sizeof(bi));
                        bi.hwndOwner = hDlg;
                        bi.ulFlags = BIF_NEWDIALOGSTYLE | BIF_EDITBOX;
                        bi.lpszTitle = L"Select image directory:";
                        WCHAR wszPath[MAX_PATH];
                        bi.pszDisplayName = wszPath;
                        LPITEMIDLIST lpiList = SHBrowseForFolderW(&bi);
                        if(lpiList)
                        {
                            if(SHGetPathFromIDListW(lpiList, wszPath))
                            {
                                wcscpy(gDirPath, wszPath);
                            }
                            piMalloc->Free(lpiList);
                        }
                        piMalloc->Release();
                    }
                
                    CoUninitialize();
                
                break;
                
                case ID_OK: 
                    
                    // Tile size radio buttons.
                    
                    if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE1))
                    {
                        nTileSize = 4;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE2))
                    {
                        nTileSize = 3;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE3))
                    {
                        nTileSize = 2;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIOTYPE4))
                    {
                        nTileSize = 1;
                    }
                    else
                    {
                        nTileSize = 0;  // smallest
                    }
                    
                    SaveState();                   
                     
                    // intentionally fall through to exit.
 
                case ID_CANCEL: 
                    EndDialog(hDlg, LOWORD(wParam) == IDOK); 
                return TRUE; 
            } 
    } 
    return FALSE; 
} 

BOOL WINAPI RegisterDialogClasses(
    HANDLE  hInst
    )
{ 
    return TRUE; 
    UNREF(hInst);
} 

LRESULT WINAPI ScreenSaverProcW (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    static HDC          hdc;      // device-context handle
    static RECT         rc;       // RECT structure
    static UINT_PTR     uTimer;   // timer identifier
    static bool         GdiplusInitialized = false;
    static ULONG_PTR    gpToken;
    
    GdiplusStartupInput sti;
 
    switch(message) 
    { 
        case WM_CREATE:
            
            // Initialize GDI+
            
            if (GdiplusStartup(&gpToken, &sti, NULL) == Ok)
            {
                GdiplusInitialized = true;
            }
            
            // Only do work if we successfully initialized.
            
            if(GdiplusInitialized)
            {
                // Retrieve the application name from the .rc file. 
                
                LoadString(hMainInstance, idsAppName, szAppName, 40); 
        
                // Initialize the global state.
                
                GetClientRect (hwnd, &rc); 

                LoadState();    

                switch(nTileSize) 
                {
                    // 1x1 pixel
                    
                    case 0:
                        gSizeX = 1;
                        gSizeY = 1;
                    break;
                    
                    // Aspect ratio of 4x3, for pictures.
                    
                    case 1:
                        gSizeX = 16;
                        gSizeY = 12;
                    break;
                    
                    case 2:
                        gSizeX = 32;
                        gSizeY = 24;
                    break;

                    case 3:
                        gSizeX = 64;
                        gSizeY = 48;
                    break;

                    case 4:
                        gSizeX = 96;
                        gSizeY = 72;
                    break;
                    
                }                
                
                ghFile = 0;
                gGenerations = 400;
                gCurrentGeneration = 0;
                
                gWidth = (rc.right - rc.left + 1)/gSizeX;
                gHeight = (rc.bottom - rc.top + 1)/gSizeY;
                
                gLifeMatrix = (INT *)malloc(sizeof(INT)*gWidth*gHeight);
                gTempMatrix = (INT *)malloc(sizeof(INT)*gWidth*gHeight);

                if(nTileSize == 0)
                {
                    // 1x1 tilesize case.
                    
                    CreateOffscreenDIB(
                        hdc, 
                        rc.right - rc.left + 1, 
                        rc.bottom - rc.top + 1
                    );
                    
                    red   = rand() % 255;
                    green = rand() % 255;
                    blue  = min(255, 512 - (red + green));
                    
                    ri = (rand() % 3) - 1;  // 1, 0 or -1
                    bi = (rand() % 3) - 1;  // 1, 0 or -1
                    gi = (rand() % 3) - 1;  // 1, 0 or -1
                }
                else
                {   
                    // Image case.
                                 
                    CachedImages = new CachedImageArray();
                }
                
                maxImage = CBSIZE;
                currentImage = 0; // initial number
    
                // Set a timer for the screen saver window 
                
                uTimer = SetTimer(hwnd, 1, 1000, NULL); 
        
                srand( (unsigned)GetTickCount() );
            }
                
            break; 
 
        case WM_ERASEBKGND: 
            
            // The WM_ERASEBKGND message is issued before the 
            // WM_TIMER message, allowing the screen saver to 
            // paint the background as appropriate. 
 
            break; 
 
        case WM_TIMER: 
            
            // Only do work if we successfully initialized.
             
            if(GdiplusInitialized)
            {
                if (uTimer)
                {
                    KillTimer(hwnd, uTimer);
                }
    
                hdc = GetDC(hwnd); 
                GetClientRect(hwnd, &rc); 
    
                DrawLifeIteration(hdc);
    
                uTimer = SetTimer(hwnd, 1, nSpeed*10, NULL); 
    
                ReleaseDC(hwnd,hdc); 
            }
            break; 
 
        case WM_DESTROY: 
            
            // When the WM_DESTROY message is issued, the screen saver 
            // must destroy any of the timers that were set at WM_CREATE 
            // time. 
            
            // Only do work if we successfully initialized.
            
            if(GdiplusInitialized)
            {
                if (uTimer) 
                {
                    KillTimer(hwnd, uTimer); 
                }
                
                free(gTempMatrix);
                free(gLifeMatrix);
                FindClose(ghFile);
                
                delete CachedImages;
                
                GdiplusShutdown(gpToken);
                GdiplusInitialized = false;
            }
            
            break; 
    } 
 
    // DefScreenSaverProc processes any messages ignored by ScreenSaverProc. 
    
    #ifdef STANDALONE_DEBUG
    return DefWindowProc(hwnd, message, wParam, lParam); 
    #else
    return DefScreenSaverProc(hwnd, message, wParam, lParam); 
    #endif
} 



#define TEMP(x, y) gTempMatrix[ ((x+gWidth) % gWidth) + ((y+gHeight) % gHeight)*gWidth ]
#define LIFE(x, y) gLifeMatrix[ ((x+gWidth) % gWidth) + ((y+gHeight) % gHeight)*gWidth ]


inline bool AliveT(int x, int y)
{
    return (TEMP(x, y) & 0x1);
}

inline bool AliveL(int x, int y)
{
    return (LIFE(x, y) & 0x1);
}

inline INT CountT(int x, int y)
{
    return (TEMP(x, y) >> 1);
}

inline void NewCellL(INT x, INT y)
{
    ASSERT(!AliveL(x, y));
    
    // update current cell
    
    LIFE(x, y) += 1;
    
    // update neighbour counts.
    
    LIFE(x-1, y-1) += 2;
    LIFE(x-1, y  ) += 2;
    LIFE(x-1, y+1) += 2;
    LIFE(x  , y-1) += 2;
    LIFE(x  , y+1) += 2;
    LIFE(x+1, y-1) += 2;
    LIFE(x+1, y  ) += 2;
    LIFE(x+1, y+1) += 2;
}

inline void NewCellL_NoWrap(INT index)
{
    ASSERT(! (gLifeMatrix[index] & 0x1) );
    
    // update current cell
    
    gLifeMatrix[index] += 1;
    
    // update neighbour counts.
    
    gLifeMatrix[index - 1 - gWidth] += 2;
    gLifeMatrix[index - 1         ] += 2;
    gLifeMatrix[index - 1 + gWidth] += 2;

    gLifeMatrix[index     - gWidth] += 2;
    
    gLifeMatrix[index     + gWidth] += 2;
    
    gLifeMatrix[index + 1 - gWidth] += 2;
    gLifeMatrix[index + 1         ] += 2;
    gLifeMatrix[index + 1 + gWidth] += 2;
}

inline void KillCellL(INT x, INT y)
{
    ASSERT(AliveL(x, y));
    
    // update current cell
    
    LIFE(x, y) -= 1;
    
    // update neighbour counts.
    
    LIFE(x-1, y-1) -= 2;
    LIFE(x-1, y  ) -= 2;
    LIFE(x-1, y+1) -= 2;
    LIFE(x  , y-1) -= 2;
    LIFE(x  , y+1) -= 2;
    LIFE(x+1, y-1) -= 2;
    LIFE(x+1, y  ) -= 2;
    LIFE(x+1, y+1) -= 2;
}


inline void KillCellL_NoWrap(INT index)
{
    ASSERT(gLifeMatrix[index] & 0x1);
    
    // update current cell
    
    gLifeMatrix[index] -= 1;
    
    // update neighbour counts.
    
    gLifeMatrix[index - 1 - gWidth] -= 2;
    gLifeMatrix[index - 1         ] -= 2;
    gLifeMatrix[index - 1 + gWidth] -= 2;

    gLifeMatrix[index     - gWidth] -= 2;
    
    gLifeMatrix[index     + gWidth] -= 2;
    
    gLifeMatrix[index + 1 - gWidth] -= 2;
    gLifeMatrix[index + 1         ] -= 2;
    gLifeMatrix[index + 1 + gWidth] -= 2;
}


VOID InitLifeMatrix()
{
    memset(gLifeMatrix, 0, sizeof(INT)*gWidth*gHeight);
    if(nTileSize == 0)
    {
        ClearOffscreenDIB();
    }
    
    if((rand()%2 == 0) ||
       (gWidth<b_heptomino_x) ||
       (gHeight<b_heptomino_y))
    {
        for(int i=1; i<gWidth-1; i++)
        for(int j=1; j<gHeight-1; j++)
        {
            if((rand() % 3) == 0)
            {
                NewCellL_NoWrap(i + j*gWidth);
            }
        }
        
        for(int i=0; i<gWidth; i++)
        {
            if((rand() % 3) == 0)
            {
                NewCellL(i, 0);
            }
            if((rand() % 3) == 0)
            {
                NewCellL(i, gHeight-1);
            }
        }
        
        for(int j=1; j<gHeight-1; j++)
        {
            if((rand() % 3) == 0)
            {
                NewCellL(0, j);
            }
            if((rand() % 3) == 0)
            {
                NewCellL(gWidth-1, j);
            }
        }
    }
    else
    {
        for(int i=0; i<b_heptomino_x; i++)
        for(int j=0; j<b_heptomino_y; j++)
        {
            if(b_heptomino[i+j*b_heptomino_x] != '0')
            {
                NewCellL(i, j);
            }
        }
    }
}


Bitmap *OpenBitmap()
{
    Bitmap *bmp = NULL;
    WIN32_FIND_DATA findData = {0};
    WCHAR filename[1024];
    
    do
    {
        // don't leak if we repeat this loop due to an invalid bitmap.
        
        delete bmp; bmp = NULL;
        
        if(ghFile)
        {
            if(!FindNextFileW(ghFile, &findData))
            {
                // finished going through the list.
                
                FindClose(ghFile);
                ghFile = 0;
                maxImage = currentImage;
                currentImage = 0;
                return NULL;
            }
        }
        
        if(!ghFile)
        {
            currentImage = 0;         // we're about to increment this.
            
            wsprintf(filename, L"%s\\*.*", gDirPath);
            ghFile = FindFirstFileW(filename, &findData);
            
            if(!ghFile)
            {
                return NULL;          // No files.
            }
        }
        
        if((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            wsprintf(
                filename, 
                L"%s\\%s", 
                gDirPath,
                findData.cFileName
            );
            
            bmp = new Bitmap(filename);
        }
        
        // !!! need to prevent infinite loops.
    } while ( 
        ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 
          FILE_ATTRIBUTE_DIRECTORY) ||
        (bmp->GetLastStatus() != Ok)
    );

    return bmp;    
}

VOID InitialPaintPicture(Graphics *g, CachedBitmap *cb)
{
    SolidBrush OffBrush(Color(0xff000000));
    
    for(int x=0; x<gWidth; x++)
    {
        for(int y=0; y<gHeight; y++)
        {
            if(AliveL(x, y))
            {
                g->DrawCachedBitmap(
                    cb, 
                    x*gSizeX, 
                    y*gSizeY
                );
            }
            else
            {
                // we should really use a bitblt for this.
                
                g->FillRectangle(
                    &OffBrush, 
                    x*gSizeX, 
                    y*gSizeY, 
                    gSizeX, 
                    gSizeY
                );
            }
        }
    }
}

VOID InitialPaintPixel()
{
    ASSERT(nTileSize == 0);
    
    DWORD *pixel = (DWORD*)(gOffscreenInfo.pvBits);
    
    ASSERT(pixel != NULL);
    
    for(int x=0; x<gWidth; x++)
    {
        for(int y=0; y<gHeight; y++)
        {
            // we know there's no wrapping, we shouldn't have to do the mod.
            INT index = x+y*gWidth;
            
            if(gLifeMatrix[index] & 0x1)
            {
                pixel[index] = gGenerationColor;
            }
        }
    }
}


CachedBitmap *MakeCachedBitmapEntry(Bitmap *bmp, Graphics *gfxMain)
{
    // Make a tile bitmap and wrap a graphics around it.
    
    Bitmap *tileBmp = new Bitmap(gSizeX, gSizeY, PixelFormat32bppPARGB);
    Graphics *g = new Graphics(tileBmp);
    
    // Shrink the image down to the tile size using the Bicubic filter.
    
    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);
    
    g->DrawImage(
        bmp, 
        Rect(0,0,gSizeX,gSizeY), 
        0, 
        0, 
        bmp->GetWidth(), 
        bmp->GetHeight(), 
        UnitPixel
    );

    // Create the CachedBitmap from the tile.
        
    CachedBitmap *cb = new CachedBitmap(tileBmp, gfxMain);
    
    // clean up.
    
    delete g; 
    delete tileBmp;
    
    return cb;
}

VOID IteratePixelGeneration()
{
    DWORD *pixel = (DWORD*)(gOffscreenInfo.pvBits);
    INT count;
    INT index = 1+gWidth;

    for(int y=1; y<gHeight-1; y++)
    {
        for(int x=1; x<gWidth-1; x++)
        {
            if(gTempMatrix[index] != 0)
            {
                // If the cell is not alive and it's neighbour count
                // is exactly 3, it is born.
                
                if( gTempMatrix[index] == 6 )
                {
                    // A new cell is born into an empty square.
                    
                    NewCellL_NoWrap(index);
                    pixel[index] = gGenerationColor;
                }
                else
                {
                    count = gTempMatrix[index] >> 1;
                    
                    // if the cell is alive and its neighbour count
                    // is not 2 or 3, it dies.
                    
                    if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                    {
                        // Kill the cell - overcrowding or not enough support.
                    
                        KillCellL_NoWrap(index);    
                        pixel[index] = 0;
                    }
                }
                
            }
            index++;
        }
        
        // skip the wrap boundaries.
        index += 2;
    }

    index = 0;
    
    for(int y=0; y<gHeight; y++)
    {
        // left vertical edge.
        
        if(gTempMatrix[index] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(0, y);
                pixel[index] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(0, y);    
                    pixel[index] = 0;
                }
            }
            
        }
        
        // right vertical edge
        
        index += gWidth-1;
        
        if(gTempMatrix[index] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(gWidth-1, y);
                pixel[index] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(gWidth-1, y);    
                    pixel[index] = 0;
                }
            }
            
        }
        
        // next scanline.
        
        index++;
    }


    index = 1;
    INT index2 = index + (gHeight-1)*gWidth;
    
    for(int x=1; x<gWidth-1; x++)
    {
        // top edge.
        
        if(gTempMatrix[index] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(x, 0);
                pixel[index] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(x, 0);    
                    pixel[index] = 0;
                }
            }
            
        }
        
        index++;
        
        // bottom edge
        
        if(gTempMatrix[index2] != 0)
        {
            // If the cell is not alive and it's neighbour count
            // is exactly 3, it is born.
            
            if( gTempMatrix[index2] == 6 )
            {
                // A new cell is born into an empty square.
                
                NewCellL(x, gHeight-1);
                pixel[index2] = gGenerationColor;
            }
            else
            {
                count = gTempMatrix[index2] >> 1;
                
                // if the cell is alive and its neighbour count
                // is not 2 or 3, it dies.
                
                if( (gTempMatrix[index2] & 0x1) && ((count<2) || (count>3)) )
                {
                    // Kill the cell - overcrowding or not enough support.
                
                    KillCellL(x, gHeight-1);    
                    pixel[index2] = 0;
                }
            }
            
        }
        
        // next pixel.
        
        index2++;
    }
}

VOID IteratePictureGeneration(Graphics &g, CachedBitmap *cb)
{
    SolidBrush OffBrush(Color(0xff000000));

    INT count;
    INT *cell = gTempMatrix;
    
    for(int y=0; y<gHeight; y++)
    {
        for(int x=0; x<gWidth; x++)
        {
            if(*cell != 0)
            {
                // If the cell is not alive and it's neighbour count
                // is exactly 3, it is born.
                
                if( *cell == 6 )
                {
                    // A new cell is born into an empty square.
                    
                    NewCellL(x, y);
    
                    g.DrawCachedBitmap(
                        cb, 
                        x*gSizeX, 
                        y*gSizeY
                    );
                }
                else
                {
                    count = *cell >> 1;
                    
                    // if the cell is alive and its neighbour count
                    // is not 2 or 3, it dies.
                    
                    if( (*cell & 0x1) && ((count<2) || (count>3)) )
                    {
                        // Kill the cell - overcrowding or not enough support.
                    
                        KillCellL(x, y);    
                        
                        g.FillRectangle(
                            &OffBrush, 
                            x*gSizeX, 
                            y*gSizeY, 
                            gSizeX, 
                            gSizeY
                        );
                    }
                }
                
            }
            cell++;
        }
    }
}

VOID RandomizeColor()
{
    if(rand() % 200 == 0)
    {
        ri = (rand() % 3) - 1;  // 1, 0 or -1
    }
    if(rand() % 200 == 0)
    {
        gi = (rand() % 3) - 1;  // 1, 0 or -1
    }
    if(rand() % 200 == 0)
    {
        bi = (rand() % 3) - 1;  // 1, 0 or -1
    }

    if((red < 100) && (green < 100) && (blue < 100))
    {
        if(red > green && red > blue)
        { 
            ri = 1;
        }
        else if (green > blue)
        {
            gi = 1;
        }
        else
        {
            bi = 1;
        }
    }        
    // bounce off the extrema.
    
    if(red == 0)
    {
        ri = 1;
    }
    
    if(red == 255)
    {
        ri = -1;
    }

    if(green == 0)
    {
        gi = 1;
    }
    
    if(green == 255)
    {
        gi = -1;
    }

    if(blue == 0)
    {
        bi = 1;
    }
    
    if(blue == 255)
    {
        bi = -1;
    }
    
    red   += ri;
    green += gi;
    blue  += bi;
}


VOID DrawLifeIteration(HDC hdc)
{
    // Are we initialized yet?
    
    if(!gLifeMatrix || !gTempMatrix) { return; }
    
    Graphics g(hdc);
    
    g.SetSmoothingMode(SmoothingModeNone);
    
    Bitmap *bmp = NULL;
    CachedBitmap *cb = NULL;
    
    // currentImage should never be larger than CBSIZE at this point.
    
    ASSERT(currentImage < CBSIZE);
    
    if(nTileSize==0)
    {
        // cycle color.
        
        RandomizeColor();
        gGenerationColor = RGB(red, green, blue);
    }
    else
    {
        // Fetch bitmaps from the image directory.
        
        if(currentImage >= CachedImages->Size()) {
        
            // We haven't filled up the cache yet. Keep opening images.    
        
            bmp = OpenBitmap();
        }
        
        // Did we get a new bitmap? 
        
        if(bmp)
        {
            cb = MakeCachedBitmapEntry(bmp, &g);
            
            if(cb)
            {
                // Put it in the cache.
                
                CachedImages->Add(cb);
                currentImage++;
            }
            
            delete bmp; bmp = NULL;
        }
        else
        {
            cb = (*CachedImages)[currentImage];
            currentImage++;
        }
        
        if( (currentImage >= CBSIZE) ||
            (currentImage >= maxImage)  )
        {
            currentImage = 0;
        }
        
        if(!cb)
        {
            // we failed to get an image tile.
            
            return;
        }
    }
    
    // update the generation and see if we need to do the first generation.
    
    //gCurrentGeneration--;
    if(gCurrentGeneration <= 0)
    {
        //    gCurrentGeneration = gGenerations;
        gCurrentGeneration++;
        InitLifeMatrix();
        if(nTileSize == 0)
        {
            InitialPaintPixel();
        }
        else 
        { 
            InitialPaintPicture(&g, cb);
        }
        goto Done;
    }
    gCurrentGeneration++;
    
    
    // Make a copy of the life matrix.
    
    memcpy(gTempMatrix, gLifeMatrix, sizeof(INT)*gWidth*gHeight);
    
    if(nTileSize==0)
    {
        IteratePixelGeneration();
        
        ASSERT(gSizeX == 1);
        ASSERT(gSizeY == 1);
        
        StretchBlt(
            hdc,
            0, 
            0, 
            gWidth, 
            gHeight,
            gOffscreenInfo.hdc,
            0, 
            0, 
            gWidth, 
            gHeight,
            SRCCOPY
        );
    }
    else
    {
        IteratePictureGeneration(g, cb);
    }
    
    // 5% mutation.
    /*
    if(((float)(rand())/RAND_MAX) < 0.05f)
    {
        int x = rand()*gWidth/RAND_MAX;
        int y = rand()*gHeight/RAND_MAX;
        
        if(AliveL(x, y))
        {
            KillCellL(x, y);
            
            g.FillRectangle(
                &OffBrush, 
                x*gSizeX, 
                y*gSizeY, 
                gSizeX, 
                gSizeY
            );
        }
        else
        {
            NewCellL(x, y);
            
            g.DrawCachedBitmap(
                cb, 
                x*gSizeX, 
                y*gSizeY
            );
        }
    }
    */
    Done:
    ;
}


#ifdef STANDALONE_DEBUG

LONG_PTR
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch(message)
    {
        // Handle the destroy message.
    
        case WM_DESTROY:
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        break;
    }
    
    // Hook into the screen saver windproc.
    
    return(ScreenSaverProcW(hwnd, message, wParam, lParam));
}

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    // not quite so white background brush.
    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hMainInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = L"MainMenu";
    wc.lpszClassName    = L"TestClass";

    if(!RegisterClass(&wc)) { return FALSE; }

    ghwndMain = CreateWindowExW(
        0,
        L"TestClass",
        L"Win32 Test",
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_BORDER       |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        800,
        600,
        NULL,
        NULL,
        hMainInstance,
        NULL
    );

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return TRUE;
}



void _cdecl main(
    INT   argc,
    PCHAR argv[]
)
{
    MSG    msg;

    hMainInstance = GetModuleHandle(NULL);

    if(!bInitApp()) {return;}

    while(GetMessage (&msg, NULL, 0, 0))
    {
        if((ghwndMain == 0) || !IsDialogMessage(ghwndMain, &msg)) {
            TranslateMessage(&msg) ;
            DispatchMessage(&msg) ;
        }
    }

    return;
    UNREF(argc);
    UNREF(argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\cobject.cpp ===
// CObject.cpp: implementation of the CObject class.
//
//////////////////////////////////////////////////////////////////////

#include "CObject.h"

CObject::CObject()
{
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
	m_flVelMax=0.0f;
}

CObject::~CObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sdk\sdktest.h ===
#pragma once

#include <windows.h>
#include <objbase.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#include "gdiplus.h"

using namespace Gdiplus;

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\cobject.h ===
// CObject.h: interface for the CObject class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __COBJECT_H
#define __COBJECT_H

#include <windows.h>
#include <math.h>
#include <objbase.h>
#include <gdiplus.h>
using namespace Gdiplus;
#include "VMath.h"
#include "resource.h"
#include "scrnsave.h"

extern Bitmap *LoadTGAResource(char *szResource);

class CObject  
{
public:
	CObject();
	virtual ~CObject();

	virtual void Destroy()=0;
	virtual BOOL Init(HWND hWnd)=0;
	virtual BOOL Move(Graphics *g)=0;

	PointF m_vPos;
	PointF m_vVel;
	PointF m_vAcc;
	float m_flVelMax;
	RECT m_rDesktop;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\cperson.h ===
// CPerson.h: interface for the CPerson class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __CPERSON_H
#define __CPERSON_H

#include "CObject.h"

enum ENUM_PERSONSTEP {
	eStepLeft=0,
	eStepRight
};

class CPerson : public CObject
{
public:
	CPerson();
	virtual ~CPerson();

	void Destroy();
	BOOL Init(HWND hWnd);
	BOOL Move(Graphics *g);
	void DrawStep(Graphics *g);

	Bitmap *m_paFoot;
	Bitmap *m_paBlended;
	Bitmap *m_paIndented;
	int m_nSnapshotSize;
	int m_nFootWidth;
	int m_nFootHeight;
	float m_flStepRadius;
	float m_flStepWidth;
	PointF m_vLastStep;
	ENUM_PERSONSTEP m_eLastStep;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\cperson.cpp ===
// CPerson.cpp: implementation of the CPerson class.
//
//////////////////////////////////////////////////////////////////////

#include "CPerson.h"

extern Bitmap *g_paBmDirtyBkg;

CPerson::CPerson()
{
	m_flStepRadius=0.0f;
	m_flStepWidth=0.0f;
	m_eLastStep=eStepLeft;
	m_paFoot=NULL;
	m_paBlended=NULL;
	m_paIndented=NULL;
	m_nSnapshotSize=0;
	m_nFootWidth=0;
	m_nFootHeight=0;
	ZeroMemory(&m_vLastStep,sizeof(m_vLastStep));
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
}

CPerson::~CPerson()
{
	Destroy();
}

void CPerson::Destroy()
{
	if (m_paFoot!=NULL) {
		delete m_paFoot;
		m_paFoot=NULL;
	}
	if (m_paBlended!=NULL) {
		delete m_paBlended;
		m_paBlended=NULL;
	}
	if (m_paIndented!=NULL) {
		delete m_paIndented;
		m_paIndented=NULL;
	}
}

BOOL CPerson::Init(HWND hWnd)
{
	int nRand;
	float flWidth;
	float flHeight;

	Destroy();

	// Get desktop dimensions, top/left can be negative on multimon
	GetClientRect(hWnd,&m_rDesktop);
	flWidth=(float)m_rDesktop.right;
	flHeight=(float)m_rDesktop.bottom;
	m_rDesktop.top+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.bottom+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.left+=GetSystemMetrics(SM_XVIRTUALSCREEN);
	m_rDesktop.right+=GetSystemMetrics(SM_XVIRTUALSCREEN);

	// Randomly pick picture to use as foot
	nRand=rand();
	if (nRand<RAND_MAX/4) {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_BAREFOOT));
	}
	else if (nRand<2*RAND_MAX/4) {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_BOOT));
	}
	else if (nRand<3*RAND_MAX/4) {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_BOOT2));
	}
	else {
		m_paFoot=LoadTGAResource(MAKEINTRESOURCE(IDR_DOG));
	}
	if (m_paFoot==NULL) { return false; }
	m_nFootWidth=m_paFoot->GetWidth();
	m_nFootHeight=m_paFoot->GetHeight();
	m_nSnapshotSize=(int)sqrt(m_nFootWidth*m_nFootWidth+m_nFootHeight*m_nFootHeight);
	m_paBlended=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppARGB);
	m_paIndented=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppARGB);

	nRand=rand();
	// Here we assume m_rDesktop.left<=0, m_rDesktop.top<=0, m_rDesktop.right>=0, m_rDesktop.bottom>=0
	if (nRand<RAND_MAX/4) {			// Start walking from the left side of desktop
		m_vPos.X=(float)m_rDesktop.left;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<2*RAND_MAX/4) {	// Start walking from the right side of desktop
		m_vPos.X=(float)m_rDesktop.right;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<3*RAND_MAX/4) {	// Start walking from the top side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*5.0f;
	}
	else {							// Start walking from the bottom side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.bottom;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*-5.0f;
	}

	m_vAcc.X=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
	m_vAcc.Y=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
	m_flStepRadius=((float)rand()/(float)RAND_MAX)*10.0f+45.0f;
	m_flStepWidth=((float)rand()/(float)RAND_MAX)*10.0f+35.0f;
	m_flVelMax=((float)rand()/(float)RAND_MAX)*10.0f+20.0f;
	m_vLastStep=m_vPos;

	return true;
}

BOOL CPerson::Move(Graphics *g)
// Returns true if moved on screen, false if moved outside screen
{
	float flAngle;
	float flOldAngle;
	float flAngleDist;
	float flMagnitude;

	flOldAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);

	// Move position and update variables
	m_vPos=m_vPos+m_vVel;
	m_vVel=m_vVel+m_vAcc;
	if (Magnitude(m_vVel)>m_flVelMax) {
		m_vVel.X=Normalize(m_vVel).X*m_flVelMax;
		m_vVel.Y=Normalize(m_vVel).Y*m_flVelMax;
	}

	// If outside desktop, return false (which will terminate the person)
	if ((m_vPos.X<(float)m_rDesktop.left-m_flStepRadius) ||
		(m_vPos.X>(float)m_rDesktop.right+m_flStepRadius) ||
		(m_vPos.Y<(float)m_rDesktop.top-m_flStepRadius) ||
		(m_vPos.Y>(float)m_rDesktop.bottom+m_flStepRadius)) {
		return false;
	}

	// Make sure we don't step more than 45 degrees away from original direction
	flAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
	flAngleDist=flAngle-flOldAngle;
	while (flAngleDist<0.0f) { flAngleDist+=360.0f; }
	while (flAngleDist>=360.0f) { flAngleDist-=360.0f; }
	if ((flAngleDist>45.0f) && (flAngleDist<=180.0f)) {
		flAngle=flOldAngle+45.0f;
		flMagnitude=Magnitude(m_vVel);
		m_vVel.X=(float)cos(flAngle*3.1415f/180.0f)*flMagnitude;
		m_vVel.Y=(float)sin(flAngle*3.1415f/180.0f)*flMagnitude;
	}
	else if ((flAngleDist<315.0f) && (flAngleDist>=180.0f)) {
		flAngle=flOldAngle-45.0f;
		flMagnitude=Magnitude(m_vVel);
		m_vVel.X=(float)cos(flAngle*3.1415f/180.0f)*flMagnitude;
		m_vVel.Y=(float)sin(flAngle*3.1415f/180.0f)*flMagnitude;
	}

	// Is it time for another step?
	if (Magnitude(m_vLastStep-m_vPos)>m_flStepRadius) {
		DrawStep(g);
		if (m_eLastStep==eStepLeft) {
			m_eLastStep=eStepRight;
		}
		else {
			m_eLastStep=eStepLeft;
		}

		// Took a step, update acceleration (random)
		m_vLastStep=m_vPos;
		m_vAcc.X=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
		m_vAcc.Y=((float)rand()/(float)RAND_MAX)*2.0f-1.0f;
	}

	return true;
}

void CPerson::DrawStep(Graphics *g)
{
	Rect rBitmapSize(0,0,m_nSnapshotSize,m_nSnapshotSize);
	Point ptPixel;
	Color Pixel;
	int nAlpha;
	Point ptCenter;
	Point ptOffset;
	float flAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
	Graphics *gBlended;
	Graphics *gIndented;
	int i,j;

	// Find out center of where the foot will land
	g->ResetTransform();
	g->TranslateTransform(m_vPos.X,m_vPos.Y);
	g->RotateTransform(flAngle+270.0f);
	if (m_eLastStep==eStepLeft) {
		g->TranslateTransform(-m_flStepWidth,0.0f);
	}
	else {
		g->TranslateTransform(m_flStepWidth,0.0f);
	}
	ptCenter.X=m_nSnapshotSize/2;
	ptCenter.Y=m_nSnapshotSize/2;
	g->TransformPoints(CoordinateSpaceDevice,CoordinateSpaceWorld,&ptCenter,1);

	// Take snapshot of larger area where foot will land
	gBlended=new Graphics(m_paBlended);
	gBlended->DrawImage(g_paBmDirtyBkg,0,0,ptCenter.X-m_nSnapshotSize/2-m_rDesktop.left,ptCenter.Y-m_nSnapshotSize/2-m_rDesktop.top,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);

	// Draw stamp (dirt) of foot on that snapshot
	gBlended->SetSmoothingMode(SmoothingModeAntiAlias);
	gBlended->SetInterpolationMode(InterpolationModeNearestNeighbor);//Bicubic);
	gBlended->TranslateTransform((float)(m_nSnapshotSize/2),(float)(m_nSnapshotSize/2));
	gBlended->RotateTransform(flAngle+270.0f);
	if (m_eLastStep==eStepLeft) {
		gBlended->ScaleTransform(-1,1);
	}
	gBlended->TranslateTransform(-(float)(m_nFootWidth/2),-(float)(m_nFootHeight/2));
	gBlended->DrawImage(m_paFoot,0,0,0,0,m_paFoot->GetWidth(),m_paFoot->GetHeight(),UnitPixel);
	gBlended->ResetTransform();

	// Blit that snapshot to another temporary surface
	gIndented=new Graphics(m_paIndented);
	gIndented->SetCompositingMode(CompositingModeSourceCopy);
	gIndented->DrawImage(m_paBlended,rBitmapSize,0,0,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);

	delete gBlended;
	delete gIndented;

	// Get the transform from snapshot to foot surface
	g->ResetTransform();
	g->TranslateTransform((float)(m_nFootWidth/2),(float)(m_nFootHeight/2));
	if (m_eLastStep==eStepRight) {
		g->ScaleTransform(-1,1);
	}
	g->RotateTransform(-flAngle-270.0f);
	g->TranslateTransform(-(float)(m_nSnapshotSize/2),-(float)(m_nSnapshotSize/2));

	// Create indent 3D look by bringing pixels closer to center depending on
	//  their distance relative to the alpha
	for (i=0;i<m_nSnapshotSize;i++) {
		for (j=0;j<m_nSnapshotSize;j++) {
			ptPixel.X=i;
			ptPixel.Y=j;
			g->TransformPoints(CoordinateSpaceDevice,CoordinateSpaceWorld,&ptPixel,1);
			// Find out if pixel is on the foot surface
			if ((ptPixel.X>=0) && (ptPixel.X<(int)m_nFootWidth) &&
				(ptPixel.Y>=0) && (ptPixel.Y<(int)m_nFootHeight)) {
				// If it is, find out if the alpha is > 0
				m_paFoot->GetPixel(ptPixel.X,ptPixel.Y,&Pixel);
				nAlpha=Pixel.GetA();
				if (nAlpha>0) {
					// If it is, move that pixel closer to middle of foot depending on the distance and alpha
					m_paBlended->GetPixel(i,j,&Pixel);
					ptOffset.X=(int)((m_nSnapshotSize/2-i)*(1.0f-(float)nAlpha/1024.0f));
					ptOffset.Y=(int)((m_nSnapshotSize/2-j)*(1.0f-(float)nAlpha/1024.0f));
					m_paIndented->SetPixel(m_nSnapshotSize/2-ptOffset.X,m_nSnapshotSize/2-ptOffset.Y,Pixel);
				}
			}
		}
	}

	// Draw the foot print result on the screen
	g->ResetTransform();
	g->TranslateTransform((float)(ptCenter.X-m_nSnapshotSize/2-m_rDesktop.left),(float)(ptCenter.Y-m_nSnapshotSize/2-m_rDesktop.top));
	g->DrawImage(m_paIndented,rBitmapSize,0,0,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);

	// Draw the foot print result on the dirty background as well
	g=new Graphics(g_paBmDirtyBkg);
	g->TranslateTransform((float)(ptCenter.X-m_nSnapshotSize/2-m_rDesktop.left),(float)(ptCenter.Y-m_nSnapshotSize/2-m_rDesktop.top));
	g->DrawImage(m_paIndented,rBitmapSize,0,0,m_nSnapshotSize,m_nSnapshotSize,UnitPixel);
	delete g;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\csweeper.cpp ===
// CSweeper.cpp: implementation of the CSweeper class.
//
//////////////////////////////////////////////////////////////////////

#include "CSweeper.h"

extern TextureBrush *g_paBrCleanBkg;
extern Bitmap *g_paBmDirtyBkg;

CSweeper::CSweeper()
{
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
	ZeroMemory(&m_vLastPos,sizeof(m_vLastPos));
	m_flStepRadius=0.0f;
	m_flBroomWidth=0.0f;
	m_flSweepLength=0.0f;
	m_paBroomOn=NULL;
	m_paBroomOff=NULL;
	m_paBackground=NULL;
	m_bSweeping=false;
	m_flLastAngle=0.0f;
	m_flDist=0.0f;
}

CSweeper::~CSweeper()
{
	Destroy();
}

void CSweeper::Destroy()
{
	if (m_paBroomOn!=NULL) {
		delete m_paBroomOn;
		m_paBroomOn=NULL;
	}
	if (m_paBroomOff!=NULL) {
		delete m_paBroomOff;
		m_paBroomOff=NULL;
	}
	if (m_paBackground!=NULL) {
		delete m_paBackground;
		m_paBackground=NULL;
	}
}

BOOL CSweeper::Init(HWND hWnd)
{
	int nRand;
	float flWidth;
	float flHeight;

	Destroy();

	// Get desktop dimensions (top/left can be negative on multimon)
	GetClientRect(hWnd,&m_rDesktop);
	flWidth=(float)m_rDesktop.right;
	flHeight=(float)m_rDesktop.bottom;
	m_rDesktop.top+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.bottom+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.left+=GetSystemMetrics(SM_XVIRTUALSCREEN);
	m_rDesktop.right+=GetSystemMetrics(SM_XVIRTUALSCREEN);

	m_flVelMax=((float)rand()/(float)RAND_MAX)*20.0f+20.0f;
	m_paBroomOn=LoadTGAResource(MAKEINTRESOURCE(IDR_BROOMON));
	m_paBroomOff=LoadTGAResource(MAKEINTRESOURCE(IDR_BROOMOFF));
	m_nSnapshotSize=(int)sqrt(m_paBroomOn->GetWidth()*m_paBroomOn->GetWidth()+(m_paBroomOn->GetHeight()+m_flVelMax*2.0f)*(m_paBroomOn->GetHeight()+m_flVelMax*2.0f));
	m_paBackground=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppPARGB);

	nRand=rand();
	if (nRand<RAND_MAX/4) {			// Start walking from the left side of desktop
		m_vPos.X=(float)m_rDesktop.left;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<2*RAND_MAX/4) {	// Start walking from the right side of desktop
		m_vPos.X=(float)m_rDesktop.right;
		m_vPos.Y=((float)rand()/(float)RAND_MAX)*flHeight+m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
	}
	else if (nRand<3*RAND_MAX/4) {	// Start walking from the top side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.top;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*5.0f;
	}
	else {							// Start walking from the bottom side of desktop
		m_vPos.X=((float)rand()/(float)RAND_MAX)*flWidth+m_rDesktop.left;
		m_vPos.Y=(float)m_rDesktop.bottom;
		m_vVel.X=((float)rand()/(float)RAND_MAX)*10.0f-5.0f;
		m_vVel.Y=((float)rand()/(float)RAND_MAX)*-5.0f;
	}

	m_vAcc.X=((float)rand()/(float)RAND_MAX)*1.0f-0.5f;
	m_vAcc.Y=((float)rand()/(float)RAND_MAX)*1.0f-0.5f;
	m_flStepRadius=((float)rand()/(float)RAND_MAX)*10.0f+45.0f;
	m_flBroomWidth=m_paBroomOn->GetWidth()-6.0f;
	m_flSweepLength=((float)rand()/(float)RAND_MAX)*50.0f+200.0f;
	m_flStepRadius=m_flSweepLength;
	m_vVel=Normalize(m_vVel);
	m_vVel.X*=m_flVelMax;
	m_vVel.Y*=m_flVelMax;
	m_vLastPos=m_vPos;

	m_bSweeping=false;
	m_flDist=0.0f;
	m_flLastAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);

	return true;
}

BOOL CSweeper::Move(Graphics *g)
// Returns true if moved on screen, false if moved outside screen
{
	float flAngle;
	float flAngleDist;

	if (m_bSweeping) {
		m_vPos=m_vPos+m_vVel;
		if ((m_vPos.X<(float)m_rDesktop.left-m_flSweepLength) ||
			(m_vPos.X>(float)m_rDesktop.right+m_flSweepLength) ||
			(m_vPos.Y<(float)m_rDesktop.top-m_flSweepLength) ||
			(m_vPos.Y>(float)m_rDesktop.bottom+m_flSweepLength)) {
			// If sweeper is outside desktop, erase it and remove it
			NoSweep(g);
			return false;
		}

		Sweep(g);
	}
	else {
		NoSweep(g);
	}

	if (!m_bSweeping && (m_flDist==0.0f)) {
		// If not sweeping and broom is back at distance 0, start next sweep
		m_bSweeping=true;
		m_flLastAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
		m_vPos.X=m_vPos.X-m_vVel.X*(m_flSweepLength/m_flVelMax*0.75f);
		m_vPos.Y=m_vPos.Y-m_vVel.Y*(m_flSweepLength/m_flVelMax*0.75f);
		m_vLastPos=m_vPos;

		flAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);
		flAngleDist=((float)rand()/(float)RAND_MAX)*40.0f-20.0f;
		flAngle+=flAngleDist;
		m_vVel.X=(float)cos(flAngle*3.1415f/180.0f)*m_flVelMax;
		m_vVel.Y=(float)sin(flAngle*3.1415f/180.0f)*m_flVelMax;
	}

	return true;
}

void CSweeper::Sweep(Graphics *g)
{
	Graphics *gBackground;
	RectF rect(0.0f,0.0f,m_flBroomWidth,m_flVelMax);
	RectF rect2(0.0f,0.0f,(float)m_paBroomOn->GetWidth(),(float)m_paBroomOn->GetHeight()+m_flVelMax);
	Matrix mat;
	GraphicsPath Path;
	Pen pen(Color(10,0,0,0),2);
	Graphics *gDirty;

	if (m_flDist!=0.0f) {	// If broom has moved already, erase a rect on dirty background
		// Set up the brush transform (opposite from original transform)
		g_paBrCleanBkg->ResetTransform();
		mat.Reset();
		mat.Translate(0.0f,-m_flDist);
		mat.Translate(-(float)m_paBroomOn->GetWidth()/2.0f,-(float)m_paBroomOn->GetHeight()+20.0f);
		mat.Rotate(-m_flLastAngle-270.0f);
		mat.Translate(-m_vLastPos.X+m_rDesktop.left,-m_vLastPos.Y+m_rDesktop.top);
		g_paBrCleanBkg->SetTransform(&mat);

		// Set up original transform and erase from DirtyBkg a rectangle where the broom moved
		gDirty=new Graphics(g_paBmDirtyBkg);
		gDirty->TranslateTransform(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
		gDirty->RotateTransform(m_flLastAngle+270.0f);
		gDirty->TranslateTransform((float)m_paBroomOn->GetWidth()/2.0f,(float)m_paBroomOn->GetHeight()-20.0f);
		gDirty->TranslateTransform(0.0f,m_flDist);
		gDirty->FillRectangle(g_paBrCleanBkg,rect);

		// Draw dirty lines around the broom, to simulate dirty that fell beside the broom
		gDirty->DrawLine(&pen,0.0f,0.0f,0.0f,m_flVelMax+2);
		gDirty->DrawLine(&pen,0.0f,m_flVelMax+2,m_flBroomWidth,m_flVelMax+2);
		gDirty->DrawLine(&pen,m_flBroomWidth,m_flVelMax+2,m_flBroomWidth,0.0f);

		delete gDirty;
	}

	// Get the bounds of the broom after rotations
	Path.AddRectangle(rect2);
	mat.Reset();
	mat.Translate(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
	mat.Rotate(m_flLastAngle+270.0f);
	mat.Translate(m_flBroomWidth/2.0f,0.0);
	mat.Translate(0.0f,m_flDist);
	Path.GetBounds(&rect,&mat,&pen);

	// Draw on a temp surface whatever was on the dirty background where the broom is to be drawn
	gBackground=new Graphics(m_paBackground);
	gBackground->DrawImage(g_paBmDirtyBkg,0,0,(int)rect.X,(int)rect.Y,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Draw broom on temp surface
	gBackground->ResetTransform();
	gBackground->TranslateTransform(rect.Width/2.0f,rect.Height/2.0f);
	gBackground->RotateTransform(m_flLastAngle+270.0f);
	gBackground->TranslateTransform(-(float)m_paBroomOn->GetWidth()/2.0f,-(float)m_paBroomOn->GetHeight()/2.0f+m_flVelMax/2.0f);
	gBackground->DrawImage(m_paBroomOn,0,0,0,0,m_paBroomOn->GetWidth(),m_paBroomOn->GetHeight(),UnitPixel);
	delete gBackground;

	// Draw temp surface to screen
	g->ResetTransform();
	g->DrawImage(m_paBackground,(int)rect.X,(int)rect.Y,0,0,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Update distance, continue the sweep
	m_flDist+=m_flVelMax;
	if (m_flDist>m_flSweepLength) {
		// If sweep is at the end, start moving broom back
		m_flDist-=m_flVelMax;
		m_bSweeping=false;
	}
}

void CSweeper::NoSweep(Graphics *g)
{
	Graphics *gBackground;
	RectF rect(0.0f,0.0f,m_flBroomWidth,m_flVelMax);
	RectF rect2(0.0f,0.0f,(float)m_paBroomOn->GetWidth(),(float)m_paBroomOn->GetHeight()+m_flVelMax);
	Matrix mat;
	GraphicsPath Path;
	Pen pen(Color(20,0,0,0),2);

	// Get the bounds of the broom after rotations
	Path.AddRectangle(rect2);
	mat.Reset();
	mat.Translate(m_vLastPos.X,m_vLastPos.Y);
	mat.Rotate(m_flLastAngle+270.0f);
	mat.Translate(m_flBroomWidth/2.0f,0.0f);
	mat.Translate(0.0f,m_flDist);
	Path.GetBounds(&rect,&mat,&pen);

	// Draw on a temp surface whatever was on the dirty background where the broom is to be drawn
	gBackground=new Graphics(m_paBackground);
	gBackground->DrawImage(g_paBmDirtyBkg,0,0,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Draw broom on temp surface
	gBackground->ResetTransform();
	gBackground->TranslateTransform(rect.Width/2.0f,rect.Height/2.0f);
	gBackground->RotateTransform(m_flLastAngle+270.0f);
	gBackground->TranslateTransform(-(float)m_paBroomOn->GetWidth()/2.0f,-(float)m_paBroomOn->GetHeight()/2.0f-m_flVelMax/2.0f);
	gBackground->DrawImage(m_paBroomOff,0,0,0,0,m_paBroomOn->GetWidth(),m_paBroomOn->GetHeight(),UnitPixel);
	delete gBackground;

	// Draw temp surface to screen
	g->ResetTransform();
	g->DrawImage(m_paBackground,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,0,0,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Update distance, continue moving back to start of sweep
	m_flDist-=m_flVelMax;
	if (m_flDist<=(m_flSweepLength/m_flVelMax*0.25f)*Magnitude(m_vVel)) {
		// If all the way back, erase last broom, and get ready for next sweep
		g->DrawImage(g_paBmDirtyBkg,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,(int)rect.X-m_rDesktop.left,(int)rect.Y-m_rDesktop.top,(int)rect.Width,(int)rect.Height,UnitPixel);
		m_flDist=0.0f;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\csqueegee.h ===
// CSqueegee.h: interface for the CSqueegee class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __CSQUEEGEE_H
#define __CSQUEEGEE_H

#include "CObject.h"

class CSqueegee : public CObject
{
public:
	CSqueegee();
	virtual ~CSqueegee();

	void Destroy();
	BOOL Init(HWND hWnd);
	BOOL Move(Graphics *g);
	void Wipe(Graphics *g);

	Bitmap *m_paSqueegee;
	Bitmap *m_paBackground;
	Bitmap *m_paOriginalBkg;
	int m_nSnapshotSize;
	float m_flSqueegeeWidth;
	PointF m_vLastPos;
	float m_flLastAngle;
	RECT m_rDesktop;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\csqueegee.cpp ===
// CSqueegee.cpp: implementation of the CSqueegee class.
//
//////////////////////////////////////////////////////////////////////

#include "CSqueegee.h"

extern TextureBrush *g_paBrCleanBkg;
extern Bitmap *g_paBmDirtyBkg;

CSqueegee::CSqueegee()
{
	ZeroMemory(&m_rDesktop,sizeof(m_rDesktop));
	ZeroMemory(&m_vLastPos,sizeof(m_vLastPos));
	m_flSqueegeeWidth=0.0f;
	m_paSqueegee=NULL;
	m_paBackground=NULL;
	m_flLastAngle=0.0f;
}

CSqueegee::~CSqueegee()
{
	Destroy();
}

void CSqueegee::Destroy()
{
	if (m_paSqueegee!=NULL) {
		delete m_paSqueegee;
		m_paSqueegee=NULL;
	}
	if (m_paBackground!=NULL) {
		delete m_paBackground;
		m_paBackground=NULL;
	}
}

BOOL CSqueegee::Init(HWND hWnd)
{
	float flWidth;
	float flHeight;

	Destroy();

	// Get desktop dimensions (left/top can be negative on multimon)
	GetClientRect(hWnd,&m_rDesktop);
	flWidth=(float)m_rDesktop.right;
	flHeight=(float)m_rDesktop.bottom;
	m_rDesktop.top+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.bottom+=GetSystemMetrics(SM_YVIRTUALSCREEN);
	m_rDesktop.left+=GetSystemMetrics(SM_XVIRTUALSCREEN);
	m_rDesktop.right+=GetSystemMetrics(SM_XVIRTUALSCREEN);

	m_flVelMax=((float)rand()/(float)RAND_MAX)*10.0f+35.0f;
	m_paSqueegee=LoadTGAResource(MAKEINTRESOURCE(IDR_SQUEEGEE));
	m_nSnapshotSize=(int)sqrt(m_paSqueegee->GetWidth()*m_paSqueegee->GetWidth()+(m_paSqueegee->GetHeight()+m_flVelMax*2.0f)*(m_paSqueegee->GetHeight()+m_flVelMax*2.0f));
	m_paBackground=new Bitmap(m_nSnapshotSize,m_nSnapshotSize,PixelFormat32bppPARGB);
	m_flSqueegeeWidth=m_paSqueegee->GetWidth()-6.0f;

	// Squeegees start from top left corner
	m_vPos.X=(float)m_rDesktop.left-(float)m_nSnapshotSize/2.0f;
	m_vPos.Y=(float)m_rDesktop.top+m_flSqueegeeWidth/2.0f;
	m_vVel.X=m_flVelMax;
	m_vVel.Y=0.0f;
	m_vAcc.X=0.0f;
	m_vAcc.Y=0.0f;

	m_vLastPos=m_vPos;
	m_flLastAngle=((float)atan2(m_vVel.Y,m_vVel.X)*180.0f/3.1415f);

	return true;
}

BOOL CSqueegee::Move(Graphics *g)
// Returns true if moved on screen, false if moved outside screen
{
	// Update position and other variables
	m_vLastPos=m_vPos;
	m_vPos=m_vPos+m_vVel;
	if ((m_vPos.X<(float)m_rDesktop.left-(float)m_nSnapshotSize) ||
		(m_vPos.X>(float)m_rDesktop.right+(float)m_nSnapshotSize)) {
		// If past the left/right edge of the screen, turn around and move down a notch
		m_vPos.Y+=m_flSqueegeeWidth-10.0f;
		m_vVel.X*=-1.0f;
		m_flLastAngle+=180.0f;
	}
	else if (m_vPos.Y>(float)m_rDesktop.bottom+(float)m_nSnapshotSize) {
		// If past the bottom of the screen, its done
		return false;
	}

	Wipe(g);

	return true;
}

void CSqueegee::Wipe(Graphics *g)
{
	Graphics *gBackground;
	RectF rect(0.0f,0.0f,m_flSqueegeeWidth,m_flVelMax);
	RectF rect2(0.0f,0.0f,(float)m_paSqueegee->GetWidth(),(float)m_paSqueegee->GetHeight()+m_flVelMax);
	Matrix mat;
	GraphicsPath Path;
	Graphics *gDirty;

	// Set up the brush transform (opposite from original transform)
	g_paBrCleanBkg->ResetTransform();
	mat.Reset();
	mat.Translate((float)m_paSqueegee->GetWidth()/2.0f-5.0f,-(float)m_paSqueegee->GetHeight()+30.0f);
	mat.Rotate(-m_flLastAngle-90.0f);
	mat.Translate(-m_vLastPos.X+m_rDesktop.left,-m_vLastPos.Y+m_rDesktop.top);
	g_paBrCleanBkg->SetTransform(&mat);

	// Set up original transform and erase from DirtyBkg a rectangle where the squeegee moved
	gDirty=new Graphics(g_paBmDirtyBkg);
	gDirty->TranslateTransform(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
	gDirty->RotateTransform(m_flLastAngle+90.0f);
	gDirty->TranslateTransform(-(float)m_paSqueegee->GetWidth()/2.0f+5.0f,(float)m_paSqueegee->GetHeight()-30.0f);
	gDirty->FillRectangle(g_paBrCleanBkg,rect);
	delete gDirty;

	// Get the bounds of the squeegee after rotations
	Path.AddRectangle(rect2);
	mat.Reset();
	mat.Translate(m_vLastPos.X-m_rDesktop.left,m_vLastPos.Y-m_rDesktop.top);
	mat.Rotate(m_flLastAngle+90.0f);
	mat.Translate(-m_flSqueegeeWidth/2.0f,0.0);
	Path.GetBounds(&rect,&mat,NULL);

	// Draw on a temp surface whatever was on the dirty background where the squeegee is to be drawn
	gBackground=new Graphics(m_paBackground);
	gBackground->DrawImage(g_paBmDirtyBkg,0,0,(int)rect.X,(int)rect.Y,(int)rect.Width,(int)rect.Height,UnitPixel);

	// Draw squeegee on temp surface
	gBackground->ResetTransform();
	gBackground->TranslateTransform(rect.Width/2.0f,rect.Height/2.0f);
	gBackground->RotateTransform(m_flLastAngle+90.0f);
	gBackground->TranslateTransform(-(float)m_paSqueegee->GetWidth()/2.0f,-(float)m_paSqueegee->GetHeight()/2.0f-m_flVelMax);
	gBackground->DrawImage(m_paSqueegee,0,0,0,0,m_paSqueegee->GetWidth(),m_paSqueegee->GetHeight(),UnitPixel);
	delete gBackground;

	// Draw temp surface to screen
	g->ResetTransform();
	g->DrawImage(m_paBackground,(int)rect.X,(int)rect.Y,0,0,(int)rect.Width,(int)rect.Height,UnitPixel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\csweeper.h ===
// CSweeper.h: interface for the CSweeper class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __CSWEEPER_H
#define __CSWEEPER_H

#include "CObject.h"

class CSweeper : public CObject
{
public:
	CSweeper();
	virtual ~CSweeper();

	void Destroy();
	BOOL Init(HWND hWnd);
	BOOL Move(Graphics *g);
	void Sweep(Graphics *g);
	void NoSweep(Graphics *g);

	Bitmap *m_paBroomOn;
	Bitmap *m_paBroomOff;
	Bitmap *m_paBackground;
	Bitmap *m_paOriginalBkg;
	int m_nSnapshotSize;
	float m_flBroomWidth;
	float m_flSweepLength;
	float m_flStepRadius;
	PointF m_vLastPos;
	float m_flLastAngle;
	float m_flDist;
	BOOL m_bSweeping;
	RECT m_rDesktop;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\trialpha\gpinit.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is probably specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects.
*   The ordering is important when apps make global GDI+ objects.
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"
#include "gpinit.h"

GdiplusInitHelper::GdiplusInitHelper() : gpToken(0), Valid(FALSE)
{
    Gdiplus::GdiplusStartupInput sti;
    if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
    {
        Valid = TRUE;
    }
}
    
GdiplusInitHelper::~GdiplusInitHelper()
{
    if (Valid)
    {
        Gdiplus::GdiplusShutdown(gpToken);
    }
}

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\makefile.inc ===
$(O)\sidewalk.scr: $(O)\sidewalk.exe
        copy $(O)\sidewalk.exe $(O)\sidewalk.scr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\trialpha\gpinit.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Notes:
*
*   An app should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
* Created:
*
*   09/25/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _GPINIT_H
#define _GPINIT_H

class GdiplusInitHelper
{
public:
    GdiplusInitHelper();
    ~GdiplusInitHelper();
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

extern GdiplusInitHelper gGdiplusInitHelper;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\loadtga.cpp ===
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>
using namespace Gdiplus;

Bitmap *LoadTGAResource(char *szResource)
// Returns an allocated Bitmap
{
	BYTE Type;
	WORD wWidth;
	WORD wHeight;
	BYTE cBits;
	HGLOBAL hGlobal=NULL;
	BYTE *pData=NULL;

	hGlobal=LoadResource(GetModuleHandle(NULL),FindResource(GetModuleHandle(NULL),szResource,"TGA"));
	pData=(BYTE*)LockResource(hGlobal);
	// There is no Unlock or unload, it will get thrown away once module gets destroyed.

	memcpy(&Type,(pData+2),sizeof(Type));
	memcpy(&wWidth,(pData+12),sizeof(wWidth));
	memcpy(&wHeight,(pData+14),sizeof(wHeight));
	memcpy(&cBits,(pData+16),sizeof(cBits));

	if (cBits!=32) { return NULL; }
	if (Type!=2) { return NULL; }

	return new Bitmap(wWidth,wHeight,wWidth*(32/8),PixelFormat32bppARGB,(pData+18));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\trialpha\gpinit.inc ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Helper for GDI+ initialization
*
* Abstract:
*
*   This code initializes GDI+ (with default parameters).
*   The code is specific to our compiler, because it uses #pragma to
*   get our code to be initialized before the app's other global objects
*   (important when apps make global GDI+ objects.)
*
* Notes:
*
*   A test app should include this in *just one* of its .cpp files.
*   It should check gGdiplusInitHelper.IsValid() in its main function,
*   and abort if it returns FALSE.
*
*   We use "#pragma code_seg()", which resets the code segment to "whatever
*   it was when compilation began" (MSDN). In other words, we stomp on whatever
*   the code segment might have been changed to before this file was included.
*   You don't need to worry about this unless you use "#pragma code_seg"
*   yourself, in the file which includes this one.
*
* Created:
*
*   09/18/2000 agodfrey
*      Created it.
*
**************************************************************************/

#include <objbase.h>
#include "gdiplus.h"

// Disable the stupid warning that says we have a "lib" code segment.
#pragma warning( push )
#pragma warning( disable : 4073 )

// Make a separate code segment, and mark it as a "library initialization"
// segment
#pragma code_seg( "GpInit" )
#pragma init_seg( lib )

class GdiplusInitHelper
{
public:
    GdiplusInitHelper() : gpToken(0), Valid(FALSE)
    {
        Gdiplus::GdiplusStartupInput sti;
        if (Gdiplus::GdiplusStartup(&gpToken, &sti, NULL) == Gdiplus::Ok)
        {
            Valid = TRUE;
        }
    }
    ~GdiplusInitHelper()
    {
        if (Valid)
        {
            Gdiplus::GdiplusShutdown(gpToken);
        }
    }
    BOOL IsValid() { return Valid; }
    
private:    
    ULONG_PTR gpToken;
    BOOL Valid;
};

// Declare the global in this code segment, so that it is initialized before/
// destroyed after the app's globals.

GdiplusInitHelper gGdiplusInitHelper;

// Reset the code segment to "whatever it was when compilation began".

#pragma code_seg()

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Sidewalk.rc
//
#define IDS_DESCRIPTION                 1
#define ID_APP                          100
#define IDD_DIALOG1                     101
#define IDR_BOOT                        129
#define IDR_BOOT2                       131
#define IDR_BAREFOOT                    133
#define IDR_DOG                         134
#define IDB_LOGO                        137
#define IDR_BROOMON                     138
#define IDR_BROOMOFF                    139
#define IDR_SQUEEGEE                    146
#define ID_SPEED                        1000
#define idsIniFile                      1001
#define ID_OK                           1002
#define ID_CANCEL                       1003
#define IDC_SWEEPER                     1004
#define IDC_SQUEEGEE                    1005
#define IDC_RANDOMCLEANER               1006
#define idsAppName                      1007
#define IDC_CLEANERGIVENINTERVAL        1008
#define IDC_CLEANERRANDOMINTERVAL       1009
#define IDC_CLEANERINTERVAL             1010
#define IDC_USEBITMAP                   1011
#define IDC_BROWSE                      1012
#define IDC_FILENAME                    1013
#define IDC_CROWDSPEED                  1014
#define IDC_CROWDSIZE                   1015
#define DLG_SCRNSAVECONFIGURE           2003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        147
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\main.cpp ===
#include "CPerson.h"
#include "CSweeper.h"
#include "CSqueegee.h"
#include <mmsystem.h>
#include <commctrl.h>
#include <stdio.h>
#include <commdlg.h>

enum ENUM_CLEANER {
    eSweeper=0,
    eSqueegee,
    eRandom
};

#define MAXOBJECTS 100
#define CROWDSPEED_DEFAULT 19
#define RANDOMCLEANINTERVAL_DEFAULT 1
#define CLEANDELAY_DEFAULT 10
#define USEBITMAP_DEFAULT 0
#define FILENAME_DEFAULT "GDI+ Logo"
#define CLEANER_DEFAULT eSweeper
#define CROWDSIZE_DEFAULT 3

char szCrowdSpeed[]="CrowdSpeed";
char szRandomCleanInterval[]="RandomCleanInterval";
char szCleanDelay[]="CleanDelay";
char szUseBitmap[]="UseBitmap";
char szFilename[]="Filename";
char szCleaner[]="Cleaner";
char szCrowdSize[]="CrowdSize";

int g_cObjectMax;
CObject *g_rgpaObject[MAXOBJECTS];
CObject *g_paCleaner;
TextureBrush *g_paBrCleanBkg=NULL;
Bitmap *g_paBmDirtyBkg=NULL;
DWORD g_dwCleanDelay;
DWORD g_dwSimulateDelay;
BOOL g_bRandomCleanInterval;
BOOL g_bUseBitmap;
ENUM_CLEANER g_eCleaner;
char g_szFile[MAX_PATH];

BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{
    return TRUE;
}

void Browse(HWND hDlg)
{
    char szFile[MAX_PATH];
    OPENFILENAME ofn;
    HWND hWnd;

    ZeroMemory(szFile,sizeof(szFile));
    ZeroMemory(&ofn,sizeof(OPENFILENAME));
    ofn.lStructSize=sizeof(OPENFILENAME);
    ofn.hwndOwner=hDlg;
    ofn.lpstrFile=szFile;
    ofn.nMaxFile=sizeof(szFile);
    ofn.lpstrFilter="All Supported\0*.bmp;*.jpg;*.jpeg;*.tif;*.tiff;*.png;*.gif;*.wmf;*.ico;*.emf\0Bitmap\0*.bmp\0JPEG\0*.jpg;*.jpeg\0TIFF\0*.tif;*.tiff\0PNG\0*.png\0GIF\0*.gif\0WMF\0*.wmf\0ICON\0*.ico\0EMF\0*.emf\0";
    ofn.nFilterIndex=1;
    ofn.lpstrFileTitle=NULL;
    ofn.nMaxFileTitle=0;
    ofn.lpstrInitialDir=NULL;
    ofn.Flags=OFN_PATHMUSTEXIST|OFN_FILEMUSTEXIST|OFN_EXPLORER;

    if (GetOpenFileName(&ofn)) {
        hWnd=GetDlgItem(hDlg,IDC_FILENAME);
        SendMessage(hWnd,WM_SETTEXT,0,(LPARAM)szFile);
    }
}

BOOL WINAPI ScreenSaverConfigureDialog(HWND hDlg,UINT Msg,WPARAM wParam,LPARAM lParam)
{ 
    HWND hWnd;
    LONG lCrowdSpeed=CROWDSPEED_DEFAULT;
    char szTemp[MAX_PATH];

    switch(Msg) {
        case WM_INITDIALOG:
            InitCommonControls();
            LoadString(hMainInstance,idsAppName,szAppName,40);
            LoadString(hMainInstance,idsIniFile,szIniFile,MAXFILELEN);

            lCrowdSpeed=GetPrivateProfileInt(szAppName,szCrowdSpeed,CROWDSPEED_DEFAULT,szIniFile);
            g_bRandomCleanInterval=GetPrivateProfileInt(szAppName,szRandomCleanInterval,RANDOMCLEANINTERVAL_DEFAULT,szIniFile);
            g_dwCleanDelay=GetPrivateProfileInt(szAppName,szCleanDelay,CLEANDELAY_DEFAULT,szIniFile);
            g_bUseBitmap=GetPrivateProfileInt(szAppName,szUseBitmap,USEBITMAP_DEFAULT,szIniFile);
            GetPrivateProfileString(szAppName,szFilename,FILENAME_DEFAULT,g_szFile,MAX_PATH,szIniFile);
            g_eCleaner=(ENUM_CLEANER)GetPrivateProfileInt(szAppName,szCleaner,CLEANER_DEFAULT,szIniFile);
            g_cObjectMax=GetPrivateProfileInt(szAppName,szCrowdSize,CROWDSIZE_DEFAULT,szIniFile);

            hWnd=GetDlgItem(hDlg,IDC_CROWDSPEED);
            SendMessage(hWnd,TBM_SETRANGE,(WPARAM)true,(LPARAM)MAKELONG(0,20));
            SendMessage(hWnd,TBM_SETPAGESIZE,0,(LPARAM)20/8);
            SendMessage(hWnd,TBM_SETPOS,(WPARAM)true,(LPARAM)lCrowdSpeed);

            hWnd=GetDlgItem(hDlg,IDC_CROWDSIZE);
            SendMessage(hWnd,TBM_SETRANGE,(WPARAM)true,(LPARAM)MAKELONG(1,10));
            SendMessage(hWnd,TBM_SETPAGESIZE,0,(LPARAM)1);
            SendMessage(hWnd,TBM_SETPOS,(WPARAM)true,(LPARAM)g_cObjectMax);

            hWnd=GetDlgItem(hDlg,IDC_FILENAME);
            SendMessage(hWnd,WM_SETTEXT,0,(LPARAM)g_szFile);

            hWnd=GetDlgItem(hDlg,IDC_USEBITMAP);
            if (g_bUseBitmap) {
                SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
            }
            else {
                hWnd=GetDlgItem(hDlg,IDC_BROWSE);
                EnableWindow(hWnd,false);
                hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                EnableWindow(hWnd,false);
            }

            if (g_bRandomCleanInterval) {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERRANDOMINTERVAL);
                SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
            }
            else {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERGIVENINTERVAL);
                SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
            }

            hWnd=GetDlgItem(hDlg,IDC_CLEANERGIVENINTERVAL);
            if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                EnableWindow(hWnd,true);
            }
            else {
                hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                EnableWindow(hWnd,false);
            }

            switch(g_eCleaner) {
                case eSweeper:
                    hWnd=GetDlgItem(hDlg,IDC_SWEEPER);
                    SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
                    break;
                case eSqueegee:
                    hWnd=GetDlgItem(hDlg,IDC_SQUEEGEE);
                    SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
                    break;
                case eRandom:
                    hWnd=GetDlgItem(hDlg,IDC_RANDOMCLEANER);
                    SendMessage(hWnd,BM_SETCHECK,(WPARAM)true,0);
                    break;
            }

            hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
            _itoa(g_dwCleanDelay,szTemp,10);
            SendMessage(hWnd,WM_SETTEXT,0,(LPARAM)szTemp);

            return TRUE;
        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case IDC_USEBITMAP:
                    if (HIWORD(wParam)==BN_CLICKED) {
                        hWnd=GetDlgItem(hDlg,IDC_BROWSE);
                        EnableWindow(hWnd,!IsWindowEnabled(hWnd));
                        hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                        EnableWindow(hWnd,!IsWindowEnabled(hWnd));
                    }
                    break;
                case IDC_CLEANERGIVENINTERVAL:
                    hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                    EnableWindow(hWnd,true);
                    break;
                case IDC_CLEANERRANDOMINTERVAL:
                    hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                    EnableWindow(hWnd,false);
                    break;
                case IDC_BROWSE:
                    Browse(hDlg);
                    break;
                case ID_OK:
                    hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                    SendMessage(hWnd,WM_GETTEXT,(WPARAM)MAX_PATH,(LPARAM)g_szFile);

                    hWnd=GetDlgItem(hDlg,IDC_CROWDSPEED);
                    lCrowdSpeed=SendMessage(hWnd,TBM_GETPOS,0,0);
                    sprintf(szTemp,"%ld",lCrowdSpeed);
                    WritePrivateProfileString(szAppName,szCrowdSpeed,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_CROWDSIZE);
                    g_cObjectMax=SendMessage(hWnd,TBM_GETPOS,0,0);
                    sprintf(szTemp,"%ld",g_cObjectMax);
                    WritePrivateProfileString(szAppName,szCrowdSize,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_CLEANERRANDOMINTERVAL);
                    g_bRandomCleanInterval=SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED;
                    sprintf(szTemp,"%ld",g_bRandomCleanInterval);
                    WritePrivateProfileString(szAppName,szRandomCleanInterval,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_CLEANERINTERVAL);
                    SendMessage(hWnd,WM_GETTEXT,(WPARAM)MAX_PATH,(LPARAM)szTemp);
                    WritePrivateProfileString(szAppName,szCleanDelay,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_USEBITMAP);
                    g_bUseBitmap=SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED;
                    sprintf(szTemp,"%ld",g_bUseBitmap);
                    WritePrivateProfileString(szAppName,szUseBitmap,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_FILENAME);
                    SendMessage(hWnd,WM_GETTEXT,(WPARAM)MAX_PATH,(LPARAM)szTemp);
                    WritePrivateProfileString(szAppName,szFilename,szTemp,szIniFile);

                    hWnd=GetDlgItem(hDlg,IDC_SWEEPER);
                    if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                        g_eCleaner=eSweeper;
                    }
                    hWnd=GetDlgItem(hDlg,IDC_SQUEEGEE);
                    if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                        g_eCleaner=eSqueegee;
                    }
                    hWnd=GetDlgItem(hDlg,IDC_RANDOMCLEANER);
                    if (SendMessage(hWnd,BM_GETCHECK,0,0)==BST_CHECKED) {
                        g_eCleaner=eRandom;
                    }
                    sprintf(szTemp,"%ld",g_eCleaner);
                    WritePrivateProfileString(szAppName,szCleaner,szTemp,szIniFile);
                case ID_CANCEL:
                    EndDialog(hDlg,LOWORD(wParam)==ID_OK);
                return TRUE;
            }
    }

    return FALSE;
}

LRESULT WINAPI ScreenSaverProc(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
{
    static bool         GdiplusInitialized = false;
    static ULONG_PTR    gpToken;
        
    const UINT_PTR NEWCLEANER_TIMERID=1;
    const UINT_PTR SIMULATE_TIMERID=2;
    static bFirstRun=true;
    Graphics *g;
    int i;
    int nRand;
    RECT rDesktop;
    HDC hdcBkgBitmap;
    HDC hdcScreen;
    TextureBrush *paBrDirtyBkg=NULL;
    Bitmap *paBmCleanBkg=NULL;
    WCHAR wsFile[MAX_PATH];
    LONG lCrowdSpeed;

    GdiplusStartupInput sti;
        
    switch(Msg) {
        case WM_CREATE:
            // Initialize GDI+

            if (GdiplusStartup(&gpToken, &sti, NULL) == Ok)
            {
                GdiplusInitialized = true;
            }
            else
            {
                break;
            }

            LoadString(hMainInstance,idsAppName,szAppName,10);
            LoadString(hMainInstance,idsIniFile,szIniFile,MAXFILELEN);

            // Load variables
            lCrowdSpeed=GetPrivateProfileInt(szAppName,szCrowdSpeed,CROWDSPEED_DEFAULT,szIniFile);
            g_dwSimulateDelay=(20-lCrowdSpeed)*10;
            g_bRandomCleanInterval=GetPrivateProfileInt(szAppName,szRandomCleanInterval,RANDOMCLEANINTERVAL_DEFAULT,szIniFile);
            g_dwCleanDelay=GetPrivateProfileInt(szAppName,szCleanDelay,CLEANDELAY_DEFAULT,szIniFile)*1000;
            g_bUseBitmap=GetPrivateProfileInt(szAppName,szUseBitmap,USEBITMAP_DEFAULT,szIniFile);
            GetPrivateProfileString(szAppName,szFilename,FILENAME_DEFAULT,g_szFile,MAX_PATH,szIniFile);
            g_eCleaner=(ENUM_CLEANER)GetPrivateProfileInt(szAppName,szCleaner,CLEANER_DEFAULT,szIniFile);
            g_cObjectMax=GetPrivateProfileInt(szAppName,szCrowdSize,CROWDSIZE_DEFAULT,szIniFile);

            srand((unsigned int)timeGetTime());

            // Get desktop dimensions
            GetClientRect(hWnd,&rDesktop);

            g_paBmDirtyBkg=new Bitmap(rDesktop.right,rDesktop.bottom,PixelFormat32bppPARGB);
            if (g_bUseBitmap) {
                mbstowcs(wsFile,g_szFile,sizeof(g_szFile));
                paBmCleanBkg=new Bitmap(wsFile);
                if (paBmCleanBkg->GetLastStatus()!=Ok) {
                    delete paBmCleanBkg;
                    paBmCleanBkg=new Bitmap((HINSTANCE)GetModuleHandle(NULL),(WCHAR*)MAKEINTRESOURCE(IDB_LOGO));
                }

                // Take snapshot of whole desktop for DirtyBkg
                g=new Graphics(g_paBmDirtyBkg);
                hdcBkgBitmap=g->GetHDC();
                hdcScreen=CreateDC("DISPLAY",NULL,NULL,NULL);
                StretchBlt(hdcBkgBitmap,0,0,rDesktop.right,rDesktop.bottom,hdcScreen,GetSystemMetrics(SM_XVIRTUALSCREEN),GetSystemMetrics(SM_YVIRTUALSCREEN),rDesktop.right,rDesktop.bottom,SRCCOPY);
                g->ReleaseHDC(hdcBkgBitmap);
                DeleteDC(hdcScreen);
                delete g;
            }
            else {
                // Take snapshot of whole desktop for CleanBkg
                paBmCleanBkg=new Bitmap(rDesktop.right,rDesktop.bottom,PixelFormat32bppPARGB);
                g=new Graphics(paBmCleanBkg);
                hdcBkgBitmap=g->GetHDC();
                hdcScreen=CreateDC("DISPLAY",NULL,NULL,NULL);
                StretchBlt(hdcBkgBitmap,0,0,rDesktop.right,rDesktop.bottom,hdcScreen,GetSystemMetrics(SM_XVIRTUALSCREEN),GetSystemMetrics(SM_YVIRTUALSCREEN),rDesktop.right,rDesktop.bottom,SRCCOPY);
                g->ReleaseHDC(hdcBkgBitmap);
                DeleteDC(hdcScreen);
                delete g;

                g=new Graphics(g_paBmDirtyBkg);
                g->DrawImage(paBmCleanBkg,0,0,0,0,rDesktop.right,rDesktop.bottom,UnitPixel);
                delete g;
            }

            // Make brush out of clean desktop
            g_paBrCleanBkg=new TextureBrush(paBmCleanBkg,WrapModeTile);
            delete paBmCleanBkg;

            for (i=0;i<g_cObjectMax;i++) {
                g_rgpaObject[i]=new CPerson();
                g_rgpaObject[i]->Init(hWnd);
            }

            SetTimer(hWnd,NEWCLEANER_TIMERID,g_dwCleanDelay,NULL);
            SetTimer(hWnd,SIMULATE_TIMERID,g_dwSimulateDelay,NULL);
            return 0;
        case WM_ERASEBKGND:
            return 0;
        case WM_TIMER:
            if(!GdiplusInitialized)
            {
                break;
            }
            switch (wParam) {
                case NEWCLEANER_TIMERID:
                    if (g_paCleaner==NULL) {
                        switch (g_eCleaner) {
                            case eSweeper:
                                g_paCleaner=new CSweeper();
                                break;
                            case eSqueegee:
                                g_paCleaner=new CSqueegee();
                                break;
                            case eRandom:
                                nRand=rand();
                                if (nRand<RAND_MAX/2) {
                                    g_paCleaner=new CSweeper();
                                }
                                else {
                                    g_paCleaner=new CSqueegee();
                                }
                                break;
                        }
                        g_paCleaner->Init(hWnd);
                    }
                    if (g_bRandomCleanInterval) {
                        nRand=rand();
                        g_dwCleanDelay=(int)(((float)rand()/(float)RAND_MAX)*15000.0f+10000.0f);
                        SetTimer(hWnd,NEWCLEANER_TIMERID,g_dwCleanDelay,NULL);
                    }
                    break;
                case SIMULATE_TIMERID:
                    g=Graphics::FromHWND(hWnd);

                    if (bFirstRun) {
                        // Blit to screen (used inside demo window in the display dialog box)
                        bFirstRun=false;
                        GetClientRect(hWnd,&rDesktop);
                        g->DrawImage(g_paBmDirtyBkg,0,0,0,0,rDesktop.right,rDesktop.bottom,UnitPixel);
                    }

                    g->SetSmoothingMode(SmoothingModeNone);
                    g->SetInterpolationMode(InterpolationModeNearestNeighbor);

                    for (i=0;i<g_cObjectMax;i++) {
                        if (!g_rgpaObject[i]->Move(g)) {
                            // Moved outside desktop, delete it and recreate another
                            delete g_rgpaObject[i];
                            g_rgpaObject[i]=new CPerson();
                            g_rgpaObject[i]->Init(hWnd);
                        }
                    }
                    if (g_paCleaner!=NULL) {
                        if (!g_paCleaner->Move(g)) {
                            // Moved outside desktop, delete it and wait for the next
                            //  NEWCLEANER_TIMERID to hit
                            delete g_paCleaner;
                            g_paCleaner=NULL;
                        }
                    }

                    delete g;
                    break;
            }
            break;
        case WM_DESTROY:
            if (!GdiplusInitialized)
            {
                break;
            }
            
            if (g_paBrCleanBkg!=NULL) {
                delete g_paBrCleanBkg;
                g_paBrCleanBkg=NULL;
            }
            if (g_paBmDirtyBkg!=NULL) {
                delete g_paBmDirtyBkg;
                g_paBmDirtyBkg=NULL;
            }

            for (i=0;i<g_cObjectMax;i++) {
                if (g_rgpaObject[i]!=NULL) {
                    delete g_rgpaObject[i];
                    g_rgpaObject[i]=NULL;
                }
            }
            if (g_paCleaner!=NULL) {
                delete g_paCleaner;
                g_paCleaner=NULL;
            }

            KillTimer(hWnd,NEWCLEANER_TIMERID);
            KillTimer(hWnd,SIMULATE_TIMERID);
            
            GdiplusShutdown(gpToken);
            GdiplusInitialized = false;
            break;
    }

    return DefScreenSaverProc(hWnd, Msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\vmath.cpp ===
// Vector Math

#include "VMath.h"

float DotProduct(PointF v1,PointF v2)
{
	return v1.X*v2.X+v1.Y*v2.Y;
}

float Magnitude(PointF v)
{
	return (float)sqrt(DotProduct(v,v));
}

PointF Normalize(PointF vPoint)
{
	float flDenom;
	PointF vResult;

	flDenom=Magnitude(vPoint);
	vResult.X=vPoint.X/flDenom;
	vResult.Y=vPoint.Y/flDenom;

	return vResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\sidewalk\vmath.h ===
// Vector Math

#include <windows.h>
#include <objbase.h>
#include <math.h>
#include <gdiplus.h>
using namespace Gdiplus;

extern float DotProduct(PointF v1,PointF v2);
extern float Magnitude(PointF v);
extern PointF Normalize(PointF vPoint);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\trialpha\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trialpha.rc
//
#define IDC_MYICON                      2
#define IDD_TESTBED_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDM_SETTINGS                    106
#define IDI_TRIALPHA                    107
#define IDI_SMALL                       108
#define IDC_TRIALPHA                    109
#define IDD_SETTINGS                    110
#define IDR_MAINFRAME                   128
#define IDC_COUNT                       1001
#define IDC_LIFETIME                    1002
#define IDC_DELAY                       1003
#define IDC_LEAVETRAILS                 1004
#define IDC_CLEARSCREEN                 1005
#define IDC_REFLECTVERT                 1006
#define IDC_REFLECTHORZ                 1007
#define IDC_REFLECTDIAG                 1008
#define IDC_ALPHA                       1009
#define IDC_CURVES                      1010
#define IDC_OSCILLATE                   1011
#define IDC_FILLED                      1012
#define IDC_ROTATIONS                   1013
#define IDC_SHAPE                       1014
#define IDS_SHAPE_BASE                  1015
#define IDS_SHAPE_TRIANGLES             1015
#define IDS_SHAPE_CURVES                1016
#define IDS_SHAPE_ELLIPSES              1017
#define IDS_SHAPE_RECTANGLES            1018
#define IDS_SHAPE_TEXT                  1019
#define IDC_THETA                       1020
#define IDC_NULL                        1021

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\trialpha\trialpha.cpp ===
// trialpha.cpp : Defines the entry point for the application.
//

#include "trialpha.h"

#include "..\gpinit.inc"

#define MAX_LOADSTRING 100

// #define STANDALONE_DEBUG 1

#ifdef STANDALONE_DEBUG

// Global Variables:
HINSTANCE hMainInstance = (HINSTANCE)NULL;
HWND ghwndMain = (HWND)NULL;
#else // !STANDALONE_DEBUG
extern HINSTANCE hMainInstance;
#endif // !STANDALONE_DEBUG

TCHAR szTitle[MAX_LOADSTRING];        // The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];// The title bar text

UINT_PTR timerID = 0;
int timercount = 0;
BOOL suspend = FALSE;
BOOL showconfig = FALSE;
BOOL screensaver = FALSE;
BOOL silent = FALSE;
HWND hwndParent = (HWND)NULL;

// Foward declarations of functions included in this code module:
ATOM MyRegisterClass(HINSTANCE hInstance);
BOOL InitInstance(HINSTANCE, int);

#ifdef STANDALONE_DEBUG
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM);
#else // !STANDALONE_DEBUG

BOOL WINAPI RegisterDialogClasses(HANDLE hInst);
LRESULT WINAPI ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif // !STANDALONE_DEBUG

BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

//===========================================================================

typedef enum
{
    dtTriangles = 0,
    dtCurves = 1,
    dtEllipses = 2,
    dtRectangles = 3,
    dtText = 4
}
SHAPE;

typedef struct
{
    BYTE alpha;    // Alpha value
    int  count;    // Number of simultaneous triangles
    int  lifetime; // Number of displayed cycles
    int  delay;    // Number of cycles to delay before clearing
    BOOL leaveTrails;
    BOOL reflectVertical;
    BOOL reflectHorizontal;
    BOOL reflectDiagonal;
    BOOL clearScreen;
    BOOL oscillate;
    BOOL filled;
    int  rotations;
    float theta;   // Additional rotation applied per iteration
    SHAPE shape;
    WCHAR wchString[256];
    WCHAR wchFont[256];
    REAL textHeight;
}
LINESETTINGS;


typedef struct
{
    float x1;
    float y1;
    float x2;
    float y2;
    float x3;
    float y3;
    float dx1;
    float dy1;
    float dx2;
    float dy2;
    float dx3;
    float dy3;
    float r;
    float g;
    float b;
    float dr;
    float dg;
    float db;
}
LINEINFO;

typedef struct
{
    HDC        hdc;
    HBITMAP    hbmpOffscreen;
    HBITMAP    hbmpOld;
    BITMAPINFO bmi;
    void      *pvBits;
}
OFFSCREENINFO;

//===========================================================================

LINESETTINGS currentSettings =
{
    20,          // Alpha value
    1,           // number of simultaneous shapes
    1500,        // number of displayed cycles
    250,         // number if cycles to pause
    TRUE,        // leave trails
    FALSE,       // reflect Vertical
    TRUE,        // reflect Horizontal
    FALSE,       // reflect Diagonal
    TRUE,        // clear screen
    FALSE,       // oscillate
    FALSE,       // filled
    3,           // Count of rotations
    0.0f,        // theta
    dtTriangles, // shape
    L"Animated", // string for dtText
    L"Tahoma",   // font for dtText
    120.0f       // text height for dtText
};

#define MAX_LINES 256

LINESETTINGS dialogSettings;
LINEINFO rgLineInfo[MAX_LINES];
OFFSCREENINFO offscreenInfo = { 0 };

//===========================================================================

int GetIntValue(char *name, int value)
{
    return GetPrivateProfileInt("Settings", name, value, "Trialpha.ini");
}

void SetIntValue(char *name, int value)
{
    char szValue[80];

    wsprintf(szValue, "%d", value);

    WritePrivateProfileString("Settings", name, szValue, "Trialpha.ini");
}

void LoadState()
{
    currentSettings.alpha             = (BYTE)GetIntValue("Alpha",    20);
    currentSettings.count             = GetIntValue("Count",           1);
    currentSettings.lifetime          = GetIntValue("Lifetime",     1500);
    currentSettings.delay             = GetIntValue("Delay",         250);
    currentSettings.leaveTrails       = GetIntValue("LeaveTrails",     1);
    currentSettings.reflectVertical   = GetIntValue("ReflectV",        0);
    currentSettings.reflectHorizontal = GetIntValue("ReflectH",        1);
    currentSettings.reflectDiagonal   = GetIntValue("ReflectD",        0);
    currentSettings.clearScreen       = GetIntValue("ClearScreen",     0);
    currentSettings.oscillate         = GetIntValue("Oscillate",       0);
    currentSettings.filled            = GetIntValue("Filled",          0);
    currentSettings.rotations         = GetIntValue("Rotations",       3);
    currentSettings.theta             = GetIntValue("Theta",           0) / 10.0f;
    currentSettings.shape             = (SHAPE)GetIntValue("Shape",           0);
}

void SaveState()
{
    SetIntValue("Alpha",       currentSettings.alpha             );
    SetIntValue("Count",       currentSettings.count             );
    SetIntValue("Lifetime",    currentSettings.lifetime          );
    SetIntValue("Delay",       currentSettings.delay             );
    SetIntValue("LeaveTrails", currentSettings.leaveTrails       );
    SetIntValue("ReflectV",    currentSettings.reflectVertical   );
    SetIntValue("ReflectH",    currentSettings.reflectHorizontal );
    SetIntValue("ReflectD",    currentSettings.reflectDiagonal   );
    SetIntValue("ClearScreen", currentSettings.clearScreen       );
    SetIntValue("Oscillate",   currentSettings.oscillate         );
    SetIntValue("Filled",      currentSettings.filled            );
    SetIntValue("Rotations",   currentSettings.rotations         );
    SetIntValue("Theta",       (int)(currentSettings.theta*10.0f));
    SetIntValue("Shape",       (int)currentSettings.shape        );
}

//===========================================================================

void randomizelocations()
{
    if (currentSettings.count > MAX_LINES)
        currentSettings.count = MAX_LINES;

    for(int i=0;i<currentSettings.count;i++)
    {
        rgLineInfo[i].x1 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].y1 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].x2 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].y2 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].x3 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].y3 = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;

        rgLineInfo[i].dx1 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dy1 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dx2 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dy2 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dx3 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dy3 = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dx1 = -rgLineInfo[i].dx1;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dx2 = -rgLineInfo[i].dx2;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dx3 = -rgLineInfo[i].dx3;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dy1 = -rgLineInfo[i].dy1;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dy2 = -rgLineInfo[i].dy2;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dy3 = -rgLineInfo[i].dy3;

        rgLineInfo[i].dx1 /= 3.0f;
        rgLineInfo[i].dy1 /= 3.0f;
        rgLineInfo[i].dx2 /= 3.0f;
        rgLineInfo[i].dy2 /= 3.0f;
        rgLineInfo[i].dx3 /= 3.0f;
        rgLineInfo[i].dy3 /= 3.0f;
    }
}

void randomizecolors(int index)
{
    if (currentSettings.count > MAX_LINES)
        currentSettings.count = MAX_LINES;

    for(int i=0;i<currentSettings.count;i++)
    {
        rgLineInfo[i].r = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].g = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;
        rgLineInfo[i].b = (rand() / REAL(RAND_MAX) * 80.0f) + 10.0f;

        rgLineInfo[i].dr = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].dg = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;
        rgLineInfo[i].db = (rand() / REAL(RAND_MAX) * 1.0f) + 0.5f;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dr = -rgLineInfo[i].dr;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].dg = -rgLineInfo[i].dg;

        if (rand() > (RAND_MAX/2))
            rgLineInfo[i].db = -rgLineInfo[i].db;
    }
}

void FreeOffscreen()
{
    if (offscreenInfo.hdc)
    {
        SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOld);
        DeleteObject(offscreenInfo.hbmpOffscreen);
        DeleteDC(offscreenInfo.hdc);

        offscreenInfo.hdc = (HDC)NULL;
        offscreenInfo.hbmpOffscreen = (HBITMAP)NULL;
        offscreenInfo.hbmpOld = (HBITMAP)NULL;
        offscreenInfo.bmi.bmiHeader.biWidth = 0;
        offscreenInfo.bmi.bmiHeader.biHeight = 0;
    }
}

void ClearOffscreen()
{
    if (offscreenInfo.hdc)
    {
        PatBlt(
            offscreenInfo.hdc,
            0,
            0,
            offscreenInfo.bmi.bmiHeader.biWidth,
            offscreenInfo.bmi.bmiHeader.biHeight,
            BLACKNESS);
    }

#ifdef STANDALONE_DEBUG
    InvalidateRect(ghwndMain, NULL, TRUE);
#endif // STANDALONE_DEBUG
}

HDC GetOffscreen(HDC hDC, int width, int height)
{
    HDC hdcResult = NULL;

    if (width > offscreenInfo.bmi.bmiHeader.biWidth ||
        height > offscreenInfo.bmi.bmiHeader.biHeight ||
        offscreenInfo.hdc == (HDC)NULL)
    {
        FreeOffscreen();

        offscreenInfo.bmi.bmiHeader.biSize = sizeof(offscreenInfo.bmi.bmiHeader);
        offscreenInfo.bmi.bmiHeader.biWidth = width;
        offscreenInfo.bmi.bmiHeader.biHeight = height;
        offscreenInfo.bmi.bmiHeader.biPlanes = 1;
        offscreenInfo.bmi.bmiHeader.biBitCount = 32;
        offscreenInfo.bmi.bmiHeader.biCompression = BI_RGB;
        offscreenInfo.bmi.bmiHeader.biSizeImage = 0;
        offscreenInfo.bmi.bmiHeader.biXPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biYPelsPerMeter = 10000;
        offscreenInfo.bmi.bmiHeader.biClrUsed = 0;
        offscreenInfo.bmi.bmiHeader.biClrImportant = 0;

        offscreenInfo.hbmpOffscreen = CreateDIBSection(
            hDC,
            &offscreenInfo.bmi,
            DIB_RGB_COLORS,
            &offscreenInfo.pvBits,
            NULL,
            0);

        if (offscreenInfo.hbmpOffscreen)
        {
            offscreenInfo.hdc = CreateCompatibleDC(hDC);

            if (offscreenInfo.hdc)
            {
                offscreenInfo.hbmpOld = (HBITMAP)SelectObject(offscreenInfo.hdc, offscreenInfo.hbmpOffscreen);

                ClearOffscreen();
            }
        }
    }

    hdcResult = offscreenInfo.hdc;

    return hdcResult;
}

void DrawGraphics(HWND hWnd, HDC hDC, LPRECT lpRectDraw, LPRECT lpRectBounds)
{
    RECT rectBounds;
    Graphics *gr = NULL;

    gr = new Graphics(hDC);

    gr->ResetTransform();
    gr->SetPageUnit(UnitPixel);
    gr->SetSmoothingMode(SmoothingModeHighQuality);
    gr->TranslateTransform(REAL(-0.5), REAL(-0.5));

    SolidBrush whiteBrush(Color(0xFF, 0xFF, 0xFF));
    SolidBrush blackBrush(Color(0x00, 0x00, 0x00));
    Pen blackPen(Color(0x00, 0x00, 0x00));
    Pen whitePen(Color(0xFF, 0xFF, 0xFF));

    FontFamily fontFamily(currentSettings.wchFont);
    StringFormat stringFormat(StringFormatFlagsDirectionRightToLeft);

    stringFormat.SetAlignment(StringAlignmentCenter);
    stringFormat.SetLineAlignment(StringAlignmentCenter);

    RectF rfDraw(REAL(lpRectDraw->left), REAL(lpRectDraw->top), REAL(lpRectDraw->right-lpRectDraw->left), REAL(lpRectDraw->bottom-lpRectDraw->top));

    RectF rect(-500.0f, -(currentSettings.textHeight/2.0f), 1000.0f, currentSettings.textHeight);
    GraphicsPath textPath;
    textPath.AddString(currentSettings.wchString, -1, &fontFamily, FontStyleRegular, currentSettings.textHeight, rect, &stringFormat);

    // This paints the background using GDI+...
    if (!currentSettings.leaveTrails)
        gr->FillRectangle(&blackBrush, rfDraw);

    REAL width  = REAL(lpRectDraw->right - lpRectDraw->left) / REAL(100.0);
    REAL height = REAL(lpRectDraw->bottom - lpRectDraw->top) / REAL(100.0);

    if (currentSettings.count > MAX_LINES)
        currentSettings.count = MAX_LINES;

    for(int index=0;index<currentSettings.count;index++)
    {
        int i = index;
        
        BYTE r = (BYTE)(rgLineInfo[i].r * 255.0 / 100.0);
        BYTE g = (BYTE)(rgLineInfo[i].g * 255.0 / 100.0);
        BYTE b = (BYTE)(rgLineInfo[i].b * 255.0 / 100.0);

        SolidBrush brush(Color(currentSettings.leaveTrails ? currentSettings.alpha : 0xC0, r, g, b));
        Pen pen(Color(currentSettings.leaveTrails ? currentSettings.alpha : 0xC0, r, g, b), 0);
        BOOL fHitWall = FALSE;
        Rect bounds;
        GraphicsPath path;
        PointF rgPoints[4];
        float offsetx = 0.0f;
        float offsety = 0.0f;
        float scalex  = (float)width;
        float scaley  = (float)height;

        if (currentSettings.oscillate)
        {
            float ratiox = (((timercount+(index*5)) % 200) / 100.0f) - 1.0f;
            float ratioy = (((timercount+(index*9)) % 160) /  80.0f) - 1.0f;

            if (ratiox < 0.0)
                ratiox = -ratiox;

            if (ratioy < 0.0)
                ratioy = -ratioy;

            offsetx = (width  * ratiox) * 50.0f;
            offsety = (height * ratioy) * 50.0f;
            scalex  = (width  * (1.0f - ratiox));
            scaley  = (height * (1.0f - ratioy));
        }

        // Setup the array of points...
        rgPoints[0].X = offsetx + rgLineInfo[i].x1 * scalex;
        rgPoints[0].Y = offsety + rgLineInfo[i].y1 * scaley;

        rgPoints[1].X = offsetx + rgLineInfo[i].x2 * scalex;
        rgPoints[1].Y = offsety + rgLineInfo[i].y2 * scaley;

        rgPoints[2].X = offsetx + rgLineInfo[i].x3 * scalex;
        rgPoints[2].Y = offsety + rgLineInfo[i].y3 * scaley;

        rgPoints[3].X = offsetx + rgLineInfo[i].x1 * scalex;
        rgPoints[3].Y = offsety + rgLineInfo[i].y1 * scaley;

        path.Reset();

        switch(currentSettings.shape)
        {
            case dtCurves :
            {
                // Add 3 curve points...
                path.AddClosedCurve(rgPoints, 3);
            }
            break;

            case dtTriangles :
            {
                // Add 4 line points...
                path.AddLines(rgPoints, 4);
            }
            break;

            case dtEllipses :
            {
                // Draw an ellipse at x1, y1
                REAL x = rgPoints[0].X;
                REAL y = rgPoints[0].Y;
                REAL dx = rgLineInfo[i].x3 * width / 4.0f;
                REAL dy = rgLineInfo[i].y3 * height / 4.0f;
                REAL rotate = (timercount / 3.0f) + (rgLineInfo[i].x2 + rgLineInfo[i].y2) * 1.8f;

                rotate += (index * 360.0f) / currentSettings.count;

                RectF rect(x-dx/2.0f, y-dy/2.0f, dx, dy);

                path.AddEllipse(rect);

                Matrix matrix;

                matrix.Translate(x, y);
                matrix.Rotate(rotate);
                matrix.Translate(-x, -y);

                path.Transform(&matrix);
            }
            break;

            case dtRectangles :
            {
                // Draw a rectangle at x1, y1
                REAL x = rgPoints[0].X;
                REAL y = rgPoints[0].Y;
                REAL dx = rgLineInfo[i].x3 * width / 4.0f;
                REAL dy = rgLineInfo[i].y3 * height / 4.0f;
                REAL rotate = (timercount / 3.0f) + (rgLineInfo[i].x2 + rgLineInfo[i].y2) * 1.8f;

                rotate += (index * 360.0f) / currentSettings.count;

                RectF rect(x-dx/2.0f, y-dy/2.0f, dx, dy);

                path.AddRectangle(rect);

                Matrix matrix;

                matrix.Translate(x, y);
                matrix.Rotate(rotate);
                matrix.Translate(-x, -y);

                path.Transform(&matrix);
            }
            break;

            case dtText:
            {
                // Draw text in a rectangle bounded by x1, y1, x2, y2:
                REAL x = rgPoints[0].X;
                REAL y = rgPoints[0].Y;
                REAL scale = (rgLineInfo[i].x3+rgLineInfo[i].y3) / 200.0f;
                REAL rotate = (timercount / 3.0f) + (rgLineInfo[i].x2 + rgLineInfo[i].y2) * 1.8f;

                rotate += (index * 360.0f) / currentSettings.count;

                path.AddPath(&textPath, FALSE);

                Matrix matrix;

                matrix.Translate(x, y);
                matrix.Rotate(rotate);
                matrix.Scale(scale, scale);

                path.Transform(&matrix);
            }
            break;
        }

        for(int k=0;k<currentSettings.rotations;k++)
        {
            Matrix rotation;

            rotation.Translate(width * 50.0f, height * 50.0f);
            rotation.Rotate((currentSettings.theta * timercount) + (k * 360.0f) / currentSettings.rotations);
            rotation.Translate(width * -50.0f, height * -50.0f);

            path.Transform(&rotation);

            rotation.Invert();

            if (currentSettings.filled)
                gr->FillPath(&brush, &path);
            else
                gr->DrawPath(&pen, &path);

            path.GetBounds(&bounds);

            if ((k == 0) && (i == 0))
            {
                rectBounds.left   = bounds.X;
                rectBounds.right  = bounds.X + bounds.Width;
                rectBounds.top    = bounds.Y;
                rectBounds.bottom = bounds.Y + bounds.Height;
            }
            else
            {
                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);
            }

            if (currentSettings.reflectVertical)
            {
                Matrix matrix;

                matrix.Translate(0.0f, height * 100.0f);
                matrix.Scale(1.0f, -1.0f);

                path.Transform(&matrix);

                if (currentSettings.filled)
                    gr->FillPath(&brush, &path);
                else
                    gr->DrawPath(&pen, &path);

                path.GetBounds(&bounds);

                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);

                matrix.Invert();

                path.Transform(&matrix);
            }

            if (currentSettings.reflectHorizontal)
            {
                Matrix matrix;

                matrix.Translate(width*100.0f, 0.0f);
                matrix.Scale(-1.0f, 1.0f);

                path.Transform(&matrix);

                if (currentSettings.filled)
                    gr->FillPath(&brush, &path);
                else
                    gr->DrawPath(&pen, &path);

                path.GetBounds(&bounds);

                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);

                matrix.Invert();

                path.Transform(&matrix);
            }

            if (currentSettings.reflectDiagonal)
            {
                Matrix matrix;

                matrix.Translate(width*100.0f, height*100.0f);
                matrix.Scale(-1.0f, -1.0f);

                path.Transform(&matrix);

                if (currentSettings.filled)
                    gr->FillPath(&brush, &path);
                else
                    gr->DrawPath(&pen, &path);

                path.GetBounds(&bounds);

                rectBounds.left   = min(bounds.X, rectBounds.left);
                rectBounds.top    = min(bounds.Y, rectBounds.top);
                rectBounds.right  = max(bounds.X + bounds.Width, rectBounds.right);
                rectBounds.bottom = max(bounds.Y + bounds.Height, rectBounds.bottom);

                matrix.Invert();

                path.Transform(&matrix);
            }

            path.Transform(&rotation);
        }

        if (!suspend)
        {
            rgLineInfo[i].x1 += rgLineInfo[i].dx1;
            rgLineInfo[i].y1 += rgLineInfo[i].dy1;
            rgLineInfo[i].x2 += rgLineInfo[i].dx2;
            rgLineInfo[i].y2 += rgLineInfo[i].dy2;
            rgLineInfo[i].x3 += rgLineInfo[i].dx3;
            rgLineInfo[i].y3 += rgLineInfo[i].dy3;
            rgLineInfo[i].r  += rgLineInfo[i].dr;
            rgLineInfo[i].g  += rgLineInfo[i].dg;
            rgLineInfo[i].b  += rgLineInfo[i].db;

            if (rgLineInfo[i].x1 < 5.0 || rgLineInfo[i].x1 > 95.0)
            {
                rgLineInfo[i].dx1 = -rgLineInfo[i].dx1;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].y1 < 5.0 || rgLineInfo[i].y1 > 95.0)
            {
                rgLineInfo[i].dy1 = -rgLineInfo[i].dy1;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].x2 < 5.0 || rgLineInfo[i].x2 > 95.0)
            {
                rgLineInfo[i].dx2 = -rgLineInfo[i].dx2;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].y2 < 5.0 || rgLineInfo[i].y2 > 95.0)
            {
                rgLineInfo[i].dy2 = -rgLineInfo[i].dy2;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].x3 < 5.0 || rgLineInfo[i].x3 > 95.0)
            {
                rgLineInfo[i].dx3 = -rgLineInfo[i].dx3;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].y3 < 5.0 || rgLineInfo[i].y3 > 95.0)
            {
                rgLineInfo[i].dy3 = -rgLineInfo[i].dy3;
                fHitWall = TRUE;
            }

            if (rgLineInfo[i].r < 5.0 || rgLineInfo[i].r > 95.0)
                rgLineInfo[i].dr = -rgLineInfo[i].dr;

            if (rgLineInfo[i].g < 5.0 || rgLineInfo[i].g > 95.0)
                rgLineInfo[i].dg = -rgLineInfo[i].dg;

            if (rgLineInfo[i].b < 5.0 || rgLineInfo[i].b > 95.0)
                rgLineInfo[i].db = -rgLineInfo[i].db;
        }
    }

    if (lpRectBounds)
    {
        *lpRectBounds = rectBounds;
    }

    delete gr;
}

LRESULT PaintWnd(HWND hWnd, HDC hDC)
{
    HBRUSH hBrush, hBrushOld;
    HPEN hPen, hPenOld;
    RECT rectClient;
    RECT rectDraw;
    
    hBrush    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    hPen      = (HPEN)GetStockObject(BLACK_PEN);

    hBrushOld = (HBRUSH)SelectObject(hDC, hBrush);
    hPenOld   = (HPEN)SelectObject(hDC, hPen);

    GetClientRect(hWnd, &rectClient);

    int width  = rectClient.right - rectClient.left;
    int height = rectClient.bottom - rectClient.top;

    // Setup the drawing rectangle relative to the client (inset 5 pixels)
    rectDraw.left   = 0;
    rectDraw.top    = 0;
    rectDraw.right  = (rectClient.right - rectClient.left);
    rectDraw.bottom = (rectClient.bottom - rectClient.top);

    // Now draw within this rectangle with GDI+ ...
    if (currentSettings.clearScreen)
    {
        // Render everything to an offscreen buffer instead of
        // directly to the display surface...
        HDC hdcOffscreen = NULL;
        int width, height;
        RECT rectOffscreen;

        width = rectDraw.right - rectDraw.left;
        height = rectDraw.bottom - rectDraw.top;

        rectOffscreen.left   = 0;
        rectOffscreen.top    = 0;
        rectOffscreen.right  = width;
        rectOffscreen.bottom = height;

        hdcOffscreen = GetOffscreen(hDC, width, height);

        if (hdcOffscreen)
        {
            if (!currentSettings.leaveTrails)
            {
                PatBlt(hdcOffscreen, 0, 0, width, height, BLACKNESS);
            }

            DrawGraphics(hWnd, hdcOffscreen, &rectOffscreen, NULL);

            StretchBlt(
                hDC,
                rectDraw.left,
                rectDraw.top,
                width,
                height,
                hdcOffscreen,
                0,
                0,
                width,
                height,
                SRCCOPY);
        }

        ReleaseDC(hWnd, hDC);
    }

    SelectObject(hDC, hBrushOld);
    SelectObject(hDC, hPenOld);

    return 0;
}

static RECT rectLast = {0, 0, 0, 0};

#ifdef STANDALONE_DEBUG

int cmpi(char *s1, char *s2)
{
    int result = 0;

    if (s1 && s2)
    {
        while((*s1 == *s2) && *s1)
        {
            s1++;
            s2++;
        }

        if (*s1 && *s2)
            result = *s1 - *s2;
        else
            result = *(s1-1) - *(s2-1);
    }

    return result;
}

void ParseCommandLine(LPSTR lpCmdLine)
{
    if (!cmpi(lpCmdLine,"/s") ||
        !cmpi(lpCmdLine,"-s") ||
        !cmpi(lpCmdLine,"s"))
    {
        screensaver = TRUE;
    }

    if (!cmpi(lpCmdLine,"/c") ||
        !cmpi(lpCmdLine,"-c") || 
        !cmpi(lpCmdLine,"c"))
    {
        // Run config with current window as parent.
        showconfig = TRUE;
        screensaver = TRUE;
    }

    // In-Place preview
    if (!cmpi(lpCmdLine, "/p") ||
        !cmpi(lpCmdLine, "-p") ||
        !cmpi(lpCmdLine, "p"))
    {
        char *p = lpCmdLine;
        int handle = 0;

        while(*p)
        {
            switch(*p)
            {
                case '0' :
                case '1' :
                case '2' :
                case '3' :
                case '4' :
                case '5' :
                case '6' :
                case '7' :
                case '8' :
                case '9' :
                    handle *= 10;
                    handle += *p-'0';
                break;
            }

            p++;
        }

        screensaver = TRUE;
        silent = TRUE;
        hwndParent = (HWND)handle;
    }

    if (!cmpi(lpCmdLine,"/t") ||
        !cmpi(lpCmdLine,"-t") ||
        !cmpi(lpCmdLine,"t"))
    {
        screensaver = FALSE;
    }
}

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    MSG msg;
    HACCEL hAccelTable;

    // Parse the command line...
    ParseCommandLine(lpCmdLine);

    if (!gGdiplusInitHelper.IsValid())
        return 0;

    srand(GetTickCount());

    randomizelocations();
    randomizecolors(-1);

    // Initialize global strings
    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadString(hInstance, IDC_TRIALPHA, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow)) 
    {
        return FALSE;
    }

    hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_TRIALPHA);

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    FreeOffscreen();

    return (int)msg.wParam;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEX wcex;

    wcex.cbSize = sizeof(WNDCLASSEX); 

    wcex.style            = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc      = (WNDPROC)WndProc;
    wcex.cbClsExtra       = 0;
    wcex.cbWndExtra       = 0;
    wcex.hInstance        = hInstance;
    wcex.hIcon            = LoadIcon(hInstance, (LPCTSTR)IDI_TRIALPHA);

    if (screensaver)
        wcex.hCursor      = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_NULL));
    else
        wcex.hCursor      = LoadCursor(NULL, IDC_ARROW);

    wcex.hbrBackground    = (HBRUSH)NULL;

    if (screensaver)
        wcex.lpszMenuName = (LPCSTR)NULL;
    else
        wcex.lpszMenuName = (LPCSTR)IDC_TRIALPHA;

    wcex.lpszClassName    = szWindowClass;
    wcex.hIconSm          = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

    return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT rectDesktop;
    RECT rectWnd;

    HWND hWndDesktop = GetDesktopWindow();

    hMainInstance = hInstance; // Store instance handle in our global variable

    if (screensaver)
    {
        if (silent)
        {
            GetWindowRect(hwndParent, &rectWnd);
        }
        else
        {
            rectWnd.left   = 0;
            rectWnd.top    = 0;
            rectWnd.right  = GetSystemMetrics(SM_CXSCREEN);
            rectWnd.bottom = GetSystemMetrics(SM_CYSCREEN);
        }

        ghwndMain = CreateWindowEx(
            WS_EX_TOPMOST,
            szWindowClass,
            NULL,
            WS_POPUP,
            rectWnd.left, rectWnd.top,
            rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top,
            NULL,
            NULL,
            hInstance,
            NULL);
    }
    else
    {
        GetWindowRect(hWndDesktop, &rectDesktop);

        rectWnd = rectDesktop;

        rectWnd.top += 100;
        rectWnd.left += 100;
        rectWnd.right -= 100;
        rectWnd.bottom -= 100;

        ghwndMain = CreateWindow(
            szWindowClass,
            szTitle,
            WS_OVERLAPPEDWINDOW,
            rectWnd.left, rectWnd.top,
            rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top,
            NULL,
            NULL,
            hInstance,
            NULL);
    }

    if (!ghwndMain)
    {
        return FALSE;
    }

    if (!showconfig)
    {
        ShowWindow(ghwndMain, nCmdShow);
        UpdateWindow(ghwndMain);
    }

    timerID = SetTimer(ghwndMain, 1, 10, NULL);

    return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND    - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY    - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message) 
    {
        case WM_WINDOWPOSCHANGED:
        {
            timercount = 0;
            ClearOffscreen();
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
        }
        break;

        case WM_LBUTTONDOWN:
        {
            timercount = 0;
            currentSettings.leaveTrails = !currentSettings.leaveTrails;
            ClearOffscreen();
        }
        break;

        case WM_RBUTTONDOWN:
        {
            randomizecolors(-1);
        }
        break;

        case WM_TIMER:
        {
            if (!suspend)
            {
                if (timercount >= currentSettings.lifetime && currentSettings.leaveTrails)
                {
                    if ((timercount - currentSettings.lifetime) > currentSettings.delay)
                    {
                        timercount = 0;
                        InvalidateRect(hWnd, NULL, TRUE);
                        randomizelocations();
                        randomizecolors(-1);
                        ClearOffscreen();
                    }
                }
                else
                {
                    // Render everything to an offscreen buffer instead of
                    // directly to the display surface...
                    HDC hdcOffscreen = NULL;
                    int width, height;

                    HDC hDC = GetDC(hWnd);
                    RECT rectClient;
                    RECT rectOffscreen;

                    GetClientRect(hWnd, &rectClient);

                    width = rectClient.right - rectClient.left;
                    height = rectClient.bottom - rectClient.top;

                    rectOffscreen.left   = 0;
                    rectOffscreen.top    = 0;
                    rectOffscreen.right  = width;
                    rectOffscreen.bottom = height;

                    hdcOffscreen = GetOffscreen(hDC, width, height);

                    if (hdcOffscreen)
                    {
                        RECT rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            PatBlt(hdcOffscreen, 0, 0, width, height, BLACKNESS);
                        }

                        DrawGraphics(hWnd, hdcOffscreen, &rectOffscreen, &rectBounds);

                        RECT rectBlt = rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            rectBlt.left   = min(rectBlt.left,   rectLast.left);
                            rectBlt.top    = min(rectBlt.top,    rectLast.top);
                            rectBlt.right  = max(rectBlt.right,  rectLast.right);
                            rectBlt.bottom = max(rectBlt.bottom, rectLast.bottom);
                        }

                        StretchBlt(
                            hDC,
                            rectClient.left + rectBlt.left,
                            rectClient.top + rectBlt.top,
                            rectBlt.right - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            hdcOffscreen,
                            rectBlt.left,
                            rectBlt.top,
                            rectBlt.right  - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            SRCCOPY);

                        rectLast = rectBounds;
                    }

                    ReleaseDC(hWnd, hDC);
                }

                timercount++;
            }
        }
        break;

        case WM_COMMAND:
        {
            int wmId, wmEvent;

            wmId    = LOWORD(wParam);
            wmEvent = HIWORD(wParam);

            // Parse the menu selections:
            switch (wmId)
            {
                case IDM_SETTINGS:
                {
                    suspend = TRUE;
                    if (DialogBox(hMainInstance, (LPCTSTR)DLG_SCRNSAVECONFIGURE, hWnd, (DLGPROC)ScreenSaverConfigureDialog) == IDOK)
                    {
                        timercount = 0;
                        randomizelocations();
                        randomizecolors(-1);
                        ClearOffscreen();
                    }

                    InvalidateRect(hWnd, NULL, TRUE);
                    suspend = FALSE;

                    if (showconfig)
                        PostQuitMessage(0);
                }
                break;

                case IDM_ABOUT:
                    DialogBox(hMainInstance, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
                break;

                case IDM_EXIT:
                    DestroyWindow(hWnd);
                break;

                default:
                    lresult = DefWindowProc(hWnd, message, wParam, lParam);
                break;
            }
        }
        break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(hWnd, &ps);

            lresult = PaintWnd(hWnd, hdc);

            EndPaint(hWnd, &ps);

            return lresult;
        }
        break;

        case WM_DESTROY:
        {
            PostQuitMessage(0);
        }
        break;

        default:
            lresult = DefWindowProc(hWnd, message, wParam, lParam);
   }

   return lresult;
}

// Message handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
            lresult = TRUE;
        break;

        case WM_COMMAND:
        {
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
            {
                EndDialog(hDlg, LOWORD(wParam));
                lresult = TRUE;
            }
        }
        break;
    }

    return lresult;
}

#else // !STANDALONE_DEBUG

BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{ 
    return TRUE; 
} 

LRESULT WINAPI ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    LRESULT lresult = 0;

    switch(message) 
    { 
        case WM_CREATE:
        {
            if (!gGdiplusInitHelper.IsValid())
                return 0;

            srand(GetTickCount());

            LoadState();

            randomizelocations();
            randomizecolors(-1);

            timerID = SetTimer(hwnd, 1, 10, NULL);
        }
        break;

        case WM_TIMER:
        {
            if (!suspend)
            {
                if (timercount >= currentSettings.lifetime && currentSettings.leaveTrails)
                {
                    if ((timercount - currentSettings.lifetime) > currentSettings.delay)
                    {
                        timercount = 0;
                        InvalidateRect(hwnd, NULL, TRUE);
                        randomizelocations();
                        randomizecolors(-1);
                        ClearOffscreen();
                    }
                }
                else
                {
                    // Render everything to an offscreen buffer instead of
                    // directly to the display surface...
                    HDC hdcOffscreen = NULL;
                    int width, height;

                    HDC hDC = GetDC(hwnd);
                    RECT rectClient;
                    RECT rectOffscreen;

                    GetClientRect(hwnd, &rectClient);

                    width = rectClient.right - rectClient.left;
                    height = rectClient.bottom - rectClient.top;

                    rectOffscreen.left   = 0;
                    rectOffscreen.top    = 0;
                    rectOffscreen.right  = width;
                    rectOffscreen.bottom = height;

                    hdcOffscreen = GetOffscreen(hDC, width, height);

                    if (hdcOffscreen)
                    {
                        RECT rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            PatBlt(hdcOffscreen, 0, 0, width, height, BLACKNESS);
                        }

                        DrawGraphics(hwnd, hdcOffscreen, &rectOffscreen, &rectBounds);

                        RECT rectBlt = rectBounds;

                        if (!currentSettings.leaveTrails)
                        {
                            rectBlt.left   = min(rectBlt.left,   rectLast.left);
                            rectBlt.top    = min(rectBlt.top,    rectLast.top);
                            rectBlt.right  = max(rectBlt.right,  rectLast.right);
                            rectBlt.bottom = max(rectBlt.bottom, rectLast.bottom);
                        }

                        StretchBlt(
                            hDC,
                            rectClient.left + rectBlt.left,
                            rectClient.top + rectBlt.top,
                            rectBlt.right - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            hdcOffscreen,
                            rectBlt.left,
                            rectBlt.top,
                            rectBlt.right  - rectBlt.left,
                            rectBlt.bottom - rectBlt.top,
                            SRCCOPY);

                        rectLast = rectBounds;
                    }

                    ReleaseDC(hwnd, hDC);
                }

                timercount++;
            }
        }
        break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(hwnd, &ps);

            lresult = PaintWnd(hwnd, hdc);

            EndPaint(hwnd, &ps);

            return lresult;
        }
        break;

        case WM_DESTROY:
            KillTimer(hwnd, timerID);
            FreeOffscreen();
        break;
    }

    lresult = DefScreenSaverProc(hwnd, message, wParam, lParam);

    return lresult;
}

#endif // !STANDALONE_DEBUG

// Message handler for settings dlg
BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lresult = 0;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            LoadState();

            // Set the current values into the dialog controls...
            dialogSettings = currentSettings;

            SetDlgItemInt(hDlg, IDC_COUNT,    dialogSettings.count, FALSE);
            SetDlgItemInt(hDlg, IDC_ALPHA,    dialogSettings.alpha, FALSE);
            SetDlgItemInt(hDlg, IDC_LIFETIME, dialogSettings.lifetime, FALSE);
            SetDlgItemInt(hDlg, IDC_DELAY,    dialogSettings.delay, FALSE);
            SetDlgItemInt(hDlg, IDC_ROTATIONS,dialogSettings.rotations, FALSE);
            SetDlgItemInt(hDlg, IDC_THETA,    (int)(dialogSettings.theta * 10), TRUE);

            for(int i=dtTriangles;i<=dtText;i++)
            {
                char szShape[256];

                LoadString(hMainInstance, IDS_SHAPE_BASE + i, szShape, sizeof(szShape));
                SendMessage(GetDlgItem(hDlg, IDC_SHAPE), CB_ADDSTRING, 0, (LPARAM)szShape);
            }

            SendMessage(GetDlgItem(hDlg, IDC_SHAPE), CB_SETCURSEL, (WPARAM)dialogSettings.shape, 0);

            SendMessage(GetDlgItem(hDlg, IDC_LEAVETRAILS), BM_SETCHECK, dialogSettings.leaveTrails ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_CLEARSCREEN), BM_SETCHECK, dialogSettings.clearScreen ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_REFLECTVERT), BM_SETCHECK, dialogSettings.reflectVertical ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_REFLECTHORZ), BM_SETCHECK, dialogSettings.reflectHorizontal ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_REFLECTDIAG), BM_SETCHECK, dialogSettings.reflectDiagonal ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_OSCILLATE),   BM_SETCHECK, dialogSettings.oscillate ? BST_CHECKED : BST_UNCHECKED, 0);
            SendMessage(GetDlgItem(hDlg, IDC_FILLED),      BM_SETCHECK, dialogSettings.filled ? BST_CHECKED : BST_UNCHECKED, 0);


            lresult = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_COUNT :
                    dialogSettings.count = GetDlgItemInt(hDlg, IDC_COUNT, NULL, FALSE);

                    if (dialogSettings.count > MAX_LINES)
                        dialogSettings.count = MAX_LINES;
                break;

                case IDC_ALPHA :
                    dialogSettings.alpha = (BYTE)GetDlgItemInt(hDlg, IDC_ALPHA, NULL, FALSE);
                break;

                case IDC_LIFETIME:
                    dialogSettings.lifetime = GetDlgItemInt(hDlg, IDC_LIFETIME, NULL, FALSE);
                    if (dialogSettings.lifetime > 10000)
                        dialogSettings.lifetime = 10000;
                break;

                case IDC_DELAY :
                    dialogSettings.delay = GetDlgItemInt(hDlg, IDC_DELAY, NULL, FALSE);
                    if (dialogSettings.delay > 10000)
                        dialogSettings.delay = 10000;
                break;

                case IDC_ROTATIONS :
                    dialogSettings.rotations = GetDlgItemInt(hDlg, IDC_ROTATIONS, NULL, FALSE);
                    if (dialogSettings.rotations > 90)
                        dialogSettings.rotations = 90;
                break;

                case IDC_THETA :
                    dialogSettings.theta = GetDlgItemInt(hDlg, IDC_THETA, NULL, FALSE) / 10.0f;
                    while(dialogSettings.theta >= 360.0f)
                        dialogSettings.theta -= 360.0f;

                    while(dialogSettings.theta <= -360.0f)
                        dialogSettings.theta += 360.0f;
                break;

                case IDC_LEAVETRAILS :
                    dialogSettings.leaveTrails = SendMessage(GetDlgItem(hDlg, IDC_LEAVETRAILS), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_CLEARSCREEN :
                    dialogSettings.clearScreen = SendMessage(GetDlgItem(hDlg, IDC_CLEARSCREEN), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_REFLECTVERT :
                    dialogSettings.reflectVertical = SendMessage(GetDlgItem(hDlg, IDC_REFLECTVERT), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_REFLECTHORZ :
                    dialogSettings.reflectHorizontal = SendMessage(GetDlgItem(hDlg, IDC_REFLECTHORZ), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_REFLECTDIAG :
                    dialogSettings.reflectDiagonal = SendMessage(GetDlgItem(hDlg, IDC_REFLECTDIAG), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_OSCILLATE :
                    dialogSettings.oscillate = SendMessage(GetDlgItem(hDlg, IDC_OSCILLATE), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_FILLED :
                    dialogSettings.filled = SendMessage(GetDlgItem(hDlg, IDC_FILLED), BM_GETCHECK, 0, 0) == BST_CHECKED;
                break;

                case IDC_SHAPE:
                    dialogSettings.shape = (SHAPE)SendMessage(GetDlgItem(hDlg, IDC_SHAPE), CB_GETCURSEL, 0, 0);
                break;

                case IDOK:
                {
                    // copy the dialog control values to our currentSettings:
                    currentSettings = dialogSettings;
                    SaveState();
                }
                // break; - fall through so the dialog closes!

                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                    lresult = TRUE;
                }
                break;
            }
        }
        break;
    }

    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\demos\trialpha\trialpha.h ===
#pragma once

#include <windows.h>
#include <objbase.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <scrnsave.h>

#include "gdiplus.h"

using namespace Gdiplus;

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\common.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Common code
*
* Abstract:
*
*   This is code which is used by multiple modules of GDI+.
*
* Created:
*
*   4/27/1999 agodfrey
*
\**************************************************************************/

#ifndef _COMMON_HPP
#define _COMMON_HPP

/* Define offsetof macro */
#ifndef offsetof
#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif
#endif

// ddraw.h is needed by globals.hpp

#include <ddraw.h>
#include <d3d.h>
#include <dciman.h>

// Internally, we want to initialize FilterType values using
// InterpolationModeDefaultInternal so that the FilterType
// is set to a on-aliased enumeration value.

#define InterpolationModeDefaultInternal InterpolationModeBilinear

/*class GpPointD;
class GpPoint;
class GpRect;
class GpColor64;
class GpString;
class GpGlyphPos;
*/

class GpFontFamily;
class GpFontCollection;
class GpInstalledFontCollection;
class GpCacheFaceRealizationList;
class GpPrivateFontCollection;

class GpMatrix;
class GpGraphics;
class GpSurface;
class GpRegion;
class GpPen;
class GpBrush;
class GpFaceRealization;
class GpFontFace;
class GpFont;
class GpTextItem;
class GpStringFormat;
class GpPath;
class GpImage;
class GpBitmap;
class GpGraphics;

class GpRegionData;
class GpLineTexture;

struct DrawGlyphData;

typedef RectF GpRectF;
typedef SizeF GpSizeF;
typedef PointF GpPointF;
typedef Status GpStatus;
typedef FillMode GpFillMode;
typedef CompositingMode GpCompositingMode;
typedef CompositingQuality GpCompositingQuality;
typedef TextRenderingHint GpTextRenderingHint;
typedef Unit GpUnit;
typedef Unit GpPageUnit;
typedef CoordinateSpace GpCoordinateSpace;
typedef WrapMode GpWrapMode;
typedef HatchStyle GpHatchStyle;
typedef DashStyle GpDashStyle;
typedef LineCap GpLineCap;
typedef DashCap GpDashCap;
typedef LineJoin GpLineJoin;
typedef PathPointType GpPathPointType;
typedef CombineMode GpCombineMode;
typedef ImageType GpImageType;
typedef PenType GpPenType;
typedef PenAlignment GpPenAlignment;
typedef StringFormatFlags      GpStringFormatflags;
typedef StringAlignment        GpStringAlignment;
typedef StringTrimming         GpStringTrimming;
typedef StringDigitSubstitute  GpStringDigitSubstitute;
typedef StringTrimming         GpStringTrimming;
typedef HotkeyPrefix           GpHotkeyPrefix;
typedef BrushType GpBrushType;
typedef EnumerationType DpEnumerationType;
typedef MatrixOrder GpMatrixOrder;
typedef FlushIntention GpFlushIntention;

// This structure should coincide with PathData, the difference being we
// don't do automatic deletion of PathData contents.
class GpPathData
{
public:
    INT Count;
    PointF* Points;
    BYTE* Types;
};

inline
REAL VectorLength(const PointF & point)
{
    return (REAL)sqrt(point.X * point.X + point.Y * point.Y);
}

#include "..\entry\intmap.hpp"
#include"..\text\inc\unidir.hxx"
#include "..\text\imager\DigitSubstitution.hpp"
#include "globals.hpp"
#include "dynarray.hpp"
#include "matrix.hpp"
#include "engine.hpp"
#include "rasterizer.hpp"
#include "stackbuffer.hpp"
#include "monitors.hpp"
#include "testcontrol.hpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\dynarrayimpl.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This class contains definitions of functions which can't (or shouldn't)
*   be inlined. We use a separate implementation class because this allows us
*   to avoid the code bloat template classes produce; every instance of the
*   DynArray template can use the same version of each out-of-line member.
*
*   The DynArray data members need to be declared here, because they are
*   used by DynArrayImpl.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*
*  8/16/2000 bhouse
*  + Changed to growth mechanics to be exponential
*
\**************************************************************************/

// 
// There are some routines for sorting and positional add and delete that
// are being removed. This #define is to make that process easier. When 
// DynSortArray is removed, the code protected by this #define should be
// removed too.
//
// See pathselfintersectremover.hpp for the definition of DynSortArray.
//

#define USE_OBSOLETE_DYNSORTARRAY


class DynArrayImpl
{
protected:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - initial number of elements

    DynArrayImpl(void *initialAllocation, UINT allocSize, UINT count = 0);
    
    // Shrink the buffer so that it is just big enough for the items
    // the dynamic array holds.

    VOID ShrinkToSize(UINT eltSize);
    
    // Add space for new elements (if necessary). Does not update Count.
    // eltSize           - size of each element
    // newElements       - number of new elements
    // exactSize         - no exponential growth

    GpStatus Grow(UINT eltSize, UINT newElements, BOOL exactSize = FALSE);

    // Add new, uninitialized elements, and return a pointer to them.
    // eltSize     - size of each element
    // newElements - number of new elements

    void *AddMultiple(UINT eltSize, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // eltSize     - size of each element
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    
    GpStatus AddMultiple(UINT eltSize, UINT newElements, const void *newData);
    
    // Detach the data buffer from the dynamic array.
    // Allocates the buffer to detatch if it is the initial allocation.

    GpStatus DetachData(UINT eltSize, void **buffer);
    
    
    #ifdef USE_OBSOLETE_DYNSORTARRAY
    
    // 
    // NOTE: These functions are used only by DynSortArray and it is being
    // discontinued. Do not use. These routines have horrible performance
    // characteristics.
    // 
    
    
    // Add new, uninitialized elements, and return a pointer to them.
    // All data from index on is shift towards the end of the array to make room.
    // index       - index from which to insert the new elements.
    // eltSize     - size of each element
    // newElements - number of new elements
    // CAUTION! could cause a big performance hit if the array is large!

    void *AddMultipleAt(UINT eltSize, UINT index, UINT newElements);
    
    // Add new elements, initializing them with the given data.
    // All data from index on is shift towards the end of the array to make room.
    // eltSize     - size of each element
    // index       - index from which to insert the new elements.
    // newElements - number of new elements
    // newData     - the data to be copied into the new space
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus AddMultipleAt(UINT eltSize, UINT index, UINT newElements, const void *newData);

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(UINT eltSize, UINT index, UINT numElements);
    
    #endif
    
    // Capacity, StepSize, AllocSize and Count are all measured in elements,
    // not bytes.

    enum {
        kMinCapacityGrowth = 16,
        kMaxCapacityGrowth = 8092
    };

    void *DataBuffer;
    void *InitialAllocation;
    UINT AllocSize;
    UINT Capacity;
    UINT Count;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\dynarray.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   dynarray.hpp
*
* Abstract:
*
*   Dynamic array template classes. See DynamicArrays.doc in the Specs 
*   directory.
*
*   DynArray is a container which keeps its contents in a contiguous buffer,
*   reallocating memory as necessary. It accepts an optional initial
*   allocation, which is used unless it is too small to accommodate the
*   elements.
*
*   DynArrayIA is a cosmetic wrapper which encapsulates the intial allocation,
*   allowing the dynamic array to be treated like a normal class.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   02/26/1999 agodfrey
*       Revamped it to use an implementation class (DynArrayImpl). 
*       Now the template part of it can compile to nothing, or be small enough
*       to inline efficiently, so that using the template with many different
*       types doesn't cause code bloat.
*
*       Also, I added a version (DynArrayIA) which makes using an initial
*       allocation much easier.
*
*   06/10/1999 t-wehunt
*       Added AddXXAt, DeletXXAt, and InsertAt methods.
*
* Notes:
*
*   12/02/1998 davidx
*   Changes from the previous version in gdiplus prototype:
*   + getData: Use &dynarr[index] instead.
*   + increaseCount: Use addMultiple instead (2nd variation).
*   + replace: Use dynarr[index] = newItem.
*   + attachData: Use dynarr.replaceWith(dynarr2).
*   + constructor: No longer takes initialCapacity, use ReserveSpace instead
*   + new constructor: Takes a stack array which is used for buffer (faster).
*
*   02/26/1999 agodfrey
*   + Use the 'implementation class' to avoid code bloat for out-of-line
*     functions.
*   + GetCapacity: Unused, not useful - removed.
*   + Reset: Added 'shrink' flag (default true). If it's false, Reset sets the
*     count to zero but doesn't free the memory. This is preferable to
*     SetCount(0).
*   + Made ShrinkToSize() reuse the initial allocation. This also makes the
*     growing and shrinking logic simpler - 'no initial allocation' is treated
*     like an initial allocation of size zero (at memory location 'NULL').
*
*   06/10/1999 t-wehunt
*   + AddXXAt, DeletXXAt, and InsertAt methods shift elements around in memory 
*     to keep the array contiguous.
*   + CAUTION: This could cause a big performance hit if the array is very large. 
*     Use care when calling these methods!!!
*
\**************************************************************************/

#ifndef _DYNARRAY_HPP
#define _DYNARRAY_HPP

#include "dynArrayImpl.hpp"

template <class T> class DynArray : public DynArrayImpl
{
public:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - the initial count
    //

    DynArray(
        T *initialAllocation, 
        UINT allocSize,
        UINT count = 0):
        DynArrayImpl(initialAllocation, allocSize, count)
    {
    }

    // Constructor (no initial allocation)
    //

    DynArray(void):
        DynArrayImpl(NULL, 0, 0)
    {
    }

    // Destructor

    ~DynArray()
    {
        if (DataBuffer != InitialAllocation)
        {
           GpFree(DataBuffer);
        }
    }

    // Return a pointer to the array data
    //   NOTE: We intentionally avoid type conversion operator here
    //   to reduce the chances for confusion.

    T *GetDataBuffer() const
    {
        return static_cast<T *>(DataBuffer);
    }

    // Index operator

    T &operator[](INT n) const
    {
        ASSERT(n >= 0 && (UINT)n < Count);
        return GetDataBuffer()[n];
    }

    // First/last element of the array

    T &First() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[0];
    }

    T &Last() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[Count-1];
    }
        
    // Number of elements in the array

    INT GetCount() const
    {
        return Count;
    }

    UINT GetCapacity() const
    {
        return Capacity;
    }

    // Reset the dynamic array to empty state
    //
    // shrink - If FALSE, don't free the current buffer.

    VOID Reset(BOOL shrink=TRUE)
    {
        Count = 0;
        if (shrink)
        {
            ShrinkToSize();
        }
    }

    // Shrink the dynamic array capacity to be just big enough
    // for the number of existing elements in the array.
    //
    // This reuses the initial allocation if possible.

    VOID ShrinkToSize()
    {
        DynArrayImpl::ShrinkToSize(sizeof(T));
    }

    // Add a new element to the end of the dynamic array

    GpStatus Add(const T& newItem)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), 1, &newItem);
    }
    
    // Add multiple items to the end of the dynamic array

    GpStatus AddMultiple(const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), n, newItems);
    }
    
    // Another variation of addMultiple above
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) reserve the space for additional elements
    //  (2) increase the Count by the number of additional elements
    //  (3) return a pointer to the first new elements

    T *AddMultiple(INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultiple(sizeof(T), n));
    }

    // Detach the data buffer from the dynamic array
    // Allocates the buffer to detatch if it is the initial allocation.

    GpStatus DetachData(T **buffer)
    {
        return DynArrayImpl::DetachData(sizeof(T), (void **)buffer);
    }
    
    // Detatch the buffer from another array, and set this array
    // to point to it. NOTE: This modifies the other array.

    GpStatus ReplaceWith(DynArray<T> *dynarr)
    {
        if (DataBuffer != InitialAllocation)
        {
            GpFree(DataBuffer);
        }

        Count = dynarr->Count;
        Capacity = dynarr->Capacity;
        
        GpStatus status = dynarr->DetachData((T**)(&DataBuffer));
        
        if(Ok != status)
        {
            Count = 0;
            Capacity = 0;
        }
        
        return status;
    }
    
    // More dangerous interface:
    //
    // These functions are alternatives to Add/AddMultiple.
    // They can be used to reduce overhead, but you have to know what
    // you're doing.
    //
    // AdjustCount/SetCount - modify the count directly, without growing or
    //   shrinking the array.
    // ReserveSpace - grow the buffer, but don't actually add any elements to
    //   the array.
    
    VOID AdjustCount(UINT addElts)
    {
        Count += addElts;
        
        ASSERT(Count <= Capacity);
    }

    VOID SetCount(UINT count)
    {
        ASSERT(Count <= Capacity);
        
        Count = count;
    }
    
    GpStatus ReserveSpace(UINT newElements, BOOL exact = FALSE)
    {
        return Grow(sizeof(T), newElements, exact);
    }
};

// DynArrayIA: A version of DynArray which encapsulates the initial allocation.
//
// For example:
//
// DynArrayIA<MyType, 10> array;
//
// This declares a DynArray of MyType objects, with an initial allocation of
// 10 elements. Such a declaration can be used on the stack or in another
// object.

template <class T, int ALLOCSIZE> class DynArrayIA : public DynArray<T>
{
public:

    // Constructor
    //

    DynArrayIA(void):
        DynArray<T>(InitialAllocationBuffer, ALLOCSIZE, 0)
    {
    }

    DynArrayIA(T * initialAllocationBuffer, UINT initialAllocationSize, UINT count = 0) :
        DynArray<T>(initialAllocationBuffer, initialAllocationSize, count)
    {
    }

private:
    T InitialAllocationBuffer[ALLOCSIZE];
};

#endif // !_DYNARRAY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\dynarrayimpl.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation class
*
* Abstract:
*
*   This is the class which implements the dynamic array. 
*   It is used by the wrapper template classes DynArray and DynArrayIA.
*
* Created:
*
*  2/18/1999 agodfrey
*
*  6/10/1999 t-wehunt 
*  + Added AddMultipleAt and DeleteMultipleAt methods.
*  + Fixed a problem in ShrinkToSize that caused elements to potentially
*    be lost.
*  8/16/2000 bhouse
*  + Changed cpacity growth to be exponential
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   DynArrayImpl constructor
*
* Arguments:
*
*   initialAllocation - initial allocation, or NULL
*   allocSize         - size of the initial allocation
*   count             - initial count
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/

DynArrayImpl::DynArrayImpl(
    void *initialAllocation, 
    UINT allocSize,
    UINT count
    )
{
    ASSERT((initialAllocation != NULL) || (allocSize == 0));
    ASSERT(count <= allocSize);

    DataBuffer = InitialAllocation = initialAllocation;
    Capacity = AllocSize = allocSize;
    Count = count;
}

/**************************************************************************\
*
* Function Description:
*
*   Shrink the buffer so that it is just big enough for the items
*   the dynamic array holds.
*
* Arguments:
*
*   eltSize - size of each array element
*
* Return Value:
*
*   NONE
*
* Created:
*
*   1/18/1999 agodfrey
*     Added code to reuse the initial allocation.
*
\**************************************************************************/

VOID DynArrayImpl::ShrinkToSize(UINT eltSize) 
{
    ASSERT(Count <= Capacity);

    if (DataBuffer == InitialAllocation)
    {
        // Since we're shrinking, we know that the current data buffer
        // is big enough.
        
        return;
    }

    if (Count <= AllocSize)
    {
        // The buffer will fit into the initial allocation.

        GpMemcpy(InitialAllocation,DataBuffer,Count * eltSize);
        GpFree(DataBuffer);
        DataBuffer = InitialAllocation;
        Capacity = AllocSize;
        return;
    }

    // If we get here, we know that DataBuffer points to dynamic memory,
    // and that Count != 0.
    //
    // The second point is important because GpRealloc(x, 0) returns
    // a pointer to a valid zero-length buffer.

    void *newbuf = GpRealloc(DataBuffer, Count*eltSize);

    if (!newbuf)
    {
        // GpRealloc failed. Keep the current allocation
        
        WARNING(("ShrinkToSize: GpRealloc failed"));
        return;
    }

    DataBuffer = newbuf;
    Capacity = Count;
}

/**************************************************************************\
*
* Function Description:
*
*   Add space for new elements (if necessary). Does not update Count.
*
* Arguments:
*
*   eltSize     - size of each array element
*   newElements - the number of new elements
*   exactSize   - no exponential growth, just add required amount
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   1/18/1999 agodfrey
*
\**************************************************************************/

GpStatus DynArrayImpl::Grow(UINT eltSize, UINT newElements, BOOL exactSize)
{
    UINT newCount = Count + newElements;

    if (newCount <= Capacity)
    {
        return Ok;
    }

    UINT capacityIncrement = newCount - Capacity;
    
    if (!exactSize)
    {
        capacityIncrement = max(capacityIncrement,
                                min(max(Capacity, kMinCapacityGrowth),
                                    kMaxCapacityGrowth));
    };

    UINT newCapacity = Capacity + capacityIncrement;

    void *newbuf;

    if (DataBuffer == InitialAllocation)
    {
        // Do our first dynamic allocation

        newbuf = GpMalloc(newCapacity*eltSize);

        if (newbuf && Count)
        {
            GpMemcpy(newbuf, DataBuffer, Count*eltSize);
        }
    }
    else
    {
        // Reallocate memory

        newbuf = GpRealloc(DataBuffer, newCapacity*eltSize);
    }

    if (!newbuf)
    {
        WARNING(("Grow: alloc failed"));

        // Aid in tracking down memory failure cases not handled properly
#if 0
        ASSERT(FALSE);
#endif
        return OutOfMemory;
    }

    Capacity = newCapacity;
    DataBuffer = newbuf;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Detach the data buffer from the dynamic array.
*   Allocates the buffer to detatch if it is the initial allocation.
*
* Return Value:
*
*   The data buffer
*
* Created:
*
*   2/25/1999 agodfrey
*   12/19/2000 asecchia - handle initial allocation by returning a copy.
*
\**************************************************************************/
    
GpStatus DynArrayImpl::DetachData(UINT eltSize, void **buffer)
{
    void *data = DataBuffer;

    // Copy the initial allocation if there is one - 
    // otherwise we simply use the DataBuffer.
    
    if (DataBuffer == InitialAllocation)
    {
        data = GpMalloc(Capacity*eltSize);

        if (NULL == data)
        {
            *buffer = NULL;
            return OutOfMemory;
        }
        
        if (Count)
        {
            GpMemcpy(data, DataBuffer, Count*eltSize);
        }
    }

    DataBuffer = NULL;
    Count = Capacity = 0;

    *buffer = data;
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultiple(UINT eltSize, UINT newElements)
{
    ASSERT(newElements>0);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    void *newSpace = static_cast<BYTE *>(DataBuffer) + Count * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*
* Arguments:
*
*   eltSize     - size of each element
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/25/1999 agodfrey
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultiple(
    UINT eltSize, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + Count * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}



#ifdef USE_OBSOLETE_DYNSORTARRAY

/**************************************************************************\
*
* Function Description:
*
*   Add new, uninitialized elements, and return a pointer to them.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*
* Return Value:
* 
*   Pointer to the new space, or NULL on failure
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
void *DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements
    )
{
    ASSERT(newElements>0 && index<=Count);

    if (Grow(eltSize, newElements) != Ok)
        return NULL;

    // NOTE: assume T is a shallow data type, i.e.
    //  it doesn't contain nested references.
    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        (Count - index) * eltSize
        );

    void *newSpace = static_cast<BYTE *>(DataBuffer) + index * eltSize;
    Count += newElements;

    return newSpace;
}

/**************************************************************************\
*
* Function Description:
*
*   Add new elements, initializing them with the given data.
*   All data from index on is shift towards the end of the array to make room.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to insert the new elements.
*   newElements - number of new elements
*   newData     - the data to be copied into the new space
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    
GpStatus DynArrayImpl::AddMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT newElements, 
    const void *newData
    )
{
    ASSERT(newElements>0 && index<=Count);

    GpStatus status = Grow(eltSize, newElements);
     
    if (status == Ok)
    {
        // NOTE: assume T is a shallow data type, i.e.
        //  it doesn't contain nested references.

        GpMemmove(
            static_cast<BYTE *>(DataBuffer) + (index + newElements) * eltSize,
            static_cast<BYTE *>(DataBuffer) + index * eltSize,
            (Count - index) * eltSize
            );
        GpMemcpy(
            static_cast<BYTE *>(DataBuffer) + index * eltSize, 
            newData, 
            newElements * eltSize
            );
        Count += newElements;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Deletes multiple items from the array starting at the index'th position.
*   CAUTION! could cause a big performance hit if the array is large!
*
* Arguments:
*
*   eltSize     - size of each element
*   index       - index from which to delete the elements.
*   numElements - number of elements to delete
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/10/1999 t-wehunt
*
\**************************************************************************/
    

GpStatus DynArrayImpl::DeleteMultipleAt(
    UINT eltSize, 
    UINT index, 
    UINT numElements
    )
{
    ASSERT(numElements>0 && (index+numElements)<=Count);

    GpMemmove(
        static_cast<BYTE *>(DataBuffer) + index * eltSize,
        static_cast<BYTE *>(DataBuffer) + (index + numElements) * eltSize,
        (Count - (index + numElements)) * eltSize
        );
    Count -= numElements;

    ShrinkToSize(eltSize);

    return Ok;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\engine.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains miscellaneous engine helper functions.
*
* Revision History:
*
*   12/13/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   The kernel32.dll function InterlockedCompareExchange does not exist 
*   on Win95, so we use this one instead when running on that platform.  
*   Unfortunately, Win95 can run on 386 machines, which don't have the
*   cmpxchg instruction, so we have to roll it ourselves.
*
* Arguments:
*
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

LONG
WINAPI
InterlockedCompareExchangeWin95(
    IN OUT PLONG destination,
    IN LONG exchange,
    IN LONG comperand
    )
{
#if defined(_X86_)

    _asm cli            // Disable interrupts to guarantee atomicity

    LONG initialValue = *destination;
    
    if (initialValue == comperand)
    {
        *destination = exchange;
    }

    _asm sti            // Re-enable interrupts

    return(initialValue);

#else

    return(0);

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   The InterlockedIncrement function in Win95 returns only a positive
*   result if the value is positive, but not necessarily the resulting value.
*   This differs from WinNT semantics which always returns the incremented
*   value.
*
* Arguments:
*
*   [IN] lpAddend - Pointer to value to increment
*
* Return Value:
*
*   NONE
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

LONG
WINAPI
InterlockedIncrementWin95(
    IN LPLONG lpAddend
    )
{
#if defined(_X86_)

    _asm cli            // Disable interrupts to guarantee atomicity

    *lpAddend += 1;
    
    LONG value = *lpAddend;

    _asm sti            // Re-enable interrupts

    return(value);

#else

    return(0);

#endif
}

/**************************************************************************\
*
* Function Description:
*
*   The InterlockedDecrement function in Win95 returns only a positive
*   result if the value is positive, but not necessarily the resulting value.
*   This differs from WinNT semantics which always returns the incremented
*   value.
*
* Arguments:
*
*   [IN] lpAddend - Pointer to value to increment
*
* Return Value:
*
*   NONE
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

LONG
WINAPI
InterlockedDecrementWin95(
    IN LPLONG lpAddend
    )
{
#if defined(_X86_)

    _asm cli            // Disable interrupts to guarantee atomicity

    *lpAddend -= 1;
    
    LONG value = *lpAddend;

    _asm sti            // Re-enable interrupts

    return(value);

#else

    return(0);

#endif
}

/**************************************************************************\
*
* Function Description:
*   
*   Given a DC to an enhanced metafile, this function determines whether
*   the DC is actually a printer DC or a true metafile DC.  
*
*   After spending a day pouring over the Win9x GDI code, I could find
*   no fool-proof API accessible method of determining whether a metafile 
*   DC is a printer DC or not.  We could potentially crack the DC handle 
*   to get the DCTYPE structure and look at flPrinting to see if 
*   PR_EMF_SPOOL is set, but the various flavors of Win9x have different 
*   DCTYPE structures (including Far East differences).
*
*   The only exploitable difference is the fact that Win9x doesn't allow 
*   escapes down to the associated device for true metafile DCs, but does 
*   for metafile print DCs.  We check for the support of QUERYESCSUPPORT, 
*   which according to the DDK all drivers are required to support, but
*   theoretically there are some that might not (so this method isn't
*   foolproof).
*
*   Note that this function works only on Win9x, as on NT escapes are
*   allowed down to the printer at record time even for true metafile DCs.
*
* Arguments:
*
*   [IN] hdc - Handle to an EMF DC
*
* Return Value:
*
*   TRUE - The DC is guaranteed to be a printer DC
*   FALSE - The DC is 99% likely to be a true metafile (there's about a 1%
*           change that the DC is a true printer DC
*
* History:
*
*   10/6/1999 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
APIENTRY
GdiIsMetaPrintDCWin9x(
    HDC hdc
    )
{
    BOOL isPrint = FALSE;

    // Our check won't work for OBJ_DC or OBJ_MEMDC types:

    ASSERT(GetDCType(hdc) == OBJ_ENHMETADC);
    
    // Make sure we don't get any false positives from metafiles associated
    // with a display:
    
    int deviceCaps = GetDeviceCaps(hdc, TECHNOLOGY);
    if ((deviceCaps == DT_RASPRINTER) || (deviceCaps == DT_PLOTTER))
    {
        // Check to see if QUERYESCSUPPORT is supported by the driver
        // (if it is, that tells us everything we need to know!)
    
        DWORD queryEscape = QUERYESCSUPPORT;
        isPrint = (ExtEscape(hdc, 
                             QUERYESCSUPPORT, 
                             sizeof(queryEscape), 
                             (CHAR*) &queryEscape, 
                             0, 
                             NULL) > 0);
        if (!isPrint)
        {
            // SETCOPYCOUNT is the most commonly supported printer escape, 
            // which we check in addition to QUERYESCSUPPORT because I'm a 
            // little paranoid that drivers might forget to say they support 
            // the QUERYESCSUPPORT function when called by QUERYESCSUPPORT.
        
            DWORD setCopyCount = SETCOPYCOUNT;
            isPrint = (ExtEscape(hdc,
                                 QUERYESCSUPPORT,
                                 sizeof(setCopyCount),
                                 (CHAR*) &setCopyCount,
                                 0,
                                 NULL) > 0);
        }
    }
    
    return(isPrint);
}

//
// 32 bit ANSI X3.66 CRC checksum table - polynomial 0xedb88320
//
// Copyright (C) 1986 Gary S. Brown.  You may use this program, or
// code or tables extracted from it, as desired without restriction.
//

static const UINT32 Crc32Table[] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};


/**************************************************************************\
*
* Function Description:
*
*   Compute the 32-bit CRC checksum on a buffer of data
*
* Arguments:
*
*   buf - Points to the data buffer to be checksumed
*   size - Size of the data buffer, in bytes
*   checksum - Initial checksum value
*
* Return Value:
*
*   Resulting checksum value
*
\**************************************************************************/

UINT32
Crc32(
    IN const VOID*  buf,
    IN UINT         size,
    IN UINT32       checksum
    )
{
    const BYTE* p = (const BYTE*) buf;

    while (size--)
    {
        checksum = Crc32Table[(checksum ^ *p++) & 0xff] ^ (checksum >> 8);
    }

    return checksum;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert a floating-point coordinate bounds to an integer pixel bounds.
*
*   Since we're converting bounds from float to int, we have to make sure
*   that the bounds are still encompassing of the object.  So we have to take
*   the floor of the left and top values, even though the rasterizer takes
*   the ceiling.  The reason for this is that the rasterizer uses 28.4 fixed
*   point.  So a number like 52.001 converts to 52.0 in 28.4, so the ceiling
*   in the rasterizer would be 52, whereas the ceiling of the original number
*   is 53, but if we return 53 here, then we would be incorrect.  It's better
*   to be too big here sometimes and still have all-encompassing bounds, than
*   to be right most of the time, but have too small a bounds the other times.
*
*   The other caveat is that we need to calculate the bounds assuming the
*   result will be used for antialiasing (the bounds antialiased fills are
*   bigger than the bounds for aliased fills).
*
*   NOTE: This conversion implicitly assumes that a fill is done on the
*         figure vertices.  Nominal-width lines REQUIRE the caller to
*         have increased all the dimensions by 1/2 before calling!
*
* Arguments:
*
* Return Value:
*
*   Ok for success, ValueOverflow if the boundsF would overflow the
*   integer size. rect is always initialized - for ValueOverflow, its
*   set to zero.
*
\**************************************************************************/

#define INT_BOUNDS_MAX   1073741823
#define INT_BOUNDS_MIN  -1073741824

GpStatus
BoundsFToRect(
    const GpRectF *boundsF,
    GpRect *rect                // Lower-right exclusive
    )
{
    // If you're wondering what the "+1" is doing below, read the 
    // above comment and remember that we're calculating the  bounds 
    // assuming antialiased fills.
    //
    // The tightest bound for an antialiased fill would truly be:
    //
    //      [round(min - epsilon), round(max + epsilon) + 1)
    //
    // Where 'epsilon' is the epsilon for rounding to our internal
    // 28.4 rasterization precision, which is 1/32 of a pixel,
    // and [left, right) is exclusive of the right pixel.
    //
    // We skip the 'round' and 'epsilon' business by using 'floor'
    // and 'ceiling':

    GpStatus status = Ok;

    if(boundsF->X >= INT_BOUNDS_MIN && boundsF->X <= INT_BOUNDS_MAX)
    {
        rect->X = GpFloor(boundsF->X);
    }
    else
    {
        status = ValueOverflow;
    }
    
    if((status == Ok) && (boundsF->Y >= INT_BOUNDS_MIN) &&
        (boundsF->Y <= INT_BOUNDS_MAX))
    {
        rect->Y = GpFloor(boundsF->Y);
    }
    else
    {
        status = ValueOverflow;
    }
    
    if((status == Ok) && (boundsF->Width >= 0) &&
        (boundsF->Width <= INT_BOUNDS_MAX))
    {
        rect->Width  = GpCeiling(boundsF->GetRight())  - rect->X + 1;
    }
    else
    {
        status = ValueOverflow;
    }
    
    if((status == Ok) && (boundsF->Height >= 0) &&
        (boundsF->Height <= INT_BOUNDS_MAX))
    {
        rect->Height = GpCeiling(boundsF->GetBottom()) - rect->Y + 1;
    }
    else
    {
        status = ValueOverflow;
    }
    
    if(status != Ok)
    {
        // Make sure the rect is always initialized.
        // Also this makes the ASSERT below valid.
        
        rect->Width = 0;
        rect->Height = 0;
        rect->X = 0;
        rect->Y = 0;
    }

    // Don't forget that 'Width' and 'Height' are effectively 
    // lower-right exclusive.  That is, if (x, y) are (1, 1) and
    // (width, height) are (2, 2), then the object is 2 pixels by
    // 2 pixels in size, and does not touch any pixels in column
    // 3 or row 3:

    ASSERT((rect->Width >= 0) && (rect->Height >= 0));

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   This seems to be some sort of unit conversion function.  
*
* Arguments:
*
* Return Value:
*
\**************************************************************************/

REAL GetDeviceWidth(REAL width, GpUnit unit, REAL dpi)
{
    // UnitWorld cannot be used for this method.
    // UnitDisplay is device-dependent and cannot be used as a pen width unit

    ASSERT((unit != UnitWorld) && (unit != UnitDisplay));

    REAL deviceWidth = width;

    switch (unit)
    {
      case UnitPoint:       // Each unit represents 1/72 inch.
        deviceWidth *= dpi / 72.0f;
        break;

      case UnitInch:        // Each unit represents 1 inch.
        deviceWidth *= dpi;
        break;

      case UnitDocument:    // Each unit represents 1/300 inch.
        deviceWidth *= dpi / 300.0f;
        break;

      case UnitMillimeter:  // Each unit represents 1 millimeter.
                            // One Millimeter is 0.03937 inches
                            // One Inch is 25.4 millimeters
        deviceWidth *= dpi / 25.4f;
        break;

      default:              // this should not happen, if it does assume
                            // UnitPixel.
        ASSERT(0);
        // FALLTHRU

      case UnitPixel:       // Each unit represents one device pixel.
        break;

    }

    return deviceWidth;
}

/**************************************************************************\
*
* Function Description:
*
*   Given two coordinates defining opposite corners of a rectangle, this
*   routine transforms the rectangle according to the specified transform
*   and computes the resulting integer bounds, taking into account the
*   possibility of non-scaling transforms.
*
*   Note that it operates entirely in floating point, and as such takes
*   no account of rasterization rules, pen width, etc.
*
* Arguments:
*
*   [IN] matrix - Transform to be applied (or NULL)
*   [IN] x0, y0, x1, y1 - 2 points defining the bounds (they don't have
*                         to be well ordered)
*   [OUT] bounds - Resulting (apparently floating point) bounds
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
TransformBounds(
    const GpMatrix *matrix,
    REAL left,
    REAL top,
    REAL right,
    REAL bottom,
    GpRectF *bounds
    )
{
    // Note that we don't have to order the points before the transform
    // (in part because the transform may flip the points anyways):

    if (matrix && !matrix->IsIdentity())
    {
        GpPointF vertex[4];

        vertex[0].X = left;
        vertex[0].Y = top;
        vertex[1].X = right;
        vertex[1].Y = bottom;

        // If the transform is a simple scaling transform, life is a little
        // easier:

        if (matrix->IsTranslateScale())
        {
            matrix->Transform(vertex, 2);
    
            // We arrange the code here a little so that we don't take a
            // jump on the common case, where the transform is non-flipping:

            left = vertex[1].X;
            right = vertex[0].X;
            if (left > right)
            {
                left = vertex[0].X;
                right = vertex[1].X;
            }
    
            top = vertex[1].Y;
            bottom = vertex[0].Y;
            if (top > bottom)
            {
                top = vertex[0].Y;
                bottom = vertex[1].Y;
            }
        }
        else
        {
            // Ugh, the result is not a rectangle in device space (it might be
            // a parallelogram, for example).  Consequently, we have to look at
            // the bounds of all the vertices:

            vertex[2].X = left;
            vertex[2].Y = bottom;
            vertex[3].X = right;
            vertex[3].Y = top;

            matrix->Transform(vertex, 4);

            left = right = vertex[0].X;
            top = bottom = vertex[0].Y;

            for (INT i = 1; i < 4; i++)
            {
                if (left > vertex[i].X)
                    left = vertex[i].X;

                if (right < vertex[i].X)
                    right = vertex[i].X;

                if (top > vertex[i].Y)
                    top = vertex[i].Y;

                if (bottom < vertex[i].Y)
                    bottom = vertex[i].Y;
            }

            ASSERT((left <= right) && (top <= bottom));
        }
    }
    
    bounds->X      = left;
    bounds->Y      = top;
    
    //!!! Watch out for underflow.

    if(right - left > CPLX_EPSILON)
        bounds->Width  = right - left;
    else
        bounds->Width = 0;
    if(bottom - top > CPLX_EPSILON)
        bounds->Height = bottom - top;
    else
        bounds->Height = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Checks if the current semaphore object is locked.  This is moved into
*   a C++ file because of the dependency on globals.hpp.  On Win9x this
*   function always returns TRUE.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL 
*
* History:
*
*   1/27/1999 ericvan    Moved from engine.hpp
*
\**************************************************************************/

BOOL 
GpSemaphore::IsLocked(
        VOID
        )
{ 
    ASSERT(Initialized);
    if (Globals::IsNt)
    {
        return(((RTL_CRITICAL_SECTION*) &CriticalSection)->LockCount != -1); 
    }
    else
    {
        return TRUE;    // No way to do this on Win95
    }
}
    
/**************************************************************************\
*
* Function Description:
*
*   Checks if the current semaphore object is locked by current thread.  
*   This is moved into a C++ file because of the dependency on globals.hpp.
*   On Win9x this function always returns TRUE.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL 
*
* History:
*
*   1/27/1999 ericvan    Moved from engine.hpp
*
\**************************************************************************/

BOOL
GpSemaphore::IsLockedByCurrentThread(
        VOID
        )
{
    ASSERT(Initialized);
    if (Globals::IsNt) 
    {
        return(((RTL_CRITICAL_SECTION*) &CriticalSection)->OwningThread ==
               (HANDLE) (DWORD_PTR) GetCurrentThreadId());
    }
    else
    {
        return TRUE;    // No way to do this on Win9x
    }
}

   
/**************************************************************************\
*
* Function Description:
*
*   Uninitializes the critical section object.  
*   This is moved into a C++ file because of the dependency on globals.hpp.
*   On Win9x this function skips the IsLocked() check.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL 
*
* History:
*
*   1/27/1999 ericvan    Moved from engine.hpp
*
\**************************************************************************/

VOID 
GpSemaphore::Uninitialize(
    VOID
    )
{
#ifdef DBG
    if (Globals::IsNt) 
    {
        ASSERTMSG(!IsLocked(), ("Semaphore can't be locked when deleted"));
    }
#endif

    if (Initialized)
    {
        DeleteCriticalSection(&CriticalSection); 
        Initialized = FALSE;
    }
}

#if defined(_X86_)

/**************************************************************************\
*
* Function Description:
*
*   This is a common function used by GetObjectTypeInternal and GetDCType.
*   It should not be called elsewhere.
*
*   NOTE: On Windows 9x, two GDI objects may have the same handle value, if
*         one is OBJ_METAFILE and the other is anything else. In this case
*         of colliding object handles, GetObjectType will always return
*         OBJ_METAFILE. This function temporarily invalidates the metafile
*         so GetObjectType will skip that check and return the type of the
*         colliding object. If no colliding object is found, or if OBJ_*DC
*         is returned, this function returns 0. OBJ_*DC objects may not be
*         "present" (available in 16-bit) sometimes, and so the wrong value
*         can be returned since GetObjectType does not make such a DC
*         "present".
*
* Arguments:
*
*   [IN] handle - GDI object handle (not when expecting OBJ_METAFILE)
*
* Return Value:
*
*   GDI object type identifier on success or 0 on failure
*
* History:
*
*   01/25/2001 johnstep
*       Created it.
*
\**************************************************************************/

static
DWORD
GetObjectTypeWin9x(
    IN HGDIOBJ handle
    )
{
    // Disable interrupts around this code to prevent other threads from
    // attempting to access this object, in case this is a collision, which
    // means we must modify the metafile object directly via the selector.

    __asm cli

    DWORD type = GetObjectType(handle);

    // If there are 2 objects with the same handle, one being an OBJ_METAFILE
    // and the other not, OBJ_METAFILE is always returned. Since the caller
    // is not interested in a metafile, do a hack here to skip the metafile
    // check and find the type of the colliding object, if any.

    if (type == OBJ_METAFILE)
    {
        // The first WORD of a metafile must contain 1 or 2, and we wouldn't
        // be here if it didn't. This macro will toggle a higher bit in the
        // first word to defeat the metafile check, allowing us to proceed to
        // the normal object check.

        #define XOR_METAFILE_BIT(selector)\
            __asm push gs\
            __asm mov gs, word ptr selector\
            __asm xor word ptr gs:[0], 8\
            __asm pop gs

        XOR_METAFILE_BIT(handle);

        type = GetObjectType(handle);

        XOR_METAFILE_BIT(handle);
    }

    // Make sure to reenable interrupts before returning.

    __asm sti

    return type;
}

#endif

/**************************************************************************\
*
* Function Description:
*
*   This is a workaround for a serious bug in Windows 9x GetObjectType
*   implementation. This function correctly returns the object type for the
*   given handle, unless it's an OBJ_*DC or OBJ_METAFILE. For those types,
*   it shouldn't crash, but it will intermittently return 0 instead of the
*   correct type.
*
*   For OBJ_*DC types, use GetDCType. You can validate an OBJ_METAFILE with
*   IsValidMetaFile, but you need to expect it to be a metafile handle. If
*   you don't know which of the 3 classes your handle falls into, you'll
*   need to expand on these workaround functions.
*
*   NOTE: On Windows 9x, two GDI objects may have the same handle value, if
*         one is OBJ_METAFILE and the other is anything else. In this case
*         of colliding object handles, GetObjectType will always return
*         OBJ_METAFILE. This function temporarily invalidates the metafile
*         so GetObjectType will skip that check and return the type of the
*         colliding object. If no colliding object is found, or if OBJ_*DC
*         is returned, this function returns 0. OBJ_*DC objects may not be
*         "present" (available in 16-bit) sometimes, and so the wrong value
*         can be returned since GetObjectType does not make such a DC
*         "present".
*
* Arguments:
*
*   [IN] handle - GDI object handle (not to verify for OBJ_METAFILE)
*
* Return Value:
*
*   GDI object type identifier on success or 0 on failure
*
* History:
*
*   01/25/2001 johnstep
*       Created it.
*
\**************************************************************************/

DWORD
GetObjectTypeInternal(
    IN HGDIOBJ handle
    )
{
#if defined(_X86_)
    if (!Globals::IsNt)
    {
        DWORD type = GetObjectTypeWin9x(handle);

        switch (type)
        {
            case OBJ_DC:
            case OBJ_METADC:
            case OBJ_MEMDC:
            case OBJ_ENHMETADC:
                type = 0;
                break;
        }
            
        return type;
    }
#else
    // We assume that this issue only matters on x86.

    ASSERT(Globals::IsNt);
#endif

    return GetObjectType(handle);
}

/**************************************************************************\
*
* Function Description:
*
*   GetObjectType on Win9x is unreliable when dealing with DC objects. It
*   is possible to get a bogus value (or potentially even lead to
*   instability in GDI) when a DC is not "present", which means its 16-bit
*   data has been "swapped out" into 32-bit. Most GDI functions handle
*   this, but GetObjectType does not. We call GetPixel to attempt to make
*   the DC present before calling GetObjectType.
*
* Arguments:
*
*   [IN] hdc - DC handle
*
* Return Value:
*
*   DC object type identifier on success or 0 on failure
*
* History:
*
*   01/31/2001 johnstep
*       Created it.
*
\**************************************************************************/

DWORD
GetDCType(
    IN HDC hdc
    )
{
#if defined(_X86_)
    if (!Globals::IsNt)
    {
        // Force the DC present here before attempting to inquire the type.

        GetPixel(hdc, 0, 0);

        DWORD type = GetObjectTypeWin9x(hdc);

        switch (type)
        {
            case OBJ_DC:
            case OBJ_METADC:
            case OBJ_MEMDC:
            case OBJ_ENHMETADC:
                break;

            default:
                // We got an unexpected object type, so return 0 to indicate
                // failure.

                type = 0;
        }

        return type;
    }
#else
    // We assume that this issue only matters on x86.

    ASSERT(Globals::IsNt);
#endif

    return GetObjectType(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\guid.c ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   GUID definition file
*
*   GUIDs that are needed by GDI+ components are defined here.
*
* Revision History:
*
*   10/22/1999 bhouse
*       Created it.
*
\**************************************************************************/

// NOTE: Since we use C++ precompiled headers this C file will not use
//       the precompiled header allowing us to define INITGUID and include
//       directdraw and d3d headers to generate the GUIDs defined by these
//       headers.

#define INITGUID
#include <ddraw.h>
#include <d3d.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\globals.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   This is where all the global variables in the Globals namespace
*   are actually declared.
*
* Created:
*
*   11/25/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Data Description:
*
*   This namespace contains all (most?) of the GDI+ global state.
*   See the header file 'globals.hpp' for comments.
*
*   Note that all global data are initialized automatically to zero.
*
* History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

namespace Globals
{
    BOOL IsNt;
    BOOL RuntimeInitialized;

    GpPath *    PathLookAside;
    GpMatrix *  MatrixLookAside;
    GpPen *     PenLookAside;

    BOOL IsWin95;
    BOOL VersionInfoInitialized;
    OSVERSIONINFOA OsVer;
    UINT ACP;
    GpDevice *DesktopDevice;
    GpDeviceList *DeviceList;
    DpBitmap *DesktopSurface;
    DpDriver *DesktopDriver;
    DpDriver *EngineDriver;
    DpDriver *GdiDriver;
    DpDriver *D3DDriver;
    DpDriver *InfoDriver;
    DpDriver *MetaDriver;
    BOOL DirectDrawInitialized;
    BOOL DirectDrawInitAttempted;
    HINSTANCE DdrawHandle;
    IDirectDraw7 *DirectDraw;
    IDirect3D7 *Direct3D;
    DIRECTDRAWCREATEEXFUNCTION DirectDrawCreateExFunction;
    DIRECTDRAWENUMERATEEXFUNCTION DirectDrawEnumerateExFunction;
    EXTTEXTOUTFUNCTION ExtTextOutFunction;
    GETDDRAWSURFACEFROMDCFUNCTION GetDdrawSurfaceFromDcFunction;
    INTERLOCKEDCOMPAREEXCHANGEFUNCTION InterlockedCompareExchangeFunction;
    GDIISMETAPRINTDCFUNCTION GdiIsMetaPrintDCFunction;
    GETMONITORINFOFUNCTION GetMonitorInfoFunction;
    ENUMDISPLAYMONITORSFUNCTION EnumDisplayMonitorsFunction;
    ENUMDISPLAYDEVICESFUNCTION EnumDisplayDevicesFunction;
    HMODULE DcimanHandle;
    DCICREATEPRIMARYFUNCTION DciCreatePrimaryFunction;
    DCIDESTROYFUNCTION DciDestroyFunction;
    DCIBEGINACCESSFUNCTION DciBeginAccessFunction;
    DCIENDACCESSFUNCTION DciEndAccessFunction;
    GETWINDOWINFOFUNCTION GetWindowInfoFunction;
    GETANCESTORFUNCTION GetAncestorFunction;
    SETWINEVENTHOOKFUNCTION SetWinEventHookFunction;
    UNHOOKWINEVENTFUNCTION UnhookWinEventFunction;
    HWINEVENTHOOK WinEventHandle;
    CAPTURESTACKBACKTRACEFUNCTION CaptureStackBackTraceFunction;
    BOOL IsMoveSizeActive;
    HRGN CachedGdiRegion;
    HDC DesktopIc;
    REAL DesktopDpiX;
    REAL DesktopDpiY;
    GpInstalledFontCollection *FontCollection;
    GpCacheFaceRealizationList *FontCacheLastRecentlyUsedList;
    GpFontLink *FontLinkTable = NULL;
    GpFontFamily **SurrogateFontsTable = (GpFontFamily **) -1;
    WCHAR *SystemDirW;
    CHAR *SystemDirA;
    WCHAR *FontsDirW;
    CHAR *FontsDirA;
    USHORT LanguageID;
    HWND HwndNotify;
    HANDLE ThreadNotify = NULL;
    DWORD ThreadId;
    ATOM WindowClassAtom;
    BOOL InitializeOleSuccess;
    LONG_PTR LookAsideCount;
    BYTE* LookAsideBuffer;
    INT LookAsideBufferSize = 0x7FFFFFFF;
    UINT PaletteChangeCount = 1;
    COLORREF SystemColors[20];
    HINSTANCE WinspoolHandle;
    WINSPOOLGETPRINTERDRIVERFUNCTION GetPrinterDriverFunction;
    HANDLE hCachedPrinter;
    INT CachedPSLevel = -1;
    WCHAR *FontsKeyW = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
    CHAR  *FontsKeyA =  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Fonts";
    
    BOOL TextCriticalSectionInitialized = FALSE;
    CRITICAL_SECTION TextCriticalSection;
    TextRenderingHint CurrentSystemRenderingHint;

    HMODULE UniscribeDllModule;

    IntMap<BYTE> *NationalDigitCache;
    BOOL UserDigitSubstituteInvalid;
    BOOL CurrentSystemRenderingHintInvalid;

    BOOL IsTerminalServer = FALSE;
    
    // GillesK: See bug NTBUG9 #409304
    // We cannot use DCI on Mirror Drivers since that doesn't get remoted.
    BOOL IsMirrorDriverActive = FALSE;

    ULONG_PTR LibraryInitToken = 0;
    INT LibraryInitRefCount = 0;
    ULONG_PTR HiddenWindowOwnerToken = NotificationModuleTokenNobody;
    ULONG_PTR NotificationInitToken = 0;
    HANDLE ThreadQuitEvent = NULL;

    BOOL g_fAccessibilityPresent = FALSE;
    UINT g_nAccessibilityMessage = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\matrix.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Matrix.cpp
*
* Abstract:
*
*   Implementation of matrix class
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it. 
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Infer an affine transformation matrix
*   from a rectangle-to-rectangle mapping
*
* Arguments:
*
*   [IN] destRect - Specifies the destination rectangle
*   [IN] srcRect  - Specifies the source rectangle
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/10/1999 DCurtis
*
\**************************************************************************/

GpStatus
GpMatrix::InferAffineMatrix(
    const GpRectF &     destRect,
    const GpRectF &     srcRect
    )
{
    REAL    srcLeft    = srcRect.X;
    REAL    srcRight   = srcRect.GetRight();
    REAL    srcTop     = srcRect.Y;
    REAL    srcBottom  = srcRect.GetBottom();
    
    REAL    destLeft   = destRect.X;
    REAL    destRight  = destRect.GetRight();
    REAL    destTop    = destRect.Y;
    REAL    destBottom = destRect.GetBottom();

    if ((srcLeft == srcRight) || (srcTop == srcBottom))
    {
        return InvalidParameter;
    }

    M12 = 0;
    M21 = 0;
    M11 = (destRight - destLeft) / (srcRight - srcLeft);
    M22 = (destBottom - destTop) / (srcBottom - srcTop);
    Dx  = destRight  - (M11 * srcRight);
    Dy  = destBottom - (M22 * srcBottom);

    Complexity = ComputeComplexity();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Infer an affine transformation matrix
*   from a rectangle-to-parallelogram mapping
*
* Arguments:
*
*   [IN] rect - Specifies the source rectangle
*   [IN] destPoints - Specifies the destination parallelogram
*       The array must contain at least 3 points.
*       destPoints[0] <=> top-left corner of the source rectangle
*       destPoints[1] <=> top-right corner
*       destPoints[2] <=> bottom-left corner
*
* Return Value:
*
*   Status code (error when 3 points for the destination
*   parallelogram is colinear).
*
* Reference:
*
*   Digital Image Warping
*   by George Wolberg
*   pp. 50-51
*
\**************************************************************************/

GpStatus
GpMatrix::InferAffineMatrix(
    const GpPointF* destPoints,
    const GpRectF& srcRect
    )
{
    REAL x0, y0, x1, y1, x2, y2;
    REAL u0, v0, u1, v1, u2, v2;
    REAL d;

    x0 = destPoints[0].X;
    y0 = destPoints[0].Y;
    x1 = destPoints[1].X;
    y1 = destPoints[1].Y;
    x2 = destPoints[2].X;
    y2 = destPoints[2].Y;

    u0 = srcRect.X;
    v0 = srcRect.Y;
    u1 = u0 + srcRect.Width;
    v1 = v0;
    u2 = u0;
    v2 = v0 + srcRect.Height;

    d = u0*(v1-v2) - v0*(u1-u2) + (u1*v2-u2*v1);

    if (REALABS(d) < REAL_EPSILON)
    {
        WARNING(("Colinear points in inferAffineMatrix"));
        return InvalidParameter;
    }
    
    d = TOREAL(1.0) / d;

    REAL t0, t1, t2;

    t0 = v1-v2;
    t1 = v2-v0;
    t2 = v0-v1;
    M11 = d * (x0*t0 + x1*t1 + x2*t2);
    M12 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u2-u1;
    t1 = u0-u2;
    t2 = u1-u0;
    M21 = d * (x0*t0 + x1*t1 + x2*t2);
    M22 = d * (y0*t0 + y1*t1 + y2*t2);

    t0 = u1*v2-u2*v1;
    t1 = u2*v0-u0*v2;
    t2 = u2*v1-u1*v0;
    Dx  = d * (x0*t0 + x1*t1 + x2*t2);
    Dy  = d * (y0*t0 + y1*t1 + y2*t2);

    Complexity = ComputeComplexity();
    return Ok;
}

GpMatrix::GpMatrix(
    const GpPointF* destPoints,
    const GpRectF& srcRect
    )
{
    // !!!
    //  Should we throw an exception if inferAffineMatrix fails?

    SetValid(InferAffineMatrix(destPoints, srcRect) == Ok);
}

/**************************************************************************\
*
* Function Description:
* 
*   Invert the matrix (in place)
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code (error if the matrix is not invertible)
*
* Reference:
*
*   Digital Image Warping
*   by George Wolberg
*   pp. 52-53
*
\**************************************************************************/

GpStatus
GpMatrix::Invert()
{
    if(IsIdentity())
    {
        // Invert the identity matrix - this is easy.
        return Ok;
    }
    
    if (!IsInvertible())
    {
        WARNING(("Matrix is non-invertible"));
        return InvalidParameter;
    }

    REAL t11, t12, t21, t22, tx, ty;
    REAL d = (M11*M22 - M12*M21);
    
    d = TOREAL(1.0) / d;

    t11 = M22;
    t12 = -M12;
    t21 = -M21;
    t22 = M11;
    tx  = M21*Dy - M22*Dx;
    ty  = M12*Dx - M11*Dy;

    M11 = d*t11;
    M12 = d*t12;
    M21 = d*t21;
    M22 = d*t22;
    Dx  = d*tx;
    Dy  = d*ty;

    Complexity = ComputeComplexity();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a scale matrix to the current matrix, i.e.
*
*         | scaleX   0    0 |
*     m = |   0    scaleY 0 |
*         |   0      0    1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   scaleX - scale factor along x-axis
*   scaleY - scale factor along y-axis
*   order  - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Scale(
    REAL scaleX,
    REAL scaleY,
    GpMatrixOrder order
    )
{
    if (order == MatrixOrderPrepend)
    {
        M11 *= scaleX;
        M12 *= scaleX;
        M21 *= scaleY;
        M22 *= scaleY;
    }
    else // Append
    {
        M11 *= scaleX;
        M21 *= scaleX;
        M12 *= scaleY;
        M22 *= scaleY;
        Dx *= scaleX;
        Dy *= scaleY;
    }

    // Scaling can magnify the error of other components.
    // So it is safest to always recompute the complexity always.

    Complexity = ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a rotation matrix to the current matrix, i.e.
*
*         |  cos(angle) sin(angle) 0 |
*     m = | -sin(angle) cos(angle) 0 |
*         |      0           0     1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   angle - Specify the rotation angle
*   order - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#define PI                  3.1415926535897932384626433832795
#define DEGREES_TO_RADIANS  (PI / 180.0)

VOID
GpMatrix::Rotate(
    REAL angle,
    GpMatrixOrder order
    )
{
    REAL s, c;
    REAL t11, t12, t21, t22;

    angle *= (REAL)DEGREES_TO_RADIANS;

    s = REALSIN(angle);
    c = REALCOS(angle);

    if (order == MatrixOrderPrepend) 
    {
        t11 = c*M11 + s*M21;
        t12 = c*M12 + s*M22;
        t21 = c*M21 - s*M11;
        t22 = c*M22 - s*M12;
    } 
    else // Append
    {
        t11 = c*M11 - s*M12;
        t12 = s*M11 + c*M12;
        t21 = c*M21 - s*M22;
        t22 = s*M21 + c*M22;

        REAL tx, ty;
        tx = c*Dx - s*Dy;
        ty = s*Dx + c*Dy;
        Dx = tx;
        Dy = ty;
    }

    M11 = t11; 
    M12 = t12; 
    M21 = t21;
    M22 = t22;

    // Rotation is very complex; we choose to simply recalculate the
    // complexity:

    Complexity = ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a translation matrix to the current matrix, i.e.
*
*         |    1       0    0 |
*     m = |    0       1    0 |
*         | offsetX offsetY 1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   offsetX - offset along x-axis
*   offsetY - offset along y-axis
*   order  - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Translate(
    REAL offsetX,
    REAL offsetY,
    GpMatrixOrder order
    )
{
    if (order == MatrixOrderPrepend) 
    {
        Dx += (offsetX * M11) + (offsetY * M21);
        Dy += (offsetX * M12) + (offsetY * M22);
    }
    else // Append
    {
        Dx += offsetX;
        Dy += offsetY;
    }

    Complexity |= TranslationMask;
    AssertComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Prepend or append a shear matrix to the current matrix, i.e.
*
*         |   1    shearY 0 |
*     m = | shearX    1   0 |
*         |   0       0   1 |
*
*     matrix = m * matrix  // for prepend
*     matrix = matrix * m  // for append
*
* Arguments:
*
*   shearX - Amount to shear along x-axis
*   shearY - Amount to shear along y-axis
*   order  - prepend or append.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Shear(
    REAL shearX,
    REAL shearY,
    GpMatrixOrder order
    )
{
    REAL t;
    
    if (order == MatrixOrderPrepend) 
    {
        t = M11;
        M11 += shearY*M21;
        M21 += shearX*t;

        t = M12;
        M12 += shearY*M22;
        M22 += shearX*t;
    }
    else    // Append
    {
        t = M11;
        M11 += shearX*M12;
        M12 += shearY*t;

        t = M21;
        M21 += shearX*M22;
        M22 += shearY*t;

        t= Dx;
        Dx += shearX*Dy;
        Dy += shearY*t;
    }

    // Shear is very complex; we choose to simply recalculate the
    // complexity:

    Complexity = ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Multiply two matrices and place the result in the 3rd one:
*       m = m1 * m2
*
* Arguments:
*
*   m - Destination matrix
*   m1, m2 - Source matrices
*
* Return Value:
*
*   NONE
*
* Notes:
*
*   m can be the same matrix as m1 and/or m2.
*
\**************************************************************************/

VOID
GpMatrix::MultiplyMatrix(
    GpMatrix& m,
    const GpMatrix& m1,
    const GpMatrix& m2
    )
{
    REAL t11, t12, t21, t22, tx, ty;

    t11 = m1.M11 * m2.M11 + m1.M12 * m2.M21;
    t12 = m1.M11 * m2.M12 + m1.M12 * m2.M22;
    t21 = m1.M21 * m2.M11 + m1.M22 * m2.M21;
    t22 = m1.M21 * m2.M12 + m1.M22 * m2.M22;
    tx  = m1.Dx  * m2.M11 + m1.Dy  * m2.M21 + m2.Dx;
    ty  = m1.Dx  * m2.M12 + m1.Dy  * m2.M22 + m2.Dy;

    m.M11 = t11;
    m.M12 = t12;
    m.M21 = t21;
    m.M22 = t22;
    m.Dx  = tx;
    m.Dy  = ty;

    // Multiply can be very complex; we choose to simply recalculate the
    // complexity:

    m.Complexity = m.ComputeComplexity();
}

/**************************************************************************\
*
* Function Description:
*
*   Scale the entire matrix by the scale value.
*
*   +--         --+      +--       --+
*   | M11  M12  0 |      | Sx  0   0 |
*   | M21  M22  0 |  x   | 0   Sy  0 |   => dest matrix
*   | Dx   Dy   1 |      | 0   0   1 |
*   +--         --+      +--       --+
*
* Arguments:
*
*   [OUT] m          - destination matrix
*   [IN]  m1         - source matrix
*   [IN]  scaleX     - dest = source * scaleValue
*   [IN]  scaleY     - dest = source * scaleValue
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/1/1999 DCurtis
*
\**************************************************************************/
VOID 
GpMatrix::ScaleMatrix(
    GpMatrix&           m, 
    const GpMatrix&     m1, 
    REAL                scaleX,
    REAL                scaleY
    )
{
    // !!! some kind of epsilon checking maybe?
    if ((scaleX != 1) || (scaleY != 1))
    {
        m.M11 = scaleX * m1.M11;
        m.M12 = scaleY * m1.M12;
        m.M21 = scaleX * m1.M21;
        m.M22 = scaleY * m1.M22;
        m.Dx  = scaleX * m1.Dx;
        m.Dy  = scaleY * m1.Dy;

        //!!! Since the scaling can magnify the other component,
        // it is safer to recompute the complexity.

        m.Complexity = m.ComputeComplexity();
/*
        if(m1.IsTranslateScale())
        {
            m.Complexity = m1.Complexity | ScaleMask;
        }
        else
        {
            // Scaling a rotation by different scale factors in x and y
            // results in a shear. Instead of working out the correct 
            // optimized complexity, we just recompute - this is a rotation
            // or shear already anyway.
            m.Complexity = m.ComputeComplexity();
        }
        m.AssertComplexity();
*/
    }
    else
    {
        m = m1;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Query for special types of transformation matrices
*
* Arguments:
*
* Return Value:
*
*   MatrixRotate enum indicating type of rotation
*
\**************************************************************************/

MatrixRotate 
GpMatrix::GetRotation() const
{
    // Check for no rotate.
    
    if(IsTranslateScale())
    {
        return MatrixRotateBy0;
    }
    
    // Check for Rotate by 90 degrees
    
    if (REALABS(M12) < REAL_EPSILON &&
        REALABS(M21) < REAL_EPSILON &&
        (M11 < 0.0f) && (M22 < 0.0f) )
    {
        return MatrixRotateBy180;
    }
    else if (REALABS(M11) < REAL_EPSILON &&
             REALABS(M22) < REAL_EPSILON)
    {
        if (M12 > 0.0f) 
        {
            return MatrixRotateBy90;
        }
        else
        {
            return MatrixRotateBy270;
        }
    }

    return MatrixRotateByOther;
}

/**************************************************************************\
*
* Function Description:
*
*   Query for special types of transformation matrices.
*   This will return a RotateFlipType for the rotation. If the rotation
*   is Identity or an arbitrary non supported format, return value is
*   RotateNoneFlipNone
*
\**************************************************************************/

RotateFlipType GpMatrix::AnalyzeRotateFlip() const 
{
    // Early out the identity case because we have a flag for it in the matrix.
    
    if(IsIntegerTranslate())
    {
        return RotateNoneFlipNone;
    }
    
    // Main Diagonal is zero.
    
    if( (REALABS(M11) < REAL_EPSILON) &&             // M11 == 0.0
        (REALABS(M22) < REAL_EPSILON) )              // M22 == 0.0
    {
        // Rotate 270 or Rotate 90 + Flip X
        
        if( REALABS(M21-1) < REAL_EPSILON )          // M21 == 1.0
        {
            if( REALABS(M12-1) < REAL_EPSILON )      // M12 == 1.0
            {
                return Rotate90FlipX;
            }
            if( REALABS(M12+1) < REAL_EPSILON )      // M21 == -1.0
            {
                return Rotate270FlipNone;
            }
        }
        
        // Rotate 90 or Rotate 270 + Flip X
        
        if( REALABS(M21+1) < REAL_EPSILON )          // M21 == -1.0
        {
            if( REALABS(M12-1) < REAL_EPSILON )      // M12 == 1.0
            {
                return Rotate90FlipNone;
            }
            if( REALABS(M12+1) < REAL_EPSILON )      // M12 == -1.0
            {
                return Rotate270FlipX;
            }
        }
    }
    
    // Main Diagonal matrix (non zero).
    
    if( (REALABS(M12) < REAL_EPSILON) &&             // M12 == 0.0
        (REALABS(M21) < REAL_EPSILON) )              // M21 == 0.0
    {
        // Identity or Flip Y
        
        if( REALABS(M11-1) < REAL_EPSILON )          // M11 == 1.0
        {
            // Identity is handled already.
            // if( REALABS(M22-1) < REAL_EPSILON )   // M22 == 1.0
            
            if( REALABS(M22+1) < REAL_EPSILON )      // M22 == -1.0
            {
                return RotateNoneFlipY;
            }
        }
        
        // Flip X or Rotate 180
        
        if( REALABS(M11+1) < REAL_EPSILON )          // M11 == -1.0
        {
            if( REALABS(M22-1) < REAL_EPSILON )      // M22 == 1.0
            {
                return RotateNoneFlipX;
            }
            if( REALABS(M22+1) < REAL_EPSILON )      // M22 == -1.0
            {
                return Rotate180FlipNone;
            }
        }
    }
    
    // We couldn't find a rotate/flip type.
    
    return RotateNoneFlipNone;
}


/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix
*
* Arguments:
*
*   points - Array of points to be transformed
*       The resulting points are stored back into the same array
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Transform(
    GpPointF* points,
    INT count
    ) const
{
    if (count <= 0)
        return;

    ASSERT(points != NULL);

    // On checked builds, verify that the Complexity flags are correct:

    AssertComplexity();

    if(IsIdentity())
    {
        return;
    }
    else if(IsTranslate())
    {
        do {
            points->X += Dx;
            points->Y += Dy;

        } while (points++, --count != 0);
    }
    else if(IsTranslateScale())
    {
        do {
            points->X = points->X * M11 + Dx;
            points->Y = points->Y * M22 + Dy;

        } while (points++, --count != 0);
    }
    else 
    {
        do {
            REAL x = points->X;
            REAL y = points->Y;

            points->X = (M11 * x) + (M21 * y) + Dx;
            points->Y = (M12 * x) + (M22 * y) + Dy;

        } while (points++, --count != 0);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix,
*   with the destination an array of integer POINTS.
*
* Arguments:
*
*   srcPoints - Array of REAL points to be transformed
*
*   destPoints - Array of REAL points to store the results
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Transform(
    const GpPointF*     srcPoints,
    GpPointF*           destPoints,
    INT                 count
    ) const
{
    if (count <= 0)
        return;

    ASSERT((srcPoints != NULL) && (destPoints != NULL));

    // On checked builds, verify that the Complexity flags are correct:

    AssertComplexity();
    
    if(IsIdentity())
    {
        GpMemcpy(destPoints, srcPoints, count*sizeof(GpPointF));
    }
    else if (IsTranslate())
    {
        do {
            destPoints->X = srcPoints->X + Dx;
            destPoints->Y = srcPoints->Y + Dy;

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else if (IsTranslateScale())
    {
        do {
            destPoints->X = srcPoints->X * M11 + Dx;
            destPoints->Y = srcPoints->Y * M22 + Dy;

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else 
    {
        do {
            REAL x = srcPoints->X;
            REAL y = srcPoints->Y;

            destPoints->X = (M11 * x) + (M21 * y) + Dx;
            destPoints->Y = (M12 * x) + (M22 * y) + Dy;

        } while (destPoints++, srcPoints++, --count != 0);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix,
*   with the destination an array of integer POINTS.
*
* Arguments:
*
*   srcPoints - Array of REAL points to be transformed
*
*   destPoints - Array of INT points to store the results
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::Transform(
    const GpPointF*     srcPoints,
    POINT *             destPoints,
    INT                 count
    ) const
{
    if (count <= 0)
        return;

    ASSERT((srcPoints != NULL) && (destPoints != NULL));

    // On checked builds, verify that the Complexity flags are correct:

    AssertComplexity();
    
    // NOTE: This code should call RasterizeCeiling() to be consistent
    // with our aliased line drawing rasterizer.  

    if (IsTranslate())
    {
        do {
            destPoints->x = RasterizerCeiling(srcPoints->X + Dx);
            destPoints->y = RasterizerCeiling(srcPoints->Y + Dy);

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else if (IsTranslateScale())
    {
        do {
            destPoints->x = RasterizerCeiling(srcPoints->X * M11 + Dx);
            destPoints->y = RasterizerCeiling(srcPoints->Y * M22 + Dy);

        } while (destPoints++, srcPoints++, --count != 0);
    }
    else 
    {
        do {
            REAL x = srcPoints->X;
            REAL y = srcPoints->Y;

            destPoints->x = RasterizerCeiling((M11 * x) + (M21 * y) + Dx);
            destPoints->y = RasterizerCeiling((M12 * x) + (M22 * y) + Dy);

        } while (destPoints++, srcPoints++, --count != 0);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform a rect and return the resulting rect.
*   This only works if the matrix is a translate-scale matrix, but we're
*   assuming here that you've already checked for that.
*
* Arguments:
*
*   [IN/OUT]  rect - the rect to transform
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/5/1999 DCurtis
*
\**************************************************************************/

VOID
GpMatrix::TransformRect(
    GpRectF &   rect
    ) const
{
    if (IsIdentity())
        return;

    // NTRAID#NTBUG9-407211-2001-05-31-gillessk "Bad assert triggers when it shouldn't" 
    // loose the condition to allow rotation by multiple of 90 degrees
    ASSERT(IsTranslateScale() || (GetRotation()==MatrixRotateBy90) || (GetRotation()==MatrixRotateBy270));

    REAL    xMin = rect.X;
    REAL    yMin = rect.Y;
    REAL    xMax = xMin + rect.Width;
    REAL    yMax = yMin + rect.Height;
    REAL    x;
    
    x = xMin;
    xMin = (M11 * x) + (M21 * yMin) + Dx;
    yMin = (M12 * x) + (M22 * yMin) + Dy;

    x = xMax;
    xMax = (M11 * x) + (M21 * yMax) + Dx;
    yMax = (M12 * x) + (M22 * yMax) + Dy;

    if (xMin > xMax)
    {
        x    = xMin;
        xMin = xMax;
        xMax = x;
    }

    if (yMin > yMax)
    {
        x    = yMin;
        yMin = yMax;
        yMax = x;
    }

    rect.X      = xMin;
    rect.Y      = yMin;
    rect.Width  = xMax - xMin;
    rect.Height = yMax - yMin;    
}

/**************************************************************************\
*
* Function Description:
*
*   Transform the specified array of points using the current matrix,
*   ignoring translation.
*
* Arguments:
*
*   points - Array of points to be transformed
*       The resulting points are stored back into the same array
*
*   count - Number of points in the array
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMatrix::VectorTransform(
    GpPointF* points,
    INT count
    ) const
{
    if (IsIdentity())
        return;

    REAL x;

    for (INT i=0; i < count; i++)
    {
        x = points[i].X;
        points[i].X = M11*x + M21*points[i].Y;
        points[i].Y = M12*x + M22*points[i].Y;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Determine matrix complexity.  
*
*   NOTE: This function is fairly expensive.  It shouldn't be called
*         after every matrix operation.  (If it was, I would argue
*         that's a good reason to get rid of 'Complexity' entirely,
*         which is intended as a short-cut and should not be expensive
*         to keep updated.)
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Returns a bitmask representing the matrix complexity.
*
\**************************************************************************/

INT
GpMatrix::ComputeComplexity() const
{
    INT complexity = ComplexMask;

    REAL maxM = max(
        max(REALABS(M11), REALABS(M22)),
        max(REALABS(M12), REALABS(M21)));
    REAL epsilon = CPLX_EPSILON*maxM;

    // M12==0 && M21==0

    if ((REALABS(M12) < epsilon) && (REALABS(M21) < epsilon))
    {
        complexity &= ~(ShearMask | RotationMask);

        // M11==1 && M22==1

        if ((REALABS(M11 - 1.0f) < CPLX_EPSILON) && 
            (REALABS(M22 - 1.0f) < CPLX_EPSILON))
        {
            complexity &= ~ScaleMask;
        }
    }
    else
    {
        // Check if this is a pure rotation

        // M11==M22 && M12==-M21

        if((REALABS(M11 - M22) < epsilon) && 
           (REALABS(M12 + M21) < epsilon))
        {
            complexity &= ~ShearMask;
        
            // M11*M11+M12*M12==1

            if (REALABS(M11*M11 + M12*M12 - 1.0f) < CPLX_EPSILON)
            {
                complexity &= ~ScaleMask;
            }
        }
    }

    // Dx==0 && Dy==0

    // We don't know the real scaling of the translational part.
    // So we use the exact value.

    //    if ((REALABS(Dx) < CPLX_EPSILON) && (REALABS(Dy) < CPLX_EPSILON))
    if(Dx == 0 && Dy == 0)
    {
        complexity &= ~TranslationMask;
    }

    return(complexity);
}

/**************************************************************************\
*
* Function Description:
*
*   Verify the matrix complexity.
*
\**************************************************************************/

#if DBG

VOID 
GpMatrix::AssertComplexity() const
{
    INT computed = ComputeComplexity();

    // The new complexity can be less complex than the old 
    // (a sequence or rotations may end up with an identity
    // transform, for example), but that's okay - complexity
    // is intended as a short cut, and as such keeping it
    // updated sholud be light weight.
    //
    // But the calculated complexity SHOULD NOT be more complex
    // than the old - if it is, we have a bug someplace -
    // we're updating the matrix but not the complexity...
    //
    // Note: under certain circumstances - such as excessive 
    // repeated matrix appending or scaling up by very large 
    // factors - we could end up with a more complex computed
    // complexity just due to rounding errors.
    // Under these circumstances, the cause should be determined
    // and most likely the algorithm re-evaluated because when
    // rounding errors are propagated to such large proportions,
    // no operations are going to have predictable results anyway.

    ASSERTMSG((Complexity & computed) == computed, 
        (("Matrix more complex than cached Complexity indicates")));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\monitors.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definition for the GpMonitor class.
*
* WARNINGS:
*
*   This code should not use anything which is initialized in GdiplusStartup,
*   because it may be called before GdiplusStartup, or after GdiplusShutdown.
*   This includes ::new and ::delete.
*
*   This code is not thread-safe. It doesn't even detect itself being used
*   in multiple threads. It shouldn't crash, but the timing results could be
*   incorrect.
*
* Revision History:
*
*   09/30/2000 bhouse
*       Created it.
*
\**************************************************************************/


#include "precomp.hpp"


#undef MONITOR
#define __MONITORS_CPP__
const char * gStaticMonitorNames[kNumStaticMonitors+1] = {
#include "monitors.inc"
    ""
};

namespace Globals
{
    GpMonitors * Monitors;
};

void GpMonitors::Clear(void)
{
    for(int i = 0; i < kNumStaticMonitors; i++)
    {
        staticMonitors[i].Clear();
    }
}

GpStatus GpMonitors::Control(GpMonitorControlEnum control, void * param)
{
    GpStatus result = Ok;

    switch(control)
    {
    
    case MonitorControlClearAll:
        {
            Clear();
        }
        break;

    
    case MonitorControlDumpAll:
        {
            result = Dump((char *) param);
        }
        break;
    
    default:
        result = InvalidParameter;
    }             
    
    return result;
}

GpStatus GpMonitors::Dump(char * path)
{
    HANDLE  fileHandle;

    fileHandle = CreateFileA(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if(INVALID_HANDLE_VALUE != fileHandle)
    {
    
        GpMonitor * monitor = staticMonitors;
        ULONG       totalTime = 0;
        char        lineBuf[80];
        DWORD       bytesToWrite;
        DWORD       bytesWritten;
        double      ticksToMicroseconds = GpIntervalMonitor::TicksToMicroseconds();
        ULONG       microseconds;
    

        bytesToWrite = wsprintfA(lineBuf, "     Num    Total      Avg Api\n");
        WriteFile(fileHandle, lineBuf, bytesToWrite, &bytesWritten, NULL);

        for(int i = 0; i < kNumStaticMonitors; i++, monitor++)
        {

            if(monitor->GetCount() > 0)
            {
                
                microseconds = (ULONG) ((double) monitor->GetTicks() * ticksToMicroseconds);

                bytesToWrite = wsprintfA(
                    lineBuf, 
                    "%8d %8d %8d %s\n", 
                    (ULONG) monitor->GetCount(),
                    (ULONG) microseconds,
                    ((ULONG) microseconds / (ULONG) monitor->GetCount()),
                    gStaticMonitorNames[i]
                );

                WriteFile(fileHandle, lineBuf, bytesToWrite, &bytesWritten, NULL);
                    
                
                if(i < kFlatApiSentinelMonitor)
                {
                    totalTime += microseconds;
                }
            }
        }
        
        bytesToWrite = wsprintfA(lineBuf, "\nTotal time %d\n", totalTime);
        WriteFile(fileHandle, lineBuf, bytesToWrite, &bytesWritten, NULL);

        CloseHandle(fileHandle);

        return Ok;
    
    }
    else
    {
        return InvalidParameter;
    }
}

void GpIntervalMonitor::ReadTicks(ULONGLONG * ticks)
{
#if defined(_X86_)
    __asm
    {
        rdtsc
        push    edi
        mov     edi, ticks
        mov     [edi], eax
        mov     [edi+4], edx
        pop     edi
    }
#else
    QueryPerformanceCounter((LARGE_INTEGER *) ticks);
#endif
}

double GpIntervalMonitor::TicksToMicroseconds(void)
{
    ULONGLONG  freq;
    QueryPerformanceFrequency((LARGE_INTEGER *) &freq);

#if defined(_X86_)
    ULONGLONG   counterStart;
    ULONGLONG   ticksStart;
    ULONGLONG   counterEnd;
    ULONGLONG   ticksEnd;

    QueryPerformanceCounter((LARGE_INTEGER *) &counterStart);
    ReadTicks(&ticksStart);
    Sleep(10);
    QueryPerformanceCounter((LARGE_INTEGER *) &counterEnd);
    ReadTicks(&ticksEnd);

    return ((double) ((counterEnd - counterStart) * 1000000) / (double) freq) / (double) (ticksEnd - ticksStart);
#else
    return (double) 1000000 / (double) freq;
#endif

}

void GpIntervalMonitor::Enter(GpMonitorEnum monitorEnum)
{
    if(Globals::Monitors != NULL)
    {
        monitor = Globals::Monitors->GetMonitor(monitorEnum);
        ReadTicks(&startTicks);
    }
    else
    {
        monitor = NULL;
    }
}

void GpIntervalMonitor::Exit(void)
{
    if(monitor != NULL)
    {
        ULONGLONG   endTicks;
        ReadTicks(&endTicks);
        monitor->Record(endTicks - startTicks);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\engine.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains simple engine-wide prototypes and helper functions and
*   compile time flags.
*
* History:
*
*   12/04/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _ENGINE_HPP
#define _ENGINE_HPP

//--------------------------------------------------------------------------
// GDI+ internal prototypes
//--------------------------------------------------------------------------

class GpDevice;
struct DpPen;

USHORT 
GetLanguageID();

BOOL 
InitSystemFontsDirs(VOID);  //WCHAR **system_dir, WCHAR **fonts_dir);

UINT32
Crc32(
    IN const VOID*  buf,
    IN UINT         size,
    IN UINT32       checksum
    );

// Get the ceiling the same way the rasterizer does
inline INT
RasterizerCeiling(
    REAL    value
    )
{
    return GpFix4Ceiling(GpRealToFix4(value));
}

GpStatus
BoundsFToRect(
    const GpRectF *rectF,
    GpRect * rect
    );

/*
REAL
GetPenDelta(
    const DpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY
    );
*/

REAL GetDeviceWidth(
    REAL width,
    GpUnit unit,
    REAL dpi);

VOID
TransformBounds(
    const GpMatrix *matrix,
    REAL x0,
    REAL y0,
    REAL x1,
    REAL y1,
    GpRectF *bounds
    );

LONG
WINAPI
InterlockedCompareExchangeWin95(
    IN OUT PLONG destination,
    IN LONG exchange,
    IN LONG comperand
    );

LONG
WINAPI
InterlockedIncrementWin95(
    IN LPLONG lpAddend
    );

LONG
WINAPI
InterlockedDecrementWin95(
    IN LPLONG lpAddend
    );

BOOL
APIENTRY
GdiIsMetaPrintDCWin9x(
    HDC hdc
    );

//--------------------------------------------------------------------------
// The following macro is useful for checking if the creation of an 
// internal object succeeds.  
//
// We don't want to use exceptions to allow a constructor to indicate failure, 
// so the object has to contain an 'IsValid()' member that returns TRUE if 
// the object was successfully allocated.  But then the caller has to write
// the following code:
//
//      p = new Object();
//      if (!p  || !p->IsValid())
//      {
//          delete p;
//          ...
//
// The following macro can be used to replace this with:
//
//      p = new Object();
//      if (!CheckValid(p))
//      {
//          ...
//
// !!!
//  Note that CheckValid sets the input parameter to NULL
//  when the return value is FALSE.
//
//--------------------------------------------------------------------------

template <class T>
inline BOOL
CheckValid(
    T*& p
    )
{
    if (p && p->IsValid())
    {
        return TRUE;
    }
    else
    {
        delete p;
        p = NULL;
        return FALSE;
    }
}

//--------------------------------------------------------------------------
// Name dynamic array types
//--------------------------------------------------------------------------

typedef DynArray<GpPointF> DynPointFArray;
typedef DynArray<GpPoint> DynPointArray;
typedef DynArray<BYTE> DynByteArray;
typedef DynArray<INT> DynIntArray;
typedef DynArray<REAL> DynRealArray;
typedef DynArray<VOID*> DynPointerArray;

//--------------------------------------------------------------------------
// Raw critical section object
// The Initialize function can throw.
//--------------------------------------------------------------------------

class GpSemaphore
{
private:
    CRITICAL_SECTION CriticalSection;
    BOOL             Initialized;

public:

    GpSemaphore()
    {
        Initialized = FALSE;
    }

    VOID 
    Initialize(
        VOID
        )
    {
        if (!Initialized)
        {
            // The caller has to have a Try_Except around us.
            __try
            {
                InitializeCriticalSection(&CriticalSection); 
            }
            __except(EXCEPTION_CONTINUE_SEARCH)
            {
            }
            Initialized = TRUE;
        }
    }

    VOID 
    Uninitialize(
        VOID
        );

    VOID 
    Lock(
        VOID
        )
    {
        ASSERT(Initialized);
        EnterCriticalSection(&CriticalSection); 
    }

    VOID 
    Unlock(
        VOID
        )
    {
        ASSERT(Initialized);
        LeaveCriticalSection(&CriticalSection); 
    }

    BOOL 
    IsLocked(
        VOID
        );

    BOOL
    IsLockedByCurrentThread(
        VOID
        );
};


//------------------------------------------------------------------------
// FillMemoryInt32 - Fill an INT32 array with the specified value
// CopyMemoryInt32 - Copy INT32 values from one array to another
//------------------------------------------------------------------------

inline VOID
FillMemoryInt32(
    VOID* buf,
    INT count,
    INT32 val
    )
{
    INT32* p = (INT32*) buf;

    while (count-- > 0)
        *p++ = val;
}

inline VOID
CopyMemoryInt32(
    VOID* dst,
    const VOID* src,
    INT count
    )
{
    INT32* d = (INT32*) dst;
    const INT32* s = (const INT32*) src;

    while (count-- > 0)
        *d++ = *s++;
}

//------------------------------------------------------------------------
// CompareExchangeLong_Ptr - Perform an interlocked compare-exchange
//      on a LONG_PTR.  Unfortunately, Win95 does not export
//      InterlockedCompareExchange, so on that platform we have
//      to create our own.  But on NT, we CANNOT roll our own, because
//      of MP and NT64 issues.  
//
//      This method should be called instead of calling through the 
//      Globals::InterlockedCompareExchangeFunction directly, because
//      on Alpha machines, Globals::InterlockedCompareExchangeFunction does
//      NOT get initialized.
//------------------------------------------------------------------------
inline LONG_PTR
CompareExchangeLong_Ptr(
    LONG_PTR *destination,
    LONG_PTR  exchange,
    LONG_PTR  comperand
    )
{
    #if defined(_X86_)
        return Globals::InterlockedCompareExchangeFunction(destination,
                                                           exchange,
                                                           comperand);
    #else
        return (LONG_PTR)InterlockedCompareExchangePointer(
                               (PVOID *)destination, 
                               (PVOID)exchange, 
                               (PVOID)comperand);
    #endif
}

//------------------------------------------------------------------------
// CompareExchangePointer - Perform an interlocked compare-exchange
//      on a pointer.  Unfortunately, Win95 does not export
//      InterlockedCompareExchangePointer, so on that platform we have
//      to create our own.  But on NT, we CANNOT roll our own, because
//      of MP and NT64 issues.
//------------------------------------------------------------------------

inline VOID*
CompareExchangePointer(
    VOID** destination,
    VOID* exchange,
    VOID* comperand
    )
{
    #if defined(_X86_)
        return((VOID*) Globals::InterlockedCompareExchangeFunction((LONG*) destination,
                                                                   (LONG) exchange,
                                                                   (LONG) comperand));
    #else
        return(InterlockedCompareExchangePointer(destination, 
                                                 exchange, 
                                                 comperand));
    #endif
}

//--------------------------------------------------------------------------
// This routine retrieves a quick, pre-allocated region from a one-deep
// cache.  Note that the contents will be random.  This call is intended 
// largely for GDI API calls such as GetRandomRgn that require a pre-created 
// region.
//
// NOTE: This can return a NULL region handle.
//--------------------------------------------------------------------------

inline
HRGN GetCachedGdiRegion(
    VOID
    )
{
    HRGN regionHandle = Globals::CachedGdiRegion;
    
    // If the Globals::CachedGdiRegion is NULL, that means that someone
    // else has the cached region, so we create a new one.
    // It is possible during multi thread access for us to create a region
    // when it's not strictly necessary --- i.e. a thread releases the cached
    // region when this thread is between the above assignment and the next
    // if statement, but that's only non-optimal and we'll work correctly 
    // under those circumstances.
    
    if ((regionHandle == NULL) ||
        (CompareExchangePointer(
            (VOID**) &Globals::CachedGdiRegion,
            NULL,
            (VOID*) regionHandle) != regionHandle
        )
       )
    {
        regionHandle = CreateRectRgn(0, 0, 1, 1);
    }
    return(regionHandle);
}

//--------------------------------------------------------------------------
// This routine releases a region to the one-deep cache.
//--------------------------------------------------------------------------

inline
VOID ReleaseCachedGdiRegion(
   HRGN regionHandle
   )
{
    // Note that 'regionHandle' may be NULL at this point if the 
    // CreateRectRgn failed, but that's okay:

    if (CompareExchangePointer((VOID**) &Globals::CachedGdiRegion,
                               (VOID*) regionHandle,
                               NULL) != NULL)
    {
        DeleteObject(regionHandle);
    }
}

inline
HDC GetCleanHdc(
    HWND    hwnd
    )
{
    // Use GetDCEx(DCX_CACHE) to get a nice clean DC (not a CS_OWNDC).  
    // Note that with GetDCEx we have to explicitly respect the window's
    // clipping styles. We stole this little bit of logic straight from 
    // ntuser\kernel\dc.c for the DCX_USESTYLE case:

    DWORD getDcFlags = DCX_CACHE;
    LONG classStyle = GetClassLongA(hwnd, GCL_STYLE);
    LONG windowStyle = GetWindowLongA(hwnd, GWL_STYLE);

    if (classStyle & CS_PARENTDC)
        getDcFlags |= DCX_PARENTCLIP;

    if (windowStyle & WS_CLIPCHILDREN)
        getDcFlags |= DCX_CLIPCHILDREN;

    if (windowStyle & WS_CLIPSIBLINGS)
        getDcFlags |= DCX_CLIPSIBLINGS;

    // Minimized windows never exclude their children.

    if (windowStyle & WS_MINIMIZE)
        getDcFlags &= ~DCX_CLIPCHILDREN;

    return GetDCEx(hwnd, NULL, getDcFlags);
}

inline INT
GetIntDistance(
    POINT &         p1,
    POINT &         p2
    )
{
    double      dx = (double)(p2.x - p1.x);
    double      dy = (double)(p2.y - p1.y);

    REAL        distance = (REAL)sqrt((dx * dx) + (dy * dy));
    
    return GpRound(distance);
}

inline REAL
GetDistance(
    GpPointF &      p1,
    GpPointF &      p2
    )
{
    double      dx = (double)p2.X - p1.X;
    double      dy = (double)p2.Y - p1.Y;

    return (REAL)sqrt((dx * dx) + (dy * dy));
}

inline REAL
GetDegreesFromRadians(double radians)
{
    return (REAL)(radians*180.0/3.1415926535897932);
}

// return angle in degrees from 2 points
inline REAL
GetAngleFromPoints(
    const GpPointF &    p1,
    const GpPointF &    p2
    )
{
    // Compute the angle of the line formed by p1 and p2.
    // Note atan2 is only undefined if dP.Y == 0.0 and dP.X == 0.0
    // and then it returns 0 radians. 
    // Also, atan2 correctly computes the quadrant from the two input points.
    
    GpPointF    dP = p2 - p1;
    double      radians = atan2((double)(dP.Y), (double)(dP.X));
    return GetDegreesFromRadians(radians);
}

#define DEFAULT_RESOLUTION  96  // most display screens are set to 96 dpi

//--------------------------------------------------------------------------
// The following 3 functions should be used in place of GetObjectType due
// to a bug on Windows 9x where an OBJ_METAFILE and another type of object
// may share the same handle!
//
// GetObjectTypeInternal: Call this to determine any object type except
//                        when expecting OBJ_METAFILE or OBJ_*DC.
//
// GetDCType: Use this when the object should be a DC,and just the type of
//            DC is required.
//
// IsValidMetaFile: OBJ_METAFILE is the special case. Use this function to
//                  validate when OBJ_METAFILE is expected. This only means
//                  there is a metafile with this handle. There could also
//                  be an "aliased" object which the caller intended to be
//                  used, so this should not be used to handle multiple
//                  object types.
//--------------------------------------------------------------------------

DWORD
GetObjectTypeInternal(
    IN HGDIOBJ handle
    );

DWORD
GetDCType(
    IN HDC hdc
    );

inline
BOOL
IsValidMetaFile(
    HMETAFILE handle
    )
{
    return (GetObjectType(handle) == OBJ_METAFILE);
};

#endif // !_ENGINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\matrix.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Matrix.hpp
*
* Abstract:
*
*   Matrix used by GDI+ implementation
*
* Revision History:
*
*   12/01/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef __MATRIX_HPP
#define __MATRIX_HPP

// Common constants used for conversions.

#define DEGREESPERRADIAN       57.2957795130823

//--------------------------------------------------------------------------
// Represents a 2D affine transformation matrix
//--------------------------------------------------------------------------

enum MatrixRotate
{
    MatrixRotateBy0,
    MatrixRotateBy90,
    MatrixRotateBy180,
    MatrixRotateBy270,
    MatrixRotateByOther
};

class GpMatrix
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagMatrix : ObjectTagInvalid;
    }

    // This method is here so that we have a virtual function table so
    // that we can add virtual methods in V2 without shifting the position
    // of the Tag value within the data structure.
    virtual VOID DontCallThis()
    {
        DontCallThis();
    }

public:

    // Default constructor - set to identity matrix

    GpMatrix()
    {
        Reset();
    }

    ~GpMatrix()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    // Reset the matrix object to identity

    VOID Reset()
    {
        M11 = M22 = 1;
        M12 = M21 = Dx = Dy = 0;
        Complexity = IdentityMask;
        SetValid(TRUE);
    }

    // Construct a GpMatrix object with the specified elements

    GpMatrix(REAL m11, REAL m12,
             REAL m21, REAL m22,
             REAL dx,  REAL dy)
    {
        SetValid(TRUE);

        M11 = m11;
        M12 = m12;
        M21 = m21;
        M22 = m22;
        Dx  = dx;
        Dy  = dy;

        Complexity = ComputeComplexity();
    }

    GpMatrix(REAL *elems)
    {
        SetValid(TRUE);

        M11 = elems[0];
        M12 = elems[1];
        M21 = elems[2];
        M22 = elems[3];
        Dx  = elems[4];
        Dy  = elems[5];

        Complexity = ComputeComplexity();
    }

    GpMatrix(const GpMatrix &matrix)
    {
        SetValid(TRUE);

        M11 = matrix.M11;
        M12 = matrix.M12;
        M21 = matrix.M21;
        M22 = matrix.M22;
        Dx  = matrix.Dx;
        Dy  = matrix.Dy;

        Complexity = matrix.Complexity;
    }

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    // If the matrix came from a different version of GDI+, its tag
    // will not match, and it won't be considered valid.
    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpMatrix, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagMatrix) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Matrix");
        }
    #endif

        return (Tag == ObjectTagMatrix);
    }

    // Construct a GpMatrix object by inferring from a rectangle-to-
    // parallelogram mapping:

    GpMatrix(const GpPointF* destPoints, const GpRectF& srcRect);

    GpStatus InferAffineMatrix(const GpPointF* destPoints, const GpRectF& srcRect);

    GpStatus InferAffineMatrix(const GpRectF& destRect, const GpRectF& srcRect);

    GpMatrix* Clone()
    {
        return new GpMatrix(*this);
    }

    // Transform an array of points using the matrix v' = v M:
    //
    //                                  ( M11 M12 0 )
    //      (vx', vy', 1) = (vx, vy, 1) ( M21 M22 0 )
    //                                  ( dx  dy  1 )

    VOID Transform(GpPointF* points, INT count = 1) const;

    VOID Transform(
        const GpPointF*     srcPoints,
        GpPointF*           destPoints,
        INT                 count = 1
        ) const;

    VOID Transform(
        const GpPointF*     srcPoints,
        POINT *             destPoints,
        INT                 count = 1
        ) const;

    VOID TransformRect(GpRectF & rect) const;

    VOID VectorTransform(GpPointF* points, INT count = 1) const;

    // XTransform returns only the x-component result of a vector 
    // transformation:

    REAL XTransform(REAL x, REAL y)
    {
        return(x*M11 + y*M21 + Dx);
    }

    BOOL IsEqual(const GpMatrix * m) const
    {
        // Note that we can't assert here that the two cached
        // complexity's are equal, since it's perfectly legal to
        // have a cache complexity that indicates more complexity
        // than is actually there (such as the case of a sequence
        // of rotations that ends up back in an identity transform):

        // !!![andrewgo] This should probably be using an epsilon compare

        return((M11 == m->M11) &&
               (M12 == m->M12) &&
               (M21 == m->M21) &&
               (M22 == m->M22) &&
               (Dx  == m->Dx)  &&
               (Dy  == m->Dy));
    }

    REAL GetDeterminant() const
    {
        return (M11*M22 - M12*M21);
    }

    // Compare to a scaled value of epsilon used for matrix complexity
    // calculations.  Must scale maximum value of matrix members to be
    // in the right range for comparison.
    BOOL IsInvertible() const
    {
        return !IsCloseReal(0.0f, GetDeterminant());
    }

    GpStatus Invert();

    VOID Scale(REAL scaleX, REAL scaleY, GpMatrixOrder order = MatrixOrderPrepend);

    VOID Rotate(REAL angle, GpMatrixOrder order = MatrixOrderPrepend);

    VOID Translate(REAL offsetX, REAL offsetY, GpMatrixOrder order = MatrixOrderPrepend);

    VOID Shear(REAL shearX, REAL shearY, GpMatrixOrder order = MatrixOrderPrepend);

    VOID AppendScale(REAL scaleX, REAL scaleY)
    {
        M11 *= scaleX;
        M21 *= scaleX;
        M12 *= scaleY;
        M22 *= scaleY;
        Dx *= scaleX;
        Dy *= scaleY;

        Complexity = ComputeComplexity();
    }

    VOID AppendTranslate(REAL offsetX, REAL offsetY)
    {
        Dx += offsetX;
        Dy += offsetY;

        Complexity |= TranslationMask;
        AssertComplexity();
    }

    // Scale the entire matrix by the scale value

    static VOID ScaleMatrix(GpMatrix& m, const GpMatrix& m1,
                            REAL scaleX, REAL scaleY);

    static VOID MultiplyMatrix(GpMatrix& m, const GpMatrix& m1, const GpMatrix& m2);

    VOID Append(const GpMatrix& m)
    {
        MultiplyMatrix(*this, *this, m);
    }

    VOID Prepend(const GpMatrix& m)
    {
        MultiplyMatrix(*this, m, *this);
    }

    // Get/set matrix elements

    VOID GetMatrix(REAL* m) const
    {
        m[0] = M11;
        m[1] = M12;
        m[2] = M21;
        m[3] = M22;
        m[4] = Dx;
        m[5] = Dy;
    }

    // This is for metafiles -- we don't save the complexity in the metafile
    VOID WriteMatrix(IStream * stream) const
    {
        REAL    m[6];
        GetMatrix(m);
        stream->Write(m, 6 * sizeof(REAL), NULL);
    }

    VOID SetMatrix(const REAL* m)
    {
        M11 = m[0];
        M12 = m[1];
        M21 = m[2];
        M22 = m[3];
        Dx  = m[4];
        Dy  = m[5];

        Complexity = ComputeComplexity();
    }

    VOID SetMatrix(REAL m11, REAL m12,
             REAL m21, REAL m22,
             REAL dx,  REAL dy)
    {
        M11 = m11;
        M12 = m12;
        M21 = m21;
        M22 = m22;
        Dx  = dx;
        Dy  = dy;

        Complexity = ComputeComplexity();
    }
    
    VOID RemoveTranslation()
    {
        Dx = 0;
        Dy = 0;

        Complexity &= ~TranslationMask;
        AssertComplexity();
    }

    // Determine matrix complexity

    enum
    {
        IdentityMask        = 0x0000,
        TranslationMask     = 0x0001,
        ScaleMask           = 0x0002,
        RotationMask        = 0x0004,
        ShearMask           = 0x0008,
        ComplexMask         = 0x000f
    };

    INT GetComplexity() const
    {
        return Complexity;
    }

    MatrixRotate GetRotation() const;
    RotateFlipType AnalyzeRotateFlip() const;

    // Returns TRUE if the matrix does not have anything other than
    // translation and/or scale (and/or identity).  i.e. there is no rotation
    // or shear in the matrix.  Returns FALSE if there is a rotation or shear.

    BOOL IsTranslateScale() const
    {
        return (!(Complexity &
                  ~(GpMatrix::TranslationMask | GpMatrix::ScaleMask)));
    }

    BOOL IsIdentity() const
    {
        return (Complexity == IdentityMask);
    }

    BOOL IsTranslate() const
    {
        return ((Complexity & ~TranslationMask) == 0);
    }
    
    // Returns true if the matrix is a translate-only transform by an 
    // integer number of pixels.

    BOOL IsIntegerTranslate() const
    {
        return (IsTranslate() &&
                (REALABS(static_cast<REAL>(GpRound(Dx)) - Dx) <= PIXEL_EPSILON) &&
                (REALABS(static_cast<REAL>(GpRound(Dy)) - Dy) <= PIXEL_EPSILON));
    }

    BOOL IsMinification() const
    {
        return (IsTranslateScale() &&
                ((M11-1.0f < -REAL_EPSILON) || 
                 (M22-1.0f < -REAL_EPSILON)));    
    }
    // Returns true if there is any minification or if the transform involves
    // rotation/shear.
    
    BOOL IsRotateOrMinification() const
    {
        return ( ((Complexity & ~(ScaleMask | TranslationMask))!= 0) || 
                 IsMinification() );
    }

    BOOL IsRotateOrShear() const
    {
        return ( (Complexity & ~(ScaleMask | TranslationMask))!= 0);
    }

    BOOL IsShear() const
    {
        return ((Complexity & ShearMask) != 0);
    }
    
    REAL GetM11() const { return M11; }
    REAL GetM12() const { return M12; }
    REAL GetM21() const { return M21; }
    REAL GetM22() const { return M22; }
    REAL GetDx() const { return Dx; }
    REAL GetDy() const { return Dy; }

    // On checked builds, verify that the Matrix flags are correct.

#if DBG
    VOID AssertComplexity() const;
#else
    VOID AssertComplexity() const {}
#endif

protected:

    mutable GpLockable Lockable;

    REAL M11;
    REAL M12;
    REAL M21;
    REAL M22;
    REAL Dx;
    REAL Dy;
    INT Complexity;             // Bit-mask short-cut

    INT ComputeComplexity() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\monitors.inc ===
//
// This file is used to generate both the monitor enumeration and
// the set of strings that correspond to each enumeration.
//
// This file is included in both monitors.cpp and monitors.hpp.  In
// monitors.cpp, we define the strings in the strin array gStaticMonitorNames.
// In monitors.hpp, we define the enumerations.
//
// This file should contain a line for each enumeration in the form:
//      MONITOR(monitor_name),
//
//


#ifndef __MONITORS_CPP__ 
#define MONITOR(x) k##x##Monitor
#else
#define MONITOR(x) #x

// Flatapi 

#endif
#include "..\flat\flatapi.inc"

MONITOR(FlatApiSentinel),

// Internal

MONITOR(GpJpegDecoder_Decode),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\monitors.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Contains the definitions for a timing 'Monitor' used to measure
*   the runtime of isolated pieces of code.
*
* WARNINGS:
*
*   This code should not use anything which is initialized in GdiplusStartup,
*   because it may be called before GdiplusStartup, or after GdiplusShutdown.
*   This includes ::new and ::delete.
*
*   This code is not thread-safe. It doesn't even detect itself being used
*   in multiple threads. It shouldn't crash, but the timing results could be
*   incorrect.
*
* Notes:
* 
*   'Monitor' in this context has nothing to do with the Display.
*
* History:
*
*   09/30/2000 bhouse
*       Created it.
*
\**************************************************************************/

#ifndef __MONITORS_HPP__
#define __MONITORS_HPP__

typedef enum GpMonitorEnum {
#include "monitors.inc"
    kNumStaticMonitors
};

extern const char * gStaticMonitorNames[];

typedef Status GpStatus;

class GpMonitors;

namespace Globals
{
    extern GpMonitors * Monitors;
};

class GpMonitor
{
public:

    GpMonitor(void)
    {
        Clear();
    }

    void Clear(void)
    {
        count = 0;
        ticks = 0;
    }

    void Record(void)
    {
        count++;
    }

    void Record(ULONGLONG inTicks)
    {
        ticks += inTicks;
        count++;
    }

    ULONGLONG GetCount()
    {
        return count;
    }

    ULONGLONG GetTicks()
    {
        return ticks;
    }

private:

    ULONGLONG   count;
    ULONGLONG   ticks;
};

enum GpMonitorControlEnum
{
   MonitorControlClearAll = 0,
   MonitorControlDumpAll
};

class GpMonitors
{
public:

    GpMonitors(void)
    {
        Clear();
    }

    void Clear(void);
    
    GpStatus Dump(char * path);
    
    GpStatus Control(GpMonitorControlEnum control, void * param);

    GpMonitor * GetMonitor(GpMonitorEnum monitor)
    {
        return &staticMonitors[monitor];
    }
    
    // Define new and delete operators which don't depend on globals.
    // This way we can use the monitors around GdiplusStartup and
    // GdiplusShutdown.
    //
    // In truth, delete() will probably never be called, because we don't want
    // to destroy GpMonitors in GdiplusShutdown.
    
    void *operator new( size_t s)
    {
        return HeapAlloc(GetProcessHeap(), 0, s);
    }
    void operator delete( void *p)
    {
        if (p)
        {
            HeapFree(GetProcessHeap(), 0, p);
        }
    }

private:

    GpMonitor staticMonitors[kNumStaticMonitors];

};

class GpIntervalMonitor
{
public:

    void Enter(GpMonitorEnum monitorEnum);
    void Exit(void);

    static void ReadTicks(ULONGLONG * ticks);
    static double TicksToMicroseconds(void);

private:

    GpMonitor * monitor;
    ULONGLONG   startTicks;

};

class GpBlockMonitor : GpIntervalMonitor
{
public:

    GpBlockMonitor(GpMonitorEnum monitorEnum)
    {
        Enter(monitorEnum);
    }

    ~GpBlockMonitor(void)
    {
        Exit();
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\globals.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains all the globals used by GDI+.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef __GLOBALS_HPP
#define __GLOBALS_HPP

class GpDevice;
class GpPrinterDevice;
class DpBitmap;
class DpDriver;
class DriverMulti;
class GpFontTable;
class GpFontLink;
class GpFontFile;
class GpDeviceList;

// Private DirectDraw export:

typedef HRESULT (WINAPI *DIRECTDRAWCREATEEXFUNCTION)(GUID*,
                                             VOID*,
                                             REFIID,
                                             IUnknown*);

typedef HRESULT (WINAPI *GETDDRAWSURFACEFROMDCFUNCTION)(HDC,
                                                        LPDIRECTDRAWSURFACE*,
                                                        HDC*);


typedef HRESULT (WINAPI *DIRECTDRAWENUMERATEEXFUNCTION)(LPDDENUMCALLBACKEXA,
                                                        LPVOID,
                                                        DWORD);

// GDI exports

typedef BOOL  (WINAPI *EXTTEXTOUTFUNCTION) (    HDC,
                                                int,
                                                int,
                                                UINT,
                                                CONST RECT *,
                                                LPCWSTR,
                                                UINT,
                                                CONST INT *);
// Private NT GDI export:

typedef BOOL (APIENTRY *GDIISMETAPRINTDCFUNCTION)(HDC);

// Win98/NT5 only stuff:

typedef WINUSERAPI BOOL (WINAPI *GETMONITORINFOFUNCTION)(HMONITOR,
                                                         LPMONITORINFOEXA);


typedef WINUSERAPI BOOL (WINAPI *ENUMDISPLAYMONITORSFUNCTION)(HDC,
                                                              LPCRECT,
                                                              MONITORENUMPROC,
                                                              LPARAM);

typedef WINUSERAPI BOOL (WINAPI *ENUMDISPLAYDEVICESFUNCTION)(LPCSTR,
                                                             DWORD,
                                                             PDISPLAY_DEVICEA,
                                                             DWORD);

typedef WINUSERAPI HWINEVENTHOOK (WINAPI *SETWINEVENTHOOKFUNCTION)(DWORD,
                                                                   DWORD,
                                                                   HMODULE,
                                                                   WINEVENTPROC,
                                                                   DWORD,
                                                                   DWORD,
                                                                   DWORD);

typedef WINUSERAPI BOOL (WINAPI *UNHOOKWINEVENTFUNCTION)(HWINEVENTHOOK);

typedef WINUSERAPI BOOL (WINAPI *GETWINDOWINFOFUNCTION)(HWND, PWINDOWINFO);

typedef WINUSERAPI HWND (WINAPI *GETANCESTORFUNCTION)(HWND, UINT);



typedef USHORT (*CAPTURESTACKBACKTRACEFUNCTION)(ULONG, ULONG, PVOID *, PULONG);


// Lazy load of DCI:

typedef int (WINAPI *DCICREATEPRIMARYFUNCTION)(HDC, LPDCISURFACEINFO FAR *);

typedef void (WINAPI *DCIDESTROYFUNCTION)(LPDCISURFACEINFO);

typedef DCIRVAL (WINAPI *DCIBEGINACCESSFUNCTION)(LPDCISURFACEINFO, int, int, int, int);

typedef void (WINAPI *DCIENDACCESSFUNCTION)(LPDCISURFACEINFO);


// Must match InterlockedCompareExchange calling convention on x86 only:

typedef WINBASEAPI LONG (WINAPI *INTERLOCKEDCOMPAREEXCHANGEFUNCTION)(IN OUT LPLONG,
                                                                     IN LONG,
                                                                     IN LONG);

typedef WINBASEAPI LONG (WINAPI *INTERLOCKEDINCREMENTFUNCTION)(IN LPLONG);

typedef WINBASEAPI LONG (WINAPI *INTERLOCKEDDECREMENTFUNCTION)(IN LPLONG);

// Winspool.drv export ('A' version only)

typedef BOOL (WINAPI *WINSPOOLGETPRINTERDRIVERFUNCTION)(HANDLE hPrinter,
                                                        LPSTR pEnvironment,
                                                        DWORD Level,
                                                        LPBYTE pDriverInfo,
                                                        DWORD vbBuf,
                                                        LPDWORD pcbNeeded);

// Most of our globals.
// There are additions to the Globals namespace in engine\entry\initialize.cpp
// See also, globals.cpp.

namespace Globals
{
    extern BOOL IsNt;                   // Are we running on any version of NT?

    extern BOOL IsWin95;                // Neither NT nor Win98?
    extern BOOL VersionInfoInitialized; // Wheter the version info has been
                                        //   initialized or not.
    extern OSVERSIONINFOA OsVer;        // More specific OS Version info
    extern UINT ACP;                    // Active Code Page
    extern GpDevice *DesktopDevice;     // The device representing the entire
                                        //   desktop
    extern GpDeviceList *DeviceList;    // List of devices that we know about
    extern DpBitmap *DesktopSurface;    // A surface representing the desktop
    extern DpDriver *DesktopDriver;     // The driver representing desktop
                                        //   drawing
    extern DpDriver *EngineDriver;      // The virtual driver representing only
                                        //   GDI+ Eng drawing functionality
    extern DpDriver *GdiDriver;         // The virtual driver that draws using
                                        //   only GDI routines
    extern DpDriver *D3DDriver;         // The virtual driver that draws using
                                        //   only D3D/DD routines
    extern DpDriver *InfoDriver;        // The virtual driver that doesn't draw
                                        //   anything -- used for metafiles
    extern DpDriver *MetaDriver;        // The virtual driver that draws using
                                        //   only GDI routines for Metafiles

    extern BOOL DirectDrawInitialized;  // Flag indicating whether diret draw
                                        //   and direct 3D related globals have
                                        //   been initialized.
    extern BOOL DirectDrawInitAttempted;// Flag indicating whether we have tried
                                        //   to initialized direct draw and
                                        //   direct 3d globals
    extern HINSTANCE DdrawHandle;       // DirectDraw DLL handle
    extern IDirectDraw7 * DirectDraw;   // Pointer to the direct draw interface
                                        //   for the desktop
    extern IDirect3D7 * Direct3D;       // Pointer to the direct 3D interface
                                        //   for the desktop
    extern DIRECTDRAWCREATEEXFUNCTION DirectDrawCreateExFunction;
                                        // Pointer to the direct draw static
                                        //   function used for creation of the
                                        //   direct draw interface
    extern DIRECTDRAWENUMERATEEXFUNCTION DirectDrawEnumerateExFunction;
                                        // Pointer to the direct draw
                                        //   enumeration function
    extern GETDDRAWSURFACEFROMDCFUNCTION GetDdrawSurfaceFromDcFunction;
                                        // Pointer to private DirectDraw
                                        //   function for getting a DDraw
                                        //   surface from an HDC
    extern INTERLOCKEDCOMPAREEXCHANGEFUNCTION InterlockedCompareExchangeFunction;
                                        // Pointer to appropriate x86
                                        //   compare-exchange function (not
                                        //   used on non-x86)
    extern EXTTEXTOUTFUNCTION ExtTextOutFunction;
                                        // Pointer to either ExtTextOutA
                                        // or ExtTextOutW. depends on IsNt
    extern GDIISMETAPRINTDCFUNCTION GdiIsMetaPrintDCFunction;
                                        // Pointer to appropriate function for
                                        //   determining if a metafile DC is
                                        //   actually a metafiled printer DC
                                        //   (Points to an internal GDI
                                        //   function on NT, and to our own
                                        //   routine on Win9x)
    extern GETMONITORINFOFUNCTION GetMonitorInfoFunction;
                                        // Pointer to GetMonitorInfo used
                                        //   used for getting information
                                        //   for a monitor identified by a
                                        //   HMONITOR.
    extern ENUMDISPLAYMONITORSFUNCTION EnumDisplayMonitorsFunction;
                                        // Pointer to EnumDisplayMonitors
                                        //   function used for enumerating all
                                        //   of the monitors of a multi-mon
                                        //   capable Win32 platform.
    extern ENUMDISPLAYDEVICESFUNCTION EnumDisplayDevicesFunction;
                                        // Pointer to EnumDisplayDevices
                                        //   function used for enumerating all
                                        //   of the display devices of a
                                        //   multi-mon capable Win32 platform.
    extern HMODULE DcimanHandle;
    extern DCICREATEPRIMARYFUNCTION DciCreatePrimaryFunction;
    extern DCIDESTROYFUNCTION DciDestroyFunction;
    extern DCIBEGINACCESSFUNCTION DciBeginAccessFunction;
    extern DCIENDACCESSFUNCTION DciEndAccessFunction;
                                        // Pointer to all functions imported
                                        //   from DCI, so that we can
                                        //   delay load DCIMAN32.DLL for perf
                                        //   reasons
    extern CAPTURESTACKBACKTRACEFUNCTION CaptureStackBackTraceFunction;
                                        // Pointer to RtlCaptureStackBackTrace
                                        //   function (if available)
    
    extern GETWINDOWINFOFUNCTION GetWindowInfoFunction;
                                        // Pointer to User32's GetWindowInfo
                                        //   function (if available)
    extern GETANCESTORFUNCTION GetAncestorFunction;
                                        // Pointer to User32's GetAncestor
                                        //   function (if available)
    extern SETWINEVENTHOOKFUNCTION SetWinEventHookFunction;
                                        // Pointer to User32's SetWinEventHook
                                        //   function (if available)
    extern UNHOOKWINEVENTFUNCTION UnhookWinEventFunction;
                                        // Pointer to User32's UnhookWinEvent
                                        //   function (if available)
    extern BOOL IsMoveSizeActive;       // TRUE if we're running on NT and our
                                        //   window event hook has indicated
                                        //   that the user is currently dragging
                                        //   windows around
    extern HRGN CachedGdiRegion;        // Cached region for random calls that
                                        //   require a region.  The contents
                                        //   aren't important; rather its
                                        //   existence is.  This handle must
                                        //   always be non-NULL
    
    // On the NT codebase, the CreateDC(DISPLAY, NULL, NULL, NULL) call has
    // thread affinity. This means that the desktop DC would go away if the
    // thread which called GdiplusStartup terminated even if we were still 
    // using it.
    // On NT we create an Info DC which has process affinity. Rendering onto
    // an Info DC is not supported but that's ok because we always create
    // DriverMulti on NT - and therefore always render on a monitor specific
    // DC instead.
    // Win9x does not have the thread affinity problem and we'd use an IC
    // if it weren't for the fact that win95 doesn't have EnumDisplayMonitors
    // and hence uses DriverGdi instead of DriverMulti - rendering directly
    // on the DesktopIc
    // see RAID:
    // 301407 GDI+ Globals::DesktopDC has thread affinity
    // 312342 CreateDC("Display", NULL, NULL, NULL) has thread affinity.
    // and gdiplus/test/multithread for a test app that exposes this problem.
    
    // I.e. Don't render on this DC - it won't work. It's for informational 
    // purposes only.
    
    extern HDC DesktopIc;               // Handle to the global desktop DC
    
    
    extern REAL DesktopDpiX;            // DpiX of desktop HDC (from GetDeviceCaps)
    extern REAL DesktopDpiY;            // DpiY of desktop HDC (from GetDeviceCaps)

    extern GpInstalledFontCollection *FontCollection;   // Table of loaded fonts
    extern GpFontLink *FontLinkTable ;  // Linked fonts Table
    extern GpFontFamily **SurrogateFontsTable;         // Surrogate font fallback family table

    extern GpCacheFaceRealizationList *FontCacheLastRecentlyUsedList; // list of last recently used CacheFaceRealization

    extern WCHAR* SystemDirW;           // System dir needed by addfontresource (Nt)
    extern CHAR*  SystemDirA;           // System dir needed by addfontresource (Win9x)

    extern WCHAR* FontsDirW;            // Fonts dir needed by addfontresource (Nt)
    extern CHAR*  FontsDirA;            // Fonts dir needed by addfontresource (Win9x)

    extern WCHAR* FontsKeyW;            // Registry key for fonts (Nt)
    extern CHAR*  FontsKeyA;            // Registry key for fonts (Win9x)
    extern BOOL   TextCriticalSectionInitialized;  // has the text critical section been initialized
    extern CRITICAL_SECTION TextCriticalSection;  // global critical section that protect all the text calls
                                        // claudebe 4/5/00 at this time we want to protect globally as opposed
                                        // to protect separately font cache, font realization access like in GDI
                                        // the idea is that we don't expect to have a huge amount of threads in parallel as in GDI
                                        // so performance is considered as acceptable for GDI+
                                        // if we want to change it the other way, look for commented code with
                                        // FontFileCacheCritSection, FontFamilyCritSection, FaceRealizationCritSection, g_cstb, csCache and ghsemTTFD
    extern TextRenderingHint CurrentSystemRenderingHint;   // current system text rendering mode, used to implement the TextRenderingHintSystemDefault mode
    extern BOOL CurrentSystemRenderingHintInvalid;  // Should we re-read CurrentSystemRenderingHint user settings?


    extern USHORT LanguageID;           // LangID needed by ttfd, for US = 0x0409

    extern LONG_PTR LookAsideCount;
    extern BYTE* LookAsideBuffer;
    extern INT LookAsideBufferSize;

    extern UINT PaletteChangeCount;
    extern COLORREF SystemColors[];

    extern HANDLE hCachedPrinter;       // for postscript cache printer handle
    extern INT CachedPSLevel;           //   + level
            // !!![ericvan] We should use: CHAR CachedPrinterName[CCHDEVICENAME];

    extern HINSTANCE WinspoolHandle;
    extern WINSPOOLGETPRINTERDRIVERFUNCTION GetPrinterDriverFunction;

    extern HMODULE UniscribeDllModule;      // Loaded Uniscribe (usp10.dll) module

    extern IntMap<BYTE> *NationalDigitCache; // National Digit Substitution cache
    extern BOOL UserDigitSubstituteInvalid;  // Should we re-read digit sub user settings?

    // clear type lookup tables

    // filtered counts of RGB
    struct F_RGB
    {
        BYTE kR;
        BYTE kG;
        BYTE kB;
        BYTE kPadding;
    };

    extern const F_RGB * gaOutTable;
    extern const BYTE FilteredCTLut[];
    extern const BYTE TextContrastTableIdentity[256];
    typedef const BYTE TEXT_CONTRAST_TABLES[12][256];
    extern TEXT_CONTRAST_TABLES TextContrastTablesDir; // 1.1 ... 2.2
    extern TEXT_CONTRAST_TABLES TextContrastTablesInv; // 1.1 ... 2.2

    extern GpPath * PathLookAside;
    extern GpMatrix * MatrixLookAside;
    extern GpPen * PenLookAside;

    // Is this instance of gdiplus running in terminal server session space.

    extern BOOL IsTerminalServer;

    // For an explanation of GDIPLUS_MIRROR_DRIVER_NO_DCI, see
    // pdrivers\drivermulti.cpp or bug #92982.
    // TRUE if any mirror driver is active on the system.   
    extern BOOL IsMirrorDriverActive;

    // User-supplied debug event reporting callback
    extern DebugEventProc UserDebugEventProc;

    //// START Synchronized under GdiplusStartupCriticalSection
        extern HANDLE ThreadNotify;         // Thread handle for hidden window notify
        extern DWORD ThreadId;              // Thread ID for hidden window notify

        // These two are used by GdiplusStartup and GdiplusShutdown
        extern ULONG_PTR LibraryInitToken;
        extern INT LibraryInitRefCount;

        // This is used by NotificationStartup and NotificationShutdown.

        extern ULONG_PTR NotificationInitToken;

        // The token of the module which owns the hidden window. 
        // See "NotificationModuleToken" below.

        extern ULONG_PTR HiddenWindowOwnerToken;
    //// END Synchronized under GdiplusStartupCriticalSection (on GDIPLUS.DLL)

    //// START Synchronized under BackgroundThreadCriticalSection:
        extern HANDLE ThreadQuitEvent;      // Event object for killing the background thread
        
        extern HWND HwndNotify;             // HWND for hidden window notify
        extern ATOM WindowClassAtom;        // Atom for our "notification window" class
        extern HWINEVENTHOOK WinEventHandle;// Handle to our window event hook
    //// END Synchronized under BackgroundThreadCriticalSection:

        extern BOOL g_fAccessibilityPresent;
        extern UINT g_nAccessibilityMessage;// Window message to disable accessibility messages.

};

// For the variable HiddenWindowOwnerToken, we have 2 values with special
// meanings:
//
// NotificationModuleTokenNobody: No module currently owns the hidden window.
//     i.e. we're waiting for the first initializer to call NotificationStartup.
// NotificationModuleTokenGdiplus: GDI+ itself owns the hidden window - i.e.
//     the background thread is running.
 
enum NotificationModuleToken
{
    NotificationModuleTokenNobody,
    NotificationModuleTokenGdiplus,
    NotificationModuleTokenMax = NotificationModuleTokenGdiplus
};

BOOL InitializeDirectDrawGlobals(void);

#endif // __GLOBALS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\precomp.hpp ===
#include "..\Runtime\runtime.hpp"

#include "common.hpp"

// We shouldn't need this, but some of the files do.
// I think this is because they don't belong in the Common directory.

#include "..\..\ddkinc\ddiplus.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\testcontrol.cpp ===
#include "precomp.hpp"

namespace Globals
{
    BOOL ForceBilinear;
    BOOL NoICM;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\testcontrol.hpp ===
#ifndef _TESTCONTROL_HPP
#define _TESTCONTROL_HPP

namespace Globals
{
    extern BOOL ForceBilinear;
    extern BOOL NoICM;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\rasterizer.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Rasterizer.hpp
*
* Abstract:
*
*   GpRasterizer class definition (and supporting classes)
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/

#ifndef _RASTERIZER_HPP
#define _RASTERIZER_HPP

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.
//
// QUOTIENT_REMAINDER_64_32 takes a 64-bit numerator and produces 32-bit 
// results.

#if defined(_USE_X86_ASSEMBLY)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#define QUOTIENT_REMAINDER_64_32(ullNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                                            \
    ULONG ulNumeratorLow = *((ULONG*) &ullNumerator);                        \
    ULONG ulNumeratorHigh = *((ULONG*) &ullNumerator + 1);                   \
    __asm mov eax, ulNumeratorLow                                            \
    __asm mov edx, ulNumeratorHigh                                           \
    __asm div ulDenominator                                                  \
    __asm mov ulQuotient, eax                                                \
    __asm mov ulRemainder, edx                                               \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#define QUOTIENT_REMAINDER_64_32(ullNumerator, ulDenominator, ulQuotient, ulRemainder)\
{                                                                            \
    ulQuotient = (ULONG) ((ULONGLONG) ullNumerator / (ULONG) ulDenominator); \
    ulRemainder = (ULONG) ((ULONGLONG) ullNumerator % (ULONG) ulDenominator);\
}

#endif

enum GpVectorDirection
{
    VectorGoingDown = -1,
    VectorHorizontal = 0,
    VectorGoingUp   =  1,
};

// This class does a y (vertical) DDA from (x1,y1) to (x2,y2), where y1 < y2.
// Horizontal lines are not handled.
//
// It is up to the caller to keep track of the current y value.  This class
// advances and keeps track of the current x value.  The Advance method should
// be called once for each increment of y.
//
// For fill algorithms (such as a winding fill), this class will also keep
// track of the original direction of the vector, if desired.

class GpYDda
{
protected:
    INT                 Error;      // DDA cumulative error
    INT                 ErrorUp;    // DDA constant 1
    INT                 YDelta;     // DDA constant 2
    INT                 YMax;       // greatest y value (last scan line)
    INT                 XInc;       // DDA X Increment
    INT                 XCur;       // current position
    GpVectorDirection   Direction;  // VectorGoingUp or VectorGoingDown

public:
    GpYDda() { /* we need a constructor with no params */ }
    GpYDda(
        FIX4                x1,
        FIX4                y1,
        FIX4                x2,
        FIX4                y2,
        GpVectorDirection   direction = VectorGoingDown
        )
    {
        Init(x1, y1, x2, y2, direction);
    }
    virtual ~GpYDda() {}

    virtual VOID
    Init(
        FIX4                x1,
        FIX4                y1,
        FIX4                x2,
        FIX4                y2,
        GpVectorDirection   direction = VectorGoingDown
        );

    virtual VOID Advance();

    BOOL DoneWithVector (INT y)
    {
        if (y < this->YMax)
        {
            Advance();
            return FALSE;
        }
        return TRUE;
    }

    INT GetX()
    {
        return this->XCur;
    }

    GpVectorDirection GetDirection()
    {
        return Direction;
    }

    virtual GpYDda * CreateYDda()
    {
        return new GpYDda();
    }
};

// Interface class for outputing a single span of a single raster at a time.
// When all the spans on a raster have been output, the EndRaster method
// is invoked.  When all rasterization for all rasters is complete, the
// End method is invoked.

template<class T> class EpScanBufferNative;
#define DpScanBuffer EpScanBufferNative<ARGB>


struct DpBrush;
class DpContext;

// [agodfrey]
//   * "Dp" should be "Ep" in this hierarchy.
//
//   There are two types of class which use this interface - 
//   "leaf" classes which actually produce the colors from the brush,
//   and "forwarding" ones which modify the input somehow, then forward it
//   down to an object of another DpOutputSpan class. The "leaf" ones
//   call Scan->NextBuffer, the "forwarding" ones can't. So my suggestion:
//
//   * Make just two subclasses of DpOutputSpan, one for each type.
//     Derive the rest of them from one of those two, instead of directly
//     from DpOutputSpan.

class DpOutputSpan
{
public:
    virtual ~DpOutputSpan() {}

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        ) = 0;

    virtual GpStatus EndRaster()   // no more spans on this raster
    {
        return Ok;
    }

    virtual GpStatus End()      // all done rasterizing everything
    {
        return Ok;
    }

    // !!! PERF [agodfrey]: I don't think this needs to be virtual.
    //     All the implementations seem to return "Scan" - just move the Scan
    //     pointer into the base class. DpClipRegion can just leave it NULL.

    virtual DpScanBuffer* GetScanBuffer()
    {
        return NULL;
    }

    virtual BOOL IsValid() const = 0;

    static DpOutputSpan * Create(
        const DpBrush * brush,
        DpScanBuffer * scan,
        DpContext * context,
        const GpRect * drawBounds=NULL);
};

typedef GpStatus (DpOutputSpan::*DpOutputSpanFunction)(INT, INT&, INT&);

// Interface class for outputing a series of rects within a Y Span.
class GpOutputYSpan
{
public:
    virtual ~GpOutputYSpan() {}
    virtual GpStatus OutputYSpan(
        INT             yMin,
        INT             yMax,
        INT *           xCoords,    // even number of X coordinates
        INT             numXCoords  // must be a multiple of 2
        ) = 0;
};

//#define USE_YSPAN_BUILDER
#ifndef USE_YSPAN_BUILDER
// Interface class for outputing a rect at a time.  Used by GpRectBuilder class.
class GpOutputRect
{
public:
    virtual ~GpOutputRect() {}
    virtual GpStatus OutputRect(
        INT             xMin,
        INT             yMin,
        INT             xMax,
        INT             yMax
        ) = 0;
};

// Builds up and outputs Y Span rects from single span inputs
class GpRectBuilder : public DpOutputSpan,  // input
                      public GpOutputYSpan  // output
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag       Tag;            // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGpRectBuilder : ObjectTagInvalid;
    }

protected:
    DynIntArray     RectXCoords;    // currently built rects
    DynIntArray     RasterXCoords;  // x coords of current raster so far
    INT             RasterY;        // y value of current raster
    INT             RectYMin;       // starting y value of current rects
    INT             RectHeight;     // height of current rects
    GpOutputYSpan * FlushRects;     // Used to output the RectXCoords buffer
    GpOutputRect  * RenderRect;     // Used by FlushRects to ouput each rect

protected:
    GpStatus InitArrays();

public:
    // You can choose to output a single rect at a time with this constructor,
    // or if you use the other constructor it will output an entire Y Span
    // at a time.
    GpRectBuilder(GpOutputRect * renderRect);
    GpRectBuilder(GpOutputYSpan * flushRects);
    virtual ~GpRectBuilder()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGpRectBuilder) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GpRectBuilder");
        }
    #endif

        return (Tag == ObjectTagGpRectBuilder);
    }

    // This method is the input of spans to this class
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual GpStatus EndRaster();
    virtual GpStatus End();

    // Default version to output 1 rect at a time
    virtual GpStatus OutputYSpan(
        INT             yMin,
        INT             yMax,
        INT *           xCoords,    // even number of X coordinates
        INT             numXCoords  // must be a multiple of 2
        );
};
#else
// Builds up and outputs Y Span rects from single span inputs
class GpYSpanBuilder : public DpOutputSpan  // input
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag       Tag;            // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGpYSpanBuilder : ObjectTagInvalid;
    }

protected:
    DynIntArray     XCoords;        // x coords of current raster so far
    INT             Y;              // y value of current raster
    GpOutputYSpan * Output;

public:
    GpYSpanBuilder(GpOutputYSpan * output);
    virtual ~GpYSpanBuilder()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGpYSpanBuilder) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GpYSpanBuilder");
        }
    #endif

        return (Tag == ObjectTagGpYSpanBuilder);
    }

    // This method is the input of spans to this class
    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        );

    virtual GpStatus EndRaster();
};
#endif

class DpPath;
class DpClipRegion;
struct DpPen;
class RasterizeVector;

GpStatus
ConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            dda1,
    GpYDda *            dda2,
    DpOutputSpan *      output,
    const GpRect *      clipBounds
    );

GpStatus
NonConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            left,
    GpYDda *            right,
    DpOutputSpan *      output,
    const GpRect *      clipBounds,
    BOOL                useAlternate
    );

GpStatus
Rasterizer(
    const DpPath *      path,
    const GpMatrix *    matrix,
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    REAL                dpiX        = 0,
    REAL                dpiY        = 0,
    const GpRect *      clipBounds  = NULL,
    GpYDda *            yDda        = NULL,
    DpEnumerationType   type        = Flattened,
    const DpPen *       pen         = NULL
    );

GpStatus
Rasterize(
    const DpPath *      path,
    GpMatrix *          matrix,
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    DpClipRegion *      clipRegion,
    const GpRect *      drawBounds,
    REAL                dpiX,
    REAL                dpiY,
    GpYDda *            yDda        = NULL,
    DpEnumerationType   type        = Flattened,
    const DpPen *       pen         = NULL
    );

#endif // _RASTERIZER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\rasterizer.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Rasterizer.cpp
*
* Abstract:
*
*   GpRasterizer class implementation (and supporting classes)
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Initialize the vector's DDA info.
*   Assumes y1 < y2.
*
* Arguments:
*
*   [IN] x1        - starting fixed-point x coordinate of vector
*   [IN] y1        - starting fixed-point y coordinate of vector
*   [IN] x2        - ending   fixed-point x coordinate of vector
*   [IN] y2        - ending   fixed-point y coordinate of vector
*   [IN] direction - VectorGoingUp or VectorGoingDown
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
VOID 
GpYDda::Init(
    FIX4                x1, 
    FIX4                y1, 
    FIX4                x2, 
    FIX4                y2,
    GpVectorDirection   direction
    )
{
    ASSERT ((direction == VectorGoingUp) || (direction == VectorGoingDown));

    FIX4        xDelta = x2 - x1;
    FIX4        yDelta = y2 - y1;

    ASSERT (yDelta > 0);

    YDelta = yDelta;

    // Set up x increment
    INT     quotient;
    INT     remainder;

    // Error is initially 0, but we add yDelta - 1 for the ceiling,
    // but then subtract off yDelta so that we can check the sign
    // instead of comparing to yDelta.
    Error = -1;

    if (xDelta < 0)
    {
        xDelta = -xDelta;
        if (xDelta < yDelta)  // y-major
        {
            XInc    = -1;
            ErrorUp = yDelta - xDelta;
        }
        else                    // x-major
        {
            QUOTIENT_REMAINDER (xDelta, yDelta, quotient, remainder);

            XInc    = -quotient;
            ErrorUp = remainder;
            if (remainder != 0)
            {
                XInc--;
                ErrorUp = yDelta - remainder;
            }
        }
    }
    else
    {
        if (xDelta < yDelta)  // y-major
        {
            XInc    = 0;
            ErrorUp = xDelta;
        }
        else                    // x-major
        {
            QUOTIENT_REMAINDER (xDelta, yDelta, quotient, remainder);

            XInc    = quotient;
            ErrorUp = remainder;
        }
    }
    // See if we need to advance to an integer coordinate
    if ((y1 & FIX4_MASK) != 0)
    {
        INT     i;

        for (i = FIX4_ONE - (y1 & FIX4_MASK); i > 0; i--)
        {
            x1 += XInc;
            Error += ErrorUp;
            if (Error >= 0)
            {
                Error -= yDelta;
                x1++;
            }
        }
        // y1 += FIX4_MASK;
    }
    if ((x1 & FIX4_MASK) != 0)
    {
        Error -= yDelta * (FIX4_ONE - (x1 & FIX4_MASK));
        x1 += FIX4_MASK;      // to get the ceiling
    }
    Error   >>= FIX4_PRECISION;
    Direction = direction;
    XCur      = x1 >> FIX4_PRECISION;
    YMax      = GpFix4Ceiling (y2) - 1;

} // End of GpYDda::Init()

/**************************************************************************\
*
* Function Description:
*
*   Advance the DDA to the next raster.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
VOID
GpYDda::Advance()
{
    XCur  += XInc;
    Error += ErrorUp;

    if (Error >= 0)
    {
        Error -= YDelta;
        XCur++;
    }
}

#ifndef USE_YSPAN_BUILDER
/**************************************************************************\
*
* Function Description:
*
*   Construct a GpRectBuilder object that will output 1 rect at a time
*
* Arguments:
*
*   [IN] renderRect - a class that outputs a single rect at a time
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpRectBuilder::GpRectBuilder(
    GpOutputRect * renderRect
    )
{
    ASSERT(renderRect);
    SetValid(FALSE);
    if ((renderRect != NULL) && (InitArrays() == Ok))
    {
        SetValid(TRUE);
        FlushRects = this;
        RenderRect = renderRect;
        RectYMin   = 0x7FFFFFFF;
        RectHeight = 0;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a GpRectBuilder object that will output a set of rects in a
*   YSpan (YMin to YMax) at a time.
*
* Arguments:
*
*   [IN] flushRects - a class that outputs a Y span at a time
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpRectBuilder::GpRectBuilder(
    GpOutputYSpan * flushRects
    )
{
    ASSERT(flushRects);
    SetValid(FALSE);
    if ((flushRects != NULL) && (InitArrays() == Ok))
    {
        SetValid(TRUE);
        FlushRects = flushRects;
        RenderRect = NULL;
        RectYMin   = 0x7FFFFFFF;
        RectHeight = 0;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the Rect and Raster arrays that will build up a set of
*   X Coordinates within a Y span.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::InitArrays()
{

    GpStatus    status;
    
    status = RectXCoords.ReserveSpace(16);
    if (status == Ok)
    {
        status = RasterXCoords.ReserveSpace(16);
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster.  Is called by the rasterizer.
*   These spans provide the input for the rect builder.
*
* Arguments:
*
*   [IN] y    - the Y value of the raster being output
*   [IN] xMin - the X value of the left edge
*   [IN] xMax - the X value of the right edge (exclusive)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::OutputSpan(
    INT y,
    INT xMin,
    INT xMax     // xMax is exclusive
    )
{
    ASSERT (xMin < xMax);

    INT *       xCoords;
    
    RasterY = y;
    
    // Test here if xMin == previous xMax and combine spans.
    // Some polygons (like the letter W) could benefit from such a check.
    // NT4 doesn't handle regions with adjacent spans that aren't combined.
    if ((RasterXCoords.GetCount() == 0) || (RasterXCoords.Last() != xMin))
    {
        if ((xCoords = RasterXCoords.AddMultiple(2)) != NULL)
        {
            xCoords[0] = xMin;
            xCoords[1] = xMax;
            return Ok;
        }
        return OutOfMemory;
    }
    else
    {
        RasterXCoords.Last() = xMax;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by the rasterizer when all the spans of a raster (Y value)
*   have been output.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::EndRaster()
{
    INT         rectXCount    = RectXCoords.GetCount();
    INT         rasterXCount  = RasterXCoords.GetCount();
    INT *       rasterXCoords = RasterXCoords.GetDataBuffer();
    GpStatus    status        = Ok;
    
    if (rectXCount != 0)
    {
        INT *       rectXCoords = RectXCoords.GetDataBuffer();

        if ((RasterY == (RectYMin + RectHeight)) &&
            (rasterXCount == rectXCount))
        {
            if (rasterXCount == 2)
            {
                if ((rasterXCoords[0] == rectXCoords[0]) &&
                    (rasterXCoords[1] == rectXCoords[1]))
                {
FoundRectMatch:
                    RasterXCoords.Reset(FALSE);
                    RectHeight++;
                    return Ok;
                }
            }
            else if (GpMemcmp(rasterXCoords, rectXCoords, 
                              rectXCount * sizeof(INT)) == 0)
            {
                goto FoundRectMatch;
            }
        }
        status = FlushRects->OutputYSpan(
                    RectYMin, 
                    RectYMin + RectHeight,
                    rectXCoords,
                    rectXCount);
    }
                        
    // if we get here, either the RectXCoords is empty or 
    // it has just been flushed
    RectXCoords.Reset(FALSE);
    if (rasterXCount > 0)
    {
        status = static_cast<GpStatus>
            (status | RectXCoords.AddMultiple(rasterXCoords, rasterXCount));
        RasterXCoords.Reset(FALSE);
        RectHeight = 1;
        RectYMin   = RasterY;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by the rasterizer when all the spans of all the rasters
*   have been output.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::End()
{
    INT         rectXCount = RectXCoords.GetCount();

    if (rectXCount != 0)
    {
        return FlushRects->OutputYSpan(
                    RectYMin, 
                    RectYMin + RectHeight,
                    RectXCoords.GetDataBuffer(),
                    rectXCount);
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   If the rect builder was constructed to output 1 rect at a time, then
*   this method is called to do that after a Y span is completed.
*
* Arguments:
*
*   [IN] yMin       - top of the Y span
*   [IN] yMax       - bottom of the Y span
*   [IN] xCoords    - array of x coordinates
*   [IN] numXCoords - number of x coordinates (>= 2, multiple of 2)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpRectBuilder::OutputYSpan(
    INT             yMin, 
    INT             yMax, 
    INT *           xCoords,    // even number of X coordinates
    INT             numXCoords  // must be a multiple of 2
    )
{
    ASSERT (yMin < yMax);
    ASSERT (xCoords);
    ASSERT ((numXCoords >= 2) && ((numXCoords & 0x00000001) == 0))

    GpStatus        status;
    INT             i = 0;

    do
    {
        status = RenderRect->OutputRect(
                        xCoords[i], 
                        yMin, 
                        xCoords[i+1], 
                        yMax);
        i += 2;
    } while ((i < numXCoords) && (status == Ok));

    return status;
}
#else
/**************************************************************************\
*
* Function Description:
*
*   Construct a GpYSpanBuilder object that will output one YSpan 
*   (YMin to YMax) at a time.
*
* Arguments:
*
*   [IN] output - a class that outputs a Y span at a time
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpYSpanBuilder::GpYSpanBuilder(
    GpOutputYSpan *     output
    )
{
    ASSERT(output);
    SetValid(FALSE);
    if (output != NULL)
    {
        Output = output;
        SetValid(XCoords.ReserveSpace(16) == Ok);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs a single span within a raster.  Is called by the rasterizer.
*   These spans provide the input for the rect builder.
*
* Arguments:
*
*   [IN] y    - the Y value of the raster being output
*   [IN] xMin - the X value of the left edge
*   [IN] xMax - the X value of the right edge (exclusive)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpYSpanBuilder::OutputSpan(
    INT y,
    INT xMin,
    INT xMax    // xMax is exclusive
    )
{
    ASSERT (xMin < xMax);

    INT *       xCoords;
    
    Y = y;
    
    if ((xCoords = XCoords.AddMultiple(2)) != NULL)
    {
        xCoords[0] = xMin;
        xCoords[1] = xMax;
        return Ok;
    }
    return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by the rasterizer when all the spans of a raster (Y value)
*   have been output.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus 
GpYSpanBuilder::EndRaster()
{
    INT         count = XCoords.GetCount();
    
    // count can be 0
    if (count >= 2)
    {
        INT         y = Y;
        GpStatus    status = Output->OutputYSpan(y, y + 1, 
                                       XCoords.GetDataBuffer(), count);

        XCoords.Reset(FALSE);
        return status;
    }
    return Ok;
}
#endif // USE_YSPAN_BUILDER

/**************************************************************************\
*
* Macro Description:
*
*   Add a newly identified vector to the VectorList.  Keep track of the
*   direction of the vector, in case we're using the winding rule.  Put
*   the min y value in y1, so we can sort the vectors by min y.  Keep track
*   of the min and max y values for the entire list of vectors.
*
*   Don't add the vector if this is a horizontal (or near-horizontal) line.
*   We don't scan-convert horizontal lines.  Note that this check will also
*   fail if the two points are identical.
*
* Arguments:
*
*   [IN] x1 - starting fixed-point x coordinate of vector
*   [IN] y1 - starting fixed-point y coordinate of vector
*   [IN] x2 - ending   fixed-point x coordinate of vector
*   [IN] y2 - ending   fixed-point y coordinate of vector
*
*   [OUT] yMin       - set to min of yMin and least y of y1, y2
*   [OUT] yMax       - set to max of yMax and greatest y of y1, y2
*   [OUT] numVectors - incremented by 1
*   [OUT] vector     - incremented by 1
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
#define ADDVECTOR_SETYBOUNDS(x1,y1,x2,y2,yMin,yMax,numVectors,vector,dir) \
    if (GpFix4Ceiling(y1) != GpFix4Ceiling(y2))                           \
    {                                                                     \
        if ((y1) <= (y2))                                                 \
        {                                                                 \
            if ((y2) > (yMax))                                            \
            {                                                             \
                (yMax) = (y2);                                            \
            }                                                             \
            if ((y1) < (yMin))                                            \
            {                                                             \
                (yMin) = (y1);                                            \
            }                                                             \
            dir = VectorGoingDown;                                        \
            vector->Set((x1),(y1),(x2),(y2),VectorGoingDown);             \
        }                                                                 \
        else                                                              \
        {                                                                 \
            if ((y1) > (yMax))                                            \
            {                                                             \
                (yMax) = (y1);                                            \
            }                                                             \
            if ((y2) < (yMin))                                            \
            {                                                             \
                (yMin) = (y2);                                            \
            }                                                             \
            dir = VectorGoingUp;                                          \
            vector->Set((x2),(y2),(x1),(y1),VectorGoingUp);               \
        }                                                                 \
        (numVectors)++;                                                   \
        (vector)++;                                                       \
    }

// Used by Rasterizer to keep track of each vector in a path.
class RasterizeVector
{
public:
    FIX4                X1;
    FIX4                Y1;             // Min Y
    FIX4                X2;
    FIX4                Y2;             // Max Y
    GpVectorDirection   Direction;      // VectorGoingUp or VectorGoingDown
    
    VOID Set(FIX4 x1, FIX4 y1, FIX4 x2, FIX4 y2, GpVectorDirection direction)
    {
        X1 = x1;
        Y1 = y1;
        X2 = x2;
        Y2 = y2;
        Direction = direction;
    }
};

typedef DynArray<RasterizeVector> DynVectorArray;

/**************************************************************************\
*
* Function Description:
*
*   Rasterizer for non-convex polygons.
*
*   Rasterize a path into a set of spans on each raster (Y value) that the
*   path intersects.  The specified output object is used to output the spans.
*   The Y values of the specified clip bounds (if any) are used to speed the 
*   rasterization process by avoiding the processing of vectors that are 
*   outside those bounds.  However, it is assumed that at least part of the
*   path is visible in the vertical span of the clip bounds.
*
*   This algorithm is based on the one documented in 
*   Foley & Van Dam, Version 1, pp. 456 - 460.
*
*   Starting with the min y value and ending with the max y value, each
*   raster (Y value) is rasterized (output) one at a time.
*
*   (1) On each raster, check to see if new vectors need to be added to
*       the ActiveVectorList.  When an vector is added, DDA information about
*       that vector is computed so that the intersection of that vector with
*       each raster can be computed.
*
*   (2) Sort the ActiveVectorList in order of increasing x.
*
*   (3) Using either the alternate rule or the winding rule, output the span
*       between the appropriate vectors.
*
*   (4) Remove any vectors from the ActiveVectorList for which the current
*       raster is the max y of the vector.
*
*   (5) Calculate the intersection of the next raster with all the vectors
*       that are still in the ActiveVectorList (i.e. advance their DDAs).
*
* Arguments:
*
*   [IN] yMin                - the min y value of the set of vectors
*   [IN] yMax                - the max y value of the set of vectors
*   [IN] numVectors          - the number of vectors in the vector list
*   [IN] vectorList          - the list of vectors to rasterize
*   [IN] sortedVectorIndices - vector list sorted by increasing y
*   [IN] left                - a dda object to use
*   [IN] right               - a dda object to use
*   [IN] output              - used to output the spans of the rasterization
*   [IN] clipBounds          - clipbounds (if any) to use to speed the process
*   [IN] useAlternate        - whether or not to use the alternate rule
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/

GpStatus
NonConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            left,
    GpYDda *            right,
    DpOutputSpan *      output,
    const GpRect *      clipBounds,
    BOOL                useAlternate
    )
{
    GpStatus                    status = Ok;
    INT                         yMinClipped = yMin;     // used for clipping
    INT                         yMaxClipped = yMax;     // used for clipping
    INT                         y;
    INT                         xMin;
    INT                         xMax;
    INT                         sortedVectorIndex = 0;  // idx to sortedVectorIndices
    RasterizeVector *           vector;
    INT                         i;
    INT                         count;
    INT                         numActiveVectors = 0;   // num used in ActiveVectorList
    DynArrayIA<GpYDda *, 16>    activeVectorList;       // active GpYDda vectors
    GpYDda **                   activeVectors;
    GpYDda *                    activeVector;
        
    activeVectors = reinterpret_cast<GpYDda **>
                            (activeVectorList.AddMultiple(2));
                                            
    if (activeVectors == NULL)
    {
        delete left;
        delete right;
        return OutOfMemory;
    }
            
    activeVectors[0] = left;
    activeVectors[1] = right;
    
    if (clipBounds != NULL)
    {
        yMinClipped = clipBounds->Y;
        yMaxClipped = clipBounds->GetBottom();

        // There are a few cases where this can happen legitimately.
        // For example, the transformed bounds of an object could be
        // partially in the clip area although the object isn't. 
        // Also, a Bezier control point might be in the clip area while
        // the actual curve isn't.
        if ((yMin > yMaxClipped) || (yMax < yMinClipped))
        {
            goto DoneNotConvex;
        }

        if (yMaxClipped > yMax)
        {
            yMaxClipped = yMax;
        }

        if (yMinClipped > yMin)
        {
            while (sortedVectorIndex < numVectors)
            {
                vector = vectorList + sortedVectorIndices[sortedVectorIndex];

                if (GpFix4Ceiling(vector->Y2) >= yMinClipped)
                {
                    yMin = GpFix4Ceiling(vector->Y1);
                    break;
                }
                sortedVectorIndex++;
            }
        }
    }

    for (y = yMin; (y <= yMaxClipped); y++)
    {
        // Add any appropriate new vectors to the active vector list
        while (sortedVectorIndex < numVectors)
        {
            vector = vectorList + sortedVectorIndices[sortedVectorIndex];

            if (GpFix4Ceiling(vector->Y1) != y)
            {
                break;
            }

            // Clip the vector (but only against Y or 
            // we wouldn't get the right number of runs)
            if (GpFix4Ceiling(vector->Y2) >= yMinClipped)
            {
                if (numActiveVectors < activeVectorList.GetCount())
                {
                    activeVector = activeVectors[numActiveVectors];
                }
                else
                {
                    activeVector = left->CreateYDda();
            
                    if ((activeVector == NULL) || 
                        (activeVectorList.Add(activeVector) != Ok))
                    {
                        delete activeVector;
                        status = OutOfMemory;
                        goto DoneNotConvex;
                    }
                    // adding the vector could change the data buffer
                    activeVectors = reinterpret_cast<GpYDda **>
                                        (activeVectorList.GetDataBuffer());
                }

                activeVector->Init(
                    vector->X1, 
                    vector->Y1, 
                    vector->X2, 
                    vector->Y2, 
                    vector->Direction);

                numActiveVectors++;
            }
            sortedVectorIndex++;
        }

        if (y >= yMinClipped)
        {
            // Make sure the activeVectorList is sorted in order of 
            // increasing x.  We have to do this every time, even if
            // we haven't added any new active vectors, because the
            // slopes of the lines can be different, which means they
            // could cross.
            for (count = 1; count < numActiveVectors; count++)
            {
                i = count;
                do
                {
                    if (activeVectors[i]->GetX() >= 
                        activeVectors[i-1]->GetX())
                    {
                        break;
                    }

                    activeVector       = activeVectors[i-1];
                    activeVectors[i-1] = activeVectors[i];
                    activeVectors[i]   = activeVector;
            
                } while (--i > 0);
            }

            // fill the appropriate pixels on the current scan line
            if (useAlternate)
            {
                // Use the alternating rule (also known as even/odd rule)
                // to output the spans of a raster between the intersections
                // of the vectors with the current scan line.
                //
                // The alternating rule means that a raster pattern is drawn 
                // between the 1st and 2nd points and between the 3rd and 
                // 4th points, etc., but not between the 2nd and 3rd points
                // or between the 4th and 5th points, etc.
                //
                // There could be an odd number of points; for example:
                //
                //      9       /\
                //      8      /  \
                //      7     /    \
                //      6    /      \
                //      5   /        \
                //      4  /----------\--------/
                //      3              \      /
                //      2               \    /
                //      1                \  /
                //      0                 \/
                //
                // On raster y==4, there are 3 points, so the 2nd half of 
                // the raster does not get output.

                for (i = 1; (i < numActiveVectors); i += 2)
                {
                    xMin = activeVectors[i-1]->GetX();
                    xMax = activeVectors[i]->GetX();
        
                    // Make sure the X's aren't equal
                    if (xMin < xMax)
                    {
                        if (output->OutputSpan(y, xMin, xMax) != Ok)
                        {
                            status = GenericError;
                            goto DoneNotConvex;
                        }
                    }
                }
            }
            else    // Winding
            {
                GpYDda *    leftEdge;
                GpYDda *    rightEdge;
                INT         j;
                INT         direction = 0;  // num times going up and down
    
                // There's got to be the same number of lines
                // going up as going down before drawing the
                // scan line.
                for (count = 1; (count < numActiveVectors); count = j + 2)
                {
                    leftEdge = activeVectors[count - 1];

                    direction += static_cast<INT>(leftEdge->GetDirection());

                    for (j = count; (j < numActiveVectors); j++)
                    {
                        rightEdge = activeVectors[j];

                        direction += static_cast<INT>
                                        (rightEdge->GetDirection());

                        if (direction == 0)
                        {
                            xMin = leftEdge->GetX();
                            xMax = rightEdge->GetX();
                
                            // Make sure the X's aren't equal
                            if (xMin < xMax)
                            {
                                if (output->OutputSpan(y, xMin, xMax) != Ok)
                                {
                                    status = GenericError;
                                    goto DoneNotConvex;
                                }
                            }
                            break;
                        }
                    }
                }
            }
            if (output->EndRaster() != Ok)
            {
                status = GenericError;
                goto DoneNotConvex;
            }
        }

        // remove any appropriate vectors from the active vector list
        // and advance all the DDAs
        {
            INT         activeIndex = 0;
            VOID *      removedActiveVector;

            while (activeIndex < numActiveVectors)
            {
                activeVector = activeVectors[activeIndex];

                if (activeVector->DoneWithVector(y))
                {
                    numActiveVectors--;

                    if (numActiveVectors > activeIndex)
                    {
                        GpMemmove(
                            &(activeVectors[activeIndex]), 
                            &(activeVectors[activeIndex + 1]), 
                            (numActiveVectors - activeIndex) * 
                            sizeof(activeVectors[0]));
                    }
                    activeVectors[numActiveVectors] = activeVector;
                }
                else
                {
                    activeIndex++;
                }
            }
        }
    }
    status = output->End();

DoneNotConvex:
    numActiveVectors = activeVectorList.GetCount();
        
    ASSERT(numActiveVectors > 0);
    activeVectors = reinterpret_cast<GpYDda **>
                            (activeVectorList.GetDataBuffer());

    do
    {
        delete activeVectors[--numActiveVectors];
    } while (numActiveVectors > 0);
    
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Rasterizer for convex polygons.
*
*   Uses basically the same algorithm to rasterize, but has a few optimizations
*   for when we know the polygon is convex.  We know there will only be 2
*   active vectors at a time (and only 2).  Even though they may cross each
*   other, we don't bother sorting them.  We just check the X values instead.
*   These optimizations provide about a 15% increase in performance.
*
* Arguments:
*
*   [IN] yMin                - the min y value of the set of vectors
*   [IN] yMax                - the max y value of the set of vectors
*   [IN] numVectors          - the number of vectors in the vector list
*   [IN] vectorList          - the list of vectors to rasterize
*   [IN] sortedVectorIndices - vector list sorted by increasing y
*   [IN] left                - a dda object to use
*   [IN] right               - a dda object to use
*   [IN] output              - used to output the spans of the rasterization
*   [IN] clipBounds          - clipbounds (if any) to use to speed the process
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/24/1999 DCurtis
*
\**************************************************************************/
GpStatus
ConvexRasterizer(
    INT                 yMin,                   // min y of all vectors
    INT                 yMax,                   // max y of all vectors
    INT                 numVectors,             // num vectors in VectorList
    RasterizeVector *   vectorList,             // list of all vectors of path
    INT *               sortedVectorIndices,    // sorted list of vector indices
    GpYDda *            dda1,
    GpYDda *            dda2,
    DpOutputSpan *      output,
    const GpRect *      clipBounds
    )
{
    GpStatus            status = Ok;
    INT                 yMinClipped = yMin;     // used for clipping
    INT                 yMaxClipped = yMax;     // used for clipping
    INT                 y;
    INT                 x1;
    INT                 x2;
    INT                 sortedVectorIndex = 0;  // idx to sortedVectorIndices
    RasterizeVector *   vector1;
    RasterizeVector *   vector2;

    if (clipBounds != NULL)
    {
        yMinClipped = clipBounds->Y;
        yMaxClipped = clipBounds->GetBottom();

        // There are a few cases where this can happen legitimately.
        // For example, the transformed bounds of an object could be
        // partially in the clip area although the object isn't. 
        // Also, a Bezier control point might be in the clip area while
        // the actual curve isn't.
        if ((yMin > yMaxClipped) || (yMax < yMinClipped))
        {
            goto DoneConvex;
        }

        if (yMaxClipped > yMax)
        {
            yMaxClipped = yMax;
        }

        if (yMinClipped > yMin)
        {
            RasterizeVector *   vector;

            vector1 = NULL;
            while (sortedVectorIndex < numVectors)
            {
                vector = vectorList+sortedVectorIndices[sortedVectorIndex++];

                if (GpFix4Ceiling(vector->Y2) >= yMinClipped)
                {
                    if (vector1 == NULL)
                    {
                        vector1 = vector;
                    }
                    else
                    {
                        vector2 = vector;
                        goto HaveVectors;
                    }
                }
            }
            ASSERT(0);
            status = InvalidParameter;  // either not convex or clipped out
            goto DoneConvex;
        }
    }
    vector1 = vectorList + sortedVectorIndices[0];
    vector2 = vectorList + sortedVectorIndices[1];
    sortedVectorIndex = 2;

HaveVectors:
    dda1->Init(vector1->X1, vector1->Y1, 
               vector1->X2, vector1->Y2, 
               VectorGoingUp);

    dda2->Init(vector2->X1, vector2->Y1, 
               vector2->X2, vector2->Y2, 
               VectorGoingUp);

    // For clipping case, we have to advance the first vector to catch up
    // to the start of the 2nd vector.
    {
        yMin = GpFix4Ceiling(vector2->Y1);
        for (INT yMinVector1 = GpFix4Ceiling(vector1->Y1);
             yMinVector1 < yMin; yMinVector1++)
        {
            dda1->Advance();
        }
    }

    for (y = yMin; (y <= yMaxClipped); y++)
    {
        if (y >= yMinClipped)
        {
            // fill the appropriate pixels on the current scan line
            x1 = dda1->GetX();
            x2 = dda2->GetX();

            // Make sure the X's aren't equal before outputting span
            if (x1 < x2)
            {
                if (output->OutputSpan(y, x1, x2) == Ok)
                {
                    if (output->EndRaster() == Ok)
                    {
                        goto DoneCheck;
                    }
                }
                status = GenericError;
                goto DoneConvex;
            }
            else if (x1 > x2)
            {
                if (output->OutputSpan(y, x2, x1) == Ok)
                {
                    if (output->EndRaster() == Ok)
                    {
                        goto DoneCheck;
                    }
                }
                status = GenericError;
                goto DoneConvex;
            }
        }

DoneCheck:
        if (dda1->DoneWithVector(y))
        {
            if (sortedVectorIndex >= numVectors)
            {
                break;
            }
            vector1 = vectorList + sortedVectorIndices[sortedVectorIndex++];
            ASSERT(GpFix4Ceiling(vector1->Y1) == (y + 1));

            dda1->Init(vector1->X1, vector1->Y1, 
                       vector1->X2, vector1->Y2, 
                       VectorGoingUp);
        }
        if (dda2->DoneWithVector(y))
        {
            if (sortedVectorIndex >= numVectors)
            {
                ASSERT(0);
                break;
            }
            vector2 = vectorList + sortedVectorIndices[sortedVectorIndex++];
            ASSERT(GpFix4Ceiling(vector2->Y1) == (y + 1));

            dda2->Init(vector2->X1, vector2->Y1, 
                       vector2->X2, vector2->Y2, 
                       VectorGoingUp);
        }
    }
    status = output->End();

DoneConvex:
    delete dda1;
    delete dda2;
    return status;
}

#define NUM_ENUMERATE_POINTS    32


/**************************************************************************\
*
* Function Description:
*
*   Perform a simple partition sort on a list indexing into the vector list.
*   The result is a sorted index array keyed on the vertex array Y1 coordinate.
*   The index array is sorted in place and in ascending order.
*
* Arguments:
*
*   v is the vertex list.
*   F, L - First and Last pointer in the index array.
*
* Created:
*
*  09/16/2000 asecchia
*
\**************************************************************************/

void QuickSortIndex(
    RasterizeVector *v,
    int *F,
    int *L
)
{
    if(F < L)
    {
        // Find the median position.
        
        int median = *(F + (L-F)/2);
        
        int *i = F;
        int *j = L;
        
        while(i<j)
        {
            // seek for elements in the wrong partition.
            
            while(v[*i].Y1 < v[median].Y1) {i++;}
            while(v[*j].Y1 > v[median].Y1) {j--;}
            
            if(i>=j) { break; }
            
            // Swap.
            
            int temp = *i;
            *i = *j;
            *j = temp;
            
            // tie breaker - handle the case where [*i] == [*j] == [median], but
            // i != j. Only possible with multiple copies of the same entry.
            
            if(v[*i].Y1 == v[*j].Y1) { i++; }
        }
        
        // Call recursively for the two sub-partitions. The partitions don't 
        // include position i because it is correctly positioned.
        
        QuickSortIndex(v, F, i-1);
        QuickSortIndex(v, i+1, L);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the data needed for the rasterization and invoke the
*   appropriate rasterizer (convex or non-convex).
*
* Arguments:
*
*   [IN] path        - the path to rasterize
*   [IN] matrix      - the matrix to transform the path points by
*   [IN] fillMode    - the fill mode to use (Alternate or Winding)
*   [IN] output      - used to output the spans of the rasterization
*   [IN] clipBounds  - clipbounds (if any) to use to speed the process
*   [IN] yDda        - instance of DDA class to use
*   [IN] type        - type of enumeration
*   [IN] strokeWidth - for wide line rasterizing
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/15/1998 DCurtis
*
\**************************************************************************/
GpStatus
Rasterizer(
    const DpPath *      path, 
    const GpMatrix *    matrix, 
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    REAL                dpiX,
    REAL                dpiY,
    const GpRect *      clipBounds,
    GpYDda *            yDda,
    DpEnumerationType   type,
    const DpPen *       pen
    )
{
    ASSERT ((path != NULL) && (matrix != NULL) && (output != NULL));

    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    GpStatus            status = Ok;
    FIX4                yMin;                   // min y of all vectors
    FIX4                yMax;                   // max y of all vectors
    INT                 numVectors;             // num vectors in VectorList
    RasterizeVector *   vectorList = NULL;      // list of all vectors of path
    INT *               sortedVectorIndices;    // sorted list of vector indices
    GpYDda *            left;
    GpYDda *            right;
    GpPointF            pointsF[NUM_ENUMERATE_POINTS];
    BYTE                types[NUM_ENUMERATE_POINTS];
    INT                 count;
    INT                 estimateVectors;
    GpPathPointType     pointType;
    FIX4                xFirst;     // first point in sub-path
    FIX4                yFirst;
    FIX4                xStart;     // start point of a vector
    FIX4                yStart;
    FIX4                xEnd;       // end point of a vector
    FIX4                yEnd;
    RasterizeVector *   vector;
    INT                 i;
    GpVectorDirection   direction; 
    GpVectorDirection   newDirection;
    INT                 numDirections;
    BOOL                multipleSubPaths;

    BOOL isAntiAliased = FALSE;
    const DpPath* flattenedPath = path->GetFlattenedPath(
        matrix,
        type,
        pen
    );

    if(!flattenedPath)
        return OutOfMemory;

    DpPathIterator enumerator(flattenedPath->GetPathPoints(),
                        flattenedPath->GetPathTypes(),
                        flattenedPath->GetPointCount());

    if(!enumerator.IsValid())
    {
        // No need to rasterize.  Exit gracefully.

        goto Done;
    }

    estimateVectors = enumerator.GetCount() + 
                        enumerator.GetSubpathCount() - 1;

    // The estimate must be >= the actual number of points
    if (estimateVectors < 2)
    {
        goto Done;
    }

    // Allocate vectorList and sortedVectorIndices together
    vectorList = static_cast<RasterizeVector *>
                    (GpMalloc((estimateVectors * sizeof(RasterizeVector)) +
                            (estimateVectors * sizeof(INT))));
    if (vectorList == NULL)
    {
        status = OutOfMemory;
        goto Done;
    }
    sortedVectorIndices = reinterpret_cast<INT*>
                                (vectorList + estimateVectors);

    // enumerate the first set of points from the path
    count = enumerator.Enumerate(pointsF, types, NUM_ENUMERATE_POINTS);
    
    ASSERT (count <= NUM_ENUMERATE_POINTS);
        
    // We know we are done enumerating when we get back a 0 count
    if (count <= 0)
    {
        goto Done;
    }

    // Keep track of direction changes as a way to know if we can use
    // the convex rasterizer or not.  As long as there is only 1 sub-path
    // and there are at most 3 directions (e.g. down, up, down), 
    // we can use the convex rasterizer.
    direction           = VectorHorizontal;  
    newDirection        = VectorHorizontal;  
    numDirections       = 0; 
    multipleSubPaths    = FALSE;

    vector     = vectorList;
    numVectors = 0;

    xFirst = GpRealToFix4(pointsF[0].X);
    yFirst = GpRealToFix4(pointsF[0].Y);
            
    xStart = xEnd = xFirst;
    yStart = yEnd = yFirst;

    yMin = yMax = yFirst;

    // Add all the vectors to the vector list.  The vector list keeps
    // the coordinates as fixed point values (28.4).  As each one is
    // added, YMin and YMax are updated.

    // Each sub-path is automatically closed, even if it was not
    // specifically asked to be closed.
    for (i = 1;; i++)
    {
        if (i == count)
        {
            count = enumerator.Enumerate(pointsF, types, 32);
            ASSERT (count <= 32);
                    
            if (count <= 0)
            {
                // Close the last subpath, if necessary
                ADDVECTOR_SETYBOUNDS(xEnd, yEnd, xFirst, yFirst, yMin, yMax, 
                                     numVectors, vector, newDirection);
                ASSERT (numVectors <= estimateVectors);
                if(newDirection != direction)   // for convex test
                {
                    numDirections++;
                    direction = newDirection;
                }
                break;
            }
            i = 0;
        }
        pointType = static_cast<GpPathPointType>
                        (types[i] & PathPointTypePathTypeMask);

        if (pointType != PathPointTypeStart)
        {
            ASSERT(pointType == PathPointTypeLine);

            xEnd = GpRealToFix4(pointsF[i].X);
            yEnd = GpRealToFix4(pointsF[i].Y);

            ADDVECTOR_SETYBOUNDS (xStart, yStart, xEnd, yEnd, yMin, yMax, 
                                  numVectors, vector, newDirection);
            ASSERT (numVectors <= estimateVectors);
            if(newDirection != direction)   // for convex test
            {
                numDirections++;
                direction = newDirection;
            }
        }
        else    // it is a start point
        {
            // Close the previous subpath, if necessary
            ADDVECTOR_SETYBOUNDS(xEnd, yEnd, xFirst, yFirst, yMin, yMax, 
                                 numVectors, vector, newDirection);
            ASSERT (numVectors <= estimateVectors);

            xFirst = GpRealToFix4(pointsF[i].X);
            yFirst = GpRealToFix4(pointsF[i].Y);

            xEnd = xFirst;
            yEnd = yFirst;

            // Can't use convex rasterizer for more than one sub-path
            // unless we've specifically been told it's Ok to do so.
            multipleSubPaths = TRUE;
        }
        xStart = xEnd;
        yStart = yEnd;
    }

    if (numVectors < 2)
    {
        goto Done;
    }

    yMin = GpFix4Ceiling (yMin);       // convert to int
    yMax = GpFix4Ceiling (yMax) - 1;   // convert to int

    //  Initialize and sort the vector indices in order of 
    //  increasing yMin values.

    //  All the vectors must be set up first in the VectorList.
    
    // Initialize the index list.
    
    for(INT count = 0; count < numVectors; count++)
    {
        sortedVectorIndices[count] = count;
    }
    
    // Sort the index list.
    
    QuickSortIndex(
        vectorList, 
        &sortedVectorIndices[0], 
        &sortedVectorIndices[numVectors-1]
    );
    
    left = yDda;
    if (left == NULL)
    {
        left = new GpYDda();
                
        if (left == NULL)
        {
            status = OutOfMemory;
            goto Done;
        }
    }

    right = left->CreateYDda();
    if (right == NULL)
    {
        status = OutOfMemory;
        delete left;
        goto Done;
    }

    if ((flattenedPath->IsConvex()) ||
        ((!multipleSubPaths) && (numDirections <= 3)))
    {
        status = ConvexRasterizer(yMin, yMax, numVectors, vectorList,
                                  sortedVectorIndices, left, right,
                                  output, clipBounds);
    }
    else
    {
        status = NonConvexRasterizer(yMin, yMax, numVectors, vectorList,
                                     sortedVectorIndices, left, right,
                                     output, clipBounds, 
                                     (fillMode == FillModeAlternate));
    }

Done:
    GpFree(vectorList);
    delete flattenedPath;
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Rasterize a path into a set of spans on each raster (Y value) that the
*   path intersects.  The specified output object is used to output the spans.
*
*   First the clipping is looked at to determine if the path is visible.
*   If not, we're done.  If totally visible, no clipping needed.  Otherwise,
*   set up the clip region to handle the clipping of this path.  The output
*   method of the rasterizer is the clip region which then clips the span
*   before calling the real output method.
*
* Arguments:
*
*   [IN] path        - the path to rasterize
*   [IN] matrix      - the matrix to transform the path points by
*   [IN] fillMode    - the fill mode to use (Alternate or Winding)
*   [IN] output      - the object used to output the spans of the rasterization
*   [IN] clipRegion  - clip region to clip against (or NULL)
*   [IN] drawBounds  - bounds of the path in device units
*   [IN] yDda        - instance of DDA class to use
*   [IN] type        - type of enumeration
*   [IN] strokeWidth - for wide line rasterizing
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/
GpStatus
Rasterize(
    const DpPath *      path, 
    GpMatrix *          matrix, 
    GpFillMode          fillMode,
    DpOutputSpan *      output,
    DpClipRegion *      clipRegion,
    const GpRect *      drawBounds,
    REAL                dpiX,
    REAL                dpiY,
    GpYDda *            yDda,
    DpEnumerationType   type,
    const DpPen *       pen
    )
{
    ASSERT ((path != NULL) && (matrix != NULL) && (output != NULL));
    ASSERT ((clipRegion != NULL) && (drawBounds != NULL));
    
    GpRect      clipBounds;
    GpRect *    clipBoundsPointer = NULL;

    DpRegion::Visibility    visibility;
        
    visibility = clipRegion->GetRectVisibility(
                    drawBounds->X,
                    drawBounds->Y,
                    drawBounds->X + drawBounds->Width,
                    drawBounds->Y + drawBounds->Height);
                        
    switch (visibility)
    {
      case DpRegion::Invisible:
        return Ok;
            
      case DpRegion::TotallyVisible:    // No clipping needed
        break;
            
      default:                          // Need to clip
        clipRegion->GetBounds(&clipBounds);
        clipBoundsPointer = &clipBounds;
        clipRegion->InitClipping(output, drawBounds->Y);
        output = clipRegion;
        break;
    }
    
    GpStatus status = Rasterizer(path, matrix, fillMode, output, dpiX, dpiY,
                                 clipBoundsPointer, yDda, type, pen);

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\dpdriver.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*
*
* Abstract:
*
*
*
* Notes:
*
*
*
* Created:
*
*   //1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"

DpDriver::DpDriver()
{
    Internal = new DpDriverInternal;
    Device = NULL;

}

DpDriver::~DpDriver()
{
    delete Internal;

    SetValid(FALSE);    // so we don't use a deleted object
}

// If we let the clipping region height get too large, then GDI will allocate
// tons of memory when we select the clip path in.
#define GDI_MAX_REGION_HEIGHT_FOR_GDI   65536

// Returns TRUE if we succeed in setting the clipping using
// path clipping.
static BOOL
SetupPathClipping(
    HDC                 hdc,
    const DpContext *   context,
    BOOL                doSaveDC,
    const GpRect *      drawBounds
    )
{
    // We can use the actual clip path to set up the clipping
    // under the following circumstances:
    //      1) the application clipping has only one path
    //      2) the container clip is simple (a single rect)
    //         which either fully encompasses the application clipping
    //         or else the application clipping is also a single rect
    //         and the intersection of the 2 rects can be used.
    // We could expand this criteria to include more cases, but for
    // now, this is sufficient.

    const GpRegion *    appClip       = &(context->AppClip);
    const DpRegion *    containerClip = &(context->ContainerClip);

    if (appClip->IsOnePath() && containerClip->IsSimple())
    {
        // ContainerClip is a single rect
        // It may be inifinte, but it shouldn't be empty at this point.
        GpRect      pathRect;
        GpRect      containerBounds;
        GpRect      appBounds;
        GpMatrix    identityMatrix;

        containerClip->GetBounds(&containerBounds);
        appClip->GetBounds(&identityMatrix, &appBounds);
        if (appClip->IsRect())
        {
            GpRect::IntersectRect(pathRect, appBounds, containerBounds);
            if (doSaveDC)
            {
                ::SaveDC(hdc);
            }

            // Use IntersectClipRect (not BeginPath, Rectangle, EndPath),
            // because mf3216.dll assumes that
            // path clipping means do XOR, black, XOR technique, and
            // we don't want that if we are playing a metafile into
            // another metafile.

            ::IntersectClipRect(hdc,
                                pathRect.GetLeft(),
                                pathRect.GetTop(),
                                pathRect.GetRight(),
                                pathRect.GetBottom());
            return TRUE;
        }
        else  // use the AppClip as the clip path
        {
            ConvertPathToGdi gdiPath(appClip->GetPath(), &identityMatrix, ForFill);
            if (gdiPath.IsValid())
            {
                if (doSaveDC)
                {
                    ::SaveDC(hdc);
                }
                gdiPath.AndClip(hdc);
                if ((appBounds.GetLeft()   < containerBounds.GetLeft())  ||
                    (appBounds.GetRight()  > containerBounds.GetRight()) ||
                    (appBounds.GetTop()    < containerBounds.GetTop())   ||
                    (appBounds.GetBottom() > containerBounds.GetBottom()))
                {
                    ::IntersectClipRect(hdc,
                                        containerBounds.GetLeft(),
                                        containerBounds.GetTop(),
                                        containerBounds.GetRight(),
                                        containerBounds.GetBottom());
                }
                return TRUE;
            }
        }
    }
    else
    {
        const DpClipRegion *    clipRegion = &(context->VisibleClip);
        DpClipRegion            intersectClip(drawBounds);
        GpRect                  clipBounds;

        clipRegion->GetBounds(&clipBounds);

        // GDI doesn't handle large clip regions very well -- it uses
        // the height of the region to decide how much memory to allocate,
        // so can end up allocating huge amounts of memory.  An example
        // of this is to take an infinite region and exclude a rect from
        // it and then clip to that region.  To solve this problem,
        // intersect the clip region with the drawBounds (which are hopefully
        // a reasonable size).

        if (clipBounds.Height >= GDI_MAX_REGION_HEIGHT_FOR_GDI)
        {
            intersectClip.And(clipRegion);
            if (intersectClip.IsValid())
            {
                clipRegion = &intersectClip;
            }
        }

        GpPath      path(clipRegion);

        if (path.IsValid())
        {
            GpMatrix         identityMatrix;
            ConvertPathToGdi gdiPath(&path, &identityMatrix, ForFill);
            if (gdiPath.IsValid())
            {
                if (doSaveDC)
                {
                    ::SaveDC(hdc);
                }
                gdiPath.AndClip(hdc);
                return TRUE;
            }
        }
    }
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Set up the clipping in the HDC for the GDI primitive
*
* Arguments:
*
*   [IN]  hdc        - The device to set the clipping in
*   [IN]  clipRegion - The region to clip to
*   [IN]  drawBounds - The bounds of the object being drawn
*   [OUT] isClip     - Whether or not we are clipping the object
*
* Return Value:
*
*   N/A
*
* Created:
*
*   9/15/1999 DCurtis
*
\**************************************************************************/
VOID
DpDriver::SetupClipping(
    HDC                 hdc,
    DpContext *         context,
    const GpRect *      drawBounds,
    BOOL &              isClip,
    BOOL &              usePathClipping,
    BOOL                forceClipping
    )
{
    // VisibleClip is the combination of the AppClip and the ContainerClip.
    // The ContainerClip is always intersected with the WindowClip.
    DpClipRegion *      clipRegion = &(context->VisibleClip);

    // We set wantPathClipping to be what the user wants to do. This way
    // when we return usePathClipping is true only if we did indeed setup a
    // path clipping
    BOOL wantPathClipping = usePathClipping;
    usePathClipping = FALSE;
    isClip = FALSE;

    if (forceClipping ||
        (clipRegion->GetRectVisibility(
                    drawBounds->X, drawBounds->Y,
                    drawBounds->GetRight(),
                    drawBounds->GetBottom()) != DpRegion::TotallyVisible))
    {
        if (clipRegion->IsSimple())
        {
            isClip = TRUE;
            GpRect clipRect;
            clipRegion->GetBounds(&clipRect);
            ::SaveDC(hdc);

            // If we have an infinite region don't intersect
            if (!clipRegion->IsInfinite())
            {
                ::IntersectClipRect(hdc, clipRect.X, clipRect.Y,
                                    clipRect.GetRight(), clipRect.GetBottom());
            }
            return;
        }

        // I'm assuming that by now we've already decided that the
        // drawBounds is at least partially visible.  Otherwise, we're
        // going to a lot of trouble here for nothing.

        // When writing a metafile, we always want to use path clipping
        // so that the clipping scales properly when being played back.
        if (wantPathClipping)
        {
            if (SetupPathClipping(hdc, context, TRUE, drawBounds))
            {
                isClip = TRUE;
                usePathClipping = TRUE;
                return;
            }
        }

        // Either we're not supposed to use path clipping, or else
        // path clipping failed for some reason, so use the region
        // to clip.
        // Since this might get saved out to a metafile, we need
        // to Save the DC, and restore it once the clipping is back
        // so that we don't overwrite the application's clipping
        HRGN        hRgn = clipRegion->GetHRgn();
        if (hRgn != (HRGN)0)
        {
            ::SaveDC(hdc);
            ::ExtSelectClipRgn(hdc, hRgn, RGN_AND);
            ::DeleteObject(hRgn);
            isClip = TRUE;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore the clipping state in the HDC
*
* Arguments:
*
*   [IN]  hdc        - The device to set the clipping in
*   [IN]  isClip     - If clipping was turned on or not
*
* Return Value:
*
*   N/A
*
* Created:
*
*   9/15/1999 DCurtis
*
\**************************************************************************/
VOID
DpDriver::RestoreClipping(
    HDC                 hdc,
    BOOL                isClip,
    BOOL                usePathClipping
    )
{
    if (isClip)
    {
        // Restore the DC in both cases for PathClipping or
        // for region clipping
        ::RestoreDC(hdc, -1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\common\stackbuffer.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Dynamic array implementation of StackBuffer class
*
* Abstract:
*
*   This class provides a simple allocation scheme for a fixed size buffer.
*
*   First case.  Reserve of 128 bytes on the stack.
*   Second case.  Lookaside buffer, size equal to first usage of it.
*   Third case.  Allocate size on heap.
*
*   This is much less flexible than the DynamicArray class, the break up of
*   cost is basically as follows:
*
*     First case.  1 assignment + 2 compare (no allocation)
*     Second case. 1 assignment + 5 compare + 2 InterlockExchange's (pot. alloc)
*     Third case.  1 assignment + 4 compare + GpMalloc + GpFree
*
*   The cost is cheap for case one.  For case two, Lock + Unlock is small
*   and fast whereas case three is O(size of heap) in time.  There is also
*   the benefit of less fragmentation from fewer allocations.
*
*   If you are considering using this code elsewhere, please contact Andrew
*   Godfrey or Eric VandenBerg.  It is important this class be used properly
*   to ensure the performance benefit isn't adversely effected.
*
*   The initialization and clean up of lookaside buffer is done in 
*   InitializeGdiplus() and UninitializeGdiplus().
*
*   We provide the source here so it can be inlined easily.
*
\**************************************************************************/

#define INIT_SIZE       128         // 16 pairs of GpPoint types

class StackBuffer
{
private:
    BYTE buffer[INIT_SIZE];

    BYTE* allocBuffer;

public:
    StackBuffer()
    {
    }

    BYTE* GetBuffer(INT size)
    {
        if (size < 0)
        {
            return (allocBuffer = NULL);
        }
        else if (size<INIT_SIZE)
        {
            allocBuffer = NULL;
            return &buffer[0];
        }
        else if (size>Globals::LookAsideBufferSize)
        {
            return (allocBuffer = (BYTE*)GpMalloc(size));
        }
        else
        {
            if ((CompareExchangeLong_Ptr(&Globals::LookAsideCount, 1, 0) == 0)
                && Globals::LookAsideCount == 1)
            {
       
                if (Globals::LookAsideBuffer == NULL)
                {
                    Globals::LookAsideBufferSize = size + 128;
             
                    Globals::LookAsideBuffer = (BYTE*)GpMalloc(Globals::LookAsideBufferSize);
                }
       
                return (allocBuffer = Globals::LookAsideBuffer);
                // we have exclusive access to lookaside
            }
            else
            {
                return (allocBuffer = (BYTE*)GpMalloc(size));
            }
        }
       
    }
    
    ~StackBuffer()
    {
        if (allocBuffer != NULL)
        {    
             if (allocBuffer == Globals::LookAsideBuffer)
             {
                 ASSERT(Globals::LookAsideCount == 1);      // should be true

                 CompareExchangeLong_Ptr(&Globals::LookAsideCount, 0, 1);
             }
             else
             {    
                 GpFree(allocBuffer);
             }
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\dpdriverdata.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Driver-specific data
*
* Abstract:
*
*   This module gives drivers a way to attach private data to GDI+
*   objects. 
*
* Created:
*
*   3/18/1999 agodfrey
*
\**************************************************************************/

#include "precomp.hpp"

DpDriverDataList::~DpDriverDataList()
{
    DpDriverData *p=head;
    while (p)
    {
        DpDriverData *tmp = p->next;
        delete p;
        p = tmp;
    }
}

void DpDriverDataList::Add(DpDriverData *dd, DpDriver *owner)
{
    dd->owner = owner;
    dd->next = head;
    head = dd;
}
    
DpDriverData *DpDriverDataList::GetData(DpDriver *owner)
{
    DpDriverData *p=head;
    while (p)
    {
        if (p->owner == owner)
        {
            return p;
        }
        p = p->next;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\dpdriverdata.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Driver-specific data
*
* Abstract:
*
*   This module gives drivers a way to attach private data to GDI+
*   objects. 
*
* Created:
*
*   3/18/1999 agodfrey
*
\**************************************************************************/

#ifndef _DPDRIVERDATA_HPP
#define _DPDRIVERDATA_HPP

class DpDriverData
{
public:
    virtual ~DpDriverData()=0;

private:
    DpDriverData *next;
    DpDriver *owner;
    friend class DpDriverDataList;
};

class DpDriverDataList
{
public:
    DpDriverDataList() { head = NULL; }
    ~DpDriverDataList();
    void Add(DpDriverData *dd, DpDriver *owner);
    
    DpDriverData *GetData(DpDriver *owner);

private:
    DpDriverData *head;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\context.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Handles the driver viewable Context class.
*
* Revision History:
*
*   12/03/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

LONG DpContext::Uniqueness = 0xfdbc;   // Used with save/restore Id's

DpContext::DpContext(
    DpContext *     prev
    )
{
    ASSERT(prev != NULL);

    Id   = InterlockedDecrement(&Uniqueness) << 16;
    Next = NULL;
    Prev = prev;

    // Save bit 15 for a container flag
    Id             |= ((prev->Id + 1) & 0x00007FFF);
    if (Id == 0)    // 0 is not a valid ID
    {
        Id = 0x0dbc0001;
    }
    AntiAliasMode      = prev->AntiAliasMode;
    TextRenderHint     = prev->TextRenderHint;
    TextContrast       = prev->TextContrast;
    CompositingMode    = prev->CompositingMode;
    CompositingQuality = prev->CompositingQuality;
    FilterType         = prev->FilterType;
    PixelOffset        = prev->PixelOffset;
    Hwnd               = prev->Hwnd;
    Hdc                = prev->Hdc;
    IsEmfPlusHdc       = prev->IsEmfPlusHdc;
    IsPrinter          = prev->IsPrinter;
    IsDisplay          = prev->IsDisplay;
    SaveDc             = prev->SaveDc;
    Palette            = prev->Palette;
    PaletteMap         = prev->PaletteMap;
    OriginalHFont      = NULL;
    CurrentHFont       = NULL;
    Face               = NULL;
    ContainerDpiX      = prev->ContainerDpiX;
    ContainerDpiY      = prev->ContainerDpiY;
    MetafileRasterizationLimitDpi = prev->MetafileRasterizationLimitDpi;

    RenderingOriginX   = prev->RenderingOriginX;
    RenderingOriginY   = prev->RenderingOriginY;
    GdiLayered         = FALSE;
                    
    // Does this need to be prev->IcmMode?

    IcmMode            = IcmModeOff;
    
    // Clipping and Transforms handled elsewhere
}

DpContext::DpContext(
    BOOL            isDisplay
    )
{
    Id   = InterlockedDecrement(&Uniqueness) << 16;
    Next = NULL;
    Prev = NULL;

    Id                |= 0x0dbc;
    AntiAliasMode      = 0;
    TextRenderHint     = TextRenderingHintSystemDefault;
    TextContrast       = DEFAULT_TEXT_CONTRAST;
    CompositingMode    = CompositingModeSourceOver;
    CompositingQuality = CompositingQualityDefault;
    FilterType         = InterpolationModeDefaultInternal;
    PixelOffset        = PixelOffsetModeDefault;
    Hwnd               = NULL;
    Hdc                = NULL;
    IsEmfPlusHdc       = FALSE;
    IsPrinter          = FALSE;
    IsDisplay          = isDisplay;
    SaveDc             = 0;
    PageUnit           = UnitDisplay;
    PageScale          = 1.0f;
    Palette            = NULL;
    PaletteMap         = NULL;
    OriginalHFont      = NULL;
    CurrentHFont       = NULL;
    Face               = NULL;
    ContainerDpiX      = Globals::DesktopDpiX;
    ContainerDpiY      = Globals::DesktopDpiY;
    GdiLayered         = FALSE;
    MetafileRasterizationLimitDpi = max(ContainerDpiX, ContainerDpiY);
    ASSERT(MetafileRasterizationLimitDpi > 0.0f);

    // Set the default rendering origin to the top left corner of the Graphics.

    RenderingOriginX   = 0;
    RenderingOriginY   = 0;
                    
    // Set the default ICM mode == ICM off.

    IcmMode            = IcmModeOff;

    // Clipping and Transforms handled elsewhere
}

DpContext::~DpContext()
{
    delete Next;
    Next = NULL;
    
    DeleteCurrentHFont();
    
    if (Prev == NULL)
    {
        if (PaletteMap != NULL)
        {
            delete PaletteMap;
            PaletteMap = NULL;
        }

        if (Palette != NULL)
        {
            GpFree(Palette);
            Palette = NULL;
        }
    }
} // DpContext::~DpContext

/**************************************************************************\
*
* Function Description:
*
*   Internal function that retrieves a clean HDC for the specified
*   context (if there is one).  This is intended to be used for
*   internal functions that require a DC (such as when we leverage
*   GDI accelerations for rendering).
*
*   The DC is cleaned for the minimum amount that we can.  That is,
*   the caller can expect an MM_TEXT transform, copy ROP, etc.
*
*   We explicitly DO NOT clean attributes that we expect any callers
*   to change, such as brush color, text color, etc.  (And consequently,
*   callers are not expected to preserve those values.)
*
*   Reset: Transform, ROP mode
*
*   NOT reset: Application clipping, stretch blt mode, current brush/pen,
*              foreground color, etc.
*
* Return Value:
*
*   NULL if no HDC can be retrieved.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

HDC
DpContext::GetHdc(
    DpBitmap *surface
    )
{
    HDC hdc = NULL;

    // Callers MUST pass in the surface:

    ASSERT(surface != NULL);

    // The first thing we have to do is flush any of our pending drawing
    // (because GDI certainly doesn't know how to flush it!)

    surface->Flush(FlushIntentionFlush);

    if (Hwnd)
    {
        // The Graphics was derived off an Hwnd.  Use GetCleanHdc
        // to get a nice clean DC (not a CS_OWNDC).

        hdc = ::GetCleanHdc(Hwnd);

        if(hdc)
        {
            // Set the appropriate ICM mode according to the context. 
            
            if(IcmMode == IcmModeOn)
            {
                // Force the ICM mode on.

                ::SetICMMode(hdc, ICM_ON);
            } 
            else
            {                
                // There are only 2 IcmMode flags possible. If you've added 
                // more you need to recode the logic that sets the IcmMode on
                // the DC.

                ASSERT(IcmMode==IcmModeOff);

                ::SetICMMode(hdc, ICM_OFF);
            }
        }

        return hdc;
    }
    else if (Hdc)
    {
        // The Graphics was derived from a bitmap, printer, or metafile Hdc.

        // First, save the application's HDC state and reset all the state

        hdc = Hdc;

        if (!SaveDc)
        {
            SaveDc = ::SaveDC(hdc);
            if (!SaveDc)
            {
                return(NULL);
            }

            this->CleanTheHdc(hdc);
        }
    }
    else if (surface->Type == DpBitmap::CreationType::GPBITMAP)
    {
        // The GpBitmap is accessible from the EpScanBitmap.  It will
        // create an HDC and GDI bitmap appropriate for interop.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(surface->Scan);
        hdc = scan->GetBitmap()->GetHdc();
        
        // !!! For some reason, this hdc is NOT clean.  So in metaplay.cpp
        // !!! I have to call CleanTheHdc on this hdc.  I don't think I should
        // !!! have to do that, but without it, there is bug #121666.
    }

    return(hdc);
}

/**************************************************************************\
*
* Function Description:
*
*   Internal function that cleans the given HDC.
*
*   Reset: Transform, ROP mode
*
*   NOT reset: Application clipping, stretch blt mode, current brush/pen,
*              foreground color, etc.
*
* Notes:
*
*   Application clipping IS reset, contrary to the above - this is bug #99338.
*
* Arguments:
*
*   hdc               - the HDC to clean
*
* History:
*
*   ??/??/???? andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpContext::CleanTheHdc(
    HDC hdc
    )
{
    // Reset the minimum number of DC attributes possible
    //
    // DON'T GRATUITOUSLY ADD RESETS HERE.  Read the function
    // comment above, and consider resetting any additional
    // DC attributes in the function that calls GetHdc().
    //
    // NOTE: A possible optimization for bitmap surfaces would
    //       be to CreateCompatibleDC a new DC, and select
    //       the bitmap into that.
    
    
    // Set the appropriate ICM mode. 
    
    if(IcmMode == IcmModeOn)
    {
        // Force the ICM mode on.

        ::SetICMMode(hdc, ICM_ON);
    } 
    else
    {                
        // There are only 2 IcmMode flags possible. If you've added 
        // more you need to recode the logic that sets the IcmMode on
        // the DC.

        ASSERT(IcmMode==IcmModeOff);

        // Force the ICM mode off.

        ::SetICMMode(hdc, ICM_OFF);
    }
    

    if (!IsEmfPlusHdc)
    {
        SetMapMode(hdc, MM_TEXT);
        SetViewportOrgEx(hdc, 0, 0, NULL);
        SetWindowOrgEx(hdc, 0, 0, NULL);
        SetROP2(hdc, R2_COPYPEN);
        
        ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);

        // If someone does a GpGraphics::GetHdc and sets the clipping,
        // we have to be sure to unset it before using the hdc again.

        SelectClipRgn(hdc, NULL);

        // Do we have to do an EndPath?
    }
    else    // it is an EMF+ HDC
    {
        // record a minimum of commands in the EMF+ file (if any at all)
        BOOL setMapMode = (::GetMapMode(hdc) != MM_TEXT);

        POINT   point;
        point.x = 0;
        point.y = 0;
        ::GetViewportOrgEx(hdc, &point);
        BOOL setViewportOrg = ((point.x != 0) || (point.y != 0));

        point.x = 0;
        point.y = 0;
        ::GetWindowOrgEx(hdc, &point);
        BOOL setWindowOrg = ((point.x != 0) || (point.y != 0));

        BOOL setROP2 = (::GetROP2(hdc) != R2_COPYPEN);

#if 0   // do NOT turn this on -- see comments below

        BOOL setWorldTransform = FALSE;

        // The graphics mode is never GM_ADVANCED on Win9x.

        // On WinNT it gets set to GM_ADVANCED when we are playing an EMF
        // into the hdc.  In that case, we don't want to set the transform
        // to the identity, because it will override the srcRect->destRect
        // transform of the command to play the metafile, which will mess
        // up GDI's transform.
        
        // The only other way we could be in GM_ADVANCED mode is if the
        // application created the EMF hdc themselves and set it to GM_ADVANCED
        // before creating a graphics from the metafile HDC.  That case is
        // currently NOT supported, and the app shouldn't do that!
        // Perhaps we should add code in the constructor to block that case.

        // This test always returns FALSE on Win9x.
        if (::GetGraphicsMode(hdc) == GM_ADVANCED)
        {
            XFORM xformIdentity;
            xformIdentity.eM11 = 1.0f;
            xformIdentity.eM12 = 0.0f;
            xformIdentity.eM21 = 0.0f;
            xformIdentity.eM22 = 1.0f;
            xformIdentity.eDx  = 0.0f;
            xformIdentity.eDy  = 0.0f;

            XFORM xform;
            xform.eM11 = 0.0;

            if (::GetWorldTransform(hdc, &xform))
            {
                setWorldTransform = (GpMemcmp(&xform, &xformIdentity, sizeof(xform)) != 0);
            }
            else
            {
                setWorldTransform = TRUE;
                WARNING1("GetWorldTransform failed");
            }
        }
#endif

        RECT clipRect;
        HRGN hRgnTmp = ::CreateRectRgn(0, 0, 0, 0);
        BOOL setClipping = ((hRgnTmp == NULL) ||
                            (::GetClipRgn(hdc, hRgnTmp) != 0));
        ::DeleteObject(hRgnTmp);

        if (setMapMode)
        {
            ::SetMapMode(hdc, MM_TEXT);
        }
        if (setViewportOrg)
        {
            ::SetViewportOrgEx(hdc, 0, 0, NULL);
        }
        if (setWindowOrg)
        {
            ::SetWindowOrgEx(hdc, 0, 0, NULL);
        }
        if (setROP2)
        {
            ::SetROP2(hdc, R2_COPYPEN);
        }
#if 0   // do NOT turn this on -- see comments above
        if (setWorldTransform)
        {
            ::ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
        }
#endif
        if (setClipping)
        {
            ::SelectClipRgn(hdc, NULL);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Releases the HDC if necessary.
*
* Return Value:
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpContext::ReleaseHdc(
    HDC hdc,
    DpBitmap *surface
    )
{
    if (Hwnd)
    {
        ReleaseDC(Hwnd, hdc);
    }
    else if (!Hdc && surface &&
             (surface->Type == DpBitmap::CreationType::GPBITMAP))
    {
        // The GpBitmap is accessible from the EpScanBitmap.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(surface->Scan);
        scan->GetBitmap()->ReleaseHdc(hdc);
    }
}

// ResetHdc() restores the HDC to the state in which it was given to us.

VOID DpContext::ResetHdc(VOID)
{
    if (SaveDc)
    {
        RestoreDC(Hdc, SaveDc);
        SaveDc = 0;
    }
} // DpContext::ResetHdc

/**************************************************************************\
*
* Function Description:
*
*   Retrieves the appropriate transform.  Implemented as a routine so that
*   we can do lazy evaluation.
*
* Arguments:
*
*   [OUT] worldToDevice: world to device matrix.
*
* Return Value:
*
*   Ok if the device to world matrix is invertible.  If this is not Ok,
*   the returned matrix is the identity matrix.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
DpContext::GetDeviceToWorld(
    GpMatrix* deviceToWorld
    ) const
{
    GpStatus status = Ok;

    if(!InverseOk)
    {
        if(WorldToDevice.IsInvertible())
        {
            DeviceToWorld = WorldToDevice;
            DeviceToWorld.Invert();
            InverseOk = TRUE;
        }
        else
        {
            DeviceToWorld.Reset();  // reset to identity matrix
            status = GenericError;
        }
    }

    *deviceToWorld = DeviceToWorld;

    return status;
}


// The units we use for the page transform with UnitDisplay depend
// on whether the graphics is associated with a display screen.  If
// it is, then we just use the dpi of the display (which is why we
// call it display units).  Otherwise (e.g. a printer), we use
// 100 dpi for display units.

#define GDIP_DISPLAY_DPI    100.0f

/**************************************************************************\
*
* Function Description:
*
*   Calculate the page multiplier for going from page units to device units.
*   Used to concatenate the page transform with the WorldToPage transform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
VOID
DpContext::GetPageMultipliers(
    REAL *              pageMultiplierX,
    REAL *              pageMultiplierY,
    GpPageUnit          unit,
    REAL                scale
    ) const
{
    if ((unit == UnitDisplay) && IsDisplay)
    {
        // The page transform is always the identity if
        // we are rendering to a display, and the unit
        // is UnitDisplay.
        *pageMultiplierX = 1.0f;
        *pageMultiplierY = 1.0f;
        return;
    }

    REAL    multiplierX;
    REAL    multiplierY;

    switch (unit)
    {
      default:
        ASSERT(0);
        // FALLTHRU

        // The units we use for the page transform with UnitDisplay depend
        // on whether the graphics is associated with a display screen.  If
        // it is, then we just use the dpi of the display (which is why we
        // call it display units).  Otherwise (e.g. a printer), we use
        // 100 dpi for display units.

      case UnitDisplay:     // Variable
        // since it's not a display, use the default display dpi of 100
        multiplierX = ContainerDpiX * scale / GDIP_DISPLAY_DPI;
        multiplierY = ContainerDpiY * scale / GDIP_DISPLAY_DPI;
        break;

      case UnitPixel:       // Each unit represents one device pixel.
        multiplierX = scale;
        multiplierY = scale;
        break;

      case UnitPoint:          // Each unit represents a printer's point,
                                // or 1/72 inch.
        multiplierX = ContainerDpiX * scale / 72.0f;
        multiplierY = ContainerDpiY * scale / 72.0f;
        break;

      case UnitInch:        // Each unit represents 1 inch.
        multiplierX = ContainerDpiX * scale;
        multiplierY = ContainerDpiY * scale;
        break;

      case UnitDocument:    // Each unit represents 1/300 inch.
        multiplierX = ContainerDpiX * scale / 300.0f;
        multiplierY = ContainerDpiY * scale / 300.0f;
        break;

      case UnitMillimeter:  // Each unit represents 1 millimeter.
                                // One Millimeter is 0.03937 inches
                                // One Inch is 25.4 millimeters
        multiplierX = ContainerDpiX * scale / 25.4f;
        multiplierY = ContainerDpiY * scale / 25.4f;
        break;
    }
    *pageMultiplierX = multiplierX;
    *pageMultiplierY = multiplierY;
}


/**************************************************************************\
*
* Function Description:
*
*   Prepares the contexts DC for use in an ExtTextOut call for a given
*   font face realization and brush.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   non-NULL   - prepared hdc
*   NULL       - faceRealization or brush could not be represented in a DC
*
* Created:
*
*   3/7/2000 DBrown
*
\**************************************************************************/

const DOUBLE PI = 3.1415926535897932384626433832795;

HDC
DpContext::GetTextOutputHdc(
    const GpFaceRealization *faceRealization,   // In  - Font face required
    GpColor                 color,              // In  - Required GdiPlus brush effect
    DpBitmap                *surface,           // In
    INT                     *angle              // Out
)
{
    ASSERT(angle);

    if (Hwnd)
    {
        // Since GetHdc will create a new DC each time for Graphics created
        // from an hWnd, we can't track the currently selected font, and
        // the overhead of selecting the font and reselecting the original
        // font everytime would be inefficent. Therefore don't optimise text in
        // Graphics created from Hwnds.

        return NULL;
    }


    // GDI can't handle clearTtype or our sort of anti-aliasing

    if (faceRealization->RealizationMethod() != TextRenderingHintSingleBitPerPixelGridFit)
    {
        return NULL;
    }

    // If it is a private font, then we need to go through with GDI+
    if (faceRealization->IsPrivate())
        return NULL;

    // Check whether GDI can handle the brush and font size

    if (!color.IsOpaque())
    {
        return NULL;  // GDI can only handle solid color brushes
    }

    if (faceRealization->GetFontFace()->IsSymbol())
    {
        return NULL;
    }
    
    // GDI can't handle the simulation.
    if (faceRealization->Getprface()->fobj.flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC | FO_SIM_ITALIC_SIDEWAYS)) 
    {
        return NULL;  
    }

    if (surface && (surface->Type == DpBitmap::CreationType::GPBITMAP))
        return NULL;
        
    // Check whether GDI can handle the glyph transform

    PointF   scale;
    REAL     rotateRadians;
    REAL     shear;
    PointF   translate;

    SplitTransform(
        faceRealization->Getprface()->mxForDDI,
        scale,
        rotateRadians,
        shear,
        translate);

    if (    scale.X / scale.Y < 0.999
        ||  scale.X / scale.Y > 1.0001)
    {
        return NULL;  // Don't pass non 1:1 aspect ratios to GDI
    }

    if (    shear < -0.0001
        ||  shear > 0.0001)
    {
        return NULL;  // GDI cannot handle shearing
    }


    // Translate rotation from radians in x-up to tenths of a degree in x-down.

    *angle = GpRound(float(3600.0 - (rotateRadians * 1800.0 / PI)));
    if (*angle >= 3600)
    {
        *angle -= 3600;
    }

    // under platform before NT 5.1 if there is a rotation, we need to render through GDI+
    // the main reason is a bug in the TrueType rasterizer that was causing in certain fonts
    // text to be rendered unhinted under 90, 180 and 270 degree rotations
    if ((*angle != 0) && 
        (!Globals::IsNt ||
             (Globals::OsVer.dwMajorVersion < 5) ||
             ((Globals::OsVer.dwMajorVersion == 5) && (Globals::OsVer.dwMinorVersion < 1)) ) )
        return NULL;

    // Prepare hdc for ExtTextOut

    HDC hdc = GetHdc(surface);

    if (!hdc)
        return NULL;

    INT style = faceRealization->Getprface()->Face->GetFaceStyle();

    // Select the font if not already selected by a previous caller

    GpStatus status = Ok;
    if (CurrentHFont == 0 || Face != faceRealization->Getprface()->Face
        ||  !FontTransform.IsEqual(&faceRealization->Getprface()->mxForDDI)
        ||  Style != style)
    {
        Face          = faceRealization->Getprface()->Face;
        FontTransform = faceRealization->Getprface()->mxForDDI;
        Style         = style;
        
        status = UpdateCurrentHFont(
                    NONANTIALIASED_QUALITY,
                    scale, 
                    *angle, 
                    hdc,
                    FALSE); // Sideway
    }

    if (status == Ok)
        status = SelectCurrentHFont(hdc);

    if (status != Ok)
    {
        ReleaseHdc(hdc);
        return NULL;
    }

    if (GetBkMode(hdc) != TRANSPARENT)
        SetBkMode(hdc, TRANSPARENT);

    COLORREF colorRef = color.ToCOLORREF();

    SetTextColor(hdc, colorRef);

    if (GetTextAlign(hdc) != TA_BASELINE)    
        SetTextAlign(hdc, TA_BASELINE);  // !!! may need VTA_BASELINE or VTA_CENTRE for vertical?
    return hdc;
}

VOID DpContext::ReleaseTextOutputHdc(HDC hdc)
{
    ::SelectObject(hdc, OriginalHFont);
    OriginalHFont = NULL;
    ReleaseHdc(hdc);
} // DpContext::ReleaseTextOutputHdc

VOID DpContext::DeleteCurrentHFont()
{
    ASSERT(OriginalHFont == 0);
    if (CurrentHFont)
    {
        ::DeleteObject(CurrentHFont);
        CurrentHFont = 0;
    }
} // DpContext::DeleteCurrentHFont

GpStatus DpContext::UpdateCurrentHFont(
        BYTE quality,
        const PointF & scale,
        INT angle,
        HDC hdc,
        BOOL sideway,
        BYTE charSet
)
{
    if (charSet == 0xFF)
        charSet = Face->GetCharset(hdc);
    DeleteCurrentHFont();
    const LONG emHeight = GpRound(Face->GetDesignEmHeight() * scale.Y);
    const LONG emWidth = 0;
    LONG rotateDeciDegrees = angle;
    const LONG weight = (Style & FontStyleBold) ? 700 : 400;
    const BYTE fItalic = (Style & FontStyleItalic) ? TRUE : FALSE;

    if (sideway)
    {
        rotateDeciDegrees -= 900;
        if (rotateDeciDegrees < 0)
        {
            rotateDeciDegrees += 3600;
        }
    }

    if (Globals::IsNt) {

        LOGFONTW lfw = {
            -emHeight,
            emWidth,
            rotateDeciDegrees,
            rotateDeciDegrees,
            weight,
            fItalic,
            0,
            0,
            charSet,     // charset
            OUT_TT_ONLY_PRECIS,
            0,
            quality,
            0,
            L""};

        if (sideway)
        {
            lfw.lfFaceName[0] = 0x0040;  // @
            memcpy(
                &lfw.lfFaceName[1],
                (WCHAR*)( (BYTE*)Face->pifi + Face->pifi->dpwszFamilyName),
                sizeof(lfw.lfFaceName)-1
            );
        }
        else
        {
            memcpy(
                lfw.lfFaceName,
                (WCHAR*)( (BYTE*)Face->pifi + Face->pifi->dpwszFamilyName),
                sizeof(lfw.lfFaceName)
            );
        }
        CurrentHFont = CreateFontIndirectW(&lfw);
    }
    else
    {
        // ANSI version for Win9X

        LOGFONTA lfa = {
            -emHeight,
            emWidth,
            rotateDeciDegrees,
            rotateDeciDegrees,
            weight,
            fItalic,
            0,
            0,
            charSet,       // charset
            OUT_TT_ONLY_PRECIS,
            0,
            quality,
            0,
            ""};

        if (sideway)
        {
            lfa.lfFaceName[0] = 0x40;  // @
            
            UnicodeToAnsiStr(
                (WCHAR*)( (BYTE*)Face->pifi + Face->pifi->dpwszFamilyName),
                &lfa.lfFaceName[1],
                LF_FACESIZE-1
            );
        }
        else
        {
            UnicodeToAnsiStr(
                (WCHAR*)( (BYTE*)Face->pifi + Face->pifi->dpwszFamilyName),
                lfa.lfFaceName,
                LF_FACESIZE
            );
        }
        CurrentHFont = CreateFontIndirectA(&lfa);
    }
    if (CurrentHFont == NULL)
    {
        return GenericError;
    }
    return Ok;
} // DpContext::UpdateCurrentHFont

GpStatus DpContext::SelectCurrentHFont(HDC hdc)
{
    ASSERT(CurrentHFont != 0 && OriginalHFont == 0);
    OriginalHFont = (HFONT)::SelectObject(hdc, CurrentHFont);
    if (OriginalHFont == 0)
        return GenericError;
    return Ok;
} // DpContext::SelectCurrentHFont


// Used only when recording a EMF or EMF+ through GpMetafile class
VOID
DpContext::SetMetafileDownLevelRasterizationLimit(
    UINT                    metafileRasterizationLimitDpi
    )
{
    if (metafileRasterizationLimitDpi > 0)
    {
        ASSERT(metafileRasterizationLimitDpi >= 10);
        MetafileRasterizationLimitDpi = (REAL)metafileRasterizationLimitDpi;
    }
    else
    {
        MetafileRasterizationLimitDpi = max(ContainerDpiX, ContainerDpiY);
        ASSERT(MetafileRasterizationLimitDpi >= 10);
    }
    DpContext *          prev = Prev;
    
    // The MetafileRasterizationLimitDpi cannot be different in any
    // other saved context of the graphics.  Update them all.
    while (prev != NULL)
    {
        prev->MetafileRasterizationLimitDpi = MetafileRasterizationLimitDpi;
        prev = prev->Prev;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\dpdriverinternal.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   
*
* Abstract:
*
*   
*
* Notes:
*
*   
*
* Created:
*
*   //1999 agodfrey
*
\**************************************************************************/

#ifndef _DPDRIVERINTERNAL_HPP
#define _DPDRIVERINTERNAL_HPP

struct DpDriverInternal
{
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\dppath.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpPath.cpp
*
* Abstract:
*
*   DpPath engine function implementation
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Create a widen path from an existing path, pen and context.  The context
*   provides the world to transform matrix, and surface dpiX, dpiY
*
* Arguments:
*
*   path, context, pen
*
* Return Value:
*
*   DpPath* - widened path
*
* Created:
*
*   1/14/2k ericvan
*
\**************************************************************************/
DpPath*
GpPath::DriverCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen,
    DpContext* context,
    BOOL outline
    )
{
    const GpPath* gpPath = GpPath::GetPath(path);
    const GpPen* gpPen = GpPen::GetPen(pen);
    
    ASSERT(gpPath->IsValid());
    ASSERT(gpPen->IsValid());
    
    GpPath* widenPath;
    GpMatrix identityMatrix;   // default initialized to identity matrix.
    
    widenPath = gpPath->GetWidenedPath(
        gpPen,
        context ? 
          &(context->WorldToDevice) : 
          &identityMatrix,
        FlatnessDefault
    );
    
    if(outline && (widenPath!=NULL))
    {
        // pass in identity matrix because GetWidenedPath has already 
        // transformed into the device space.
        // Note: We explicitly ignore the return code here because we want
        // to draw witht he widened path if the ComputeWindingModeOutline
        // fails.
        
        widenPath->ComputeWindingModeOutline(&identityMatrix, FlatnessDefault);
    }
    
    // Returns NULL on failure.
    
    return (DpPath*) widenPath;
}

VOID
GpPath::DriverDeletePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    delete gpPath;
}

DpPath*
GpPath::DriverClonePath(
    DpPath* path
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    return (DpPath*)(gpPath->Clone());
}

VOID
GpPath::DriverTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    GpPath* gpPath = GpPath::GetPath(path);

    ASSERT(gpPath->IsValid());

    gpPath->Transform(matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\aatext.hpp ===
#ifndef __AATEXT_HPP_
#define __AATEXT_HPP_

#define CT_LOOKUP 115

// the max number of foreground virt pixels in a subpixel,  2x X 1y , no filtering

#define CT_SAMPLE_NF  2

// the number of distinct nonfiltered states in a whole pixel = 3 x 3 x 3 = 27
// The indices coming from the rasterizer are in [0,26] range

#define CT_MAX_NF ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

// the max number of foreground virt pixels in a subpixel AFTER filtering, 6

#define CT_SAMPLE_F   6

// size of the storage table, basically 3^5 = 243.
// The table does filtering and index computation (vector quantization) in one step.


#define CT_STORAGE ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

class TextColorGammaTable
{
public:
    ARGB            argb[256];
    ULONG           gammaValue;

public:
    TextColorGammaTable() {};
    void CreateTextColorGammaTable(const GpColor * color, ULONG gammaValue, ULONG gsLevel);
    BYTE GetGammaTableIndexValue(BYTE grayscaleValue, ULONG gsLevel);

    inline ARGB GetGammaColorCorrection(BYTE grayscaleValue)
    {
        return argb[grayscaleValue];
    }

};

class DpOutputAntiAliasSolidColorSpan : public DpOutputSolidColorSpan
{
public:
    TextColorGammaTable textColorGammaTable;

public:

    DpOutputAntiAliasSolidColorSpan(GpColor &color, DpScanBuffer * scan, ULONG gammaValue, ULONG gsLevel);

    virtual GpStatus OutputSpan(
        INT             y,
        INT             xMin,
        INT             xMax
        )
    {
       return DpOutputSolidColorSpan::OutputSpan(y, xMin, xMax);
    }

    BOOL IsValid() const { return TRUE; }
    DpScanBuffer* GetScanBuffer(){ return DpOutputSolidColorSpan::Scan; }

    inline ARGB GetAASolidColor(ULONG grayscaleValue)
    {
        return DpOutputSolidColorSpan::Argb = textColorGammaTable.argb[grayscaleValue];
    }
};

// This class implements antialiasing for Text brush

class DpOutputAntiAliasBrushOutputSpan : public DpOutputSpan
{
public:
    DpOutputSpan *  Output;
    BYTE            alphaCoverage;

public:

    DpOutputAntiAliasBrushOutputSpan()
    {
        // Now we have nothing to do but we should have something to add
        // when we start to optimize the code
    }

    void Init(DpOutputSpan *output)
    {
        Output = output;
        alphaCoverage = 255;
    }

    void SetCoverage(BYTE coverage)
    {
        alphaCoverage = coverage;
    }
    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax);

    virtual ~DpOutputAntiAliasBrushOutputSpan() {};

    virtual BOOL IsValid() const {return TRUE;}
    virtual GpStatus End() { return Ok; }
};

void UpdateLCDOrientation();

#endif // __AATEXT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\transform.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   transform.cpp
*
* Abstract:
*
*   Implement functions related to transforms
*   inside the graphics context.
*
* Revision History:
*
*   12/09/1998 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Get the inverse of the world to device matrix.
*   We try to keep the world to device matrix invertible all the time,
*   so this should always succeed.
*
* Arguments:
*
*   [OUT] matrix - the device to world transformation matrix
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
GpStatus 
GpGraphics::GetDeviceToWorldTransform(GpMatrix * matrix) const
{
    ASSERT(matrix != NULL);
    
    if (!Context->InverseOk)
    {
        Context->DeviceToWorld = Context->WorldToDevice;
        if (Context->DeviceToWorld.Invert() == Ok)
        {
            Context->InverseOk = TRUE;
            goto InverseOk;
        }
        ASSERT(0);  // somehow we got a non-invertible matrix
        return GenericError;
    }

InverseOk:
    *matrix = Context->DeviceToWorld;
    return Ok;
}

inline REAL myabs(REAL x)
{
    return (x >= 0.0f) ? x : -x;
}

VOID 
GpGraphics::GetWorldPixelSize(
    REAL &      xSize, 
    REAL &      ySize
    )
{
    GpMatrix    matrix;
    if (this->GetDeviceToWorldTransform(&matrix) == Ok)
    {
        PointF      pnt(1.0f,1.0f);
        matrix.VectorTransform(&pnt);
        xSize = myabs(pnt.X);
        ySize = myabs(pnt.Y);
    }
    else
    {
        xSize = 1.0f;
        ySize = 1.0f;
    }
}

GpStatus
GpGraphics::SetWorldTransform(const GpMatrix& matrix)
{
    GpStatus    status = Ok;
    
    // Keep the WorldToPage transform invertible
    if (matrix.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordSetWorldTransform(matrix);
        }
        Context->WorldToPage = matrix;
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        status = InvalidParameter;
    }
    return status;
}

GpStatus
GpGraphics::ResetWorldTransform()
{
    GpStatus    status = Ok;
    
    if (IsRecording())
    {
        status = Metafile->RecordResetWorldTransform();
    }
    Context->WorldToPage.Reset();
    Context->InverseOk = FALSE;
    Context->UpdateWorldToDeviceMatrix();
    return status;
}

GpStatus
GpGraphics::MultiplyWorldTransform(const GpMatrix& matrix, 
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;
    GpMatrix    save = Context->WorldToPage;
   
    if (order == MatrixOrderPrepend)
    { 
        Context->WorldToPage.Prepend(matrix);
    }
    else
    {
        Context->WorldToPage.Append(matrix);
    }

    // Keep the WorldToPage transform invertible
    if (Context->WorldToPage.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordMultiplyWorldTransform(matrix, order);
        }
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        Context->WorldToPage = save;
        WARNING(("Matrix is non-invertible"));
        status = InvalidParameter;
    }
    return status;
}

GpStatus
GpGraphics::TranslateWorldTransform(REAL dx, REAL dy, 
                                    GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordTranslateWorldTransform(dx, dy, order);
    }
    Context->WorldToPage.Translate(dx, dy, order);
    Context->InverseOk = FALSE;
    Context->UpdateWorldToDeviceMatrix();
    return status;
}

GpStatus
GpGraphics::ScaleWorldTransform(REAL sx, REAL sy, 
                                GpMatrixOrder order)
{
    GpStatus    status = Ok;
    GpMatrix    save = Context->WorldToPage;

    Context->WorldToPage.Scale(sx, sy, order);

    // Keep the WorldToPage transform invertible
    if (Context->WorldToPage.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordScaleWorldTransform(sx, sy, order);
        }
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        Context->WorldToPage = save;
        WARNING(("Matrix is non-invertible"));
        status = InvalidParameter;
    }
    return status;
}

GpStatus
GpGraphics::RotateWorldTransform(REAL angle, GpMatrixOrder order)
{
    GpStatus    status = Ok;
    GpMatrix    save = Context->WorldToPage;

    Context->WorldToPage.Rotate(angle, order);

    // Keep the WorldToPage transform invertible
    if (Context->WorldToPage.IsInvertible())
    {
        if (IsRecording())
        {
            status = Metafile->RecordRotateWorldTransform(angle, order);
        }
        Context->InverseOk = FALSE;
        Context->UpdateWorldToDeviceMatrix();
    }
    else
    {
        Context->WorldToPage = save;
        WARNING(("Matrix is non-invertible"));
        status = InvalidParameter;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the page transformation using the specified units and scale.
*
* Arguments:
*
*   [IN] unit  - the type of units to use
*   [IN] scale - any additional scale to use.  For example, if you wanted
*                the page to be described in terms of feet, you'd set the
*                units to be inches and set the scale to be 12.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
GpStatus 
GpGraphics::SetPageTransform(
    GpPageUnit  unit, 
    REAL        scale
    )
{
    GpStatus    status = Ok;
    
    if ((scale < 0.000000001) || (scale > 1000000000))
    {
        status = InvalidParameter;
    }
    else
    {
        switch (unit)
        {
        case UnitDisplay:       // Variable
        case UnitPixel:         // Each unit is one device pixel. 
        case UnitPoint:         // Each unit is a printer's point, or 1/72 inch.
        case UnitInch:          // Each unit is 1 inch.
        case UnitDocument:      // Each unit is 1/300 inch.
        case UnitMillimeter:    // Each unit is 1 millimeter.
            if (IsRecording() &&
                ((unit != Context->PageUnit) || (scale != Context->PageScale)))
            {
                status = Metafile->RecordSetPageTransform(unit, scale);
            }
            Context->PageUnit  = unit;
            Context->PageScale = scale;
            Context->GetPageMultipliers();
            Context->UpdateWorldToDeviceMatrix();
            break;
        default:
            ASSERT(0);
            status = InvalidParameter;
            break;
        }
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert the points from one coordinate space to another.
*
* Arguments:
*
*   [IN]     source - the coordinate space of the source points
*   [IN]     dest   - the coordinate space to convert the points to
*   [IN/OUT] points - the points to convert
*   [IN]     count  - the number of points to convert
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/8/1999 DCurtis
*
\**************************************************************************/
GpStatus 
GpGraphics::TransformPoints(
    GpPointF *          points,
    INT                 count,
    GpCoordinateSpace   source, 
    GpCoordinateSpace   dest
    )
{
    if (source != dest)
    {
        GpMatrix    m;
        GpMatrix *  matrix;
        
        switch (source)
        {
          case CoordinateSpaceWorld:
            switch (dest)
            {
              case CoordinateSpacePage:
                matrix = &(Context->WorldToPage);
                break;

              case CoordinateSpaceDevice:
                matrix = &(Context->WorldToDevice);
                break;

              default:
                return InvalidParameter;
            }
            break;

          case CoordinateSpacePage:
            matrix = &m;
            switch (dest)
            {
              case CoordinateSpaceWorld:
                m = Context->WorldToPage;
                m.Invert();
                break;

              case CoordinateSpaceDevice:
                m.Scale(Context->PageMultiplierX, Context->PageMultiplierY);
                break;

              default:
                return InvalidParameter;
            }
            break;

          case CoordinateSpaceDevice:
            matrix = &m;
            switch (dest)
            {
              case CoordinateSpaceWorld:
                GetDeviceToWorldTransform(&m);
                break;

              case CoordinateSpacePage:
                {
                    REAL    scaleX = 1 / Context->PageMultiplierX;
                    REAL    scaleY = 1 / Context->PageMultiplierY;
                    m.Scale (scaleX, scaleY);
                }
                break;

              default:
                return InvalidParameter;
            }
            break;

          default:
            return InvalidParameter;
        }
        matrix->Transform(points, count);
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\brush.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Implementation of GpBrush class
*
* Revision History:
*
*   12/09/1998 davidx
*       Flesh out brush interfaces.
*
*   12/08/1998 andrewgo
*       Initial placeholders.
*
\**************************************************************************/

#include "precomp.hpp"

// For GetData and SetData methods
#define GDIP_BRUSHFLAGS_PATH                0x00000001
#define GDIP_BRUSHFLAGS_TRANSFORM           0x00000002
#define GDIP_BRUSHFLAGS_PRESETCOLORS        0x00000004
#define GDIP_BRUSHFLAGS_BLENDFACTORS        0x00000008
#define GDIP_BRUSHFLAGS_BLENDFACTORSH       GDIP_BRUSHFLAGS_BLENDFACTORS
#define GDIP_BRUSHFLAGS_BLENDFACTORSV       0x00000010
#define GDIP_BRUSHFLAGS_BLENDFACTORS0       GDIP_BRUSHFLAGS_BLENDFACTORSH
#define GDIP_BRUSHFLAGS_BLENDFACTORS1       GDIP_BRUSHFLAGS_BLENDFACTORSV
#define GDIP_BRUSHFLAGS_BLENDFACTORS2       0x00000020
#define GDIP_BRUSHFLAGS_FOCUSSCALES         0x00000040
#define GDIP_BRUSHFLAGS_ISGAMMACORRECTED    0x00000080

// Defined in path.cpp
extern BOOL 
IsRectanglePoints(
    const GpPointF* points,
    INT count,
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    );

GpStatus
GpElementaryBrush::MultiplyTransform(const GpMatrix& matrix,
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (matrix.IsInvertible())
    {
        if (order == MatrixOrderPrepend)
        {
            DeviceBrush.Xform.Prepend(matrix);
        }
        else
        {
            DeviceBrush.Xform.Append(matrix);
        }
        UpdateUid();
    }
    else
        status = InvalidParameter;

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculate the brush transform from a starting point and two directions.
*
* Arguments:
*
*   [OUT] m         - matrix coefficients
*   [OUT] width     - width (the length of dP1)
*   [OUT] height    - height (the length of dP2)
*   [IN] p0         - the starting point of the brush.
*   [IN] dP1        - the vector to represent the transformed x-direction.
*   [IN] dP2        - the vector to represent the transformed y-direction.
*
* Return Vaule:
*
*   TRUE if the transform matrix is non-degenerate.
*   Otherwise returns FALSE.
*
* History:
*
*   06/03/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL getLineGradientTransform(
    REAL* m,
    REAL* width,
    REAL* height,
    const GpPointF& p0,
    const GpPointF& dP1,
    const GpPointF& dP2
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    REAL l1 = dP1.X*dP1.X + dP1.Y*dP1.Y;
    REAL l2 = dP2.X*dP2.X + dP2.Y*dP2.Y;
    REAL test = dP1.X*dP2.Y - dP1.Y*dP2.X;

    if(l1 == 0 || l2 == 0 || test == 0)
        return FALSE;

    l1 = REALSQRT(l1);
    l2 = REALSQRT(l2);
    m[0] = TOREAL(dP1.X/l1);    // M11
    m[1] = TOREAL(dP1.Y/l1);    // M12
    m[2] = TOREAL(dP2.X/l2);   // M21
    m[3] = TOREAL(dP2.Y/l2);    // M22
    m[4] = TOREAL(p0.X - p0.X*m[0] - p0.Y*m[2]);    // Dx
    m[5] = TOREAL(p0.Y - p0.X*m[1] - p0.Y*m[3]);    // Dy

    *width = l1;
    *height = l2;

    return TRUE;
}

static GpStatus
LinearGradientRectFromPoints(
    const GpPointF& point1,
    const GpPointF& point2,
    GpRectF &       rect
    )
{
    // If the API specifies two coincident points, we
    // can't get information for the gradient, so we
    // fail the construction here.

    if( IsClosePointF(point1, point2) )
    {
        return InvalidParameter;
    }

    // Compute the bounding rectangle of the two input points.

    rect.X = min(point1.X, point2.X);
    rect.Y = min(point1.Y, point2.Y);
    rect.Width = REALABS(point1.X-point2.X);
    rect.Height = REALABS(point1.Y-point2.Y);

    // eliminate degenerate rectangles when the two
    // input points form a horizontal or vertical line.

    // This is a very odd way of coercing a 1d linear gradient
    // into a rect gradient and avoiding later matrix computation error
    // when we try get an affine warp between this rectangle and a
    // reference rectangle.

    if( IsCloseReal(point1.X, point2.X) )
    {
        rect.X -= rect.Height/2;
        rect.Width = rect.Height;
    }

    if( IsCloseReal(point1.Y, point2.Y) )
    {
        rect.Y -= rect.Width/2;
        rect.Height = rect.Width;
    }
    return Ok;
}

static GpStatus 
CalcLinearGradientXform(
    REAL                angle,
    BOOL                isAngleScalable,
    const GpRectF&      rect,
    GpMatrix&           xform
    )
{
    GpPointF p0, dP1, dP2;

    angle = GpModF(angle, 360);

    INT zone;
    REALD deltaTheta;
    const REALD degreeToRadian = 3.1415926535897932/180;

    if(angle < 90)
    {
        zone = 0;
        deltaTheta = angle;
    }
    else if(angle < 180)
    {
        zone = 1;
        deltaTheta = 180 - angle;
    }
    else if(angle < 270)
    {
        zone = 2;
        deltaTheta = angle - 180;
    }
    else
    {
        zone = 3;
        deltaTheta = 360 - angle;
    }

    REALD s, c;

    deltaTheta *= degreeToRadian;

    s = sin(deltaTheta);
    c = cos(deltaTheta);

    // d0 is the distance between p0 and the starting corner of the
    // original rectangle.
    // d1 and d2 is the length of dP1 and dP2, respectively.

    REALD top, left, w, h, d0, d1, d2;
    REALD x0, y0;   // Starting corner of the original rectangle.
    GpPointD norm;  // Direction of dP1.

    // Direction of dP2 = (-norm.Y, norm.X) which is 90 degree rotation
    // of dP1.

    if(!isAngleScalable)
    {
        left = rect.X;
        top = rect.Y;
        w = rect.Width;
        h = rect.Height;
    }
    else
    {
        // Scale to (0, 0, 1, 1) rectangle.

        top = 0.0;
        left = 0.0;
        w = 1.0;
        h = 1.0;
    }

    switch(zone)
    {
    case 0:
        d0 = w*s;
        norm.X = c;
        norm.Y = s;

        x0 = left;
        y0 = top;
        break;

    case 1:
        d0 = h*c;
        norm.X = - c;
        norm.Y = s;

        x0 = left + w;
        y0 = top;
        break;

    case 2:
        d0 = w*s;
        norm.X = - c;
        norm.Y = - s;

        x0 = left + w;
        y0 = top + h;
        break;

    case 3:
        d0 = h*c;
        norm.X = c;
        norm.Y = - s;

        x0 = left;
        y0 = top + h;
        break;
    }

    d2 = w*s + h*c;
    d1 = w*c + h*s;
    p0.X = TOREAL(x0 + d0*norm.Y);
    p0.Y = TOREAL(y0 - d0*norm.X);
    dP1.X = TOREAL(d1*norm.X);
    dP1.Y = TOREAL(d1*norm.Y);
    dP2.X = TOREAL(- d2*norm.Y);
    dP2.Y = TOREAL(d2*norm.X);

    if(isAngleScalable)
    {
        // Scale back.

        p0.X = rect.Width*p0.X + rect.X;
        p0.Y = rect.Height*p0.Y + rect.Y;

        dP1.X *= rect.Width;
        dP1.Y *= rect.Height;
        dP2.X *= rect.Width;
        dP2.Y *= rect.Height;
    }

    // Set up the transform.

    GpPointF points[3];

    points[0] = p0;
    points[1].X = p0.X + dP1.X;
    points[1].Y = p0.Y + dP1.Y;
    points[2].X = p0.X + dP2.X;
    points[2].Y = p0.Y + dP2.Y;

    GpStatus status;

    if(xform.InferAffineMatrix(&points[0], rect) == Ok)
    {
        return Ok;
    }
    return InvalidParameter;
}

GpStatus
GpLineGradient::ChangeLinePoints(
    const GpPointF&     point1,
    const GpPointF&     point2,
    BOOL                isAngleScalable
    )
{
    GpStatus    status;
    GpRectF     rect;
    
    if ((status = LinearGradientRectFromPoints(point1, point2, rect)) != Ok)
    {
        return status;
    }

    REAL        angle = GetAngleFromPoints(point1, point2);
    GpMatrix    xform;

    if ((status = CalcLinearGradientXform(angle, isAngleScalable, rect, xform)) == Ok)
    {
        DeviceBrush.Xform           = xform;
        DeviceBrush.Rect            = rect;
        DeviceBrush.IsAngleScalable = isAngleScalable;
        DeviceBrush.Points[0]       = point1;
        DeviceBrush.Points[1]       = point2;
        return Ok;
    }
    return status;
}

GpLineGradient::GpLineGradient(
    const GpPointF& point1,
    const GpPointF& point2,
    const GpColor& color1,
    const GpColor& color2,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    REAL angle;
    GpRectF rect;

    if (LinearGradientRectFromPoints(point1, point2, rect) != Ok)
    {
        SetValid(FALSE);
        return;
    }

    // Compute the angle of the line formed by point1 and point2.
    // Note atan2 is only undefined if dP.Y == 0.0 and dP.X == 0.0
    // and then it returns 0 radians. We take care of that case separately
    // (above).
    // Also, atan2 correctly computes the quadrant from the two input points.

    GpPointF dP = point2 - point1;
    double rad = atan2((double)(dP.Y), (double)(dP.X));

    SetLineGradient(
        point1,
        point2,
        rect,
        color1,
        color2,

        // why aren't we working in radians???

        (REAL)(rad*180.0/3.1415926535897932),
        FALSE,
        wrapMode
    );
}


/**************************************************************************\
*
* Function Description:
*
*   Creates a LineGradient which is defined by the rectangle.
*
* Arguments:
*
*   [IN] rect       - the rectangle to define this gradient.
*   [IN] color1     - the color of the start point.
*   [IN] color2     - the color of the end point.
*   [IN] mode       - the line gradient mode
*   [IN] wrapMode   - the wrap mode of this brush.
*
* The start and end points of this gradient is defined as follows
* according to the line gradient mode:
*
*       mode                        start point     end point
*    -------------------------------------------------------------
*    LineGradientHorizontal         top-left        top-right
*    LineGradientVertical           top-right       bottom-right
*    LineGradientForwardDiagonal    top-left        bottom-right
*    LineGradientBackwardDiagonal   bottom-left     top-right
*
*
* History:
*
*   06/03/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpLineGradient::GpLineGradient(
    const GpRectF& rect,
    const GpColor& color1,
    const GpColor& color2,
    LinearGradientMode mode,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    BOOL isAngleScalable = TRUE;
    REAL angle = 0;
    GpPointF    point1;
    GpPointF    point2;

    switch(mode)
    {
    case LinearGradientModeHorizontal:
        angle = 0;
        point1.X = rect.X;
        point1.Y = (rect.Y + rect.GetBottom()) / 2.0f;
        point2.X = rect.GetRight();
        point2.Y = point1.Y;
        break;

    case LinearGradientModeVertical:
        angle = 90;
        point1.X = (rect.X + rect.GetRight()) / 2.0f;
        point1.Y = rect.Y;
        point2.X = point1.X;
        point2.Y = rect.GetBottom();
        break;

    case LinearGradientModeForwardDiagonal:
        angle = 45;
        point1.X = rect.X;
        point1.Y = rect.Y;
        point2.X = rect.GetRight();
        point2.Y = rect.GetBottom();
        break;

    case LinearGradientModeBackwardDiagonal:
        angle = 135;
        point1.X = rect.GetRight();
        point1.Y = rect.Y;
        point2.X = rect.X;
        point2.Y = rect.GetBottom();
        break;

    default:
        // No such a case.
        ASSERT(0);

        SetValid(FALSE);
        return;
    }

    SetLineGradient(
        point1,
        point2,
        rect,
        color1,
        color2,
        angle,
        isAngleScalable,
        wrapMode);
}


/**************************************************************************\
*
* Function Description:
*
*   Creates a LineGradient which is defined by the rectangle.
*
* Arguments:
*
*   [IN] rect       - the rectangle to define this gradient.
*   [IN] color1     - the color of the start point.
*   [IN] color2     - the color of the end point.
*   [IN] angle      - the angle of the gradient
*   [IN] isAngleScalable - TRUE if 45 degree is corner to corner.
*                          The default value is FALSE.
*   [IN] wrapMode   - the wrap mode of this brush.
*
*
*
* History:
*
*   10/06/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpLineGradient::GpLineGradient(
    const GpRectF& rect,
    const GpColor& color1,
    const GpColor& color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();
    GpPointF    point1;
    GpPointF    point2;
    
    // Not an Office scenario, but need to fix at some point
    // so we can print to PCL better.
    point1.X = point1.Y = point2.X = point2.Y = 0;

    SetLineGradient(
        point1,
        point2,
        rect,
        color1,
        color2,
        angle,
        isAngleScalable,
        wrapMode);
}

GpStatus
GpLineGradient::SetLineGradient(
    const GpPointF& point1,
    const GpPointF& point2,
    const GpRectF& rect,
    const GpColor& color1,
    const GpColor& color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapMode
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    DeviceBrush.Wrap = wrapMode;
    DeviceBrush.Colors[0] = color1;
    DeviceBrush.Colors[1] = color2;
    DeviceBrush.Colors[2] = color1;
    DeviceBrush.Colors[3] = color2;

    DeviceBrush.BlendCounts[0] = DeviceBrush.BlendCounts[1] = 1;
    DeviceBrush.BlendFactors[0] = DeviceBrush.BlendFactors[1] = NULL;
    DeviceBrush.Falloffs[0] = DeviceBrush.Falloffs[1] = 1;

    GpStatus status;
    
    if (CalcLinearGradientXform(angle, isAngleScalable, rect, DeviceBrush.Xform) == Ok)
    {
        SetValid(TRUE);
        DeviceBrush.Rect = rect;
        DeviceBrush.IsAngleScalable = isAngleScalable;
        DeviceBrush.Points[0] = point1;
        DeviceBrush.Points[1] = point2;
        status = Ok;
    }
    else
    {
        SetValid(FALSE);
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
        GpMemset(DeviceBrush.Points, 0, sizeof(DeviceBrush.Points[0]) * 2);
        DeviceBrush.IsAngleScalable = FALSE;
        status = InvalidParameter;
    }

    return status;
}



GpStatus
GpLineGradient::SetLinePoints(
    const GpPointF& point1,
    const GpPointF& point2
    )
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    GpPointF p0, dP1, dP2;

    p0 = point1;
    dP1.X = point2.X - point1.X;
    dP1.Y = point2.Y - point1.Y;
    dP2.X = - dP1.Y;
    dP2.Y = dP1.X;

    REAL m[6];
    REAL width, height;

    if(getLineGradientTransform(&m[0], &width, &height, p0, dP1, dP2))
    {
        SetValid(TRUE);

        DeviceBrush.Rect.X = p0.X;
        DeviceBrush.Rect.Y = p0.Y;
        DeviceBrush.Rect.Width = width;
        DeviceBrush.Rect.Height = height;
    }
    else
    {
        // Don't change the current state.

        return GenericError;
    }

    DeviceBrush.Xform.SetMatrix(m);
    UpdateUid();
    return Ok;
}


GpStatus
GpLineGradient::GetLinePoints(GpPointF* points)
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    ASSERT(points);
    points[0].X = DeviceBrush.Rect.X;
    points[0].Y = DeviceBrush.Rect.Y;
    points[1].X = DeviceBrush.Rect.X + DeviceBrush.Rect.Width;
    points[1].Y = DeviceBrush.Rect.Y + DeviceBrush.Rect.Height;
    DeviceBrush.Xform.Transform(points, 2);

    return Ok;
}


INT
GpLineGradient::GetPresetBlendCount()
{
    if(DeviceBrush.UsesPresetColors)
        return DeviceBrush.BlendCounts[0];
    else
        return 0;
}

/*
** This returns the premultiplied colors
*/

GpStatus
GpLineGradient::GetPresetBlend(
    GpColor* blendColors,
    REAL* blendPositions,
    INT count)
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    if(DeviceBrush.UsesPresetColors &&
       DeviceBrush.PresetColors &&
       DeviceBrush.BlendPositions[0])
    {
        for(INT i = 0; i < count; i++)
        {
            blendColors[i].SetColor(DeviceBrush.PresetColors[i]);
        }
        GpMemcpy(blendPositions,
                 DeviceBrush.BlendPositions[0],
                 count*sizeof(REAL));

        return Ok;
    }
    else
        return GenericError;
}

GpStatus
GpLineGradient::SetPresetBlend(
            const GpColor* blendColors,
            const REAL* blendPositions,
            INT count)
{
    // Make sure the flat API has correctly set the FPU.

    FPUStateSaver::AssertMode();

    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    ARGB* newColors = (ARGB*) GpRealloc(DeviceBrush.PresetColors,
                                        count*sizeof(ARGB));

    if (newColors != NULL)
    {
        DeviceBrush.PresetColors = newColors;
    }
    else
    {
        return OutOfMemory;
    }

    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0],
                                           count*sizeof(REAL));

    if (newPositions != NULL)
    {
        DeviceBrush.BlendPositions[0] = newPositions;
    }
    else
    {
        return OutOfMemory;
    }

    GpFree(DeviceBrush.BlendFactors[0]);

    // DeviceBrush.BlendFactors[1] is always NULL for LineGradient.
    DeviceBrush.BlendFactors[0] = NULL;

    DeviceBrush.UsesPresetColors = TRUE;

    for(INT i = 0; i < count; i++)
    {
        newColors[i] = blendColors[i].GetValue();
    }
    GpMemcpy(newPositions, blendPositions, count*sizeof(REAL));
    DeviceBrush.BlendCounts[0] = count;
    UpdateUid();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Blend any transparent colors in this brush with white.  Note that
*   colors are premultiplied, since they will become fully opaque.
*
* Arguments:
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpLineGradient::BlendWithWhite()
{
    if (DeviceBrush.UsesPresetColors)
    {
        GpColor color;
        
        for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
        {
            color.SetValue(GpColor::ConvertToPremultiplied(DeviceBrush.PresetColors[i]));
            color.BlendOpaqueWithWhite();
            DeviceBrush.PresetColors[i] = color.GetValue();
        }
        return Ok;
    }
    else
    {
        return GpRectGradient::BlendWithWhite();
    }
}

BOOL
GpPathGradient::IsRectangle() const
{
    BOOL result = FALSE;

    if (DeviceBrush.PointsPtr != NULL)
        result = IsRectanglePoints(DeviceBrush.PointsPtr, DeviceBrush.Count, NULL, NULL);
    else
    {
        GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);
        if(path)
            result = path->IsRectangle(NULL);
    }

    return result;
}

INT
GpPathGradient::GetPresetBlendCount() const
{
    if(DeviceBrush.UsesPresetColors)
        return DeviceBrush.BlendCounts[0];
    else
        return 0;
}

/*
** This returns the premultiplied colors
*/

GpStatus
GpPathGradient::GetPresetBlend(
    GpColor* blendColors,
    REAL* blendPositions,
    INT count) const
{
    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    if(DeviceBrush.UsesPresetColors && DeviceBrush.PresetColors && DeviceBrush.BlendPositions[0])
    {
        // Users will obtain the preset colors as radial blend colors.
        // 0 position means the center location and 1 position means the
        // the outer edge.  In order to convert those colors and position arrays
        // from the weight factor arrays in PathGradient,
        // we must invert the order of the returned arrays.

        for(INT i = 0; i < count; i++)
        {
            blendColors[count - 1 -i].SetColor(DeviceBrush.PresetColors[i]);
            blendPositions[count - 1 -i] = TOREAL(1.0 - DeviceBrush.BlendPositions[0][i]);
        }

        return Ok;
    }
    else
        return GenericError;
}

GpStatus
GpPathGradient::SetPresetBlend(
            const GpColor* blendColors,
            const REAL* blendPositions,
            INT count)
{
    if(!blendColors || !blendPositions || count <= 1)
        return InvalidParameter;

    ARGB* newColors = (ARGB*) GpRealloc(DeviceBrush.PresetColors, count*sizeof(ARGB));

    if (newColors != NULL)
    {
        DeviceBrush.PresetColors = newColors;
    }
    else
    {
        return OutOfMemory;
    }

    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], count*sizeof(REAL));

    if (newPositions != NULL)
    {
        DeviceBrush.BlendPositions[0] = newPositions;
    }
    else
    {
        return OutOfMemory;
    }

    GpFree(DeviceBrush.BlendFactors[0]);
    DeviceBrush.BlendFactors[0] = NULL;

    DeviceBrush.UsesPresetColors = TRUE;

    // Users will supply the preset colors as radial blend colors.
    // 0 position means the center location and 1 position means the
    // the outer edge.  In order to convert those colors and position arrays
    // to the weight factor arrays in PathGradient,
    // we must invert the order of the given arrays.

    for(INT i = 0; i < count; i++)
    {
        // PresetColors are stored non-premultiplied.
        newColors[count - 1 - i] = blendColors[i].GetValue();
        newPositions[count - 1 - i] = TOREAL(1.0 - blendPositions[i]);
    }

    DeviceBrush.BlendCounts[0] = count;
    UpdateUid();
    return Ok;
}

//==================================================================
// Copy constructors
//==================================================================

GpElementaryBrush::GpElementaryBrush(const GpElementaryBrush *brush)
{
    if(brush && brush->IsValid())
    {
        // !!! [asecchia] we should really be asking the DeviceBrush to
        // copy it's members instead of duplicating the code all over
        // the place. Current code is error prone - each subclass is has to 
        // know all about how to copy and what has or hasn't been updated on
        // the chain down to it's ancestor.
        
        DeviceBrush.Xform = brush->DeviceBrush.Xform;
        DeviceBrush.Wrap = brush->DeviceBrush.Wrap;
        DeviceBrush.IsGammaCorrected = brush->DeviceBrush.IsGammaCorrected;
        
        SetValid(brush->IsValid());
    }
    else
        SetValid(FALSE);
}

GpTexture::GpTexture(
    const GpTexture *brush
    ) : GpElementaryBrush(brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        InitializeBrush(brush->Image, devBrush->Wrap, NULL);
        SetTransform(devBrush->Xform);
    }
    else
        SetValid(FALSE);
}

GpRectGradient::GpRectGradient(
    const GpRectGradient *brush
    )  : GpGradientBrush(brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        InitializeBrush(
            devBrush->Rect,
            &(devBrush->Colors[0]),
            devBrush->Wrap
            );

        SetTransform(devBrush->Xform);

        SetHorizontalBlend(
            devBrush->BlendFactors[0],
            devBrush->BlendPositions[0],
            devBrush->BlendCounts[0]
            );

        SetVerticalBlend(
            devBrush->BlendFactors[1],
            devBrush->BlendPositions[1],
            devBrush->BlendCounts[1]
            );

    }
    else
        SetValid(FALSE);
}

GpLineGradient::GpLineGradient(
    const GpLineGradient *brush
    ) : GpRectGradient(brush)
{
    if(brush && brush->IsValid())
    {
        // Copy the preset colors.
        // !!! [asecchia] why isn't this handled in a uniform way?
        const DpBrush* devBrush = &(brush->DeviceBrush);

        DeviceBrush.Points[0]       = devBrush->Points[0];
        DeviceBrush.Points[1]       = devBrush->Points[1];
        DeviceBrush.IsAngleScalable = devBrush->IsAngleScalable;

        if(devBrush->UsesPresetColors)
        {
            SetPresetBlend(
                (GpColor*)(devBrush->PresetColors),
                (REAL*)(devBrush->BlendPositions[0]),
                devBrush->BlendCounts[0]
            );
        }
    }
}

GpPathGradient::GpPathGradient(
    const GpPathGradient *brush
    ) : GpGradientBrush(brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        // If a path exists for the brush, use that for initialization.
        // Otherwise, use the points collection.
        if (devBrush->Path != NULL)
        {
            DefaultBrush();
            DeviceBrush.Wrap = devBrush->Wrap;
            DeviceBrush.Path = devBrush->Path->ClonePath();
            PrepareBrush();
        }
        else
        {
            InitializeBrush(devBrush->PointsPtr, 
                            devBrush->Count, 
                            devBrush->Wrap);
        }

        if(IsValid())
        {
            SetTransform(devBrush->Xform);

            SetCenterPoint(devBrush->Points[0]);
            SetCenterColor(devBrush->Colors[0]);
            SetSurroundColors(devBrush->ColorsPtr);
            DeviceBrush.Falloffs[0] = devBrush->Falloffs[0];
            DeviceBrush.FocusScaleX = devBrush->FocusScaleX;
            DeviceBrush.FocusScaleY = devBrush->FocusScaleY;
            DeviceBrush.UsesPresetColors = devBrush->UsesPresetColors;
            
            INT blendCount = devBrush->BlendCounts[0];
            DeviceBrush.BlendCounts[0] = blendCount;

            // If we're cloning a brush with preset colors, copy preset colors 
            // and blend positions.  Otherwise, copy the blend factors and
            // blend positions.
            if (devBrush->UsesPresetColors)
            {
                ARGB* newColors = (ARGB*) GpRealloc(DeviceBrush.PresetColors, blendCount*sizeof(ARGB));
                if (newColors != NULL)
                {
                    DeviceBrush.PresetColors = newColors;

                    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], blendCount*sizeof(REAL));

                    if (newPositions != NULL)
                    {
                        DeviceBrush.BlendPositions[0] = newPositions;
                        GpFree(DeviceBrush.BlendFactors[0]);
                        DeviceBrush.BlendFactors[0] = NULL;
                
                        memcpy(DeviceBrush.PresetColors,
                               devBrush->PresetColors,
                               blendCount*sizeof(ARGB));
                        memcpy(DeviceBrush.BlendPositions[0],
                               devBrush->BlendPositions[0],
                               blendCount*sizeof(REAL));
                    }
                    else
                    {
                        SetValid(FALSE);
                    }
                }
                else
                {
                    SetValid(FALSE);
                }
            }
            else if (devBrush->BlendFactors[0] && devBrush->BlendPositions[0])
            {
                REAL* newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[0], blendCount*sizeof(REAL));
                if (newFactors != NULL)
                {
                    DeviceBrush.BlendFactors[0] = newFactors;

                    REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], blendCount*sizeof(REAL));

                    if (newPositions != NULL)
                    {
                        DeviceBrush.BlendPositions[0] = newPositions;
                
                        memcpy(DeviceBrush.BlendFactors[0],
                               devBrush->BlendFactors[0],
                               blendCount*sizeof(REAL));
                        memcpy(DeviceBrush.BlendPositions[0],
                               devBrush->BlendPositions[0],
                               blendCount*sizeof(REAL));
                    }
                    else
                    {
                        SetValid(FALSE);
                    }
                }
                else
                {
                    SetValid(FALSE);
                }
            }
        }
    }
    else
        SetValid(FALSE);
}

GpHatch::GpHatch(const GpHatch* brush)
{
    if(brush && brush->IsValid())
    {
        const DpBrush* devBrush = &(brush->DeviceBrush);

        InitializeBrush(devBrush->Style,
                    devBrush->Colors[0],
                    devBrush->Colors[1]);
    }
    else
        SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Getting horizontal falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [OUT] blendFactors - Buffer for returning the horizontal
*               falloff or blend-factors.
*   count - Size of the buffer (in number of REAL elements)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::GetHorizontalBlend(
    REAL* blendFactors,
    REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    // Check if the input buffer is big enough

    if (count < DeviceBrush.BlendCounts[0])
        return InsufficientBuffer;

    if (DeviceBrush.BlendCounts[0] == 1)
    {
        // Return falloff parameter

        blendFactors[0] = DeviceBrush.Falloffs[0];
    }
    else
    {
        // Return blend factors

        GpMemcpy(
            blendFactors,
            DeviceBrush.BlendFactors[0],
            DeviceBrush.BlendCounts[0]*sizeof(REAL)
            );
        GpMemcpy(
            blendPositions,
            DeviceBrush.BlendPositions[0],
            DeviceBrush.BlendCounts[0]*sizeof(REAL)
            );
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Setting horizontal falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [IN] blendFactors - Specify the new blend factors
*   count - Number of elements in the blend factor array
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::SetHorizontalBlend(
    const REAL* blendFactors,
    const REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    if (count == 1)
    {
        // Setting falloff parameter

        GpFree(DeviceBrush.BlendFactors[0]);
        DeviceBrush.BlendFactors[0] = NULL;
        GpFree(DeviceBrush.BlendPositions[0]);
        DeviceBrush.BlendPositions[0] = NULL;

        if (blendFactors == NULL)
            DeviceBrush.Falloffs[0] = 1;
        else
            DeviceBrush.Falloffs[0] = blendFactors[0];

        DeviceBrush.BlendCounts[0] = 1;
    }
    else
    {
        ASSERT(blendFactors != NULL && blendPositions != NULL);
        
        // blend positions must start at 0.0 and end at 1.0
        
        if (REALABS(blendPositions[0]) > REAL_EPSILON ||
            REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
        {
            return InvalidParameter;
        }

        // Setting blend factors

        REAL* newFactors;
        REAL* newPositions;

        newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[0], count*sizeof(REAL));

        if (newFactors != NULL)
        {
            DeviceBrush.BlendFactors[0] = newFactors;
        }
        else
        {
            return OutOfMemory;
        }

        newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], count*sizeof(REAL));

        if (newPositions != NULL)
        {
            DeviceBrush.BlendPositions[0] = newPositions;
        }
        else
        {
            return OutOfMemory;
        }

        if (newFactors == NULL || newPositions == NULL)
            return OutOfMemory;

        GpMemcpy(newFactors, blendFactors, count*sizeof(REAL));
        GpMemcpy(newPositions, blendPositions, count*sizeof(REAL));
        DeviceBrush.BlendCounts[0] = count;
    }

    DeviceBrush.UsesPresetColors = FALSE;
    GpFree(DeviceBrush.PresetColors);
    DeviceBrush.PresetColors = NULL;
    UpdateUid();
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Getting vertical falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [OUT] blendFactors - Buffer for returning the vertical
*               falloff or blend-factors.
*   count - Size of the buffer (in number of REAL elements)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::GetVerticalBlend(
    REAL* blendFactors,
    REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    // Check if the input buffer is big enough

    if (count < DeviceBrush.BlendCounts[1])
        return InsufficientBuffer;

    if (DeviceBrush.BlendCounts[1] == 1)
    {
        // Return falloff parameter

        blendFactors[0] = DeviceBrush.Falloffs[1];
    }
    else
    {
        // Return blend factors

        GpMemcpy(
            blendFactors,
            DeviceBrush.BlendFactors[1],
            DeviceBrush.BlendCounts[1]*sizeof(REAL));
        GpMemcpy(
            blendPositions,
            DeviceBrush.BlendPositions[1],
            DeviceBrush.BlendCounts[1]*sizeof(REAL));
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Setting vertical falloff / blend-factors for
*   a rectangular gradient brush object
*
* Arguments:
*
*   [IN] blendFactors - Specify the new blend factors
*   count - Number of elements in the blend factor array
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpRectGradient::SetVerticalBlend(
    const REAL* blendFactors,
    const REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    if (count == 1)
    {
        // Setting falloff parameter

        GpFree(DeviceBrush.BlendFactors[1]);
        DeviceBrush.BlendFactors[1] = NULL;
        GpFree(DeviceBrush.BlendPositions[1]);
        DeviceBrush.BlendPositions[1] = NULL;

        if (blendFactors == NULL)
            DeviceBrush.Falloffs[1] = 1;
        else
            DeviceBrush.Falloffs[1] = blendFactors[0];

        DeviceBrush.BlendCounts[1] = 1;
    }
    else
    {
        ASSERT(blendFactors != NULL && blendPositions != NULL);

        // Setting blend factors

        REAL* newFactors;
        REAL* newPositions;

        newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[1], count*sizeof(REAL));

        if (newFactors != NULL)
        {
            DeviceBrush.BlendFactors[1] = newFactors;
        }
        else
        {
            return OutOfMemory;
        }

        newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[1], count*sizeof(REAL));

        if (newPositions != NULL)
        {
            DeviceBrush.BlendPositions[1] = newPositions;
        }
        else
        {
            return OutOfMemory;
        }

        GpMemcpy(newFactors, blendFactors, count*sizeof(REAL));
        GpMemcpy(newPositions, blendPositions, count*sizeof(REAL));
        DeviceBrush.BlendCounts[1] = count;
    }

    DeviceBrush.UsesPresetColors = FALSE;
    GpFree(DeviceBrush.PresetColors);
    DeviceBrush.PresetColors = NULL;
    UpdateUid();

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Blend any transparent colors in this brush with white.  Note that colors
*   are converted to premultiplied first, since they will become fully opaque.
*
* Arguments:
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpRectGradient::BlendWithWhite()
{
    GpColor color;
    
    for (INT i=0; i<4; i++)
    {
        color.SetValue(DeviceBrush.Colors[i].GetPremultipliedValue());
        color.BlendOpaqueWithWhite();
        DeviceBrush.Colors[i] = color.GetValue();
    }

    return Ok;
}

//--------------------------------------------------------------------------
// Path Gradient
//--------------------------------------------------------------------------

VOID
GpPathGradient::PrepareBrush()
{
    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if (path)
    {
        DeviceBrush.Count = path->Points.GetCount();
        GpPointF* points = path->Points.GetDataBuffer();

        if(!DeviceBrush.ColorsPtr)
        {
           DeviceBrush.ColorsPtr = (GpColor*)GpMalloc(DeviceBrush.Count*sizeof(GpColor));

           if (DeviceBrush.ColorsPtr != NULL)
              GpMemset(&DeviceBrush.ColorsPtr[0], 255, DeviceBrush.Count*sizeof(GpColor));
        }

        REAL xmin, xmax, ymin, ymax, x0, y0; 

        x0 = xmin = xmax = points[0].X;
        y0 = ymin = ymax = points[0].Y;

        for(INT i = 1; i < DeviceBrush.Count; i++)
        {
            x0 += points[i].X;
            y0 += points[i].Y;
            xmin = min(xmin, points[i].X);
            xmax = max(xmax, points[i].X);
            ymin = min(ymin, points[i].Y);
            ymax = max(ymax, points[i].Y);
        }

        DeviceBrush.Rect.X = xmin;
        DeviceBrush.Rect.Width = xmax - xmin;
        DeviceBrush.Rect.Y = ymin;
        DeviceBrush.Rect.Height = ymax - ymin;

        if(!WrapModeIsValid(DeviceBrush.Wrap) || DeviceBrush.Rect.Width <= 0 || DeviceBrush.Rect.Height <= 0)
            return;

        DeviceBrush.Points[0].X = x0/DeviceBrush.Count;
        DeviceBrush.Points[0].Y = y0/DeviceBrush.Count;

        SetValid(TRUE);
    }
}

GpStatus
GpPathGradient::Flatten(GpMatrix* matrix) const
{
    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if(!path)
        return Ok;

    if(path->HasCurve())
    {
        INT origCount = DeviceBrush.Count;

        GpStatus status = path->Flatten(
                            const_cast<DynByteArray*>(&FlattenTypes),
                            const_cast<DynPointFArray*> (&FlattenPoints),
                            matrix);

        if(status == Ok)
        {
            DeviceBrush.Count = FlattenPoints.GetCount();
            DeviceBrush.PointsPtr = FlattenPoints.GetDataBuffer();
            
            if ((DeviceBrush.Count > origCount) &&
                (DeviceBrush.ColorsPtr != NULL)) 
            {
                // The colors array is no longer the proper size.  Adjust the
                // size and copy up the last color.  It is the apps responsibility
                // to estimate and specify the correct number of flattened points.
                
                const_cast<GpColor*>(DeviceBrush.ColorsPtr) = (GpColor*) GpRealloc((VOID*)DeviceBrush.ColorsPtr, 
                                                             sizeof(GpColor)*DeviceBrush.Count);

                if (DeviceBrush.ColorsPtr != NULL)
                {
                     GpColor copyColor = (origCount > 1) ? 
                                        DeviceBrush.ColorsPtr[origCount-1] :
                                        GpColor(0xFFFFFFFF);

                     for (INT i=origCount; i<DeviceBrush.Count; i++) 
                     {
                          DeviceBrush.ColorsPtr[i] = copyColor;
                     }
                }
                else
                {
                    return OutOfMemory;
                }
            }
        }
    }
    else
    {
            DeviceBrush.Count = path->GetPointCount();
            DeviceBrush.PointsPtr = const_cast<GpPointF*> (path->GetPathPoints());
    }

    return Ok;
}


GpStatus
GpPathGradient::GetBlend(
    REAL* blendFactors,
    REAL* blendPositions,
    INT count
    ) const
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    // Check if the input buffer is big enough

    if (count < DeviceBrush.BlendCounts[0])
        return InsufficientBuffer;

    if (DeviceBrush.BlendCounts[0] == 1)
    {
        // Return falloff parameter

        blendFactors[0] = DeviceBrush.Falloffs[0];
    }
    else
    {
        // Return blend factors

        // Users want to obtain the blend factor as radial blend factors.
        // 0 blend factor means 100 % center color and 0 position means
        // the center location.  In order to return those factor and
        // position arrays, we must invert the weight and position factor
        // arrays stored in this PathGradient class.

        for(INT i = 0; i < DeviceBrush.BlendCounts[0]; i++)
        {
            blendFactors[DeviceBrush.BlendCounts[0] - 1 - i] = TOREAL(1.0 - DeviceBrush.BlendFactors[0][i]);
            blendPositions[DeviceBrush.BlendCounts[0] - 1 - i] = TOREAL(1.0 - DeviceBrush.BlendPositions[0][i]);
        }
    }

    return Ok;
}

GpStatus
GpPathGradient::SetBlend(
    const REAL* blendFactors,
    const REAL* blendPositions,
    INT count
    )
{
    if(!blendFactors || !blendPositions || count < 1)
        return InvalidParameter;

    if (count == 1)
    {
        // Setting falloff parameter

        GpFree(DeviceBrush.BlendFactors[0]);
        DeviceBrush.BlendFactors[0] = NULL;
        GpFree(DeviceBrush.BlendPositions[0]);
        DeviceBrush.BlendPositions[0] = NULL;

        if (blendFactors == NULL)
            DeviceBrush.Falloffs[0] = 1;
        else
            DeviceBrush.Falloffs[0] = blendFactors[0];

        DeviceBrush.BlendCounts[0] = 1;
    }
    else
    {
        // blend positions must start at 0.0 and end at 1.0
        
        if (REALABS(blendPositions[0]) > REAL_EPSILON ||
            REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
        {
            return InvalidParameter;
        }

        // Setting blend factors

        REAL* newFactors;
        REAL* newPositions;

        newFactors = (REAL*) GpRealloc(DeviceBrush.BlendFactors[0], count*sizeof(REAL));

        if (newFactors != NULL)
        {
            DeviceBrush.BlendFactors[0] = newFactors;
        }
        else
        {
            return OutOfMemory;
        }

        newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], count*sizeof(REAL));

        if (newPositions != NULL)
        {
            DeviceBrush.BlendPositions[0] = newPositions;
        }
        else
        {
            return OutOfMemory;
        }

        // Users will supply the blend factor as radial blend factors.
        // 0 blend factor means 100 % center color and 0 position means
        // the center location.  In order to convert those factor and position arrays
        // to the weight and position factor arrays in PathGradient,
        // we must invert the given arrays.

        for(INT i = 0; i < count; i++)
        {
            newFactors[count - 1 - i] = TOREAL(1.0 - blendFactors[i]);
            newPositions[count - 1 - i] = TOREAL(1.0 - blendPositions[i]);
        }
        DeviceBrush.BlendCounts[0] = count;
    }

    DeviceBrush.UsesPresetColors = FALSE;
    GpFree(DeviceBrush.PresetColors);
    DeviceBrush.PresetColors = NULL;
    UpdateUid();

    return Ok;
}

GpStatus
GpGradientBrush::GetSigmaBlendArray(
    REAL focus,
    REAL scale,
    INT* count,
    REAL* blendFactors,
    REAL* blendPositions)
{
    // Make sure the FPU is set correctly.

    FPUStateSaver::AssertMode();

    if(!blendFactors || !blendPositions || !count)
        return InvalidParameter;

    // This gives 1/4 of the Sigma array.

    static REAL factors[] =
    {
            0,    59,   120,   182,   247,   314,   383,   454,
          527,   602,   680,   759,   841,   926,  1013,  1102,
         1194,  1288,  1385,  1485,  1587,  1692,  1800,  1911,
         2024,  2141,  2260,  2383,  2508,  2637,  2769,  2904,
         3042,  3183,  3328,  3477,  3628,  3783,  3942,  4104,
         4270,  4439,  4612,  4789,  4969,  5153,  5341,  5533,
         5728,  5928,  6131,  6338,  6549,  6764,  6983,  7206,
         7434,  7665,  7900,  8139,  8382,  8630,  8881,  9136,
         9396,  9660,  9927, 10199, 10475, 10755, 11039, 11327,
        11619, 11916, 12216, 12520, 12828, 13140, 13456, 13776,
        14099, 14427, 14758, 15093, 15431, 15774, 16119, 16469,
        16822, 17178, 17538, 17901, 18267, 18637, 19009, 19385,
        19764, 20146, 20530, 20918, 21308, 21701, 22096, 22494,
        22894, 23297, 23702, 24109, 24518, 24929, 25342, 25756,
        26173, 26591, 27010, 27431, 27853, 28276, 28701, 29126,
        29552, 29979, 30407, 30836, 31264, 31694, 32123, 32553
    };

    if(focus < 0 || focus > 1 || scale < 0 || scale > 1)
        return InvalidParameter;

    if(blendFactors && blendPositions)
    {
        INT i, n;
        scale /= 65536;
        REAL one = 65536;

        if(focus > 0 && focus < 1)
        {
            for(i = 0; i < 128; i++)
            {
                blendFactors[i] = factors[i];
                blendPositions[i] = focus*i/255;
            }
            for(i = 128; i < 256; i++)
            {
                blendFactors[i] = one - factors[255 - i];
                blendPositions[i] = focus*i/255;
            }

            // skip i = 256 since this gives the same data.

            for(i = 257; i < 384; i++)
            {
                blendFactors[i - 1] = one - factors[i - 256];
                blendPositions[i - 1] = TOREAL(focus + (1.0 - focus)*(i - 256)/255);
            }
            for(i = 384; i < 512; i++)
            {
                blendFactors[i - 1] = factors[511 - i];
                blendPositions[i - 1] = TOREAL(focus + (1.0 - focus)*(i - 256)/255);
            }

            // Set n to 511 because we skipped index 256 above to avoid
            // the duplicate 1 entry in the ramp from 0 to 1 to 0.

            n = 511;
        }
        else if(focus == 1)
        {
            for(i = 0; i < 128; i++)
            {
                blendFactors[i] = factors[i];
                blendPositions[i] = TOREAL(i)/255;
            }
            for(i = 128; i < 256; i++)
            {
                blendFactors[i] = one - factors[255 - i];
                blendPositions[i] = TOREAL(i)/255;
            }

            n = 256;
        }
        else    // focus == 0
        {
            for(i = 256; i < 384; i++)
            {
                blendFactors[i - 256] = one - factors[i - 256];
                blendPositions[i - 256] = TOREAL(i - 256)/255;
            }
            for(i = 384; i < 512; i++)
            {
                blendFactors[i - 256] = factors[511 - i];
                blendPositions[i - 256] = TOREAL(i - 256)/255;
            }

            n = 256;
        }

        for(i = 0; i < n; i++)
            blendFactors[i] *= scale;

        *count = n;
        return Ok;
    }
    else
        return InvalidParameter;
}

GpStatus
GpGradientBrush::GetLinearBlendArray(
    REAL focus,
    REAL scale,
    INT* count,
    REAL* blendFactors,
    REAL* blendPositions)
{
    if(!blendFactors || !blendPositions || !count)
        return InvalidParameter;

    if(focus < 0 || focus > 1 || scale < 0 || scale > 1)
        return InvalidParameter;

    if(blendFactors && blendPositions)
    {
        if(focus > 0 && focus < 1)
        {
            blendFactors[0] = 0.0f;
            blendFactors[1] = scale;
            blendFactors[2] = 0.0f;

            blendPositions[0] = 0.0f;
            blendPositions[1] = focus;
            blendPositions[2] = 1.0f;

            *count = 3;
        }
        else if(focus == 1)
        {
            blendFactors[0] = 0.0f;
            blendFactors[1] = scale;

            blendPositions[0] = 0.0f;
            blendPositions[1] = 1.0f;

            *count = 2;
        }
        else    // focus == 0
        {
            blendFactors[0] = scale;
            blendFactors[1] = 0.0f;

            blendPositions[0] = 0.0f;
            blendPositions[1] = 1.0f;

            *count = 2;
        }

        return Ok;
    }
    else
        return InvalidParameter;
}

GpStatus
GpGradientBrush::SetSigmaBlend(
            REAL focus,
            REAL scale)
{
    REAL*   blendFactors = (REAL*) GpMalloc(512*sizeof(REAL));
    REAL*   blendPositions = (REAL*) GpMalloc(512*sizeof(REAL));
    INT     count;
    GpStatus status;

    if(blendFactors && blendPositions)
    {
        status = GetSigmaBlendArray(focus, scale,
                    &count, blendFactors, blendPositions);

        if(status == Ok)
            status = SetBlend(&blendFactors[0], &blendPositions[0], count);
    }
    else
        status = OutOfMemory;

    GpFree(blendFactors);
    GpFree(blendPositions);

    return status;
}

GpStatus
GpGradientBrush::SetLinearBlend(
            REAL focus,
            REAL scale)
{
    REAL    blendFactors[3];
    REAL    blendPositions[3];
    INT     count;

    GpStatus status = GetLinearBlendArray(focus, scale,
                        &count, &blendFactors[0], &blendPositions[0]);

    if(status != Ok)
        return status;

    return SetBlend(&blendFactors[0], &blendPositions[0], count);
}

//--------------------------------------------------------------------------
// Hatch Brush
//--------------------------------------------------------------------------

const BYTE GdipHatchPatterns8bpp[HatchStyleTotal][64] = {
    {    //    HatchStyleHorizontal,                   0
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleVertical,                     1
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleForwardDiagonal,              2
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80,
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
    },
    {    //    HatchStyleBackwardDiagonal,             3
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80,
        0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00,
        0x00, 0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    },
    {    //    HatchStyleCross,                        4
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDiagonalCross                 5
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x80, 0xff, 0x80,
        0x00, 0x80, 0xff, 0x80, 0x80, 0xff, 0x80, 0x00,
        0x00, 0x00, 0x80, 0xff, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xff, 0xff, 0x80, 0x00, 0x00,
        0x00, 0x80, 0xff, 0x80, 0x80, 0xff, 0x80, 0x00,
        0x80, 0xff, 0x80, 0x00, 0x00, 0x80, 0xff, 0x80,
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff,
    },
    {    //    HatchStyle05Percent,                    6
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyle10Percent,                    7
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyle20Percent,                    8
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyle25Percent,                    9
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
    },
    {    //    HatchStyle30Percent,                    10
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyle40Percent,                    11
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle50Percent,                    12
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle60Percent,                    13
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle70Percent,                    14
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyle75Percent,                    15
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyle80Percent,                    16
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyle90Percent,                    17
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyleLightDownwardDiagonal,        18
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleLightUpwardDiagonal,          19
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDarkDownwardDiagonal,         20
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleDarkUpwardDiagonal,           21
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleWideDownwardDiagonal,         22
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
    },
    {    //    HatchStyleWideUpwardDiagonal,           23
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleLightVertical,                24
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleLightHorizontal,              25
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleNarrowVertical,               26
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyleNarrowHorizontal,             27
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDarkVertical,                 28
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
    },
    {    //    HatchStyleDarkHorizontal,               29
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedDownwardDiagonal,       30
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedUpwardDiagonal,         31
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedHorizontal,             32
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDashedVertical,               33
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleSmallConfetti,                34
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
    },
    {    //    HatchStyleLargeConfetti,                35
        0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff,
        0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff,
    },
    {    //    HatchStyleZigZag,                       36
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleWave,                         37
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDiagonalBrick,                38
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleHorizontalBrick,              39
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleWeave,                        40
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStylePlaid,                        41
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDivot,                        42
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDottedGrid,                   43
        0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleDottedDiamond,                44
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleShingle,                      45
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleTrellis,                      46
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleSphere,                       47
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleSmallGrid,                    48
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
    },
    {    //    HatchStyleSmallCheckerBoard,            49
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
        0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleLargeCheckerBoard,            50
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    },
    {    //    HatchStyleOutlinedDiamond,              51
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    },
    {    //    HatchStyleSolidDiamond,                 52
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    },
};

VOID
GpHatch::InitializeData()
{
    if ((DeviceBrush.Style >= HatchStyleMin) &&
        (DeviceBrush.Style <= HatchStyleMax))
    {
        GpMemcpy(DeviceBrush.Data, GdipHatchPatterns8bpp[DeviceBrush.Style], 64);
    }
    else
    {
        WARNING1("Bad Hatch Style Value");
        GpMemset(DeviceBrush.Data, 0x00, 64);   // make it transparent
    }
}

/***************************************************************************\
*
*   Equivalence comparsion functions
*
\***************************************************************************/

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically)
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 5/28/99 peterost
*
\**************************************************************************/

BOOL
GpHatch::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpBrush::IsEqual(brush))
    {
        const GpHatch * hbrush = static_cast<const GpHatch *>(brush);
        return hbrush->DeviceBrush.Style == DeviceBrush.Style &&
               hbrush->DeviceBrush.Colors[0].IsEqual(DeviceBrush.Colors[0]) &&
               hbrush->DeviceBrush.Colors[1].IsEqual(DeviceBrush.Colors[1]);
    }
    else
    {
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).  RectGradient brushes require all four colors and
*   blend factors to be equal.
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 5/28/99 peterost
*
\**************************************************************************/

BOOL
GpRectGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpRectGradient * rbrush = static_cast<const GpRectGradient *>(brush);

        if (rbrush->DeviceBrush.UsesPresetColors == DeviceBrush.UsesPresetColors &&
            rbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0] &&
            rbrush->DeviceBrush.BlendCounts[1] == DeviceBrush.BlendCounts[1])
        {
            INT i;

            if (DeviceBrush.UsesPresetColors)
            {
                // For preset colors, only the horizontal blend variables are used.
                for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (rbrush->DeviceBrush.PresetColors[i] != DeviceBrush.PresetColors[i] ||
                        rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }

            }
            else
            {
                for (i=0; i<4; i++)
                {
                    if (!rbrush->DeviceBrush.Colors[i].IsEqual(DeviceBrush.Colors[i]))
                        return FALSE;
                }

                if (DeviceBrush.BlendCounts[0] > 1)
                {
                    for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                    {
                        if (rbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                            rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                            return FALSE;
                    }
                }
                else if (rbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
                {
                    return FALSE;
                }

                if (DeviceBrush.BlendCounts[1] > 1)
                {
                    for (i=0; i<DeviceBrush.BlendCounts[1]; i++)
                    {
                        if (rbrush->DeviceBrush.BlendFactors[1][i] != DeviceBrush.BlendFactors[1][i] ||
                            rbrush->DeviceBrush.BlendPositions[1][i] != DeviceBrush.BlendPositions[1][i])
                            return FALSE;
                    }
                }
                else if (rbrush->DeviceBrush.Falloffs[1] != DeviceBrush.Falloffs[1])
                {
                    return FALSE;
                }
            }

            return TRUE;

        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

}

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 6/2/99 peterost
*
\**************************************************************************/
#if 0
BOOL
GpRadialGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpRadialGradient * rbrush = static_cast<const GpRadialGradient *>(brush);
        if (rbrush->DeviceBrush.UsesPresetColors == DeviceBrush.UsesPresetColors &&
            rbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0])
        {
            if (DeviceBrush.UsesPresetColors)
            {
                for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (rbrush->DeviceBrush.PresetColors[i] != DeviceBrush.PresetColors[i] ||
                        rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }
            }
            else
            {
                if (rbrush->DeviceBrush.Colors[0].IsEqual(DeviceBrush.Colors[0]) &&
                    rbrush->DeviceBrush.Colors[1].IsEqual(DeviceBrush.Colors[1]))
                {
                    if (DeviceBrush.BlendCounts[0] > 1)
                    {
                        for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
                        {
                            if (rbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                                rbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                                return FALSE;
                        }
                    }
                    else if (rbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
                    {
                        return FALSE;
                    }
                }
                else
                {
                    return FALSE;
                }
            }

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

}

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 6/7/99 peterost
*
\**************************************************************************/

BOOL
GpTriangleGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpTriangleGradient * tbrush = static_cast<const GpTriangleGradient *>(brush);
        if (tbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0] &&
            tbrush->DeviceBrush.BlendCounts[1] == DeviceBrush.BlendCounts[1] &&
            tbrush->DeviceBrush.BlendCounts[2] == DeviceBrush.BlendCounts[2] &&
            tbrush->DeviceBrush.Rect.Equals(DeviceBrush.Rect))
        {
            INT   i;
            for (i=0; i<3; i++)
            {
                if (tbrush->DeviceBrush.Points[i].X != DeviceBrush.Points[i].X ||
                    tbrush->DeviceBrush.Points[i].Y != DeviceBrush.Points[i].Y ||
                    !(tbrush->DeviceBrush.Colors[i].IsEqual(DeviceBrush.Colors[i])))
                    return FALSE;
            }

            if (DeviceBrush.BlendCounts[0] > 1)
            {
                for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (tbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                        tbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }
            }
            else if (tbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
            {
                return FALSE;
            }

            if (DeviceBrush.BlendCounts[1] > 1)
            {
                for (i=0; i<DeviceBrush.BlendCounts[1]; i++)
                {
                    if (tbrush->DeviceBrush.BlendFactors[1][i] != DeviceBrush.BlendFactors[1][i] ||
                        tbrush->DeviceBrush.BlendPositions[1][i] != DeviceBrush.BlendPositions[1][i])
                        return FALSE;
                }
            }
            else if (tbrush->DeviceBrush.Falloffs[1] != DeviceBrush.Falloffs[1])
            {
                return FALSE;
            }

            if (DeviceBrush.BlendCounts[2] > 1)
            {
                for (i=0; i<DeviceBrush.BlendCounts[2]; i++)
                {
                    if (tbrush->DeviceBrush.BlendFactors[2][i] != DeviceBrush.BlendFactors[2][i] ||
                        tbrush->DeviceBrush.BlendPositions[2][i] != DeviceBrush.BlendPositions[2][i])
                        return FALSE;
                }
            }
            else if (tbrush->DeviceBrush.Falloffs[2] != DeviceBrush.Falloffs[2])
            {
                return FALSE;
            }

            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Answer TRUE if brush and the receiver are equivalent (i.e. - they will
*   render indentically).
*
* Arguments:
*
*   [IN] brush - GpBrush, or subclass, to compare this against.
*
* Return Value:
*
*   TRUE if equivalent
*
* Created - 6/7/99 peterost
*
\**************************************************************************/

BOOL
GpPathGradient::IsEqual(const GpBrush * brush) const
{
    if(!brush)
        return FALSE;

    if (brush == this)
        return TRUE;

    if (GpGradientBrush::IsEqual(brush))
    {
        const GpPathGradient * pbrush = static_cast<const GpPathGradient *>(brush);
        if (pbrush->DeviceBrush.BlendCounts[0] == DeviceBrush.BlendCounts[0] &&
            pbrush->DeviceBrush.Count == DeviceBrush.Count &&
            pbrush->DeviceBrush.OneSurroundColor == DeviceBrush.OneSurroundColor &&
            pbrush->DeviceBrush.UsesPresetColors == DeviceBrush.UsesPresetColors &&
            pbrush->DeviceBrush.Points[0].X == DeviceBrush.Points[0].X &&
            pbrush->DeviceBrush.Points[0].Y == DeviceBrush.Points[0].Y &&
            pbrush->DeviceBrush.Rect.Equals(DeviceBrush.Rect) &&
            pbrush->DeviceBrush.Colors[0].IsEqual(DeviceBrush.Colors[0])
            )
        {
            INT   i;
            for (i=0; i<DeviceBrush.Count; i++)
            {
                if (pbrush->DeviceBrush.PointsPtr[i].X != DeviceBrush.PointsPtr[i].X ||
                    pbrush->DeviceBrush.PointsPtr[i].Y != DeviceBrush.PointsPtr[i].Y ||
                    !(pbrush->DeviceBrush.ColorsPtr[i].IsEqual(DeviceBrush.ColorsPtr[i])))
                    return FALSE;
            }

            if (DeviceBrush.UsesPresetColors)
            {
                for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                {
                    if (pbrush->DeviceBrush.PresetColors[i] != DeviceBrush.PresetColors[i] ||
                        pbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                        return FALSE;
                }
            }
            else
            {
                if (DeviceBrush.BlendCounts[0] > 1)
                {
                    for (i=0; i<DeviceBrush.BlendCounts[0]; i++)
                    {
                        if (pbrush->DeviceBrush.BlendFactors[0][i] != DeviceBrush.BlendFactors[0][i] ||
                            pbrush->DeviceBrush.BlendPositions[0][i] != DeviceBrush.BlendPositions[0][i])
                            return FALSE;
                    }
                }
                else if (pbrush->DeviceBrush.Falloffs[0] != DeviceBrush.Falloffs[0])
                {
                    return FALSE;
                }
            }
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }

}


DpOutputSpan*
GpSolidFill::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    return new DpOutputSolidColorSpan(
                    DeviceBrush.SolidColor.GetPremultipliedValue(),
                    scan
                    );
}

DpOutputSpan*
GpRectGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    DpOutputSpan* span = NULL;

    ARGB argb[4];

    for(INT i = 0; i < 4; i++)
    {
        argb[i] = DeviceBrush.Colors[i].GetValue();
    }

    BOOL isHorizontal = FALSE;
    BOOL isVertical = FALSE;

    if(HasPresetColors() && DeviceBrush.BlendCounts[0] > 1)
        isHorizontal = TRUE;

    if(!isHorizontal && argb[0] == argb[2] && argb[1] == argb[3])
        isHorizontal = TRUE;

    if(!isHorizontal && argb[0] == argb[1] && argb[2] == argb[3])
        isVertical = TRUE;

    if(!isHorizontal && !isVertical)
    {
        span = new DpOutputGradientSpan(this, scan, context);
    }
    else
    {
        // !!![andrewgo] Not sure why a LinearGradient is coming down to us
        //               as BrushRectGrad - if it comes down as a BrushTypeLinearGradient
        //               (as it should) then we don't have to do any of the
        //               above 'isHorizontal', 'isVertical' stuff

        FPUStateSaver fpuState; // Set the rounding mode.

        if ((GetBrushType() == BrushTypeLinearGradient) /*|| (GetBrushType() == BrushRectGrad)*/)
        {
            if (OSInfo::HasMMX)
            {
                span = new DpOutputLinearGradientSpan_MMX(this, scan, context);
            }
            else
            {
                span = new DpOutputLinearGradientSpan(this, scan, context);
            }
        }
        else
        {
            span = new DpOutputOneDGradientSpan(this, scan, context,
                                                isHorizontal, isVertical);
        }
    }

    if (span && !span->IsValid())
    {
        delete span;
        span = NULL;
    }

    return span;
}

#if 0
DpOutputSpan*
GpRadialGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    return new DpOutputOneDGradientSpan(
                    this,
                    scan,
                    context
                    );
}


DpOutputSpan*
GpTriangleGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    return new DpOutputTriangleGradientSpan(
                    this,
                    scan,
                    context
                    );
}
#endif

DpOutputSpan*
GpPathGradient::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    FPUStateSaver::AssertMode();

    DpOutputSpan* span = NULL;
    WrapMode  wrap = DeviceBrush.Wrap;

    // Check to see if a tiled gradient is really needed.  It 
    // is not necessary if the transformed drawbounds fit 
    // entirely within the bounds of the brush rectangle.
    if (drawBounds && wrap != WrapModeClamp)
    {
        GpMatrix inverseXForm = context->WorldToDevice;
        
        if (Ok == inverseXForm.Invert())
        {  
            GpRectF brushRect = DeviceBrush.Rect;
            GpRectF transformRect;
            
            TransformBounds(
                &inverseXForm, 
                (REAL)drawBounds->GetLeft(),
                (REAL)drawBounds->GetTop(),
                (REAL)drawBounds->GetRight(),
                (REAL)drawBounds->GetBottom(),
                &transformRect
            );

            if (brushRect.Contains(transformRect))
            {
                wrap = WrapModeClamp;
            }
        }
    }

    if(wrap == WrapModeClamp)
    {
        if(!DeviceBrush.OneSurroundColor)
        {
            span = new DpOutputPathGradientSpan(
                this,
                scan,
                context
            );

        }
        else
        {
            span = new DpOutputOneDPathGradientSpan(
                this,
                scan,
                context
            );
        }
    }
    else
    {
        INT width, height, ix, iy;

        GpRectF brushRect = DeviceBrush.Rect;

        // Create a texture brush to represent this path gradient brush.
        // We do this by creating a texture as close to device resolution 
        // as we can and computing the transform (brush to world) for the
        // texture brush decomposed into two transforms that take the 
        // brush via device space. The texture brush transform 
        // usually works out to be the inverse of the world to device, so
        // the final texture brush draws with a resultant identity transform
        // regardless of the world to device matrix. (exception when there is 
        // a rotation in the w2d).

        GpPointF worldDestPoints[3];
        worldDestPoints[0].X = brushRect.X ;
        worldDestPoints[0].Y = brushRect.Y;
        worldDestPoints[1].X = worldDestPoints[0].X + brushRect.Width;
        worldDestPoints[1].Y = worldDestPoints[0].Y;
        worldDestPoints[2].X = worldDestPoints[0].X;
        worldDestPoints[2].Y = worldDestPoints[0].Y + brushRect.Height;

        // Take into account transformation by both the brush xform and
        // the world to device. This will handle transforms such as
        // UnitInch and w2d scales.
        
        // First get the destination points in world space by applying the 
        // brush transform.
        
        DeviceBrush.Xform.Transform(worldDestPoints, 3);
        
        GpPointF deviceDestPoints[3];
        GpMemcpy(deviceDestPoints, worldDestPoints, sizeof(worldDestPoints));
        
        // Now get the device space destination points by applying the 
        // world to device transform.
        
        context->WorldToDevice.Transform(deviceDestPoints, 3);
        
        // Compute the bounds in device space.
        
        REAL xmin, xmax, ymin, ymax, nextX, nextY;
        
        xmin = xmax = deviceDestPoints[1].X + 
            deviceDestPoints[2].X - deviceDestPoints[0].X;
            
        ymin = ymax = deviceDestPoints[1].Y + 
            deviceDestPoints[2].Y - deviceDestPoints[0].Y;
        
        for(INT i = 0; i < 3; i++)
        {
            nextX = deviceDestPoints[i].X;
            nextY = deviceDestPoints[i].Y;

            if(nextX < xmin)
                xmin = nextX;
            else if(nextX > xmax)
                xmax = nextX;
            if(nextY < ymin)
                ymin = nextY;
            else if(nextY > ymax)
                ymax = nextY;
        }

        // Set the optimal bitmap bounds.

        ix = GpRound(xmin);
        iy = GpRound(ymin);
        width = GpRound(xmax) - ix;
        height = GpRound(ymax) - iy;
        GpRectF bitmapBounds(0, 0, TOREAL(width), TOREAL(height));

        // Decompose brushRect --> worldDestPoints transform into two matrix.
        // mat1: brushRect --> bitmapBounds (device space)
        // mat2: bitmapBounds --> worldDestPoints

        GpMatrix mat1, mat2;
        mat1.InferAffineMatrix(bitmapBounds, brushRect);
        mat2.InferAffineMatrix(worldDestPoints, bitmapBounds);

        if(width <= 0 || height <= 0)
            return NULL;

        // Create a bitmap which the gradient will be drawn onto.
        // Make it the full width and height of the gradient, even
        // though only a small portion may be used to simplify 
        // handling by downstream functions.
        
        GpBitmap* bitmap = new GpBitmap(width, height, PixelFormat32bppARGB);  

        if(bitmap)
        {
            GpGraphics* g = bitmap->GetGraphicsContext();
            if(g)
            {
                GpLock lock(g->GetObjectLock());
                
                // Set the transform to brushRect --> bitmapBounds.

                g->MultiplyWorldTransform(mat1);

                WrapMode savedWrapMode = DeviceBrush.Wrap;
                DeviceBrush.Wrap = WrapModeClamp;
                GpMatrix savedMat = DeviceBrush.Xform;
                DeviceBrush.Xform.Reset();

                g->FillRect(this, brushRect.X, brushRect.Y,
                            brushRect.Width, brushRect.Height);
                
                DeviceBrush.Wrap = savedWrapMode;
                DeviceBrush.Xform = savedMat;

                if(MorphedBrush)
                    delete MorphedBrush;

                // Create a texuture with a unit tile and set the
                // brush transform to bitmapBounds --> worldDestPoints.

                GpTexture* texture = new GpTexture(bitmap, savedWrapMode);
                
                // span must be NULL at this point. If it's not, we're going 
                // to leak memory when we create it below, or in the case of
                // an error out, we may end up with uninitialized memory
                // being returned to the caller.
                
                ASSERT(span == NULL);
                
                if(texture)
                {
                    texture->MultiplyTransform(mat2);
    
                    span = texture->CreateOutputSpan(scan, context, drawBounds);
                }
                
                // Even if we failed to create the texture, we still want to
                // set a reasonable (NULL) value for MorphedBrush so that we
                // don't have a dangling pointer.
                
                MorphedBrush = texture;
            }
            
            // We're done with this graphics.
            // NOTE: this is explicitly done outside of the scope of the 
            // GpLock object, so that the GpLock (which modifies the graphics
            // in its destructor) doesn't touch freed memory.
            
            delete g;

            bitmap->Dispose();            
        }
    }

    return span;
}

DpOutputSpan*
GpTexture::CreateOutputSpan(
    DpScanBuffer *scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    DpOutputBilinearSpan *textureSpan = NULL;
    GpMatrix brushTransform;
    GpMatrix worldToDevice;

    // Figure out the world-to-device transform:

    worldToDevice = context->WorldToDevice;
    this->GetTransform(&brushTransform);
    worldToDevice.Prepend(brushTransform);

    // Go through our heirarchy of scan drawers:
    if (worldToDevice.IsIntegerTranslate() &&
        ((this->GetWrapMode() == WrapModeTile) ||
         (this->GetWrapMode() == WrapModeClamp)))
    {
        textureSpan = new DpOutputBilinearSpan_Identity(this,
                                                       scan,
                                                       &worldToDevice,
                                                       context);
    }
    else if (OSInfo::HasMMX &&
             GpValidFixed16(DeviceBrush.Rect.Width) &&
             GpValidFixed16(DeviceBrush.Rect.Height))
    {
        textureSpan = new DpOutputBilinearSpan_MMX(this,
                                                  scan,
                                                  &worldToDevice,
                                                  context);
    }

    // Scan drawer creation may fail, so clean up and try one last time
    if ((textureSpan) && !textureSpan->IsValid())
    {
        delete textureSpan;
        textureSpan = NULL;
    }

    if (!textureSpan)
    {
        textureSpan = new DpOutputBilinearSpan(this,
                                              scan,
                                              &worldToDevice,
                                              context);
    }

    if ((textureSpan) && !textureSpan->IsValid())
    {
        delete textureSpan;
        textureSpan = NULL;
    }

    return textureSpan;
}

DpOutputSpan*
GpHatch::CreateOutputSpan(
    DpScanBuffer *  scan,
    DpContext *context,
    const GpRect *drawBounds)
{
    if (StretchFactor == 1)
    {
        return new DpOutputHatchSpan(
                        this,
                        scan,
                        context
                        );
    }
    else
    {
        return new DpOutputStretchedHatchSpan(
                        this,
                        scan,
                        context,
                        StretchFactor
                        );
    }
}

class SolidBrushData : public ObjectTypeData
{
public:
    ARGB        SolidColor;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpSolidFill::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    SolidBrushData  brushData;
    brushData.Type       = DeviceBrush.Type;
    brushData.SolidColor = DeviceBrush.SolidColor.GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);
    return Ok;
}

UINT
GpSolidFill::GetDataSize() const
{
    return sizeof(SolidBrushData);
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpSolidFill::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((SolidBrushData *)dataBuffer)->Type) == BrushTypeSolidColor);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(SolidBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    if (!((SolidBrushData *)dataBuffer)->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    SetColor(GpColor(((SolidBrushData *)dataBuffer)->SolidColor));

    return Ok;
}

GpStatus
GpSolidFill::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32 = Color.GetValue();

    recolor->ColorAdjust(&solidColor32, 1, type);

    this->SetColor(GpColor(solidColor32));
    return Ok;
}

class TextureBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTexture::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    if (Image == NULL)
    {
        WARNING(("Image is NULL"));
        return Ok;
    }

    INT         flags = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    TextureBrushData    brushData;
    brushData.Type  = DeviceBrush.Type;
    brushData.Flags = flags;
    brushData.Wrap  = DeviceBrush.Wrap;
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    return Image->GetData(stream);
}

UINT
GpTexture::GetDataSize() const
{
    if (Image == NULL)
    {
        WARNING(("Image is NULL"));
        return 0;
    }

    UINT    size = sizeof(TextureBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    size += Image->GetDataSize();

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTexture::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((TextureBrushData *)dataBuffer)->Type) == BrushTypeTextureFill);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(TextureBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const TextureBrushData *    brushData;

    brushData = reinterpret_cast<const TextureBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    DeviceBrush.Type             = BrushTypeTextureFill;
    DeviceBrush.Wrap             = (GpWrapMode) brushData->Wrap;
    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(TextureBrushData);
    size       -= sizeof(TextureBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }
        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }
    if (Image != NULL)
    {
        Image->Dispose();
        Image = NULL;
    }

    if (size >= sizeof(ObjectTypeData))
    {
        Image = (GpImage *)GpObject::Factory(ObjectTypeImage, (const ObjectData *)dataBuffer, size);

        if (Image != NULL)
        {
            if ((Image->SetData(dataBuffer, size) == Ok) && Image->IsValid() &&
                ((ImageType = Image->GetImageType()) == ImageTypeBitmap))
            {
                GpPageUnit  unit;
                Image->GetBounds(&DeviceBrush.Rect, &unit);
                SetValid(TRUE);
                UpdateUid();
                return Ok;
            }
            Image->Dispose();
            Image = NULL;
        }
    }
    WARNING(("Failure getting image"));
    GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
    SetValid(FALSE);
    return GenericError;
}

GpStatus
GpTexture::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    if (Image != NULL)
    {
        Image->ColorAdjust(recolor, type);
        UpdateUid();
    }

    return Ok;
}


VOID GpTexture::InitializeBrush(
    GpImage* image,
    GpWrapMode wrapMode,
    const GpRectF* rect,
    const GpImageAttributes *imageAttributes)
{
    ASSERT(image && image->IsValid());

    if (!WrapModeIsValid(wrapMode))
    {
        WARNING(("bad wrap mode"));
        goto Failure;
    }

    GpImageType imageType;

    imageType = image->GetImageType();

    if (imageType == ImageTypeBitmap)
    {
        InitializeBrushBitmap(
            static_cast<GpBitmap*>(image),
            wrapMode, rect, imageAttributes
        );
    }
    else if (imageType == ImageTypeMetafile)
    {
        // For now, convert the metafile into a bitmap image and use that to
        // create the brush.

        GpBitmap *  bitmapImage;

        if (rect != NULL)
        {
            // !!! we don't handle this case yet
            if ((rect->X != 0) || (rect->Y != 0))
            {
                WARNING(("No handling for non-zero start in metafiles"));
            }
            // Don't apply the imageAttributes now, because WMF/EMF rendering
            // doesn't support alpha.  So wait until it's been converted to
            // a bitmap to apply the imageAttributes.

            bitmapImage = ((GpMetafile *)image)->GetBitmap(
                            GpRound(rect->Width),
                            GpRound(rect->Height), NULL);
        }
        else
        {
            // Let the metafile decide how big the bitmap should be

            // Don't apply the imageAttributes now, because WMF/EMF rendering
            // doesn't support alpha.  So wait until it's been converted to
            // a bitmap to apply the imageAttributes.

            bitmapImage = ((GpMetafile *)image)->GetBitmap(0, 0, NULL);
        }

        if (bitmapImage != NULL)
        {
            ASSERT (bitmapImage->IsValid());

            InitializeBrushBitmap(bitmapImage, wrapMode, NULL, imageAttributes, TRUE);
            return;
        }
        goto Failure;
    }
    else    // unknown image type
    {
        WARNING(("unknown image type"));
Failure:
        Image = NULL;
        SetValid(FALSE);
    }
}

VOID GpTexture::InitializeBrushBitmap(
    GpBitmap* bitmap,
    GpWrapMode wrapMode,
    const GpRectF* rect,
    const GpImageAttributes *imageAttributes,
    BOOL useBitmap)
{
    DeviceBrush.Type = BrushTypeTextureFill;
    DeviceBrush.Wrap = wrapMode;

    ImageType = ImageTypeBitmap;

    Image = NULL;

    FPUStateSaver fpState;   // Setup the fpu state.

    if (bitmap && bitmap->IsValid())
    {
        GpRect *pRectI = NULL;
        GpRect recti;
        if(rect)
        {
            recti.X = GpRound(rect->X);
            recti.Y = GpRound(rect->Y);
            recti.Width = GpRound(rect->Width);
            recti.Height = GpRound(rect->Height);
            pRectI = &recti;
        }

        if(imageAttributes)
        {
            GpBitmap *dst = NULL;

            if (bitmap->Recolor(
                imageAttributes->recolor, &dst,
                NULL, NULL, pRectI
            ) == Ok)
            {
                Image = dst;
                
                // If useBitmap is TRUE that means the caller has transferred
                // ownership of bitmap to us. In this case, Recolor makes
                // a clone of the bitmap that we're going to use, so we have
                // to free the bitmap passed in and use the clone instead,
                // otherwise we leak.
                
                if(useBitmap)
                {
                    bitmap->Dispose();
                }
            }
        }

        // !!! note that this should be non-premultiplied ARGB.
        //     we'll fix this when we drop premultiplied data [asecchia]
        //     also note that the output of RecolorImage is 32BPP_ARGB

        // if it's not NULL it's because the RecolorImage code cloned it already
        if (Image == NULL)
        {
            if (useBitmap)
            {
                // This is for the case where we constructed a bitmap
                // from a metafile image.
                Image = bitmap;
            }
            else
            {
                #ifdef NO_PREMULTIPLIED_ALPHA
                Image = bitmap->Clone(pRectI, PIXFMT_32BPP_ARGB);
                #else
                Image = bitmap->Clone(pRectI, PIXFMT_32BPP_PARGB);
                #endif
            }
        }
    }

    if (Image && Image->IsValid())
    {
        SetValid(TRUE);

        // Rect is given as a pixel unit in bitmap.

        GpPageUnit unit;
        Image->GetBounds(&DeviceBrush.Rect, &unit);
    }
    else
    {
        SetValid(FALSE);

        GpMemset(&DeviceBrush.Rect,
                 0,
                 sizeof(DeviceBrush.Rect));
    }
}

// See if this texture fill is really a picture fill (with a bitmap, 
// not a metafile).
BOOL 
GpTexture::IsPictureFill(
    const GpMatrix *    worldToDevice,
    const GpRect *      drawBounds
    ) const
{
    ASSERT ((drawBounds->Width > 0) && (drawBounds->Height > 0));

    BOOL        isPictureFill = FALSE;
    GpMatrix    newBrushMatrix;
    
    this->GetTransform(&newBrushMatrix);

    if (worldToDevice != NULL)
    {
        newBrushMatrix.Append(*worldToDevice);
    }

    newBrushMatrix.Translate(
        (REAL)-(drawBounds->X),
        (REAL)-(drawBounds->Y),
        MatrixOrderAppend
    );

    // See if the texture is supposed to fill the drawBounds.  
    // If so, this is a picture fill.
    if (newBrushMatrix.IsTranslateScale())
    {
        Size    size;

        // If the texture is not a bitmap, this returns InvalidParameter.
        if (this->GetBitmapSize(&size) == Ok)
        {
            GpRectF     transformedRect(0.0f, 0.0f, (REAL)size.Width, (REAL)size.Height);
            newBrushMatrix.TransformRect(transformedRect);

            // get the transformed width
            INT     deltaValue = abs(GpRound(transformedRect.Width) - drawBounds->Width);
            
            // We might be off a little because of the pixel offset mode
            // or a matrix that isn't quite right for whatever reason.
            if (deltaValue <= 2)
            {
                // get the transformed height
                deltaValue = abs(GpRound(transformedRect.Height) - drawBounds->Height);

                if (deltaValue <= 2)
                {
                    if ((abs(GpRound(transformedRect.X)) <= 2) &&
                        (abs(GpRound(transformedRect.Y)) <= 2))
                    {
                        isPictureFill = TRUE;
                    }
                }
            }
        }
    }
    return isPictureFill;
}


class RectGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    GpRectF     Rect;
    UINT32      Color0;
    UINT32      Color1;
    UINT32      Color2;
    UINT32      Color3;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRectGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    // PresetColors used for GpLineGradient, but not for GpRectGradient.
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PRESETCOLORS;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORSH;
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORSV;
    }

    RectGradientBrushData   brushData;
    brushData.Type   = DeviceBrush.Type;
    brushData.Flags  = flags;
    brushData.Wrap   = DeviceBrush.Wrap;
    brushData.Rect   = DeviceBrush.Rect;
    brushData.Color0 = DeviceBrush.Colors[0].GetValue();
    brushData.Color1 = DeviceBrush.Colors[1].GetValue();
    brushData.Color2 = DeviceBrush.Colors[2].GetValue();
    brushData.Color3 = DeviceBrush.Colors[3].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);
        INT     argbSize = DeviceBrush.BlendCounts[0] * sizeof(ARGB);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.PresetColors, argbSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORSH)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[0], realSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORSV)
    {
        INT     realSize = DeviceBrush.BlendCounts[1] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[1], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[1], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[1], realSize, NULL);
    }

    return Ok;
}

UINT
GpRectGradient::GetDataSize() const
{
    UINT        size = sizeof(RectGradientBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    // PresetColors used for GpLineGradient, but not for GpRectGradient.
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        size += sizeof(INT32) + ((sizeof(ARGB) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[1]);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRectGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((RectGradientBrushData *)dataBuffer)->Type) == BrushTypeLinearGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(RectGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const RectGradientBrushData *   brushData;
    GpColor                         colors[4];

    brushData = reinterpret_cast<const RectGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    colors[0].SetValue(brushData->Color0);
    colors[1].SetValue(brushData->Color1);
    colors[2].SetValue(brushData->Color2);
    colors[3].SetValue(brushData->Color3);

    InitializeBrush(brushData->Rect, colors, (GpWrapMode) brushData->Wrap);

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(RectGradientBrushData);
    size       -= sizeof(RectGradientBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }
        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);
        UINT argbSize = count * sizeof(ARGB);

        if (size < (realSize + argbSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        ARGB* newColors    = (ARGB*) GpRealloc(DeviceBrush.PresetColors, argbSize);

        if (newColors != NULL)
        {
            // We have to just copy in the ARGB values, because they've already
            // been premultiplied.
            // Actually PresetColors is NON-premultiplied, but this code should
            // still be right because we write them out non-premultiplied too.
            
            GpMemcpy(newColors, dataBuffer + realSize, argbSize);
            DeviceBrush.PresetColors = newColors;

            REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], realSize);

            if (newPositions != NULL)
            {
                GpMemcpy(newPositions, dataBuffer, realSize);
                DeviceBrush.BlendPositions[0] = newPositions;

                GpFree(DeviceBrush.BlendFactors[0]);
                DeviceBrush.BlendFactors[0] = NULL;
                DeviceBrush.UsesPresetColors = TRUE;
                DeviceBrush.BlendCounts[0] = count;
            }
        }

        dataBuffer += (realSize + argbSize);
        size       -= (realSize + argbSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORSH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetHorizontalBlend((REAL *)(dataBuffer + realSize),(REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORSV)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetVerticalBlend((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }
    UpdateUid();
    return Ok;
}

GpStatus
GpRectGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[4];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();
    solidColor32[2] = DeviceBrush.Colors[2].GetValue();
    solidColor32[3] = DeviceBrush.Colors[3].GetValue();

    recolor->ColorAdjust(solidColor32, 4, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);
    DeviceBrush.Colors[2].SetValue(solidColor32[2]);
    DeviceBrush.Colors[3].SetValue(solidColor32[3]);

    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL))
    {
        recolor->ColorAdjust(DeviceBrush.PresetColors, DeviceBrush.BlendCounts[0], type);
    }

    UpdateUid();
    return Ok;
}

#if 0
class RadialGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    GpRectF     Rect;
    UINT32      CenterColor;
    UINT32      BoundaryColor;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRadialGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PRESETCOLORS;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS;
    }

    RadialGradientBrushData brushData;
    brushData.Type          = DeviceBrush.Type;
    brushData.Flags         = flags;
    brushData.Wrap          = DeviceBrush.Wrap;
    brushData.Rect          = DeviceBrush.Rect;
    brushData.CenterColor   = DeviceBrush.Colors[0].GetValue();
    brushData.BoundaryColor = DeviceBrush.Colors[1].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);
        INT     argbSize = DeviceBrush.BlendCounts[0] * sizeof(ARGB);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.PresetColors, argbSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[0], realSize, NULL);
    }

    return Ok;
}

UINT
GpRadialGradient::GetDataSize() const
{
    UINT    size = sizeof(RadialGradientBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        size += sizeof(INT32) + ((sizeof(ARGB) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRadialGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
//    ASSERT ((GpBrushType)(((RadialGradientBrushData *)dataBuffer)->Type) == BrushTypeRadialGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(RadialGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const RadialGradientBrushData * brushData;
    GpColor                         centerColor;
    GpColor                         boundaryColor;

    brushData = reinterpret_cast<const RadialGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    centerColor.SetValue(brushData->CenterColor);
    boundaryColor.SetValue(brushData->BoundaryColor);

    InitializeBrush(
        brushData->Rect,
        centerColor,
        boundaryColor,
        (GpWrapMode) brushData->Wrap
        );

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(RadialGradientBrushData);
    size       -= sizeof(RadialGradientBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);
        UINT argbSize = count * sizeof(ARGB);

        if (size < (realSize + argbSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        ARGB* newColors    = (ARGB*) GpRealloc(DeviceBrush.PresetColors, argbSize);

        if (newColors != NULL)
        {
            // We have to just copy in the ARGB values, because they've already
            // been premultiplied.
            GpMemcpy(newColors, dataBuffer + realSize, argbSize);
            DeviceBrush.PresetColors = newColors;

            REAL* newPositions = (REAL*) GpRealloc(DeviceBrush.BlendPositions[0], realSize);

            if (newPositions != NULL)
            {
                GpMemcpy(newPositions, dataBuffer, realSize);
                DeviceBrush.BlendPositions[0] = newPositions;

                GpFree(DeviceBrush.BlendFactors[0]);
                DeviceBrush.BlendFactors[0] = NULL;
                DeviceBrush.UsesPresetColors = TRUE;
                DeviceBrush.BlendCounts[0] = count;
            }
        }

        dataBuffer += (realSize + argbSize);
        size       -= (realSize + argbSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpRadialGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[2];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();

    recolor->ColorAdjust(solidColor32, 2, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);

    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL))
    {
        recolor->ColorAdjust(DeviceBrush.PresetColors, DeviceBrush.BlendCounts[0], type);
    }

    UpdateUid();
    return Ok;
}

class TriangleGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    GpPointF    Points[3];
    UINT32      Color0;
    UINT32      Color1;
    UINT32      Color2;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTriangleGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS0;
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS1;
    }

    if ((DeviceBrush.BlendCounts[2] > 1) && (DeviceBrush.BlendFactors[2] != NULL) && (DeviceBrush.BlendPositions[2] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS2;
    }

    TriangleGradientBrushData   brushData;
    brushData.Type      = DeviceBrush.Type;
    brushData.Flags     = flags;
    brushData.Wrap      = DeviceBrush.Wrap;
    brushData.Points[0] = DeviceBrush.Points[0];
    brushData.Points[1] = DeviceBrush.Points[1];
    brushData.Points[2] = DeviceBrush.Points[2];
    brushData.Color0    = DeviceBrush.Colors[0].GetValue();
    brushData.Color1    = DeviceBrush.Colors[1].GetValue();
    brushData.Color2    = DeviceBrush.Colors[2].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS0)
    {
        INT     realSize = DeviceBrush.BlendCounts[0] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[0], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[0], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[0], realSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS1)
    {
        INT     realSize = DeviceBrush.BlendCounts[1] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[1], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[1], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[1], realSize, NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS2)
    {
        INT     realSize = DeviceBrush.BlendCounts[2] * sizeof(REAL);

        stream->Write(&DeviceBrush.BlendCounts[2], sizeof(INT32), NULL);
        stream->Write(DeviceBrush.BlendPositions[2], realSize, NULL);
        stream->Write(DeviceBrush.BlendFactors[2], realSize, NULL);
    }

    return Ok;
}

UINT
GpTriangleGradient::GetDataSize() const
{
    UINT    size = sizeof(RectGradientBrushData);

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[1] > 1) && (DeviceBrush.BlendFactors[1] != NULL) && (DeviceBrush.BlendPositions[1] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[1]);
    }

    if ((DeviceBrush.BlendCounts[2] > 1) && (DeviceBrush.BlendFactors[2] != NULL) && (DeviceBrush.BlendPositions[2] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[2]);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpTriangleGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
//    ASSERT ((GpBrushType)(((TriangleGradientBrushData *)dataBuffer)->Type) == BrushTypeTriangleGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(TriangleGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const TriangleGradientBrushData *   brushData;
    GpColor                             colors[3];

    brushData = reinterpret_cast<const TriangleGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    colors[0].SetValue(brushData->Color0);
    colors[1].SetValue(brushData->Color1);
    colors[2].SetValue(brushData->Color2);

    InitializeBrush(brushData->Points, colors, (GpWrapMode) brushData->Wrap);

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    dataBuffer += sizeof(TriangleGradientBrushData);
    size       -= sizeof(TriangleGradientBrushData);

    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS0)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend0((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS1)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend1((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS2)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend2((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpTriangleGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[3];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();
    solidColor32[2] = DeviceBrush.Colors[2].GetValue();

    recolor->ColorAdjust(solidColor32, 3, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);
    DeviceBrush.Colors[2].SetValue(solidColor32[2]);

    UpdateUid();
    return Ok;
}
#endif

class PathGradientBrushData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Wrap;
    UINT32      CenterColor;
    GpPointF    CenterPoint;
    UINT32      SurroundingColorCount;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPathGradient::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    UINT        pathSize              = 0;
    UINT        surroundingColorCount = DeviceBrush.OneSurroundColor ? 1 : DeviceBrush.Count;
    INT         flags                 = 0;
    GpPath *    path                  = GpPath::GetPath(DeviceBrush.Path);

    if (DeviceBrush.IsGammaCorrected)
    {
        flags |= GDIP_BRUSHFLAGS_ISGAMMACORRECTED;
    }

    if ((DeviceBrush.PointsPtr == NULL) && (path != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PATH;
        pathSize = path->GetDataSize();
        ASSERT((pathSize & 0x03) == 0);
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        flags |= GDIP_BRUSHFLAGS_TRANSFORM;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        flags |= GDIP_BRUSHFLAGS_PRESETCOLORS;
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        flags |= GDIP_BRUSHFLAGS_BLENDFACTORS;
    }

    if((DeviceBrush.FocusScaleX != 0) || (DeviceBrush.FocusScaleY != 0))
    {
        flags |= GDIP_BRUSHFLAGS_FOCUSSCALES;
    }

    PathGradientBrushData   brushData;
    brushData.Type                  = DeviceBrush.Type;
    brushData.Flags                 = flags;
    brushData.Wrap                  = DeviceBrush.Wrap;
    brushData.CenterColor           = DeviceBrush.Colors[0].GetValue();
    brushData.CenterPoint           = DeviceBrush.Points[0];
    brushData.SurroundingColorCount = surroundingColorCount;
    stream->Write(&brushData, sizeof(brushData), NULL);

    ARGB    argb;

    for (UINT i = 0; i < surroundingColorCount; i++)
    {
        argb = DeviceBrush.ColorsPtr[i].GetValue();
        stream->Write(&argb, sizeof(argb), NULL);
    }

    if (flags & GDIP_BRUSHFLAGS_PATH)
    {
        stream->Write(&pathSize, sizeof(INT32), NULL);
        path->GetData(stream);
    }
    else
    {
        INT     count = DeviceBrush.Count;

        if (DeviceBrush.PointsPtr == NULL)
        {
            count = 0;
        }
        stream->Write(&count, sizeof(INT32), NULL);
        if (count > 0)
        {
            INT pointsSize = count * sizeof(DeviceBrush.PointsPtr[0]);
            stream->Write(DeviceBrush.PointsPtr, pointsSize, NULL);
        }
    }

    if (flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        DeviceBrush.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        INT     count = DeviceBrush.BlendCounts[0];
        INT     realSize = count * sizeof(REAL);
        INT     argbSize = count * sizeof(ARGB);

        REAL    *newPositions = (REAL*) GpMalloc(realSize);

        if (newPositions == NULL )
        {
            return OutOfMemory;
        }

        ARGB    *newARGB = (ARGB*) GpMalloc(argbSize);

        if (newARGB == NULL )
        {
            GpFree(newPositions);
            return OutOfMemory;
        }

        GpColor *newPresetColors = new GpColor[count];

        if (newPresetColors == NULL)
        {
            GpFree(newPositions);
            GpFree (newARGB);
            return OutOfMemory;
        }

        // Users will supply the preset colors as radial blend colors.
        // 0 position means the center location and 1 position means the
        // the outer edge.  These are stored inverted internally, so to get back
        // to the original user values, invert again.

        GetPresetBlend(newPresetColors, newPositions, count);

        for (INT i = 0; i < count; i++)
        {
            newARGB[i] = newPresetColors[i].GetValue();
        }

        stream->Write(&count, sizeof(INT32), NULL);
        stream->Write(newPositions, realSize, NULL);
        stream->Write(newARGB, argbSize, NULL);

        GpFree(newPositions);
        GpFree(newARGB);
        delete newPresetColors;
    }

    if (flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        INT  count = DeviceBrush.BlendCounts[0];
        INT  realSize = count * sizeof(REAL);

        // Users will supply the blend factor as radial blend factors, and these are stored
        // with inverted values.  To get back the original user specified blend factors to
        // store, they must be inverted again.

        REAL *newFactors = (REAL*) GpMalloc(realSize);

        if (newFactors == NULL )
        {
            return OutOfMemory;
        }

        REAL *newPositions = (REAL*) GpMalloc(realSize);

        if (newPositions == NULL )
        {
            GpFree(newFactors);
            return OutOfMemory;
        }

        GetBlend(newFactors, newPositions, count);

        stream->Write(&count, sizeof(INT32), NULL);
        stream->Write(newPositions, realSize, NULL);
        stream->Write(newFactors, realSize, NULL);

        GpFree(newPositions);
        GpFree(newFactors);
    }

    if (flags & GDIP_BRUSHFLAGS_FOCUSSCALES)
    {
        INT     count = 2;
        REAL    focusScale[2];

        focusScale[0] = DeviceBrush.FocusScaleX;
        focusScale[1] = DeviceBrush.FocusScaleY;

        stream->Write(&count, sizeof(INT32), NULL);
        stream->Write(focusScale, 2 * sizeof(REAL), NULL);
    }

    return Ok;
}

UINT
GpPathGradient::GetDataSize() const
{
    UINT        pathSize;
    UINT        surroundingColorCount = DeviceBrush.OneSurroundColor ? 1 : DeviceBrush.Count;
    UINT        size                  = sizeof(PathGradientBrushData) +
                                        (surroundingColorCount * sizeof(ARGB));

    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if (DeviceBrush.PointsPtr != NULL)
    {
        size += sizeof(INT32) + (DeviceBrush.Count * sizeof(DeviceBrush.PointsPtr[0]));
    }
    else if (path != NULL)
    {
        pathSize = path->GetDataSize();
        ASSERT((pathSize & 0x03) == 0);
        size += sizeof(INT32) + pathSize;
    }

    if (!DeviceBrush.Xform.IsIdentity())
    {
        size += GDIP_MATRIX_SIZE;
    }

    // Note: can't have both blendFactors and presetColors at the same time
    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL) &&
        (DeviceBrush.BlendPositions[0] != NULL) && (DeviceBrush.BlendFactors[0] == NULL))
    {
        size += sizeof(INT32) + ((sizeof(ARGB) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if ((DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.BlendFactors[0] != NULL) && (DeviceBrush.BlendPositions[0] != NULL))
    {
        size += sizeof(INT32) + ((sizeof(REAL) + sizeof(REAL)) * DeviceBrush.BlendCounts[0]);
    }

    if((DeviceBrush.FocusScaleX != 0) || (DeviceBrush.FocusScaleY != 0))
    {
        size += sizeof(INT32) + 2*sizeof(REAL);
    }

    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPathGradient::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((PathGradientBrushData *)dataBuffer)->Type) == BrushTypePathGradient);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(PathGradientBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    if (DeviceBrush.PointsPtr != NULL)
    {
        GpFree(DeviceBrush.PointsPtr);
        DeviceBrush.PointsPtr = NULL;
    }

    GpPath* path = static_cast<GpPath*> (DeviceBrush.Path);

    if (path != NULL)
    {
        delete path;
        path = NULL;
    }

    const PathGradientBrushData *   brushData;
    ARGB *                          surroundingColors;

    brushData = reinterpret_cast<const PathGradientBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    dataBuffer += sizeof(PathGradientBrushData);
    size       -= sizeof(PathGradientBrushData);

    if (size < (brushData->SurroundingColorCount * sizeof(ARGB)))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    surroundingColors = (ARGB *)dataBuffer;

    dataBuffer += (brushData->SurroundingColorCount * sizeof(ARGB));
    size       -= (brushData->SurroundingColorCount * sizeof(ARGB));

    if (brushData->Flags & GDIP_BRUSHFLAGS_PATH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT    pathSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        DefaultBrush();
        DeviceBrush.Wrap = (GpWrapMode) brushData->Wrap;

        if (size < pathSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        path = new GpPath();
        if (path)
        {
            path->SetData(dataBuffer, pathSize);
        }

        DeviceBrush.Path = path;
        PrepareBrush();
        dataBuffer += pathSize;
        size       -= pathSize;
    }
    else
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        INT         count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(GpPointF)))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        InitializeBrush((GpPointF *)dataBuffer, count, (GpWrapMode) brushData->Wrap);
        dataBuffer += (count * sizeof(GpPointF));
        size       -= (count * sizeof(GpPointF));
    }

    DeviceBrush.IsGammaCorrected = ((brushData->Flags & GDIP_BRUSHFLAGS_ISGAMMACORRECTED) != 0);

    SetCenterPoint(brushData->CenterPoint);
    SetCenterColor(GpColor(brushData->CenterColor));

    DeviceBrush.OneSurroundColor = (brushData->SurroundingColorCount == 1);

    if (DeviceBrush.ColorsPtr != NULL)
    {
        for (UINT32 i = 0; i < brushData->SurroundingColorCount; i++)
        {
            SetSurroundColor(GpColor(surroundingColors[i]), i);
        }
        
        // OneSurroundColor requires n colors and they are all set to the 
        // same value. This is a very weird requirement, but that's the way
        // it was written. One color simply isn't enough.
        
        if (i == 1)
        {
            for (i = 1; (INT)i < DeviceBrush.Count; i++)
            {
                DeviceBrush.ColorsPtr[i] = GpColor(surroundingColors[0]);
            }
        }
    }
    
    if (brushData->Flags & GDIP_BRUSHFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_PRESETCOLORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);
        UINT argbSize = count * sizeof(ARGB);

        if (size < (realSize + argbSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        ARGB  *argbBuffer = (ARGB*)(dataBuffer + realSize);
        GpColor *colors = new GpColor[count];

        if (colors == NULL)
        {
            return OutOfMemory;
        }

        for (UINT i = 0; i < count; i++)
        {
            colors[i].SetValue(argbBuffer[i]);
        }

        this->SetPresetBlend(colors, (REAL *)dataBuffer, count);

        dataBuffer += (realSize + argbSize);
        size       -= (realSize + argbSize);

        delete colors;
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_BLENDFACTORS)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        UINT realSize = count * sizeof(REAL);

        if (size < (2 * realSize))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        this->SetBlend((REAL *)(dataBuffer + realSize), (REAL *)dataBuffer, count);
        dataBuffer += (2 * realSize);
        size       -= (2 * realSize);
    }

    if (brushData->Flags & GDIP_BRUSHFLAGS_FOCUSSCALES)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (2 * sizeof(REAL)))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        DeviceBrush.FocusScaleX = ((REAL *) dataBuffer)[0];
        DeviceBrush.FocusScaleY = ((REAL *) dataBuffer)[1];

        dataBuffer += (2 * sizeof(REAL));
        size       -= (2 * sizeof(REAL));
    }

    UpdateUid();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Blend any transparent colors in this brush with white. Note that
*   colors are premultiplied, since they will become fully opaque.
*
* Arguments:
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpPathGradient::BlendWithWhite()
{        
    DeviceBrush.Colors[0].SetValue(
        GpColor::ConvertToPremultiplied(DeviceBrush.Colors[0].GetValue()));
    DeviceBrush.Colors[0].BlendOpaqueWithWhite();
    
    if (DeviceBrush.UsesPresetColors)
    {
        GpColor color;
        
        for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
        {
            color.SetValue(GpColor::ConvertToPremultiplied(DeviceBrush.PresetColors[i]));
            color.BlendOpaqueWithWhite();
            DeviceBrush.PresetColors[i] = color.GetValue();
        }
    }
    else
    {
        for (INT i=0; i<DeviceBrush.Count; i++)
        {
            DeviceBrush.ColorsPtr[i].SetValue(
                GpColor::ConvertToPremultiplied(DeviceBrush.ColorsPtr[i].GetValue()));
            DeviceBrush.ColorsPtr[i].BlendOpaqueWithWhite();
        }
    }
        
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the surround color.
*
* Arguments:
*
*   [IN] color - the color to set.
*   [IN] index - which color to set.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpPathGradient::SetSurroundColor(GpColor& color, INT index)
{
    if(index >= 0 && index < DeviceBrush.Count)
    {
        if(DeviceBrush.OneSurroundColor)
        {
            if(index == 0)
            {
                DeviceBrush.ColorsPtr[0] = color;
                
                // OneSurroundColor requires n colors and they are all set to the 
                // same value. This is a very weird requirement, but that's the way
                // it was written. One color simply isn't enough.
                
                for (INT i = 1; i < DeviceBrush.Count; i++)
                {
                    DeviceBrush.ColorsPtr[i] = GpColor(DeviceBrush.ColorsPtr[0]);
                }
                
                UpdateUid();
            }
            else
            {
                if(DeviceBrush.ColorsPtr[0].GetValue() !=
                   color.GetValue())
                {
                    DeviceBrush.OneSurroundColor = FALSE;
                    DeviceBrush.ColorsPtr[index] = color;
                    UpdateUid();
                }
            }
        }
        else
        {
            DeviceBrush.ColorsPtr[index] = color;
            UpdateUid();
        }

        return Ok;
    }
    else
        return InvalidParameter;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the surround colors.
*
* Arguments:
*
*   [IN] color - the color to set.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
\**************************************************************************/

GpStatus GpPathGradient::SetSurroundColors(const GpColor* colors)
{
    GpStatus status = InvalidParameter;

    ASSERT(DeviceBrush.Count > 0);

    if(IsValid() && colors && DeviceBrush.Count > 0)
    {
        GpMemcpy(
            DeviceBrush.ColorsPtr,
            colors,
            DeviceBrush.Count*sizeof(GpColor)
        );

        DeviceBrush.OneSurroundColor = TRUE;
        
        INT i = 1;
        ARGB value = colors[0].GetValue();

        while((i < DeviceBrush.Count) && (DeviceBrush.OneSurroundColor))
        {
            if(colors[i].GetValue() != value)
            {
                DeviceBrush.OneSurroundColor = FALSE;
            }

            i++;
        }

        UpdateUid();
        status = Ok;
    }

    return status;
}



GpStatus
GpPathGradient::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    if(!recolor)
        return InvalidParameter;

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    INT     surroundingColorCount = DeviceBrush.OneSurroundColor ? 1 : DeviceBrush.Count;

    if ((surroundingColorCount > 0) && (DeviceBrush.ColorsPtr != NULL))
    {
        ARGB    solidColor32[32];
        ARGB *  color32 = solidColor32;

        if (surroundingColorCount > 32)
        {
            color32 = new ARGB[surroundingColorCount];
            if (color32 == NULL)
            {
                return OutOfMemory;
            }
        }
        INT     i;

        for (i = 0; i < surroundingColorCount; i++)
        {
            color32[i] = DeviceBrush.ColorsPtr[i].GetValue();
        }

        recolor->ColorAdjust(color32, surroundingColorCount, type);

        for (i = 0; i < surroundingColorCount; i++)
        {
            DeviceBrush.ColorsPtr[i].SetValue(color32[i]);
        }

        if (color32 != solidColor32)
        {
            delete[] color32;
        }
    }

    if (DeviceBrush.UsesPresetColors && (DeviceBrush.BlendCounts[0] > 1) && (DeviceBrush.PresetColors != NULL))
    {
        recolor->ColorAdjust(DeviceBrush.PresetColors, DeviceBrush.BlendCounts[0], type);
    }

    UpdateUid();
    return Ok;
}

class HatchBrushData : public ObjectTypeData
{
public:
    INT32       Style;
    UINT32      ForeColor;
    UINT32      BackColor;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the brush data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpHatch::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    HatchBrushData  brushData;
    brushData.Type      = DeviceBrush.Type;
    brushData.Style     = DeviceBrush.Style;
    brushData.ForeColor = DeviceBrush.Colors[0].GetValue();
    brushData.BackColor = DeviceBrush.Colors[1].GetValue();
    stream->Write(&brushData, sizeof(brushData), NULL);

    return Ok;
}

UINT
GpHatch::GetDataSize() const
{
    return sizeof(HatchBrushData);
}

/**************************************************************************\
*
* Function Description:
*
*   Read the brush object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpHatch::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpBrushType)(((HatchBrushData *)dataBuffer)->Type) == BrushTypeHatchFill);

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(HatchBrushData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const HatchBrushData *      brushData;

    brushData = reinterpret_cast<const HatchBrushData *>(dataBuffer);

    if (!brushData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    InitializeBrush(static_cast<GpHatchStyle>(brushData->Style),
                    GpColor(brushData->ForeColor),
                    GpColor(brushData->BackColor));

    UpdateUid();
    return Ok;
}

GpStatus
GpHatch::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    ASSERT(recolor != NULL);
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBrush;
    }

    ARGB    solidColor32[2];

    solidColor32[0] = DeviceBrush.Colors[0].GetValue();

    //!!! bhouse: bug?
    //            seems that this should be BackColor ... I'm making the
    //            change!
//    solidColor32[1] = ForeColor.GetValue();
    solidColor32[1] = DeviceBrush.Colors[1].GetValue();

    recolor->ColorAdjust(solidColor32, 2, type);

    DeviceBrush.Colors[0].SetValue(solidColor32[0]);
    DeviceBrush.Colors[1].SetValue(solidColor32[1]);
    UpdateUid();
    return Ok;
}

static COLORREF
AverageColors(
    const GpColor *     colors,
    INT                 count
    )
{
    REAL    r = 0;
    REAL    g = 0;
    REAL    b = 0;

    if (count > 0)
    {
        for (INT i = 0; i < count; i++)
        {
            r += colors->GetRed();
            g += colors->GetGreen();
            b += colors->GetBlue();
        }

        r /= count;
        g /= count;
        b /= count;
    }

    INT     red   = GpRound(r);
    INT     green = GpRound(g);
    INT     blue  = GpRound(b);

    return RGB(red, green, blue);
}

static COLORREF
AverageColors(
    const GpColor &     color1,
    const GpColor &     color2
    )
{
    REAL    r = ((REAL)((INT)color1.GetRed()  + (INT)color2.GetRed()))   / 2.0f;
    REAL    g = ((REAL)((INT)color1.GetGreen()+ (INT)color2.GetGreen())) / 2.0f;
    REAL    b = ((REAL)((INT)color1.GetBlue() + (INT)color2.GetBlue()))  / 2.0f;

    INT     red   = GpRound(r);
    INT     green = GpRound(g);
    INT     blue  = GpRound(b);

    return RGB(red, green, blue);
}

COLORREF
ToCOLORREF(
    const DpBrush *     deviceBrush
    )
{
    switch (deviceBrush->Type)
    {
    default:
        ASSERT(0);
        // FALLTHRU

    case BrushTypeSolidColor:
        return deviceBrush->SolidColor.ToCOLORREF();

    case BrushTypeHatchFill:
        return AverageColors(deviceBrush->Colors[0],
                             deviceBrush->Colors[1]);

    case BrushTypeTextureFill:
        return RGB(0x80, 0x80, 0x80);

//    case BrushRectGrad:
    case BrushTypeLinearGradient:
        return AverageColors(deviceBrush->Colors, 4);
#if 0
    case BrushRadialGrad:
        return AverageColors(deviceBrush->Colors[0],
                             deviceBrush->Colors[1]);

    case BrushTriangleGrad:
        return AverageColors(deviceBrush->Colors, 3);
#endif

    case BrushTypePathGradient:
        return AverageColors(deviceBrush->Colors[0],
                             deviceBrush->ColorsPtr[0]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\dpregion.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   DpRegion.cpp
*
* Abstract:
*
*   DpRegion class operates on scan-converted Y spans of rects
*
* Created:
*
*   12/17/1998 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

//#define DEBUG_REGION 1

/**************************************************************************\
*
* Function Description:
*
*   Do a binary search of the horizontal tessellation structure to find
*   the Y Span containing y.  If y is inside a Y Span, that span will be
*   returned.  If y is inside the region extent but not inside a Y Span,
*   the span whose yMin > y will be returned.  If y is less than the region
*   extent, the first Y span will be returned.  If y is greater than the
*   region extent, the last Y Span will be returned.
*
* Arguments:
*
*   [IN]  y              - y value to search for
*   [OUT] ySpanFound     - y span pointer found by the search
*   [OUT] spanIndexFound - y span index found by the search
*
* Return Value:
*
*   TRUE  - found a y span that includes the y value
*   FALSE - the y span does not include the y value
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpComplexRegion::YSpanSearch(
    INT     y,
    INT **  ySpanFound,
    INT *   spanIndexFound
    )
{
    INT     indexMin    = 0;
    INT     indexMax    = NumYSpans - 1;
    INT     indexMiddle = YSearchIndex;
    INT *   ySpan       = GetYSpan (indexMiddle);

    ASSERT((indexMiddle >= indexMin) && (indexMiddle <= indexMax));

    for (;;)
    {
        if (y >= ySpan[YSPAN_YMIN])
        {
            if (y < ySpan[YSPAN_YMAX])
            {
                *ySpanFound     = ySpan;
                *spanIndexFound = indexMiddle;
                return TRUE;
            }
            else
            {
                // If only 1 span, this could go past the indexMax
                indexMin = indexMiddle + 1;
            }
        }
        else
        {
            indexMax = indexMiddle;
        }

        if (indexMin >= indexMax)
        {
            ySpan           = GetYSpan (indexMax);
            *ySpanFound     = ySpan;
            *spanIndexFound = indexMax;
            return  (y >= ySpan[YSPAN_YMIN]) && (y < ySpan[YSPAN_YMAX]);
        }

        // If there are only 2 elements left to check, then
        // indexMiddle is set to indexMin.

        indexMiddle = (indexMin + indexMax) >> 1;
        ySpan       = GetYSpan (indexMiddle);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified point is inside this region.
*
* Arguments:
*
*   [IN]  x - x coordinate of point
*   [IN]  y - y coordinate of point
*
* Return Value:
*
*   TRUE  - point is inside the region
*   FALSE - point is not inside the region
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::PointInside(
    INT     x,
    INT     y
    )
{
    ASSERT(IsValid());

    if (ComplexData == NULL)
    {
#if 0
        if (Infinite)
        {
            return TRUE;
        }
        if (Empty)
        {
            return FALSE;
        }
#endif
        return ((x >= XMin) && (x < XMax) &&
                (y >= YMin) && (y < YMax));
    }
    else
    {
        INT *       ySpan;
        INT         ySpanIndex;

        ComplexData->ResetSearchIndex();
        if (ComplexData->YSpanSearch (y, &ySpan, &ySpanIndex))
        {
            INT *   xSpan;
            INT     numXCoords;

            xSpan      = ComplexData->XCoords + ySpan[YSPAN_XOFFSET];
            numXCoords = ySpan[YSPAN_XCOUNT];

            for (;;)
            {
                if (x < xSpan[1])
                {
                    if (x >= xSpan[0])
                    {
                        return TRUE;
                    }
                    break;
                }
                if ((numXCoords -= 2) <= 0)
                {
                    break;
                }
                xSpan += 2;
            }
        }
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Determine the visibility of the specified rectangle.
*
*   Note that some rects that could return ClippedVisible end up returning
*   PartiallyVisible (for performance reasons).
*
* Arguments:
*
*   [IN]  xMin        - minimum x of rect
*   [IN]  yMin        - minimum y of rect
*   [IN]  xMax        - maximum x of rect (exclusive)
*   [IN]  yMax        - maximum y of rect (exclusive)
*   [OUT] rectClipped - used when ClippedVisible is returned (can be NULL)
*
* Return Value:
*
*   Visibility
*       Invisible        - rect is completely outside all region rects
*       TotallyVisible   - rect is completely inside a region rect
*       ClippedVisible   - rect intersects 1 and only 1 region rect
*       PartiallyVisible - rect partially intersects at least 1 region rect
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::Visibility
DpRegion::GetRectVisibility(
    INT         xMin,
    INT         yMin,
    INT         xMax,       // exclusive
    INT         yMax,       // exclusive
    GpRect *    rectClipped
    )
{
    ASSERT(IsValid());
    ASSERT((xMin < xMax) && (yMin < yMax));

    Visibility  visibility = ClippedVisible;

    if (Infinite)
    {
IsTotallyVisible:
        if (rectClipped != NULL)
        {
            rectClipped->X      = xMin;
            rectClipped->Y      = yMin;
            rectClipped->Width  = xMax - xMin;
            rectClipped->Height = yMax - yMin;
        }
        return TotallyVisible;
    }

    BOOL    simpleRegion = (ComplexData == NULL);

    if (!Empty)
    {
        // If it is a simple region (only 1 rect) and the specified rect is
        // completely inside the region, then trivially accept it
        if (simpleRegion &&
            (xMin >= XMin) && (yMin >= YMin) &&
            (xMax <= XMax) && (yMax <= YMax))
        {
            goto IsTotallyVisible;
        }

        // Try to trivially reject rectangle.
        if ((xMax > XMin) && (xMin < XMax) &&
            (yMax > YMin) && (yMin < YMax))
        {
            // Couldn't trivially reject
            // If simple region, clip it against the region
            if (simpleRegion)
            {
ClipToRgnExtent:
                if (rectClipped)
                {
                    INT     xMinTmp = (xMin > XMin) ? xMin : XMin;
                    INT     xMaxTmp = (xMax < XMax) ? xMax : XMax;
                    INT     yMinTmp = (yMin > YMin) ? yMin : YMin;
                    INT     yMaxTmp = (yMax < YMax) ? yMax : YMax;

                    rectClipped->X      = xMinTmp;
                    rectClipped->Y      = yMinTmp;
                    rectClipped->Width  = xMaxTmp - xMinTmp;
                    rectClipped->Height = yMaxTmp - yMinTmp;
                }
                return visibility;
            }

            // else not a simple region -- see if the rect falls
            // within one of the region rects

            INT *           ySpanYMin;
            INT *           ySpanYMax;
            INT *           xSpan;
            INT             numXCoords;
            INT             ySpanIndex;
            BOOL            yMinInside;
            BOOL            yMaxInside;

            // Don't resetSearchIndex() here cause if we're calling this
            // from regionOverlaps, we want to search from where we left off
            // the last time.
            yMinInside = ComplexData->YSpanSearch(
                                    yMin,
                                    &ySpanYMin,
                                    &ySpanIndex);

            ComplexData->YSearchIndex = ySpanIndex;
            yMaxInside = ComplexData->YSpanSearch(
                                    yMax - 1,
                                    &ySpanYMax,
                                    &ySpanIndex);

            // See if both values are inside the same Y span
            // so that we are totally visible in Y
            if (yMinInside && yMaxInside && (ySpanYMin == ySpanYMax))
            {
                xSpan      = ComplexData->XCoords + ySpanYMin[YSPAN_XOFFSET];
                numXCoords = ySpanYMin[YSPAN_XCOUNT];

                for (;;)
                {
                    if (xMax <= xSpan[0])
                    {
                        goto IsInvisible;
                    }
                    if (xMin < xSpan[1])
                    {
                        // we found an intersection!
                        if (xMax <= xSpan[1])
                        {
                            if (xMin >= xSpan[0])
                            {
                                goto IsTotallyVisible;
                            }
                            if (rectClipped != NULL)
                            {
                                rectClipped->X      = xSpan[0];
                                rectClipped->Width  = xMax - xSpan[0];
                                rectClipped->Y      = yMin;
                                rectClipped->Height = yMax - yMin;
                            }
                            return ClippedVisible;
                        }
                        // we could look ahead to see if we are clipped visible
                        visibility = PartiallyVisible;
                        goto ClipToRgnExtent;
                    }
                    // continue on with loop through x spans

                    if ((numXCoords -= 2) <= 0)
                    {
                        break;
                    }
                    xSpan += 2;
                }
                goto IsInvisible;
            }

            // See if the rect intersects with at least one X Span
            // within the set of Y Spans it crosses

            // If yMax was not inside a span, ySpanYMax could be
            // one span too far
            if (yMax <= ySpanYMax[YSPAN_YMIN])
            {
                ySpanYMax -= YSPAN_SIZE;
            }
            INT *   ySpan = ySpanYMin;

            for (;;)
            {
                xSpan      = ComplexData->XCoords + ySpan[YSPAN_XOFFSET];
                numXCoords = ySpan[YSPAN_XCOUNT];

                for (;;)
                {
                    if (xMax <= xSpan[0])
                    {
                        break;
                    }
                    if (xMin < xSpan[1])
                    {
                        visibility = PartiallyVisible;
                        goto ClipToRgnExtent;
                    }
                    // continue on with loop through x spans

                    if ((numXCoords -= 2) <= 0)
                    {
                        break;
                    }
                    xSpan += 2;
                }

                if (ySpan >= ySpanYMax)
                {
                    break;
                }
                ySpan += YSPAN_SIZE;
            }
        }
    }

IsInvisible:
    // couldn't find a span that it intersected
    if (rectClipped)
    {
        rectClipped->X      = 0;
        rectClipped->Y      = 0;
        rectClipped->Width  = 0;
        rectClipped->Height = 0;
    }
    return Invisible;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified region overlaps (intersects) this
*   region at all.
*
* Arguments:
*
*   [IN]  region - region to test visibility of
*
* Return Value:
*
*   BOOL - whether region is at least partially visible or not
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::RegionVisible(
    DpRegion *  region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Empty || region->Empty)
    {
        return FALSE;
    }
    if (Infinite || region->Infinite)
    {
        return TRUE;
    }
    else // neither is empty or infinite
    {
        Visibility      visibility = GetRectVisibility(
                                            region->XMin,
                                            region->YMin,
                                            region->XMax,
                                            region->YMax);

        if (visibility == TotallyVisible)
        {
            return TRUE;
        }
        if (visibility == Invisible)
        {
            return FALSE;
        }
        if ((ComplexData == NULL) && (region->ComplexData == NULL))
        {
            return TRUE;
        }
        else
        {
            INT *           ySpan;
            INT *           ySpanLast;
            INT *           xSpan;
            INT *           xCoords;
            INT             numXCoords;
            INT             yMin;
            INT             yMax;
            INT             ySpanTmp[YSPAN_SIZE];
            INT             xCoordsTmp[2];

            if (region->ComplexData == NULL)
            {
                ySpan                = ySpanTmp;
                ySpanLast            = ySpanTmp;

                ySpan[YSPAN_YMIN]    = region->YMin;
                ySpan[YSPAN_YMAX]    = region->YMax;
                ySpan[YSPAN_XOFFSET] = 0;
                ySpan[YSPAN_XCOUNT]  = 2;

                xCoords              = xCoordsTmp;
                xCoords[0]           = region->XMin;
                xCoords[1]           = region->XMax;
            }
            else
            {
                DpComplexRegion *   complexData = region->ComplexData;
                ySpan     = complexData->YSpans;
                ySpanLast = ySpan + ((complexData->NumYSpans - 1) * YSPAN_SIZE);
                xCoords   = complexData->XCoords;
            }

            if (ComplexData != NULL)
            {
                ComplexData->ResetSearchIndex();
            }

            do
            {
                yMin = ySpan[YSPAN_YMIN];
                yMax = ySpan[YSPAN_YMAX];

                if (yMin >= YMax)
                {
                    break;  // doesn't overlap
                }
                if (yMax > YMin)
                {
                    xSpan      = xCoords + ySpan[YSPAN_XOFFSET];
                    numXCoords = ySpan[YSPAN_XCOUNT];

                    for (;;)
                    {
                        if (GetRectVisibility(xSpan[0], yMin, xSpan[1], yMax) !=
                                Invisible)
                        {
                            return TRUE;
                        }
                        if ((numXCoords -= 2) <= 0)
                        {
                            break;
                        }
                        xSpan += 2;
                    }
                }

            } while ((ySpan += YSPAN_SIZE) <= ySpanLast);
        }
    }
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect intersects this region.
*
* Arguments:
*
*   [IN]  xMin - minimum x coordinate of rect
*   [IN]  yMin - minimum y coordinate of rect
*   [IN]  xMax - maximum x coordinate of rect
*   [IN]  yMax - maximum y coordinate of rect
*
* Return Value:
*
*   BOOL
*       TRUE  - rect intersects this region
*       FALSE - rect does not intersect this region
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::RectVisible(
    INT     xMin,
    INT     yMin,
    INT     xMax,
    INT     yMax
    )
{
    ASSERT(IsValid());

    // Do Trivial Rejection Test
    if ((xMin >= XMax) || (xMax <= XMin) ||
        (yMin >= YMax) || (yMax <= YMin) ||
        (xMin >= xMax) || (yMin >= yMax)) // must test for empty rect too
    {
        return FALSE;
    }

    if (ComplexData == NULL)
    {
        return TRUE;
    }

    ComplexData->ResetSearchIndex();

    return (GetRectVisibility(xMin, yMin, xMax, yMax) != Invisible);
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect intersects this region.
*
* Arguments:
*
*   [IN]  xMin - minimum x coordinate of rect
*   [IN]  yMin - minimum y coordinate of rect
*   [IN]  xMax - maximum x coordinate of rect
*   [IN]  yMax - maximum y coordinate of rect
*
* Return Value:
*
*   BOOL
*       TRUE  - rect intersects this region
*       FALSE - rect does not intersect this region
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::RectInside(
    INT     xMin,
    INT     yMin,
    INT     xMax,
    INT     yMax
    )
{
    ASSERT(IsValid());

    // Do Trivial Rejection Test
    if ((xMin < XMin) || (xMax > XMax) ||
        (yMin < YMin) || (yMax > YMax))
    {
        return FALSE;
    }

    if (ComplexData == NULL)
    {
        return TRUE;
    }

    ComplexData->ResetSearchIndex();

    return (GetRectVisibility(xMin, yMin, xMax, yMax) == TotallyVisible);
}

#define YSPAN_INC   16

GpStatus
DpRegionBuilder::InitComplexData(
    INT     ySpans  // estimate of number of y spans required for region
    )
{
    if (ySpans < YSPAN_INC)
    {
        ySpans = YSPAN_INC;
    }

    INT     xCoordsCapacity;

    for (;;)
    {
        xCoordsCapacity = ySpans * 4;

        ComplexData = static_cast<DpComplexRegion *>(
                GpMalloc(sizeof(DpComplexRegion) +
                (ySpans * (YSPAN_SIZE * sizeof(*(ComplexData->YSpans)))) +
                (xCoordsCapacity * sizeof(*(ComplexData->XCoords)))));
        if (ComplexData != NULL)
        {
            break;
        }
        ySpans >>= 1;
        if (ySpans <= (YSPAN_INC / 2))
        {
            return OutOfMemory;
        }
    }

    DpComplexRegion *   complexData = ComplexData;

    complexData->XCoordsCapacity = xCoordsCapacity;
    complexData->XCoordsCount    = 0;
    complexData->YSpansCapacity  = ySpans;
    complexData->NumYSpans       = 0;
    complexData->YSearchIndex    = 0;
    complexData->XCoords         = reinterpret_cast<INT *>(complexData + 1);
    complexData->YSpans          = complexData->XCoords + xCoordsCapacity;
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Traverse through the region, clipping as you go, doing a fill using
*   the specified output object.
*
* Arguments:
*
*   [IN] output     - the object used to output the region spans
*   [IN] clipBounds - the bounds to clip to (if any)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/25/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Fill(
    DpOutputSpan *      output,
    GpRect *            clipBounds
    ) const
{
    GpStatus        status = Ok;

    if (!Empty)
    {
        INT     y;
        INT     xMin;
        INT     yMin;
        INT     xMax;
        INT     yMax;

        if (Infinite)
        {
            ASSERT(clipBounds != NULL);
            if (clipBounds != NULL)
            {
                xMin = clipBounds->X;
                xMax = clipBounds->GetRight();
                yMax = clipBounds->GetBottom();

                for (y = clipBounds->Y; (y < yMax) && (status == Ok); y++)
                {
                    status = output->OutputSpan(y, xMin, xMax);
                }
            }
        }
        else if (ComplexData == NULL)
        {
            xMin = XMin;
            yMin = YMin;
            xMax = XMax;
            yMax = YMax;

            if (clipBounds != NULL)
            {
                if (xMin < clipBounds->X)
                {
                    xMin = clipBounds->X;
                }
                if (yMin < clipBounds->Y)
                {
                    yMin = clipBounds->Y;
                }
                if (xMax > clipBounds->GetRight())
                {
                    xMax = clipBounds->GetRight();
                }
                if (yMax > clipBounds->GetBottom())
                {
                    yMax = clipBounds->GetBottom();
                }
            }
            for (y = yMin; (y < yMax) && (status == Ok); y++)
            {
                status = output->OutputSpan(y, xMin, xMax);
            }
        }
        else // complex region
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                    ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT *               xCoords;
            INT *               xSpan;
            INT                 numXCoords;
            INT                 numXSpan;

            if (clipBounds != NULL)
            {
                INT     ySpanIndex;

                complexData->ResetSearchIndex();
                if (YMin < clipBounds->Y)
                {
                    complexData->YSpanSearch(clipBounds->Y,
                                             &ySpan, &ySpanIndex);
                }
                if (YMax > clipBounds->GetBottom())
                {
                    complexData->YSpanSearch(clipBounds->GetBottom(),
                                             &ySpanLast, &ySpanIndex);
                }
            }
            xCoords = complexData->XCoords + ySpan[YSPAN_XOFFSET];
            for (;;)
            {
                yMin       = ySpan[YSPAN_YMIN];
                yMax       = ySpan[YSPAN_YMAX];
                numXCoords = ySpan[YSPAN_XCOUNT];

                // [agodfrey] We must clip our output range to the clip region.
                // Bug #122789 showed that, otherwise, we can take inordinately
                // long to execute. In the bug's specific case, the loop below
                // executed 67 million iterations before getting to the
                // first unclipped scan.

                if (clipBounds != NULL)
                {
                    if (yMin < clipBounds->Y)
                    {
                        yMin = clipBounds->Y;
                    }

                    if (yMax > clipBounds->GetBottom())
                    {
                        yMax = clipBounds->GetBottom();
                    }
                }

                // The code below assumes that yMax > yMin. We think this should
                // be satisfied because the clipBounds and yspan should both
                // be non-empty, and yMax >= clipBounds->Y since the code
                // above searched for a yspan which intersects the clip bounds.

                // NTRAID#NTBUG9-393985-2001/05/16-asecchia
                // This ASSERT is overactive and fires when there is no real
                // crash problem, however there is a performance issue that
                // should be addressed - see RAID bug.
                
                // ASSERT(yMax > yMin);

                if (numXCoords == 2)
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;
                    do
                    {
                        status = output->OutputSpan(yMin, xMin, xMax);

                    } while ((++yMin < yMax) && (status == Ok));
                }
                else
                {
                    do
                    {
                        for (xSpan = xCoords, numXSpan = numXCoords;;)
                        {
                            numXSpan -= 2;
                            status = output->OutputSpan(yMin,xSpan[0],xSpan[1]);
                            if (status != Ok)
                            {
                                goto Done;
                            }
                            if (numXSpan < 2)
                            {
                                break;
                            }
                            xSpan += 2;
                        }

                    } while (++yMin < yMax);

                    xCoords += numXCoords;
                }
                if (ySpan >= ySpanLast)
                {
                    break;
                }
                ySpan += YSPAN_SIZE;
            }
        }
    }
Done:
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Impelement GpOutputYSpan interface to create the region
*   data from the path data, using the rasterizer.
*   Exclusive in yMax and in the xMax'es.
*
* Arguments:
*
*   [IN] yMin       - min y of this span
*   [IN] yMax       - max y of this span
*   [IN] xCoords    - array of x coordinates (in pairs of x min, x max)
*   [IN] numXCoords - number of x coordinates in xCoords array
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegionBuilder::OutputYSpan(
    INT             yMin,
    INT             yMax,
    INT *           xCoords,    // even number of X coordinates
    INT             numXCoords  // must be a multiple of 2
    )
{
    ASSERT(IsValid());

    DpComplexRegion *   complexData = ComplexData;
    INT                 numYSpans   = complexData->NumYSpans;

#ifdef USE_YSPAN_BUILDER
    if (numYSpans > 0)
    {
        // Try to add this row to the previous row,
        // if the scans are the same and the y's match up
        INT *       ySpanPrev;
        INT *       xSpanPrev;
        INT         numXCoordsPrev;

        ySpanPrev = complexData->GetYSpan(numYSpans - 1);
        xSpanPrev = complexData->XCoords + ySpanPrev[YSPAN_XOFFSET];
        numXCoordsPrev = ySpanPrev[YSPAN_XCOUNT];

        if ((numXCoordsPrev == numXCoords) &&
            (ySpanPrev[YSPAN_YMAX] >= yMin)  &&
            (GpMemcmp (xSpanPrev, xCoords, numXCoords * sizeof(INT)) == 0))
        {
            // Yes, it did match -- just set the new yMax and return
            YMax = yMax;
            ySpanPrev[YSPAN_YMAX] = yMax;
            return Ok;
        }
    }

    // no previous spans or doesn't match previous spans
#endif

    INT                 xCount = complexData->XCoordsCount;
    INT *               ySpan;
    INT *               xArray;

    if ((complexData->YSpansCapacity > numYSpans) &&
        (complexData->XCoordsCapacity >= (xCount + numXCoords)))
    {
        complexData->NumYSpans++;
        complexData->XCoordsCount += numXCoords;
    }
    else // need more capacity
    {
        // We want to have YSPAN_INC Y spans available and
        // to have YSPAN_INC * 4 X coords available after we
        // add this data.
        INT     newYSpansCapacity  = numYSpans + (YSPAN_INC + 1);
        INT     newXCoordsCapacity = xCount + numXCoords + (YSPAN_INC * 4);
        DpComplexRegion *  oldData = complexData;

        complexData = static_cast<DpComplexRegion *>(
          GpMalloc(sizeof(DpComplexRegion) +
          (newYSpansCapacity * (YSPAN_SIZE * sizeof(*(oldData->YSpans)))) +
          (newXCoordsCapacity * sizeof(*(oldData->XCoords)))));

        if (complexData == NULL)
        {
            return OutOfMemory;
        }
        ComplexData = complexData;

        complexData->XCoordsCapacity = newXCoordsCapacity;
        complexData->XCoordsCount    = xCount + numXCoords;
        complexData->YSpansCapacity  = newYSpansCapacity;
        complexData->NumYSpans       = numYSpans + 1;
        complexData->YSearchIndex    = 0;
        complexData->XCoords         = reinterpret_cast<INT *>(complexData + 1);
        complexData->YSpans          = complexData->XCoords +
                                            newXCoordsCapacity;

        GpMemcpy(complexData->XCoords, oldData->XCoords,
                    xCount * sizeof(*(complexData->XCoords)));

        GpMemcpy(complexData->YSpans, oldData->YSpans,
                    numYSpans * (YSPAN_SIZE * sizeof(*(complexData->YSpans))));

        GpFree (oldData);
    }
    xArray = complexData->XCoords +  xCount;
    ySpan  = complexData->YSpans  + (numYSpans * YSPAN_SIZE);

    ySpan[YSPAN_YMIN]    = yMin;            // y Start (Min)
    ySpan[YSPAN_YMAX]    = yMax;            // y End   (Max)
    ySpan[YSPAN_XOFFSET] = xCount;          // XCoords index
    ySpan[YSPAN_XCOUNT]  = numXCoords;      // number of X's

    GpMemcpy (xArray, xCoords, numXCoords * sizeof(xArray[0]));

    if (numYSpans == 0)
    {
        YMin = yMin;
        XMin = xCoords[0];
        XMax = xCoords[numXCoords - 1];
    }
    else
    {
        if (XMin > xCoords[0])
        {
            XMin = xCoords[0];
        }
        if (XMax < xCoords[numXCoords - 1])
        {
            XMax = xCoords[numXCoords - 1];
        }
    }

    YMax = yMax;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Set to either empty or to infinite, depending on the value of empty.
*
* Arguments:
*
*   [IN] empty - if non-zero, initialize to empty else to infinite
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    BOOL    empty
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;

    if (!empty)
    {
        // set to infinite
        Infinite = TRUE;
        Empty    = FALSE;

        XMin     = INFINITE_MIN;
        YMin     = INFINITE_MIN;
        XMax     = INFINITE_MAX;
        YMax     = INFINITE_MAX;
    }
    else
    {
        // set to empty
        Infinite = FALSE;
        Empty    = TRUE;

        XMin     = 0;
        YMin     = 0;
        XMax     = 0;
        YMax     = 0;
    }

    SetValid(TRUE);
    UpdateUID();
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Set to the specified rect.
*
* Arguments:
*
*   [IN] rect - rect to use for the region coverage area
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const GpRect *  rect
    )
{
    ASSERT (rect != NULL);

    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    Set(rect->X, rect->Y, rect->Width, rect->Height);
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Set to the specified list of rects, which must be in the same order
*   as our YSpan data.
*
* Arguments:
*
*   [IN] rects - rects to use for the region coverage area
*   [IN] count - number of rects
*
* Return Value:
*
*   NONE
*
* Created:
*
*   05/04/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const RECT *    rects,
    INT             count
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(rects, count) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Set to the specified list of rects, which must be in the same order
*   as our YSpan data.
*
* Arguments:
*
*   [IN] rects - rects to use for the region coverage area
*   [IN] count - number of rects
*
* Return Value:
*
*   NONE
*
* Created:
*
*   05/04/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    const RECT *    rects,
    INT             count
    )
{
    if ((rects == NULL) || (count <= 0))
    {
        SetEmpty();
        return Ok;
    }

    if (count == 1)
    {
OneRect:
        Set(rects->left, rects->top,
            rects->right - rects->left,
            rects->bottom - rects->top);
        return Ok;
    }

    // Verify the first rect(s) to make sure they're not empty
    for (;;)
    {
        // Ignore any empty rects at the beginning of the list
        if ((rects->top  < rects->bottom) &&
            (rects->left < rects->right))
        {
            break;
        }

        WARNING1("Empty or Invalid Rect");
        rects++;
        if (--count == 1)
        {
            goto OneRect;
        }
    }

    {
        DpRegionBuilder     regionBuilder(count);

        if (regionBuilder.IsValid())
        {
            INT     yMin = rects->top;
            INT     yMax = rects->bottom;
            BOOL    failed = FALSE;

            DynArrayIA<INT,32>  xCoords;

            if(xCoords.ReserveSpace(count * 2) != Ok)
                goto ErrorExit;

            xCoords.Add(rects->left);
            xCoords.Add(rects->right);

            for (INT i = 1; i < count; i++)
            {
                // Ignore empty rects
                if ((rects[i].top  < rects[i].bottom) &&
                    (rects[i].left < rects[i].right))
                {
                    if (rects[i].top != yMin)
                    {
                        if (regionBuilder.OutputYSpan(yMin, yMax,
                                xCoords.GetDataBuffer(), xCoords.GetCount()) != Ok)
                        {
                            goto ErrorExit;
                        }

                        ASSERT(rects[i].top >= yMax);

                        xCoords.SetCount(0);
                        yMin = rects[i].top;
                        yMax = rects[i].bottom;
                    }

                    xCoords.Add(rects[i].left);
                    xCoords.Add(rects[i].right);
                }
                else
                {
                    WARNING1("Empty or Invalid Rect");
                }
            }

            if (xCoords.GetCount() > 0)
            {
                if (regionBuilder.OutputYSpan(yMin, yMax,
                        xCoords.GetDataBuffer(), xCoords.GetCount()) != Ok)
                {
                    goto ErrorExit;
                }
            }

            return Set(regionBuilder);
        }
    }

ErrorExit:
    SetEmpty();
    SetValid(FALSE);
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   constructor
*   Make this region be the specified rect.
*
* Arguments:
*
*   [IN] x       - starting x coordinate of rect
*   [IN] y       - starting y coordinate of rect
*   [IN] width   - width of rect
*   [IN] height  - height of rect
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    INT     x,
    INT     y,
    INT     width,
    INT     height
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    Set(x, y, width, height);
}

/**************************************************************************\
*
* Function Description:
*
*   Make this region be the specified rect.
*
* Arguments:
*
*   [IN] x       - starting x coordinate of rect
*   [IN] y       - starting y coordinate of rect
*   [IN] width   - width of rect
*   [IN] height  - height of rect
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
VOID
DpRegion::Set(
    INT     x,
    INT     y,
    INT     width,
    INT     height
    )
{
    ASSERT(IsValid());
    ASSERT((width >= 0) && (height >= 0));

    // crop to infinity
    if (x < INFINITE_MIN)
    {
        if (width < INFINITE_SIZE)
        {
            width -= (INFINITE_MIN - x);
        }
        x = INFINITE_MIN;
    }
    if (y < INFINITE_MIN)
    {
        if (height < INFINITE_SIZE)
        {
            height -= (INFINITE_MIN - y);
        }
        y = INFINITE_MIN;
    }

    if ((width  > 0) && (width  < INFINITE_SIZE) &&
        (height > 0) && (height < INFINITE_SIZE))
    {
        FreeData();

        SetValid(TRUE);
        Infinite  = FALSE;
        Empty     = FALSE;
        UpdateUID();

        XMin     = x;
        YMin     = y;
        XMax     = x + width;
        YMax     = y + height;
    }
    else if ((width <= 0) || (height <= 0))
    {
        SetEmpty();
    }
    else
    {
        SetInfinite();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the region to a cleared state with an empty coverage area.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
VOID
DpRegion::SetEmpty()
{
    ASSERT(IsValid());

    FreeData();

    SetValid(TRUE);
    Infinite   = FALSE;
    Empty      = TRUE;
    UpdateUID();


    XMin     = 0;
    YMin     = 0;
    XMax     = 0;
    YMax     = 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the region to contain an infinite coverage area.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
VOID
DpRegion::SetInfinite()
{
    ASSERT(IsValid());

    FreeData();

    SetValid(TRUE);
    Infinite  = TRUE;
    Empty     = FALSE;
    UpdateUID();

    XMin     = INFINITE_MIN;
    YMin     = INFINITE_MIN;
    XMax     = INFINITE_MAX;
    YMax     = INFINITE_MAX;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.
*   Make this region cover the area specified by the path.
*
* Arguments:
*
*   [IN] path   - specifies the coverage area in world units
*   [IN] matrix - matrix to apply to the path
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const DpPath *      path,
    const GpMatrix *    matrix
    )
{
    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(path, matrix) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Make this region cover the area specified by the path.
*
* Arguments:
*
*   [IN] path   - specifies the coverage area in world units
*   [IN] matrix - matrix to apply to the path
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    const DpPath *      path,
    const GpMatrix *    matrix
    )
{
    ASSERT(IsValid());
    ASSERT ((path != NULL) && (matrix != NULL));

    GpRect  bounds;

    path->GetBounds(&bounds, matrix);

    DpRegionBuilder     regionBuilder(bounds.Height);

    if (regionBuilder.IsValid())
    {
#ifndef USE_YSPAN_BUILDER

        GpRectBuilder   rectBuilder(&regionBuilder);

        if (rectBuilder.IsValid() &&
            (Rasterizer(path, matrix, path->GetFillMode(), &rectBuilder) == Ok))
        {
            return Set(regionBuilder);
        }
#else
        GpYSpanBuilder   ySpanBuilder(&regionBuilder);

        if (ySpanBuilder.IsValid() &&
            (Rasterizer(path, matrix, path->GetFillMode(), &ySpanBuilder) ==Ok))
        {
            return Set(regionBuilder);
        }
#endif // USE_YSPAN_BUILDER
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Make this region be a copy of the data in the specified region builder.
*
* Arguments:
*
*   [IN] regionBuilder - contains the simple or complex region data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    DpRegionBuilder &   regionBuilder
    )
{
    ASSERT(IsValid());

    DpComplexRegion *   srcComplexData = regionBuilder.ComplexData;

    if (srcComplexData != NULL)
    {
        if ((srcComplexData->NumYSpans == 1) &&
            (srcComplexData->XCoordsCount == 2))
        {
            Set(regionBuilder.XMin, regionBuilder.YMin,
                regionBuilder.XMax - regionBuilder.XMin,
                regionBuilder.YMax - regionBuilder.YMin);
            return Ok;
        }
        if (srcComplexData->NumYSpans >= 1)
        {
            ASSERT(srcComplexData->XCoordsCount >= 2);

            DpComplexRegion *   destComplexData = NULL;

            FreeData();

            SetValid(TRUE);
            Infinite   = FALSE;
            Empty      = FALSE;
            UpdateUID();


            XMin     = regionBuilder.XMin;
            YMin     = regionBuilder.YMin;
            XMax     = regionBuilder.XMax;
            YMax     = regionBuilder.YMax;

            if ((srcComplexData->YSpansCapacity - srcComplexData->NumYSpans) >=
                YSPAN_INC)
            {
                destComplexData = static_cast<DpComplexRegion *>(
                    GpMalloc(sizeof(DpComplexRegion) +
                            (srcComplexData->NumYSpans *
                            (YSPAN_SIZE * sizeof(*(srcComplexData->YSpans)))) +
                            (srcComplexData->XCoordsCount *
                            sizeof(*(srcComplexData->XCoords)))));
            }

            if (destComplexData != NULL)
            {
                destComplexData->XCoordsCapacity = srcComplexData->XCoordsCount;
                destComplexData->XCoordsCount    = srcComplexData->XCoordsCount;

                destComplexData->YSpansCapacity  = srcComplexData->NumYSpans;
                destComplexData->NumYSpans       = srcComplexData->NumYSpans;

                destComplexData->XCoords =
                                reinterpret_cast<INT*>(destComplexData + 1);
                destComplexData->YSpans  = destComplexData->XCoords +
                                           destComplexData->XCoordsCapacity;

                GpMemcpy (destComplexData->XCoords,
                          srcComplexData->XCoords,
                          srcComplexData->XCoordsCount *
                          sizeof(*(destComplexData->XCoords)));

                GpMemcpy (destComplexData->YSpans,
                          srcComplexData->YSpans,
                          srcComplexData->NumYSpans *
                          (YSPAN_SIZE * sizeof(*(destComplexData->YSpans))));
            }
            else
            {
                destComplexData = srcComplexData;
                regionBuilder.ComplexData = NULL;
            }
            destComplexData->ResetSearchIndex();
            ComplexData = destComplexData;
            return Ok;
        }
    }

    // else empty
    SetEmpty();
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor - makes a copy of the specified region
*
* Arguments:
*
*   [IN] region - region to copy
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    const DpRegion *    region,
    BOOL                lazy
    )
{
    ASSERT((region != NULL) && region->IsValid());

    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(region, lazy) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Copy constructor
*
* Arguments:
*
*   [IN] region - region to copy
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion::DpRegion(
    DpRegion &  region
    )
{
    ASSERT(region.IsValid());

    ComplexData = NULL;
    Lazy        = FALSE;
    SetValid(TRUE);
    UpdateUID();

    if (Set(&region) == Ok)
    {
        return;
    }
    SetValid(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Makes this region be a copy of another source region.
*
* Arguments:
*
*   [IN] region - region to copy.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Set(
    const DpRegion *    region,
    BOOL                lazy
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (region != NULL)
    {
        GpStatus            status = Ok;
        DpComplexRegion *   srcComplexData = region->ComplexData;

        if (srcComplexData == NULL)
        {
            Set (region->XMin, region->YMin,
                 region->XMax - region->XMin,
                 region->YMax - region->YMin);
            return Ok;
        }

        if ((region == this) && !Lazy)
        {
            return Ok;
        }

        FreeData();

        if (!lazy)
        {
            ComplexData = static_cast<DpComplexRegion*>(
                GpMalloc(sizeof(DpComplexRegion) +
                    (srcComplexData->NumYSpans *
                    (YSPAN_SIZE * sizeof(*(ComplexData->YSpans)))) +
                    (srcComplexData->XCoordsCount *
                    sizeof(*(ComplexData->XCoords)))));

            if (ComplexData == NULL)
            {
                ASSERT(0);
                SetValid(FALSE);
                return OutOfMemory;
            }

            DpComplexRegion *   destComplexData = ComplexData;

            destComplexData->XCoordsCapacity = srcComplexData->XCoordsCount;
            destComplexData->XCoordsCount    = srcComplexData->XCoordsCount;

            destComplexData->YSpansCapacity  = srcComplexData->NumYSpans;
            destComplexData->NumYSpans       = srcComplexData->NumYSpans;

            destComplexData->ResetSearchIndex();

            destComplexData->XCoords= reinterpret_cast<INT*>(destComplexData+1);
            destComplexData->YSpans = destComplexData->XCoords +
                                      destComplexData->XCoordsCapacity;

            GpMemcpy (destComplexData->XCoords,
                    srcComplexData->XCoords,
                    srcComplexData->XCoordsCount *
                    sizeof(*(destComplexData->XCoords)));

            GpMemcpy (destComplexData->YSpans,
                    srcComplexData->YSpans,
                    srcComplexData->NumYSpans *
                    (YSPAN_SIZE * sizeof(*(destComplexData->YSpans))));
        }
        else
        {
            ComplexData = srcComplexData;
            Lazy        = TRUE;
        }

        SetValid(TRUE);
        Empty    = FALSE;
        Infinite = FALSE;
        UpdateUID();

        XMin     = region->XMin;
        YMin     = region->YMin;
        XMax     = region->XMax;
        YMax     = region->YMax;

        return Ok;
    }

    return InvalidParameter;
}

/**************************************************************************\
*
* Function Description:
*
*   assignment operator.
*
* Arguments:
*
*   [IN] region - region to copy
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
DpRegion &
DpRegion::operator=(
    DpRegion & region
    )
{
    ASSERT(IsValid());
    ASSERT(region.IsValid());

    Set (&region);  // what do we do if this fails?
    return *this;   // Assignment operator returns left side.
}

/**************************************************************************\
*
* Function Description:
*
*   Offset (translate) the region by the specified offset values
*
* Arguments:
*
*   [IN] xOffset - x offset (delta) value
*   [IN] yOffset - y offset (delta) value
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Offset(
    INT     xOffset,
    INT     yOffset
    )
{
    ASSERT(IsValid());

    if ((xOffset | yOffset) != 0)
    {
        // copy the data, so it's not a lazy copy
        if (Lazy && (Set(this) != Ok))
        {
            return GenericError;
        }

        if (Infinite || Empty)
        {
            return Ok;
        }

        if (xOffset != 0)
        {
            XMin += xOffset;
            XMax += xOffset;

            // !!! Handle this for non-debug case
            ASSERT((XMin >= INFINITE_MIN) && (XMin <= INFINITE_MAX));
            ASSERT((XMax >= INFINITE_MIN) && (XMax <= INFINITE_MAX));

            if (ComplexData != NULL)
            {
                INT *   xCoords = ComplexData->XCoords;
                INT     count   = ComplexData->XCoordsCount;

                while (count >= 2)
                {
                    xCoords[0] += xOffset;
                    xCoords[1] += xOffset;
                    xCoords += 2;
                    count -= 2;
                }
            }
        }
        if (yOffset != 0)
        {
            YMin += yOffset;
            YMax += yOffset;

            // !!! Handle this for non-debug case
            ASSERT((YMin >= INFINITE_MIN) && (YMin <= INFINITE_MAX));
            ASSERT((YMax >= INFINITE_MIN) && (YMax <= INFINITE_MAX));

            if (ComplexData != NULL)
            {
                INT *   ySpans = ComplexData->YSpans;
                INT     count  = ComplexData->NumYSpans;

                while (count > 0)
                {
                    ySpans[YSPAN_YMIN] += yOffset;
                    ySpans[YSPAN_YMAX] += yOffset;
                    ySpans += YSPAN_SIZE;
                    count--;
                }
            }
        }
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   See if another region is identical in coverage to this one.
*   For this to work, infinite regions must all have the same data.
*
* Arguments:
*
*   [IN] region - region to compare with
*
* Return Value:
*
*   TRUE    - regions cover the same area
*   FALSE   - regions not identical
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
BOOL
DpRegion::IsEqual(
    DpRegion *  region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (!Empty)
    {
        if ((XMin == region->XMin) &&
            (YMin == region->YMin) &&
            (XMax == region->XMax) &&
            (YMax == region->YMax))
        {
            if (ComplexData == NULL)
            {
                return (region->ComplexData == NULL);
            }
            if (region->ComplexData == NULL)
            {
                return FALSE;
            }
            if (ComplexData->NumYSpans == region->ComplexData->NumYSpans)
            {
                // If the ySpans are the same, then the size of the
                // xCoords buffers should also be the same.
                return ((GpMemcmp (ComplexData->YSpans,
                                   region->ComplexData->YSpans,
                                   ComplexData->NumYSpans *
                                   YSPAN_SIZE * sizeof(INT)) == 0) &&
                        (GpMemcmp (ComplexData->XCoords,
                                   region->ComplexData->XCoords,
                                   ComplexData->XCoordsCount *
                                   sizeof(INT)) == 0));
            }
        }
        return FALSE;
    }
    return region->Empty;
}

/**************************************************************************\
*
* Function Description:
*
*   Add Y Span data to a regionBuilder, compacting the data as we go.
*   Used by the region combine methods.
*
* Arguments:
*
*   [IN] yMin          - min y of this span
*   [IN] yMax          - max y of this span
*   [IN] xCoords       - array of x coordinates (in pairs of x min, x max)
*   [IN] numXCoords    - number of x coordinates in xCoords array
*   [IN] regionBuilder - the region builder that stores the data
*   [IN] combineCoords - used to compact the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::CompactAndOutput(
    INT                 yMin,
    INT                 yMax,
    INT *               xCoords,
    INT                 numXCoords,
    DpRegionBuilder *   regionBuilder,
    DynIntArray *       combineCoords
    )
{
    // numEdgeCoords could be 0 when this is called from the combine code
    if (numXCoords > 0)
    {
        if (numXCoords > 2)
        {
            // Try to compact the X Span data.
            // First, make a copy of the data if we need to
            // so we can compact it in place.
            if (combineCoords != NULL)
            {
                combineCoords->Reset(FALSE);
                if (combineCoords->AddMultiple(xCoords, numXCoords) != Ok)
                {
                    return OutOfMemory;
                }
                xCoords = combineCoords->GetDataBuffer();
            }

            INT         indexDest = 0;
            INT         index     = 2;
            INT         indexLast = numXCoords - 2;

            numXCoords = 2;
            do
            {
                if ((xCoords[indexDest + 1]) >= xCoords[index])
                {
                    xCoords[indexDest + 1] = xCoords[index + 1];
                    index += 2;
                }
                else
                {
                    indexDest  += 2;
                                        if (indexDest != index)
                                        {
                                                xCoords[indexDest]   = xCoords[index];
                                                xCoords[indexDest+1] = xCoords[index+1];
                                        }
                    index      += 2;
                    numXCoords += 2;
                }
            } while (index <= indexLast);
        }

#ifndef USE_YSPAN_BUILDER
        DpComplexRegion *   complexData = regionBuilder->ComplexData;

        if (complexData->NumYSpans > 0)
        {
            // Try to add this row to the previous row,
            // if the scans are the same and the y's match up
            INT *       ySpanPrev;
            INT *       xSpanPrev;
            INT         numXCoordsPrev;

            ySpanPrev = complexData->GetYSpan(complexData->NumYSpans - 1);
            xSpanPrev = complexData->XCoords + ySpanPrev[YSPAN_XOFFSET];
            numXCoordsPrev = ySpanPrev[YSPAN_XCOUNT];

            if ((numXCoordsPrev == numXCoords) &&
                (ySpanPrev[YSPAN_YMAX] >= yMin)  &&
                (GpMemcmp (xSpanPrev, xCoords, numXCoords * sizeof(INT)) == 0))
            {
                // Yes, it did match -- just set the new yMax and return
                regionBuilder->YMax = yMax;
                ySpanPrev[YSPAN_YMAX] = yMax;
                return Ok;
            }
        }
#endif // USE_YSPAN_BUILDER

        return regionBuilder->OutputYSpan(yMin, yMax, xCoords, numXCoords);
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the AND operator.
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::And(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Empty || (region->Infinite) || (region == this))
    {
        return Ok;
    }
    if (Infinite)
    {
        return Set(region);
    }
    if (region->Empty)
    {
        SetEmpty();
        return Ok;
    }
    // check if the region totally encompasses this
    if ((region->ComplexData == NULL) &&
        (region->XMin <= XMin) &&
        (region->YMin <= YMin) &&
        (region->XMax >= XMax) &&
        (region->YMax >= YMax))
    {
        return Ok;
    }
    // check if this totally encompasses the region
    if ((ComplexData == NULL) &&
        (XMin <= region->XMin) &&
        (YMin <= region->YMin) &&
        (XMax >= region->XMax) &&
        (YMax >= region->YMax))
    {
        return Set(region);
    }
    // check for no intersection
    if ((XMin >= region->XMax) ||
        (region->XMax <= XMin) ||
        (XMax <= region->XMin) ||
        (region->XMin >= XMax) ||
        (YMin >= region->YMax) ||
        (region->YMax <= YMin) ||
        (YMax <= region->YMin) ||
        (region->YMin >= YMax))
    {
        SetEmpty();
        return Ok;
    }
    else
    {
        INT *           ySpan1;
        INT *           ySpan2;
        INT *           ySpan1Last;
        INT *           ySpan2Last;
        INT *           xCoords1;
        INT *           xCoords2;
        INT             ySpan1Tmp[YSPAN_SIZE];
        INT             ySpan2Tmp[YSPAN_SIZE];
        INT             xCoords1Tmp[2];
        INT             xCoords2Tmp[2];
        INT             yMin1 = YMin;
        INT             yMax1;
        INT             yMin2 = region->YMin;
        INT             yMax2;
        INT             numYSpans1;
        INT             numYSpans2;
        INT             combineTmp[4];
        DynIntArray     combineCoords(combineTmp, 4);

        if (ComplexData == NULL)
        {
            numYSpans1            = 1;
            ySpan1                = ySpan1Tmp;
            ySpan1Last            = ySpan1Tmp;
            yMax1                 = YMax;

            ySpan1[YSPAN_YMIN]    = yMin1;
            ySpan1[YSPAN_YMAX]    = yMax1;
            ySpan1[YSPAN_XOFFSET] = 0;
            ySpan1[YSPAN_XCOUNT]  = 2;

            xCoords1              = xCoords1Tmp;
            xCoords1[0]           = XMin;
            xCoords1[1]           = XMax;
        }
        else
        {
            numYSpans1 = ComplexData->NumYSpans;
            ySpan1     = ComplexData->YSpans;
            ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
            yMax1      = ySpan1[YSPAN_YMAX];
            xCoords1   = ComplexData->XCoords;
        }
        if (region->ComplexData == NULL)
        {
            numYSpans2            = 1;
            ySpan2                = ySpan2Tmp;
            ySpan2Last            = ySpan2Tmp;
            yMax2                 = region->YMax;

            ySpan2[YSPAN_YMIN]    = yMin2;
            ySpan2[YSPAN_YMAX]    = yMax2;
            ySpan2[YSPAN_XOFFSET] = 0;
            ySpan2[YSPAN_XCOUNT]  = 2;

            xCoords2              = xCoords2Tmp;
            xCoords2[0]           = region->XMin;
            xCoords2[1]           = region->XMax;
        }
        else
        {
            numYSpans2 = region->ComplexData->NumYSpans;
            ySpan2     = region->ComplexData->YSpans;
            ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
            yMax2      = ySpan2[YSPAN_YMAX];
            xCoords2   = region->ComplexData->XCoords;
        }

        DpRegionBuilder regionBuilder(numYSpans1 + numYSpans2);

        if (!regionBuilder.IsValid())
        {
            return OutOfMemory;
        }

        for (;;)
        {
            if (yMin1 <= yMin2)
            {
                if (yMax1 > yMin2)
                {
                    if (XSpansAND(
                            &combineCoords,
                            xCoords1 + ySpan1[YSPAN_XOFFSET],
                            ySpan1[YSPAN_XCOUNT],
                            xCoords2 + ySpan2[YSPAN_XOFFSET],
                            ySpan2[YSPAN_XCOUNT]) == Ok)
                    {
                        if (yMax1 <= yMax2)
                        {
                            if (CompactAndOutput(
                                    yMin2,
                                    yMax1,
                                    combineCoords.GetDataBuffer(),
                                    combineCoords.GetCount(),
                                    &regionBuilder, NULL) == Ok)
                            {
                                goto AndIncYSpan1;
                            }
                        }
                        else
                        {
                            if (CompactAndOutput(
                                    yMin2,
                                    yMax2,
                                    combineCoords.GetDataBuffer(),
                                    combineCoords.GetCount(),
                                    &regionBuilder, NULL) == Ok)
                            {
                                goto AndIncYSpan2;
                            }
                        }
                    }
                    return GenericError;
                }
                goto AndIncYSpan1;
            }
            if (yMax2 > yMin1)
            {
                if (XSpansAND(
                        &combineCoords,
                        xCoords1 + ySpan1[YSPAN_XOFFSET],
                        ySpan1[YSPAN_XCOUNT],
                        xCoords2 + ySpan2[YSPAN_XOFFSET],
                        ySpan2[YSPAN_XCOUNT]) == Ok)
                {
                    if (yMax2 <= yMax1)
                    {
                        if (CompactAndOutput(
                                yMin1,
                                yMax2,
                                combineCoords.GetDataBuffer(),
                                combineCoords.GetCount(),
                                &regionBuilder, NULL) == Ok)
                        {
                            goto AndIncYSpan2;
                        }
                    }
                    else
                    {
                        if (CompactAndOutput(
                                yMin1,
                                yMax1,
                                combineCoords.GetDataBuffer(),
                                combineCoords.GetCount(),
                                &regionBuilder, NULL) == Ok)
                        {
                            goto AndIncYSpan1;
                        }
                    }
                }
                return GenericError;
            }
            // else goto AndIncYSpan2

AndIncYSpan2:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                break;
            }
            yMin2 = ySpan2[YSPAN_YMIN];
            yMax2 = ySpan2[YSPAN_YMAX];
            continue;

AndIncYSpan1:
            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                break;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }
        return Set(regionBuilder);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the AND operator.
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansAND(
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT     xMin1 = xSpan1[0];
        INT     xMax1 = xSpan1[1];
        INT     xMin2 = xSpan2[0];
        INT     xMax2 = xSpan2[1];

        for (;;)
        {
            if (xMin1 <= xMin2)
            {
                if (xMax1 > xMin2)
                {
                    XCoords[count++] = xMin2;       // left
                    if (xMax1 <= xMax2)
                    {
                        XCoords[count++] = xMax1;   // right
                        goto AndIncXSpan1;
                    }
                    XCoords[count++] = xMax2;       // right
                    goto AndIncXSpan2;
                }
                goto AndIncXSpan1;
            }
            if (xMax2 > xMin1)
            {
                XCoords[count++] = xMin1;           // left
                if (xMax2 <= xMax1)
                {
                    XCoords[count++] = xMax2;       // right
                    goto AndIncXSpan2;
                }
                XCoords[count++] = xMax1;           // right
                goto AndIncXSpan1;
            }
            // else goto AndIncXSpan2;

AndIncXSpan2:
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xSpan2 += 2;
            xMin2    = xSpan2[0];
            xMax2    = xSpan2[1];
            continue;

AndIncXSpan1:
            if ((numXCoords1 -= 2) < 2)
            {
                break;
            }
            xSpan1 += 2;
            xMin1    = xSpan1[0];
            xMax1    = xSpan1[1];
        }
        combineCoords->SetCount(count);
        return Ok;
    }
    return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the OR operator.
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Or(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Infinite || region->Empty || (region == this))
    {
        return Ok;
    }
    if (region->Infinite)
    {
        SetInfinite();
        return Ok;
    }
    if (Empty)
    {
        return Set(region);
    }
    // check if the region totally encompasses this
    if ((region->ComplexData == NULL) &&
        (region->XMin <= XMin) &&
        (region->YMin <= YMin) &&
        (region->XMax >= XMax) &&
        (region->YMax >= YMax))
    {
        Set(region->XMin, region->YMin,
            region->XMax - region->XMin,
            region->YMax - region->YMin);
        return Ok;
    }
    // check if this totally encompasses the region
    if ((ComplexData == NULL) &&
        (XMin <= region->XMin) &&
        (YMin <= region->YMin) &&
        (XMax >= region->XMax) &&
        (YMax >= region->YMax))
    {
        return Ok;
    }
    else
    {
        INT *           ySpan1;
        INT *           ySpan2;
        INT *           ySpan1Last;
        INT *           ySpan2Last;
        INT *           xCoords1;
        INT *           xCoords2;
        INT             ySpan1Tmp[YSPAN_SIZE];
        INT             ySpan2Tmp[YSPAN_SIZE];
        INT             xCoords1Tmp[2];
        INT             xCoords2Tmp[2];
        INT             yMin1 = YMin;
        INT             yMax1;
        INT             yMin2 = region->YMin;
        INT             yMax2;
        INT             numYSpans1;
        INT             numYSpans2;
        INT             combineTmp[4];
        DynIntArray     combineCoords(combineTmp, 4);

        if (ComplexData == NULL)
        {
            numYSpans1            = 1;
            ySpan1                = ySpan1Tmp;
            ySpan1Last            = ySpan1Tmp;
            yMax1                 = YMax;

            ySpan1[YSPAN_YMIN]    = yMin1;
            ySpan1[YSPAN_YMAX]    = yMax1;
            ySpan1[YSPAN_XOFFSET] = 0;
            ySpan1[YSPAN_XCOUNT]  = 2;

            xCoords1              = xCoords1Tmp;
            xCoords1[0]           = XMin;
            xCoords1[1]           = XMax;
        }
        else
        {
            numYSpans1 = ComplexData->NumYSpans;
            ySpan1     = ComplexData->YSpans;
            ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
            yMax1      = ySpan1[YSPAN_YMAX];
            xCoords1   = ComplexData->XCoords;
        }
        if (region->ComplexData == NULL)
        {
            numYSpans2            = 1;
            ySpan2                = ySpan2Tmp;
            ySpan2Last            = ySpan2Tmp;
            yMax2                 = region->YMax;

            ySpan2[YSPAN_YMIN]    = yMin2;
            ySpan2[YSPAN_YMAX]    = yMax2;
            ySpan2[YSPAN_XOFFSET] = 0;
            ySpan2[YSPAN_XCOUNT]  = 2;

            xCoords2              = xCoords2Tmp;
            xCoords2[0]           = region->XMin;
            xCoords2[1]           = region->XMax;
        }
        else
        {
            numYSpans2 = region->ComplexData->NumYSpans;
            ySpan2     = region->ComplexData->YSpans;
            ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
            yMax2      = ySpan2[YSPAN_YMAX];
            xCoords2   = region->ComplexData->XCoords;
        }

        DpRegionBuilder regionBuilder(numYSpans1 + numYSpans2);
        BOOL            done = FALSE;
        INT             numXCoords;
        INT *           xSpan;

        if (!regionBuilder.IsValid())
        {
            return OutOfMemory;
        }

        for (;;)
        {
            if (yMin1 < yMin2)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (yMax1 <= yMin2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto OrIncYSpan1;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMin2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin1 = yMin2;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            else if (yMin1 > yMin2)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (yMax2 <= yMin1)
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMax2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto OrIncYSpan2;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMin1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin2 = yMin1;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            // else if (yMin1 == yMin2)
            if (XSpansOR (
                    &combineCoords,
                    xCoords1 + ySpan1[YSPAN_XOFFSET],
                    ySpan1[YSPAN_XCOUNT],
                    xCoords2 + ySpan2[YSPAN_XOFFSET],
                    ySpan2[YSPAN_XCOUNT]) == Ok)
            {
                if (yMax1 < yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin2 = yMax1;
                        goto OrIncYSpan1;
                    }
                }
                else if (yMax1 > yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax2,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin1 = yMax2;
                        goto OrIncYSpan2;
                    }
                }
                else // if (yMax1 == yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        goto OrIncYSpanBoth;
                    }
                }
            }
            return GenericError;

OrIncYSpanBoth:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                done = TRUE;
            }
            else
            {
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }

            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto OrCheckMoreY2Spans;
            }
            else
            {
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }

            if (done)
            {
                break;
            }
            continue;

OrIncYSpan2:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                break;
            }
            yMin2 = ySpan2[YSPAN_YMIN];
            yMax2 = ySpan2[YSPAN_YMAX];
            continue;

OrIncYSpan1:
            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto OrCheckMoreY2Spans;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }

        if (ySpan1 <= ySpan1Last)
        {
            for (;;)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin1,
                        yMax1,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan1 += YSPAN_SIZE;
                if (ySpan1 > ySpan1Last)
                {
                    break;
                }
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }
        }

OrCheckMoreY2Spans:

        if (ySpan2 <= ySpan2Last)
        {
            for (;;)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin2,
                        yMax2,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan2 += YSPAN_SIZE;
                if (ySpan2 > ySpan2Last)
                {
                    break;
                }
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }
        }
        return Set(regionBuilder);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the OR operator.
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansOR (
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT     xMin1 = xSpan1[0];
        INT     xMax1 = xSpan1[1];
        INT     xMin2 = xSpan2[0];
        INT     xMax2 = xSpan2[1];
        BOOL         done = FALSE;

        for (;;)
        {
            if (xMin1 <= xMin2)
            {
                XCoords[count++] = xMin1;
                if (xMax1 <= xMin2)
                {
                    XCoords[count++] = xMax1;
                    goto OrIncXSpan1;
                }
                XCoords[count++] = (xMax1 <= xMax2) ? xMax2 : xMax1;
                goto OrIncXSpanBoth;
            }
            XCoords[count++] = xMin2;
            if (xMax2 <= xMin1)
            {
                XCoords[count++] = xMax2;
                goto OrIncXSpan2;
            }
            XCoords[count++] = (xMax2 <= xMax1) ? xMax1 : xMax2;
            // goto OrIncXSpanBoth;

OrIncXSpanBoth:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                done = TRUE;
            }
            else
            {
                xMin2 = xSpan2[0];
                xMax2 = xSpan2[1];
            }

            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto OrCheckMoreX2Spans;
            }
            else
            {
                xMin1 = xSpan1[0];
                xMax1 = xSpan1[1];
            }

            if (done)
            {
                break;
            }
            continue;

OrIncXSpan2:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xMin2 = xSpan2[0];
            xMax2 = xSpan2[1];
            continue;

OrIncXSpan1:
            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto OrCheckMoreX2Spans;
            }
            xMin1 = xSpan1[0];
            xMax1 = xSpan1[1];
        }

        while (numXCoords1 >= 2)
        {
            XCoords[count++] = xSpan1[0];
            XCoords[count++] = xSpan1[1];

            numXCoords1 -= 2;
            xSpan1     += 2;
        }

OrCheckMoreX2Spans:

        while (numXCoords2 >= 2)
        {
            XCoords[count++] = xSpan2[0];
            XCoords[count++] = xSpan2[1];

            numXCoords2 -= 2;
            xSpan2     += 2;
        }
        combineCoords->SetCount(count);
        return Ok;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the XOR operator.
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Xor(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (region == this)
    {
        SetEmpty();
        return Ok;
    }
    if (region->Empty)
    {
        return Ok;
    }
    if (Empty)
    {
        return Set(region);
    }
    if (Infinite)
    {
        if (region->Infinite)
        {
            SetEmpty();
            return Ok;
        }
        return Exclude(region);
    }
    if (region->Infinite)
    {
        return Complement(region);
    }
    else
    {
        INT *           ySpan1;
        INT *           ySpan2;
        INT *           ySpan1Last;
        INT *           ySpan2Last;
        INT *           xCoords1;
        INT *           xCoords2;
        INT             ySpan1Tmp[YSPAN_SIZE];
        INT             ySpan2Tmp[YSPAN_SIZE];
        INT             xCoords1Tmp[2];
        INT             xCoords2Tmp[2];
        INT             yMin1 = YMin;
        INT             yMax1;
        INT             yMin2 = region->YMin;
        INT             yMax2;
        INT             numYSpans1;
        INT             numYSpans2;
        INT             combineTmp[4];
        DynIntArray     combineCoords(combineTmp, 4);

        if (ComplexData == NULL)
        {
            numYSpans1            = 1;
            ySpan1                = ySpan1Tmp;
            ySpan1Last            = ySpan1Tmp;
            yMax1                 = YMax;

            ySpan1[YSPAN_YMIN]    = yMin1;
            ySpan1[YSPAN_YMAX]    = yMax1;
            ySpan1[YSPAN_XOFFSET] = 0;
            ySpan1[YSPAN_XCOUNT]  = 2;

            xCoords1              = xCoords1Tmp;
            xCoords1[0]           = XMin;
            xCoords1[1]           = XMax;
        }
        else
        {
            numYSpans1 = ComplexData->NumYSpans;
            ySpan1     = ComplexData->YSpans;
            ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
            yMax1      = ySpan1[YSPAN_YMAX];
            xCoords1   = ComplexData->XCoords;
        }
        if (region->ComplexData == NULL)
        {
            numYSpans2            = 1;
            ySpan2                = ySpan2Tmp;
            ySpan2Last            = ySpan2Tmp;
            yMax2                 = region->YMax;

            ySpan2[YSPAN_YMIN]    = yMin2;
            ySpan2[YSPAN_YMAX]    = yMax2;
            ySpan2[YSPAN_XOFFSET] = 0;
            ySpan2[YSPAN_XCOUNT]  = 2;

            xCoords2              = xCoords2Tmp;
            xCoords2[0]           = region->XMin;
            xCoords2[1]           = region->XMax;
        }
        else
        {
            numYSpans2 = region->ComplexData->NumYSpans;
            ySpan2     = region->ComplexData->YSpans;
            ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
            yMax2      = ySpan2[YSPAN_YMAX];
            xCoords2   = region->ComplexData->XCoords;
        }

        DpRegionBuilder regionBuilder(2 * (numYSpans1 + numYSpans2));
        BOOL            done = FALSE;
        INT             numXCoords;
        INT *           xSpan;

        if (!regionBuilder.IsValid())
        {
            return OutOfMemory;
        }

        for (;;)
        {
            if (yMin1 < yMin2)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (yMax1 <= yMin2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto XorIncYSpan1;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMin2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin1 = yMin2;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            else if (yMin1 > yMin2)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (yMax2 <= yMin1)
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMax2,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        goto XorIncYSpan2;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin2,
                            yMin1,
                            xSpan,
                            numXCoords,
                            &regionBuilder,
                            &combineCoords) == Ok)
                    {
                        yMin2 = yMin1;
                        continue;   // no increment
                    }
                }
                return GenericError;
            }
            // else if (yMin1 == yMin2)
            if (XSpansXOR (
                    &combineCoords,
                    xCoords1 + ySpan1[YSPAN_XOFFSET],
                    ySpan1[YSPAN_XCOUNT],
                    xCoords2 + ySpan2[YSPAN_XOFFSET],
                    ySpan2[YSPAN_XCOUNT]) == Ok)
            {
                if (yMax1 < yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin2 = yMax1;
                        goto XorIncYSpan1;
                    }
                }
                else if (yMax1 > yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax2,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin1 = yMax2;
                        goto XorIncYSpan2;
                    }
                }
                else // if (yMax1 == yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        goto XorIncYSpanBoth;
                    }
                }
            }
            return GenericError;

XorIncYSpanBoth:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                done = TRUE;
            }
            else
            {
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }

            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto XorCheckMoreY2Spans;
            }
            else
            {
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }

            if (done)
            {
                break;
            }
            continue;

XorIncYSpan2:
            if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
            {
                break;
            }
            yMin2 = ySpan2[YSPAN_YMIN];
            yMax2 = ySpan2[YSPAN_YMAX];
            continue;

XorIncYSpan1:
            if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
            {
                goto XorCheckMoreY2Spans;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }

        if (ySpan1 <= ySpan1Last)
        {
            for (;;)
            {
                xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
                numXCoords = ySpan1[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin1,
                        yMax1,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan1 += YSPAN_SIZE;
                if (ySpan1 > ySpan1Last)
                {
                    break;
                }
                yMin1 = ySpan1[YSPAN_YMIN];
                yMax1 = ySpan1[YSPAN_YMAX];
            }
        }

XorCheckMoreY2Spans:

        if (ySpan2 <= ySpan2Last)
        {
            for (;;)
            {
                xSpan      = xCoords2 + ySpan2[YSPAN_XOFFSET];
                numXCoords = ySpan2[YSPAN_XCOUNT];

                if (CompactAndOutput(
                        yMin2,
                        yMax2,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) != Ok)
                {
                    return GenericError;
                }

                ySpan2 += YSPAN_SIZE;
                if (ySpan2 > ySpan2Last)
                {
                    break;
                }
                yMin2 = ySpan2[YSPAN_YMIN];
                yMax2 = ySpan2[YSPAN_YMAX];
            }
        }
        return Set(regionBuilder);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the XOR operator.
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansXOR(
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT        xMin1 = xSpan1[0];
        INT        xMax1 = xSpan1[1];
        INT        xMin2 = xSpan2[0];
        INT        xMax2 = xSpan2[1];
        BOOL       done  = FALSE;

        for (;;)
        {
            if (xMin1 < xMin2)
            {
                XCoords[count++] = xMin1;       // left
                if (xMax1 <= xMin2)
                {
                    XCoords[count++] = xMax1;   // right
                    goto XorIncXSpan1;
                }
                XCoords[count++] = xMin2;       // right
                if (xMax1 < xMax2)
                {
                    xMin2 = xMax1;
                    goto XorIncXSpan1;
                }
                else if (xMax1 > xMax2)
                {
                    xMin1 = xMax2;
                    goto XorIncXSpan2;
                }
                // else if (xMax1 == xMax2)
                goto XorIncXSpanBoth;
            }
            else if (xMin1 > xMin2)
            {
                XCoords[count++] = xMin2;       // left
                if (xMax2 <= xMin1)
                {
                    XCoords[count++] = xMax2;   // right
                    goto XorIncXSpan2;
                }
                XCoords[count++] = xMin1;       // right
                if (xMax1 < xMax2)
                {
                    xMin2 = xMax1;
                    goto XorIncXSpan1;
                }
                else if (xMax1 > xMax2)
                {
                    xMin1 = xMax2;
                    goto XorIncXSpan2;
                }
                // else if (xMax1 == xMax2)
                goto XorIncXSpanBoth;
            }
            // else if (xMin1 == xMin2)
            if (xMax1 < xMax2)
            {
                xMin2 = xMax1;
                goto XorIncXSpan1;
            }
            else if (xMax1 > xMax2)
            {
                xMin1 = xMax2;
                goto XorIncXSpan2;
            }
            // else if (xMax1 == xMax2)
            // goto XorIncXSpanBoth;

XorIncXSpanBoth:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                done = TRUE;
            }
            else
            {
                xMin2 = xSpan2[0];
                xMax2 = xSpan2[1];
            }

            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto XorCheckMoreX2Spans;
            }
            else
            {
                xMin1 = xSpan1[0];
                xMax1 = xSpan1[1];
            }

            if (done)
            {
                break;
            }
            continue;

XorIncXSpan2:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xMin2    = xSpan2[0];
            xMax2    = xSpan2[1];
            continue;

XorIncXSpan1:
            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto XorCheckMoreX2Spans;
            }
            xMin1    = xSpan1[0];
            xMax1    = xSpan1[1];
        }

        if (numXCoords1 >= 2)
        {
            for (;;)
            {
                XCoords[count++] = xMin1;
                XCoords[count++] = xMax1;

                numXCoords1 -= 2;
                if (numXCoords1 < 2)
                {
                    break;
                }
                xSpan1 += 2;
                xMin1    = xSpan1[0];
                xMax1    = xSpan1[1];
            }
        }

XorCheckMoreX2Spans:

        if (numXCoords2 >= 2)
        {
            for (;;)
            {
                XCoords[count++] = xMin2;
                XCoords[count++] = xMax2;

                numXCoords2 -= 2;
                if (numXCoords2 < 2)
                {
                    break;
                }
                xSpan2 += 2;
                xMin2    = xSpan2[0];
                xMax2    = xSpan2[1];
            }
        }
        combineCoords->SetCount(count);
        return Ok;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the Complement operator.
*   i.e. this = region - this
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Complement(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (region->Empty || (region == this) || Infinite)
    {
        SetEmpty();
        return Ok;
    }
    if (Empty)
    {
        return Set(region);
    }
    // check if this totally encompasses the region
    if ((ComplexData == NULL) &&
        (XMin <= region->XMin) &&
        (YMin <= region->YMin) &&
        (XMax >= region->XMax) &&
        (YMax >= region->YMax))
    {
        SetEmpty();
        return Ok;
    }
    // check for no intersection
    if ((XMin >= region->XMax) ||
        (region->XMax <= XMin) ||
        (XMax <= region->XMin) ||
        (region->XMin >= XMax) ||
        (YMin >= region->YMax) ||
        (region->YMax <= YMin) ||
        (YMax <= region->YMin) ||
        (region->YMin >= YMax))
    {
        return Set(region);
    }
    return Diff(const_cast<DpRegion *>(region), this, FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Combine another region with this one using the Exclude operator.
*   i.e. this = this - region
*
* Arguments:
*
*   [IN] region - the region to combine with this one
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Exclude(
    const DpRegion *    region
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());

    if (Empty || region->Empty)
    {
        return Ok;
    }
    if ((region == this) || region->Infinite)
    {
        SetEmpty();
        return Ok;
    }
    // check if the region totally encompasses this
    if ((region->ComplexData == NULL) &&
        (region->XMin <= XMin) &&
        (region->YMin <= YMin) &&
        (region->XMax >= XMax) &&
        (region->YMax >= YMax))
    {
        SetEmpty();
        return Ok;
    }
    // check for no intersection
    if ((XMin >= region->XMax) ||
        (region->XMax <= XMin) ||
        (XMax <= region->XMin) ||
        (region->XMin >= XMax) ||
        (YMin >= region->YMax) ||
        (region->YMax <= YMin) ||
        (YMax <= region->YMin) ||
        (region->YMin >= YMax))
    {
        return Ok;
    }
    return Diff(this, const_cast<DpRegion *>(region), TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Subtract region2 from region1.  If set1, then region1 gets the result;
*   otherwise region2 gets the result.
*
* Arguments:
*
*   [IN] region1 - the 1st region
*   [IN] region2 - the 2nd region
*   [IN] set1    - if TRUE, region1 gets result, else region2 does
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::Diff(
    DpRegion *      region1,
    DpRegion *      region2,
    BOOL            set1
    )
{
    INT *           ySpan1;
    INT *           ySpan2;
    INT *           ySpan1Last;
    INT *           ySpan2Last;
    INT *           xCoords1;
    INT *           xCoords2;
    INT             ySpan1Tmp[YSPAN_SIZE];
    INT             ySpan2Tmp[YSPAN_SIZE];
    INT             xCoords1Tmp[2];
    INT             xCoords2Tmp[2];
    INT             yMin1 = region1->YMin;
    INT             yMax1;
    INT             yMin2 = region2->YMin;
    INT             yMax2;
    INT             numYSpans1;
    INT             numYSpans2;
    INT             combineTmp[4];
    DynIntArray     combineCoords(combineTmp, 4);

    if (region1->ComplexData == NULL)
    {
        numYSpans1            = 1;
        ySpan1                = ySpan1Tmp;
        ySpan1Last            = ySpan1Tmp;
        yMax1                 = region1->YMax;

        ySpan1[YSPAN_YMIN]    = yMin1;
        ySpan1[YSPAN_YMAX]    = yMax1;
        ySpan1[YSPAN_XOFFSET] = 0;
        ySpan1[YSPAN_XCOUNT]  = 2;

        xCoords1              = xCoords1Tmp;
        xCoords1[0]           = region1->XMin;
        xCoords1[1]           = region1->XMax;
    }
    else
    {
        numYSpans1 = region1->ComplexData->NumYSpans;
        ySpan1     = region1->ComplexData->YSpans;
        ySpan1Last = ySpan1 + ((numYSpans1 - 1) * YSPAN_SIZE);
        yMax1      = ySpan1[YSPAN_YMAX];
        xCoords1   = region1->ComplexData->XCoords;
    }
    if (region2->ComplexData == NULL)
    {
        numYSpans2            = 1;
        ySpan2                = ySpan2Tmp;
        ySpan2Last            = ySpan2Tmp;
        yMax2                 = region2->YMax;

        ySpan2[YSPAN_YMIN]    = yMin2;
        ySpan2[YSPAN_YMAX]    = yMax2;
        ySpan2[YSPAN_XOFFSET] = 0;
        ySpan2[YSPAN_XCOUNT]  = 2;

        xCoords2              = xCoords2Tmp;
        xCoords2[0]           = region2->XMin;
        xCoords2[1]           = region2->XMax;
    }
    else
    {
        numYSpans2 = region2->ComplexData->NumYSpans;
        ySpan2     = region2->ComplexData->YSpans;
        ySpan2Last = ySpan2 + ((numYSpans2 - 1) * YSPAN_SIZE);
        yMax2      = ySpan2[YSPAN_YMAX];
        xCoords2   = region2->ComplexData->XCoords;
    }

    DpRegionBuilder regionBuilder(numYSpans1 + (2 * numYSpans2));
    INT             numXCoords;
    INT *           xSpan;

    if (!regionBuilder.IsValid())
    {
        return OutOfMemory;
    }

    for (;;)
    {
        if (yMin1 < yMin2)
        {
            xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
            numXCoords = ySpan1[YSPAN_XCOUNT];

            if (yMax1 <= yMin2)
            {
                if (CompactAndOutput(
                        yMin1,
                        yMax1,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) == Ok)
                {
                    goto DiffIncYSpan1;
                }
            }
            else
            {
                if (CompactAndOutput(
                        yMin1,
                        yMin2,
                        xSpan,
                        numXCoords,
                        &regionBuilder,
                        &combineCoords) == Ok)
                {
                    yMin1 = yMin2;
                    continue;   // no increment
                }
            }
            return GenericError;
        }
        else if (yMin1 < yMax2)
        {
            if (XSpansDIFF(
                    &combineCoords,
                    xCoords1 + ySpan1[YSPAN_XOFFSET],
                    ySpan1[YSPAN_XCOUNT],
                    xCoords2 + ySpan2[YSPAN_XOFFSET],
                    ySpan2[YSPAN_XCOUNT]) == Ok)
            {
                if (yMax1 <= yMax2)
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax1,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        goto DiffIncYSpan1;
                    }
                }
                else
                {
                    if (CompactAndOutput(
                            yMin1,
                            yMax2,
                            combineCoords.GetDataBuffer(),
                            combineCoords.GetCount(),
                            &regionBuilder, NULL) == Ok)
                    {
                        yMin1 = yMax2;
                        goto DiffIncYSpan2;
                    }
                }
            }
            return GenericError;
        }
        // else goto DiffIncYSpan2;

DiffIncYSpan2:
        if ((ySpan2 += YSPAN_SIZE) > ySpan2Last)
        {
            break;
        }
        yMin2 = ySpan2[YSPAN_YMIN];
        yMax2 = ySpan2[YSPAN_YMAX];
        continue;

DiffIncYSpan1:
        if ((ySpan1 += YSPAN_SIZE) > ySpan1Last)
        {
            goto DiffDone;
        }
        yMin1 = ySpan1[YSPAN_YMIN];
        yMax1 = ySpan1[YSPAN_YMAX];
    }

    if (ySpan1 <= ySpan1Last)
    {
        for (;;)
        {
            xSpan      = xCoords1 + ySpan1[YSPAN_XOFFSET];
            numXCoords = ySpan1[YSPAN_XCOUNT];

            if (CompactAndOutput(
                    yMin1,
                    yMax1,
                    xSpan,
                    numXCoords,
                    &regionBuilder,
                    &combineCoords) != Ok)
            {
                return GenericError;
            }

            ySpan1 += YSPAN_SIZE;
            if (ySpan1 > ySpan1Last)
            {
                break;
            }
            yMin1 = ySpan1[YSPAN_YMIN];
            yMax1 = ySpan1[YSPAN_YMAX];
        }
    }
DiffDone:
    if (set1)
    {
        return region1->Set(regionBuilder);
    }
    return region2->Set(regionBuilder);
}

/**************************************************************************\
*
* Function Description:
*
*   Combine a set of X spans from each region with the DIFF operator.
*   i.e. xSpan1 - xSpan2
*
* Arguments:
*
*   [IN] combineCoords - where to put the combined coordinates
*   [IN] xSpan1        - x spans from this region
*   [IN] numXCoords1   - number of xSpan1 coordinates
*   [IN] xSpan2        - x spans from the other region
*   [IN] numXCoords2   - number of xSpan2 coordinates
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpRegion::XSpansDIFF(
    DynIntArray *   combineCoords,
    INT *           xSpan1,
    INT             numXCoords1,
    INT *           xSpan2,
    INT             numXCoords2)
{
    INT *           XCoords;
    INT             count = 0;

    combineCoords->Reset(FALSE);
    XCoords = combineCoords->AddMultiple(numXCoords1 + numXCoords2);

    if (XCoords != NULL)
    {
        INT     xMin1 = xSpan1[0];
        INT     xMax1 = xSpan1[1];
        INT     xMin2 = xSpan2[0];
        INT     xMax2 = xSpan2[1];

        for (;;)
        {
            if (xMin1 < xMin2)
            {
                XCoords[count++] = xMin1;       // left
                if (xMax1 <= xMin2)
                {
                    XCoords[count++] = xMax1;   // right
                    goto DiffIncXSpan1;
                }
                XCoords[count++] = xMin2;       // right
                xMin1 = xMin2;
                continue;   // no increment
            }
            else if (xMin1 < xMax2)
            {
                if (xMax1 <= xMax2)
                {
                    goto DiffIncXSpan1;
                }
                xMin1 = xMax2;
                // goto DiffIncXSpan2;
            }
            // else goto DiffIncXSpan2;

// DiffIncXSpan2:
            xSpan2 += 2;
            if ((numXCoords2 -= 2) < 2)
            {
                break;
            }
            xMin2 = xSpan2[0];
            xMax2 = xSpan2[1];
            continue;

DiffIncXSpan1:
            xSpan1 += 2;
            if ((numXCoords1 -= 2) < 2)
            {
                goto DiffDone;
            }
            xMin1 = xSpan1[0];
            xMax1 = xSpan1[1];
        }

        if (numXCoords1 >= 2)
        {
            for (;;)
            {
                XCoords[count++] = xMin1;
                XCoords[count++] = xMax1;

                numXCoords1 -= 2;
                if (numXCoords1 < 2)
                {
                    break;
                }
                xSpan1 += 2;
                xMin1    = xSpan1[0];
                xMax1    = xSpan1[1];
            }
        }
DiffDone:
        combineCoords->SetCount(count);
        return Ok;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the clipper by setting the output method and setting the
*   starting y span search index.
*
* Arguments:
*
*   [IN] outputClippedSpan - The output class for clipped spans
*   [IN] yMin              - The starting y value of the object to clip
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/
VOID
DpClipRegion::InitClipping(
    DpOutputSpan *  outputClippedSpan,
    INT             yMin
    )
{
    OutputClippedSpan = outputClippedSpan;

    // init search index if appropriate
    if (ComplexData != NULL)
    {
        INT *       ySpan;
        INT         ySpanIndex;

        ComplexData->ResetSearchIndex();
        ComplexData->YSpanSearch (yMin, &ySpan, &ySpanIndex);
        ComplexData->YSearchIndex = ySpanIndex;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   The method called from the rasterizer during the rasterization when a
*   horizontal span has been identified.  We clip it and if not clipped out,
*   we send the clipped data to the output method.
*
* Arguments:
*
*   [IN] y    - the Y value of the raster being output
*   [IN] xMin - the X value of the left edge
*   [IN] xMax - the X value of the right edge (exclusive)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpClipRegion::OutputSpan(
    INT             y,
    INT             xMin,
    INT             xMax    // xMax is exclusive
    )
{
    ASSERT(!Empty && !Infinite);
    ASSERT(OutputClippedSpan != NULL);
    INT  xMinCur = xMin;
    INT  xMaxCur = xMax;

    // do simple clip test to bounding rectangle
    if ((xMin <  XMax) && (xMax > XMin) &&
        (y    >= YMin) && (y    < YMax))
    {
        if (xMin < XMin)
        {
            xMinCur = XMin;
        }
        if (xMax > XMax)
        {
            xMaxCur = XMax;
        }
    }
    else
        return Ok;

    if (ComplexData == NULL)
    {
       return OutputClippedSpan->OutputSpan(y, xMinCur, xMaxCur);
    }
    else // not a simple region
    {
        // find the Y span that includes the line (if any)
        INT         ySpanIndex = ComplexData->YSearchIndex;
        INT *       ySpan      = ComplexData->GetYSpan (ySpanIndex);

        if (y >= ySpan[YSPAN_YMIN])
        {
            if (y >= ySpan[YSPAN_YMAX])
            {
                // do forward linear search from previous point
                for (;;)
                {
                    // see if we're past the end of the tessellation
                    if (++ySpanIndex >= ComplexData->NumYSpans)
                    {
                        ComplexData->YSearchIndex = ComplexData->NumYSpans - 1;
                        return Ok;      // nothing to draw
                    }
                    ySpan += YSPAN_SIZE;
                    if (y < ySpan[YSPAN_YMAX])
                    {
                        ComplexData->YSearchIndex = ySpanIndex;
                        if (y >= ySpan[YSPAN_YMIN])
                        {
                            break;
                        }
                        return Ok;      // nothing to draw
                    }
                }
            }
            // else yMin is inside this ySpan
        }
        else // need to search backward (shouldn't happen when rasterizing)
        {
            for (;;)
            {
                if (ySpanIndex == 0)
                {
                    ComplexData->YSearchIndex = 0;
                    return Ok;          // nothing to draw
                }
                ySpanIndex--;
                ySpan -= YSPAN_SIZE;

                if (y >= ySpan[YSPAN_YMIN])
                {
                    ComplexData->YSearchIndex = ySpanIndex;
                    if (y < ySpan[YSPAN_YMAX])
                    {
                        break;
                    }
                    return Ok;          // nothing to draw
                }
            }
        }

        // If we get here, we know there y is within a Y span and that
        // ySpan points to the correct Y span

        GpStatus        status = Ok;
        INT *           xSpan;
        INT             numXCoords;

        xSpan = ComplexData->XCoords + ySpan[YSPAN_XOFFSET];
        numXCoords = ySpan[YSPAN_XCOUNT];

        for (;;)
        {
            if (xMax <= xSpan[0])
            {
                break;
            }
            if (xMin < xSpan[1])
            {
                xMinCur = (xMin < xSpan[0]) ? xSpan[0] : xMin;
                xMaxCur = (xMax > xSpan[1]) ? xSpan[1] : xMax;
                status = OutputClippedSpan->OutputSpan(y, xMinCur, xMaxCur);
            }
            // continue on with loop through x spans

            if (((numXCoords -= 2) <= 0) || (status != Ok))
            {
                break;
            }
            xSpan += 2;
        }

        return status;
    }
}

INT
DpRegion::GetRects(
    GpRect *    rects
    ) const
{
    if (Empty)
    {
        return 0;
    }
    else if (Infinite)
    {
        if (rects != NULL)
        {
            rects->X      = INFINITE_MIN;
            rects->Y      = INFINITE_MIN;
            rects->Width  = INFINITE_SIZE;
            rects->Height = INFINITE_SIZE;
        }
        return 1;
    }
    else if (ComplexData == NULL)
    {
        if (rects != NULL)
        {
            rects->X      = XMin;
            rects->Y      = YMin;
            rects->Width  = XMax - XMin;
            rects->Height = YMax - YMin;
        }
        return 1;
    }
    else
    {
        if (rects != NULL)
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               xCoords     = complexData->XCoords;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                   ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT                 numXCoords;
            INT                 yMin;
            INT                 height;
            INT                 xMin;
            INT                 xMax;

            do
            {
                yMin       = ySpan[YSPAN_YMIN];
                height     = ySpan[YSPAN_YMAX] - yMin;
                numXCoords = ySpan[YSPAN_XCOUNT];
                do
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;

                    rects->X      = xMin;
                    rects->Y      = yMin;
                    rects->Width  = xMax - xMin;
                    rects->Height = height;

                    rects++;
                    numXCoords -= 2;
                 } while (numXCoords >= 2);

                ySpan += YSPAN_SIZE;
            } while (ySpan <= ySpanLast);
        }
        return ComplexData->XCoordsCount / 2;
    }
}

INT
DpRegion::GetRects(
    GpRectF *   rects
    ) const
{
    if (Empty)
    {
        return 0;
    }
    else if (Infinite)
    {
        if (rects != NULL)
        {
            rects->X      = (REAL)INFINITE_MIN;
            rects->Y      = (REAL)INFINITE_MIN;
            rects->Width  = (REAL)INFINITE_SIZE;
            rects->Height = (REAL)INFINITE_SIZE;
        }
        return 1;
    }
    else if (ComplexData == NULL)
    {
        if (rects != NULL)
        {
            rects->X      = (REAL)XMin;
            rects->Y      = (REAL)YMin;
            rects->Width  = (REAL)(XMax - XMin);
            rects->Height = (REAL)(YMax - YMin);
        }
        return 1;
    }
    else
    {
        if (rects != NULL)
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               xCoords     = complexData->XCoords;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                   ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT                 numXCoords;
            INT                 yMin;
            INT                 height;
            INT                 xMin;
            INT                 xMax;

            do
            {
                yMin       = ySpan[YSPAN_YMIN];
                height     = ySpan[YSPAN_YMAX] - yMin;
                numXCoords = ySpan[YSPAN_XCOUNT];
                do
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;

                    rects->X      = (REAL)xMin;
                    rects->Y      = (REAL)yMin;
                    rects->Width  = (REAL)(xMax - xMin);
                    rects->Height = (REAL)height;

                    rects++;
                    numXCoords -= 2;
                 } while (numXCoords >= 2);

                ySpan += YSPAN_SIZE;
            } while (ySpan <= ySpanLast);
        }
        return ComplexData->XCoordsCount / 2;
    }
}

// The WIN9x infinite max and min values are set up to be the greatest
// values that will interop with GDI HRGNs on Win9x successfully.
#define INFINITE_MIN_WIN9X  -16384
#define INFINITE_MAX_WIN9X  16383

INT
DpRegion::GetRects(
    RECT *      rects,
    BOOL        clampToWin9xSize
    ) const
{
    if (Empty)
    {
        return 0;
    }
    else if (Infinite)
    {
        if (rects != NULL)
        {
            if (!clampToWin9xSize)
            {
                rects->left   = INFINITE_MIN;
                rects->top    = INFINITE_MIN;
                rects->right  = INFINITE_MAX;
                rects->bottom = INFINITE_MAX;
            }
            else
            {
                rects->left   = INFINITE_MIN_WIN9X;
                rects->top    = INFINITE_MIN_WIN9X;
                rects->right  = INFINITE_MAX_WIN9X;
                rects->bottom = INFINITE_MAX_WIN9X;
            }
        }
        return 1;
    }
    else if (ComplexData == NULL)
    {
        if (rects != NULL)
        {
            rects->left   = XMin;
            rects->top    = YMin;
            rects->right  = XMax;
            rects->bottom = YMax;

            if (clampToWin9xSize)
            {
                if (rects->left < INFINITE_MIN_WIN9X)
                {
                    rects->left = INFINITE_MIN_WIN9X;
                }
                if (rects->top < INFINITE_MIN_WIN9X)
                {
                    rects->top = INFINITE_MIN_WIN9X;
                }
                if (rects->right > INFINITE_MAX_WIN9X)
                {
                    rects->right = INFINITE_MAX_WIN9X;
                }
                if (rects->bottom > INFINITE_MAX_WIN9X)
                {
                    rects->bottom = INFINITE_MAX_WIN9X;
                }
            }
        }
        return 1;

    }
    else
    {
        if (rects != NULL)
        {
            DpComplexRegion *   complexData = ComplexData;
            INT *               xCoords     = complexData->XCoords;
            INT *               ySpan       = complexData->YSpans;
            INT *               ySpanLast   = ySpan +
                                   ((complexData->NumYSpans - 1) * YSPAN_SIZE);
            INT                 numXCoords;
            INT                 yMin;
            INT                 height;
            INT                 xMin;
            INT                 xMax;

            do
            {
                yMin       = ySpan[YSPAN_YMIN];
                height     = ySpan[YSPAN_YMAX] - yMin;
                numXCoords = ySpan[YSPAN_XCOUNT];
                do
                {
                    xMin = *xCoords++;
                    xMax = *xCoords++;

                    rects->left   = xMin;
                    rects->top    = yMin;
                    rects->right  = xMax;
                    rects->bottom = yMin + height;

                    if (clampToWin9xSize)
                    {
                        // In this case, this could invalidate the region,
                        // but hopefully ExtCreateRegion will catch this.
                        if (rects->left < INFINITE_MIN_WIN9X)
                        {
                            rects->left = INFINITE_MIN_WIN9X;
                        }
                        if (rects->top < INFINITE_MIN_WIN9X)
                        {
                            rects->top = INFINITE_MIN_WIN9X;
                        }
                        if (rects->right > INFINITE_MAX_WIN9X)
                        {
                            rects->right = INFINITE_MAX_WIN9X;
                        }
                        if (rects->bottom > INFINITE_MAX_WIN9X)
                        {
                            rects->bottom = INFINITE_MAX_WIN9X;
                        }
                    }

                    rects++;
                    numXCoords -= 2;
                 } while (numXCoords >= 2);

                ySpan += YSPAN_SIZE;
            } while (ySpan <= ySpanLast);
        }
        return ComplexData->XCoordsCount / 2;
    }
}

// If error, returns INVALID_HANDLE_VALUE
HRGN
DpRegion::GetHRgn() const
{
    HRGN    hRgn = NULL;

    if (Infinite)
    {
        return NULL;
    }
    else if (Empty)
    {
        hRgn = CreateRectRgn(0, 0, 0, 0);
    }
    else if (ComplexData == NULL)
    {
        hRgn = CreateRectRgn(XMin, YMin, XMax, YMax);
    }
    else
    {
        INT     numRects = GetRects((RECT *)NULL);

        ASSERT(numRects > 1);

        // Allocate memory to hold RGNDATA structure

        INT         rgnDataSize = numRects * sizeof(RECT);
        RGNDATA *   rgnData = (RGNDATA*)GpMalloc(sizeof(RGNDATAHEADER) +
                                                 rgnDataSize);

        if (rgnData != NULL)
        {
            RECT*   rects = (RECT*)rgnData->Buffer;
            RECT    bounds;

            bounds.left   = XMin;
            bounds.top    = YMin;
            bounds.right  = XMax;
            bounds.bottom = YMax;

            rgnData->rdh.dwSize   = sizeof(RGNDATAHEADER);
            rgnData->rdh.iType    = RDH_RECTANGLES;
            rgnData->rdh.nCount   = numRects;
            rgnData->rdh.nRgnSize = rgnDataSize;
            rgnData->rdh.rcBound  = bounds;

            GetRects(rects, !Globals::IsNt);

            hRgn = ExtCreateRegion(NULL, sizeof(RGNDATAHEADER) + rgnDataSize,
                                   rgnData);
            GpFree(rgnData);
        }
    }
    if (hRgn != NULL)
    {
        return hRgn;
    }

    WARNING(("Couldn't create win32 HRGN"));
    return (HRGN)INVALID_HANDLE_VALUE;
}

VOID
DpClipRegion::StartEnumeration (
    INT         yMin,
    Direction   direction
    )
{
    INT *               ySpan;
    EnumDirection = direction;

    if (ComplexData != NULL)
    {
        DpComplexRegion *   complexData = ComplexData;
        INT                 ySpanIndex;

        complexData->ResetSearchIndex();
        complexData->YSpanSearch (yMin, &ySpan, &ySpanIndex);
        complexData->YSearchIndex = ySpanIndex;

        if(EnumDirection == TopLeftToBottomRight ||
           EnumDirection == BottomLeftToTopRight )
        {
            EnumSpan = 0;
        }
        else
        {
            EnumSpan = ySpan[YSPAN_XCOUNT] - 2;
        }

        if(EnumDirection == BottomLeftToTopRight ||
           EnumDirection == BottomRightToTopLeft)
        {
            //If the enumeration is from bottom to top,
            //and the suplied y is not inside a span, we
            //want to return the span with the next smaller
            //y, instead of the one with the next largest y.
            //Or better, the next span in the enumeration order.

            if(yMin < ySpan[YSPAN_YMIN])
            {
                //Get the previous span
                complexData->YSearchIndex--;

                if(complexData->YSearchIndex < 0)
                {
                    complexData->YSearchIndex = 0;
                    EnumDirection = NotEnumerating;
                }
            }

        }
        else
        {
            if(yMin > ySpan[YSPAN_YMAX])
            {
                // This situation can only happen if there
                // are no more spans.
                EnumDirection = NotEnumerating;
            }

        }
    }
}


BOOL
DpClipRegion::Enumerate (
    GpRect *    rects,
    INT &       numRects
    )
{
    INT numOut = 0;

    INT *ySpan = ComplexData->YSpans +
                    ComplexData->YSearchIndex*YSPAN_SIZE;

    if(EnumDirection == NotEnumerating)
    {
        numRects = 0;
        return FALSE;
    }

    while(numOut < numRects)
    {
        // Return the current rectangle

        INT *xCoords = ComplexData->XCoords + ySpan[YSPAN_XOFFSET] + EnumSpan;

        INT xMin = *xCoords++;
        INT xMax = *xCoords;

        rects->X      = xMin;
        rects->Y      = ySpan[YSPAN_YMIN];
        rects->Width  = xMax - xMin;
        rects->Height = ySpan[YSPAN_YMAX] - rects->Y;

        rects++;

        numOut++;

        // Update the indices

        switch(EnumDirection)
        {
        case TopLeftToBottomRight:
            EnumSpan += 2;
            if(EnumSpan == ySpan[YSPAN_XCOUNT])
            {
                if(ComplexData->YSearchIndex == ComplexData->NumYSpans - 1)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex++;
                ySpan += YSPAN_SIZE;
                EnumSpan = 0;
            }
            break;
        case BottomLeftToTopRight:
            EnumSpan += 2;
            if(EnumSpan == ySpan[YSPAN_XCOUNT])
            {
                if(ComplexData->YSearchIndex == 0)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex--;
                ySpan -= YSPAN_SIZE;
                EnumSpan = 0;
            }
            break;
        case TopRightToBottomLeft:
            EnumSpan -= 2;
            if(EnumSpan < 0)
            {
                if(ComplexData->YSearchIndex == ComplexData->NumYSpans - 1)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex++;
                ySpan += YSPAN_SIZE;
                EnumSpan = ySpan[YSPAN_XCOUNT] - 2;
            }
            break;
        case BottomRightToTopLeft:
            EnumSpan -= 2;
            if(EnumSpan < 0)
            {
                if(ComplexData->YSearchIndex == 0)
                {
                    goto enumeration_finished;
                }
                ComplexData->YSearchIndex--;
                ySpan -= YSPAN_SIZE;
                EnumSpan = ySpan[YSPAN_XCOUNT] - 2;
            }
            break;
        }
    }

    numRects = numOut;
    return TRUE;

enumeration_finished:

    EnumDirection = NotEnumerating;
    numRects = numOut;
    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   The method called to convert the region scans to an outline path.  The
*   path can be quite large and contains only points at righ angles with
*   each other.
*
* Arguments:
*
*   [IN,OUT] points - array of points to output
*   [IN,OUT] types - array of types for output
*
*   We do not return a path because we work on GpPoint's not GpPointF's.
*
*   NOTE: This alorithm was copied from GDI's RGNOBJ::bOutline by
*         J. Andrew Goossen.
*
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/12/1999 DCurtis
*
\**************************************************************************/

// Because the XCoords may be negative, the high bit is reserved.  Instead we
// use a bit in the Types byte array since we know the
// Types.Count >= XCoordsCount.  We also know that points generated by this
// code aren't in dash mode, so we reuse the dash mode bit for marking a
// visited wall.  We clear all bits on exit.

const UINT MarkWallBit = PathPointTypeDashMode; // 0x10, currently in dash mode.

#define XOFFSET(span,index) (INT)(XCoords[*(span + YSPAN_XOFFSET) + index])

#define XCOUNT(span) *(span + YSPAN_XCOUNT)

#define MARKXOFFSET(span,index) MarkWallPtr[*(span + YSPAN_XOFFSET) + index] \
                                    |= MarkWallBit

// This macro adds a type to the type array.  If the current count exceeds
// the capacity, then we grow the structure by 256 bytes.  Then we continue
// adding the new type to array.
#define ADDTYPE(pointtype) if ((UINT)types.GetCount() >= types.GetCapacity()) { \
                              if (types.ReserveSpace(512) == Ok) \
                              { \
                                  Types = (INT)(Types - MarkWallPtr) + types.GetDataBuffer(); \
                                  GpMemset(Types, 0, types.GetCapacity() - types.GetCount()); \
                                  MarkWallPtr = types.GetDataBuffer(); \
                              } else { \
                                  return FALSE; \
                              } \
                           } \
                           types.AdjustCount(1); \
                           *Types++ |= pointtype;

DpRegion::GetOutlinePoints(DynPointArray& points,
                           DynByteArray& types) const
{
    if (IsSimple())
    {
        GpRect rect;

        GpPoint newPoints[4];
        BYTE newTypes[4];

        GetBounds(&rect);

        newPoints[0] = GpPoint(rect.X, rect.Y);
        newPoints[1] = GpPoint(rect.X + rect.Width, rect.Y);
        newPoints[2] = GpPoint(rect.X + rect.Width, rect.Y + rect.Height);
        newPoints[3] = GpPoint(rect.X, rect.Y + rect.Height);

        newTypes[0] = PathPointTypeStart;
        newTypes[1] = PathPointTypeLine;
        newTypes[2] = PathPointTypeLine;
        newTypes[3] = PathPointTypeLine | PathPointTypeCloseSubpath;

        points.AddMultiple(&newPoints[0], 4);
        types.AddMultiple(&newTypes[0], 4);

        return TRUE;
    }

    // to avoid too many reallocations, we grow the array by the total number
    // or x,y pairs in the reigon.

    points.ReserveSpace(ComplexData->XCoordsCount+10);
    types.ReserveSpace(ComplexData->XCoordsCount+10);

    BYTE* MarkWallPtr = types.GetDataBuffer();
    BYTE* Types = types.GetDataBuffer();

    // Clear all bits in the Types array
    GpMemset(MarkWallPtr, 0, types.GetCapacity());

    // complicated case.

    GpPoint pt[2];
    INT     NumYScans;

    INT*    CurYScan;
    INT*    XCoords;
    INT*    LastYScan;
    INT*    FirstYScan;

    INT     XOffset;
    INT     XIndex;
    INT     XCount;

// Now compute the outline:

    CurYScan    = ComplexData->YSpans;
    NumYScans   = ComplexData->NumYSpans;
    XCoords     = ComplexData->XCoords;
    LastYScan   = CurYScan + NumYScans * YSPAN_SIZE;
    FirstYScan  = CurYScan;

    while (NumYScans--)
    {
        XCount = *(CurYScan + YSPAN_XCOUNT);
        XOffset = *(CurYScan + YSPAN_XOFFSET);

        for (XIndex = 0; XIndex < XCount; XIndex++)
        {
            // Only start at unvisited walls:

            if ((MarkWallPtr[XOffset + XIndex] & MarkWallBit) == 0)
            {

                INT*  YScan     = CurYScan;
                INT   IndexWall = XIndex;
                LONG  Turn;

                pt[0].X = XCoords[XOffset + XIndex];
                pt[0].Y = *(CurYScan + YSPAN_YMIN);

                points.Add(pt[0]);

                ADDTYPE(PathPointTypeStart);
#ifdef DEBUG_REGION
                DbgPrint("Point: (%d,%d)\n",pt[0].X, pt[0].Y);
#endif
                INT* YSearch = CurYScan + YSPAN_SIZE;
                BOOL Inside = (BOOL) (XIndex & 1);

            // Mark that we've visited this wall:

                MarkWallPtr[XOffset + IndexWall] |= MarkWallBit;

            // Loop until the path closes on itself:

            GoDown:
                // YSPAN_YMAX is exclusive, YSPAN_YMIN is inclusive so 
                // vertically adjacent spans have YSPAN_YMIN==YSPAN_YMAX
                Turn = +1;
                while (
                    (YSearch >= CurYScan) && 
                    (YSearch < LastYScan) &&
                    (YScan[YSPAN_YMAX] == YSearch[YSPAN_YMIN])
                      )
                {
                    INT Wall = XOFFSET(YScan, IndexWall);
                    INT IndexNewWall;
                    INT NewWall;

                    INT Left  = Inside;
                    INT Right = XCOUNT(YSearch) - 1 - Inside;

                // It would be nice if the first wall in the region structure
                // was minus infinity, but it isn't, so we do this check:

                    if (XOFFSET(YSearch, Left) > Wall)
                        IndexNewWall = Left;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // minimum x-value > xWall:

                        if (XOFFSET(YSearch, Right) <= Wall)
                            break;                  // =====>

                    // Do a binary search to find it:

                        while (TRUE)
                        {
                            INT IndexSearch = (Left + Right) >> 1;
                            if (IndexSearch == Left)
                                break;              // =====>

                            INT Search = XOFFSET(YSearch, IndexSearch);

                            if (Search > Wall)
                                Right = IndexSearch;
                            else
                                Left = IndexSearch;
                        }

                        IndexNewWall = Right;
                    }

                    if ((IndexNewWall & 1) != Inside)
                    {
                    // There is a region directly below xWall.  We can't
                    // move down if its left side is < the left
                    // side of our space:

                        if (IndexWall > 0 &&
                            XOFFSET(YSearch, IndexNewWall - 1) <
                            XOFFSET(YScan, IndexWall - 1))
                        {
                            Turn = -1;
                            break;                      // =====>
                        }

                        IndexNewWall--;
                    }
                    else
                    {
                    // There is a space directly below xWall.  We can't
                    // move down if its right side is more than the
                    // right side of our region:

                        if (XOFFSET(YSearch, IndexNewWall) >=
                            XOFFSET(YScan, IndexWall + 1))
                            break;                      // =====>
                    }

                    NewWall  = XOFFSET(YSearch, IndexNewWall);

                // Don't bother outputing multiple in-line straight lines:

                    if (Wall != NewWall                               ||
                        XOFFSET(YScan, IndexWall) != NewWall          ||
                        XOFFSET(YSearch, IndexNewWall) != NewWall)
                    {
                        pt[0].X = Wall;
                        pt[0].Y = *(YScan + YSPAN_YMAX);
                        pt[1].Y = *(YScan + YSPAN_YMAX);
                        pt[1].X = NewWall;

                        points.Add(pt[0]);
                        points.Add(pt[1]);

                        ADDTYPE(PathPointTypeLine);
                        ADDTYPE(PathPointTypeLine);

#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif
                    }

                    YScan      = YSearch;
                    IndexWall  = IndexNewWall;
                    YSearch    = YScan + YSPAN_SIZE;

                    MARKXOFFSET(YScan, IndexWall);
                }

            // Setup to go up other side:

                pt[0].X = XOFFSET(YScan, IndexWall);
                pt[0].Y = *(YScan + YSPAN_YMAX);
                pt[1].Y = *(YScan + YSPAN_YMAX);
                pt[1].X = XOFFSET(YScan, IndexWall + Turn);

                points.Add(pt[0]);
                points.Add(pt[1]);

                ADDTYPE(PathPointTypeLine);
                ADDTYPE(PathPointTypeLine);
#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif

                YSearch = YScan - YSPAN_SIZE;
                IndexWall += Turn;
                MARKXOFFSET(YScan, IndexWall);

            // Go up:

                // YSPAN_YMAX is exclusive, YSPAN_YMIN is inclusive so 
                // vertically adjacent spans have YSPAN_YMIN==YSPAN_YMAX
                Turn = -1;
                while (
                    (YSearch >= CurYScan) && 
                    (YSearch < LastYScan) &&
                    (YScan[YSPAN_YMIN] == YSearch[YSPAN_YMAX])
                      )
                {
                    INT  Wall = XOFFSET(YScan, IndexWall);
                    INT  IndexNewWall;
                    INT  NewWall;

                    INT Left  = Inside;
                    INT Right = XCOUNT(YSearch) - 1 - Inside;

                // It would be nice if the last wall in the region structure
                // was plus infinity, but it isn't, so we do this check:

                    if (XOFFSET(YSearch, Right) < Wall)
                        IndexNewWall = Right;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // maximum x-value < xWall:

                        if (XOFFSET(YSearch, Left) >= Wall)
                            break;                  // =====>

                    // Binary search to find it:

                        while (TRUE)
                        {
                            INT IndexSearch = (Left + Right) >> 1;
                            if (IndexSearch == Left)
                                break;              // =====>

                            INT Search = XOFFSET(YSearch, IndexSearch);

                            if (Search >= Wall)
                                Right = IndexSearch;
                            else
                                Left = IndexSearch;
                        }

                        IndexNewWall = Left;
                    }

                    if ((IndexNewWall & 1) == Inside)
                    {
                    // There is a region directly above xWall.  We can't
                    // move up if its right side is more than the right
                    // side of our space:

                        if ((IndexWall < (XCOUNT(YScan) - 1)) &&
                            (XOFFSET(YSearch, IndexNewWall + 1) >
                             XOFFSET(YScan, IndexWall + 1)) )
                        {
                            Turn = +1;
                            break;                          // =====>
                        }

                        IndexNewWall++;
                    }
                    else
                    {
                    // There is a space directly above xWall.  We can't
                    // move up if its left side is <= the left side
                    // of our region:

                        if (XOFFSET(YSearch, IndexNewWall) <=
                            XOFFSET(YScan, IndexWall - 1))
                            break;                          // =====>
                    }

                    NewWall = XOFFSET(YSearch, IndexNewWall);

                // Don't bother outputing multiple in-line straight lines:

                    if (Wall != NewWall                                 ||
                        XOFFSET(YScan, IndexWall) != NewWall            ||
                        XOFFSET(YSearch, IndexNewWall) != NewWall)
                    {
                       pt[0].X = Wall;
                       pt[0].Y = *(YScan + YSPAN_YMIN);
                       pt[1].Y = *(YScan + YSPAN_YMIN);
                       pt[1].X = NewWall;

                       points.Add(pt[0]);
                       points.Add(pt[1]);

                       ADDTYPE(PathPointTypeLine);
                       ADDTYPE(PathPointTypeLine);
#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif
                    }

                    YScan      = YSearch;
                    IndexWall  = IndexNewWall;
                    YSearch    = YScan - YSPAN_SIZE;

                    MARKXOFFSET(YScan, IndexWall);
                }

            // Check if we've returned to where we started from:

                if ((CurYScan != YScan) || (XIndex != IndexWall - 1))
                {
                // Setup to go down other side:

                    pt[0].X = XOFFSET(YScan, IndexWall);
                    pt[0].Y = *(YScan + YSPAN_YMIN);
                    pt[1].Y = *(YScan + YSPAN_YMIN);
                    pt[1].X = XOFFSET(YScan, IndexWall + Turn);

                    points.Add(pt[0]);
                    points.Add(pt[1]);

                    ADDTYPE(PathPointTypeLine);
                    ADDTYPE(PathPointTypeLine);
#ifdef DEBUG_REGION
                DbgPrint("Points: (%d,%d), (%d,%d)\n",
                         pt[0].X, pt[0].Y, pt[1].X, pt[1].Y);
#endif
                    YSearch = YScan + YSPAN_SIZE;

                    IndexWall += Turn;
                    MARKXOFFSET(YScan, IndexWall);

                    goto GoDown;                    // =====>
                }

            // We're all done with this outline!

                pt[0].X = XOFFSET(YScan, IndexWall);
                pt[0].Y = *(YScan + YSPAN_YMIN);

                points.Add(pt[0]);

                ADDTYPE(PathPointTypeLine | PathPointTypeCloseSubpath);
#ifdef DEBUG_REGION
                DbgPrint("Point: (%d,%d)\n", pt[0].X, pt[0].Y);
#endif

            }
        }

        CurYScan  = CurYScan + YSPAN_SIZE;
    }

    // we must untrash the region by removing our MarkWallBits

    BYTE* TypesPtr = types.GetDataBuffer();
    INT  XCnt = ComplexData->XCoordsCount;

    while (XCnt--)
    {
        *TypesPtr++ &= ~MarkWallBit;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\pathiterator.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   PathIterator.cpp
*
* Abstract:
*
*   Implementation of the DpPathTypeIterator and DpPathIterator classes
*
* Revision History:
*
*   11/13/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

VOID
DpPathTypeIterator::SetTypes(const BYTE* types, INT count)
{
    if(types && count > 0)
    {
        Types = types;
        Count = count;

        // Set Valid flag to TRUE so that CheckValid()
        // can call NextSubpath() and NextPathType().

        SetValid(TRUE);
        SetValid(CheckValid());
    }
    else
        Initialize();
}

// !!! bhouse CheckValid should not be required
//
// When we create an iterator, we should be able to provide
// data that is consistent and that does not need to be
// checked.
// Also, CheckValid actually has side effects like determining
// whether the path has beziers and calculating sub-path count.
// These should be provided at iterator creation time or taken
// out of the source path for which the iterator is created.
// The reasoning is that this data should persist beyond the
// lifespan of the iterator so that we do not have to keep
// re-calculating information that can be calculated once and
// stored with the path.


BOOL
DpPathTypeIterator::CheckValid()
{
    if(Count < 0)
        return FALSE;
    else if(Count == 0) // Allow an empty path.
        return TRUE;
    else
    {
        // If Count > 0 and Types = NULL, the path is not valid.

        if(Types == NULL)
        return FALSE;
    }

    INT startIndex, endIndex;
    BOOL isClosed;
    BOOL isValid = TRUE;

    Rewind();

    INT subpathCount = 0;

    HasBezier = FALSE;
    ExtendedPath = FALSE;

    while(
        NextSubpath(&startIndex, &endIndex, &isClosed)
        && isValid
        )
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType = PathPointTypeStart;

        if(endIndex == startIndex && Count > 1)
        {
            // This is a case when the next subpath has only one point.

            isValid = FALSE;
        }

        while(
            NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && isValid
            )
        {
            INT count = typeEndIndex - typeStartIndex + 1;
            INT order = (INT) pathType;

            switch(pathType)
            {
            case PathPointTypeStart:
                // This happens when there is only one point
                // in a path.

                if(count == 1)
                    isValid;
                else
                {
                    ASSERT(("Invalid path type."));
                    isValid = FALSE;
                }
                break;

            // The number of the Bezier points must be in the form of
            // n*order + 1.

            case PathPointTypeBezier3:
                if(count % order != 1)
                    isValid = FALSE;
                if(!HasBezier)
                    HasBezier = TRUE;
                if(order != 3 && !ExtendedPath)
                    ExtendedPath = TRUE;
                break;           
            
            case PathPointTypeLine:
                break;

            default:            
                // Undefined path type.

                WARNING(("Undefined path type."));
                isValid = FALSE;
                break;
            }
        }

        subpathCount++;
    }

    Rewind();

    SubpathCount = subpathCount;

    return isValid;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the index range of the next subpah.
*
* Arguments:
*
*   [OUT] startIndex - the starting index of the next subpath.
*   [OUT] endIndex   - the ending index of the next subpath.
*   [OUT] isClosed   - TRUE is the next subpath is closed.
*
* Return Value:
*
*   Retuns the sumber of points in the next subpath.
*   Returns 0 if there is no more subpath.
*
* History:
*
*   11/01/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
DpPathTypeIterator::NextSubpath(
    INT* startIndex,
    INT* endIndex,
    BOOL *isClosed
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT count = Count;

    if(SubpathEndIndex >= count - 1)
        return 0;

    INT i;

    // Set the starting index of the current subpath.

    if(SubpathEndIndex <= 0)
    {
        SubpathStartIndex = 0;
        i = 1;
    }
    else
    {
        SubpathStartIndex = SubpathEndIndex + 1;
        SubpathEndIndex = SubpathStartIndex;
        i = SubpathStartIndex + 1;
    }

    BOOL hasData = FALSE;
    INT segmentCount = 0;

    const BYTE* types = Types + i;

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (*types & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            segmentCount++;
            if(hasData)
            {
                break;
            }
            else
            {
                // Skip the consequtive move segments in the beginning of a subpath.

                SubpathStartIndex = i;
                SubpathEndIndex = SubpathStartIndex;
                i++;
                types++;
            }
        }
        if(segmentCount > 0 && hasData)
        {
            SubpathEndIndex = i - 1;
            break;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;

        while(i < count && (*types & PathPointTypePathTypeMask) != PathPointTypeStart)
        {
            i++;
            types++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            hasData = TRUE;
        }
    }

    *startIndex = SubpathStartIndex;
    if(i >= count)
        SubpathEndIndex = count - 1;    // The last subpath.
    *endIndex = SubpathEndIndex;
    segmentCount = SubpathEndIndex - SubpathStartIndex + 1;

    if(segmentCount > 1)
    {
        // If there is the close flag this subpath is closed.

        if((Types[SubpathEndIndex] & PathPointTypeCloseSubpath))
        {
            *isClosed = TRUE;
        }
        else
            *isClosed = FALSE;
    }
    else
        *isClosed = FALSE;
    
    // Set the start and end index of type to be the starting index of
    // the current subpath.  NextPathType() will start from the
    // beginning of the current subpath.

    TypeStartIndex = SubpathStartIndex;
    TypeEndIndex = -1;  // Indicate that this is the first type
                        // in the current subpath.
    
    // Set the current index to the start index of the subpath.

    Index = SubpathStartIndex;

    return segmentCount;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the path type, and the index range of the next segment.
*   This must be used after NextSubpath() is called.  This returns only
*   the next segment within the current subpath.
*
* Arguments:
*
*   [OUT] pathType   - the type of the next segment ignoring the closed
*                       and other flags.
*   [OUT] startIndex - the starting index of the next subpath.
*   [OUT] endIndex   - the ending index of the next subpath.
*
* Return Value:
*
*   Retuns the sumber of points in the next segment.
*   Returns 0 if there is no more segment in the current subpath.
*
* History:
*
*   11/01/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
DpPathTypeIterator::NextPathType(
    BYTE* pathType,
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    if(TypeEndIndex >= SubpathEndIndex)
        return 0;   // There is no more segment in the current subpath.

    INT count = SubpathEndIndex + 1;    // Limit for the ending index.

    if(TypeEndIndex <= 0)
        TypeEndIndex = SubpathStartIndex;   // This is the first type.

    TypeStartIndex = TypeEndIndex;
    INT i = TypeStartIndex;
    INT segmentCount = 0;

    i++;    // Go to the next point.

    const BYTE* types = Types + i;

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (*types & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            // Move the start and end index.

            TypeStartIndex = i;
            TypeEndIndex = TypeStartIndex;
            i++;
            types++;
            segmentCount++;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;
        BYTE nextType = *types & PathPointTypePathTypeMask;
        while(i < count && (*types & PathPointTypePathTypeMask) == nextType)
        {
            i++;
            types++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            TypeEndIndex = TypeStartIndex + segmentCount;
            *pathType = nextType;
            break;
        }
    }

    *startIndex = TypeStartIndex;
    *endIndex = TypeEndIndex;
    segmentCount = TypeEndIndex - TypeStartIndex + 1;

    return segmentCount;   
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the index range of the next subpah.
*
* Arguments:
*
*   [OUT] startIndex - the starting index of the next subpath.
*   [OUT] endIndex   - the ending index of the next subpath.
*   [OUT] isClosed   - TRUE is the next subpath is closed.
*
* Return Value:
*
*   Retuns the sumber of points in the next subpath.
*   Returns 0 if there is no more subpath.
*
* History:
*
*   11/01/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
DpPathTypeIterator::NextMarker(
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT count = Count;

    if(MarkerEndIndex >= count - 1)
        return 0;

    INT i;

    // Set the starting index of the current subpath.

    if(MarkerEndIndex <= 0)
    {
        MarkerStartIndex = 0;
        i = 1;
    }
    else
    {
        MarkerStartIndex = MarkerEndIndex + 1;
        MarkerEndIndex = MarkerStartIndex;
        i = MarkerStartIndex + 1;
    }

    const BYTE* types = Types + i;
    BOOL hasData = FALSE;

    while(i < count && (*types & PathPointTypePathMarker) == 0)
    {
        i++;
        types++;
    }

    if(i < count)
        MarkerEndIndex = i;
    else
        MarkerEndIndex = count - 1;

    *startIndex = MarkerStartIndex;
    *endIndex = MarkerEndIndex;
    INT segmentCount = MarkerEndIndex - MarkerStartIndex + 1;
    
    // Set the start and end index of type to be the starting index of
    // the current marker.  NextSubpath() and NextPathType() will
    // start from the beginning of the current current marked path.

    SubpathStartIndex = SubpathEndIndex = MarkerStartIndex;
    TypeStartIndex = TypeEndIndex = MarkerStartIndex;
    
    // Set the current index to the start index of the subpath.

    Index = MarkerStartIndex;

    return segmentCount;
}


/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if the control type in the given index is in dash mode.
*   Otherwise this returns FALSE.  If the given index is outside of
*   the range this returns FALSE.  A user must know the range of the
*   index beforehand to find the correct information.
*
\**************************************************************************/
BOOL DpPathTypeIterator::IsDashMode(INT index)
{
    if(!IsValid() || Count == 0 || index < 0 || index >= Count)
        return FALSE;

    return (Types[index] & PathPointTypeDashMode);
}

DpPathIterator::DpPathIterator(
    const DpPath* path
    )
{
    Initialize();

    if(path)
    {
        const BYTE* types = path->GetPathTypes();
        const GpPointF* points = path->GetPathPoints();
        INT count = path->GetPointCount();
        SetData(points, types, count);
    }
}

VOID
DpPathIterator::SetData(
    const GpPointF* points,
    const BYTE* types,
    INT count
    )
{
    if(points && types && count > 0)
    {
        Points = points;
        Types = types;
        Count = count;

        // Set Valid flag to TRUE so that CheckValid()
        // can call NextSubpath() and NextPathType().

        SetValid(TRUE);
        SetValid(CheckValid());
    }
    else
        Initialize();
}

VOID
DpPathIterator::SetData(
    const DpPath* path
    )
{
    if(path)
    {
        const BYTE* types = path->GetPathTypes();
        const GpPointF* points = path->GetPathPoints();
        INT count = path->GetPointCount();
        SetData(points, types, count);
    }
    else
        Initialize();
}

INT
DpPathIterator::NextSubpath(
    INT* startIndex,
    INT* endIndex,
    BOOL *isClosed
    )
{
    if(!IsValid() || Count == 0)
    {
        return 0;
    }

    BOOL closed = TRUE;
    INT start = 0, end = 0;
    INT count = DpPathTypeIterator::NextSubpath(&start, &end, &closed);

    *startIndex = start;
    *endIndex = end;
    *isClosed = closed;

    return count;
}

INT
DpPathIterator::NextSubpath(
    DpPath* path,
    BOOL *isClosed
    )
{
    if(!IsValid() || Count == 0 || !path)
    {
        return 0;
    }

    BOOL closed = TRUE;
    INT start = 0, end = 0;
    INT count = DpPathTypeIterator::NextSubpath(&start, &end, &closed);

    GpPathData pathData;
    pathData.Count = count;
    pathData.Points = (GpPointF*) &Points[start];
    pathData.Types = (BYTE*) &Types[start];

    path->SetPathData(&pathData);

    *isClosed = closed;

    return count;
}

INT
DpPathIterator::NextMarker(
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT count = DpPathTypeIterator::NextMarker(startIndex, endIndex);

    return count;
}

INT
DpPathIterator::NextMarker(
    DpPath* path
    )
{
    if(!IsValid() || Count == 0 || !path)
        return 0;

    BOOL closed;
    INT start = 0, end = 0;
    INT count = DpPathTypeIterator::NextMarker(&start, &end);

    GpPathData pathData;
    pathData.Count = count;
    pathData.Points = (GpPointF*) &Points[start];
    pathData.Types = (BYTE*) &Types[start];

    path->SetPathData(&pathData);

    return count;
}

/**************************************************************************\
*
* Function Description:
*
* This retrieves the next points and types up to the number count.
* This does not copy the unnecessary (consequetive) move points.
* This fills up the data until the count number is reached.  This fills
* data beyond the current subpath.
*
* Arguments:
*
* [OUT] points - point array to copy the retrieved point data.
* [OUT] types - type array to copy the retrieved type data.
* [IN] count - the number of points to be copied (request).
*
* Retrun Value:
*   Returns the total number of the retrieved points.
*
\**************************************************************************/

INT
DpPathIterator::Enumerate(
    GpPointF* points,
    BYTE* types,
    INT count
    )
{
    if(!IsValid() || Count == 0)
        return 0;

    INT totalNumber = 0;
    INT number = EnumerateWithinSubpath(points, types, count);

    while(number > 0)
    {
        totalNumber += number;
        count -= number;

        if(count > 0)
        {
            points += number;
            types += number;
            number = EnumerateWithinSubpath(points, types, count);
        }
        else
            number = 0;
    }

    return totalNumber;
}


/**************************************************************************\
*
* Function Description:
*
* This retrieves the next points and types up to the number count.
* This does not copy the unnecessary (consequetive) move points.
* This fills up the data until the count number is reached or the
* end of the current subopath is reached.
*
* Arguments:
*
* [OUT] points - point array to copy the retrieved point data.
* [OUT] types - type array to copy the retrieved type data.
* [IN] count - the number of points to be copied (request).
*
* Retrun Value:
*   Returns the total number of the retrieved points.
*
\**************************************************************************/

INT
DpPathIterator::EnumerateWithinSubpath(
    GpPointF* points,
    BYTE* types,
    INT count
    )
{
    if(!IsValid() || Count == 0 || count <= 0 || !points || !types)
        return 0;

    INT startIndex, endIndex;
    BOOL isClosed;
    INT segmentCount;

    if(Index == 0)
        segmentCount = NextSubpath(&startIndex, &endIndex, &isClosed);

    if(Index > SubpathEndIndex)
        segmentCount = NextSubpath(&startIndex, &endIndex, &isClosed);
    else
        segmentCount = SubpathEndIndex - SubpathStartIndex + 1;

    if(segmentCount == 0)
        return 0;   // No more segment.

    count = min(count, SubpathEndIndex - Index + 1);
    
    if(count > 0)
    {
        GpMemcpy(points, Points + Index, count*sizeof(GpPointF));
        GpMemcpy(types, Types + Index, count);
        Index += count;
    }

    return count;
}


/**************************************************************************\
*
* Function Description:
*
* This copies the data stored in Points and Types arrays
* in the index range between startIndex and endIndex.
* This may copy unnecessary (consequetive) move points.
* startIndex and endIndex must be within the index range of
* the original data.  Otherwise, this does not copy the data
* and returns 0.
*
* Arguments:
*
* [OUT] points - point array to copy the retrieved point data.
* [OUT] types - type array to copy the retrieved type data.
* [IN] startIndex - start index of the origianl data
* [IN] endIndex - end index of the origianl data.
*
* Retrun Value:
*   Returns the total number of the copied points.
*
\**************************************************************************/

INT
DpPathIterator::CopyData(
    GpPointF* points,
    BYTE* types,
    INT startIndex,
    INT endIndex
    )
{
    if(!IsValid() || Count == 0 || startIndex < 0 || endIndex >= Count
        || startIndex > endIndex || !points || !types)
        return 0;

    INT count = endIndex - startIndex + 1;

    ASSERT(count > 0);

    GpMemcpy(points, Points + startIndex, count*sizeof(GpPointF));
    GpMemcpy(types, Types + startIndex, count);
    Index += count;

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\aatext.cpp ===
#include "precomp.hpp"

namespace Globals
{

const BYTE TextContrastTableIdentity[256] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 
0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 
0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 
0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 
0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 
0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 
0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

TEXT_CONTRAST_TABLES TextContrastTablesDir =
{
{ // 1.1
0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 
0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 
0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x10, 0x11, 0x12, 
0x13, 0x14, 0x15, 0x16, 0x16, 0x17, 0x18, 0x19, 
0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
0x29, 0x2A, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 
0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 
0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x95, 0x96, 0x97, 0x98, 
0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 
0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA9, 
0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xBA, 
0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 
0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE3, 0xE4, 0xE5, 
0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 
0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 
0xF7, 0xF8, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
},

{ // 1.2
 0x00,   0x00,   0x01,   0x01,   0x02,   0x02,   0x03,   0x03,
 0x04,   0x05,   0x05,   0x06,   0x07,   0x07,   0x08,   0x09,
 0x09,   0x0A,   0x0B,   0x0B,   0x0C,   0x0D,   0x0D,   0x0E,
 0x0F,   0x10,   0x10,   0x11,   0x12,   0x13,   0x14,   0x14,
 0x15,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,   0x1B,
 0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x20,   0x21,   0x22,
 0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x28,
 0x29,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,
 0x31,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3E,
 0x3F,   0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,
 0x47,   0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,
 0x4F,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,
 0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,
 0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,   0x88,
 0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
 0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,
 0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,
 0xAC,   0xAD,   0xAF,   0xB0,   0xB1,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBD,
 0xBF,   0xC0,   0xC1,   0xC2,   0xC3,   0xC4,   0xC5,   0xC7,
 0xC8,   0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCF,   0xD0,
 0xD1,   0xD2,   0xD3,   0xD4,   0xD6,   0xD7,   0xD8,   0xD9,
 0xDA,   0xDB,   0xDD,   0xDE,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE4,   0xE5,   0xE6,   0xE7,   0xE8,   0xEA,   0xEB,   0xEC,
 0xED,   0xEE,   0xEF,   0xF1,   0xF2,   0xF3,   0xF4,   0xF5,
 0xF7,   0xF8,   0xF9,   0xFA,   0xFB,   0xFD,   0xFE,   0xFF
},

{ // 1.3
0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0B, 0x0B, 
0x0C, 0x0C, 0x0D, 0x0E, 0x0E, 0x0F, 0x10, 0x10, 
0x11, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1C, 
0x1D, 0x1E, 0x1F, 0x1F, 0x20, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x29, 
0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x2F, 0x30, 
0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 
0x39, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 
0x82, 0x83, 0x84, 0x85, 0x87, 0x88, 0x89, 0x8A, 
0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x91, 0x92, 0x93, 
0x94, 0x95, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA6, 
0xA7, 0xA8, 0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB8, 0xB9, 
0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 0xCC, 
0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD4, 0xD5, 0xD6, 
0xD7, 0xD9, 0xDA, 0xDB, 0xDC, 0xDE, 0xDF, 0xE0, 
0xE2, 0xE3, 0xE4, 0xE5, 0xE7, 0xE8, 0xE9, 0xEA, 
0xEC, 0xED, 0xEE, 0xF0, 0xF1, 0xF2, 0xF3, 0xF5, 
0xF6, 0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFE, 0xFF
},

 { // 1.4
 0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x04,   0x04,   0x04,   0x05,
 0x05,   0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0C,   0x0C,   0x0D,   0x0D,
 0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,   0x12,   0x12,
 0x13,   0x14,   0x14,   0x15,   0x16,   0x16,   0x17,   0x18,
 0x19,   0x19,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1F,   0x1F,   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,
 0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,   0x2B,
 0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,   0x31,   0x31,
 0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,
 0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x67,   0x68,   0x69,
 0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,   0x71,
 0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,
 0x7C,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x84,
 0x85,   0x86,   0x87,   0x88,   0x89,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x94,   0x95,   0x97,
 0x98,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA0,
 0xA1,   0xA3,   0xA4,   0xA5,   0xA6,   0xA8,   0xA9,   0xAA,
 0xAB,   0xAD,   0xAE,   0xAF,   0xB0,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBB,   0xBC,   0xBD,   0xBE,
 0xC0,   0xC1,   0xC2,   0xC4,   0xC5,   0xC6,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCD,   0xCE,   0xCF,   0xD1,   0xD2,   0xD3,
 0xD5,   0xD6,   0xD7,   0xD9,   0xDA,   0xDB,   0xDD,   0xDE,
 0xDF,   0xE1,   0xE2,   0xE3,   0xE5,   0xE6,   0xE8,   0xE9,
 0xEA,   0xEC,   0xED,   0xEE,   0xF0,   0xF1,   0xF2,   0xF4,
 0xF5,   0xF7,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
},

{ // 1.5
   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
   0x01,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x04,
   0x04,   0x04,   0x05,   0x05,   0x06,   0x06,   0x06,   0x07,
   0x07,   0x08,   0x08,   0x09,   0x09,   0x0A,   0x0A,   0x0B,
   0x0B,   0x0C,   0x0C,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,
   0x10,   0x10,   0x11,   0x12,   0x12,   0x13,   0x14,   0x14,
   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x19,   0x1A,
   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x1F,
   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,   0x25,   0x25,
   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,   0x2C,
   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,
   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,
   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,   0x41,
   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
   0x52,   0x53,   0x54,   0x55,   0x56,   0x58,   0x59,   0x5A,
   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,
   0x63,   0x64,   0x66,   0x67,   0x68,   0x69,   0x6A,   0x6B,
   0x6C,   0x6D,   0x6E,   0x70,   0x71,   0x72,   0x73,   0x74,
   0x75,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7E,
   0x7F,   0x80,   0x81,   0x82,   0x84,   0x85,   0x86,   0x87,
   0x88,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
   0x92,   0x93,   0x95,   0x96,   0x97,   0x98,   0x9A,   0x9B,
   0x9C,   0x9E,   0x9F,   0xA0,   0xA1,   0xA3,   0xA4,   0xA5,
   0xA7,   0xA8,   0xA9,   0xAB,   0xAC,   0xAD,   0xAE,   0xB0,
   0xB1,   0xB2,   0xB4,   0xB5,   0xB6,   0xB8,   0xB9,   0xBB,
   0xBC,   0xBD,   0xBF,   0xC0,   0xC1,   0xC3,   0xC4,   0xC5,
   0xC7,   0xC8,   0xCA,   0xCB,   0xCC,   0xCE,   0xCF,   0xD1,
   0xD2,   0xD3,   0xD5,   0xD6,   0xD8,   0xD9,   0xDA,   0xDC,
   0xDD,   0xDF,   0xE0,   0xE2,   0xE3,   0xE4,   0xE6,   0xE7,
   0xE9,   0xEA,   0xEC,   0xED,   0xEF,   0xF0,   0xF2,   0xF3,
   0xF5,   0xF6,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
},

{ // 1.6
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,   0x03,
 0x03,   0x03,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,
 0x06,   0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,   0x0D,
 0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,
 0x12,   0x12,   0x13,   0x13,   0x14,   0x15,   0x15,   0x16,
 0x17,   0x17,   0x18,   0x19,   0x19,   0x1A,   0x1B,   0x1B,
 0x1C,   0x1D,   0x1D,   0x1E,   0x1F,   0x1F,   0x20,   0x21,
 0x22,   0x22,   0x23,   0x24,   0x25,   0x26,   0x26,   0x27,
 0x28,   0x29,   0x2A,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,
 0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,   0x3B,   0x3C,
 0x3D,   0x3E,   0x3F,   0x40,   0x40,   0x41,   0x42,   0x43,
 0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4A,   0x4B,
 0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,   0x54,
 0x55,   0x56,   0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,
 0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,   0x64,   0x65,
 0x66,   0x67,   0x68,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x71,   0x72,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7D,   0x7E,   0x7F,   0x80,   0x82,
 0x83,   0x84,   0x85,   0x87,   0x88,   0x89,   0x8A,   0x8C,
 0x8D,   0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,
 0x97,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA1,
 0xA2,   0xA3,   0xA5,   0xA6,   0xA7,   0xA9,   0xAA,   0xAB,
 0xAD,   0xAE,   0xB0,   0xB1,   0xB2,   0xB4,   0xB5,   0xB7,
 0xB8,   0xB9,   0xBB,   0xBC,   0xBE,   0xBF,   0xC1,   0xC2,
 0xC4,   0xC5,   0xC6,   0xC8,   0xC9,   0xCB,   0xCC,   0xCE,
 0xCF,   0xD1,   0xD2,   0xD4,   0xD5,   0xD7,   0xD8,   0xDA,
 0xDB,   0xDD,   0xDE,   0xE0,   0xE1,   0xE3,   0xE4,   0xE6,
 0xE7,   0xE9,   0xEB,   0xEC,   0xEE,   0xEF,   0xF1,   0xF2,
 0xF4,   0xF5,   0xF7,   0xF9,   0xFA,   0xFC,   0xFD,   0xFF
},

{ // 1.7
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 0x0E, 
0x0F, 0x0F, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 
0x13, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 
0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x69, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6F, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x78, 0x7A, 0x7B, 0x7C, 
0x7D, 0x7F, 0x80, 0x81, 0x83, 0x84, 0x85, 0x86, 
0x88, 0x89, 0x8A, 0x8C, 0x8D, 0x8E, 0x90, 0x91, 
0x92, 0x94, 0x95, 0x97, 0x98, 0x99, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA2, 0xA3, 0xA4, 0xA6, 0xA7, 
0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xB0, 0xB1, 0xB3, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBA, 0xBC, 0xBD, 0xBF, 
0xC0, 0xC2, 0xC3, 0xC5, 0xC6, 0xC8, 0xC9, 0xCB, 
0xCD, 0xCE, 0xD0, 0xD1, 0xD3, 0xD4, 0xD6, 0xD8, 
0xD9, 0xDB, 0xDC, 0xDE, 0xE0, 0xE1, 0xE3, 0xE4, 
0xE6, 0xE8, 0xE9, 0xEB, 0xED, 0xEE, 0xF0, 0xF2, 
0xF3, 0xF5, 0xF7, 0xF8, 0xFA, 0xFC, 0xFD, 0xFF
},

{ // 1.8
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x03,
 0x04,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,   0x06,
 0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,
 0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,
 0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,   0x15,
 0x15,   0x16,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,
 0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1E,   0x1F,
 0x20,   0x20,   0x21,   0x22,   0x23,   0x23,   0x24,   0x25,
 0x26,   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,
 0x2C,   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,
 0x33,   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,
 0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
 0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
 0x52,   0x53,   0x54,   0x56,   0x57,   0x58,   0x59,   0x5A,
 0x5B,   0x5C,   0x5D,   0x5F,   0x60,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x71,   0x72,   0x73,   0x74,   0x76,   0x77,
 0x78,   0x7A,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x81,
 0x83,   0x84,   0x86,   0x87,   0x88,   0x8A,   0x8B,   0x8C,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,   0x98,
 0x99,   0x9A,   0x9C,   0x9D,   0x9F,   0xA0,   0xA2,   0xA3,
 0xA5,   0xA6,   0xA8,   0xA9,   0xAB,   0xAC,   0xAE,   0xAF,
 0xB1,   0xB2,   0xB4,   0xB5,   0xB7,   0xB8,   0xBA,   0xBC,
 0xBD,   0xBF,   0xC0,   0xC2,   0xC3,   0xC5,   0xC7,   0xC8,
 0xCA,   0xCC,   0xCD,   0xCF,   0xD0,   0xD2,   0xD4,   0xD5,
 0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,   0xE1,   0xE3,
 0xE5,   0xE6,   0xE8,   0xEA,   0xEC,   0xED,   0xEF,   0xF1,
 0xF3,   0xF4,   0xF6,   0xF8,   0xFA,   0xFB,   0xFD,   0xFF
},

{ // 1.9
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 
0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 0x12, 
0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 
0x1C, 0x1D, 0x1E, 0x1E, 0x1F, 0x20, 0x20, 0x21, 
0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x26, 0x27, 
0x28, 0x29, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 
0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 
0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 
0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x67, 0x68, 
0x69, 0x6A, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x79, 0x7A, 0x7B, 0x7D, 
0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x86, 0x88, 
0x89, 0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x92, 0x93, 
0x95, 0x96, 0x98, 0x99, 0x9B, 0x9C, 0x9E, 0x9F, 
0xA1, 0xA2, 0xA4, 0xA5, 0xA7, 0xA8, 0xAA, 0xAC, 
0xAD, 0xAF, 0xB0, 0xB2, 0xB4, 0xB5, 0xB7, 0xB8, 
0xBA, 0xBC, 0xBD, 0xBF, 0xC1, 0xC2, 0xC4, 0xC6, 
0xC7, 0xC9, 0xCB, 0xCC, 0xCE, 0xD0, 0xD2, 0xD3, 
0xD5, 0xD7, 0xD9, 0xDA, 0xDC, 0xDE, 0xE0, 0xE1, 
0xE3, 0xE5, 0xE7, 0xE9, 0xEB, 0xEC, 0xEE, 0xF0, 
0xF2, 0xF4, 0xF6, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
},

 { // 2.0
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x03,   0x03,   0x04,   0x04,
 0x04,   0x04,   0x05,   0x05,   0x05,   0x05,   0x06,   0x06,
 0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0B,   0x0C,
 0x0C,   0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,
 0x10,   0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,
 0x14,   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x18,
 0x19,   0x1A,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1E,   0x1F,   0x20,   0x20,   0x21,   0x22,   0x23,   0x23,
 0x24,   0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,
 0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x2F,   0x30,
 0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,
 0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,
 0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x82,   0x83,
 0x85,   0x86,   0x88,   0x89,   0x8B,   0x8C,   0x8E,   0x8F,
 0x91,   0x92,   0x94,   0x95,   0x97,   0x98,   0x9A,   0x9B,
 0x9D,   0x9E,   0xA0,   0xA2,   0xA3,   0xA5,   0xA6,   0xA8,
 0xAA,   0xAB,   0xAD,   0xAF,   0xB0,   0xB2,   0xB4,   0xB5,
 0xB7,   0xB9,   0xBA,   0xBC,   0xBE,   0xC0,   0xC1,   0xC3,
 0xC5,   0xC7,   0xC8,   0xCA,   0xCC,   0xCE,   0xCF,   0xD1,
 0xD3,   0xD5,   0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,
 0xE2,   0xE4,   0xE6,   0xE8,   0xE9,   0xEB,   0xED,   0xEF,
 0xF1,   0xF3,   0xF5,   0xF7,   0xF9,   0xFB,   0xFD,   0xFF
},

{ // 2.1
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 
0x12, 0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 
0x16, 0x17, 0x18, 0x18, 0x19, 0x19, 0x1A, 0x1B, 
0x1B, 0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x21, 0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 
0x27, 0x28, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2C, 
0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x33, 
0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 
0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 
0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5F, 
0x60, 0x61, 0x62, 0x64, 0x65, 0x66, 0x68, 0x69, 
0x6A, 0x6B, 0x6D, 0x6E, 0x70, 0x71, 0x72, 0x74, 
0x75, 0x76, 0x78, 0x79, 0x7B, 0x7C, 0x7E, 0x7F, 
0x81, 0x82, 0x83, 0x85, 0x86, 0x88, 0x89, 0x8B, 
0x8D, 0x8E, 0x90, 0x91, 0x93, 0x94, 0x96, 0x97, 
0x99, 0x9B, 0x9C, 0x9E, 0xA0, 0xA1, 0xA3, 0xA5, 
0xA6, 0xA8, 0xAA, 0xAB, 0xAD, 0xAF, 0xB0, 0xB2, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBB, 0xBD, 0xBF, 0xC0, 
0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCB, 0xCD, 0xCF, 
0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 0xDF, 
0xE1, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 
0xF1, 0xF3, 0xF5, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
},

 { // 2.2
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 
0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 
0x09, 0x09, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0C, 
0x0C, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0F, 0x0F, 
0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 
0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18, 
0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x23, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x51, 
0x52, 0x53, 0x54, 0x55, 0x57, 0x58, 0x59, 0x5A, 
0x5B, 0x5D, 0x5E, 0x5F, 0x61, 0x62, 0x63, 0x64, 
0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D, 0x6E, 0x6F, 
0x71, 0x72, 0x74, 0x75, 0x77, 0x78, 0x79, 0x7B, 
0x7C, 0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x87, 
0x89, 0x8A, 0x8C, 0x8D, 0x8F, 0x91, 0x92, 0x94, 
0x95, 0x97, 0x99, 0x9A, 0x9C, 0x9E, 0x9F, 0xA1, 
0xA3, 0xA5, 0xA6, 0xA8, 0xAA, 0xAC, 0xAD, 0xAF, 
0xB1, 0xB3, 0xB5, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE, 
0xC0, 0xC2, 0xC4, 0xC5, 0xC7, 0xC9, 0xCB, 0xCD, 
0xCF, 0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 
0xDF, 0xE1, 0xE3, 0xE5, 0xE7, 0xEA, 0xEC, 0xEE, 
0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFB, 0xFD, 0xFF 
}
}; // g_GammaTableDir

TEXT_CONTRAST_TABLES TextContrastTablesInv =
{
{ // 1.1
0x00, 0x02, 0x03, 0x04, 0x06, 0x07, 0x08, 0x0A,
0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x12, 0x13,
0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1D,
0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x26,
0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E,
0x2F, 0x30, 0x31, 0x33, 0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x47, 0x48,
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80,
0x81, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 0x9D, 0x9E,
0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE,
0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5,
0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD,
0xBE, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4,
0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC,
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3,
0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA,
0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2,
0xE3, 0xE4, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9,
0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xEF, 0xF0,
0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
0xF9, 0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
},

{ // 1.2
 0x00,   0x03,   0x04,   0x06,   0x08,   0x0A,   0x0B,   0x0D,
 0x0E,   0x10,   0x11,   0x13,   0x14,   0x15,   0x17,   0x18,
 0x19,   0x1B,   0x1C,   0x1D,   0x1F,   0x20,   0x21,   0x22,
 0x24,   0x25,   0x26,   0x27,   0x28,   0x2A,   0x2B,   0x2C,
 0x2D,   0x2E,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x36,   0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,
 0x3F,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,
 0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,
 0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,   0x80,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,
 0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,   0x96,
 0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9D,
 0x9E,   0x9F,   0xA0,   0xA1,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA8,   0xA8,   0xA9,   0xAA,   0xAB,   0xAC,
 0xAD,   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
 0xBB,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC1,   0xC1,
 0xC2,   0xC3,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,
 0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,
 0xD7,   0xD8,   0xD9,   0xDA,   0xDB,   0xDB,   0xDC,   0xDD,
 0xDE,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
 0xE5,   0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xEA,   0xEB,
 0xEC,   0xED,   0xED,   0xEE,   0xEF,   0xF0,   0xF1,   0xF2,
 0xF2,   0xF3,   0xF4,   0xF5,   0xF6,   0xF7,   0xF7,   0xF8,
 0xF9,   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFF
},

{ // 1.3
0x00, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10,
0x12, 0x13, 0x15, 0x17, 0x18, 0x1A, 0x1B, 0x1D,
0x1E, 0x20, 0x21, 0x23, 0x24, 0x25, 0x27, 0x28,
0x29, 0x2B, 0x2C, 0x2D, 0x2F, 0x30, 0x31, 0x32,
0x34, 0x35, 0x36, 0x37, 0x39, 0x3A, 0x3B, 0x3C,
0x3D, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E,
0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x60, 0x61, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68,
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x86,
0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,
0x8F, 0x90, 0x91, 0x92, 0x92, 0x93, 0x94, 0x95,
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9B, 0x9C,
0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA3,
0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAA,
0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB0, 0xB1,
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7, 0xB8,
0xB9, 0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6,
0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC,
0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3,
0xD4, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD8, 0xD9,
0xDA, 0xDB, 0xDC, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE4, 0xE5, 0xE6,
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xEC,
0xED, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3,
0xF3, 0xF4, 0xF5, 0xF6, 0xF6, 0xF7, 0xF8, 0xF9,
0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFF
},

{ // 1.4
 0x00,   0x05,   0x08,   0x0B,   0x0D,   0x0F,   0x12,   0x14,
 0x16,   0x17,   0x19,   0x1B,   0x1D,   0x1E,   0x20,   0x22,
 0x23,   0x25,   0x26,   0x28,   0x29,   0x2B,   0x2C,   0x2E,
 0x2F,   0x31,   0x32,   0x33,   0x35,   0x36,   0x37,   0x39,
 0x3A,   0x3B,   0x3C,   0x3E,   0x3F,   0x40,   0x41,   0x43,
 0x44,   0x45,   0x46,   0x48,   0x49,   0x4A,   0x4B,   0x4C,
 0x4D,   0x4E,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,
 0x56,   0x57,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,
 0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x8F,   0x90,   0x91,   0x92,   0x93,   0x94,
 0x95,   0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,
 0x9C,   0x9D,   0x9E,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,
 0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAE,   0xAF,   0xAF,
 0xB0,   0xB1,   0xB2,   0xB3,   0xB4,   0xB4,   0xB5,   0xB6,
 0xB7,   0xB8,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,
 0xBD,   0xBE,   0xBF,   0xC0,   0xC0,   0xC1,   0xC2,   0xC3,
 0xC4,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,   0xD6,
 0xD6,   0xD7,   0xD8,   0xD9,   0xD9,   0xDA,   0xDB,   0xDC,
 0xDC,   0xDD,   0xDE,   0xDF,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE2,   0xE3,   0xE4,   0xE5,   0xE5,   0xE6,   0xE7,   0xE8,
 0xE8,   0xE9,   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xEE,
 0xEE,   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF3,
 0xF4,   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF9,   0xF9,
 0xFA,   0xFB,   0xFB,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
},
{ // 1.5
   0x00,   0x06,   0x0A,   0x0D,   0x10,   0x13,   0x15,   0x17,
   0x19,   0x1B,   0x1D,   0x1F,   0x21,   0x23,   0x25,   0x27,
   0x28,   0x2A,   0x2C,   0x2D,   0x2F,   0x30,   0x32,   0x33,
   0x35,   0x36,   0x38,   0x39,   0x3A,   0x3C,   0x3D,   0x3F,
   0x40,   0x41,   0x43,   0x44,   0x45,   0x46,   0x48,   0x49,
   0x4A,   0x4B,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,
   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5B,   0x5C,
   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,
   0x65,   0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,
   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,   0x8A,   0x8B,
   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,
   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,   0x99,
   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0x9F,   0xA0,
   0xA1,   0xA2,   0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,
   0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,
   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,   0xB4,
   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC0,
   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,   0xC5,   0xC6,   0xC6,
   0xC7,   0xC8,   0xC9,   0xC9,   0xCA,   0xCB,   0xCC,   0xCC,
   0xCD,   0xCE,   0xCF,   0xCF,   0xD0,   0xD1,   0xD2,   0xD2,
   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,
   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,
   0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE8,   0xE8,   0xE9,
   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xED,   0xEE,   0xEF,
   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF4,   0xF4,
   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF8,   0xF9,   0xFA,
   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
},

 { // 1.6
 0x00,   0x08,   0x0C,   0x10,   0x13,   0x16,   0x18,   0x1B,
 0x1D,   0x20,   0x22,   0x24,   0x26,   0x28,   0x2A,   0x2B,
 0x2D,   0x2F,   0x31,   0x32,   0x34,   0x36,   0x37,   0x39,
 0x3A,   0x3C,   0x3D,   0x3F,   0x40,   0x42,   0x43,   0x44,
 0x46,   0x47,   0x48,   0x4A,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x51,   0x53,   0x54,   0x55,   0x56,   0x57,   0x59,
 0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,
 0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6A,
 0x6B,   0x6D,   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,
 0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,
 0x7C,   0x7D,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,
 0x83,   0x84,   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,
 0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,
 0x92,   0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,
 0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9E,
 0x9F,   0xA0,   0xA1,   0xA2,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,   0xAB,
 0xAC,   0xAD,   0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,
 0xB2,   0xB3,   0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,
 0xB9,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,
 0xBF,   0xBF,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,
 0xC4,   0xC5,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,
 0xD6,   0xD6,   0xD7,   0xD8,   0xD8,   0xD9,   0xDA,   0xDA,
 0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,   0xDF,   0xE0,
 0xE1,   0xE1,   0xE2,   0xE3,   0xE3,   0xE4,   0xE5,   0xE5,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEB,
 0xEB,   0xEC,   0xEC,   0xED,   0xEE,   0xEE,   0xEF,   0xF0,
 0xF0,   0xF1,   0xF2,   0xF2,   0xF3,   0xF4,   0xF4,   0xF5,
 0xF6,   0xF6,   0xF7,   0xF7,   0xF8,   0xF9,   0xF9,   0xFA,
 0xFB,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
},
{ // 1.7
0x00, 0x0A, 0x0F, 0x13, 0x16, 0x19, 0x1C, 0x1F,
0x21, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30,
0x32, 0x34, 0x36, 0x37, 0x39, 0x3B, 0x3C, 0x3E,
0x40, 0x41, 0x43, 0x44, 0x46, 0x47, 0x48, 0x4A,
0x4B, 0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54,
0x56, 0x57, 0x58, 0x59, 0x5B, 0x5C, 0x5D, 0x5E,
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80,
0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x87,
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C,
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3,
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9,
0xAA, 0xAB, 0xAC, 0xAC, 0xAD, 0xAE, 0xAF, 0xAF,
0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB5, 0xB5,
0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA, 0xBB, 0xBB,
0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1,
0xC2, 0xC3, 0xC3, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7,
0xC7, 0xC8, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 0xCC,
0xCD, 0xCE, 0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD2,
0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6, 0xD7,
0xD8, 0xD8, 0xD9, 0xDA, 0xDA, 0xDB, 0xDC, 0xDC,
0xDD, 0xDE, 0xDE, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2,
0xE2, 0xE3, 0xE3, 0xE4, 0xE5, 0xE5, 0xE6, 0xE7,
0xE7, 0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEC,
0xEC, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1,
0xF1, 0xF2, 0xF2, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5,
0xF6, 0xF7, 0xF7, 0xF8, 0xF8, 0xF9, 0xFA, 0xFA,
0xFB, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF
},

{ // 1.8
 0x00,   0x0C,   0x11,   0x16,   0x19,   0x1D,   0x20,   0x23,
 0x25,   0x28,   0x2A,   0x2C,   0x2F,   0x31,   0x33,   0x35,
 0x37,   0x39,   0x3A,   0x3C,   0x3E,   0x40,   0x41,   0x43,
 0x45,   0x46,   0x48,   0x49,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x52,   0x53,   0x55,   0x56,   0x57,   0x59,   0x5A,
 0x5B,   0x5C,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
 0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
 0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8B,   0x8C,
 0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,   0x93,
 0x94,   0x95,   0x96,   0x97,   0x98,   0x98,   0x99,   0x9A,
 0x9B,   0x9C,   0x9D,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,
 0xA1,   0xA2,   0xA3,   0xA4,   0xA5,   0xA5,   0xA6,   0xA7,
 0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAC,   0xAD,
 0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,
 0xBA,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,
 0xBF,   0xC0,   0xC1,   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,   0xCF,
 0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,
 0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,   0xD9,   0xD9,
 0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,
 0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE2,   0xE3,
 0xE4,   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE7,   0xE8,
 0xE9,   0xE9,   0xEA,   0xEA,   0xEB,   0xEC,   0xEC,   0xED,
 0xED,   0xEE,   0xEE,   0xEF,   0xF0,   0xF0,   0xF1,   0xF1,
 0xF2,   0xF3,   0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,
 0xF7,   0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
},

{  // 1.9
0x00, 0x0E, 0x14, 0x19, 0x1D, 0x20, 0x23, 0x26,
0x29, 0x2C, 0x2E, 0x31, 0x33, 0x35, 0x37, 0x39,
0x3B, 0x3D, 0x3F, 0x41, 0x43, 0x45, 0x46, 0x48,
0x4A, 0x4B, 0x4D, 0x4E, 0x50, 0x51, 0x53, 0x54,
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5E, 0x5F,
0x60, 0x61, 0x63, 0x64, 0x65, 0x66, 0x68, 0x69,
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72,
0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82,
0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
0x8B, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91,
0x92, 0x93, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9D, 0x9E,
0x9F, 0xA0, 0xA1, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5,
0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9, 0xAA, 0xAB,
0xAB, 0xAC, 0xAD, 0xAE, 0xAE, 0xAF, 0xB0, 0xB1,
0xB1, 0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6,
0xB7, 0xB8, 0xB9, 0xB9, 0xBA, 0xBB, 0xBB, 0xBC,
0xBD, 0xBD, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2,
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC6, 0xC6, 0xC7,
0xC8, 0xC8, 0xC9, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC,
0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1,
0xD2, 0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6,
0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB,
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0,
0xE0, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4, 0xE4,
0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8, 0xE9, 0xE9,
0xEA, 0xEA, 0xEB, 0xEB, 0xEC, 0xEC, 0xED, 0xEE,
0xEE, 0xEF, 0xEF, 0xF0, 0xF0, 0xF1, 0xF2, 0xF2,
0xF3, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6,
0xF7, 0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB,
0xFB, 0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF
},

{ // 2.0
 0x00,   0x10,   0x17,   0x1C,   0x20,   0x24,   0x27,   0x2A,
 0x2D,   0x30,   0x32,   0x35,   0x37,   0x3A,   0x3C,   0x3E,
 0x40,   0x42,   0x44,   0x46,   0x47,   0x49,   0x4B,   0x4D,
 0x4E,   0x50,   0x51,   0x53,   0x54,   0x56,   0x57,   0x59,
 0x5A,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,
 0x8F,   0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,
 0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,
 0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA7,   0xA8,
 0xA9,   0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,   0xAE,
 0xAF,   0xB0,   0xB0,   0xB1,   0xB2,   0xB3,   0xB3,   0xB4,
 0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,   0xBA,
 0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBE,   0xBF,
 0xC0,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xC9,
 0xCA,   0xCB,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,
 0xCF,   0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,
 0xD4,   0xD4,   0xD5,   0xD6,   0xD6,   0xD7,   0xD7,   0xD8,
 0xD9,   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,
 0xDD,   0xDE,   0xDE,   0xDF,   0xE0,   0xE0,   0xE1,   0xE1,
 0xE2,   0xE2,   0xE3,   0xE4,   0xE4,   0xE5,   0xE5,   0xE6,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEA,
 0xEB,   0xEB,   0xEC,   0xEC,   0xED,   0xED,   0xEE,   0xEE,
 0xEF,   0xF0,   0xF0,   0xF1,   0xF1,   0xF2,   0xF2,   0xF3,
 0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,   0xF6,   0xF7,
 0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
},
{ // 2.1
0x00, 0x12, 0x19, 0x1F, 0x23, 0x27, 0x2B, 0x2E,
0x31, 0x34, 0x37, 0x39, 0x3B, 0x3E, 0x40, 0x42,
0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x4F, 0x51,
0x53, 0x54, 0x56, 0x58, 0x59, 0x5B, 0x5C, 0x5D,
0x5F, 0x60, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68,
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72,
0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7A, 0x7B,
0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83,
0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B,
0x8C, 0x8D, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92,
0x93, 0x94, 0x95, 0x95, 0x96, 0x97, 0x98, 0x99,
0x9A, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA3, 0xA4, 0xA5, 0xA6,
0xA6, 0xA7, 0xA8, 0xA9, 0xA9, 0xAA, 0xAB, 0xAC,
0xAC, 0xAD, 0xAE, 0xAF, 0xAF, 0xB0, 0xB1, 0xB1,
0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7,
0xB8, 0xB8, 0xB9, 0xBA, 0xBA, 0xBB, 0xBC, 0xBC,
0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2,
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7,
0xC7, 0xC8, 0xC9, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC,
0xCC, 0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD0,
0xD1, 0xD2, 0xD2, 0xD3, 0xD3, 0xD4, 0xD5, 0xD5,
0xD6, 0xD6, 0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA,
0xDA, 0xDB, 0xDB, 0xDC, 0xDD, 0xDD, 0xDE, 0xDE,
0xDF, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2, 0xE2, 0xE3,
0xE3, 0xE4, 0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7,
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB,
0xEC, 0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF,
0xF0, 0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3,
0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7,
0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB,
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
},
{ // 2.2
0x00, 0x15, 0x1C, 0x22, 0x27, 0x2B, 0x2E, 0x32,
0x35, 0x38, 0x3B, 0x3D, 0x40, 0x42, 0x44, 0x46,
0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x55,
0x57, 0x59, 0x5A, 0x5C, 0x5D, 0x5F, 0x60, 0x62,
0x63, 0x65, 0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D,
0x6E, 0x6F, 0x70, 0x72, 0x73, 0x74, 0x75, 0x76,
0x77, 0x78, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
0x97, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C,
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3,
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA7, 0xA8, 0xA9,
0xAA, 0xAA, 0xAB, 0xAC, 0xAD, 0xAD, 0xAE, 0xAF,
0xAF, 0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB4,
0xB5, 0xB6, 0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA,
0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBE, 0xBF,
0xC0, 0xC0, 0xC1, 0xC2, 0xC2, 0xC3, 0xC3, 0xC4,
0xC5, 0xC5, 0xC6, 0xC7, 0xC7, 0xC8, 0xC8, 0xC9,
0xCA, 0xCA, 0xCB, 0xCB, 0xCC, 0xCD, 0xCD, 0xCE,
0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1, 0xD2, 0xD2,
0xD3, 0xD4, 0xD4, 0xD5, 0xD5, 0xD6, 0xD6, 0xD7,
0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB, 0xDB,
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0,
0xE0, 0xE1, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4,
0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8,
0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB, 0xEC,
0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0,
0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3, 0xF4,
0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7, 0xF8,
0xF8, 0xF9, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB,
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
}
};

// The codebook: 115 entries stored as sequential triples of unsigned char

static const F_RGB gaOutTableRGB[CT_LOOKUP] = {
0,0,0,0,
0,0,1,0,
0,0,2,0,
0,1,1,0,
0,1,2,0,
0,1,3,0,
0,2,2,0,
0,2,3,0,
0,2,4,0,
1,0,0,0,
1,0,1,0,
1,0,2,0,
1,1,0,0,
1,1,1,0,
1,1,2,0,
1,1,3,0,
1,2,1,0,
1,2,2,0,
1,2,3,0,
1,2,4,0,
1,3,2,0,
1,3,3,0,
1,3,4,0,
1,3,5,0,
2,0,0,0,
2,0,1,0,
2,0,2,0,
2,1,0,0,
2,1,1,0,
2,1,2,0,
2,1,3,0,
2,2,0,0,
2,2,1,0,
2,2,2,0,
2,2,3,0,
2,2,4,0,
2,3,1,0,
2,3,2,0,
2,3,3,0,
2,3,4,0,
2,3,5,0,
2,4,2,0,
2,4,3,0,
2,4,4,0,
2,4,5,0,
2,4,6,0,
3,1,0,0,
3,1,1,0,
3,1,2,0,
3,1,3,0,
3,2,0,0,
3,2,1,0,
3,2,2,0,
3,2,3,0,
3,2,4,0,
3,3,1,0,
3,3,2,0,
3,3,3,0,
3,3,4,0,
3,3,5,0,
3,4,2,0,
3,4,3,0,
3,4,4,0,
3,4,5,0,
3,4,6,0,
3,5,3,0,
3,5,4,0,
3,5,5,0,
3,5,6,0,
4,2,0,0,
4,2,1,0,
4,2,2,0,
4,2,3,0,
4,2,4,0,
4,3,1,0,
4,3,2,0,
4,3,3,0,
4,3,4,0,
4,3,5,0,
4,4,2,0,
4,4,3,0,
4,4,4,0,
4,4,5,0,
4,4,6,0,
4,5,3,0,
4,5,4,0,
4,5,5,0,
4,5,6,0,
4,6,4,0,
4,6,5,0,
4,6,6,0,
5,3,1,0,
5,3,2,0,
5,3,3,0,
5,3,4,0,
5,4,2,0,
5,4,3,0,
5,4,4,0,
5,4,5,0,
5,5,3,0,
5,5,4,0,
5,5,5,0,
5,5,6,0,
5,6,4,0,
5,6,5,0,
5,6,6,0,
6,4,2,0,
6,4,3,0,
6,4,4,0,
6,5,3,0,
6,5,4,0,
6,5,5,0,
6,6,4,0,
6,6,5,0,
6,6,6,0
};

static const F_RGB gaOutTableBGR[CT_LOOKUP] = {
0,0,0,0,
1,0,0,0,
2,0,0,0,
1,1,0,0,
2,1,0,0,
3,1,0,0,
2,2,0,0,
3,2,0,0,
4,2,0,0,
0,0,1,0,
1,0,1,0,
2,0,1,0,
0,1,1,0,
1,1,1,0,
2,1,1,0,
3,1,1,0,
1,2,1,0,
2,2,1,0,
3,2,1,0,
4,2,1,0,
2,3,1,0,
3,3,1,0,
4,3,1,0,
5,3,1,0,
0,0,2,0,
1,0,2,0,
2,0,2,0,
0,1,2,0,
1,1,2,0,
2,1,2,0,
3,1,2,0,
0,2,2,0,
1,2,2,0,
2,2,2,0,
3,2,2,0,
4,2,2,0,
1,3,2,0,
2,3,2,0,
3,3,2,0,
4,3,2,0,
5,3,2,0,
2,4,2,0,
3,4,2,0,
4,4,2,0,
5,4,2,0,
6,4,2,0,
0,1,3,0,
1,1,3,0,
2,1,3,0,
3,1,3,0,
0,2,3,0,
1,2,3,0,
2,2,3,0,
3,2,3,0,
4,2,3,0,
1,3,3,0,
2,3,3,0,
3,3,3,0,
4,3,3,0,
5,3,3,0,
2,4,3,0,
3,4,3,0,
4,4,3,0,
5,4,3,0,
6,4,3,0,
3,5,3,0,
4,5,3,0,
5,5,3,0,
6,5,3,0,
0,2,4,0,
1,2,4,0,
2,2,4,0,
3,2,4,0,
4,2,4,0,
1,3,4,0,
2,3,4,0,
3,3,4,0,
4,3,4,0,
5,3,4,0,
2,4,4,0,
3,4,4,0,
4,4,4,0,
5,4,4,0,
6,4,4,0,
3,5,4,0,
4,5,4,0,
5,5,4,0,
6,5,4,0,
4,6,4,0,
5,6,4,0,
6,6,4,0,
1,3,5,0,
2,3,5,0,
3,3,5,0,
4,3,5,0,
2,4,5,0,
3,4,5,0,
4,4,5,0,
5,4,5,0,
3,5,5,0,
4,5,5,0,
5,5,5,0,
6,5,5,0,
4,6,5,0,
5,6,5,0,
6,6,5,0,
2,4,6,0,
3,4,6,0,
4,4,6,0,
3,5,6,0,
4,5,6,0,
5,5,6,0,
4,6,6,0,
5,6,6,0,
6,6,6,0
};

const F_RGB * gaOutTable = gaOutTableRGB;

const BYTE FilteredCTLut[7*7*7] =
{
0x00,0x01,0x02,0x02,0x05,0x05,0x08,0x00,0x03,0x04,0x05,0x05,0x08,0x08,0x03,0x03,
0x06,0x07,0x08,0x08,0x17,0x10,0x06,0x06,0x07,0x08,0x17,0x17,0x10,0x14,0x14,0x15,
0x16,0x17,0x17,0x14,0x14,0x14,0x15,0x16,0x17,0x2d,0x29,0x29,0x29,0x2a,0x2b,0x2c,
0x2d,0x09,0x0a,0x0b,0x0b,0x0f,0x0f,0x13,0x0c,0x0d,0x0e,0x0f,0x0f,0x13,0x13,0x0c,
0x10,0x11,0x12,0x13,0x13,0x17,0x10,0x10,0x14,0x15,0x16,0x17,0x17,0x24,0x14,0x14,
0x15,0x16,0x17,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x29,0x2a,0x2b,
0x2c,0x2d,0x18,0x19,0x1a,0x1a,0x1e,0x1e,0x23,0x1b,0x1c,0x1d,0x1e,0x1e,0x23,0x23,
0x1f,0x20,0x21,0x22,0x23,0x23,0x28,0x1f,0x24,0x25,0x26,0x27,0x28,0x28,0x24,0x24,
0x29,0x2a,0x2b,0x2c,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x41,0x41,
0x42,0x43,0x44,0x18,0x19,0x1a,0x31,0x31,0x31,0x36,0x2e,0x2f,0x30,0x31,0x31,0x36,
0x36,0x32,0x33,0x34,0x35,0x36,0x36,0x3b,0x32,0x37,0x38,0x39,0x3a,0x3b,0x3b,0x37,
0x37,0x3c,0x3d,0x3e,0x3f,0x40,0x37,0x3c,0x3c,0x41,0x42,0x43,0x44,0x3c,0x3c,0x41,
0x41,0x42,0x43,0x44,0x2e,0x2f,0x30,0x31,0x31,0x49,0x49,0x2e,0x2f,0x30,0x31,0x49,
0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x45,0x4a,0x4b,0x4c,0x4d,0x4e,0x4e,
0x4a,0x4a,0x4f,0x50,0x51,0x52,0x53,0x4a,0x4f,0x4f,0x54,0x55,0x56,0x57,0x4f,0x4f,
0x54,0x54,0x58,0x59,0x5a,0x2e,0x2f,0x30,0x31,0x49,0x49,0x49,0x45,0x46,0x47,0x48,
0x49,0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,0x4e,
0x4e,0x5b,0x5b,0x5f,0x60,0x61,0x62,0x53,0x5b,0x5f,0x5f,0x63,0x64,0x65,0x66,0x5f,
0x5f,0x63,0x63,0x67,0x68,0x69,0x45,0x46,0x47,0x48,0x49,0x49,0x49,0x45,0x46,0x47,
0x48,0x49,0x49,0x49,0x5b,0x5b,0x5c,0x5d,0x5e,0x5e,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,
0x5e,0x62,0x5b,0x6a,0x6a,0x6b,0x6c,0x62,0x62,0x6a,0x6a,0x6a,0x6d,0x6e,0x6f,0x66,
0x6a,0x6a,0x6d,0x6d,0x70,0x71,0x72};

} // namespace Globals


// The encoding lookup table. There are 3^5 possible entries corresponding to
// 5 emmiters: BP, RT, GT, BT, RN

const BYTE gajStorageTable[CT_STORAGE] = {
  0,  1,  2,  3,  4,  5,  6,  7,  8,
 13, 14, 15, 17, 18, 19, 21, 22, 23,
 33, 34, 35, 38, 39, 40, 43, 44, 45,
 12, 13, 14, 16, 17, 18, 20, 21, 22,
 32, 33, 34, 37, 38, 39, 42, 43, 44,
 56, 57, 58, 61, 62, 63, 66, 67, 68,
 31, 32, 33, 36, 37, 38, 41, 42, 43,
 55, 56, 57, 60, 61, 62, 65, 66, 67,
 79, 80, 81, 84, 85, 86, 88, 89, 90,
  9, 10, 11, 13, 14, 15, 17, 18, 19,
 28, 29, 30, 33, 34, 35, 38, 39, 40,
 52, 53, 54, 57, 58, 59, 62, 63, 64,
 27, 28, 29, 32, 33, 34, 37, 38, 39,
 51, 52, 53, 56, 57, 58, 61, 62, 63,
 75, 76, 77, 80, 81, 82, 85, 86, 87,
 50, 51, 52, 55, 56, 57, 60, 61, 62,
 74, 75, 76, 79, 80, 81, 84, 85, 86,
 95, 96, 97, 99,100,101,103,104,105,
 24, 25, 26, 28, 29, 30, 33, 34, 35,
 47, 48, 49, 52, 53, 54, 57, 58, 59,
 71, 72, 73, 76, 77, 78, 81, 82, 83,
 46, 47, 48, 51, 52, 53, 56, 57, 58,
 70, 71, 72, 75, 76, 77, 80, 81, 82,
 92, 93, 94, 96, 97, 98,100,101,102,
 69, 70, 71, 74, 75, 76, 79, 80, 81,
 91, 92, 93, 95, 96, 97, 99,100,101,
106,107,108,109,110,111,112,113,114
};

const BYTE gajStorageTableBloated[CT_STORAGE] = {
  0,  2,  5,  6,  8,  8, 22, 23, 23,
 33, 35, 40, 43, 45, 45, 44, 45, 45,
 61, 63, 63, 66, 68, 68, 67, 68, 68,
 31, 33, 38, 41, 43, 43, 66, 67, 67,
 79, 81, 86, 88, 90, 90, 89, 90, 90,
 84, 86, 86, 88, 90, 90, 89, 90, 90,
 74, 76, 81, 84, 86, 86, 85, 86, 86,
 95, 97,101,103,105,105,104,105,105,
 99,101,101,103,105,105,104,105,105,
 24, 26, 30, 33, 35, 35, 58, 59, 59,
 71, 73, 78, 81, 83, 83, 82, 83, 83,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 46, 48, 53, 56, 58, 58, 81, 82, 82,
 92, 94, 98,100,102,102,101,102,102,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114
};

// rasterizer returns unfiltered data in 2,2,2 format for r,g,b

#define GETRED(j)  (((j) >> 4) & 3)
#define GETGRE(j)  (((j) >> 2) & 3)
#define GETBLU(j)  (((j) >> 0) & 3)

#define R_SET(j)   ((j) & 0X30)
#define B_SET(j)   ((j) & 0X03)

#define FL_LEFT_LEAK   1
#define FL_RIGHT_LEAK  2

// because of the color filtering we may need to expand the original bitmap
// by one column of zero pixels on the left and on the right.
// After we perform the color filtering the column of left edge will pick up
// a non-trivial Blue component (color "leak" from the leftmost pixel in the
// original bitmap) while the column on the right edge will pick up the
// nontrivial Red component from the "leakage" of the rightmost pixel in the
// original bitmap. [BodinD]

ULONG ulClearTypeFilter(GLYPHBITS *pgb, ULONG cjBits, CacheFaceRealization *prface)
{
    const ULONG cx = pgb->sizlBitmap.cx;
    const ULONG cy = pgb->sizlBitmap.cy;
    const BYTE * pCurrentStorageTable = gajStorageTable;

    if (prface->Face->pifi->flInfo & (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH) /* the font is fixed pitch */
        /* we need find some way for horizontal transform */
        && (prface->Face->pifi->usWinWeight <= FW_NORMAL) /* normal or thin weight */
        && (!UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Courier New")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Rod")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Rod Transparent")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Fixed Miriam Transparent")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Miriam Fixed")
           || !UnicodeStringCompareCI((PWSTR)((BYTE*)prface->Face->pifi + prface->Face->pifi->dpwszFamilyName),L"Simplified Arabic Fixed")
          )
        )
    {
        /* Courier New look too thin with ClearType standard filter, let's use a bloated filter : */
        pCurrentStorageTable = gajStorageTableBloated;
    }


    FLONG flCTBits = 0;
    ULONG cyT = cy;

    for (BYTE *pjScan = pgb->aj; cyT; cyT--, pjScan += cx)
    {
        if (R_SET(pjScan[0]))
            flCTBits |= FL_LEFT_LEAK;

        if (B_SET(pjScan[cx - 1]))
            flCTBits |= FL_RIGHT_LEAK;

        if ((flCTBits & (FL_LEFT_LEAK | FL_RIGHT_LEAK)) == (FL_LEFT_LEAK | FL_RIGHT_LEAK))
            break;
    }

// we need to copy and filter in the same pass for performance reasons,
// we traverse the source backwards, so that we do not overwrite it

    ULONG cxD = cx;

    if (flCTBits & FL_LEFT_LEAK)
        cxD += 1;

    if (flCTBits & FL_RIGHT_LEAK)
        cxD += 1;

    BYTE jP, jT, jN;

    ULONG kBP;          // unfiltered blue count from the previous pixel
    ULONG kRN;          // unfiltered red count from the next pixel
    ULONG kRT, kGT, kBT;   // unfiltered counts from this pixel

    BYTE * pjSrcScanEnd = pgb->aj + (cx * cy) - 1;
    BYTE * pjDstScanEnd = pgb->aj + (cxD * cy) - 1;

    for ( ; pjDstScanEnd > pgb->aj; pjDstScanEnd -= cxD, pjSrcScanEnd -= cx)
    {
        BYTE *pjD1, *pjS1, *pjS0;

        pjD1 = pjDstScanEnd;
        pjS1 = pjSrcScanEnd;
        pjS0 = pjS1 - cx;

    // for the right border pixel jN = 0; jT = 0; jP = *pjS1;
    // therefore:
    //
    // kBP = GETBLU(*pjS1);  // GETBLU(jP);
    // kRN = 0; // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));

        if (flCTBits & FL_RIGHT_LEAK)
        {
            *pjD1-- = pCurrentStorageTable[3 * 3 * 3 * 3 * GETBLU(*pjS1)];
        }

    // initialize the loop in the middle

        for (jN = 0, jT = *pjS1; pjS1 > pjS0; pjS1--, pjD1--, jN = jT, jT = jP)
        {
            jP = (pjS1 == &pjS0[1]) ? 0 : pjS1[-1];

            kBP = GETBLU(jP);
            kRN = GETRED(jN);

            if (kBP || jT || kRN) // must compute, else optimize
            {
                kRT = GETRED(jT);
                kGT = GETGRE(jT);
                kBT = GETBLU(jT);

            // now convert this to a filtered index in the lookup table range
            // this is the trick, filtering and storing is done in one step

                ULONG iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
                *pjD1 = pCurrentStorageTable[iStorage];
            }
            else
            {
                *pjD1 = 0;
            }
        }

    // for the left border pixel jP = 0; jT = 0; jN = pjS0[1];
    // therefore:
    //
    // kBP = 0; // GETBLU(jP);
    // kRN = GETRED(pjS0[1]); // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
    // i.e. iStorage = kRN, which implies:

        if (flCTBits & FL_LEFT_LEAK)
        {
            *pjD1 = pCurrentStorageTable[ GETRED(pjS0[1]) ];
        }
    }

// fix the size and the origin

    pgb->sizlBitmap.cx = cxD;
    if (flCTBits & FL_LEFT_LEAK)
    {
        pgb->ptlUprightOrigin.x -= 1;
        pgb->ptlSidewaysOrigin.x -= 1;
    }

    return CJ_CTGD(cxD, cy);
}

void TextColorGammaTable::CreateTextColorGammaTable(const GpColor * color, ULONG value, ULONG gsLevel)
{
    gammaValue = value;

    if (color)
    {
        ULONG i;
        ULONG k = gsLevel - 1;

        if (gammaValue)
        {
            ULONG k = gammaValue - 1;

            for (i = 0; i < gsLevel; i++)
            {
                ULONG j;
                j = (ULONG) 255-(((ULONG) 255 * (ULONG) i) / (gsLevel - 1));

                argb[i] = color->PremultiplyWithCoverage(color->GetValue(), 255 - Globals::TextContrastTablesInv[k][j]);
            }
        }
        else
        {
            for (i = 0; i < gsLevel; i++)
            {
                ULONG j;
                argb[i] = color->PremultiplyWithCoverage(color->GetValue(),  (BYTE)((255 * i) / (gsLevel - 1)));
            }
        }
    }
}

BYTE TextColorGammaTable::GetGammaTableIndexValue(BYTE grayscaleValue, ULONG gsLevel)
{
    if (gammaValue)
    {
        ULONG k = gammaValue - 1;

        ULONG j;
        j = (ULONG) 255-(((ULONG) 255 * (ULONG) grayscaleValue) / (gsLevel - 1));

       return ((BYTE)255 - Globals::TextContrastTablesInv[k][j]);
    }
    else
    {
       return (BYTE)(((ULONG) 255 * (ULONG) grayscaleValue) / (gsLevel - 1));
    }
}

DpOutputAntiAliasSolidColorSpan::DpOutputAntiAliasSolidColorSpan(GpColor &color, DpScanBuffer * scan, ULONG gammaValue, ULONG gsLevel)
                                : DpOutputSolidColorSpan( 0, scan)
{
    textColorGammaTable.CreateTextColorGammaTable(&color, gammaValue, gsLevel);
}

GpStatus DpOutputAntiAliasBrushOutputSpan::OutputSpan(INT y, INT xMin, INT xMax)
{
    Output->OutputSpan(y, xMin, xMax);

    ARGB *buffer;

    buffer = Output->GetScanBuffer()->GetCurrentBuffer();

    for (INT j = xMin; j < xMax; j++)
    {
        *buffer++ = GpColor::MultiplyCoverage(*buffer, alphaCoverage);
    }

    return Ok;
}

void UpdateLCDOrientation()
{
    DWORD dwOrientation = FE_FONTSMOOTHINGORIENTATIONRGB;
    BOOL ret = SystemParametersInfoA(SPI_GETFONTSMOOTHINGORIENTATION, 0, &dwOrientation, 0);
    if (!ret)
        dwOrientation = FE_FONTSMOOTHINGORIENTATIONRGB;

    if ((dwOrientation & FE_FONTSMOOTHINGORIENTATIONRGB) != 0)
    {
        Globals::gaOutTable = Globals::gaOutTableRGB;
    }
    else
    {
        Globals::gaOutTable = Globals::gaOutTableBGR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\ddi\precomp.hpp ===
#include "..\Runtime\runtime.hpp"
#include "common.hpp"

#include "..\..\privinc\imaging.h"
#include "..\..\ddkinc\ddiplus.hpp"

#include "..\render\Scan.hpp"
#include "..\render\scandib.hpp"


// Hack: These dependencies on 'Entry' should be fixed
#include "..\Entry\device.hpp"
#include "..\Entry\ImageAttr.hpp"
#include "..\Entry\gpbitmap.hpp"
#include "..\Entry\brush.hpp"
#include "..\Entry\pen.hpp"
#include "..\Entry\intmap.hpp"
#include "..\fondrv\tt\ttfd\fontddi.h"
#include "..\Entry\fontFace.hpp"
#include "..\Entry\facerealization.hpp"
#include "..\Entry\family.hpp"
#include "..\Entry\font.hpp"
#include "..\Entry\fontcollection.hpp"
#include "..\Entry\stringFormat.hpp"
#include "..\Entry\path.hpp"
#include "..\Entry\metafile.hpp"
#include "..\Entry\path.hpp"
#include "..\Entry\DrawGlyphData.hpp"
#include "..\Entry\graphics.hpp"
#include "..\Entry\textImager.hpp"
// EndHack

#include "DpDriverInternal.hpp"
#include "DpDriverData.hpp"

#include "..\imaging\api\ColorPal.hpp"
#include "..\imaging\api\ImgUtils.hpp"

#include "..\Pdrivers\ConvertToGdi.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\brush.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Brush API related declarations
*
* Revision History:
*
*   12/09/1998 davidx
*       Flesh out Brush interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _BRUSH_HPP
#define _BRUSH_HPP

#define HatchBrush HatchFillBrush

#include "path.hpp" // GpPathGradient needs GpPath.
#include <stddef.h>
#include "..\..\sdkinc\GdiplusColor.h"  // IsOpaque needs AlphaMask.

COLORREF
ToCOLORREF(
    const DpBrush *     deviceBrush
    );

enum GpSpecialGradientType
{
    GradientTypeNotSpecial,
    GradientTypeHorizontal,
    GradientTypeVertical,
    GradientTypeDiagonal,
    GradientTypePathTwoStep,
    GradientTypePathComplex
};

//--------------------------------------------------------------------------
// Abstract base class for various brush types
//--------------------------------------------------------------------------

class GpBrush : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagBrush : ObjectTagInvalid);
    }

public:

    // Make a copy of the Brush object

    virtual GpBrush* Clone() const = 0;

    // Virtual destructor

    virtual ~GpBrush() {}

    // Determine if brushes are equivalent
    virtual BOOL IsEqual(const GpBrush * brush) const
    {
        return DeviceBrush.Type == brush->DeviceBrush.Type;
    }

    // Get the lock object

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    GpBrushType GetBrushType() const
    {
        return DeviceBrush.Type;
    }

    const DpBrush * GetDeviceBrush() const
    {
        return & DeviceBrush;
    }

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagBrush);
    }

    virtual const DpPath * GetOutlinePath() const
    {
        return NULL;
    }

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const = 0;

    //IsSolid currently means that the entire fill has the same ARGB color.
    //v2: Think about changing this to mean same RGB color instead.
    virtual BOOL IsSolid() const = 0;

    virtual BOOL IsNearConstant(BYTE *MinAlpha, BYTE* MaxAlpha) const = 0;

    // return Horizontal, Vertical, or (in future path)
    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const = 0;

    virtual ObjectType GetObjectType() const { return ObjectTypeBrush; }

    static GpBrush * GetBrush(const DpBrush * brush)
    {
        return (GpBrush *) ((BYTE *) brush - offsetof(GpBrush, DeviceBrush));
    }

    COLORREF ToCOLORREF() const
    {
        return ::ToCOLORREF(&DeviceBrush);
    }

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds = NULL) = 0;

    void SetGammaCorrection(BOOL useGamma)
    {
        DeviceBrush.IsGammaCorrected = useGamma;
    }
    
    BOOL GetGammaCorrection() const
    {
        return DeviceBrush.IsGammaCorrected;
    }
    

protected:  // GDI+ Internal

    DpBrush DeviceBrush;

    mutable GpLockable Lockable;
};


//--------------------------------------------------------------------------
// Represent solid fill brush object
//--------------------------------------------------------------------------

class GpSolidFill : public GpBrush
{
public:

    GpSolidFill(VOID)
    {
        DefaultBrush();
    }

    GpSolidFill(const GpColor& color)
        : Color(color)
    {
        DeviceBrush.Type = BrushTypeSolidColor;
        DeviceBrush.SolidColor.SetColor(color.GetValue());
        SetValid(TRUE);
    }

    ~GpSolidFill() {}

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    GpColor GetColor() const
    {
        return Color;
    }

    VOID SetColor(const GpColor& color)
    {
        Color = color;
        DeviceBrush.SolidColor.SetColor(color.GetValue());
    }

    GpBrush* Clone() const
    {
        return new GpSolidFill(Color);
    }

    virtual BOOL IsEqual(const GpSolidFill * brush) const
    {
        return Color.IsEqual(brush->Color);
    }

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        return DeviceBrush.SolidColor.IsOpaque();
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return TRUE;
    }

    virtual BOOL IsNearConstant(BYTE *MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = Color.GetAlpha();
        *MaxAlpha = *MinAlpha;
        return TRUE;
    }
    
    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        return GradientTypeNotSpecial;
    }

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

private:

    //bhouse: why do we have store a GpColor here?
    GpColor         Color;

    VOID DefaultBrush()
    {
        Color.SetValue(Color::Black);
        DeviceBrush.Type = BrushTypeSolidColor;
        DeviceBrush.SolidColor.SetColor(Color.GetValue());
        SetValid(TRUE);
    }
};

//--------------------------------------------------------------------------
// Abstract brush which is made of an elementary object.
//--------------------------------------------------------------------------

class GpElementaryBrush : public GpBrush
{
public:

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const = 0;

    // Set/get brush transform

    GpStatus SetTransform(const GpMatrix& matrix)
    {
        GpStatus    status = Ok;

        // Keep the transform invertible

        if (matrix.IsInvertible())
        {
            DeviceBrush.Xform = matrix;
            UpdateUid();
        }
        else
            status = InvalidParameter;

        return status;
    }

    GpStatus GetTransform(GpMatrix* matrix) const
    {
        *matrix = DeviceBrush.Xform;

        return Ok;
    }

    GpStatus ResetTransform()
    {
        DeviceBrush.Xform.Reset();
        UpdateUid();

        return Ok;
    }

    GpStatus MultiplyTransform(const GpMatrix& matrix,
                                    GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus TranslateTransform(REAL dx, REAL dy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DeviceBrush.Xform.Translate(dx, dy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus ScaleTransform(REAL sx, REAL sy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DeviceBrush.Xform.Scale(sx, sy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus ScalePath(REAL sx, REAL sy)
    {
        DeviceBrush.Rect.X *= sx;
        DeviceBrush.Rect.Y *= sy;
        DeviceBrush.Rect.Height *= sy;
        DeviceBrush.Rect.Width *= sx;
        DeviceBrush.Points[0].X = DeviceBrush.Points[0].X * sx;
        DeviceBrush.Points[0].Y = DeviceBrush.Points[0].Y * sy;

        if (DeviceBrush.Path != NULL)
        {
            GpMatrix matrix(sx, 0.0f, 0.0f, sy, 0.0f, 0.0f); 
            DeviceBrush.Path->Transform(&matrix);
        }
        else if (DeviceBrush.PointsPtr && DeviceBrush.Count > 0)
        {
            for (INT i = 0; i < DeviceBrush.Count; i++)
            {
                DeviceBrush.PointsPtr[i].X *= sx;
                DeviceBrush.PointsPtr[i].Y *= sy;
            }
        }
        
        UpdateUid();

        return Ok;
    }
    
    GpStatus RotateTransform(REAL angle,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DeviceBrush.Xform.Rotate(angle, order);
        UpdateUid();

        return Ok;
    }

    // Set/get brush wrapping mode

    VOID SetWrapMode(GpWrapMode wrapMode)
    {
       if (!WrapModeIsValid(wrapMode))
          return;

       DeviceBrush.Wrap = wrapMode;
       UpdateUid();
    }

    GpWrapMode GetWrapMode() const
    {
        return DeviceBrush.Wrap;
    }

    // Get source rectangle

    VOID GetRect(GpRectF& rect) const
    {
        rect = DeviceBrush.Rect;
    }

    // Determine if the brushes are equivalent.  Only compare for equivalence
    // if both brushes are valid.

    virtual BOOL isEqual(const GpBrush * brush) const
    {
        if (GpBrush::IsEqual(brush))
        {
            const GpElementaryBrush * ebrush;

            ebrush = static_cast<const GpElementaryBrush *>(brush);
            return IsValid() &&
                   ebrush->IsValid() &&
                   ebrush->DeviceBrush.Wrap == DeviceBrush.Wrap &&
                   ebrush->DeviceBrush.Xform.IsEqual(&DeviceBrush.Xform);
        }
        else
        {
            return FALSE;
        }
    }

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        return GradientTypeNotSpecial;
    }

protected:  // GDI+ Internal

    GpElementaryBrush()
    {
        SetValid(FALSE);
        DeviceBrush.Wrap = WrapModeTile;
        DeviceBrush.IsGammaCorrected = FALSE;
    }

    GpElementaryBrush(const GpElementaryBrush* brush);

};

//--------------------------------------------------------------------------
// Represent texture brush object
//
// A rectangel returned by GetRect() is given by the pixel unit in case of
// GpBitmap and by the inch unit in case of GpMetafile.
//--------------------------------------------------------------------------

class GpTexture : public GpElementaryBrush
{
public:

    // Constructors

    GpTexture() {
        DefaultBrush();
    }

    GpTexture(GpImage* image, GpWrapMode wrapMode = WrapModeTile)
    {
        InitializeBrush(image, wrapMode, NULL);
    }

    GpTexture(GpImage* image, GpWrapMode wrapMode, const GpRectF& rect)
    {
        InitializeBrush(image, wrapMode, &rect);
    }

    GpTexture(GpImage *image, const GpRectF& rect, const GpImageAttributes *imageAttributes)
    {
        GpWrapMode wrapMode = WrapModeTile;
        if (imageAttributes)
        {
            wrapMode = imageAttributes->DeviceImageAttributes.wrapMode;
            if (!imageAttributes->HasRecoloring())
            {
                imageAttributes = NULL;
            }
        }
        InitializeBrush(image, wrapMode, &rect, imageAttributes);
    }

    GpBrush* Clone() const
    {
        return new GpTexture(this);
    }

    ~GpTexture() {
        if(Image)
            Image->Dispose();
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Get texture brush attributes

    GpImage* GetImage()
    {
        // !!!
        //  Notice that we're returning a pointer
        //  to our internal bitmap object here.

        return Image;
    }

    GpImageType GetImageType() const
    {
        return ImageType;
    }

    GpBitmap* GetBitmap() const
    {
        // !!!
        //  Notice that we're returning a pointer
        //  to our internal bitmap object here.

        if(ImageType == ImageTypeBitmap)
            return static_cast<GpBitmap*>(Image);
        else
            return NULL;
    }

    GpStatus GetBitmapSize(Size * size) const
    {
        GpBitmap *  brushBitmap = this->GetBitmap();

        if (brushBitmap != NULL)
        {
            brushBitmap->GetSize(size);
            return Ok;
        }
        size->Width = size->Height = 0;
        return InvalidParameter;
    }


    // Check the opacity of bitmap.

    BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        DpTransparency transparency;

        GpBitmap *bitmap = GetBitmap();

        if (bitmap == NULL) 
        {
            return FALSE;
        }

        ASSERT(bitmap->IsValid());

        if (ColorsOnly)     // get real transparency, not cached
        {
            if (bitmap->GetTransparencyFlags(&transparency,
                                             PixelFormat32bppPARGB) != Ok)
            {
                transparency = TransparencyUnknown;
            }
        }
        else
        {
            if (bitmap->GetTransparencyHint(&transparency) != Ok)
            {
                transparency = TransparencyUnknown;
            }
        }

        switch (transparency)
        {
        case TransparencyUnknown:
        case TransparencySimple:
        case TransparencyComplex:
        case TransparencyNearConstant:
            return FALSE;

        case TransparencyOpaque:
        case TransparencyNoAlpha:
            return TRUE;
        }

        ASSERT(FALSE);

        return FALSE;
    }

    BOOL Is01Bitmap() const
    {
       DpTransparency transparency;
       GpBitmap *bitmap = GetBitmap();

       if (bitmap == NULL)
       {
           return FALSE;
       }

       ASSERT(bitmap->IsValid());

       if (bitmap->GetTransparencyHint(&transparency) != Ok)
           return FALSE;

       switch (transparency)
       {
       case TransparencyUnknown:
       case TransparencyOpaque:
       case TransparencyNoAlpha:
       case TransparencyComplex:
       case TransparencyNearConstant:
           return FALSE;

       case TransparencySimple:
           return TRUE;
       }

       ASSERT(FALSE);

       return FALSE;
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE *MinAlpha, BYTE* MaxAlpha) const
    {
        DpTransparency transparency;
        GpBitmap *bitmap = GetBitmap();
 
        if (bitmap == NULL)
        {
            return FALSE;
        }
 
        ASSERT(bitmap->IsValid());
 
        return (bitmap->GetTransparencyFlags(&transparency,
                                             PixelFormat32bppPARGB,
                                             MinAlpha,
                                             MaxAlpha) == Ok) &&
                transparency == TransparencyNearConstant;
    }
    
    // See if this texture fill is really a picture fill
    BOOL IsPictureFill(
        const GpMatrix *    worldToDevice,
        const GpRect *      drawBounds
        ) const;

    // Determine if the brushes are equivalent

    virtual BOOL isEqual(const GpBrush * brush) const
    {
       // HACKHACK - To avoid a potentially large bitmap comparison,
       // treat all texture brushes as different...
       return FALSE;
    }

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

private:

    GpTexture(const GpTexture *brush);

    VOID InitializeBrush(
        GpImage* image,
        GpWrapMode wrapMode,
        const GpRectF* rect,
        const GpImageAttributes *imageAttributes=NULL);
    VOID InitializeBrushBitmap(
        GpBitmap* bitmap,
        GpWrapMode wrapMode,
        const GpRectF* rect,
        const GpImageAttributes *imageAttributes,
        BOOL useBitmap = FALSE  // use the bitmap instead of cloning it?
        );
    VOID DefaultBrush()
    {
        InitializeBrushBitmap(NULL, WrapModeTile, NULL, NULL);
    }

private:

    GpImageType     ImageType;
    GpImage *       Image;      // brush image
};


class GpGradientBrush : public GpElementaryBrush
{
public:
    virtual VOID GetColors(GpColor* colors) const = 0;
    virtual INT GetNumberOfColors()         const = 0;
    virtual BOOL UsesDefaultColorArray()    const = 0;
    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const = 0;

    virtual GpStatus SetBlend(
                const REAL* blendFactors,
                const REAL* blendPositions,
                INT count)
            {
                return NotImplemented;
            }

    // Determine if the brushes are equivalent
    virtual BOOL isEqual(const GpBrush * brush) const
    {
        if (GpElementaryBrush::IsEqual(brush))
        {
            const DpBrush * deviceBrush = brush->GetDeviceBrush();

            return deviceBrush->Rect.Equals(DeviceBrush.Rect);
        }
        else
        {
            return FALSE;
        }
    }

    virtual GpStatus BlendWithWhite()
    {
        return NotImplemented;
    }

    GpStatus SetSigmaBlend(REAL focus, REAL scale = 1.0f);

    GpStatus SetLinearBlend(REAL focus, REAL scale = 1.0f);

protected:

    GpGradientBrush()
    {
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
    }

    GpGradientBrush(
        const GpGradientBrush* brush
        ) : GpElementaryBrush(brush)
    {
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
    }

    GpStatus GetSigmaBlendArray(
        REAL focus,
        REAL scale,
        INT* count,
        REAL* blendFactors,
        REAL* blendPositions);

    GpStatus GetLinearBlendArray(
        REAL focus,
        REAL scale,
        INT* count,
        REAL* blendFactors,
        REAL* blendPositions);
};

//--------------------------------------------------------------------------
// Represent rectangular gradient brush object
//--------------------------------------------------------------------------

class GpRectGradient : public GpGradientBrush
{
friend class DpOutputGradientSpan;
friend class DpOutputOneDGradientSpan;
friend class DpOutputLinearGradientSpan;

public:

    // Constructors

    GpRectGradient(VOID)
    {
        DefaultBrush();
    }

    GpRectGradient(
        const GpRectF& rect,
        const GpColor* colors,
        GpWrapMode wrapMode = WrapModeTile)
    {
        InitializeBrush(rect, colors, wrapMode);
    }

    virtual GpBrush* Clone() const
    {
        return new GpRectGradient(this);
    }

    ~GpRectGradient()
    {
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendFactors[1]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.BlendPositions[1]);
        GpFree(DeviceBrush.PresetColors);
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    virtual GpStatus BlendWithWhite();
   
    // Get/set colors

    VOID GetColors(GpColor* colors) const
    {
        ASSERT(colors);

        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
        colors[2] = DeviceBrush.Colors[2];
        colors[3] = DeviceBrush.Colors[3];
    }

    VOID SetColors(const GpColor* colors)
    {
        ASSERT(colors);

        DeviceBrush.Colors[0] = colors[0];
        DeviceBrush.Colors[1] = colors[1];
        DeviceBrush.Colors[2] = colors[2];
        DeviceBrush.Colors[3] = colors[3];
        UpdateUid();
    }

    INT GetNumberOfColors() const {return 4;}
    BOOL UsesDefaultColorArray() const {return TRUE;}
    
    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    INT GetHorizontalBlendCount()
    {
        return DeviceBrush.BlendCounts[0];
    }

    GpStatus GetHorizontalBlend(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count
        );

    GpStatus SetHorizontalBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        );

    INT GetVerticalBlendCount()
    {
        return DeviceBrush.BlendCounts[1];
    }

    GpStatus GetVerticalBlend(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count
        );

    virtual GpStatus SetVerticalBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        );

    BOOL HasPresetColors() const
    {
        return DeviceBrush.UsesPresetColors;
    }

    // Check the opacity of this brush element.  It is opaque only if
    // ALL of the colors are opaque.

    BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        BOOL opaque =  ColorsOnly || DeviceBrush.Wrap != WrapModeClamp;

        if (HasPresetColors()) 
        {      
            INT i=0;
            while (opaque && (i < DeviceBrush.BlendCounts[0]))
            {
                opaque = opaque && GpColor(DeviceBrush.PresetColors[i]).IsOpaque();
                i++;
            }
        }
        else
        {
            opaque = opaque && 
                     DeviceBrush.Colors[0].IsOpaque() &&
                     DeviceBrush.Colors[1].IsOpaque() &&
                     DeviceBrush.Colors[2].IsOpaque() &&
                     DeviceBrush.Colors[3].IsOpaque();
        }

        return opaque;
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        if (HasPresetColors()) 
        {
            *MaxAlpha = GpColor(DeviceBrush.PresetColors[0]).GetAlpha();
            *MinAlpha = *MaxAlpha;
            
            for (INT i=1; i<DeviceBrush.BlendCounts[0]; i++)
            {
                *MaxAlpha = max(*MaxAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
                *MinAlpha = min(*MinAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
            }
        }
        else
        {
            *MinAlpha = min(min(DeviceBrush.Colors[0].GetAlpha(),
                               DeviceBrush.Colors[1].GetAlpha()),
                           min(DeviceBrush.Colors[2].GetAlpha(),
                               DeviceBrush.Colors[3].GetAlpha()));
            *MaxAlpha = max(max(DeviceBrush.Colors[0].GetAlpha(),
                               DeviceBrush.Colors[1].GetAlpha()),
                           max(DeviceBrush.Colors[2].GetAlpha(),
                               DeviceBrush.Colors[3].GetAlpha()));
        }
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

protected:

    GpRectGradient(const GpRectGradient* brush);

    VOID InitializeBrush(
        const GpRectF& rect,
        const GpColor* colors,
        GpWrapMode wrapMode
        )
    {
        DeviceBrush.Type = (BrushType) BrushTypeLinearGradient; // BrushRectGrad;
        DeviceBrush.Wrap = wrapMode;
        DeviceBrush.Rect = rect;
        DeviceBrush.UsesPresetColors = FALSE;

        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.PresetColors = NULL;

        if(!WrapModeIsValid(wrapMode) || rect.Width <= 0 || rect.Height <= 0)
        {
            SetValid(FALSE);
            return;
        }

        SetValid(TRUE);
        SetColors(colors);
    }

    VOID DefaultBrush(VOID)
    {
        DeviceBrush.Type = (BrushType) BrushTypeLinearGradient; //BrushRectGrad;
        DeviceBrush.Wrap = WrapModeTile;
        DeviceBrush.UsesPresetColors = FALSE;
        GpMemset(&DeviceBrush.Rect, 0, sizeof(Rect));

        GpColor color;   // NULL brush

        DeviceBrush.Colors[0] = color;
        DeviceBrush.Colors[1] = color;
        DeviceBrush.Colors[2] = color;
        DeviceBrush.Colors[3] = color;

        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.PresetColors = NULL;

        // Defaults used for GpLineGradient
        DeviceBrush.IsAngleScalable = FALSE;
        DeviceBrush.Points[0].X = DeviceBrush.Points[0].Y = 0;
        DeviceBrush.Points[1].X = DeviceBrush.Points[1].Y = 0;

        SetValid(FALSE);
    }

protected:

};


class GpLineGradient : public GpRectGradient
{
friend class DpOutputGradientSpan;
friend class DpOutputOneDGradientSpan;

public:

    // Constructors

    GpLineGradient(VOID)
    {
        DefaultBrush();
    }

    GpLineGradient(
        const GpPointF& point1,
        const GpPointF& point2,
        const GpColor& color1,
        const GpColor& color2,
        GpWrapMode wrapMode = WrapModeTile
        );

    GpLineGradient(
        const GpRectF& rect,
        const GpColor& color1,
        const GpColor& color2,
        LinearGradientMode mode,
        GpWrapMode wrapMode = WrapModeTile
        );

    GpLineGradient(
        const GpRectF& rect,
        const GpColor& color1,
        const GpColor& color2,
        REAL angle,
        BOOL isAngleScalable = FALSE,
        GpWrapMode wrapMode = WrapModeTile
        );

    GpLineGradient(
        const GpRectF& rect,
        const GpColor* colors,
        GpWrapMode wrapMode = WrapModeTile)
        :GpRectGradient(rect, colors, wrapMode)
    {
    }

    GpBrush* Clone() const
    {
        return new GpLineGradient(this);
    }

    virtual GpStatus BlendWithWhite();

    // Note: ChangeLinePoints works dramatically differently than SetLinePoints.
    //       ChangeLinePoints is more like the constructor that takes points.
    GpStatus
    GpLineGradient::ChangeLinePoints(
        const GpPointF&     point1,
        const GpPointF&     point2,
        BOOL                isAngleScalable
        );

    GpStatus SetLinePoints(const GpPointF& point1, const GpPointF& point2);
    GpStatus GetLinePoints(GpPointF* points);

    VOID SetLineColors(const GpColor& color1, const GpColor& color2)
    {
        DeviceBrush.Colors[0] = color1;
        DeviceBrush.Colors[1] = color2;
        DeviceBrush.Colors[2] = color1;
        DeviceBrush.Colors[3] = color2;
        UpdateUid();
    }

    VOID GetLineColors(GpColor* colors)
    {
        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
    }

    // Get/set blend factors
    //
    // If the blendFactors.length = 1, then it's treated
    // as the falloff parameter. Otherwise, it's the array
    // of blend factors.

    INT GetBlendCount()
    {
        return GetHorizontalBlendCount();
    }

    GpStatus GetBlend(REAL* blendFactors, REAL* blendPositions, INT count)
    {
        return GetHorizontalBlend(blendFactors, blendPositions, count);
    }

    GpStatus SetBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        )
    {
        return SetHorizontalBlend(blendFactors, blendPositions, count);
    }

    // Setting Vertical Blend factor is not allowed.

    GpStatus SetVerticalBlend(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count
        )
    {
        ASSERT(0);
        return GenericError;
    }

    // Get/set preset blend-factors

    INT GetPresetBlendCount();

    GpStatus GetPresetBlend(
                GpColor* blendColors,
                REAL* blendPositions,
                INT count);

    GpStatus SetPresetBlend(
                const GpColor* blendColors,
                const REAL* blendPositions,
                INT count);

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        GpMatrix m;

        GpMatrix::MultiplyMatrix(m, DeviceBrush.Xform, *matrix);

        if (m.IsTranslateScale())
        {
            return GradientTypeVertical;
        }
        else if (REALABS(m.GetM11()) < CPLX_EPSILON &&
                 REALABS(m.GetM12()) >= CPLX_EPSILON &&
                 REALABS(m.GetM21()) >= CPLX_EPSILON &&
                 REALABS(m.GetM22()) < CPLX_EPSILON)
        {
            return GradientTypeHorizontal;
        }
        else
        {
            return GradientTypeDiagonal;
        }
    }

protected:

    GpLineGradient(const GpLineGradient* brush);

    GpStatus SetLineGradient(
        const GpPointF& point1,
        const GpPointF& point2,
        const GpRectF& rect,
        const GpColor& color1,
        const GpColor& color2,
        REAL angle,
        BOOL isAngleScalable = FALSE,
        GpWrapMode wrapMode = WrapModeTile
        );
};

//--------------------------------------------------------------------------
// Represent radial gradient brush object
//--------------------------------------------------------------------------
#if 0

class GpRadialGradient : public GpGradientBrush
{
friend class DpOutputGradientSpan;
friend class DpOutputOneDGradientSpan;

public:

    // Constructors

    GpRadialGradient(VOID)
    {
        DefaultBrush();
    }

    GpRadialGradient(
        const GpRectF& rect,
        const GpColor& centerColor,
        const GpColor& boundaryColor,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        InitializeBrush(rect, centerColor, boundaryColor, wrapMode);
    }

    GpBrush* Clone() const
    {
        return new GpRadialGradient(this);
    }

    ~GpRadialGradient()
    {
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.PresetColors);
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Get/set color attributes

    VOID SetCenterColor(const GpColor& color)
    {
        DeviceBrush.Colors[0] = color;
        UpdateUid();
    }

    VOID SetBoundaryColor(const GpColor& color)
    {
        DeviceBrush.Colors[1] = color;
        UpdateUid();
    }

    GpColor GetCenterColor() const
    {
        return DeviceBrush.Colors[0];
    }

    GpColor GetBoundaryColor() const
    {
        return DeviceBrush.Colors[1];
    }

    VOID GetColors(GpColor* colors) const
    {
        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
    }

    INT GetNumberOfColors() const {return 2;}
    BOOL UsesDefaultColorArray() const {return TRUE;}

    // Get/set falloff / blend-factors

    INT GetBlendCount()
    {
        return DeviceBrush.BlendCounts[0];
    }

    GpStatus GetBlend(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend(
        const REAL* blendFactors,
        const REAL* blendPosition,
        INT count
        );

    // Get/set preset blend-factors

    BOOL HasPresetColors() const
    {
        return DeviceBrush.UsesPresetColors;
    }

    INT GetPresetBlendCount() const;

    GpStatus GetPresetBlend(
                GpColor* blendColors,
                REAL* blendPositions,
                INT count) const;

    GpStatus SetPresetBlend(
                const GpColor* blendColors,
                const REAL* blendPositions,
                INT count);

    // Check the opacity of this brush element.

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This gradient brush is opaque only if
        // all the colors are opaque and wrap mode is not WrapModeClamp.
        // In case of WrapModeClamp mode, we need alpha channel to do
        // clipping outside of the oval.
        return (DeviceBrush.Colors[0].IsOpaque() &&
                DeviceBrush.Colors[1].IsOpaque() &&
                (ColorsOnly || DeviceBrush.Wrap != WrapModeClamp));
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = min(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MaxAlpha = max(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

private:

    GpRadialGradient(const GpRadialGradient *brush);

    VOID
    InitializeBrush(
        const GpRectF& rect,
        const GpColor& centerColor,
        const GpColor& boundaryColor,
        GpWrapMode wrapMode
        )
    {
        DeviceBrush.Type = (BrushType)-1; //BrushRadialGrad;
        DeviceBrush.Wrap = wrapMode;
        DeviceBrush.Rect = rect;
        DeviceBrush.UsesPresetColors = FALSE;

        DeviceBrush.Colors[0] = centerColor;
        DeviceBrush.Colors[1] = boundaryColor;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.PresetColors = NULL;

        SetValid(WrapModeIsValid(wrapMode) && rect.Width > 0 && rect.Height > 0);
    }

    VOID DefaultBrush(VOID)
    {
        DeviceBrush.Type = (BrushType)-1; //BrushRadialGrad;
        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));
        DeviceBrush.Wrap = WrapModeTile;
        DeviceBrush.UsesPresetColors = FALSE;
        GpColor color(255, 255, 255);   // Opaque white
        DeviceBrush.Colors[0] = color;
        DeviceBrush.Colors[1] = color;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.PresetColors = NULL;
        SetValid(FALSE);
    }

};
#endif

//--------------------------------------------------------------------------
// Represent triangle gradient brush object
//--------------------------------------------------------------------------
#if 0
class GpTriangleGradient : public GpGradientBrush
{
friend class DpOutputTriangleGradientSpan;

public:

    // Constructors

    GpTriangleGradient(VOID)
    {
        DefaultBrush();
    }

    GpTriangleGradient(
        const GpPointF* points,
        const GpColor* colors,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        InitializeBrush(
            points,
            colors,
            wrapMode);
    }

    GpBrush* Clone() const
    {
        return new GpTriangleGradient(this);
    }

    ~GpTriangleGradient()
    {
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendFactors[1]);
        GpFree(DeviceBrush.BlendFactors[2]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.BlendPositions[1]);
        GpFree(DeviceBrush.BlendPositions[2]);
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Get/set colors

    VOID GetColors(GpColor* colors) const
    {
        colors[0] = DeviceBrush.Colors[0];
        colors[1] = DeviceBrush.Colors[1];
        colors[2] = DeviceBrush.Colors[2];
    }

    VOID SetColors(const GpColor* colors)
    {
        DeviceBrush.Colors[0] = colors[0];
        DeviceBrush.Colors[1] = colors[1];
        DeviceBrush.Colors[2] = colors[2];
        UpdateUid();
    }

    // Get/set triangle

    VOID GetTriangle(GpPointF* points) const
    {
        points[0] = DeviceBrush.Points[0];
        points[1] = DeviceBrush.Points[1];
        points[2] = DeviceBrush.Points[2];
    }

    VOID SetTriangle(const GpPointF* points)
    {
        DeviceBrush.Points[0] = points[0];
        DeviceBrush.Points[1] = points[1];
        DeviceBrush.Points[2] = points[2];
        UpdateUid();
    }

    INT GetNumberOfColors() const {return 3;}
    BOOL UsesDefaultColorArray() const {return TRUE;}

    // Get/set falloff / blend-factors

    INT GetBlendCount0() const
    {
        return DeviceBrush.BlendCounts[0];
    }

    INT GetBlendCount1() const
    {
        return DeviceBrush.BlendCounts[1];
    }

    INT GetBlendCount2() const
    {
        return DeviceBrush.BlendCounts[2];
    }

    //!!! bhouse We really don't need all of these GetBlendX methods.  We
    //    should just implement a single GetBlend() which takes an index.
    //    With the change to the data layout, the argument for this method
    //    is stronger.  This should remove a bunch of redundant code.

    GpStatus GetBlend0(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend0(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count);

    GpStatus GetBlend1(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend1(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count);

    GpStatus GetBlend2(
        REAL* blendFactors,
        REAL* blendPositions,
        INT count) const;

    GpStatus SetBlend2(
        const REAL* blendFactors,
        const REAL* blendPositions,
        INT count);

    // Check the opacity of this brush element.

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This gradient brush is opaque only if
        // all the colors are opaque.
        // In case of WrapModeClamp mode, we need alpha channel to do
        // clipping outside of the triangle.
        return (DeviceBrush.Colors[0].IsOpaque() &&
                DeviceBrush.Colors[1].IsOpaque() &&
                DeviceBrush.Colors[2].IsOpaque() &&
                (ColorsOnly || DeviceBrush.Wrap != WrapModeClamp));
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = min(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MinAlpha = min(*MinAlpha,
                        DeviceBrush.Colors[2].GetAlpha());

        *MaxAlpha = max(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MaxAlpha = min(*MaxAlpha,
                        DeviceBrush.Colors[2].GetAlpha());
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const pRect *drawBounds=NULL);


protected:  // GDI+ Internal

    GpTriangleGradient(const GpTriangleGradient* brush);

    VOID
    InitializeBrush(
        const GpPointF* points,
        const GpColor* colors,
        GpWrapMode wrapMode
        )
    {
        DeviceBrush.Type = (BrushType)-1; //BrushTriangleGrad;
        DeviceBrush.Wrap = wrapMode;

        // Set the blending and fall off factors.

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.Falloffs[2] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendCounts[2] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendFactors[2] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.BlendPositions[2] = NULL;

        GpMemcpy(&DeviceBrush.Points[0],
                 points,
                 3*sizeof(GpPointF));

        GpMemcpy(&DeviceBrush.Colors[0],
                 colors,
                 3*sizeof(GpColor));

        // Get the boundary rectangle.

        REAL xmin, xmax, ymin, ymax;

        xmin = min(DeviceBrush.Points[0].X,
                   DeviceBrush.Points[1].X);
        xmax = max(DeviceBrush.Points[0].X,
                   DeviceBrush.Points[1].X);
        ymin = min(DeviceBrush.Points[0].Y,
                   DeviceBrush.Points[1].Y);
        ymax = max(DeviceBrush.Points[0].Y,
                   DeviceBrush.Points[1].Y);
        xmin = min(xmin, DeviceBrush.Points[2].X);
        xmax = max(xmax, DeviceBrush.Points[2].X);
        ymin = min(ymin, DeviceBrush.Points[2].Y);
        ymax = max(ymax, DeviceBrush.Points[2].Y);
        DeviceBrush.Rect.X = xmin;
        DeviceBrush.Rect.Width = xmax - xmin;
        DeviceBrush.Rect.Y = ymin;
        DeviceBrush.Rect.Height = ymax - ymin;

        if(!WrapModeIsValid(wrapMode) ||
           DeviceBrush.Rect.Width <= 0 ||
           DeviceBrush.Rect.Height <= 0)
        {
            SetValid(FALSE);
            return;
        }
        SetValid(TRUE);
    }

    VOID DefaultBrush()
    {
        DeviceBrush.Type =  (BrushType)-1; //BrushTriangleGrad;
        GpMemset(&DeviceBrush.Points, 0, 3*sizeof(GpPointF));
        DeviceBrush.Wrap = WrapModeClamp;

        GpColor color(255, 255, 255);   // Opaque white
        DeviceBrush.Colors[0] = color;
        DeviceBrush.Colors[1] = color;
        DeviceBrush.Colors[2] = color;

        GpMemset(&DeviceBrush.Rect, 0, sizeof(DeviceBrush.Rect));

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.Falloffs[1] = 1;
        DeviceBrush.Falloffs[2] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendCounts[1] = 1;
        DeviceBrush.BlendCounts[2] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendFactors[1] = NULL;
        DeviceBrush.BlendFactors[2] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.BlendPositions[1] = NULL;
        DeviceBrush.BlendPositions[2] = NULL;

        SetValid(FALSE);
    }


};
#endif

//--------------------------------------------------------------------------
// Represent polygon gradient brush object
//--------------------------------------------------------------------------

class GpPathGradient : public GpGradientBrush
{
friend class DpOutputPathGradientSpan;
friend class DpOutputOneDPathGradientSpan;

public:

    // Constructors

    GpPathGradient()
    {
        DefaultBrush();
    }

    GpPathGradient(
        const GpPointF* points,
        INT count,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        InitializeBrush(
            points,
            count,
            wrapMode);
    }

    GpPathGradient(
        const GpPath* path,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        DefaultBrush();
        DeviceBrush.Wrap = wrapMode;
        if(path)
        {
            DeviceBrush.Path = new GpPath((GpPath*) path);
            PrepareBrush();
        }
        else
            DeviceBrush.Path = NULL;
    }

    BOOL IsRectangle() const;

    GpBrush* Clone() const
    {
        return new GpPathGradient(this);
    }

    ~GpPathGradient()
    {
        if(DeviceBrush.Path)
            delete DeviceBrush.Path;
        else
            GpFree(DeviceBrush.PointsPtr);

        GpFree(DeviceBrush.ColorsPtr);
        GpFree(DeviceBrush.BlendFactors[0]);
        GpFree(DeviceBrush.BlendPositions[0]);
        GpFree(DeviceBrush.PresetColors);

        if(MorphedBrush)
            delete MorphedBrush;
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    virtual GpStatus BlendWithWhite();

    // Get/set colors

    VOID GetCenterColor(GpColor* color) const
    {
        if(color)
            *color = DeviceBrush.Colors[0];
    }

    VOID SetCenterColor(const GpColor& color)
    {
        DeviceBrush.Colors[0] = color;
        UpdateUid();
    }

    GpStatus GetSurroundColor(GpColor* color, INT index) const
    {
        if(color && index >= 0 && index < DeviceBrush.Count)
        {
            if(DeviceBrush.OneSurroundColor)
                *color = DeviceBrush.ColorsPtr[0];
            else
                *color = DeviceBrush.ColorsPtr[index];
            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus SetSurroundColor(GpColor& color, INT index);
    GpStatus SetSurroundColors(const GpColor* colors);

    GpStatus GetSurroundColors(GpColor* colors) const
    {
        GpStatus status = InvalidParameter;

        if(IsValid() && colors) {
            GpMemcpy(colors,
                     DeviceBrush.ColorsPtr,
                     DeviceBrush.Count*sizeof(GpColor));
            status = Ok;
        }

        return status;
    }

    // Get/set polygon

    GpStatus GetPolygon(GpPointF* points)
    {
        GpStatus status = InvalidParameter;

        ASSERT(DeviceBrush.Count > 0);

        if(IsValid() && points && DeviceBrush.Count > 0)
        {
            GpMemcpy(points,
                     DeviceBrush.PointsPtr,
                     DeviceBrush.Count*sizeof(GpPointF));
            status = Ok;
        }

        return status;
    }

    GpStatus SetPolygon(const GpPointF* points)
    {
        GpStatus status = InvalidParameter;

        ASSERT(DeviceBrush.Count > 0);

        if(IsValid() && points && DeviceBrush.Count > 0)
        {
            GpMemcpy(DeviceBrush.PointsPtr,
                     points,
                     DeviceBrush.Count*sizeof(GpPointF));

            UpdateUid();
            status = Ok;
        }

        return status;
    }

    GpStatus GetPoint(GpPointF* point, INT index) const
    {
        if(point && index >= 0 && index < DeviceBrush.Count)
        {
            *point = DeviceBrush.PointsPtr[index];
            return Ok;
        }
        else
            return GenericError;
    }

    GpStatus SetPoint(GpPointF& point, INT index)
    {
        if(index >= 0 && index < DeviceBrush.Count)
        {
            DeviceBrush.PointsPtr[index] = point;
            UpdateUid();
            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus GetCenterPoint(GpPointF* point) const
    {
        if(point)
        {
            *point = DeviceBrush.Points[0];
            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus SetCenterPoint(const GpPointF& point)
    {
        DeviceBrush.Points[0] = point;
        UpdateUid();
        return Ok;
    }

    GpStatus GetInflationFactor(REAL* inflation) const
    {
        if (inflation)
        {
            *inflation = InflationFactor;
            return Ok;
        }
        else
        {
            return InvalidParameter;
        }
    }
    
    GpStatus SetInflationFactor(REAL inflation)
    {
        InflationFactor = inflation;
        UpdateUid();
        return Ok;
    }

    GpStatus GetFocusScales(REAL* xScale, REAL* yScale)
    {
        if(xScale && yScale)
        {
            *xScale = DeviceBrush.FocusScaleX;
            *yScale = DeviceBrush.FocusScaleY;

            return Ok;
        }
        else
            return InvalidParameter;
    }

    GpStatus SetFocusScales(REAL xScale, REAL yScale)
    {
        DeviceBrush.FocusScaleX = xScale;
        DeviceBrush.FocusScaleY = yScale;

        UpdateUid();
        return Ok;
    }

    // Number of Surround Points and Colors.

    INT GetNumberOfPoints() const {return DeviceBrush.Count;}
    INT GetNumberOfColors() const {return DeviceBrush.Count;}
    BOOL UsesDefaultColorArray() const {return FALSE;}    // Don't use
                                                    // the default array.

    VOID GetColors(GpColor* colors) const // Implement a vurtual function.
    {
        GetSurroundColors(colors);
    }

    // Get/set falloff / blend-factors

    BOOL HasPresetColors() const
    {
        return DeviceBrush.UsesPresetColors;
    }

    INT GetBlendCount() const
    {
        return DeviceBrush.BlendCounts[0];
    }

    GpStatus GetBlend(REAL* blendFactors, REAL* blendPositions, INT count) const;
    GpStatus SetBlend(const REAL* blendFactors,
                       const REAL* blendPositions, INT count);

    // Get/set preset blend-factors

    INT GetPresetBlendCount() const;

    GpStatus GetPresetBlend(
                GpColor* blendColors,
                REAL* blendPositions,
                INT count) const;

    GpStatus SetPresetBlend(
                const GpColor* blendColors,
                const REAL* blendPositions,
                INT count);


    // Check if the Path Gradient is rectangular.
    BOOL IsRectangular() const
    {
        const GpPointF *points;
        INT count;
        
        if (DeviceBrush.Path != NULL) 
        {
            return DeviceBrush.Path->IsRectangular();
        }
        else
        {
            count = DeviceBrush.Count;
            points = DeviceBrush.PointsPtr;
        }

        if (count > 0 && points != NULL) 
        {
            for (INT i=0; i<count; i++) 
            {
                INT j = (i+1) % count;

                if (REALABS(points[i].X-points[j].X) > REAL_EPSILON &&
                    REALABS(points[i].Y-points[j].Y) > REAL_EPSILON) 
                {
                    // Points are not at 90 degree angles, not rectangular.
                    return FALSE;
                }
            }

            return TRUE;
        }

        return FALSE;
    }

    // Check the opacity of this brush element.

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This gradient brush is opaque only if
        // all the colors are opaque (including the center color
        // which is DeviceBrush.Colors[0]).
        // In case of WrapModeClamp mode, we need alpha channel to do
        // clipping outside of the polygon.

        BOOL test;

        if(ColorsOnly || DeviceBrush.Wrap != WrapModeClamp)
        {
            test = (ColorsOnly || IsRectangle()) &&
                   DeviceBrush.Colors[0].IsOpaque();
            INT i = 0;
            INT count = DeviceBrush.UsesPresetColors ? DeviceBrush.BlendCounts[0] : DeviceBrush.Count;

            while(i < count && test)
            {
                if (DeviceBrush.UsesPresetColors)
                {
                    test = (DeviceBrush.PresetColors[i] & Color::AlphaMask) == 
                           Color::AlphaMask;
                }
                else
                {
                    test = DeviceBrush.ColorsPtr[i].IsOpaque();
                }
                i++;
            }
        }
        else
            test = FALSE;

        return test;
    }

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        if (DeviceBrush.UsesPresetColors) 
        {
            ARGB color1 = DeviceBrush.Colors[0].GetValue();         // Center color
            ARGB color2 = DeviceBrush.PresetColors[0];   // 1st Preset Color

            for (INT i=1; i<DeviceBrush.BlendCounts[0]; i++)
            {
                ARGB color = DeviceBrush.PresetColors[i];

                if ((color1 != color) && (color2 != color))
                {
                    if (color1 == color2)
                    {
                        color2 = color;
                    }
                    else
                    {
                        return GradientTypePathComplex;
                    }
                }
            }
        }
        else
        {
            if (DeviceBrush.OneSurroundColor || DeviceBrush.Count <= 2)
            {
                return GradientTypePathTwoStep;
            }

            GpColor *color1 = &(DeviceBrush.ColorsPtr[0]);
            GpColor *color2 = &(DeviceBrush.ColorsPtr[1]);

            for (INT i=2; i<DeviceBrush.Count; i++)
            {
                GpColor *color = &(DeviceBrush.ColorsPtr[i]);

                if (!color1->IsEqual(*color) && !color2->IsEqual(*color))
                {
                    if (color1->IsEqual(*color2))
                    {
                        color2 = color;
                    }
                    else
                    {
                        return GradientTypePathComplex;
                    }
                }
            }
        }

        return GradientTypePathTwoStep;
    }

    virtual BOOL IsSolid() const
    {
        //This is not optimal but is such a rare case that it probably 
        //shouldn't be fixed as long as we keep the defination of IsSolid 
        //that we are currently using.  See comment at GpBrush::IsSolid for 
        //definition.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        if (HasPresetColors()) 
        {
            *MaxAlpha = DeviceBrush.Colors[0].GetAlpha();
            *MinAlpha = *MaxAlpha;
            
            for (INT i=0; i<DeviceBrush.BlendCounts[0]; i++)
            {
                *MaxAlpha = max(*MaxAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
                *MinAlpha = min(*MinAlpha, GpColor(DeviceBrush.PresetColors[i]).GetAlpha());
            }
        }
        else
        {
            if (DeviceBrush.OneSurroundColor)
            {
                *MaxAlpha = max((DeviceBrush.ColorsPtr[0]).GetAlpha(), // surround
                                (DeviceBrush.Colors[0]).GetAlpha()); // center
                *MinAlpha = min((DeviceBrush.ColorsPtr[0]).GetAlpha(), // surround
                                (DeviceBrush.Colors[0]).GetAlpha()); // center            }
            }
            else
            {
                *MaxAlpha = DeviceBrush.Colors[0].GetAlpha();
                *MinAlpha = *MaxAlpha;
                
                for (INT i=0; i<DeviceBrush.Count; i++)
                {
                    *MaxAlpha = max(*MaxAlpha, DeviceBrush.ColorsPtr[i].GetAlpha());
                    *MinAlpha = min(*MinAlpha, DeviceBrush.ColorsPtr[i].GetAlpha());
                }
            }
        }
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

protected:  // GDI+ Internal

    GpPathGradient(const GpPathGradient* brush);

    VOID
    PrepareBrush();

    VOID
    InitializeBrush(
        const GpPointF* points,
        INT count,
        GpWrapMode wrapMode = WrapModeClamp
        )
    {
        DeviceBrush.Type = BrushTypePathGradient;
        DeviceBrush.Wrap = wrapMode;
        SetValid(FALSE);
        DeviceBrush.OneSurroundColor = TRUE;
        DeviceBrush.UsesPresetColors = FALSE;

        MorphedBrush = NULL;
        DeviceBrush.Path = NULL;
        DeviceBrush.PointsPtr = NULL;
        DeviceBrush.ColorsPtr = NULL;

        // Set the blending and fall off factors.

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.PresetColors = NULL;

        if(!WrapModeIsValid(wrapMode) || count <= 0 || points == NULL)
        {
            DeviceBrush.Count = 0;
            return;
        }

        DeviceBrush.Count = count;

        // Get the boundary rectangle.

        REAL xmin, xmax, ymin, ymax, x0, y0;

        x0 = xmin = xmax = points[0].X;
        y0 = ymin = ymax = points[0].Y;

        for(INT i = 1; i < DeviceBrush.Count; i++)
        {
            x0 += points[i].X;
            y0 += points[i].Y;
            xmin = min(xmin, points[i].X);
            xmax = max(xmax, points[i].X);
            ymin = min(ymin, points[i].Y);
            ymax = max(ymax, points[i].Y);
        }

        DeviceBrush.Rect.X = xmin;
        DeviceBrush.Rect.Width = xmax - xmin;
        DeviceBrush.Rect.Y = ymin;
        DeviceBrush.Rect.Height = ymax - ymin;

        if(DeviceBrush.Rect.Width <= 0 ||
           DeviceBrush.Rect.Height <= 0)
            return;

        // The default center point is the center of gravity.

        DeviceBrush.Points[0].X = x0 / DeviceBrush.Count;
        DeviceBrush.Points[0].Y = y0 / DeviceBrush.Count;

        DeviceBrush.PointsPtr =
            (GpPointF*) GpMalloc(DeviceBrush.Count *
                                 sizeof(GpPointF));

        if(!DeviceBrush.PointsPtr)
        {
            DeviceBrush.Count = 0;
            return;
        }

        DeviceBrush.ColorsPtr =
            (GpColor*) GpMalloc(DeviceBrush.Count *
                                sizeof(GpColor));

        if(!DeviceBrush.ColorsPtr)
        {
            GpFree(DeviceBrush.PointsPtr);
            DeviceBrush.PointsPtr = NULL;
            DeviceBrush.Count = 0;
            return;
        }

        // If this comes so far, both Points and Colors are valid.

        GpMemcpy(&DeviceBrush.PointsPtr[0],
                 points,
                 DeviceBrush.Count*sizeof(GpPointF));

        GpMemset(&DeviceBrush.ColorsPtr[0],
                 255,
                 DeviceBrush.Count*sizeof(GpColor));

        DeviceBrush.FocusScaleX = 0;
        DeviceBrush.FocusScaleY = 0;

        InflationFactor = 0.0f;

        SetValid(TRUE);
    }

    VOID DefaultBrush(VOID)
    {
        DeviceBrush.Type = BrushTypePathGradient;
        SetValid(FALSE);
        DeviceBrush.OneSurroundColor = TRUE;
        DeviceBrush.Wrap = WrapModeClamp;
        DeviceBrush.UsesPresetColors = FALSE;

        DeviceBrush.Path = NULL;
        DeviceBrush.PointsPtr = NULL;
        DeviceBrush.ColorsPtr = 0;
        DeviceBrush.Count = 0;

        // The default center point is the center of gravity.

        GpMemset(&DeviceBrush.Rect, 0, sizeof(GpRectF));
        GpMemset(&DeviceBrush.Points, 0, sizeof(GpPointF));
        GpMemset(&DeviceBrush.Colors, 255, sizeof(GpColor));

        DeviceBrush.FocusScaleX = 0;
        DeviceBrush.FocusScaleY = 0;

        // Set the blending and fall off factors.

        DeviceBrush.Falloffs[0] = 1;
        DeviceBrush.BlendCounts[0] = 1;
        DeviceBrush.BlendFactors[0] = NULL;
        DeviceBrush.BlendPositions[0] = NULL;
        DeviceBrush.PresetColors = NULL;

        MorphedBrush = NULL;
        InflationFactor = 0.0f;
    }

    // This does not update the Uid of the object because it's defined as const
    // But the object doesn't really change anyway
    GpStatus Flatten(GpMatrix* matrix) const;

    virtual
    const DpPath *
    GetOutlinePath(
        VOID
        ) const
    {
        return DeviceBrush.Path;
    }

protected:
    GpBrush* MorphedBrush;
    DynByteArray FlattenTypes;
    DynPointFArray FlattenPoints;
    REAL InflationFactor;
};

//--------------------------------------------------------------------------
// Represent hatch brush object
//--------------------------------------------------------------------------

class GpHatch : public GpBrush
{
friend class DpOutputHatchSpan;

public:

    // Constructors

    GpHatch(VOID)
    {
        DefaultBrush();
    }

    GpHatch(GpHatchStyle hatchStyle, const GpColor& foreColor)
    {
        InitializeBrush(hatchStyle, foreColor, 0);
    }

    GpHatch(
        GpHatchStyle hatchStyle,
        const GpColor& foreColor,
        const GpColor& backColor)
    {
        InitializeBrush(hatchStyle, foreColor, backColor);
    }

    GpBrush* Clone() const
    {
        return new GpHatch(this);
    }

    ~GpHatch() {}

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    virtual BOOL IsOpaque(BOOL ColorsOnly = FALSE) const
    {
        // This brush is opaque only if
        // all the colors are opaque.
        return (DeviceBrush.Colors[0].IsOpaque() &&
                DeviceBrush.Colors[1].IsOpaque());
    }

    virtual BOOL IsSolid() const
    {
        //This may have to change if we change the defination of IsSolid.  
        //See comment at GpBrush::IsSolid() for more info.
        return FALSE;
    }

    virtual BOOL IsNearConstant(BYTE* MinAlpha, BYTE* MaxAlpha) const
    {
        *MinAlpha = min(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        *MaxAlpha = max(DeviceBrush.Colors[0].GetAlpha(),
                        DeviceBrush.Colors[1].GetAlpha());
        
        return (*MaxAlpha - *MinAlpha < NEARCONSTANTALPHA);
    }
    
    virtual BOOL IsEqual(const GpBrush * brush) const;

    virtual DpOutputSpan* CreateOutputSpan(
                DpScanBuffer *  scan,
                DpContext *context,
                const GpRect *drawBounds=NULL);

    virtual GpSpecialGradientType
        GetSpecialGradientType(const GpMatrix* matrix) const
    {
        return GradientTypeNotSpecial;
    }

    GpHatchStyle GetHatchStyle()
    {
        return DeviceBrush.Style;
    }

    GpStatus GetForegroundColor(GpColor* color)
    {
        ASSERT(color != NULL);
        *color = DeviceBrush.Colors[0];

        return Ok;
    }

    GpStatus GetBackgroundColor(GpColor* color)
    {
        ASSERT(color != NULL);
        *color = DeviceBrush.Colors[1];

        return Ok;
    }

    VOID SetStretchFactor(INT stretch)
    {
        StretchFactor = stretch;
    }

private:

    GpHatch(const GpHatch* brush);

    VOID
    InitializeBrush(
        GpHatchStyle hatchStyle,
        const GpColor& foreColor,
        const GpColor& backColor
        )
    {
        DeviceBrush.Type = BrushTypeHatchFill;
        DeviceBrush.Style = hatchStyle;
        DeviceBrush.Colors[0] = foreColor;
        DeviceBrush.Colors[1] = backColor;
        StretchFactor = 1;
        InitializeData();
        SetValid(TRUE);
    }

    VOID DefaultBrush()
    {
        InitializeBrush(HatchStyle50Percent,
                        GpColor(Color::Black),
                        GpColor(Color::White));
    }

    VOID
    InitializeData();

    INT StretchFactor;
};

#endif _BRUSH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\cachedbitmap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   <an unabbreviated name for the module (not the filename)>
*
* Abstract:
*
*   <Description of what this module does>
*
* Notes:
*
*   <optional>
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

/**************************************************************************
*
* Function Description:
*
*   This function renders the GpCachedBitmap on the GpGraphics.
*
* Arguments:
*  
*   inputCachedBitmap - the input data.
*   x, y              - destination offset.
*
* Return Value:
*
*   Returns Ok if successful
*   Returs WrongState if the GpGraphics and GpCachedBitmap have
*   different pixel formats.
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/
GpStatus 
GpGraphics::DrvDrawCachedBitmap(
    GpCachedBitmap *inputCachedBitmap,
    INT x, 
    INT y
)
{
    // Internally we must be called with a valid object.
    
    ASSERT(inputCachedBitmap->IsValid());
    
    // Don't attempt to record a cached bitmap to a metafile
    if (IsRecording())
        return WrongState;

    // First grab the device lock so that we can protect all the
    // non-reentrant code in the DpScanBuffer class.

    Devlock devlock(Device);

    // Check the world transform
    
    if(!(Context->WorldToDevice.IsTranslate()))
    {
        // There is a complex transform selected into the graphics.
        // fail the call.
        return WrongState;
    }

    // Can't check the pixel format here because of the possibility of
    // MultiMon - we'd be checking against the meta device surface
    // -- although maybe that's the correct behaviour.    
    
    // Set up the world to device translation offset.
    
    INT xOffset = x+GpRound(Context->WorldToDevice.GetDx());
    INT yOffset = y+GpRound(Context->WorldToDevice.GetDy());

    // Store the rendering origin so we can restore it later.
    
    INT renderX, renderY;
    GetRenderingOrigin(&renderX, &renderY);
    
    // Set the rendering origin to the origin of the CachedBitmap drawing
    // so that the dither matrix offset of the semi-transparent pixels 
    // matches that of the already dithered (stored) native pixels.

    SetRenderingOrigin(xOffset, yOffset);

    // Call the driver to draw the cached bitmap.
    // Note: the driver does not respect the world to device transform
    // it expects device coordinates for this API.

    GpStatus status = Driver->DrawCachedBitmap(
        Context,
        &inputCachedBitmap->DeviceCachedBitmap,
        Surface,
        xOffset, 
        yOffset
    );

    // Restore the rendering origin.

    SetRenderingOrigin(renderX, renderY);

    return status;    
}

/**************************************************************************
*
* Function Description:
*
*   Constructs the GpCachedBitmap based on the pixel format and
*   rendering quality derived from the GpGraphics and the bits
*   from the GpBitmap.
*
* Arguments:
*
*   graphics - input graphics to be compatible with
*   bitmap   - data to be cached.
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/


enum TransparencyState {
    Transparent,
    SemiTransparent,
    Opaque
};

inline TransparencyState GetTransparency(ARGB pixel)
{
    if((pixel & 0xff000000) == 0xff000000) {return Opaque;}
    if((pixel & 0xff000000) == 0x00000000) {return Transparent;}
    return SemiTransparent;
}

// Intermetiate record used to parse the transparency information
// in the bitmap.

struct ScanRecordTemp
{
    // Pointer to the start and end of the run.
    
    ARGB *pStart;
    ARGB *pEnd;    // exclusive end.

    // Transparency

    TransparencyState tsTransparent;

    // Position

    INT x, y;        
    INT width;    // in pixels
};

// Simple macro to make the failure cases easier to read.

#define FAIL() \
        SetValid(FALSE); \
        return

GpCachedBitmap::GpCachedBitmap(GpBitmap *bitmap, GpGraphics *graphics)
{
    BitmapData bmpDataSrc;

    // Lock the bits.
    // we need to convert the bits to the appropriate format.

    // Note - we're assuming that the knowledgeable user will be
    // initializing their CachedBitmap with a 32bppPARGB surface.
    // This is important for performance at creation time, because
    // the LockBits below can avoid a costly clone & convert format.

    if (bitmap == NULL ||
        !bitmap->IsValid() ||
        bitmap->LockBits(
            NULL,
            IMGLOCK_READ,
            PIXFMT_32BPP_PARGB,
            &bmpDataSrc
        ) 
        != Ok)
    {
        FAIL();
    }

    // copy the dimensions.

    DeviceCachedBitmap.Width = bmpDataSrc.Width;
    DeviceCachedBitmap.Height = bmpDataSrc.Height;

    // Create a dynamic array to store the transparency transition points.
    // The initial allocation size is based on an estimate of 3 
    // transition events per scanline. Overestimate.
    
    DynArray<ScanRecordTemp> RunData;

    RunData.ReserveSpace(4*DeviceCachedBitmap.Height);

    // Scan through the bits adding an item to the dynamic list every
    // time a new run would be required in the output - i.e. when the
    // transparency changes to one of opaque or semi-transparent.
    // Before the beginning of a scanline is considered to be transparent.
    // While scanning through the bits, keep a running total of the 
    // size of the final RLE bitmap - so we know how much space to allocate.

    // Size of the final RLE bitmap in bytes;
    
    // This is not actually a pointer to an EpScanRecord - it is simply
    // a mechanism to work out how big to allocate the buffer
       
    EpScanRecord *RLESize = (EpScanRecord *)0;

    // Pointer to the current position in the source.

    ARGB *src;
    ARGB *runStart;

    // Temporary ScanRecord used to accumulate the runs.

    ScanRecordTemp sctTmp;

    TransparencyState tsThisPixel;
    TransparencyState tsCurrentRun;


    DpBitmap *Surface = graphics->GetSurface();
    void *Buffers[5];

    // Create the blending buffers for the alpha blender.
    
    // !!! [asecchia] While we don't currently depend on this behaviour,
    // it seems like a bug that a graphics wrapped around a bitmap uses
    // the desktop display device and driver. This leads to weirdness 
    // if we try use GetScanBuffers to derive the pixel format of the 
    // destination. For example a graphics around a PixelFormat24bppRGB 
    // bitmap would return PixelFormat16bppRGB565 if the screen is in
    // 16bpp mode !?
    // However, the Buffers[] returned will be allocated as 64bpp buffers
    // and therefore will have the correct properties under all circumstances.
        
    if (!graphics->GetDriver()->Device->GetScanBuffers(
        Surface->Width, 
        NULL, 
        NULL, 
        NULL, 
        Buffers)
       )
    {
        FAIL();
    }

    // Compute the destination pixel format.
    
    PixelFormatID dstFormat = Surface->PixelFormat;
        
    if(dstFormat == PixelFormatUndefined) { FAIL(); }

    // The following destination formats are not supported.
    // In particular, no palettized modes are supported because
    // tracking the cached opaque data in native format across
    // palette changes would be a nightmare.
    // Instead we set the opaque format to be 32bppRGB and force
    // the EpAlphaBlender to do the work at render time - slower
    // but it will work.
    
    if( !EpAlphaBlender::IsSupportedPixelFormat(dstFormat) ||
        IsIndexedPixelFormat(dstFormat) ||
        
        // If the graphics is for a multi format device such as 
        // a multimon meta-screen.
        
        dstFormat == PixelFormatMulti
    )
    {
        // We don't want to silently fail if the input
        // is undefined.
        
        ASSERT(dstFormat != PixelFormatUndefined);
        
        // Opaque pixels - we don't support palettized modes
        // and some of the other weird ones

        dstFormat = PixelFormat32bppRGB;
    }

    // Size of a destination pixel in bytes.

    INT dstFormatSize = GetPixelFormatSize(dstFormat) >> 3;


    // Run through each scanline.

    for(INT y = 0; y < DeviceCachedBitmap.Height; y++)
    {
        // Point to the beginning of this scanline.

        src = reinterpret_cast<ARGB*>(
            reinterpret_cast<BYTE*>(bmpDataSrc.Scan0) + y * bmpDataSrc.Stride
        );

        // Start the run off with transparency.

        tsCurrentRun = Transparent;
        runStart = src;

        // Run through all the pixels in this scanline.

        for(INT x = 0; x < DeviceCachedBitmap.Width; x++)
        {

            // Compute the transparency state for the current pixel.

            tsThisPixel = GetTransparency(*src);

            // If a transparency transition occurs, 

            if(tsThisPixel != tsCurrentRun)
            {
                // Close off the last transition and store a record if it wasn't
                // a transparent run.

                if(tsCurrentRun != Transparent)
                {
                    sctTmp.pStart = runStart;
                    sctTmp.pEnd = src;
                    sctTmp.tsTransparent = tsCurrentRun;
                    sctTmp.y = y;
                    
                    // src is in PixelFormat32bppPARGB so we can divide the 
                    // pointer difference by 4 to figure out the number of 
                    // pixels in this run.
                    
                    sctTmp.width = (INT)(((INT_PTR)src - (INT_PTR)runStart)/sizeof(ARGB));
                    sctTmp.x = x - sctTmp.width;

                    if(RunData.Add(sctTmp) != Ok) { FAIL(); }

                    // Add the size of the record

                    if (tsCurrentRun == SemiTransparent) 
                    {
                        // This is the semi-transparent case.

                        RLESize = EpScanRecord::CalculateNextScanRecord(
                            RLESize,
                            EpScanTypeBlend,
                            sctTmp.width,
                            sizeof(ARGB)
                        );
                    } 
                    else 
                    {
                        // This is the opaque case.
                        
                        ASSERT(tsCurrentRun == Opaque);

                        RLESize = EpScanRecord::CalculateNextScanRecord(
                            RLESize,
                            EpScanTypeOpaque,
                            sctTmp.width,
                            dstFormatSize
                        );
                    }
                }

                // Update the run tracking variables.

                runStart = src;
                tsCurrentRun = tsThisPixel;
            }

            // Look at the next pixel.

            src++;
        }

        // Close off the last run for this scanline (if it's not transparent).

        if(tsCurrentRun != Transparent)
        {
            sctTmp.pStart = runStart;
            sctTmp.pEnd = src;
            sctTmp.tsTransparent = tsCurrentRun;
            sctTmp.y = y;
            
            // Size of the source is 32bits (PARGB).
            
            sctTmp.width = (INT)(((INT_PTR)src - (INT_PTR)runStart)/sizeof(ARGB));
            sctTmp.x = x - sctTmp.width;
            if(RunData.Add(sctTmp)!=Ok) { FAIL(); }
            
            // Add the size of the record

            if (tsCurrentRun == SemiTransparent) 
            {
                // This is the semi-transparent case.

                RLESize = EpScanRecord::CalculateNextScanRecord(
                    RLESize,
                    EpScanTypeBlend,
                    sctTmp.width,
                    sizeof(ARGB)
                );
            } 
            else 
            {
                // This is the opaque case.
                
                ASSERT(tsCurrentRun == Opaque);

                RLESize = EpScanRecord::CalculateNextScanRecord(
                    RLESize,
                    EpScanTypeOpaque,
                    sctTmp.width,
                    dstFormatSize
                );
            }
        }        
    }

    ASSERT(RLESize >= 0);

    // Allocate space for the RLE bitmap.
    // This should be the exact size required for the RLE bitmap.
    // Add 8 bytes to handle the fact that GpMalloc may not return
    // a 64bit aligned allocation.

    void *RLEBits = GpMalloc((INT)(INT_PTR)(RLESize)+8);
    if(RLEBits == NULL) { FAIL(); }       // Out of memory.
    
    // QWORD-align the result
    
    EpScanRecord *recordStart = MAKE_QWORD_ALIGNED(EpScanRecord *, RLEBits);
    
    // Scan through the dynamic array and add each record to the RLE bitmap
    // followed by its bits (pixels).
    // For native format pixels (opaque) use the EpAlphaBlender to 
    // convert to native format.

    // Query for the number of records in the RunData

    INT nRecords = RunData.GetCount();

    EpScanRecord *rec = recordStart;
    ScanRecordTemp *pscTmp;

    // Store the rendering origin so we can modify it.
    // The graphics must be locked at the API.

    INT renderX, renderY;
    graphics->GetRenderingOrigin(&renderX, &renderY);

    // Set the rendering origin to the top left corner of the CachedBitmap
    // so that the dither pattern for the native pixels will match
    // the dither pattern for the semi-transparent pixels (rendered later
    // in DrawCachedBitmap).

    graphics->SetRenderingOrigin(0,0);


    // Make a 32bppPARGB->Native conversion blender.
    // This will be used for converting the 32bppPARGB
    // source data into the native pixel format (dstFormat)
    // of the destination.
    // For palettized modes, dstFormat is 32bppRGB

    EpAlphaBlender alphaBlender;
  
    alphaBlender.Initialize(
        EpScanTypeOpaque,
        dstFormat,
        PixelFormat32bppPARGB,
        graphics->Context,
        NULL,        
        Buffers,
        TRUE,
        FALSE,
        0
    );

    // For each record ...

    for(INT i=0; i<nRecords; i++)
    {
        // Make sure we don't overrun our buffer...

        ASSERT((INT_PTR)rec < (INT_PTR)recordStart + (INT_PTR)RLESize);

        // Copy the data into the destination record.

        pscTmp = &RunData[i];
        rec->X = pscTmp->x;
        rec->Y = pscTmp->y;
        rec->Width = rec->OrgWidth = pscTmp->width;
        
        // We should never store a transparent run.

        ASSERT(pscTmp->tsTransparent != Transparent);
        
        if(pscTmp->tsTransparent == Opaque)
        {
            // Use the native pixel format for the destination.

            rec->BlenderNum = 1;
            rec->ScanType = EpScanTypeOpaque;
            
            // Find the start of the new pixel run.
    
            VOID *dst = rec->GetColorBuffer(); 

            // Compute the number of bytes per pixel.

            INT pixelFormatSize = GetPixelFormatSize(dstFormat) >> 3;

            // This should perform a source over blend from 32bppPARGB
            // to the native format into the destination.

            // For CachedBitmaps, the dither origin is always the top 
            // left corner of the CachedBitmap (i.e. 0, 0).
            // In 8bpp we dither down while rendering and get the correct
            // origin at that time.

            alphaBlender.Blend(
                dst, 
                pscTmp->pStart, 
                pscTmp->width, 
                pscTmp->x, 
                pscTmp->y,
                NULL
            );
            
            // Increment position to the next record.

            rec = rec->NextScanRecord(pixelFormatSize);
        }
        else
        {
            rec->BlenderNum = 0;
            rec->ScanType = EpScanTypeBlend;

            // Find the start of the new pixel run.
    
            VOID *dst = rec->GetColorBuffer(); 
            
            // Semi-Transparent pixels are stored in 32bpp PARGB, so
            // we can simply copy the pixels.

            GpMemcpy(dst, pscTmp->pStart, pscTmp->width*sizeof(ARGB));
            
            // Increment position to the next record.

            rec = rec->NextScanRecord(sizeof(ARGB));
        }

    }

    // Restore the rendering origin.

    graphics->SetRenderingOrigin(renderX, renderY);

    // Finally store the pointer to the RLE bits in the DeviceCachedBitmap

    DeviceCachedBitmap.Bits = RLEBits;
    DeviceCachedBitmap.RecordStart = recordStart;
    DeviceCachedBitmap.RecordEnd = rec;
    DeviceCachedBitmap.OpaqueFormat = dstFormat;
    DeviceCachedBitmap.SemiTransparentFormat = PixelFormat32bppPARGB;

    bitmap->UnlockBits(&bmpDataSrc);
    
    // Everything is golden - set Valid to TRUE
    // all the error paths early out with Valid set to FALSE

    SetValid(TRUE);
}

#undef FAIL

GpCachedBitmap::~GpCachedBitmap()
{
    // throw away the cached bitmap storage.

    GpFree(DeviceCachedBitmap.Bits);
    
    SetValid(FALSE);    // so we don't use a deleted object
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\cachedbitmap.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   GpCachedBitmap object
*
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _CACHEDBITMAP_HPP
#define _CACHEDBITMAP_HPP

class GpCachedBitmap
{
    friend GpGraphics;
    
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    
    ObjectTag           Tag;    // Keep this as the 1st value in the object!
    
    GpLockable Lockable;

    DpCachedBitmap DeviceCachedBitmap;

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectCachedBitmap : ObjectTagInvalid;
    }

public:

    // constructor and destructor

    GpCachedBitmap(GpBitmap *bitmap, GpGraphics *graphics);
    virtual ~GpCachedBitmap();

    // 'getter' state retrieval

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpCachedBitmap, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectCachedBitmap) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid CachedBitmap");
        }
    #endif

        return (Tag == ObjectCachedBitmap);
    }

    void GetSize(Size *s)
    {
        // Get the width and height from the DeviceCachedBitmap.

        s->Width = DeviceCachedBitmap.Width;
        s->Height = DeviceCachedBitmap.Height;
    }

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\create.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Handle all the permutations of the creation and deletion of the
*   GpGraphics class.
*
* Revision History:
*
*   12/03/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "..\Render\HtTables.hpp"

#include "printer.hpp"
#include "winspool.h"
#include "winbase.h"

/**************************************************************************\
*
* Function Description:
*
*   Updates the draw bounds of the graphics. Resets the clipping.
*
* Arguments:
*
*   [IN] x, y, width, height - Specifies the client drawable boundaries
*
* History:
*
*   03/30/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID
GpGraphics::UpdateDrawBounds(
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    DpContext *context  = Context;

    // Set up the surface bounds and the clip regions:

    SurfaceBounds.X = x;
    SurfaceBounds.Y = y;
    SurfaceBounds.Width = width;
    SurfaceBounds.Height = height;

    WindowClip.Set(x, y, width, height);
    context->VisibleClip.Set(x, y, width, height);

    // ContainerClip always contains the clipping for the container,
    // intersected with the WindowClip.  Currently, the container is
    // infinite, so just set it to the WindowClip.
    context->ContainerClip.Set(x, y, width, height);

    context->AppClip.SetInfinite();
}

/**************************************************************************\
*
* Function Description:
*
*   Resets the graphics state to its defaults.
*
* Arguments:
*
*   [IN] x, y, width, height - Specifies the client drawable boundaries
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
GpGraphics::ResetState(
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    DpContext *context  = Context;

    context->CompositingMode    = CompositingModeSourceOver;
    context->CompositingQuality = CompositingQualityDefault;
    context->AntiAliasMode      = FALSE;
    context->TextRenderHint     = TextRenderingHintSystemDefault;
    context->TextContrast       = DEFAULT_TEXT_CONTRAST;
    context->FilterType         = InterpolationModeDefaultInternal;
    context->PixelOffset        = PixelOffsetModeDefault;
    context->InverseOk          = FALSE;
    context->WorldToPage.Reset();
    context->ContainerToDevice.Reset();
    this->SetPageTransform(UnitDisplay, 1.0f);  // updates the matrix

    UpdateDrawBounds(x, y, width, height);
}

/**************************************************************************\
*
* Function Description:
*
*   Get the drawing bounds of a DC. Only intended for use by
*   GpGraphics::GpGraphics(HWND, HDC).
*
* Arguments:
*
*   [IN]  hdc  - Specifies the DC
*   [OUT] rect - The returned client rectangle.
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   See bug #93012. We used to just call GetClipBox, convert to device
*   coordinates, then boost the rectangle by one pixel on each side to cover
*   rounding error. But this was causing AV's - we really do need the exact
*   client rectangle.
*
*   But we need good perf in common cases. So we do a two-step process
*   - check if the transform is such that there won't be rounding error
*   (and simply use GetClipBox if so).
*   Otherwise, save the DC, reset the transform, and then query.
*
*   I tried an alternative - calling LPtoDP on 3 points to infer the transform
*   (as we do in InheritAppClippingAndTransform).
*   But because of rounding, and made worse by
*   NT bug #133322 (in the old NT RAID), it's nearly impossible
*   to infer the transform unambiguously. The particularly bad case is
*   when the world-to-device transform is a shrink, but the scale factor
*   is very close to 1. We'd decide it was a one-to-one transform, but it
*   would be susceptible to bug #133322.
*
*   So, to round off this novel: We're using a much simpler approach,
*   which restricts the cases in which we can use the fast method, but
*   should be ok.
*
* Notes:
*
*   This should really be a member of DpContext (bug #98174).
*
* History:
*
*   03/28/2000 agodfrey
*       Created it.
*
\**************************************************************************/

#if 0   // not used
GpStatus
GpGraphics::GetDCDrawBounds(
    HDC hdc,
    RECT *rect
    )
{
    BOOL hackResetClipping = FALSE;

    // Check if the transform is translation-only. If it is, we can avoid the
    // expense of cleaning the DC. GetGraphicsMode and GetMapMode are both
    // handled in user mode on NT.

    if (   (GetGraphicsMode(hdc) != GM_COMPATIBLE)
        || (GetMapMode(hdc) != MM_TEXT))
    {
        // Clean the DC, to set the transform back to translation-only.

        ASSERT(Context->SaveDc == 0);

        Context->SaveDc = ::SaveDC(hdc);
        if (!Context->SaveDc)
        {
            return GenericError;
        }

        // CleanTheHdc shouldn't be resetting the clipping, but it does,
        // which messes up GetClipBox below.
        // So until bug #99338 is resolved, we must work around it.

        hackResetClipping = TRUE;
        Context->CleanTheHdc(hdc, FALSE);
    }

    // The code above is necessary because GetClipBox returns
    // logical coordinates, but we want device coordinates.
    // By this point, we've made sure that the transform is translation-only.

    if (GetClipBox(hdc, rect) == ERROR)
    {
        return GenericError;
    }

    // See bug #99338. We must reset the clipping, because that's what
    // CleanTheHdc normally does, and apparently some of our code relies on it.
    // If #99338 is resolved as suggested, this should go away.

    if (hackResetClipping)
    {
        SelectClipRgn(hdc, NULL);
    }

    #if DBG
        // Save the world-coordinate rectangle.

        RECT checkRect = *rect;
    #endif

    // Convert to device coordinates.
    if (!LPtoDP(hdc, reinterpret_cast<POINT *>(rect), 2))
    {
        return GenericError;
    }

    // NT can sometimes return poorly-ordered rectangles,
    // but I don't think this applies to translation-only tranforms.

    ASSERT(   (rect->left <= rect->right)
           && (rect->top  <= rect->bottom));

    // Verify that the transform was translation-only.
    // Note that this sanity check could fail to catch some transforms
    // which are 'almost' translation-only. But ask me if I care.

    ASSERT(   (  (rect->right      - rect->left)
              == (checkRect.right  - checkRect.left))
           && (  (rect->bottom     - rect->top)
              == (checkRect.bottom - checkRect.top)));

    return Ok;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a window handle.
*
*   The advantage of this call over that of GetFromHdc is that
*   it can avoid the (slow) process of cleaning the DC.
*
*   NOTE: This does not provide BeginPaint/EndPaint functionality, so
*         the app will still have to call BeginPaint/EndPaint in its
*         WM_PAINT call.
*
* Arguments:
*
*   [IN] hwnd - Specifies the window
*
* Return Value:
*
*   NULL if failure (such as with an invalid hwnd).
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpGraphics::GpGraphics(
    HWND hwnd,
    HDC hdc,
    INT clientWidth,
    INT clientHeight,
    HdcIcmMode icmMode,
    BOOL gdiLayered
    ) : BottomContext((hwnd != NULL) ||
                      (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY))
{
    ASSERT((hdc != NULL) || (hwnd != NULL));

    //User doesn't have any protection against negative client areas so we 
    //should consider them to be valid although empty.
    clientWidth = max(clientWidth, 0);
    clientHeight = max(clientHeight, 0);
    
    SetValid(TRUE);

    Context = &BottomContext;

    Type = GraphicsScreen;
    Metafile = NULL;
    DownLevel = FALSE;
    Printer = FALSE;
    LockedByGetDC = 0;
    Driver = Globals::DesktopDriver;
    Surface = Globals::DesktopSurface;
    Device = Globals::DesktopDevice;
    GdipBitmap = NULL;
    CreatedDevice = FALSE;

    // We don't do GetDC(hwnd) here and store that here because,
    // among other things, we don't want to hit the cached DC
    // limit on Win9x:

    Context->Hdc = hdc;
    Context->Hwnd = hwnd;
    Context->IcmMode = icmMode;
    Context->GdiLayered = gdiLayered;

    HDC tempHdc = (hdc != NULL) ? hdc : Globals::DesktopDevice->DeviceHdc;

    if (GetDeviceCaps(tempHdc, BITSPIXEL) <= 8)
    {
        Context->PaletteMap = new EpPaletteMap(tempHdc);

        if (!Context->PaletteMap ||
            !Context->PaletteMap->IsValid())
        {
             WARNING(("Unable to compute palette translation vector"));
             SetValid(FALSE);
             return;
        }
        
        Context->PaletteMap->SetUniqueness(Globals::PaletteChangeCount);
    }

    ResetState(0, 0, clientWidth, clientHeight);

    // Now inherit state from the HDC:

    if (hwnd == NULL)
    {
        // In addition to extracting the HDC's transform state, this
        // will also extract app-specified clipping and combine it
        // with our other clipping state:

        if (IsValid())
        {
            SetValid(InheritAppClippingAndTransform(hdc) == Ok);
        }

        // Check the ICM Mode on the hdc - The ICM state in the HDC
        // passed in should override the flag setting.
        // IcmModeOn -> screen rendering will avoid using the
        // DCI codepath and instead render using GDI with the ICM enabled
        // HDC.

        if(::SetICMMode(hdc, ICM_QUERY)==ICM_ON)
        {
            Context->IcmMode = IcmModeOn;
        }
        else
        {
            // If the ICM mode is off or we failed somehow to query
            // the ICM mode, then set it to OFF.

            Context->IcmMode = IcmModeOff;
        }
    }
    else    // non-NULL hwnd
    {
        // Since the window could have CS_OWNDC style, we still have to
        // inherit from it.
        HDC hdc = ::GetDC(hwnd);

        if (hdc != NULL)
        {
            if (IsValid())
            {
                SetValid(InheritAppClippingAndTransform(hdc) == Ok);
            }

            ::ReleaseDC(hwnd, hdc);
        }
    }
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Create a GpGraphics class from a DpBitmap.
*
* Arguments:
*
*   [IN] surface - Specifies the DpBitmap
*
* Return Value:
*
*   NULL if failure
*
\**************************************************************************/

GpGraphics::GpGraphics(DpBitmap * surface)
    : BottomContext(surface->IsDisplay)
{
    Surface                     = surface;
    BottomContext.ContainerDpiX = surface->DpiX;
    BottomContext.ContainerDpiY = surface->DpiY;
    Context                     = &BottomContext;
    Metafile                    = NULL;
    DownLevel                   = FALSE;
    Printer                     = FALSE;
    PrintInit                   = NULL;
    LockedByGetDC               = 0;
    CreatedDevice               = FALSE;
    GdipBitmap                  = NULL;
    Device                      = Globals::DesktopDevice;

    // Fail the creation of the destination if EpAlphaBlender
    // cannot convert to the DpBitmap pixel format.
    // The only reason to create a graphics around a bitmap is to be
    // able to draw onto it. If we can't convert the format to it,
    // we can't draw on it.

    if( (surface->Type != DpBitmap::GPBITMAP) ||
        (EpAlphaBlender::IsSupportedPixelFormat(surface->PixelFormat) &&
         surface->PixelFormat != PixelFormat8bppIndexed))
    {
        SetValid(TRUE);
    }
    else
    {
        SetValid(FALSE);
    }
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Check whether the HWND has windows layering set.
*
* Arguments:
*
*   [IN] hwnd - Specifies the HWND
*
*   [OUT] isLayeredWindow - Points to BOOL that returns layering property
*
* Return Value:
*
*   FALSE if failure.
*
\**************************************************************************/

BOOL
CheckWindowsLayering(
    HWND hwnd,
    BOOL *isLayered
    )
{
    BOOL bRet = TRUE;

    // Assume no layering.

    *isLayered = FALSE;

    // Layering is only supported on NT5 or better.

    if ((Globals::IsNt) && (Globals::OsVer.dwMajorVersion >= 5)
        && (Globals::GetWindowInfoFunction))
    {
        WINDOWINFO wndInfo;
        
        // Initialize the structure with the appropriate size.
        
        GpMemset(&wndInfo, 0, sizeof(WINDOWINFO));
        wndInfo.cbSize = sizeof(WINDOWINFO);

        // NTRAID#NTBUG9-385929-2001/05/05-asecchia
        // See JasonSch's comments in the bug report.
        // Perf [agodfrey]: JStall pointed out that GetWindowInfo is very
        // slow (he quoted 2,700,000 clocks). Much better would be
        // GetWindowLong(hwnd, GWL_EXSTYLE).
        
        if (Globals::GetWindowInfoFunction(hwnd, &wndInfo))
        {
            *isLayered = ((wndInfo.dwExStyle & WS_EX_LAYERED) != 0);

            // An app using layered windows might only have the property set
            // on the topmost or root window.  So if we didn't find the
            // layered property on the window itself, need to check the root
            // window.

            if ((!*isLayered) && (Globals::GetAncestorFunction))
            {
                HWND hwndRoot = Globals::GetAncestorFunction(hwnd, GA_ROOT);

                // It's OK for GetAncestor to fail, which indicates that
                // hwnd is already the top level window.  If it succeeds,
                // then hwnd is a child window and we need to check the
                // root for layering.

                if (hwndRoot)
                {
                    // Perf [agodfrey]: Ditto here - GetWindowLong is better.

                    if (Globals::GetWindowInfoFunction(hwndRoot, &wndInfo))
                    {
                        *isLayered = ((wndInfo.dwExStyle & WS_EX_LAYERED) != 0);
                    }
                    else
                    {
                        WARNING(("GetWindowInfo failed"));
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
            WARNING(("GetWindowInfo failed"));
            bRet = FALSE;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Create a GpGraphics for a window.
*
* Arguments:
*
*   [IN] hwnd - Specifies the window
*
*   [IN] icmMode - Specifies the GDI ICM mode associated with this
*
* Return Value:
*
*   NULL if failure.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromHwnd(
    HWND        hwnd,
    HdcIcmMode  icmMode
    )
{
    // If hwnd is NULL, caller really meant that desktop
    // window should be used (Windows convention treats NULL hwnd
    // as a reference to desktop window).

    if (hwnd == NULL)
    {
        hwnd = GetDesktopWindow();
        ASSERT(hwnd != NULL);
    }

    RECT    rect;

    // Check if hwnd has layering enabled.  Need to let GpGraphics know
    // about it.  Only on NT5 or better.  Also note that GetWindowInfo
    // is only on NT4SP3 (or later) or Win98 (or later).

    BOOL isLayeredWindow;

    if (!CheckWindowsLayering(hwnd, &isLayeredWindow))
    {
        WARNING(("CheckWindowsLayering failed"));
        return NULL;
    }

    // GetClientRect is nice and fast (entirely user-mode on NT).

    if (::GetClientRect(hwnd, &rect))
    {
        ASSERT((rect.top == 0) && (rect.left == 0));

        GpGraphics *g = new GpGraphics(hwnd, NULL, rect.right, rect.bottom,
                                       icmMode, isLayeredWindow);
        CheckValid(g);
        return g;
    }
    else
    {
        WARNING(("GetClientRect failed"));
    }
    return NULL;
}

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Create a GpGraphics for a screen DC.
*
* Arguments:
*
*   [IN] hdc - Specifies the DC
*
* Return Value:
*
*   NULL if failure.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdiScreenDC(
    HDC     hdc
    )
{
    // If hdc is NULL, caller really meant that desktop
    // window should be used (Windows convention treats NULL hwnd
    // as a reference to desktop window).

    if (hdc == NULL)
    {
        return GpGraphics::GetFromHwnd(NULL);
    }

    ASSERT(GetDCType(hdc) == OBJ_DC);

    HWND    hwnd = WindowFromDC(hdc);

    if (hwnd != NULL)
    {
        RECT    windowRect;
        POINT   dcOrg;

        // Check if hwnd has layering enabled.  Need to let GpGraphics know
        // about it.  Only on NT5 or better.  Also note that GetWindowInfo
        // is only on NT4SP3 (or later) or Win98 (or later).

        BOOL isLayeredWindow;

        if (!CheckWindowsLayering(hwnd, &isLayeredWindow))
        {
            WARNING(("CheckWindowsLayering failed"));
            return NULL;
        }

        // If the user did a GetWindowFromDC call, then they want to be
        // able to draw to the entire window, not just to the client area.
        // In that case we use the WindowRect for the surface size, instead
        // of using the ClientRect.  We determine this by seeing where the
        // DC origin is (the window rect or the client rect).

        if (::GetWindowRect(hwnd, &windowRect))
        {
            if (::GetDCOrgEx(hdc, &dcOrg))
            {
                if ((dcOrg.x == windowRect.left) && (dcOrg.y == windowRect.top))
                {
                    windowRect.right  -= windowRect.left;
                    windowRect.bottom -= windowRect.top;

                    GpGraphics *g = new GpGraphics(NULL,
                                                   hdc,
                                                   windowRect.right,
                                                   windowRect.bottom,
                                                   IcmModeOff,
                                                   isLayeredWindow);

                    CheckValid(g);
                    return g;
                }

                RECT    clientRect;

                // GetClientRect is nice and fast (entirely user-mode on NT).
                if (::GetClientRect(hwnd, &clientRect))
                {
                    ASSERT((clientRect.top == 0) && (clientRect.left == 0));

                    GpGraphics *g = new GpGraphics(NULL,
                                                   hdc,
                                                   clientRect.right,
                                                   clientRect.bottom,
                                                   IcmModeOff,
                                                   isLayeredWindow);

                    CheckValid(g);
                    return g;
                }
                else
                {
                    WARNING(("GetClientRect failed"));
                }
            }
            else
            {
                WARNING(("GetDCOrgEx failed"));
            }
        }
        else
        {
            WARNING(("GetWindowRect failed"));
        }
    }
    else    // WindowFromDC failed
    {
        // The client must have used CreateDC("DISPLAY") to get this hdc,
        // so we'll use the full bounds of the screen to create the graphics.

        INT     screenWidth;
        INT     screenHeight;

        screenWidth  = ::GetDeviceCaps(hdc, HORZRES);
        screenHeight = ::GetDeviceCaps(hdc, VERTRES);

        if ((screenWidth > 0) && (screenHeight > 0))
        {
            GpGraphics *g = new GpGraphics(NULL, hdc, screenWidth, screenHeight);
            CheckValid(g);
            return g;
        }
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the Graphics container transform to copy the transform set in
*   the DC.
*
*   NOTE: This function will be called a lot, and is therefore rather
*         performance critical.  Do not add gratuitous GDI or GDI+
*         calls!
*
* Arguments:
*
*   [IN] hdc - Specifies the DC to be copied
*
* Notes:
*
*   This should really be a member of DpContext (bug #98174).
*
* Return Value:
*
*   Ok if successful
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::InheritAppClippingAndTransform(
    HDC hdc
    )
{
    POINT points[3];
    GpPointF destPoints[3];
    GpRectF srcRect;
    GpRectF destRect;
    GpStatus infer = GenericError;
    GpStatus status;
    BYTE stackBuffer[1024];

    // It would take a lot of time to call all the Win32 APIs to query
    // the transform: we would minimally have to call GetMapMode,
    // GetWindowOrgEx, and GetViewportOrgEx; and maximally also have to
    // call GetWorldTransform, GetViewportExtEx, and GetWindowExtEx.
    //
    // We cheat a little by making a single call to LPtoDP with a
    // parallelogram, and then inferring the result.  Note that we do
    // run the risk of some error, and on Win9x of overflow, since Win9x
    // only supports 16-bit coordinates.  To counteract this, we try to
    // choose large values that won't overflow.

    // There is a common scenario when LPtoDP will overflow returning
    // bad saturated values.  In printing to high DPI devices to avoid
    // overflow on Win9x, apps will use a large translate in the
    // window org to reposition the graphics.  In such cases, we do
    // the expensive work of determining the real WorldToDevice.
    if (!Globals::IsNt && Context->ContainerDpiX > 600.0f) 
    {
        INT mapMode = GetMapMode(hdc);

        if (mapMode == MM_ANISOTROPIC ||
            mapMode == MM_ISOTROPIC) 
        {
            POINT viewOrg, windOrg;
            GetViewportOrgEx(hdc, &viewOrg);
            GetWindowOrgEx(hdc, &windOrg);

            SIZE viewExt, windExt;
            GetViewportExtEx(hdc, &viewExt);
            GetWindowExtEx(hdc, &windExt);

            GpRectF windRect(TOREAL(windOrg.x), TOREAL(windOrg.y), 
                             TOREAL(windExt.cx), TOREAL(windExt.cy));
            GpRectF viewRect(TOREAL(viewOrg.x), TOREAL(viewOrg.y),
                             TOREAL(viewExt.cx), TOREAL(viewExt.cy));

            infer = Context->ContainerToDevice.InferAffineMatrix(viewRect,
                                                                 windRect);
        }
    }
    
    if (infer != Ok)
    {
        points[0].x = 0;
        points[0].y = 0;
        points[1].x = 8192;
        points[1].y = 0;
        points[2].x = 0;
        points[2].y = 8192;

        if (!LPtoDP(hdc, points, 3))
            return(GenericError);

        srcRect.X = TOREAL(0.0);
        srcRect.Y = TOREAL(0.0);
        srcRect.Width = TOREAL(8192.0);
        srcRect.Height = TOREAL(8192.0);

        if ((points[0].x == points[2].x) && (points[0].y == points[1].y))
        {
            // Win9x doesn't support rotation, and even on NT it will be
            // pretty rare.  Having a special-case like this for scaling
            // saves us some work in 'InferAffineMatrix':

            destRect.X = LTOF(points[0].x);
            destRect.Y = LTOF(points[0].y);
            destRect.Width = LTOF(points[1].x - points[0].x);
            destRect.Height = LTOF(points[2].y - points[0].y);

            infer = Context->ContainerToDevice.InferAffineMatrix(destRect,
                                                                 srcRect);
        }
        else
        {
            destPoints[0].X = LTOF(points[0].x);
            destPoints[0].Y = LTOF(points[0].y);
            destPoints[1].X = LTOF(points[1].x);
            destPoints[1].Y = LTOF(points[1].y);
            destPoints[2].X = LTOF(points[2].x);
            destPoints[2].Y = LTOF(points[2].y);

            infer = Context->ContainerToDevice.InferAffineMatrix(destPoints,
                                                                 srcRect);
        }
    }

    if (infer != Ok)
        return(infer);

    Context->UpdateWorldToDeviceMatrix();

    // Quickly get a GDI region object:

    HRGN regionHandle = GetCachedGdiRegion();
    if (regionHandle == NULL)
        return(OutOfMemory);

    // Verify that our cache is working properly, and we have a valid region:

    ASSERT(GetObjectTypeInternal(regionHandle) == OBJ_REGION);

    // No early-outs from here-in, because we have to cleanup:

    status = Ok;

    // Query the application clip region, if there is one.  The value of '1'
    // as a parameter is a magic value used by the metafile code on both
    // Win9x and NT to query the application clipping.  If a value of zero
    // is returned, there is no application-set clipping.
    //
    // Note that if we had passed in SYSRGN (a value of '4') instead of '1',
    // the result does NOT include the application level clipping.  (In other
    // words, SYSRGN is not equivalent to the Rao region, which is why we have
    // to explicitly query the application clipping here.)

    INT getResult = GetRandomRgn(hdc, regionHandle, 1);
    if (getResult == TRUE)
    {
        // If our stack buffer is big enough, get the clipping contents
        // in one gulp:

        INT newSize = GetRegionData(regionHandle,
                                    sizeof(stackBuffer),
                                    (RGNDATA*) &stackBuffer[0]);
        RGNDATA *regionBuffer = (RGNDATA*) &stackBuffer[0];

        // The spec says that  GetRegionData returns '1' in the event of
        // success, but NT returns the actual number of bytes written if
        // successful, and returns '0' if the buffer wasn't large enough:

        if ((newSize < 1) || (newSize > sizeof(stackBuffer)))
        {
            // Our stack buffer wasn't big enough.  Figure out the required
            // size:

            newSize = GetRegionData(regionHandle, 0, NULL);
            if (newSize > 1)
            {
                regionBuffer = (RGNDATA*) GpMalloc(newSize);
                if (regionBuffer == NULL)
                    return OutOfMemory;

                // Initialize to a decent result in the unlikely event of
                // failure of GetRegionData:

                regionBuffer->rdh.nCount = 0;

                GetRegionData(regionHandle, newSize, regionBuffer);
            }
        }

        // Set our GDI+ container clipping to be the same thing as the
        // GDI application clipping:

        status = Context->ContainerClip.Set((RECT*) &regionBuffer->Buffer[0],
                                            regionBuffer->rdh.nCount);

        if (status == Ok)
        {
            // the ContainerClip must always be intersected with the WindowClip
            status = Context->ContainerClip.And(&WindowClip);
        }

        if (status != Ok)
        {
            // use the best fall-back solution we can

            // guaranteed to succeed
            Context->ContainerClip.Set(&WindowClip);
        }

        // Now calculate the combined result:
        status = this->AndVisibleClip();

        // Free the temporary buffer if one was allocated:

        if (regionBuffer != (RGNDATA*) &stackBuffer[0])
            GpFree(regionBuffer);
    }

    ReleaseCachedGdiRegion(regionHandle);
    return(status);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a bitmap DC.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
*   11/21/2000 minliu
*       Change the way GDI+ using the palette inside the DIBSection
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdiBitmap(
    HDC hdc
    )
{
    ASSERT((hdc != NULL) && (GetDCType(hdc) == OBJ_MEMDC));

    HBITMAP hbitmap = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);
    if (hbitmap)
    {
        DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
        if (CheckValid(bitmap))
        {
            INT             bitmapWidth;
            INT             bitmapHeight;
            EpPaletteMap*   pPaletteMap = NULL;
            DIBSECTION      dibInfo;
            INT             infoSize = GetObjectA(hbitmap, sizeof(dibInfo),
                                                  &dibInfo);
            BOOL            initialized = FALSE;
            BOOL            isHalftoneDIB = FALSE;
            DpDriver*       driver = NULL;
            ColorPalette*   pPalette = NULL;

            // WinNT/Win95 differences in GetObject:
            //
            // WinNT always returns the number of bytes filled, either
            // sizeof(BITMAP) or sizeof(DIBSECTION).
            //
            // Win95 always returns the original requested size (filling the
            // remainder with NULLs).  So if it is a DIBSECTION, we expect
            // dibInfo.dsBmih.biSize != 0; otherwise it is a BITMAP.

            if ( (infoSize == sizeof(DIBSECTION) )
               &&(Globals::IsNt || dibInfo.dsBmih.biSize != 0) )
            {
                // If this is an 8 bpp DIB, get its color palette and make a
                // matching palette map from our halftone palette.

                if ( dibInfo.dsBmih.biBitCount == 8 )
                {
                    // Create a new EpPaletteMap object.
                    // Note: If the colorTable is exactly the same as our
                    // GDI+ halftone palette, we will have a 1 to 1 color
                    // translation table in the EpPaletteMap object. If the
                    // color palette doesn't match exactly with our GDI+
                    // halftone palette and also within a certain
                    // mismatching range, we will have a translation table
                    // in EpPaletteMap object.
                    // Also, EpPaletteMap object will set up a IsVGAOnly()
                    // to tell us if GDI+ can do the halftone dithering or
                    // not (if IsVGAOnly() returns FALSE, it means GDI+ can
                    // do it
                    
                    // NOTE: EpPaletteMap may allocate storage for pPalette
                    // which must be freed with GpFree.

                    pPaletteMap = new EpPaletteMap(hdc, &pPalette, TRUE);

                    if ( pPaletteMap == NULL )
                    {
                        WARNING(("FromGdiBmp()-new EpPaletteMap failed"));
                    }
                    else if ( (pPaletteMap->IsValid() == TRUE)
                              &&(pPaletteMap->IsVGAOnly() == FALSE) )
                    {
                        ASSERT(pPalette != NULL);

                        // GDI+ can do the halftone dithering

                        isHalftoneDIB = TRUE;
                    }
                    else
                    {
                        // The supplied palette has insufficient
                        // matching colors for our halftone dithering,
                        // but we can still do VGA dithering. However,
                        // we'll use the GDI bitmap path instead, to
                        // be safe, since this is what we were doing
                        // before.

                        if (pPaletteMap->IsValid())
                        {
                            ASSERT(pPalette != NULL);

                            GpFree(pPalette);
                            pPalette = NULL;
                        }

                        delete pPaletteMap;
                        pPaletteMap = NULL;
                    }
                }// if ( dibInfo.dsBmih.biBitCount == 8 )

                // Up to this point, we will either have isHalftoneDIB = TRUE,
                // which means GDI+ can do the dithering or FALSE otherwise.

                if ((dibInfo.dsBmih.biBitCount > 8) || (isHalftoneDIB == TRUE) )
                {
                    initialized = bitmap->InitializeForDibsection(
                        hdc,
                        hbitmap,
                        Globals::DesktopDevice,
                        &dibInfo,
                        &bitmapWidth,
                        &bitmapHeight,
                        &driver
                    );
                }
            }// if it is a DIBSection

            if ( initialized == FALSE )
            {
                // Use GDI code path

                bitmapWidth = dibInfo.dsBm.bmWidth;
                bitmapHeight = dibInfo.dsBm.bmHeight;

                bitmap->InitializeForGdiBitmap(Globals::DesktopDevice,
                                               bitmapWidth,
                                               bitmapHeight);

                driver = Globals::GdiDriver;
            }

            GpGraphics *g = new GpGraphics(bitmap);

            if (g)
            {
                // NTRAID#NTBUG9-370409-2001/04/17-asecchia
                // This is error-prone code. The GpGraphics and the DpContext
                // objects should properly encapsulate their own construction.
                
                g->Type                 = GraphicsBitmap;
                g->Driver               = driver;
                g->Context->Hdc         = hdc;
                g->Context->PaletteMap  = NULL;
                g->Context->Palette     = NULL;

                g->ResetState(0, 0, bitmapWidth, bitmapHeight);

                if (g->InheritAppClippingAndTransform(hdc) == Ok)
                {
                    // If this is our special DIB, set the original palette in
                    // the Context so that later on when we doing alpha blend
                    // etc., we can use it to read pixel data from the
                    // DIBSection correctly

                    if ( isHalftoneDIB == TRUE )
                    {
                        g->Context->Palette = pPalette;
                        g->Context->PaletteMap = pPaletteMap;

                        return(g);
                    }
                    else if (GetDeviceCaps(hdc, BITSPIXEL) <= 8)
                    {
                        ASSERT(pPaletteMap == NULL);

                        pPaletteMap = new EpPaletteMap(hdc);

                        if ( NULL != pPaletteMap )
                        {    

                            pPaletteMap->SetUniqueness(
                                Globals::PaletteChangeCount
                            );

                            if ( pPaletteMap->IsValid() )
                            {
                                // Now that we know that the pPaletteMap is
                                // valid and we're returning a valid GpGraphics
                                // we can give up ownership of the pPaletteMap
                                // to the GpGraphics and return without 
                                // deleting it.
                                
                                g->Context->PaletteMap = pPaletteMap;
                                return(g);
                            }
                        }
                    }
                    else
                    {
                        // Higher than 8 bpp, this graphics object is fine

                        return(g);
                    }
                }// if (g->InheritAppClippingAndTransform(hdc) == Ok)

                delete g;
            }// if (g)
            else
            {
                delete bitmap;
            }

            // We fall into here only we failed to create the Graphics object

            if ( NULL != pPaletteMap )
            {
                delete pPaletteMap;
            }

            if ( NULL != pPalette )
            {
                GpFree(pPalette);
            }
        }// if (CheckValid(bitmap))
    }// if ( hbitmap )
    else
    {
        RIP(("GetCurrentObject failed"));
    }

    return(NULL);
}// GetFromGdiBitmap()

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a GpBitmap.
*
* History:
*
*   09/22/1999 gilmanw
*       Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdipBitmap(
    GpBitmap *      bitmap,
    ImageInfo *     imageInfo,
    EpScanBitmap *  scanBitmap,
    BOOL            isDisplay
    )
{
    DpBitmap *surface = new DpBitmap();

    if (CheckValid(surface))
    {
        // This call initializes the DPI and IsDisplay members
        surface->InitializeForGdipBitmap(imageInfo->Width, imageInfo->Height, imageInfo, scanBitmap, isDisplay);
        GpGraphics *g = new GpGraphics(surface);
        if (g)
        {
            g->Type         = GraphicsBitmap;
            g->Driver       = Globals::EngineDriver;
            g->Context->Hdc = NULL;
            g->GdipBitmap   = bitmap;

            g->ResetState(0, 0, imageInfo->Width, imageInfo->Height);

            return g;
        }
        else
        {
            delete surface;
        }
    }

    return(NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a direct draw surface.
*
* History:
*
*   10/06/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromDirectDrawSurface(
    IDirectDrawSurface7 * surface
    )
{
    INT bitmapWidth;
    INT bitmapHeight;
    GpGraphics *g;
    DpDriver *driver;

    DpBitmap *bitmap = new DpBitmap();

    if (CheckValid(bitmap))
    {
        // Leave bitmap->IsDisplay and Dpi params at their default values.
        if( bitmap->InitializeForD3D(surface,
                                     &bitmapWidth,
                                     &bitmapHeight,
                                     &driver))
        {
            GpGraphics *g = new GpGraphics(bitmap);

            if (g)
            {
                g->Type         = GraphicsBitmap;
                g->Driver       = driver;
                g->Context->Hdc = NULL;

                g->ResetState(0, 0, bitmapWidth, bitmapHeight);

                return(g);
            }
            else
            {
                delete bitmap;
            }
        }
    }

    return(NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   This should only be called by the GetFromHdc() for a printer DC.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::StartPrinterEMF()
{
   IStream *stream = NULL;
   INT result;

   // Send escape to printer to determine if this supports the UNIDRV
   // escape codes.

   GDIPPRINTINIT printInit;
   printInit.dwSize = sizeof(GDIPPRINTINIT);

   // !! Query whether escape is supported first.

   result = ExtEscape(Context->Hdc,
                      GDIPLUS_UNI_INIT,
                      0,
                      NULL,
                      sizeof(GDIPPRINTINIT),
                      (LPSTR)&printInit);

   if (result<=0)
       return NotImplemented;


   // save printer data in structure

   PrintInit = new GDIPPRINTINIT;
   
   if(!PrintInit)
   {
       return OutOfMemory;
   }
   
   memcpy((LPVOID)PrintInit, (LPVOID)&printInit, sizeof(GDIPPRINTINIT));

   PrinterEMF = GlobalAlloc(GMEM_MOVEABLE, 1);

   if (!PrinterEMF)
   {
       return OutOfMemory;
   }

   if (CreateStreamOnHGlobal(PrinterEMF, FALSE, &stream) != S_OK)
   {
       GlobalFree(PrinterEMF);
       PrinterEMF = NULL;
       return Win32Error;
   }

   FPUStateSaver fpuState;

   PrinterMetafile = new GpMetafile(stream, Context->Hdc, EmfTypeEmfPlusOnly);

   stream->Release();

   if (!PrinterMetafile)
   {
      GlobalFree(PrinterEMF);
      PrinterEMF = NULL;
      return OutOfMemory;
   }

   PrinterGraphics = PrinterMetafile->GetGraphicsContext();

   Metafile = PrinterGraphics->Metafile;

   return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Arguments:
*
* Return Value:
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::EndPrinterEMF()
{
   LPVOID emfBlock;
   INT result = -1;
   GpStatus status;

   if (PrinterGraphics)
   {
       // end recording to metafile graphics context
       delete PrinterGraphics;
       PrinterGraphics = NULL;
   }

   // Disposing of metafile also Release() stream interface.
   if (PrinterMetafile)
   {
       PrinterMetafile->Dispose();
       PrinterMetafile = NULL;
       Metafile = NULL;
   }

   if (PrinterEMF)
   {
      emfBlock = GlobalLock(PrinterEMF);

      if (emfBlock)
         result = ExtEscape(Context->Hdc,
                            GDIPLUS_UNI_ESCAPE,
                            // This is a downcast on IA64, but I don't believe
                            // PrinterEMF will be bigger than MAXINT
                            (ULONG)GlobalSize(PrinterEMF),
                            (LPCSTR)emfBlock,
                            sizeof(GpStatus),
                            (LPSTR)&status);

      GlobalUnlock(PrinterEMF);
      GlobalFree(PrinterEMF);
      PrinterEMF = NULL;

      if (result>0)
         return status;
      else
         return Win32Error;

   }
   else
      return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Uses HDC and HANDLE for printer to determine the postscript level.  The
* caller must ensure this is a PS HDC so we don't waste our time.
*
* Arguments:
*
*  HDC - handle to device context for printer
*  HANDLE - handle to printer device (may be NULL)
*
* Return Value:
*
*  Postscript Level - (-1) if not found, must provide downlevel support
*
* History:
*    10/26/1999 ericvan Created it.
*
\**************************************************************************/

INT
GpGraphics::GetPostscriptLevel(HDC hDC, HANDLE hPrinter)
{
    // Place this code under the load library critical section.  We make
    // extensive use of Globals::variables and need protection.
    LoadLibraryCriticalSection llcs;

    INT feature = FEATURESETTING_PSLEVEL;

    INT level;

    if ((Globals::hCachedPrinter != 0) &&
        (Globals::hCachedPrinter == hPrinter))
    {
        return Globals::CachedPSLevel;
    }

    // !! Re-examine this, Nolan said he would add this to the HP ps driver
    //    so we may have this working on Win9x

    if (Globals::IsNt && Globals::OsVer.dwMajorVersion >= 5)
    {
        DWORD EscapeValue = POSTSCRIPT_IDENTIFY;

        if (ExtEscape(hDC,
                      QUERYESCSUPPORT,
                      sizeof(DWORD),
                      (LPSTR)&EscapeValue,
                      0,
                      NULL) != 0)
        {

           // must be in GDI centric mode to get PS feature settings...

           DWORD Mode = PSIDENT_GDICENTRIC;

           if (ExtEscape(hDC,
                         POSTSCRIPT_IDENTIFY,
                         sizeof(DWORD),
                         (LPSTR)&Mode,
                         0,
                         NULL)>0)
           {
               if (ExtEscape(hDC,
                             GET_PS_FEATURESETTING,
                             sizeof(INT),
                             (LPSTR)&feature,
                             sizeof(INT),
                             (LPSTR)&level)>0)
               {
                   Globals::hCachedPrinter = hPrinter;
                   Globals::CachedPSLevel = level;

                   return level;
               }
           }
        }
    }

    if (hPrinter == NULL)
        return -1;

    // get name of the PPD file.

    union
    {
        DRIVER_INFO_2A driverInfo;
        CHAR buftmp[1024];
    };
    DWORD size;

    // we require GetPrinterDriver() API to get the .PPD path+file.
    // unfortunately this API is buried in winspool.drv (112KB), so we
    // lazy load it here.

    if (Globals::WinspoolHandle == NULL)
    {
        Globals::WinspoolHandle = LoadLibraryA("winspool.drv");

        if (Globals::WinspoolHandle == NULL)
            return -1;

        Globals::GetPrinterDriverFunction = (WINSPOOLGETPRINTERDRIVERFUNCTION)
                                              GetProcAddress(
                                                     Globals::WinspoolHandle,
                                                     "GetPrinterDriverA");
    }

    if (Globals::GetPrinterDriverFunction == NULL)
        return -1;

    if (Globals::GetPrinterDriverFunction(hPrinter,
                          NULL,
                          2,
                          (BYTE*)&driverInfo,
                          1024,
                          &size) == 0)
        return -1;

    HANDLE hFile;

    hFile = CreateFileA(driverInfo.pDataFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return -1;

    // Obtain the file size
    //  NOTE: We don't support files larger than 4GB.

    DWORD sizeLow, sizeHigh;
    sizeLow = GetFileSize(hFile, &sizeHigh);

    // impose a 4GB limit (certainly reasonable)
    if (sizeLow == 0xffffffff || sizeHigh != 0)
    {
        CloseHandle(hFile);
        return -1;
    }

    // Map the file into memory

    HANDLE hFilemap;
    LPSTR fileview = NULL;

    hFilemap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFilemap != NULL)
    {
         fileview = (LPSTR) MapViewOfFile(hFilemap, FILE_MAP_READ, 0, 0, 0);
         CloseHandle(hFilemap);
    }
    else
    {
         CloseHandle(hFile);
         return -1;
    }

    LPSTR buf = fileview;
    LPSTR topbuf = fileview + (sizeLow-16);

    // we actually expect the LanguageLevel to be early
    // in the file (likely in the first 2K of data).

    // !! What if this appears in comments (read starting at carriage returns?!

    level = -1;

    while (buf < topbuf)
    {
        if (*buf == 'L' &&
            GpMemcmp(buf, "LanguageLevel", 13) == 0)
        {
             while ((*buf < '0' || *buf > '9') && buf < topbuf)
                 buf++;

             CHAR ch = *buf;

             if (ch >= '0' && ch <= '9')
                 level = (INT)ch - (INT)'0';

             break;
        }
        buf++;
    }

    UnmapViewOfFile((LPCVOID)fileview);
    CloseHandle(hFile);

    Globals::hCachedPrinter = hPrinter;
    Globals::CachedPSLevel = level;

    return level;
}

/**************************************************************************\
*
* Function Description:
*
* Arguments:
*
* Return Value:
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromGdiPrinterDC(
    HDC hdc,
    HANDLE hPrinter
    )
{
    ASSERT((hdc != NULL) &&
           ((GetDCType(hdc) == OBJ_DC) ||
            (GetDCType(hdc) == OBJ_ENHMETADC))&&
           (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASPRINTER));

    // !! Change to useNewPrinterCode when we've fully switched
    DriverPrint *driver = NULL;

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        GpPrinterDevice *pdevice;

        {   // FPU Sandbox for potentially unsafe FPU code.
            FPUStateSandbox fpsb;
            pdevice = new GpPrinterDevice(hdc);
        }   // FPU Sandbox for potentially unsafe FPU code.

        if (CheckValid(pdevice))
        {
            // we defer creating driver until we know which to create
            // change to use DIBSECTION instead of GDI operations

            // Check if this is a postscript printer
            CHAR strTech[30];
            strTech[0] = '\0';

            INT ScaleX;          // ratio of device DPI : capped DPI
            INT ScaleY;

            // It is a PostScript printer if POSTSCRIPT_PASSTHROUGH or
            // POSTSCRIPT_IGNORE is available.  For some reason querying
            // GETTECHNOLOGY for postscript fails in MS Publisher, it may
            // be because we are in GDI centric mode.

            int iWant1 = POSTSCRIPT_PASSTHROUGH;
            int iWant2 = POSTSCRIPT_IGNORE;

            BOOL postscript;
            {   // FPU Sandbox for potentially unsafe FPU code.
                FPUStateSandbox fpsb;
                postscript = (
                    (Escape(hdc, QUERYESCSUPPORT, sizeof(iWant1), (LPCSTR)&iWant1, NULL) != 0) || 
                    (Escape(hdc, QUERYESCSUPPORT, sizeof(iWant2), (LPCSTR)&iWant2, NULL) != 0));
            }   // FPU Sandbox for potentially unsafe FPU code.

            SIZEL szlDevice;

            szlDevice.cx = GetDeviceCaps(hdc, HORZRES);
            szlDevice.cy = GetDeviceCaps(hdc, VERTRES);

            // ScaleX and ScaleY should be power of two (2, 4, 8)

            if (bitmap->DpiX <= 100)
            {
                ScaleX = 1;
                ScaleY = 1;
            }
            else
            {
                if (bitmap->DpiX >= 1200)
                {
                    ScaleX = GpRound(TOREAL(bitmap->DpiX) / 200);
                    ScaleY = GpRound(TOREAL(bitmap->DpiY) / 200);
                }
                else
                {
                    ScaleX = 3;
                    ScaleY = 3;        // cap 600 to 200 dpi or 3:1
                }
            }

            // We no longer keep capped dpi -- we use the device dpi as
            // capped dpi so that the world to
            // device transformation is correct for the clipped region and
            // path transformation.  ScaleX and ScaleY are used to scale
            // the output rectangle region.

            bitmap->InitializeForPrinter(pdevice,
                                         szlDevice.cx,
                                         szlDevice.cy);

            GpGraphics *g = new GpGraphics(bitmap);
            if (g)
            {
                g->Printer               = TRUE;
                g->Context->Hdc          = hdc;
                g->Context->IsPrinter    = TRUE;

                // Note: Both 'Device' and 'Driver' are freed at
                // ~GpGraphics time when 'CreatedDevice' is set:

                g->PrinterMetafile = NULL;
                g->PrinterGraphics = NULL;
                g->PrinterEMF = NULL;

                if (postscript)
                {
                    g->Type = GraphicsBitmap;

                    INT level = GetPostscriptLevel(hdc, hPrinter);

                    driver = new DriverPS(pdevice, level);

                    // !! Should this stuff be shifted into some driver
                    //    initialization routine?!

                    // !! Interop - what about redefines or conflicts
                    //             (conflicts aren't likely, but are
                    //              theoretically possible with
                    //              GetDC/ReleaseDC)

                }
#if 0
                else if (g->StartPrinterEMF() == Ok) 
                {
                    g->Type = GraphicsMetafile;

                    RIP(("Setting CreatedDevice will free Driver"));

                    driver = NULL; new DriverMeta(pdevice);

                    // GDI has some optimization code to check the page for color
                    // content, if none is found, on play back, it sets the device
                    // as being monochrome.
                    //
                    // Unfortunately, since our stuff is encoded in escapes, we end up
                    // playing back in monochrome.  The work-around, is to call a GDI
                    // API that forces a color flag to be set in the EMF code.  A
                    // simple one is SetTextColor().

                    // !!! Might want to remove this SetTextColor stuff for version one:

                    COLORREF colorRef = GetTextColor(hdc);
                    SetTextColor(hdc, 0x00808080);
                    SetTextColor(hdc, colorRef);
                }
#endif
                else
                {
                    // We can't use escapes for optimization,
                    // Map to GDI HDC operations.

                    g->Type = GraphicsBitmap;

                    driver = new DriverNonPS(pdevice);
                }

                if (CheckValid(driver))
                {
                    g->Driver = driver;
                    g->Device = pdevice;

                    driver->ScaleX = ScaleX;
                    driver->ScaleY = ScaleY;

                    // check for supporting print clip escapes
                    // These may be supported on PCL as well as Postscript
                    DWORD EscapeValue1 = CLIP_TO_PATH;
                    DWORD EscapeValue2 = BEGIN_PATH;
                    DWORD EscapeValue3 = END_PATH;

                    // Although some PCL drivers support CLIP_TO_PATH we 
                    // currently disable their use due to some outstanding 
                    // bugs in HP and Lexmark PCL drivers.  See bug #182972
                    
                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;

                        driver->UseClipEscapes = postscript &&
                            (ExtEscape(hdc,
                                       QUERYESCSUPPORT,
                                       sizeof(DWORD),
                                       (LPSTR)&EscapeValue1,
                                       0,
                                       NULL) != 0) &&
                            (ExtEscape(hdc,
                                       QUERYESCSUPPORT,
                                       sizeof(DWORD),
                                       (LPSTR)&EscapeValue2,
                                       0,
                                       NULL) != 0) &&
                            (ExtEscape(hdc,
                                       QUERYESCSUPPORT,
                                       sizeof(DWORD),
                                       (LPSTR)&EscapeValue3,
                                       0,
                                       NULL) != 0);
                    }   // FPU Sandbox for potentially unsafe FPU code.

                    DWORD EscapeValue = CHECKJPEGFORMAT;

                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;
                        driver->SupportJPEGpassthrough = ExtEscape(
                            hdc,
                            QUERYESCSUPPORT,
                            sizeof(DWORD),
                            (LPSTR)&EscapeValue,
                            0,
                            NULL) != 0;
                    }   // FPU Sandbox for potentially unsafe FPU code.
                            
                    EscapeValue = CHECKPNGFORMAT;
                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;
                        driver->SupportPNGpassthrough = ExtEscape(
                            hdc,
                            QUERYESCSUPPORT,
                            sizeof(DWORD),
                            (LPSTR)&EscapeValue,
                            0,
                            NULL) != 0;
                    }   // FPU Sandbox for potentially unsafe FPU code.

                    driver->NumColors = GetDeviceCaps(hdc, NUMCOLORS);

                    driver->UseVDP = FALSE;

                    // !! VDP not supported in v1
                    //VDP_GetFormSupport(hdc,
                    //                       (WORD*)&(driver->SupportVDP));

                    g->CreatedDevice = TRUE;

                    g->ResetState(0, 0, szlDevice.cx, szlDevice.cy);

                    if (g->InheritAppClippingAndTransform(hdc) == Ok)
                    {
                        return(g);
                    }
                    else
                    {
                        // ~GpGraphics implicitly deletes bitmap, device, and driver
                        delete g;
                        return NULL;
                    }
                }

                delete g;

                delete pdevice;

                return NULL;
            }

            delete pdevice;
        }

        delete bitmap;
    }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   This constructor is used internally for printer callback routine.
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*    6/1/1999 ericvan Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromHdcSurf(
    HDC           hdc,
    SURFOBJ*      surfObj,
    RECTL*        bandClip
    )
{
    static UINT16 PixelCount[] = { 1, 4, 8, 16, 24, 32 };

    INT width;
    INT height;
    GpGraphics* g;
    DpDriver *driver;

    // This is a weird surface.  It is a banded surface, so we set up a
    // clip and direct bits pointer.  We also have an HDC for it if we
    // decide to punt to GDI.

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        GpGraphics *g = new GpGraphics(bitmap);
        if (g)
        {
            width = GetDeviceCaps(hdc, HORZRES);
            height = GetDeviceCaps(hdc, VERTRES);

            // create DIB section for direct rendering of bits

            if (surfObj->iBitmapFormat < BMF_1BPP ||
                surfObj->iBitmapFormat > BMF_32BPP)
            {

InitializeHdcOnlyUse:
                // we don't support direct rendering to this type of
                // surface format.  Do everything through GDI HDC.

               driver = Globals::GdiDriver;

               bitmap->InitializeForGdiBitmap(Globals::DesktopDevice,
                                              width,
                                              height);


               g->Type         = GraphicsBitmap;
               g->Driver       = driver;
               g->Context->Hdc = hdc;

               g->ResetState(0, 0, 1, 1);
            }
            else
            {
               DIBSECTION dibSec;
               dibSec.dsBm.bmType = 0;
               dibSec.dsBm.bmWidth = surfObj->sizlBitmap.cx;

               if (surfObj->lDelta < 0)
               {
                  // bits pointer at top of frame buffer (scans down)

                  dibSec.dsBm.bmWidthBytes = -surfObj->lDelta;
                  dibSec.dsBm.bmHeight = -surfObj->sizlBitmap.cy;
               }
               else
               {
                  // bits pointer at base of frame buffer (scans up)

                  dibSec.dsBm.bmWidthBytes = surfObj->lDelta;
                  dibSec.dsBm.bmHeight = surfObj->sizlBitmap.cy;
               }

               dibSec.dsBm.bmPlanes = 1;
               dibSec.dsBm.bmBitsPixel = PixelCount[surfObj->iBitmapFormat-1];

               dibSec.dsBmih.biSize = sizeof(BITMAPINFOHEADER);
               dibSec.dsBmih.biWidth = width;
               dibSec.dsBmih.biHeight = height;
               dibSec.dsBmih.biPlanes = 1;
               dibSec.dsBmih.biBitCount = PixelCount[surfObj->iBitmapFormat-1];
               dibSec.dsBmih.biCompression = BI_BITFIELDS;
               dibSec.dsBmih.biSize = 0;

               dibSec.dsBitfields[0] = 0x000000FF;
               dibSec.dsBitfields[1] = 0x0000FF00;
               dibSec.dsBitfields[2] = 0x00FF0000;

               if (bitmap->InitializeForDibsection( hdc,
                                                    (HBITMAP) NULL,
                                                    Globals::DesktopDevice,
                                                    &dibSec,
                                                    &width,
                                                    &height,
                                                    &driver) == FALSE)
                                     goto InitializeHdcOnlyUse;

               // Init Valid now so later calls won't fail

               g->Type         = GraphicsBitmap;
               g->Driver       = driver;
               g->Context->Hdc = hdc;

               // How do we clip and map to correct band?
               // GDI has set the WorldToContainer transform to translate the
               // correct band to position (0,0) on the device surface.  So we
               // clip the size of the band relative to the surface.  The image
               // is mapped via the transform into this clipped region.

               // set visible client clip region for surface

               g->ResetState(0, 0,              // bandClip->left, bandClip->top,
                             bandClip->right - bandClip->left,
                             bandClip->bottom - bandClip->top);

               // Set the destination Graphics to represent device co-ordinates

               g->SetPageTransform(UnitPixel);

               if (g->InheritAppClippingAndTransform(hdc) == Ok)
               {
                   return(g);
               }
               else
               {
                   delete g;
               }
           }
       }
   }

   return(NULL);

}

GpGraphics*
GpGraphics::GetFromGdiEmfDC(
    HDC hdc
    )
{
    ASSERT (hdc != NULL);

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        bitmap->InitializeForMetafile(Globals::DesktopDevice);

        GpGraphics *g = new GpGraphics(bitmap);
        if (g)
        {
            g->Type                  = GraphicsMetafile;
            g->DownLevel             = TRUE;
            g->Driver                = Globals::MetaDriver;
            g->Context->Hdc          = hdc;
            g->Context->IsEmfPlusHdc = TRUE;

            g->ResetState(0, 0, 1, 1);

            // Override some state, as we don't want anything to be
            // clipped out of a metafile, unless there is clipping
            // in the hdc.

            g->WindowClip.SetInfinite();
            g->Context->ContainerClip.SetInfinite();
            g->Context->VisibleClip.SetInfinite();

            if (g->InheritAppClippingAndTransform(hdc) == Ok)
            {
                return g;
            }
            delete g;
        }
    }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*
* Arguments:
*
*
* Return Value:
*
*
* History:
*
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetForMetafile(
    IMetafileRecord *   metafile,
    EmfType             type,
    HDC                 hdc
    )
{
    ASSERT ((metafile != NULL) && (hdc != NULL));

    DpBitmap *bitmap = new DpBitmap(hdc);   // initializes Dpi
    if (CheckValid(bitmap))
    {
        bitmap->InitializeForMetafile(Globals::DesktopDevice);

        GpGraphics *g = new GpGraphics(bitmap);
        if (g)
        {
            g->Type                  = GraphicsMetafile;
            g->Metafile              = metafile;
            g->DownLevel             = (type != EmfTypeEmfPlusOnly);
            g->Driver                = Globals::MetaDriver;
            g->Context->Hdc          = hdc;
            g->Context->IsEmfPlusHdc = TRUE;

            g->ResetState(0, 0, 1, 1);

            // Override some state, as we don't want anything to be
            // clipped out of a metafile

            g->WindowClip.SetInfinite();
            g->Context->ContainerClip.SetInfinite();
            g->Context->VisibleClip.SetInfinite();

            return(g);
        }
    }

    return(NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a GpGraphics class from a DC.
*
* Arguments:
*
*   [IN] hdc - Specifies the DC.
*
* Return Value:
*
*   NULL if failure (such as with an invalid DC).
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpGraphics*
GpGraphics::GetFromHdc(
    HDC hdc,
    HANDLE hDevice
    )
{
    GpGraphics *g = NULL;

    // GetObjectType is nice and fast (entirely user-mode on NT):

    switch (GetDCType(hdc))
    {
    case OBJ_DC:
        if (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASPRINTER )
        {
            g = GpGraphics::GetFromGdiPrinterDC(hdc, hDevice);
        }
        else
        {
            g = GpGraphics::GetFromGdiScreenDC(hdc);
        }

        break;

    case OBJ_MEMDC:
        g = GpGraphics::GetFromGdiBitmap(hdc);
        break;

    case OBJ_ENHMETADC:
        // When metafile spooling, the printer DC will be of type
        // OBJ_ENHMETADC on Win9x and NT4 (but not NT5 due to a fix
        // to NT bug 98810).  We need to do some more work to figure
        // out whether it's really a printer DC or a true metafile
        // DC:

        BOOL printDC;
        
        {   // FPU Sandbox for potentially unsafe FPU code.
            FPUStateSandbox fpsb;
            printDC = Globals::GdiIsMetaPrintDCFunction(hdc);
        }   // FPU Sandbox for potentially unsafe FPU code.
        
        if (printDC)
        {
            g = GpGraphics::GetFromGdiPrinterDC(hdc, hDevice);
        }
        else
        {
            g = GpGraphics::GetFromGdiEmfDC(hdc);
        }
        break;

    case OBJ_METADC:
        TERSE(("16-bit metafile DC support not yet implemented"));
        break;
    }

    return(g);
}

/**************************************************************************\
*
* Function Description:
*
*   Dispose of a GpGraphics object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpGraphics::~GpGraphics()
{
    // How do we ensure that no one is using the graphics when we are here?
    // Flush any pending drawing commands before we go out of scope:

    Flush(FlushIntentionFlush);

    if (IsPrinter())
    {
        EndPrinterEMF();

        if (PrintInit)
            delete PrintInit;
    }

    BOOL    doResetHdc = TRUE;

    // Handle Graphics-type specific functionality:

    switch (Type)
    {
    case GraphicsMetafile:
        if (Metafile != NULL)
        {
            Metafile->EndRecording();
            doResetHdc = FALSE; // EndRecording closes the metafile HDC
        }
        // FALLTHRU

    case GraphicsBitmap:

        // if this is created on a GdipBitmap, dec the ref count
        // delete the bitmap if ref count <= 0

        if (GdipBitmap)
        {
            GdipBitmap->Dispose();
        }
        // We have to delete the temporary surface that we created:

        delete Surface;
        break;
    }

    // Restore the DC that we were derived from (if any).
    // We must NOT do this before the call to EndRecording because
    // EndRecording needs the context->Hdc to be in the saved state
    // so that the transforms are still reset like GDI+ requires.

    if (doResetHdc)
    {
        Context->ResetHdc();
    }

    // Free any device and driver objects that had to be created only for the
    // lifespan of the Graphics object:

    if (CreatedDevice)
    {
        delete Driver;
        delete Device;
    }

    SetValid(FALSE);    // so we don't use a deleted object
}


/**************************************************************************\
*
* Function Description:
*
*   Return a GDI DC handle associated with the current graphics context.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GDI DC handle associated with the current graphics context
*   NULL if there is an error
*
* NOTE: We assume the caller has already obtained a lock on the
*       current graphics context.
*
* NOTE: This function does not return a clean DC!  That is, expect it
*       to have a funky transform, weird ROP mode, etc.  If you want
*       to use this internally, you should probably call Context->GetHdc()
*       directly.
*
\**************************************************************************/

HDC
GpGraphics::GetHdc()
{
    // We must flush the output of the Graphics before returning an HDC.
    this->Flush(FlushIntentionFlush);

    HDC hdc = NULL;

    if (Context->Hdc)
    {
        // If the Graphics was originally derived from an HDC, we simply
        // return back the original HDC (this avoids some issues as to
        // what to do about inherited transforms, etc.).  We may have
        // mucked with some of the DC state, though, so reset it back to
        // what it was originally:

        Context->ResetHdc();

        hdc = Context->Hdc;
    }
    else if (Context->Hwnd)
    {
        // The Graphics was originally derived from an HWND:

        hdc = GetDC(Context->Hwnd);
    }
    else if (Surface && (Surface->Type == DpBitmap::CreationType::GPBITMAP))
    {
        // The GpBitmap is accessible from the EpScanBitmap.  It will
        // create an HDC and GDI bitmap appropriate for interop.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(Surface->Scan);
        hdc = scan->GetBitmap()->GetHdc();
    }

    if (IsRecording() && (hdc != NULL))
    {
        if (IsPrinter())
        {
            EndPrinterEMF();
        }
        else
        {
            GpStatus status = Metafile->RecordGetDC();
        }
    }

    return(hdc);
}

/**************************************************************************\
*
* Function Description:
*
*   Release the GDI DC handle associated with the current graphics context.
*
* Arguments:
*
*   hdc - GDI DC handle returned by a previous GetHdc() call
*
* Return Value:
*
*   NONE
*
* Notes:
*
*   We assume the caller has already obtained a lock on the
*   current graphics context.
*
\**************************************************************************/

VOID
GpGraphics::ReleaseHdc(
    HDC hdc
    )
{
    if (Context->Hdc)
    {
        // The Graphics was originally derived from an HDC.  We don't
        // have to do anything here; ResetHdc() already marked the
        // DC as dirty.
    }
    else if (Context->Hwnd)
    {
        // The Graphics was originally derived from an HWND:

        ReleaseDC(Context->Hwnd, hdc);
    }
    else if (Surface && (Surface->Type == DpBitmap::CreationType::GPBITMAP))
    {
        // The GpBitmap is accessible from the EpScanBitmap.

        EpScanBitmap *scan = static_cast<EpScanBitmap*>(Surface->Scan);
        scan->GetBitmap()->ReleaseHdc(hdc);
    }

    if (IsRecording() && IsPrinter())
    {
        StartPrinterEMF();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Save (push) the graphics context state.  Return the ID of the current
*   state (before the push) for the app to restore to later on.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   gstate - the state to restore the context to later
*
* Created:
*
*   3/4/1999 DCurtis
*
\**************************************************************************/
INT
GpGraphics::Save()
{
    DpContext *     newContext = new DpContext(Context);

    if ((newContext != NULL) &&
        (newContext->AppClip.Set(&(Context->AppClip), TRUE) == Ok) &&
        (newContext->ContainerClip.Set(&(Context->ContainerClip), TRUE)
                                                            == Ok) &&
        (newContext->VisibleClip.Set(&(Context->VisibleClip), TRUE) == Ok))
    {
        INT     gstate = newContext->Id;

        newContext->InverseOk         = Context->InverseOk;
        newContext->PageUnit          = Context->PageUnit;
        newContext->PageScale         = Context->PageScale;
        newContext->PageMultiplierX   = Context->PageMultiplierX;
        newContext->PageMultiplierY   = Context->PageMultiplierY;
        newContext->WorldToPage       = Context->WorldToPage;
        newContext->ContainerToDevice = Context->ContainerToDevice;
        newContext->WorldToDevice     = Context->WorldToDevice;
        newContext->DeviceToWorld     = Context->DeviceToWorld;
        newContext->IcmMode           = Context->IcmMode;
        newContext->GdiLayered        = Context->GdiLayered;

        Context->Next = newContext;
        Context = newContext;

        if (IsRecording())
        {
            GpStatus status = Metafile->RecordSave(gstate);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
            }
        }
        return gstate;
    }

    delete newContext;

    return 0;
}

#define CONTAINER_ID    0x00008000

/**************************************************************************\
*
* Function Description:
*
*   Restore (pop) the context to the state before the specified one.
*
* Arguments:
*
*   gstate - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   3/4/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::Restore(
    INT         gstate
    )
{
    DpContext *     cur = Context;
    DpContext *     prev;

    for (;;)
    {
        if ((prev = cur->Prev) == NULL)
        {
            return;
        }
        if (cur->Id == (UINT)gstate)
        {
            // don't double record EndContainer calls
            if (IsRecording() && ((gstate & CONTAINER_ID) == 0))
            {
                GpStatus status = Metafile->RecordRestore(gstate);
                if (status != Ok)
                {
                    SetValid(FALSE);      // Prevent any more recording
                }
            }
            prev->Next   = NULL;
            prev->SaveDc = cur->SaveDc;
            Context = prev;
            delete cur;
            return;
        }
        cur = prev;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   End a container.  Restores the state back to what it was before the
*   container was started.  The CONTAINER_ID bit is used to make sure that
*   Restore is not used with BeginContainer and that EndContainer is not
*   used with Save.
*
* Arguments:
*
*   [IN] containerState - the pushed container state
*
* Return Value:
*
*   NONE
*
* Created:
*
*   4/7/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::EndContainer(
    INT     containerState
    )
{
    if (IsRecording())
    {
        GpStatus status = Metafile->RecordEndContainer(containerState);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
        }
    }
    Restore(containerState | CONTAINER_ID);
}

/**************************************************************************\
*
* Function Description:
*
*   Begin a container.  This sets the container transform and the
*   container clip based on the current transform and the current clip.
*
*   We have to have a container transform for 2 reasons:
*       1)  If we tried to do it in the world transform, then a call
*           to (Re)SetWorldTransform would erase the container transform.
*
*       2)  We have APIs for setting the text size and the line width that
*           are based on the page units, so they are not affected by the
*           world transform, but they are affected by the container transform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   gstate - the state to restore the context to later
*
* Created:
*
*   3/9/1999 DCurtis
*
\**************************************************************************/

INT
GpGraphics::BeginContainer(
    const GpRectF &     destRect,
    const GpRectF &     srcRect,
    GpPageUnit          srcUnit,
    REAL                srcDpiX,        // only set by metafile enumeration
    REAL                srcDpiY,
    BOOL                srcIsDisplay
    )
{
    GpMatrix        identityMatrix;
    DpContext *     newContext = new DpContext(Context);

    if (newContext == NULL)
    {
        return 0;
    }

    // leave newContext->AppClip set to identity

    if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
        (newContext->ContainerClip.Set(&(Context->AppClip.DeviceRegion),
                                                            TRUE) == Ok) &&
        (newContext->ContainerClip.And(&(Context->ContainerClip)) == Ok) &&
        (newContext->VisibleClip.Set(&(Context->VisibleClip), TRUE) == Ok))
    {
        REAL        unitMultiplierX;
        REAL        unitMultiplierY;
        GpRectF     deviceSrc;

        newContext->GetPageMultipliers(&unitMultiplierX, &unitMultiplierY,
                                       srcUnit);

        deviceSrc.X      = unitMultiplierX * srcRect.X;
        deviceSrc.Y      = unitMultiplierY * srcRect.Y;
        deviceSrc.Width  = unitMultiplierX * srcRect.Width;
        deviceSrc.Height = unitMultiplierY * srcRect.Height;

        if (newContext->ContainerToDevice.InferAffineMatrix(
                           destRect, deviceSrc) == Ok)
        {
            newContext->AntiAliasMode      = 0;
            newContext->TextRenderHint     = TextRenderingHintSystemDefault;
            newContext->TextContrast       = DEFAULT_TEXT_CONTRAST;
            newContext->CompositingMode    = CompositingModeSourceOver;
            newContext->CompositingQuality = CompositingQualityDefault;
            newContext->FilterType         = InterpolationModeDefaultInternal;
            newContext->PixelOffset        = PixelOffsetModeDefault;

            // Note that the world to device transform includes the previous
            // container to device transform.
            newContext->ContainerToDevice.Append(Context->WorldToDevice);
            newContext->InverseOk          = FALSE;
            newContext->PageUnit           = UnitDisplay;
            newContext->PageScale          = 1.0f;
            if ((srcDpiX > 0.0f) && (srcDpiY > 0.0f))
            {
                // When playing a metafile, we have to guarantee that
                // a unit inch is played now as it would have been
                // when it was recorded.  For example, if we recorded
                // the metafile at 300 dpi, then an inch was 300 pixels.
                // Even if we're playing it back to a 96-dpi display,
                // that metafile inch must still be transformed to
                // 300 pixels before going throught the container
                // transformation, so that all graphics are scaled
                // the same, whether pixel units or some other units.
                newContext->ContainerDpiX = srcDpiX;
                newContext->ContainerDpiY = srcDpiY;
                newContext->IsDisplay     = srcIsDisplay;
            }
            newContext->GetPageMultipliers();
            newContext->WorldToPage.Reset();

            // Have to inherit the ICM and layering state:

            newContext->IcmMode           = Context->IcmMode;
            newContext->GdiLayered        = Context->GdiLayered;

            INT     containerState = newContext->Id;
            newContext->Id |= CONTAINER_ID;

            Context->Next = newContext;
            Context = newContext;

            if (IsRecording())
            {
                GpStatus status = Metafile->RecordBeginContainer(destRect,
                                            srcRect, srcUnit, containerState);
                if (status != Ok)
                {
                    SetValid(FALSE);      // Prevent any more recording
                }
            }

            // Do this after switching over the context!
            Context->UpdateWorldToDeviceMatrix();

            return containerState;
        }
    }

    delete newContext;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Begin a container.  This sets the container transform and the
*   container clip based on the current transform and the current clip.
*
*   We have to have a container transform for 2 reasons:
*       1)  If we tried to do it in the world transform, then a call
*           to (Re)SetWorldTransform would erase the container transform.
*
*       2)  We have APIs for setting the text size and the line width that
*           are based on the page units, so they are not affected by the
*           world transform, but they are affected by the container transform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   gstate - the state to restore the context to later
*
* Created:
*
*   3/9/1999 DCurtis
*
\**************************************************************************/

INT
GpGraphics::BeginContainer(
    BOOL                forceIdentityTransform, // only set by metafile player
    REAL                srcDpiX,        
    REAL                srcDpiY,
    BOOL                srcIsDisplay
    )
{
    GpMatrix        identityMatrix;
    DpContext *     newContext = new DpContext(Context);

    if (newContext == NULL)
    {
        return 0;
    }

    // leave newContext->AppClip set to identity

    if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
        (newContext->ContainerClip.Set(&(Context->AppClip.DeviceRegion),
                                       TRUE) == Ok) &&
        (newContext->ContainerClip.And(&(Context->ContainerClip)) == Ok) &&
        (newContext->VisibleClip.Set(&(Context->VisibleClip), TRUE) == Ok))
    {
        // Note that the world to device transform includes the previous
        // container to device transform.
        GpMatrix    worldToDevice = Context->WorldToDevice;
        
        // We append the world to device transform below, which already
        // has the container transform in it.  We don't want to apply
        // the same transform twice, so we need to reset the container
        // transform here.
        newContext->ContainerToDevice.Reset();

        // When playing a GDI+ metafile into another metafile, we have to guarantee
        // that the transform is the identity so that the GDI+ records don't get
        // transformed by GDI+ and then get transformed again by GDI.
        if (forceIdentityTransform)
        {
            worldToDevice.Reset();
        }
        else
        {
            // The coordinates that the container transform is expecting are
            // world coordinates, but they will already have gone through
            // the new page to device transform, so convert from device
            // units back to page units before running them through the
            // the container to device transform.
            // In the routine above, this is done through an inferred transform
            // between device unit src rect and world unit dest rect.
            newContext->ContainerToDevice.Scale(1.0f / Context->PageMultiplierX, 
                                                1.0f / Context->PageMultiplierY);
        }

        newContext->AntiAliasMode        = 0;
        newContext->TextRenderHint       = TextRenderingHintSystemDefault;
        newContext->TextContrast         = DEFAULT_TEXT_CONTRAST;
        newContext->CompositingMode      = CompositingModeSourceOver;
        newContext->CompositingQuality   = CompositingQualityDefault;
        newContext->FilterType           = InterpolationModeDefaultInternal;
        newContext->PixelOffset          = PixelOffsetModeDefault;
        newContext->ContainerToDevice.Append(worldToDevice);
        newContext->InverseOk            = FALSE;
        newContext->PageUnit             = UnitDisplay;
        newContext->PageScale            = 1.0f;

        if ((srcDpiX > 0.0f) && (srcDpiY > 0.0f))
        {
            // When playing a metafile, we have to guarantee that
            // a unit inch is played now as it would have been
            // when it was recorded.  For example, if we recorded
            // the metafile at 300 dpi, then an inch was 300 pixels.
            // Even if we're playing it back to a 96-dpi display,
            // that metafile inch must still be transformed to
            // 300 pixels before going throught the container
            // transformation, so that all graphics are scaled
            // the same, whether pixel units or some other units.
            newContext->ContainerDpiX = srcDpiX;
            newContext->ContainerDpiY = srcDpiY;
            newContext->IsDisplay     = srcIsDisplay;
        }

        newContext->GetPageMultipliers();
        newContext->WorldToPage.Reset();

        // Have to inherit the ICM and layering state:

        newContext->IcmMode           = Context->IcmMode;
        newContext->GdiLayered        = Context->GdiLayered;

        INT     containerState = newContext->Id;
        newContext->Id |= CONTAINER_ID;

        Context->Next = newContext;
        Context = newContext;

        if (IsRecording())
        {
            GpStatus status = Metafile->RecordBeginContainer(containerState);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
            }
        }

        // Do this after switching over the context!
        Context->UpdateWorldToDeviceMatrix();

        return containerState;
    }

    delete newContext;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\compatibledib.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*    Compatible DIBSections
*
* Abstract:
*
*    Create a DIB section with an optimal format w.r.t. the specified hdc.
*    CreateSemiCompatibleDIB makes an exception if the format is <8bpp;
*    in such a case it returns an 8bpp DIBSection.
*
* Notes:
*
* History:
*
*  01/23/1996 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Added it to GDI+ (from Gilman's 'fastdib.c'), and morphed it into 
*     'CreateSemiCompatibleDIB'.
*
\**************************************************************************/

#ifndef _COMPATIBLEDIB_HPP
#define _COMPATIBLEDIB_HPP

PixelFormatID
ExtractPixelFormatFromHDC(
    HDC hdc
    );

HBITMAP 
CreateSemiCompatibleDIB(
    HDC hdc, 
    ULONG ulWidth, 
    ULONG ulHeight,
    ColorPalette *palette,
    PVOID *ppvBits,
    PixelFormatID *pixelFormat
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\customlinecap.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   CustomLineCap.cpp
*
* Abstract:
*
*   Implementation of custom line cap class
*
* Revision History:
*
*   02/21/00 ikkof
*       Created it
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*  
* Function Description:
*
*   ComputeCapLength
*
*   Compute the length of the cap from zero along the + y axis
*   Typically custom caps will return a negative length.
*
* Arguments:
*
*    GpPointF *points,    the points representing the cap path.
*    BYTE *types,         the types  "
*    INT pointCount       how many points in the above arrays.
*
* Return Value:
*   REAL    -- the length.
*
*   08/25/2000 [asecchia]
*       Created it
*
\**************************************************************************/

static REAL ComputeCapLength(
    DpPath * path
)
{
    const GpPointF *points = path->GetPathPoints();
    const BYTE *types = path->GetPathTypes();
    INT pointCount = path->GetPointCount();

    REAL length = 0.0f;
    BOOL isClosed = (types[pointCount-1] & PathPointTypeCloseSubpath) != 0;
    
    // Eliminate degenerate paths and uninitialized paths.
    
    if( points && (pointCount>1) )
    {
        REAL curlength = 0.0f;
        
        GpArrayIterator<GpPointF> pIt(const_cast<GpPointF *>(points), pointCount);
        
        // Get the last item in the list.
        
        pIt.SeekLast();
        GpPointF *lastPoint = pIt.CurrentItem();
        
        // Begin at the first item.
        
        pIt.SeekFirst();
        GpPointF *curPoint;
        
        if(!isClosed)
        {
            // if it's not a closed path, skip the last-to-first point line.
            
            lastPoint = pIt.CurrentItem();
        }
        
        while(!pIt.IsDone())
        {
            curPoint = pIt.CurrentItem();
            
            if(intersect_line_yaxis(*curPoint, *lastPoint, &curlength))
            {
                length = min(length, curlength);
            }
            
            lastPoint = curPoint;
            pIt.Next();
        }
    }
    
    return length;
}

GpStatus GpCustomLineCap::ComputeFillCapLength()
{
    FillLength = -ComputeCapLength(FillPath);
    
    // Fill paths cannot have a length of zero or less.
    
    if(FillLength < REAL_EPSILON)
    {
        return NotImplemented;
    }
    
    return Ok;
}

GpStatus GpCustomLineCap::ComputeStrokeCapLength()
{
    StrokeLength = -ComputeCapLength(StrokePath);
    
    // Stroke paths can have a length of zero - we explicitly check for 
    // this and handle it.
    
    if(StrokeLength < -REAL_EPSILON)
    {
        return NotImplemented;
    }
    
    return Ok;
}

GpCustomLineCap::GpCustomLineCap(
    const DpPath* fillPath,
    const DpPath* strokePath,
    GpLineCap baseCap,
    REAL baseInset
    ) : GpFillPath  (NULL, 0, PointsBuffer1, TypesBuffer1, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex),
        GpStrokePath(NULL, 0, PointsBuffer2, TypesBuffer2, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex)
{
    Initialize();

    GpStatus status = Ok;

    if(fillPath)
    {
        GpPath* gpFillPath = GpPath::GetPath(fillPath);
        status = SetFillPath(gpFillPath);
    }

    if(status == Ok && strokePath)
    {
        GpPath* gpStrokePath = GpPath::GetPath(strokePath);
        status = SetStrokePath(gpStrokePath);
    }

    if(status == Ok)
    {
        switch(baseCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            BaseCap = baseCap;
            break;

        default:
            BaseCap = LineCapFlat;
            break;
        }

        BaseInset = baseInset;
    }
    else
    {
        Reset();
        SetValid(FALSE);
        m_creationStatus = status;  // this defaults to Ok.
    }
}

VOID
GpCustomLineCap::ResetFillPath()
{
    GpFillPath.Reset(FillModeWinding);
}

VOID
GpCustomLineCap::ResetStrokePath()
{
    GpStrokePath.Reset(FillModeWinding);
}

VOID 
GpCustomLineCap::ReverseFillPath()
{
    GpFillPath.Reverse();
}

VOID 
GpCustomLineCap::ReverseStrokePath()
{
    GpStrokePath.Reverse();
}

VOID
GpCustomLineCap::Reset()
{
    // Clean up and reset to the default state.

    Initialize();
    ResetFillPath();
    ResetStrokePath();
}

GpCustomLineCap::GpCustomLineCap(
    const GpCustomLineCap* customCap
    ) : GpFillPath  (NULL, 0, PointsBuffer1, TypesBuffer1, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex),
        GpStrokePath(NULL, 0, PointsBuffer2, TypesBuffer2, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex)
{
    Initialize();

    if(customCap == NULL)
        return;

    GpStatus status = Ok;

    status = SetFillPath(customCap->FillPath);

    if(status == Ok)
        status = SetStrokePath(customCap->StrokePath);

    if(status == Ok)
    {
        GpLineCap baseCap = customCap->BaseCap;

        switch(baseCap)
        {
        case LineCapFlat:
        case LineCapSquare:
        case LineCapRound:
        case LineCapTriangle:
            BaseCap = baseCap;
            break;

        default:
            BaseCap = LineCapFlat;
            break;
        }

        BaseInset = customCap->BaseInset;

        StrokeStartCap = customCap->StrokeStartCap;
        StrokeEndCap = customCap->StrokeEndCap;
        StrokeJoin = customCap->StrokeJoin;
        WidthScale = customCap->WidthScale;
    }
    else
    {
        Reset();
        SetValid(FALSE);
        m_creationStatus = status;  // this defaults to Ok.
    }
}


GpCustomLineCap::~GpCustomLineCap()
{
}

GpStatus 
GpCustomLineCap::SetFillPath(
    const DpPath* path
    )
{
    // If the given path is NULL, empty the fill path.

    if(path == NULL)
    {
        ResetFillPath();
        return Ok;
    }

    INT count = path->GetPointCount();

    return SetFillPath(path->GetPathPoints(), path->GetPathTypes(), count);
}

GpStatus
GpCustomLineCap::SetFillPath(
    const GpPointF* fillPoints,
    const BYTE* fillTypes,
    INT fillCount)
{
    if(fillCount == 0)
    {
        ResetFillPath();
        return Ok;
    }

    if(fillCount <= 2 || fillPoints == NULL || fillTypes == NULL)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(fillPoints);
    pathData.Types = const_cast<BYTE *>(fillTypes);
    pathData.Count = fillCount;

    GpStatus status = FillPath->SetPathData(&pathData);

    if(status == Ok)
    {
        status = ComputeFillCapLength();
    }

    return status;
}

GpStatus
GpCustomLineCap::GetFillPath(
    GpPath* path
    ) const
{
    if(!path)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(FillPath->GetPathPoints());
    pathData.Types  = const_cast<BYTE *>(FillPath->GetPathTypes());
    pathData.Count  = FillPath->GetPointCount();

    return path->SetPathData(&pathData);
}

GpStatus
GpCustomLineCap::SetStrokePath(
    const DpPath* path
    )
{
    // If the given path is NULL, empty the stroke path.

    if(path == NULL)
    {
        ResetStrokePath();
        return Ok;
    }

    INT count = path->GetPointCount();

    return SetStrokePath(path->GetPathPoints(), path->GetPathTypes(), count);
}

GpStatus
GpCustomLineCap::SetStrokePath(
    const GpPointF* strokePoints,
    const BYTE* strokeTypes,
    INT strokeCount)
{
    if(strokeCount == 0)
    {
        ResetStrokePath();
        return Ok;
    }

    if(strokeCount <= 1 || strokePoints == NULL || strokeTypes == NULL)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(strokePoints);
    pathData.Types = const_cast<BYTE *>(strokeTypes);
    pathData.Count = strokeCount;

    GpStatus status = StrokePath->SetPathData(&pathData);

    if(status == Ok)
    {
        status = ComputeStrokeCapLength();
    }

    return status;
}

GpStatus
GpCustomLineCap::GetStrokePath(
    GpPath* path
    ) const
{
    if(!path)
        return InvalidParameter;

    GpPathData pathData;

    pathData.Points = const_cast<GpPointF *>(StrokePath->GetPathPoints());
    pathData.Types  = const_cast<BYTE *>(StrokePath->GetPathTypes());
    pathData.Count  = StrokePath->GetPointCount();

    return path->SetPathData(&pathData);
}

BOOL
GpCustomLineCap::IsEqual(
    const DpCustomLineCap* customLineCap
    ) const
{
    if(!customLineCap)
        return FALSE;

    const GpCustomLineCap* otherCap;
    otherCap = static_cast<const GpCustomLineCap*>(customLineCap);

    return (
        (BaseCap == otherCap->BaseCap) &&
        (BaseInset == otherCap->BaseInset) &&
        (StrokeStartCap == otherCap->StrokeStartCap) &&
        (StrokeEndCap == otherCap->StrokeEndCap) &&
        (StrokeJoin == otherCap->StrokeJoin) &&
        (WidthScale == otherCap->WidthScale) &&
        GpFillPath.IsEqual(&(otherCap->GpFillPath)) &&
        GpStrokePath.IsEqual(&(otherCap->GpStrokePath))
        );
}

INT getTransformedPoints(
    GpPointF* points,
    BYTE* types,
    INT count,
    const GpPointF* srcPoints,
    const BYTE* srcTypes,
    INT srcCount,
    const GpPointF& origin,
    const GpPointF& tangent,
    REAL lineWidth,
    REAL minLineWidth,
    const GpPointF& hotSpot
    )
{
    if(points == NULL && types == NULL)
    {
        return 0;
    }

    ASSERT(srcPoints && srcTypes);

    if(srcPoints == NULL || srcTypes == NULL)
    {
        return 0;
    }

    INT count1 = srcCount;
    if(count1 > count)
    {
        count1 = count;
    }

    if(types)
    {
        GpMemcpy(types, srcTypes, count1);
    }

    // Make sure the line width used for the cap path is
    // larger than the minimum line width.

    REAL width = lineWidth;
    if(lineWidth < minLineWidth)
    {
        width = minLineWidth;
    }

    if(points)
    {
        GpPointF* dstPts = points;
        const GpPointF* srcPts = srcPoints;

        REAL m11, m12, m21, m22, tx, ty;
        m11 = width*tangent.Y;
        m21 = width*tangent.X;
        m12 = - width*tangent.X;
        m22 = width*tangent.Y;
        
        // Adjust the origin according to the hot spot.

        tx = hotSpot.X*(1.0f - width);
        ty = hotSpot.Y*(1.0f - width);
        REAL savedTx = tx;
        tx = tx*tangent.Y + ty*tangent.X + origin.X;
        ty = - savedTx*tangent.X + ty*tangent.Y + origin.Y;

        // Transform the points.

        for(INT i = 0; i < count1; i++)
        {
            dstPts->X = m11*srcPts->X + m21*srcPts->Y + tx;
            dstPts->Y = m12*srcPts->X + m22*srcPts->Y + ty;

            dstPts++;
            srcPts++;
        }
    }

    return count1;
}

INT
GpCustomLineCap::GetTransformedFillCap(
    GpPointF* points,
    BYTE* types,
    INT count,
    const GpPointF& origin,
    const GpPointF& tangent,
    REAL lineWidth,
    REAL minimumWidth
    ) const
{
    INT fillCount = GetFillPointCount();
    
    if(fillCount <= 0)
        return 0;

    // Calculate the minimum line width and hot spot.
    // FillHotSpot is defined relative to the minimumWidth.

    REAL minLineWidth = minimumWidth;
    GpPointF hotSpot;

    hotSpot.X = minimumWidth*FillHotSpot.X;
    hotSpot.Y = minimumWidth*FillHotSpot.Y;

    return getTransformedPoints(
                points,
                types,
                count,
                GetFillPoints(),
                GetFillTypes(),
                fillCount,
                origin,
                tangent,
                lineWidth,
                minLineWidth,
                hotSpot);
}

INT
GpCustomLineCap::GetTransformedStrokeCap(
    INT cCapacity,          // In, initial pPoints & pTypes capacity
    GpPointF ** pPoints,    // In/out, may be reallocated here
    BYTE ** pTypes,         // In/out, may be reallocated here
    INT * pCount,           // In/out, may change here if flattened
    const GpPointF& origin,
    const GpPointF& tangent,
    REAL lineWidth,
    REAL minimumWidth
    ) const
{
    INT strokeCount = GetStrokePointCount();

    if(strokeCount <= 0 || lineWidth <= 0)
        return 0;
	if (!pPoints  ||  !pTypes  ||  !pCount)
        return 0;

    // Calculate the minimum line width and hot spot.
    // StrokeHotSpot is defined relative to the minimumWidth.

    GpPointF hotSpot;

    hotSpot.X = minimumWidth*StrokeHotSpot.X;
    hotSpot.Y = minimumWidth*StrokeHotSpot.Y;

	strokeCount = getTransformedPoints(
                *pPoints,
                *pTypes,
                *pCount,
                GetStrokePoints(),
                GetStrokeTypes(),
                strokeCount,
                origin,
                tangent,
                lineWidth,
                minimumWidth,
                hotSpot);

	// The widener expects a flattened path
	GpPath path(*pPoints, *pTypes, strokeCount, FillModeWinding);
	if (Ok == path.Flatten(NULL, FlatnessDefault))
	{
		// Flattening succeeded
		strokeCount = path.GetPointCount();
		if (strokeCount > cCapacity)
        {
			// Reallocate the points and types arrays
			GpPointF * ptfTemp = (GpPointF*) GpRealloc(*pPoints, 
									strokeCount*sizeof(GpPointF));
			if (ptfTemp)
				*pPoints = ptfTemp;
			else
				strokeCount	= 0;
			BYTE * pbTemp = (BYTE*)GpRealloc(*pTypes, strokeCount);
			if (pbTemp)
				*pTypes = pbTemp;
			else
				strokeCount	= 0;
        }

		if (strokeCount)
		{
			// Replace with the flattened points
			GpMemcpy(*pPoints, path.GetPathPoints(), strokeCount*sizeof(GpPointF));
			GpMemcpy(*pTypes, path.GetPathTypes(), strokeCount);
		}
		*pCount = strokeCount;

    } // end if flattening succeeded
	return strokeCount;
}

REAL
GpCustomLineCap::GetRadius(
    REAL lineWidth,
    REAL minimumWidth
    ) const
{
    INT fillCount = GetFillPointCount();
    INT strokeCount = GetStrokePointCount();

    if((fillCount <= 0 && strokeCount <= 0) || lineWidth <= 0)
        return 0;

    INT maxCount = max(fillCount, strokeCount);

    const INT buffCount = 32;
    GpPointF pointBuff[buffCount];
    BYTE typeBuff[buffCount];
    GpPointF* points = NULL;
    BYTE* types = NULL;

    if(maxCount <= buffCount)
    {
        points = &pointBuff[0];
        types = &typeBuff[0];
    }
    else
    {
        points = (GpPointF*) GpMalloc(maxCount*sizeof(GpPointF));
        types = (BYTE*) GpMalloc(maxCount);
    }

    REAL maxR = 0;

    if(points && types)
    {
        GpPointF origin(0, 0);
        GpPointF tangent(0, 1);

        REAL minLineWidth;
        GpPointF hotSpot;
        REAL d;
        INT count;
        
        if(fillCount > 0)
        {
            // Calculate the minimum line width and hot spot.
            // FillHotSpot is defined relative to the minimumWidth.

            minLineWidth = minimumWidth;

            hotSpot.X = minimumWidth*FillHotSpot.X;
            hotSpot.Y = minimumWidth*FillHotSpot.Y;

            count = getTransformedPoints(
                    points,
                    types,
                    fillCount,
                    GetFillPoints(),
                    GetFillTypes(),
                    fillCount,
                    origin,
                    tangent,
                    lineWidth,
                    minLineWidth,
                    hotSpot);

            REAL i;
            GpPointF* pts = points;
            maxR = pts->X*pts->X + pts->Y*pts->Y;

            for(i = 1, pts++; i < count; i++, pts++)
            {
                d = pts->X*pts->X + pts->Y*pts->Y;

                if(d > maxR)
                    maxR = d;
            }
        }

        if(strokeCount > 0)
        {
            // Calculate the minimum line width and hot spot.
            // FillHotSpot is defined relative to the minimumWidth.

            minLineWidth = minimumWidth;
            hotSpot.X = minimumWidth*StrokeHotSpot.X;
            hotSpot.Y = minimumWidth*StrokeHotSpot.Y;

            count = getTransformedPoints(
                    points,
                    types,
                    strokeCount,
                    GetStrokePoints(),
                    GetStrokeTypes(),
                    strokeCount,
                    origin,
                    tangent,
                    lineWidth,
                    minLineWidth,
                    hotSpot);

            GpPath strokePath(points, types, count, FillModeWinding);
            GpRectF rect;
            strokePath.GetBounds(&rect);
            REAL sharpestAngle = strokePath.GetSharpestAngle();

            REAL delta0 = max(lineWidth*WidthScale, minimumWidth);
            REAL delta = delta0/2;

            if(StrokeJoin == LineJoinMiter ||
               StrokeJoin == LineJoinMiterClipped)
            {
                REAL miterLimit = StrokeMiterLimit;

                delta = delta0*miterLimit;

                if(delta > 20)
                {
                    delta = GpPen::ComputeMiterLength(
                        sharpestAngle,
                        miterLimit
                    );

                    delta *= delta0;
                }
            }

            REAL left, right, top, bottom;
            left = rect.X - delta;
            right = rect.X + delta;
            top = rect.Y - delta;
            bottom = rect.Y + delta;

            d = left*left + top*top;
            if(d > maxR)
                maxR = d;
            d = left*left + bottom*bottom;
            if(d > maxR)
                maxR = d;
            d = right*right + top*top;
            if(d > maxR)
                maxR = d;
            d = right*right + bottom*bottom;
            if(d > maxR)
                maxR = d;            
        }
    }
    else
    {
        //!!! Do something when the memory is not available.
    }

    if(points != &pointBuff[0])
        GpFree(points);

    if(types != &typeBuff[0])
        GpFree(types);

    if(maxR > 0)
        maxR = REALSQRT(maxR);

    return maxR;
}


GpAdjustableArrowCap::GpAdjustableArrowCap(
    const GpAdjustableArrowCap* arrowCap
    ) : GpCustomLineCap(arrowCap)
{
    if(arrowCap)
    {
        Height = arrowCap->Height;
        Width = arrowCap->Width;
        MiddleInset = arrowCap->MiddleInset;
        FillState = arrowCap->FillState;
    }
    else
    {
        SetDefaultValue();
    }
    
    Update();
}

GpStatus
GpAdjustableArrowCap::GetPathData(
    GpPathData* pathData,
    REAL height,
    REAL width,
    REAL middleInset,
    BOOL isFilled
    )
{
    if(pathData == NULL)
        return InvalidParameter;

    GpPointF* points = pathData->Points;
    BYTE* types = pathData->Types;

    points[0].X = width/2;
    points[0].Y = - height;
    points[1].X = 0;
    points[1].Y = 0;
    points[2].X = - width/2;
    points[2].Y = - height;
    points[3].X = 0;
    points[3].Y = - height + middleInset;

    types[0] = PathPointTypeStart;
    types[1] = PathPointTypeLine;
    types[2] = PathPointTypeLine;
    types[3] = PathPointTypeLine;

    INT lastIndex = 2;

    if(middleInset != 0 && isFilled)
        lastIndex = 3;

    if(isFilled)
        types[lastIndex] |= PathPointTypeCloseSubpath;

    pathData->Count = lastIndex + 1;

    return Ok;
}

GpStatus
GpAdjustableArrowCap::Update()
{
    GpPointF points[4];
    BYTE types[4];
    GpPathData pathData;
    pathData.Points = &points[0];
    pathData.Types = &types[0];
    pathData.Count = 3;

    BaseCap   = LineCapTriangle;
    BaseInset = (Width != 0) ? (Height / Width) : 0;

    GetPathData(&pathData, Height, Width, MiddleInset, FillState);

    GpPath path(FillModeWinding);
    path.SetPathData(&pathData);

    if(FillState)
    {
        // Fill path only.

        SetFillPath(&path);
        SetStrokePath(NULL);
    }
    else
    {
        // Stroke path only.

        SetStrokePath(&path);
        SetFillPath(NULL);
    }

    return Ok;
}

ObjectType 
GpCustomLineCap::GetObjectType() const 
{
    return ObjectTypeCustomLineCap;
}

#define GDIP_CAPFLAGS_FILLPATH        0x00000001
#define GDIP_CAPFLAGS_STROKEPATH      0x00000002

class CustomLineCapData : public ObjectTypeData
{
public:
    INT32               Flags;
    INT32               BaseCap;
    REAL                BaseInset;
    INT32               StrokeStartCap;
    INT32               StrokeEndCap;
    INT32               StrokeJoin;
    REAL                StrokeMiterLimit;
    REAL                WidthScale;
    GpPointF            FillHotSpot;
    GpPointF            StrokeHotSpot;
};

UINT 
GpCustomLineCap::GetDataSize() const 
{ 
    ASSERT(IsValid());

    UINT            size           = sizeof(CustomLineCapData);
    INT             fillPathSize   = 0;
    INT             strokePathSize = 0;
    
    if ((GetFillPointCount() > 2) &&
        ((fillPathSize = FillPath->GetDataSize()) > 0))
    {
        ASSERT((fillPathSize & 0x03) == 0);
        size += sizeof(INT32) + fillPathSize;
    }
        
    if ((GetStrokePointCount() > 2) &&
        ((strokePathSize = StrokePath->GetDataSize()) > 0))
    {
        ASSERT((strokePathSize & 0x03) == 0);
        size += sizeof(INT32) + strokePathSize;
    }

    return size;
}

GpStatus 
GpCustomLineCap::GetData(
    IStream *       stream
    ) const 
{ 
    ASSERT(IsValid());

    INT             flags          = 0;
    INT             fillPathSize   = 0;
    INT             strokePathSize = 0;
    
    if ((GetFillPointCount() > 2) &&
        ((fillPathSize = FillPath->GetDataSize()) > 0))
    {
        ASSERT((fillPathSize & 0x03) == 0);
        flags |= GDIP_CAPFLAGS_FILLPATH;
    }
        
    if ((GetStrokePointCount() > 2) &&
        ((strokePathSize = StrokePath->GetDataSize()) > 0))
    {
        ASSERT((strokePathSize & 0x03) == 0);
        flags |= GDIP_CAPFLAGS_STROKEPATH;
    }

    CustomLineCapData   capData;
    
    capData.Type             = GetType();
    capData.Flags            = flags;
    capData.BaseCap          = BaseCap;
    capData.BaseInset        = BaseInset;
    capData.StrokeStartCap   = StrokeStartCap;
    capData.StrokeEndCap     = StrokeEndCap;
    capData.StrokeJoin       = StrokeJoin;
    capData.StrokeMiterLimit = StrokeMiterLimit;
    capData.WidthScale       = WidthScale;
    capData.FillHotSpot      = FillHotSpot;
    capData.StrokeHotSpot    = StrokeHotSpot;
    
    stream->Write(&capData, sizeof(capData), NULL);

    if (flags & GDIP_CAPFLAGS_FILLPATH)
    {
        stream->Write(&fillPathSize, sizeof(INT32), NULL);
        FillPath->GetData(stream);
    }

    if (flags & GDIP_CAPFLAGS_STROKEPATH)
    {
        stream->Write(&strokePathSize, sizeof(INT32), NULL);
        StrokePath->GetData(stream);
    }

    return Ok; 
}

GpStatus 
GpCustomLineCap::SetData(
    const BYTE *    dataBuffer, 
    UINT            size
    ) 
{ 
    this->Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(CustomLineCapData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const CustomLineCapData *   capData;
    capData = reinterpret_cast<const CustomLineCapData *>(dataBuffer);

    ASSERT((CustomLineCapType)(capData->Type) == CustomLineCapTypeDefault);

    if (!capData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    BaseCap          = (GpLineCap)capData->BaseCap;
    BaseInset        = capData->BaseInset;
    StrokeStartCap   = (GpLineCap)capData->StrokeStartCap;
    StrokeEndCap     = (GpLineCap)capData->StrokeEndCap;
    StrokeJoin       = (GpLineJoin)capData->StrokeJoin;
    StrokeMiterLimit = capData->StrokeMiterLimit;
    WidthScale       = capData->WidthScale;
    FillHotSpot      = capData->FillHotSpot;
    StrokeHotSpot    = capData->StrokeHotSpot;

    dataBuffer += sizeof(CustomLineCapData);
    size       -= sizeof(CustomLineCapData);

    GpStatus    status = Ok;

    if (capData->Flags & GDIP_CAPFLAGS_FILLPATH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT    pathSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < pathSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        if ((status = FillPath->SetData(dataBuffer, pathSize)) != Ok)
        {
            return status;
        }

        if(Ok == status)
        {
            status = ComputeFillCapLength();
        }

        dataBuffer += pathSize;
        size       -= pathSize;
    }

    if (capData->Flags & GDIP_CAPFLAGS_STROKEPATH)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        UINT    pathSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < pathSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        status = StrokePath->SetData(dataBuffer, pathSize);

        if(Ok == status)
        {
            status = ComputeStrokeCapLength();
        }

        dataBuffer += pathSize;
        size       -= pathSize;
    }

    UpdateUid();
    return status;
}

class AdjustableArrowCapData : public ObjectTypeData
{
public:
    REAL                Width;
    REAL                Height;
    REAL                MiddleInset;
    INT32               FillState;
    INT32               StrokeStartCap;
    INT32               StrokeEndCap;
    INT32               StrokeJoin;
    REAL                StrokeMiterLimit;
    REAL                WidthScale;
    GpPointF            FillHotSpot;
    GpPointF            StrokeHotSpot;
};

UINT 
GpAdjustableArrowCap::GetDataSize() const 
{ 
    ASSERT(IsValid());

    return sizeof(AdjustableArrowCapData);
}

GpStatus 
GpAdjustableArrowCap::GetData(
    IStream *       stream
    ) const 
{ 
    ASSERT(IsValid());

    AdjustableArrowCapData   arrowCapData;

    arrowCapData.Type             = GetType();
    arrowCapData.Width            = Width;
    arrowCapData.Height           = Height;
    arrowCapData.MiddleInset      = MiddleInset;
    arrowCapData.FillState        = FillState;
    arrowCapData.StrokeStartCap   = StrokeStartCap;
    arrowCapData.StrokeEndCap     = StrokeEndCap;
    arrowCapData.StrokeJoin       = StrokeJoin;
    arrowCapData.StrokeMiterLimit = StrokeMiterLimit;
    arrowCapData.WidthScale       = WidthScale;
    arrowCapData.FillHotSpot      = FillHotSpot;
    arrowCapData.StrokeHotSpot    = StrokeHotSpot;
    
    stream->Write(&arrowCapData, sizeof(arrowCapData), NULL);
    
    return Ok;
}

GpStatus 
GpAdjustableArrowCap::SetData(
    const BYTE *    dataBuffer, 
    UINT            size
    ) 
{ 
    this->Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(AdjustableArrowCapData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const AdjustableArrowCapData *   arrowCapData;
    arrowCapData = reinterpret_cast<const AdjustableArrowCapData *>(dataBuffer);

    ASSERT((CustomLineCapType)(arrowCapData->Type) == CustomLineCapTypeAdjustableArrow);

    if (!arrowCapData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    Width            = arrowCapData->Width;
    Height           = arrowCapData->Height;
    MiddleInset      = arrowCapData->MiddleInset;
    FillState        = arrowCapData->FillState;
    StrokeStartCap   = (GpLineCap)arrowCapData->StrokeStartCap;
    StrokeEndCap     = (GpLineCap)arrowCapData->StrokeEndCap;
    StrokeJoin       = (GpLineJoin)arrowCapData->StrokeJoin;
    StrokeMiterLimit = arrowCapData->StrokeMiterLimit;
    WidthScale       = arrowCapData->WidthScale;
    FillHotSpot      = arrowCapData->FillHotSpot;
    StrokeHotSpot    = arrowCapData->StrokeHotSpot;

    this->Update();

    UpdateUid();
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\compatibledib.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*    Compatible DIBSections
*
* Abstract:
*
*    Create a DIB section with an optimal format w.r.t. the specified hdc.
*    If the hdc format is <8bpp, returns an 8bpp DIBSection.
*    If the hdc format is not recognized, returns a 32bpp DIBSection.
*
* Notes:
*
* History:
*
*  01/23/1996 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Added it to GDI+ (from Gilman's 'fastdib.c'), and morphed it into 
*     'CreateSemiCompatibleDIB'.
*  08/10/2000 agodfrey
*     Hacked it further so that if we don't understand the format, we make
*     a 32bpp section. Bug #96879. 
*
\**************************************************************************/

#include "precomp.hpp"
#include "compatibleDIB.hpp"


const DWORD AlphaMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x00000000, // PixelFormat16bppRGB555
    0x00000000, // PixelFormat16bppRGB565
    0x00008000, // PixelFormat16bppARGB1555
    0x00000000, // PixelFormat24bppRGB
    0x00000000, // PixelFormat32bppRGB
    0xff000000, // PixelFormat32bppARGB
    0xff000000, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x00000000  // PixelFormat24bppBGR
};

const DWORD RedMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x00007c00, // PixelFormat16bppRGB555
    0x0000f800, // PixelFormat16bppRGB565
    0x00007c00, // PixelFormat16bppARGB1555
    0x00ff0000, // PixelFormat24bppRGB
    0x00ff0000, // PixelFormat32bppRGB
    0x00ff0000, // PixelFormat32bppARGB
    0x00ff0000, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x000000ff  // PixelFormat24bppBGR
};

const DWORD GreenMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x000003e0, // PixelFormat16bppRGB555
    0x000007e0, // PixelFormat16bppRGB565
    0x000003e0, // PixelFormat16bppARGB1555
    0x0000ff00, // PixelFormat24bppRGB
    0x0000ff00, // PixelFormat32bppRGB
    0x0000ff00, // PixelFormat32bppARGB
    0x0000ff00, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x0000ff00  // PixelFormat24bppBGR
};

const DWORD BlueMaskFromPixelFormatIndex[PIXFMT_MAX] = {
    0x00000000, // PixelFormatUndefined
    0x00000000, // PixelFormat1bppIndexed
    0x00000000, // PixelFormat4bppIndexed
    0x00000000, // PixelFormat8bppIndexed
    0x00000000, // PixelFormat16bppGrayScale
    0x0000001f, // PixelFormat16bppRGB555
    0x0000001f, // PixelFormat16bppRGB565
    0x0000001f, // PixelFormat16bppARGB1555
    0x000000ff, // PixelFormat24bppRGB
    0x000000ff, // PixelFormat32bppRGB
    0x000000ff, // PixelFormat32bppARGB
    0x000000ff, // PixelFormat32bppPARGB
    0x00000000, // PixelFormat48bppRGB
    0x00000000, // PixelFormat64bppARGB
    0x00000000, // PixelFormat64bppPARGB
    0x00ff0000  // PixelFormat24bppBGR
};


/**************************************************************************\
* CreatePBMIFromPixelFormat
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by analyzing the pixelFormat
*
* Arguments:
*    OUT pbmi : this must point to a valid BITMAPINFO structure
*               which has enough space for the palette (RGBQUAD array)
*               and MUST be zero initialized.
*    palette  : Input palette that will be copied into the BITMAPINFO
*               if it's a palettized mode.
*    pixelFormat : Input pixel format.
*  
*
* History:
*  06/07/1995 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Munged it for GDI+'s needs.
*  08/11/2000 asecchia
*     Extracted the pixel format detection into a separate routine.
*     It now analyzes the pixelformat for all its data.
*
\**************************************************************************/

static VOID
CreatePBMIFromPixelFormat(
    OUT BITMAPINFO *pbmi,
    IN ColorPalette *palette, 
    IN PixelFormatID pixelFormat
    )
{
    // NOTE: Contents of pbmi should be zero initialized by the caller.
    
    ASSERT(pbmi != NULL);    
    if(pixelFormat == PixelFormatUndefined) { return; }
    
    // GDI can't handle the following formats: 
    
    ASSERT(
        pixelFormat != PixelFormatUndefined &&
        pixelFormat != PixelFormat16bppGrayScale &&
        pixelFormat != PixelFormat16bppARGB1555 &&
        pixelFormat != PixelFormat48bppRGB &&
        pixelFormat != PixelFormat64bppARGB &&
        pixelFormat != PixelFormat64bppPARGB
    );
 
    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = 0;
    pbmi->bmiHeader.biHeight = 0;
    pbmi->bmiHeader.biPlanes = 1;    
    pbmi->bmiHeader.biBitCount = (WORD)GetPixelFormatSize(pixelFormat);
        
    pbmi->bmiHeader.biCompression = BI_RGB;
    
    if (IsIndexedPixelFormat(pixelFormat))
    {        
        // Fill the color table

        // If there's no palette, assume the caller is going to 
        // set it up.
                
        if(palette)
        {
            RGBQUAD *rgb = pbmi->bmiColors;
            UINT         i;
            
            for (i=0; i<palette->Count; i++, rgb++)
            {
               GpColor color(palette->Entries[i]);
            
               rgb->rgbRed    = color.GetRed();
               rgb->rgbGreen  = color.GetGreen();
               rgb->rgbBlue   = color.GetBlue();
            }
        }
    }
    else
    {
        INT pfSize = GetPixelFormatSize(pixelFormat);
        
        if( (pfSize==16) || (pfSize==32) )
        {
            // BI_BITFIELDS is only valid on 16- and 32-bpp formats.
            
            pbmi->bmiHeader.biCompression = BI_BITFIELDS;
        }
        
        // Get the masks from the 16bpp, 24bpp and 32bpp formats.
        DWORD* masks = reinterpret_cast<DWORD*>(&pbmi->bmiColors[0]);
        INT formatIndex = GetPixelFormatIndex(pixelFormat);
        
        masks[0] = RedMaskFromPixelFormatIndex[formatIndex];
        masks[1] = GreenMaskFromPixelFormatIndex[formatIndex];
        masks[2] = BlueMaskFromPixelFormatIndex[formatIndex];
    }
}

/**************************************************************************\
* CreateSemiCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DC format <= 8bpp, creates an 8bpp section using the specified palette.
* If the palette handle is NULL, then the system palette is used.
*
* Otherwise, if the DC format is not natively supported, creates a 32bpp
* section.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Arguments:
*
*   hdc                 - The reference hdc
*   ulWidth             - The width of the desired DIBSection
*   ulHeight            - The height of the desired DIBSection
*   palette             - The palette for <=8bpp modes
*   [OUT] ppvBits       - A pointer to the DIBSection's bits
*   [OUT] pixelFormat   - The pixel format of the returned DIBSection
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  01/23/1996 gilmanw
*     Created it.
*  01/21/2000 agodfrey
*     Munged it for GDI+'s needs.
*  08/11/2000 asecchia
*     Call more general pixel format determination code.
\**************************************************************************/

HBITMAP 
CreateSemiCompatibleDIB(
    HDC hdc,
    ULONG ulWidth, 
    ULONG ulHeight,
    ColorPalette *palette,
    PVOID *ppvBits,
    PixelFormatID *pixelFormat
    )
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    ASSERT(GetDCType(hdc) == OBJ_DC);
    ASSERT(pixelFormat && ppvBits);

    // Zero initialize the pbmi. This is a requirement for 
    // CreatePBMIFromPixelFormat()
    
    GpMemset(aj, 0, sizeof(aj));

    *pixelFormat = ExtractPixelFormatFromHDC(hdc);
    
    if(IsIndexedPixelFormat(*pixelFormat))
    {
        // For indexed modes, we only support 8bpp. Lower bit-depths
        // are supported via 8bpp mode, if at all.
        
        *pixelFormat = PixelFormat8bppIndexed;
    }

    // Not all printer HDC's have queriable palettes, the GpDevice()
    // constructor doesn't support it.  Fake 32bpp in this case.
    
    // Also, if the format is undefined, use 32bpp, and the caller will use
    // GDI to do the conversion.
    
    if (   (   (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASPRINTER)
            && (IsIndexedPixelFormat(*pixelFormat))
           )
        || (*pixelFormat == PixelFormatUndefined)
       )
    {
        *pixelFormat = PixelFormat32bppRGB;
    }
    
    CreatePBMIFromPixelFormat(pbmi, palette, *pixelFormat);
    
    // Change bitmap size to match specified dimensions.

    pbmi->bmiHeader.biWidth = ulWidth;
    pbmi->bmiHeader.biHeight = ulHeight;
    if (pbmi->bmiHeader.biCompression == BI_RGB)
    {
        pbmi->bmiHeader.biSizeImage = 0;
    }
    else
    {
        if ( pbmi->bmiHeader.biBitCount == 16 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
        else if ( pbmi->bmiHeader.biBitCount == 32 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
        else
            pbmi->bmiHeader.biSizeImage = 0;
    }
    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    // Create the DIB section.  Let Win32 allocate the memory and return
    // a pointer to the bitmap surface.

    hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

    if ( !hbmRet )
    {
        ONCE(WARNING(("CreateSemiCompatibleDIB: CreateDIBSection failed")));
    }

    return hbmRet;
}

/**************************************************************************\
* ExtractPixelFormatFromHDC
* 
* Returns:
*   PixelFormatID if successful, PixelFormatUndefined if not.
*
* History:
*  08/11/2000 asecchia
*     Created it.
\**************************************************************************/

PixelFormatID
ExtractPixelFormatFromHDC(
    HDC hdc
    )
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;
    PixelFormatID pixelFormat = PixelFormatUndefined;
    
    BYTE bmi_buf[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) bmi_buf;
    
    GpMemset(bmi_buf, 0, sizeof(bmi_buf));
    
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        // Call first time to fill in BITMAPINFO header.

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        // First handle the 'simple' case of indexed formats.
        
        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            switch(pbmi->bmiHeader.biBitCount)
            {
            case 1: pixelFormat = PixelFormat1bppIndexed; break;
            case 4: pixelFormat = PixelFormat4bppIndexed; break;
            case 8: pixelFormat = PixelFormat8bppIndexed; break;
            
            // Fallthrough on default - the pixelFormat is already
            // initialized to PixelFormatUndefined.
            default: 
                WARNING((
                    "BitDepth %d from GetDIBits is not supported.", 
                    pbmi->bmiHeader.biBitCount
                ));                
            }
        }
        else
        {
            DWORD redMask = 0;
            DWORD greenMask = 0;
            DWORD blueMask = 0;
            
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".

                GetDIBits(
                    hdc, 
                    hbm, 
                    0, 
                    pbmi->bmiHeader.biHeight, 
                    NULL, 
                    pbmi,
                    DIB_RGB_COLORS
                );
                          
                DWORD* masks = reinterpret_cast<DWORD*>(&pbmi->bmiColors[0]);

                redMask = masks[0];
                greenMask = masks[1];
                blueMask = masks[2];          
            }
            else if (pbmi->bmiHeader.biCompression == BI_RGB)
            {
               redMask   = 0x00ff0000;
               greenMask = 0x0000ff00;
               blueMask  = 0x000000ff;
            }
            
            if ((redMask   == 0x00ff0000) &&
                (greenMask == 0x0000ff00) &&
                (blueMask  == 0x000000ff))
            {
                if (pbmi->bmiHeader.biBitCount == 24)
                {
                    pixelFormat = PixelFormat24bppRGB;
                }
                else if (pbmi->bmiHeader.biBitCount == 32)
                {
                    pixelFormat = PixelFormat32bppRGB;
                }
            }
            else if ((redMask   == 0x000000ff) &&
                     (greenMask == 0x0000ff00) &&
                     (blueMask  == 0x00ff0000) &&
                     (pbmi->bmiHeader.biBitCount == 24))
            {
                pixelFormat = PIXFMT_24BPP_BGR;
            }            
            else if ((redMask   == 0x00007c00) &&
                     (greenMask == 0x000003e0) &&
                     (blueMask  == 0x0000001f) &&
                     (pbmi->bmiHeader.biBitCount == 16))
            {
                pixelFormat = PixelFormat16bppRGB555;
            }
            else if ((redMask   == 0x0000f800) &&
                     (greenMask == 0x000007e0) &&
                     (blueMask  == 0x0000001f) &&
                     (pbmi->bmiHeader.biBitCount == 16))
            {
                pixelFormat = PixelFormat16bppRGB565;
            }
        }

        if (pixelFormat == PixelFormatUndefined)
        {
            ONCE(WARNING(("(once) ExtractPixelFormatFromHDC: Unrecognized pixel format")));
        }

        DeleteObject(hbm);
    }
    else
    {
        WARNING(("ExtractPixelFormatFromHDC: CreateCompatibleBitmap failed"));
    }

    return pixelFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\copyonwritebitmap.hpp ===
#ifndef _COPYONWRITEBITMAP_HPP
#define _COPYONWRITEBITMAP_HPP

class CopyOnWriteBitmap : private CopyOnWrite
{
friend class GpBitmap;

private:

    // Constructors

    CopyOnWriteBitmap(const WCHAR* filename);
    CopyOnWriteBitmap(IStream* stream);
    CopyOnWriteBitmap(INT width, INT height, PixelFormatID format);
    CopyOnWriteBitmap(INT width, INT height, PixelFormatID format, GpGraphics * graphics);
    CopyOnWriteBitmap(
        INT width,
        INT height,
        INT stride,     // negative for bottom-up bitmaps
        PixelFormatID format,
        BYTE *  scan0
        );
    CopyOnWriteBitmap(
        BITMAPINFO* gdiBitmapInfo,
        VOID* gdiBitmapData,
        BOOL ownBitmapData
        );
    CopyOnWriteBitmap(IDirectDrawSurface7 *surface);

    static VOID CheckValid(CopyOnWriteBitmap *& p)
    {
        if ((p == NULL) || (!p->IsValid()))
        {
            delete p;
            p = NULL;
        }
    }

    static CopyOnWriteBitmap * Create(const WCHAR* filename)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(filename);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(IStream* stream)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(stream);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(INT width, INT height, PixelFormatID format)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(width, height, format);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(INT width, INT height, PixelFormatID format, GpGraphics * graphics)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(width, height, format, graphics);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(
        INT width,
        INT height,
        INT stride,     // negative for bottom-up bitmaps
        PixelFormatID format,
        BYTE *  scan0
        )
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(width, height, stride, format, scan0);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(
        BITMAPINFO* gdiBitmapInfo,
        VOID* gdiBitmapData,
        BOOL ownBitmapData
        )
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(gdiBitmapInfo, gdiBitmapData, ownBitmapData);
        CheckValid(newBitmap);
        return newBitmap;
    }

    static CopyOnWriteBitmap * Create(IDirectDrawSurface7 *surface)
    {
        CopyOnWriteBitmap * newBitmap = new CopyOnWriteBitmap(surface);
        CheckValid(newBitmap);
        return newBitmap;
    }

    CopyOnWriteBitmap*
    Clone(
        const GpRect* rect,
        PixelFormatID format = PixelFormat32bppPARGB
    ) const;

    virtual CopyOnWrite * Clone() const
    {
        return Clone(NULL, PixelFormatDontCare);
    }

    CopyOnWriteBitmap*
    CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         type = ColorAdjustTypeDefault
        ) const;

    GpStatus
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    GpStatus
    GetEncoderParameterList(
        IN  CLSID* clsidEncoder,
        IN  UINT size,
        OUT EncoderParameters* pBuffer
        );

    GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    DoSave(
        IStream* stream,
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );
    
    GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        );

    GpStatus
    SaveAdd(
        CopyOnWriteBitmap*        newBits,
        const EncoderParameters*  encoderParams
        );

    // Dispose the bitmap object

    VOID Dispose()
    {
        if (InterlockedDecrement(&ObjRefCount) <= 0)
        {
            this->Release();
        }
    }

    // Get bitmap information

    VOID GetImageInfo(ImageInfo * imageInfo)
    {
        ASSERT(imageInfo != NULL);
        GpMemcpy(imageInfo, &SrcImageInfo, sizeof(ImageInfo));
    }

    CopyOnWriteBitmap* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                          GetThumbnailImageAbort callback,
                          VOID *callbackData);
    GpStatus GetFrameCount(const GUID* dimensionID,
                           UINT* count)                      const;
    GpStatus GetFrameDimensionsCount(OUT UINT* count)        const;
    GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                    IN UINT count)          const;
    GpStatus SelectActiveFrame(const GUID*  dimensionID,
                               UINT frameIndex);
    GpStatus GetPalette(ColorPalette *palette, INT size);
    GpStatus SetPalette(ColorPalette *palette);
    INT      GetPaletteSize();
    GpStatus GetTransparencyHint(DpTransparency* transparency);

    GpStatus SetTransparencyHint(DpTransparency transparency);

    GpStatus GetTransparencyFlags(DpTransparency* transparency,
                                  PixelFormatID loadFormat =PixelFormatDontCare,
                                  BYTE* minA = NULL,
                                  BYTE* maxA = NULL);

    // Property related functions

    GpStatus GetPropertyCount(UINT* numOfProperty);
    GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list);
    GpStatus GetPropertyItemSize(PROPID propId, UINT* size);
    GpStatus GetPropertyItem(PROPID propId,UINT propSize,
                             PropertyItem* buffer);
    GpStatus GetPropertySize(UINT* totalBufferSize,UINT* numProperties);
    GpStatus GetAllPropertyItems(UINT totalBufferSize,
                                 UINT numProperties,
                                 PropertyItem* allItems);
    GpStatus RemovePropertyItem(PROPID propId);
    GpStatus SetPropertyItem(PropertyItem* item);

    // Check if the CopyOnWriteBitmap object is valid

    virtual BOOL IsValid() const
    {
        return (State != Invalid);
    }

    // Retrieve bitmap data

    GpStatus
    LockBits(
        const GpRect* rect,
        UINT flags,
        PixelFormatID pixelFormat,
        BitmapData* bmpdata,
        INT width = 0,
        INT height = 0
    ) const;   // Does not change the image

    GpStatus
    UnlockBits(
        BitmapData* bmpdata,
        BOOL Destroy=FALSE
    ) const;

    // Get and set pixel on the bitmap.
    GpStatus GetPixel(INT x, INT y, ARGB *color);
    GpStatus SetPixel(INT x, INT y, ARGB color);

    // Derive an HDC for interop on top of the bitmap object

    HDC GetHdc();
    VOID ReleaseHdc(HDC hdc);

    // Serialization

    UINT GetDataSize() const;
    GpStatus GetData(IStream * stream) const;
    GpStatus SetData(const BYTE * dataBuffer, UINT size);

    GpStatus GetCompressedData(
            DpCompressedData * compressed_data,
            BOOL getJPEG = TRUE,
            BOOL getPNG = TRUE,
            HDC hdc = (HDC)NULL);

    GpStatus DeleteCompressedData(
            DpCompressedData * compressed_data) ;


    // Image transform

    GpStatus RotateFlip(
        RotateFlipType rfType
        );

    // Color adjust

    GpStatus ColorAdjust(
        GpRecolor *     recolor,
        ColorAdjustType type
        );

    GpStatus
    ColorAdjust(
        GpRecolor * recolor,
        PixelFormatID pixfmt,
        DrawImageAbort callback,
        VOID *callbackData
        );

    GpStatus GetPixelFormatID(PixelFormatID* pixfmt);

    enum
    {
        Invalid = 0,        // bitmap object is invalid
        ImageRef = 1,       // contains a reference only (e.g. filename)
        ExtStream = 2,      // contains a reference to a stream
        DecodedImg = 3,     // contains a decoded image object,
                            // but it's not decoded yet - name is misleading.
        MemBitmap = 4       // contains an in-memory bitmap object
    };

    GpStatus SetResolution(REAL xdpi, REAL ydpi);

    GpStatus
    PreDraw(
        INT numPoints,
        GpPointF *dstPoints,
        GpRectF *srcRect,
        INT numBitsPerPixel
        );

    // Interop:

    static GpStatus CreateFromHBITMAP(
        HBITMAP hbm,
        HPALETTE hpal,
        CopyOnWriteBitmap** bitmap
        );

    GpStatus CreateHBITMAP(HBITMAP *phbm, ARGB background);

    GpStatus Recolor(
        GpRecolor *recolor,
        CopyOnWriteBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    GpStatus ICMFrontEnd(
        CopyOnWriteBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    static GpStatus CreateFromHICON(
        HICON hicon,
        CopyOnWriteBitmap** bitmap
        );

    GpStatus CreateHICON(HICON *phicon);

    static GpStatus CreateFromResource(
        HINSTANCE hInstance,
        LPWSTR lpBitmapName,
        CopyOnWriteBitmap** bitmap
        );

private:
    CopyOnWriteBitmap(GpMemoryBitmap* membmp);
    
    mutable INT State;          // current state of the bitmap object
    mutable LONG ObjRefCount;   // object reference count used for LockBits
    WCHAR* Filename;
    IStream* Stream;
    mutable GpDecodedImage* Img;
    mutable GpMemoryBitmap* Bmp;
    UINT    CurrentFrameIndex;  // Frame index, zero based
    VOID* cleanupBitmapData;    // Bitmap(BITMAPINFO*, ...) ctor will
                                // set this if dtor should cleanup buffer
    IImageEncoder*  EncoderPtr; // Pointer to encoder pointer for saving
                                // multi-frame images
                                // Note: CopyOnWriteBitmap has to hold this pointer
                                // and do the close later. This is because
                                // 1) Both Bmp and Img will be destroied when
                                // navigating among frames
                                // 2) It is possible that sometime we call
                                // Img->SaveAppend and sometime for
                                // Bmp->SaveAppend, depends on if the frame is
                                // dirty or not.
                                // It make sense that 1 CopyOnWriteBitmap talks to 1
                                // encoder at a time
    BOOL SpecialJPEGSave;       // TRUE if do special lossless JPEG transform
    BOOL ICMConvert;            // TRUE if we should do ICM on this bitmap

    // We need to know how to handle the page transform when it is set
    // to UnitDisplay.  If Display is TRUE (which is the default), then
    // the page transform will be the identity, which is what we want
    // most of the time.  The only exception is when the image is
    // derived from a non-display graphics.
    BOOL Display;               // Set UnitDisplay to identity transform?
    REAL XDpiOverride;          // if non-zero, replaces native dpi
    REAL YDpiOverride;          // if non-zero, replaces native dpi
                                // supports scan interface to CopyOnWriteBitmap
                                // when drawing to bitmap via a Graphics
    mutable BOOL DirtyFlag;     // TRUE if the image bits got modified
    ImageInfo   SrcImageInfo;   // Image info for the source image
    mutable PixelFormatID PixelFormatInMem;
                                // Pixel format in the memory
                                // For example, if the source image is 4 bpp, we
                                // load it into memory as 32 PARGB. This
                                // variable will be set to 32PARGB.
    mutable BOOL HasChangedRequiredPixelFormat;
                                // Flag to remember if we have hacked the color
                                // formats or not in LoadIntoMemory(). Then this
                                // format will be restored in ICMFrontEnd() if
                                // this flag is TRUE

    struct                      // Interop data (information used to return
    {                           // an HDC that can draw into this CopyOnWriteBitmap)
        HDC     Hdc;
        HBITMAP Hbm;

        VOID*   Bits;
        INT_PTR Stride;
        INT     Width;
        INT     Height;
    } InteropData;


    VOID FreeData();            // called by destructor

    // Destructor
    //  We don't want apps to use delete operator directly.
    //  Instead, they should use Dispose method so that
    //  we can take care of reference counting.

    ~CopyOnWriteBitmap();

    // Initialize the bitmap object to its initial state

    VOID InitDefaults()
    {
        State = Invalid;
        ObjRefCount = 1;
        Filename = NULL;
        Stream = NULL;
        Img = NULL;
        Bmp = NULL;
        InteropData.Hdc = NULL;
        InteropData.Hbm = NULL;
        CurrentFrameIndex = 0;
        cleanupBitmapData = NULL;
        DirtyFlag = FALSE;
        XDpiOverride = 0.0f;          // if non-zero, replaces native dpi
        YDpiOverride = 0.0f;          // if non-zero, replaces native dpi
        ICMConvert = FALSE;           // default is don't do ICM (it's slow)
        SpecialJPEGSave = FALSE;

        // We must always treat the bitmap as if it is a display so that
        // the default page transform (in a graphics constructed from
        // the image) is the identity.  The only time we don't do this
        // is if the bitmap is contructed from a graphics that is not
        // associated with a display.  In that case, we want the image
        // to inherit the display property from the graphics so that
        // drawing to the image and drawing to the original graphics
        // will work the same, i.e. will have a similar page transform.
        Display = TRUE;
        EncoderPtr = NULL;
        PixelFormatInMem = PixelFormatUndefined;

        HasChangedRequiredPixelFormat = FALSE;
        GpMemset(&SrcImageInfo, 0, sizeof(ImageInfo));
    }

    // Convert the pixel data of a bitmap object
    // to the specified format

    GpStatus ConvertFormat(PixelFormatID format,
        DrawImageAbort callback = NULL,
        VOID *callbackData = NULL
        );

    // Perform color adjustment by the lower level codec if it can do it

    GpStatus
    ColorAdjustByCodec(
        GpRecolor * recolor,
        DrawImageAbort callback,
        VOID *callbackData
        );

    // Set decode parameters for icons

    GpStatus
    SetIconParameters(
        INT numPoints,
        GpPointF *dstPoints,
        GpRectF *srcRect,
        INT numBitsPerPixel
        );

    CopyOnWriteBitmap()
    {
        InitDefaults();
    }

    // Dereference the stream or file pointer and promote this bitmap object
    // to at least DecodedImg state.
    GpStatus CopyOnWriteBitmap::DereferenceStream() const;

    // Load bitmap image into memory
    // width and height are the suggested width and height to decode into.
    // zero means use the source width and height.

    GpStatus LoadIntoMemory(
        PixelFormatID format = PixelFormat32bppPARGB,
        DrawImageAbort callback = NULL,
        VOID *callbackData = NULL,
        INT width = 0,
        INT height = 0
    ) const;

    VOID SetDirtyFlag(BOOL flag) const
    {
        DirtyFlag = flag;
    }

    BOOL    IsDirty() const
    {
        return DirtyFlag;
    }

    VOID TerminateEncoder()
    {
        if ( EncoderPtr != NULL )
        {
            EncoderPtr->TerminateEncoder();
            EncoderPtr->Release();
            EncoderPtr = NULL;
        }
    }

    GpStatus ValidateMultiFrameSave();
    GpStatus ParseEncoderParameter(
        const EncoderParameters*    encoderParams,
        BOOL*                       pfIsMultiFrameSave,
        BOOL*                       pfSpecialJPEG,
        RotateFlipType*             rfType
        );
    GpStatus TransformThumbanil(
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams,
        PropertyItem **ppOriginalItem
        );

    VOID CacheImageInfo(HRESULT hr);

private:
    GpStatus SaveAppend(
        const EncoderParameters* encoderParams,
        IImageEncoder* EncoderPtr
        );
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\customlinecap.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   CustomLineCap.hpp
*
* Abstract:
*
*   Class used for the custom line caps.
*
* Revision History:
*
*   02/21/00 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _CUSTOMLINECAP_HPP
#define _CUSTOMLINECAP_HPP

#define CLCAP_BUFFER_SIZE    16

class GpCustomLineCap : public DpCustomLineCap
{
friend class GpObject;
protected:
    // This is used by the object factory
    GpCustomLineCap(
        ) : GpFillPath  (NULL, 0, PointsBuffer1, TypesBuffer1, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex),
            GpStrokePath(NULL, 0, PointsBuffer2, TypesBuffer2, CLCAP_BUFFER_SIZE, FillModeWinding, DpPath::PossiblyNonConvex)
    { 
        Initialize(); 
    }

public:

    GpCustomLineCap(
        const DpPath* fillPath,
        const DpPath* strokePath,
        GpLineCap baseCap = LineCapFlat,
        REAL baseInset = 0
        );

    virtual ObjectType GetObjectType() const;
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual CustomLineCapType GetType() const
    {
        return CustomLineCapTypeDefault;
    }
    
    GpStatus SetFillPath(const DpPath* path);

    GpStatus SetFillPath(
        const GpPointF* fillPoints,
        const BYTE* fillTypes,
        INT fillCount);

    GpStatus GetFillPath(GpPath* fillPath) const;

    GpStatus SetStrokePath(const DpPath* path);

    GpStatus SetStrokePath(
        const GpPointF* strokePoints,
        const BYTE* strokeTypes,
        INT strokeCount);

    GpStatus GetStrokePath(GpPath* strokePath) const;

    virtual BOOL IsEqual(const DpCustomLineCap* customLineCap) const;

    virtual INT GetTransformedFillCap(
            GpPointF* points,
            BYTE* types,
            INT count,
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL minimumWidth
            ) const;

    virtual INT GetTransformedStrokeCap(
            INT cCapacity,       // In, initial pPoints & pTypes capacity
            GpPointF ** pPoints, // In/out, may be reallocated here
            BYTE ** pTypes,      // In/out, may be reallocated here
            INT * pCount,        // In/out, may change here if flattened
            const GpPointF& origin,
            const GpPointF& tangent,
            REAL lineWidth,
            REAL minimumWidth
            ) const;
            
    virtual REAL GetRadius(
            REAL lineWidth,
            REAL minimumWidth
            ) const;

    ~GpCustomLineCap();

    virtual GpCustomLineCap* Clone() const
    {
        return new GpCustomLineCap(this);
    }
    
    // Get the lock object
    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

    VOID ReverseFillPath();
    VOID ReverseStrokePath();
    
    GpStatus GetCreationStatus()
    {
        return m_creationStatus;
    }
    
protected:

    GpCustomLineCap(const GpCustomLineCap* customCap);

    VOID Initialize()
    {
        FillPath   = &GpFillPath;
        StrokePath = &GpStrokePath;

        FillLength = 0.0f;
        StrokeLength = 0.0f;
        BaseCap = LineCapFlat;
        BaseInset = 0;

        StrokeStartCap = LineCapFlat;
        StrokeEndCap = LineCapFlat;
        StrokeJoin = LineJoinMiter;
        StrokeMiterLimit = 10;
        WidthScale = 1;

        FillHotSpot.X = 0;
        FillHotSpot.Y = 0;
        StrokeHotSpot.X = 0;
        StrokeHotSpot.Y = 0;
        
        m_creationStatus = Ok;
        
        SetValid(TRUE);
    }

    VOID Reset();

    VOID ResetFillPath();

    VOID ResetStrokePath();

    GpStatus ComputeFillCapLength();
    GpStatus ComputeStrokeCapLength();
    
protected:
    GpLockable Lockable;
    GpPath GpFillPath;
    GpPath GpStrokePath;
    GpPointF PointsBuffer1[CLCAP_BUFFER_SIZE];
    GpPointF PointsBuffer2[CLCAP_BUFFER_SIZE];
    BYTE TypesBuffer1[CLCAP_BUFFER_SIZE];
    BYTE TypesBuffer2[CLCAP_BUFFER_SIZE];
    
    GpStatus m_creationStatus;  // check this if IsValid() == FALSE 
};


class GpAdjustableArrowCap : public GpCustomLineCap
{
friend class GpObject;
private:
    // This is only used by the object factory
    GpAdjustableArrowCap()
    {
        SetDefaultValue();
        Update();
    }

public:
    GpAdjustableArrowCap(REAL height, REAL width, BOOL isFilled = TRUE)
    {
        Height = height;
        Width = width;
        MiddleInset = 0;
        FillState = isFilled;

        Update();
    }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    CustomLineCapType GetType() const
    {
        return CustomLineCapTypeAdjustableArrow;
    }
    
    GpStatus SetHeight(REAL height)
    {
        if(Height == height)
            return Ok;

        Height = height;
        return Update();
    }

    REAL GetHeight() const { return Height; }

    GpStatus SetWidth(REAL width)
    {
        if(Width == width)
            return Ok;

        Width = width;
        return Update();
    }

    REAL GetWidth() const { return Width; }

    GpStatus SetMiddleInset(REAL middleInset)
    {
        if(MiddleInset == middleInset)
            return Ok;

        MiddleInset = middleInset;
        return Update();
    }

    REAL GetMiddleInset() const { return MiddleInset; }

    GpStatus SetFillState(BOOL isFilled)
    {
        if(FillState == isFilled)
            return Ok;

        FillState = isFilled;
        return Update();
    }

    BOOL IsFilled() const {return FillState;}

    virtual GpCustomLineCap* Clone() const
    {
        return new GpAdjustableArrowCap(this);
    }

protected:

    GpAdjustableArrowCap(const GpAdjustableArrowCap* customCap);

    VOID SetDefaultValue()
    {
        Height = 2;
        Width = 2;
        MiddleInset = 0;
        FillState = TRUE;
    }

    GpStatus GetPathData(
        GpPathData* pathData,
        REAL height,
        REAL width,
        REAL middleInset,
        BOOL isFilled
        );

    GpStatus Update();

protected:
    REAL Width;
    REAL Height;
    REAL MiddleInset;
    BOOL FillState;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\device.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Internal class representing the device.
*
* Revision History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _DEVICE_HPP
#define _DEVICE_HPP

//--------------------------------------------------------------------------
// Represents the underlying physical device
//--------------------------------------------------------------------------

class GpDevice
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDevice : ObjectTagInvalid;
    }

public:

    // Buffer data:

    INT BufferWidth;            // Buffer width in pixels, 0 if there are no
                                // buffers or they couldn't be allocated
    HBITMAP DIBSectionBitmap;
    HDC DIBSectionHdc;
    VOID *DIBSection;
    VOID *Buffers[5];
    PixelFormatID BufferFormat;

    // Scan interfaces:

    EpScanEngine ScanEngine;    // For accessing bitmap formats that are 
                                // directly writeable by GDI+
    EpScanGdiDci *ScanGdi;      // For accessing bitmap formats that are not
                                // directly accessible by GDI+, via GDI
                                // BitBlt calls
    EpScanGdiDci *ScanDci;      // For accessing the screen directly

    HDC DeviceHdc;              // Owned DC representing specific
                                // device

    HMONITOR hMonitor;          // Handle to monitor.  This is set if the
                                // device represents a physical device
                                // associated with monitor on the system.

                                // WARNING: current code uses hMonitor != NULL
                                // to indicate that GpDevice was created via
                                // GpDevice(HMONITOR) and that deletion of
                                // DeviceHdc is owned by destructor.  If
                                // somebody wants to change this, then they
                                // will need to fix how DeviceHdc is managed.

    INT ScreenOffsetX;          // Offset to screen for this device.  Needed
    INT ScreenOffsetY;          // to support multimon.  NOTE, currently we
                                // have not found a good way to derive the
                                // screen position of the monitor specific
                                // hdc.  If we find a way to get this
                                // from the DeviceHdc then we can remove
                                // this state.

    INT ScreenWidth;            // Width and Height of screen space.  There
    INT ScreenHeight;           // is probably a better place to store this
                                // information but we'll stick it here for
                                // now.  TODO - find a better place

    IDirectDraw7 * pdd;         // Direct Draw Interface for device
    IDirect3D7 * pd3d;          // Direct 3D Interface for device
    IDirectDrawSurface7 * pdds; // Direct draw primary surface of device

    IDirect3DDevice7 * pd3dDevice; // D3D device for monitor device
    IDirectDrawSurface7 * pddsRenderTarget; 
                                // Current render target that is
                                // selected into the D3D device

    ColorPalette * Palette;     // System palette color table

public:

    GpDevice(HDC hdc);
    GpDevice(HMONITOR hMonitor);

    // Allow subclass devices to cleanup before deleting DC
    virtual ~GpDevice();

    virtual BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDevice) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Device");
        }
    #endif

        return (Tag == ObjectTagDevice);
    }

    BOOL
    GetScanBuffers(
        INT width,
        VOID **dibSection        = NULL,
        HDC *hdcDibSection       = NULL,
        PixelFormatID *dstFormat = NULL,
        VOID *buffers[5]         = NULL
        );
    
    GpSemaphore DeviceLock;

private:

    static BOOL EnumDirectDrawCallback(
        GUID *      lpGUID,
        LPSTR       lpDriverDescription,
        LPSTR       lpDriverName,
        LPVOID      lpContext,
        HMONITOR    hMonitor);
                                       
};

class GpDeviceList 
{
public:

    GpDeviceList(void);
    ~GpDeviceList(void);

    GpStatus AddDevice(GpDevice * device);

    GpDevice * FindD3DDevice(IDirectDrawSurface7 * surface);

private:

#if 0
    void Build(void);

    static HRESULT EnumD3DDevicesCallback(LPSTR lpDevDesc,
                                   LPSTR lpDevName,
                                   LPD3DDEVICEDESC7 * d3dDevDesc,
                                   LPVOID lpConetxt);
#endif

    INT         mNumDevices;
    GpDevice ** mDevices;

};


//--------------------------------------------------------------------------
// Represents the underlying physical device
//--------------------------------------------------------------------------

class GpPrinterDevice : public GpDevice
{
public:

    // !! Split into two classes, we don't want to inherit the scan goop
    //    from above.  Don't forget DeviceLock->Initialize()

    EpScanDIB ScanPrint;

public:

    GpPrinterDevice(HDC hdc) : GpDevice(hdc) {};
    virtual ~GpPrinterDevice() 
    {
        // Don't delete the printer HDC
        DeviceHdc = NULL;
    };
};

//--------------------------------------------------------------------------
// GpDevice lock
//--------------------------------------------------------------------------

class Devlock
{
private:
    GpSemaphore *DeviceLock;

public:
    Devlock(GpDevice *device)
    {
        DeviceLock = &device->DeviceLock;
        DeviceLock->Lock();
    }
    
    ~Devlock()
    {
        DeviceLock->Unlock();
    }
};

#endif // !_DEVICE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\device.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Handle all the device associations.
*
* Revision History:
*
*   12/03/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "compatibledib.hpp"

BOOL gbUseD3DHAL = TRUE;
/**************************************************************************\
*
* Function Description:
*
*   Creates a GpDevice class that represents the (meta) desktop.
*
* Arguments:
*
*   [IN] hdc - Owned DC representing the device.  Note that this has to
*              live for the lifetime of this 'GpDevice' object.  Caller
*              is responsible for deletion or management of the HDC.
*
* Return Value:
*
*   IsValid() is FALSE in the event of failure.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpDevice::GpDevice(
    HDC hdc
    )
{
    hMonitor = NULL;
    Buffers[0] = NULL;

    __try
    {
        DeviceLock.Initialize();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        WARNING(("Unable to allocate the DeviceLock"));
        SetValid(FALSE);
        return;
    }

    DeviceHdc = hdc;
    BufferWidth = 0;

    DIBSectionBitmap = NULL;
    DIBSection = NULL;
    ScanDci = NULL;
        
    pdd = NULL;
    pd3d = NULL;
    pdds = NULL;
    pd3dDevice = NULL;

    DIBSectionHdc = CreateCompatibleDC(hdc);

    if ((GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY) &&
        (GetDeviceCaps(hdc, BITSPIXEL)  <= 8))
    {
        // Query and cache color palette
        
        // !!! [agodfrey] This is hard to maintain. We have much the same
        //     palette code spread all over the place. It should be abstracted
        //     into a single location. I've marked each instance with
        //     <SystemPalette>.
        
        Palette = (ColorPalette*) GpMalloc(sizeof(ColorPalette) + sizeof(ARGB)*256);
       
        if (Palette == NULL) 
        {
            WARNING(("Unable to allocate color palette"));
            SetValid(FALSE);
            return;
        }

        INT i;
        INT numEntries;
        PALETTEENTRY palEntry[256];

        // [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
        //    doesn't do what MSDN says it does. It seems to return the number
        //    of entries in the logical palette of the DC instead. So we have
        //    to make it up ourselves.
        
        numEntries = (1 << (GetDeviceCaps(hdc, BITSPIXEL) * 
                            GetDeviceCaps(hdc, PLANES)));

        ASSERT(numEntries <= 256); 
 
        GetSystemPaletteEntries(hdc, 0, numEntries, &palEntry[0]);
           
        Palette->Count = numEntries;
        for (i=0; i<numEntries; i++) 
        {
             Palette->Entries[i] = Color::MakeARGB(0xFF,
                                                   palEntry[i].peRed,
                                                   palEntry[i].peGreen,
                                                   palEntry[i].peBlue);
        }
    }
    else
    {
        Palette = NULL;
    }

    ScreenOffsetX = 0;
    ScreenOffsetY = 0;

    ScreenWidth = GetDeviceCaps(hdc,  HORZRES);
    ScreenHeight = GetDeviceCaps(hdc, VERTRES);

    ScanDci = new EpScanGdiDci(this, TRUE);
    ScanGdi = new EpScanGdiDci(this);

    SetValid((ScanDci != NULL) && (ScanGdi != NULL) && (DIBSectionHdc != NULL));
}

/**************************************************************************\
*
* Function Description:
*
*   Creates a GpDevice class that represents a device associated with
*   a particular monitor on the desktop.
*
* Arguments:
*
*   [IN] hMonitor - Identifies the monitor on the system.
*
* Return Value:
*
*   IsValid() is FALSE in the event of failure.
*
* History:
*
*   10/13/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDevice::GpDevice(
    HMONITOR inMonitor
    )
{
    hMonitor = NULL;
    Buffers[0] = NULL;
    
    MONITORINFOEXA   mi;
    
    mi.cbSize = sizeof(mi);

    DIBSectionBitmap = NULL;
    DIBSection = NULL;
    ScanDci = NULL;
    ScanGdi = NULL;

    pdd = NULL;
    pd3d = NULL;
    pdds = NULL;
    pd3dDevice = NULL;

    DIBSectionHdc = NULL;
    Palette = NULL;
        
    __try
    {
        DeviceLock.Initialize();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        WARNING(("Unable to allocate the DeviceLock"));
        SetValid(FALSE);
        return;
    }
    
    SetValid(FALSE);

    if(Globals::GetMonitorInfoFunction == NULL)
    {
        WARNING(("GpDevice with HMONITOR called with no multi-monitor support"));
    }
    else if(Globals::GetMonitorInfoFunction(inMonitor, &mi))
    {
        HDC hdc;

        if (Globals::IsNt)
        {
            hdc = CreateDCA("Display", mi.szDevice, NULL, NULL);
        }
        else
        {
            hdc = CreateDCA(NULL, mi.szDevice, NULL, NULL);
        }
        
        // Note: because we created the hdc, the ~GpDevice destructor is
        // responsible for for its deletion.  We currently recognize this
        // case by a non-NULL hMonitor.

        if(hdc != NULL)
        {
            hMonitor = inMonitor;

            DeviceHdc = hdc;
            BufferWidth = 0;

            DIBSectionHdc = CreateCompatibleDC(hdc);

            if ((GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY) &&
                (GetDeviceCaps(hdc, BITSPIXEL)  <= 8))
            {
                // Query and cache color palette
                // <SystemPalette>
        
                Palette = (ColorPalette*) GpMalloc(sizeof(ColorPalette) + sizeof(ARGB)*256);
                
                if (Palette == NULL) 
                {
                    WARNING(("Unable to allocate color palette"));
                    return;
                }
        
                INT i;
                INT numEntries;
                PALETTEENTRY palEntry[256];
                        
                // [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
                //    doesn't do what MSDN says it does. It seems to return the number
                //    of entries in the logical palette of the DC instead. So we have
                //    to make it up ourselves.
                
                numEntries = (1 << (GetDeviceCaps(hdc, BITSPIXEL) *
                                    GetDeviceCaps(hdc, PLANES)));

                ASSERT(numEntries <= 256);
        
                GetSystemPaletteEntries(hdc, 0, numEntries, &palEntry[0]);
                    
                Palette->Count = numEntries;
                for (i=0; i<numEntries; i++) 
                {
                     Palette->Entries[i] = Color::MakeARGB(0xFF,
                                                           palEntry[i].peRed,
                                                           palEntry[i].peGreen,
                                                           palEntry[i].peBlue);
                }
            }

            ScreenOffsetX = mi.rcMonitor.left;
            ScreenOffsetY = mi.rcMonitor.top;

            ScreenWidth = (mi.rcMonitor.right - mi.rcMonitor.left);
            ScreenHeight = (mi.rcMonitor.bottom - mi.rcMonitor.top);

            ScanDci = new EpScanGdiDci(this, TRUE);
            ScanGdi = new EpScanGdiDci(this);

#if HW_ACCELERATION_SUPPORT

            if(InitializeDirectDrawGlobals())
            {
                HRESULT hr = Globals::DirectDrawEnumerateExFunction(
                                GpDevice::EnumDirectDrawCallback,
                                this,
                                DDENUM_ATTACHEDSECONDARYDEVICES);

                if(pdd == NULL)
                {
                    // This could happen if this is a single monitor
                    // machine. Try again to create the DirectDraw Object.
                    hr = Globals::DirectDrawCreateExFunction(NULL,
                                                    &pdd,
                                                    IID_IDirectDraw7,
                                                    NULL);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to create monitor Direct Draw interface"));
                    }

                    hr = pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to set cooperative level for monitor device"));
                        pdd->Release();
                        pdd = NULL;
                    }
                }

                if(pdd != NULL)
                {
                    DDSURFACEDESC2  sd;

                    memset(&sd, 0, sizeof(sd));
                    sd.dwSize = sizeof(sd);

                    sd.dwFlags = DDSD_CAPS;
                    sd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_3DDEVICE;

                    hr = pdd->CreateSurface(&sd, &pdds, NULL);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to create primary surface for monitor"));
                    }

                    hr = pdd->QueryInterface(IID_IDirect3D7, (void **) &pd3d);

                    if(hr != DD_OK)
                    {
                        WARNING(("Unable to get monitor D3D interface"));
                    }

                    if(pd3d != NULL && pdds != NULL)
                    {

                        if(gbUseD3DHAL)
                            hr = pd3d->CreateDevice(IID_IDirect3DHALDevice, pdds, &pd3dDevice);
                        else
                            hr = pd3d->CreateDevice(IID_IDirect3DRGBDevice, pdds, &pd3dDevice);

                        if(hr != DD_OK)
                        {
                            WARNING(("Unable to create D3D device"));
                        }

                        if(pd3dDevice != NULL)
                        {
                            pddsRenderTarget = pdds;

                            hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_ZENABLE, 0);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, 0);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_SHADEMODE, D3DSHADE_FLAT);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_CLIPPING, FALSE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_LIGHTING, FALSE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_CULLMODE,     D3DCULL_NONE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_DITHERENABLE, FALSE);
        
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND,     D3DBLEND_SRCALPHA);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND,     D3DBLEND_INVSRCALPHA);
                            if(hr == DD_OK) hr = pd3dDevice->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, FALSE);
        
                            // Setup viewport
        
                            D3DVIEWPORT7 viewData;
        
                            viewData.dwX = 0;
                            viewData.dwY = 0;
                            viewData.dwWidth  = ScreenWidth;
                            viewData.dwHeight = ScreenHeight;
                            viewData.dvMinZ = 0.0f;
                            viewData.dvMaxZ = 1.0f;
        
                            if(hr == DD_OK) hr = pd3dDevice->SetViewport(&viewData);
        
                            if(hr != DD_OK)
                            {
                                WARNING(("Failed setting default D3D state"));
                                pd3d->Release();
                                pd3d = NULL;
                            }

                        }

                    }

                }

            }

#endif // HW_ACCELERATION_SUPPORT

            SetValid((ScanDci != NULL) && (ScanGdi != NULL) && (DIBSectionHdc != NULL));
            
        }
        else
        {
            WARNING(("Failed creating HDC from HMONITOR"));
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Callback function used to D3D Device Enumeration  
*
* Arguments:
*
*   See D3D SDK
*
* Return Value:
*
*   See D3D SDK
*
* History:
*
*   10/11/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL GpDevice::EnumDirectDrawCallback(
    GUID *      lpGUID,
    LPSTR       lpDriverDescription,
    LPSTR       lpDriverName,
    LPVOID      lpContext,
    HMONITOR    hMonitor)
{
    GpDevice * device = (GpDevice *) lpContext;

    if(device->hMonitor == hMonitor && lpGUID)
    {
        HRESULT hr = Globals::DirectDrawCreateExFunction(lpGUID,
                                                    &device->pdd,
                                                    IID_IDirectDraw7,
                                                    NULL);

        if(hr != DD_OK)
        {
            WARNING(("Unable to create monitor Direct Draw interface"));
        }

        hr = device->pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL);

        if(hr != DD_OK)
        {
            WARNING(("Unable to set cooperative level for monitor device"));
            device->pdd->Release();
            device->pdd = NULL;
        }

        return(FALSE);
        
    }

    return(TRUE);
}

/**************************************************************************\
*
* Function Description:
*
*   Destroys a GpDevice class.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpDevice::~GpDevice(
    VOID
    )
{
    DeviceLock.Uninitialize();

#if 0
    // !!!TODO: Find out why we are getting an access fault when we try and
    //          release the pd3d7 interface
    if(pd3dDevice != NULL)
        pd3dDevice->Release();

    if(pd3d != NULL)
        pd3d->Release();
#endif

    if(pdds != NULL)
        pdds->Release();

    if(pdd != NULL)
        pdd->Release();

    DeleteObject(DIBSectionBitmap);
    DeleteDC(DIBSectionHdc);

    if (hMonitor != NULL)
    {
        // If GpDevice was created by the GpDevice(HMONITOR) contructor,
        // then the HDC was created by the object.  Therefore, in that case
        // the destructor is responsible for deletion.

        if (DeviceHdc != NULL)
        {
            DeleteDC(DeviceHdc);
        }
    }

    GpFree(Buffers[0]);
    GpFree(Palette);
    
    delete ScanDci;
    delete ScanGdi;

    SetValid(FALSE);    // so we don't use a deleted object
}

/**************************************************************************\
*
* Function Description:
*
*   Returns 5 scan buffers of a specified width, from a cache in
*   the device.
*
*   One is a DIBSection which is compatible with the device (or 8bpp if
*   the device format is smaller than 8bpp.)
*
* Arguments:
*
*   [IN] width - Specifies the requested width in pixels
*   [OUT] [OPTIONAL] dibSection - Returns the pointer to the DIBSection
*   [OUT] [OPTIONAL] hdcDibSection - Returns an HDC to the DIBSection
*   [OUT] [OPTIONAL] dstFormat - Returns the format of the DIBSection.
*   [OUT] [OPTIONAL] buffers - Returns an array of 5 pointers to
*                    buffers, each big enough to hold <width> pixels in 64bpp.
*
* Return Value:
*
*   FALSE if there was an allocation error.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*   01/21/2000 agodfrey
*       Changed it to create just 1 DIBSection, and 4 memory buffers.
*
\**************************************************************************/

BOOL
GpDevice::GetScanBuffers(
    INT width,
    VOID **dibSection,
    HDC *hdcDibSection,
    PixelFormatID *dstFormat,
    VOID *buffers[5]
    )
{
    // If BufferWidth is 0 this means that the DIBSectionBitmap should be
    // recreated.  This is used, for instance, when switching bit depths
    // to a palettized format.
    if (width > BufferWidth)
    {
        if (DIBSectionBitmap != NULL)
        {
            DeleteObject(DIBSectionBitmap);
        }

        DIBSectionBitmap = CreateSemiCompatibleDIB(
            DeviceHdc, 
            width, 
            1, 
            Palette,
            &DIBSection,
            &BufferFormat);

        if (DIBSectionBitmap)
        {
            BufferWidth = width;
        
            SelectObject(DIBSectionHdc, DIBSectionBitmap);

        }
        else
        {
            BufferWidth = 0;
        }
        
        // Allocate the 5 memory buffers from one chunk.
        
        if (Buffers[0])
        {
            GpFree(Buffers[0]);
        }
        
        Buffers[0] = GpMalloc(sizeof(ARGB64) * width * 5);
        if (Buffers[0])
        {
            int i;
            for (i=1;i<5;i++)
            {
                Buffers[i] = static_cast<BYTE *>(Buffers[i-1]) + 
                             sizeof(ARGB64) * width;
            }
        }
        else
        {
            BufferWidth = 0;
        }
    }
    
    if (dibSection != NULL)
    {
        *dibSection = DIBSection;
    }
    if (hdcDibSection != NULL)
    {
        *hdcDibSection = DIBSectionHdc;
    }
    if (buffers != NULL)
    {
        int i;
        for (i=0;i<5;i++)
        {
            buffers[i] = Buffers[i];
        }
    }
    if (dstFormat != NULL)
    {
        *dstFormat = BufferFormat;
    }

    return(BufferWidth != 0);
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor of GpDeviceList  
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDeviceList::GpDeviceList()
{
    mNumDevices = 0;
    mDevices = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Destructor of GpDeviceList  
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDeviceList::~GpDeviceList()
{
    GpFree(mDevices);
}

/**************************************************************************\
*
* Function Description:
*
*   Add device to device list.  
*
* Arguments:
*
*   inDevice - device to add
*
* Return Value:
*
*   Ok if device was successfully added otherwise OutOfMemory
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/


GpStatus GpDeviceList::AddDevice(GpDevice * inDevice)
{
    GpDevice ** newList = (GpDevice **) GpMalloc((mNumDevices + 1) * sizeof(GpDevice *));

    if(newList == NULL)
        return OutOfMemory;

    memcpy(newList, mDevices, (mNumDevices * sizeof(GpDevice *)));
    newList[mNumDevices++] = inDevice;

    GpFree(mDevices);

    mDevices = newList;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add device to device list.  
*
* Arguments:
*
*   inSurface - surface for which we need to find matching D3DDevice
*
* Return Value:
*
*   GpDevice if found otherwise NULL
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/

GpDevice * GpDeviceList::FindD3DDevice(IDirectDrawSurface7 * inSurface)
{
    HRESULT     hr;
    IUnknown *  unknown;

    hr = inSurface->GetDDInterface((void **) &unknown);

    if(hr != DD_OK)
        return NULL;

    IDirectDraw7 * pddMatch;

    hr = unknown->QueryInterface(IID_IDirectDraw7, (void **) &pddMatch);

    if(hr != DD_OK)
        return NULL;

#if 0
    IDirect3D7 * pd3dMatch;

    hr = pddMatch->QueryInterface(IID_IDirect3D7, (void **) &pd3dMatch);

    if(hr != DD_OK)
    {
        pddMatch->Release();
        return NULL;
    }

    GpDevice * device = NULL;

    for(INT i = 0; i < mNumDevices; i++)
    {
        if(mDevices[i]->pd3d == pd3dMatch)
        {
            device = mDevices[i];
            break;
        }
    }

    pd3dMatch->Release();
#else
    GpDevice * device = NULL;

    for(INT i = 0; i < mNumDevices; i++)
    {
        if(mDevices[i]->pdd == pddMatch)
        {
            device = mDevices[i];
            break;
        }
    }
#endif

    pddMatch->Release();

    return device;
}

#if 0
/**************************************************************************\
*
* Function Description:
*
*   Callback function used to D3D Device Enumeration  
*
* Arguments:
*
*   See D3D SDK
*
* Return Value:
*
*   See D3D SDK
*
* History:
*
*   10/11/1999 bhouse
*       Created it.
*
\**************************************************************************/

HRESULT GpDeviceList::EnumD3DDevicesCallback(
    LPSTR lpDevDesc,
    LPSTR lpDevName,
    LPD3DDEVICEDESC7 * d3dDevDesc,
    LPVOID lpContext)
{
    GpDeviceList * devList = (GpDeviceList *) lpContext;


}

/**************************************************************************\
*
* Function Description:
*
*   Build a device list.  
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/08/1999 bhouse
*       Created it.
*
\**************************************************************************/


void GpDeviceList::Build(void)
{
    if(!InitializeDirectDrawGlobals())
        return;

    HRESULT hr;

    hr = Globals::Direct3D->EnumDevices(EnumD3DDevicesCallback, this);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\dpbitmap.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Device bitmap APIs and internals.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "compatibleDIB.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Temporary function to see if the bitmap is a standard format type
*   (5-5-5, 5-6-5, 24bpp or 32bpp).
*
* Notes:
*
*   Code which calls this assumes that there are no standard formats which
*   support alpha.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::StandardFormat(
    VOID
    )
{
    INT BitsPerPixel = GetPixelFormatSize(PixelFormat);
    BOOL standardFormat = FALSE;

    if ((RedMask == 0x00ff0000) &&       
        (GreenMask == 0x0000ff00) &&     
        (BlueMask == 0x000000ff))        
    {                                             
        if (BitsPerPixel == 24)          
        {                                         
            standardFormat = TRUE;
        }                                         
        else if (BitsPerPixel == 32)     
        {
            standardFormat = TRUE;
        }
    }
    else if ((RedMask == 0x00007c00) &&  
             (GreenMask == 0x000003e0) &&
             (BlueMask == 0x0000001f) && 
             (BitsPerPixel == 16))       
    {
        standardFormat = TRUE;
    }
    else if ((RedMask == 0x0000f800) &&  
             (GreenMask == 0x000007e0) &&
             (BlueMask == 0x0000001f) && 
             (BitsPerPixel == 16))       
    {
        standardFormat = TRUE;
    }

    return(standardFormat);
}

/**************************************************************************\
*
* Function Description:
*
*   This function computes the PixelFormatID corresponding to a particular
*   combination of bit depth and color channel masks in the DpBitmap.
*
* Notes:
*
*   Code which calls this assumes that there are no standard formats which
*   support alpha.
*
* History:
*
*   05/17/2000 asecchia
*       Created it.
*
\**************************************************************************/

PixelFormatID DpBitmap::GetPixelFormatFromBitDepth(INT bits)
{
    switch(bits)
    {
        // !!! [asecchia] not sure if we support these indexed modes
        //     from this codepath.

        case 1:
            return PixelFormat1bppIndexed;
    
        case 4:
            return PixelFormat4bppIndexed;
    
        case 8:
            return PixelFormat8bppIndexed;
    
        case 16:
            if (RedMask == 0x00007c00)
            {
                return PixelFormat16bppRGB555;
            }
            if (RedMask == 0x0000f800)  
            {
                return PixelFormat16bppRGB565;
            }
            break;
    
        case 24:
            if (RedMask == 0x00ff0000)
            {
                return PixelFormat24bppRGB;
            }
            if (RedMask == 0x000000ff)  
            {
                return PIXFMT_24BPP_BGR;    
            }
            break;
    
        case 32:
            if (RedMask == 0x00ff0000)
            {
                return PixelFormat32bppRGB;
            }
            break;
    }
    
    WARNING(("Unsupported pixel format"));
    return PixelFormatUndefined;
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via the GDI routines.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpBitmap::InitializeForGdiBitmap(
    GpDevice *device,
    INT width,
    INT height
    )
{
    SurfaceTransparency = TransparencyNoAlpha;
    
    // !!![andrewgo] Disable this assert until MetaFiles stop calling
    //               with a zero dimension surface
    //
    // ASSERTMSG((width > 0) && (height > 0), ("Dimensions must be positive"));

    Width = width;
    Height = height;
    
    NumBytes = 0;
    Uniqueness = (DWORD)GpObject::GenerateUniqueness();

    PixelFormat = ExtractPixelFormatFromHDC(device->DeviceHdc);
    
    Scan = device->ScanGdi;

    SetValid(TRUE);
    Bits = NULL;
    Delta = 0;

    DdrawSurface7 = NULL;

    Type = GDI; 
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via the DCI routines, if possible.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
DpBitmap::InitializeForGdiScreen(
    GpDevice *device,
    INT width,
    INT height
    )
{
    InitializeForGdiBitmap(device, width, height);

    // Even if GDI bitmaps change to support alpha, the screen doesn't.
    
    SurfaceTransparency = TransparencyNoAlpha;
    ASSERT(!IsAlphaPixelFormat(PixelFormat));
    
    if(device->pdds != NULL)
    {
        DdrawSurface7 = device->pdds;
        DdrawSurface7->AddRef();
    }

    Scan = device->ScanDci;
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via D3D/DD access.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   09/28/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForD3D(
    HDC hdc,
    INT *width,
    INT *height,
    DpDriver **driver
    )
{
    HRESULT ddVal;
    HDC hdcDevice;
    DDSURFACEDESC2 ddsd;

    if(!InitializeDirectDrawGlobals())
            return FALSE;

    IDirectDrawSurface7 * surface;

    ddVal = Globals::DirectDraw->GetSurfaceFromDC(hdc, &surface);

    if(ddVal != DD_OK)
        return(FALSE);

    return InitializeForD3D(surface, width, height, driver);
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via D3D/DD access.
*
* Arguments:
*
*   [IN] device - Identifies the device
*   [IN] width - Bitmap width
*   [IN] height - Bitmap height
*   [OUT] driver - Driver interface to be used
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   09/28/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForD3D(
    IDirectDrawSurface7 * surface,
    INT *width,
    INT *height,
    DpDriver **driver
    )
{
    HRESULT ddVal;
    HDC hdcDevice;
    DDSURFACEDESC2 ddsd;

    GpDevice * device = Globals::DeviceList->FindD3DDevice(surface);

    if(device == NULL || device->pd3d == NULL)
        return FALSE;

    DdrawSurface7 = surface;

    ddsd.dwSize = sizeof(ddsd);
    ddVal = DdrawSurface7->GetSurfaceDesc(&ddsd);

    if (ddVal == DD_OK)
    {
        // Initialize bitmap class stuff:

        Bits = NULL;
        Delta = ddsd.lPitch;
        Width = ddsd.dwWidth;
        Height = ddsd.dwHeight;

        // AlphaMask is initialized to zero because we don't use it -
        // non-alpha format.

        AlphaMask = 0x00000000;
        RedMask = ddsd.ddpfPixelFormat.dwRBitMask;
        GreenMask = ddsd.ddpfPixelFormat.dwGBitMask;
        BlueMask = ddsd.ddpfPixelFormat.dwBBitMask;

        PixelFormat = GetPixelFormatFromBitDepth(ddsd.ddpfPixelFormat.dwRGBBitCount);

        if (StandardFormat())
        {
            // Our standard formats don't have alpha.
            
            SurfaceTransparency = TransparencyNoAlpha;
    
            *driver = Globals::D3DDriver;
            Scan = &Globals::DesktopDevice->ScanEngine;

            NumBytes = 0;
            Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        
            Type = D3D; 
            SetValid(TRUE);

            // Return some stuff:

            *width = Width;
            *height = Height;

            // Grab a reference:

            DdrawSurface7->AddRef();

            return(TRUE);
        }
    }

    return(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via printer routines, if possible.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForPrinter(
    GpPrinterDevice *device,
    INT width,
    INT height
    )
{
    InitializeForGdiBitmap(device, width, height);
        
    // Even if GDI bitmaps change to support alpha, printers don't.
    
    SurfaceTransparency = TransparencyNoAlpha;
    ASSERT(!IsAlphaPixelFormat(PixelFormat));

    Scan = &device->ScanPrint;
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a bitmap for drawing on via direct access to the 
*   DIBsection bits.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

BOOL
DpBitmap::InitializeForDibsection(
    HDC hdc,
    HBITMAP hbitmap,            // [IN] Bitmap handle, needed for determing
                                //       if bitmap is really top-down or not
    GpDevice *device,           // [IN] Identifies the device
    DIBSECTION *dib,            // [IN] Structure describing the bitmap
    INT *width,                 // [OUT] Bitmap width
    INT *height,                // [OUT] Bitmap height
    DpDriver **driver           // [OUT] Driver interface to be used
    )
{
    BOOL isTopDown;

    // On NT5, drivers have the option of supporting GetDC with DirectDraw
    // surfaces in such a way that the surfaces are not Locked when GDI
    // does the GetDC on them.  This means that there may be no user-mode 
    // mapping of the underlying surface.  So we have to check here for 
    // that case, because we obviously cannot render directly to those 
    // surfaces via software:

    // NOTE: if the surface is actually a DDraw surface, this check is not
    // actually enough. It is up to the driver to return a pointer here and
    // on occasion it simply returns its KM address. I.e. it will return a
    // non-NULL pointer that we can't access.
    // See the DDraw special case below.
    // This has been verified on a number of video drivers on Windows 2000
    // and Windows XP. (for instance, the inbox win2k permedia driver).
    
    if (dib->dsBm.bmBits == NULL)
    {
        return(FALSE);
    }

    LONG scans = abs(dib->dsBm.bmHeight);
    LONG widthInBytes = dib->dsBm.bmWidthBytes;

    // For backwards compatibility with Get/SetBitmapBits, GDI does
    // not accurately report the bitmap pitch in bmWidthBytes.  It
    // always computes bmWidthBytes assuming WORD-aligned scanlines
    // regardless of the platform.
    //
    // Therefore, if the platform is WinNT, which uses DWORD-aligned
    // scanlines, adjust the bmWidthBytes value.

    if (Globals::IsNt)
    {
        widthInBytes = (widthInBytes + 3) & ~3;
    }

    DWORD* topDown = (DWORD*) dib->dsBm.bmBits;
    DWORD* bottomUp = (DWORD*) ((ULONG_PTR) topDown + (scans - 1) * widthInBytes);

    if (Globals::IsNt)
    {
        // Unfortunately, on NT there is no simple means of determining
        // whether the DIB-section or DDraw surface is bottom-up or
        // top-down.  (NT should really set biHeight as Win9x does, but
        // unfortunately this is a bug that due to compatibility with
        // older versions of NT, will never be fixed.)
        //
        // At least we know that DirectDraw surfaces will always be
        // top-down, and we can recognize DDraw surfaces by the fact
        // that they have biSizeImage set to 0.  (Note that we can't let
        // this fall into the SetBitmapBits case because NT5 doesn't
        // permit SetBitmapBits calls on DDraw surface handles.)

        if (dib->dsBmih.biSizeImage == 0)
        {
            // This is a DirectDraw surface.
            
            // Currently we don't support direct rendering on DDraw surfaces
            // that are not backed by a system memory DIB Section so we simply 
            // fail here and drop into the GDI fallback code if we detect 
            // this condition.
        
            isTopDown = TRUE;
                                
            if(!InitializeDirectDrawGlobals() ||
               (Globals::GetDdrawSurfaceFromDcFunction == NULL))
            {
                // If we can't talk to the DDraw surface, we simply fall back
                // to our GDI rendering codepath.
                
                return FALSE;
            }
            
            HDC driverHdc;
            LPDIRECTDRAWSURFACE pDDS = NULL;
            
            HRESULT hr = Globals::GetDdrawSurfaceFromDcFunction(
                hdc, 
                &pDDS,
                &driverHdc
            );
            
            if (FAILED(hr) || (pDDS == NULL)) 
            {
                // Bail out if we can't get a DirectDraw Surface object.
                
                return FALSE;
            }
            
            // Lock the surface so we can see what the user mode bits pointer
            // is. If it's the same as the one in dib->dsBm.bmBits, then 
            // the DDraw surface is backed by a DIB section and we can continue
            // to treat this bitmap as a DIB. Otherwise we must fall back
            // to GDI.
            
            DDSURFACEDESC2 DDSD;
            DDSD.dwSize = sizeof(DDSURFACEDESC);
            
            hr = pDDS->Lock(
                NULL, 
                (LPDDSURFACEDESC)&DDSD, 
                DDLOCK_WAIT, 
                NULL
            );
            
            if (FAILED(hr))
            {
                pDDS->Release();
                return FALSE;
            }
            
            // Get the correct pitch from the DDSD. Note this may not be the
            // same as the pitch in the dib info structure.
            
            widthInBytes = DDSD.lPitch;
            
            // If the lpSurface is not the same as the dib->dsBm.bmBits then
            // this is not a DIB backed DDraw surface, so we (currently) have
            // no way of drawing on it besides our GDI fallback codepath.
            // Fail this call and release resources so that we can pick up
            // the StretchBlt fallback case.
            
            if(DDSD.lpSurface != dib->dsBm.bmBits)
            {
                pDDS->Unlock(NULL);
                pDDS->Release();
                return FALSE;
            }
            
            pDDS->Unlock(NULL);
            pDDS->Release();
            
            // We're set: this is a DIB backed DDraw surface so we can continue
            // to treat it as a DIB - now that we have the correct pitch.    
        }
        else
        {
            // When it's not a DDraw surface, we have to go through a
            // somewhat more indirect method to figure out where pixel
            // (0, 0) is in memory.  
            //
            // We use SetBitmapBits instead of something like SetPixel
            // or PatBlt because those would need to use the 'hdc'
            // given to us by the application, which might have a
            // transform set that maps (0, 0) to something other than
            // the top-left pixel of the bitmap.

            DWORD top = *topDown;
            DWORD bottom = *bottomUp;
            DWORD setBits = 0x000000ff;

            // Our SetBitmapBits call will set the top-left dword of
            // the bitmap to 0x000000ff.  If it's a top-down bitmap,
            // that will have modified the value at address 'topDown':

            *topDown = 0;
            LONG bytes = SetBitmapBits(hbitmap, sizeof(setBits), &setBits);
            isTopDown = (*topDown != 0);

            // The scanlines are guaranteed to be DWORD aligned, so there
            // really is at least a DWORD that we can directly access via
            // the pointer.  However, if the bitmap dimensions are such
            // that there is less than a DWORD of active data per scanline
            // (for example, a 3x3 8bpp bitmap or a 1x1 16bpp bitmap),
            // SetBitmapBits may use less than a DWORD of data.

            ASSERT(bytes > 0);

            // Restore the bitmap portions that we may have modified:

            *topDown = top;
            *bottomUp = bottom;
        }
    }
    else
    {
        // On Win9x, we can simply look at the sign of 'biHeight' to
        // determine whether the surface is top-down or bottom-up:

        isTopDown = (dib->dsBmih.biHeight < 0);
    }

    // Fill in our bitmap fields:

    if (isTopDown)
    {
        Bits = (BYTE*) topDown;
        Delta = widthInBytes;
    }
    else
    {
        Bits = (BYTE*) bottomUp;
        Delta = -widthInBytes;
    }

    Width = dib->dsBm.bmWidth;
    Height = dib->dsBm.bmHeight;
    
    // Note that this code doesn't handle palettes!

    if (dib->dsBmih.biCompression == BI_BITFIELDS)
    {
        RedMask = dib->dsBitfields[0];
        GreenMask = dib->dsBitfields[1];
        BlueMask = dib->dsBitfields[2];
    }
    else
    {
        if((dib->dsBmih.biCompression == BI_RGB) &&
           (dib->dsBm.bmBitsPixel == 16))
        {
            // According to MSDN, 16bpp BI_RGB implies 555 format.
            
            RedMask = 0x00007c00;
            GreenMask = 0x000003e0;
            BlueMask = 0x0000001F;
        }
        else
        {
            RedMask = 0x00ff0000;
            GreenMask = 0x0000ff00;
            BlueMask = 0x000000ff;
        }
    }
    
    // DibSections don't have alpha, but we don't want to leave this
    // field uninitialized because we peek at it occasionally.

    AlphaMask = 0x00000000;

    PixelFormat = GetPixelFormatFromBitDepth(dib->dsBm.bmBitsPixel);

    // if we are here and the bits per pel is 8, this is a DIB
    // with halftone colortable

    if ((dib->dsBm.bmBitsPixel == 8) || StandardFormat())
    {
        // Our standard formats don't have alpha.
        
        SurfaceTransparency = TransparencyNoAlpha;
        
        *driver = Globals::EngineDriver;
        Scan = &device->ScanEngine;

        NumBytes = 0;
        Uniqueness = (DWORD)GpObject::GenerateUniqueness();
    
        Type = GDIDIBSECTION; 
        SetValid(TRUE);

        // Return some stuff:

        *width = Width;
        *height = Height;

        return(TRUE);
    }

    return(FALSE);
}

/**************************************************************************\
*
* Function Description:
*
*   Initializes a GDI+ bitmap for drawing on via GpBitmap.Lock/UnlockBits.
*
* Arguments:
*
*   [IN] bitmap - Specifies the target GpBitmap
*
* Return Value:
*
*   TRUE is successful, FALSE otherwise.
*
* History:
*
*   09/22/1999 gilmanw
*       Created it based on DpBitmap::InitializeForGdiBitmap.
*
\**************************************************************************/

VOID
DpBitmap::InitializeForGdipBitmap(
    INT             width,
    INT             height,
    ImageInfo *     imageInfo,
    EpScanBitmap *  scanBitmap,
    BOOL            isDisplay
    )
{
    Width  = width;
    Height = height;

    NumBytes   = 0;
    Uniqueness = (DWORD)GpObject::GenerateUniqueness();
    AlphaMask = 0xff000000;
    RedMask   = 0x00ff0000;
    GreenMask = 0x0000ff00;
    BlueMask  = 0x000000ff;

    SetValid(TRUE);
    Bits = NULL;
    Delta = 0;

    Type = GPBITMAP;

    Scan = scanBitmap;

    PaletteTable = NULL;

    PixelFormat = imageInfo->PixelFormat;

    // GetTransparencyHint is called from DrvDrawImage
    // bitmap->GetTransparencyHint(&SurfaceTransparency);
    
    IsDisplay = isDisplay;
    DpiX = (REAL)imageInfo->Xdpi;
    DpiY = (REAL)imageInfo->Ydpi;
}

/**************************************************************************\
*
* Function Description:
*
*   Bitmap destructor
*
\**************************************************************************/

DpBitmap::~DpBitmap()
{ 
    if (PaletteTable != NULL) 
        GpFree(PaletteTable);
    
    if (DdrawSurface7 != NULL)
        DdrawSurface7->Release();

    SetValid(FALSE);    // so we don't use a deleted object
}

/**************************************************************************\
*
* Function Description:
*
*   Flush any rendering pending to this surface
*
\**************************************************************************/

VOID
DpBitmap::Flush(
    GpFlushIntention intention
    )
{
    Scan->Flush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\drawglyphdata.hpp ===
#ifndef _DRAWGLYPHDATA_
#define _DRAWGLYPHDATA_

struct DrawGlyphData
{
    DpContext                *context;
    DpBitmap                 *surface;
    const GpRect             *drawBounds;
    const GpGlyphPos         *glyphPos;
    const GpGlyphPos         *glyphPathPos;
    INT                       count;
    const DpBrush            *brush;
    const GpFaceRealization  *faceRealization;
    const UINT16             *glyphs;
    const UINT16             *glyphMap;
    const PointF             *glyphOrigins;
    INT                       glyphCount;   // (May differ from count)
    const WCHAR              *string;
    UINT                      stringLength;
    ItemScript                script;
    INT                       edgeGlyphAdvance;
    BOOL                      rightToLeft;
    INT                       flags;         // DG_NOGDI - testing only
};

#endif // _DRAWGLYPHDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\drvtextout.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Engine text out routines.
*
* Revision History:
*
*   3/25/1999 cameronb
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

struct GlyphScanBuf
{
    INT left;
    INT top;
    INT bottom;
    INT widthInBytes;
    DpRegion::Visibility visibility;
};

const BYTE GRAYSCALE_LEVEL = 16;

/**************************************************************************\
*
* Function Description:
*
*   Draws text at a position.
*
* Arguments:
*
*   [IN] context    - the context (matrix and clipping)
*   [IN] surface    - the surface to fill
*   [IN] drawBounds - the surface bounds
*   [IN] text       - the typeset text to be drawn
*   [IN] font       - the font to use
*   [IN] fgBrush    - the brush to use for the text
*   [IN] bgBrush    - the brush to use for the background (default = NULL)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   3/25/1999 cameronb
*
\**************************************************************************/

GpStatus
DpDriver::DrawGlyphs
(
    DrawGlyphData *drawGlyphData
)
{
    GpStatus status = GenericError;
    HDC hdc = NULL;

    ASSERT(!drawGlyphData->glyphPathPos);

    //  Choose appropriate brush behaviour

    switch(drawGlyphData->brush->Type)
    {
        case BrushTypeSolidColor:

            INT angle;  // Passed from GetTextOutputHdc to GdiText

            if (!(drawGlyphData->flags & DG_NOGDI))
            {
                hdc = drawGlyphData->context->GetTextOutputHdc(
                    drawGlyphData->faceRealization,
                    drawGlyphData->brush->SolidColor,
                    drawGlyphData->surface,
                    &angle
                );
            }
            if (hdc)
            {
                BOOL isClip;
                BOOL usePathClipping = FALSE;
                SetupClipping(hdc, drawGlyphData->context,
                              drawGlyphData->drawBounds, isClip,
                              usePathClipping, FALSE);

                status = GdiText(
                    hdc,
                    angle,
                    drawGlyphData->glyphs,
                    drawGlyphData->glyphOrigins,
                    drawGlyphData->glyphCount,
                    drawGlyphData->rightToLeft
                );
                RestoreClipping(hdc, isClip, usePathClipping);
                drawGlyphData->context->ReleaseTextOutputHdc(hdc);
            }
            else
            {

                status = SolidText(
                    drawGlyphData->context,
                    drawGlyphData->surface,
                    drawGlyphData->drawBounds,
                    drawGlyphData->brush->SolidColor,
                    drawGlyphData->glyphPos,
                    drawGlyphData->count,
                    drawGlyphData->faceRealization->RealizationMethod(),
                    drawGlyphData->rightToLeft
                );
            }
            break;

//        case BrushRectGrad:
//        case BrushRadialGrad:
        case BrushTypeTextureFill:
        case BrushTypeHatchFill:
//        case BrushTriangleGrad:
        case BrushTypePathGradient:
        case BrushTypeLinearGradient:

            status = BrushText(
                drawGlyphData->context,
                drawGlyphData->surface,
                drawGlyphData->drawBounds,
                drawGlyphData->brush,
                drawGlyphData->glyphPos,
                drawGlyphData->count,
                drawGlyphData->faceRealization->RealizationMethod()
            );
            break;

        default:
            status = GenericError;
            break;
    }

    return status;
}

static GpStatus
OutputSolidNormalText (
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    GpColor   color,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        (color.IsOpaque() &&
        (!context->AntiAliasMode)));

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    ARGB argb = color.GetPremultipliedValue();

    DpOutputSolidColorSpan  outputSolid(argb, &scan);
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y,
        drawBounds->GetRight(), drawBounds->GetBottom()) !=
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(&outputSolid, drawBounds->Y);
    }

    for (int i = 0; i < count; i++)
    {
        INT left = glyphPos[i].GetLeft();
        INT top = glyphPos[i].GetTop();
#if 0
        printf("Drawing glyph at [%d,%d]\n", left, top);
#endif
        INT widthInPixels = glyphPos[i].GetWidth();
        INT right = left + widthInPixels;
        INT height = glyphPos[i].GetHeight();
        INT bottom = top + height;

        INT widthInBytes = (widthInPixels + 7) / 8;

        const BYTE* mask = glyphPos[i].GetBits();

        if (widthInPixels == 0 || height == 0)
            continue;

        ASSERT(mask != NULL);

        if (clipRegion != NULL)
        {
            //  Clipping
            GpRect clippedRect;
            DpRegion::Visibility visibility =
                clipRegion->GetRectVisibility(
                    left, top, right, bottom, &clippedRect
                );

            if (visibility == DpRegion::Invisible)
                continue;

            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                const BYTE* maskPtr = mask + my * widthInBytes;

                BYTE bit = 0x80;
                BYTE nextPixel = (*(maskPtr) & bit) ? 255 : 0;

                INT runStart = 0;

                for (INT mx = 0; mx < widthInPixels; mx++)
                {
                    BYTE pixel = nextPixel;

                    bit = (bit == 0x01) ? 0x80 : bit >> 1;
                    nextPixel = (mx == widthInPixels - 1)
                                    ? 0
                                    : ( (*(maskPtr + (mx + 1) / 8) & bit) ? 255 : 0);

                    if (pixel != nextPixel)
                    {
                        if (pixel)
                        {

                        //  Draw this run

                            INT runLength = mx - runStart + 1;
                            INT from = left + runStart;

                            if (visibility == DpRegion::TotallyVisible)
                            {

                            //  Draw the entire run

                                FillMemoryInt32( scan.NextBuffer(from, y, runLength),
                                                    runLength, argb);
                            }
                            else
                            {

                            //  Clip the run

                                INT to = from + runLength; // reference needed
                                clipRegion->OutputSpan(y, from, to);
                            }

                        };

                        if (nextPixel)
                        {
                            //  Start a new run
                            runStart = mx + 1;
                        }
                    }

                }
            }
        }
        else
        {
           //  No clipping
           for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
           {
               const BYTE* maskPtr = mask + my * widthInBytes;
               BYTE bit = 0x80;

               INT runLength = 0;
               INT runStart;

               for (INT mx = 0; mx < widthInPixels; mx++)
               {
                   BOOL pixelOn = *(maskPtr + mx / 8) & bit;

                   if (pixelOn)
                   {
                       if (runLength == 0)
                       {
                           // Start a new run
                           runStart = mx;
                       }
                       runLength++;
                   }

                   if
                   (
                        runLength > 0 && !pixelOn
                        ||
                        runLength > 0 && mx == widthInPixels - 1
                   )
                   {
                       //  Finish this run and draw it
                       FillMemoryInt32(
                           scan.NextBuffer(left + runStart, y, runLength),
                           runLength, argb
                       );
                       runLength = 0;
                   };
                   bit = (bit == 0x01) ? 0x80 : bit >> 1;
               }
           }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    return(Ok);

}

static inline
VOID GetGlyphDimensions(
    const GpGlyphPos & glyphPos,
    INT * left,
    INT * top,
    INT * widthInPixels,
    INT * right,
    INT * height,
    INT * bottom
    )
{
    *left = glyphPos.GetLeft();
    *top = glyphPos.GetTop();
    *widthInPixels = glyphPos.GetWidth();
    *right = *left + *widthInPixels;
    *height = glyphPos.GetHeight();
    *bottom = *top + *height;
} // GetGlyphDimensions

template <typename MASKTYPE>
class DpOutputOptimizedSpan : public DpOutputSpan
{
public:
    typedef MASKTYPE    SCANMASKTYPE;

    DpOutputOptimizedSpan(DpScanBuffer * scan)
        : Scan(scan)
    {}

    virtual BOOL IsValid() const
    {
        return TRUE;
    }

    void SetMaskAndLeft(const MASKTYPE * maskPtr, INT left)
    {
        ASSERT(maskPtr != 0);
        MaskPtr = maskPtr;
        Left = left;
    }

protected:
    DpScanBuffer *  Scan;
    INT             Left;
    const MASKTYPE *MaskPtr;
};

template <class OUTPUT_SPAN>
static GpStatus
OutputTextOptimized(
    DpContext* context,
    const GpRect* drawBounds,
    const GpGlyphPos *glyphPos,
    INT count,
    OUTPUT_SPAN & outputSpan
    )
{
    ASSERT(context->CompositingMode == CompositingModeSourceOver);

    DpClipRegion * clipRegion = &(context->VisibleClip);
    clipRegion->InitClipping(&outputSpan, drawBounds->Y);

    // measure bounding box for all glyphs
    INT minX = INT_MAX, maxX = INT_MIN, minY = INT_MAX, maxY = INT_MIN;
    for (INT i = 0; i < count; ++i)
    {
        INT left, top, widthInPixels, right, height, bottom;
        GetGlyphDimensions(glyphPos[i], &left, &top, &widthInPixels, &right, &height, &bottom);

        if (widthInPixels == 0 ||
            height == 0 ||
            clipRegion->GetRectVisibility(left, top, right, bottom) ==
                DpRegion::Invisible)
            continue;

        if (left   < minX)  minX = left;
        if (top    < minY)  minY = top;
        if (right  > maxX)  maxX = right;
        if (bottom > maxY)  maxY = bottom;
    }

    ASSERT(drawBounds->GetLeft() <= minX);
    ASSERT(drawBounds->GetTop() <= minY);
    ASSERT(drawBounds->GetRight() >= maxX);
    ASSERT(drawBounds->GetBottom() >= maxY);

    if (minX >= maxX || minY >= maxY)
        return Ok;

    AutoArray<OUTPUT_SPAN::SCANMASKTYPE> scanLine(new OUTPUT_SPAN::SCANMASKTYPE[maxX - minX]);
    if (!scanLine)
        return OutOfMemory;

    outputSpan.SetMaskAndLeft(scanLine.Get(), minX);

    for (INT line = minY; line < maxY; ++line)
    {
        GpMemset(scanLine.Get(), 0, (maxX - minX) * sizeof(OUTPUT_SPAN::SCANMASKTYPE));

        for (INT i = 0; i < count; ++i)
        {
            INT left, top, widthInPixels, right, height, bottom;
            GetGlyphDimensions(glyphPos[i], &left, &top, &widthInPixels, &right, &height, &bottom);

            if (widthInPixels == 0 ||
                height == 0 ||
                top > line ||
                line >= bottom ||
                clipRegion->GetRectVisibility(left, top, right, bottom) ==
                    DpRegion::Invisible)
                continue; // is the last check necessary? [mleonov]

            // now, render glyph into the horizontal merge buffer

            outputSpan.RenderGlyph(
                glyphPos[i].GetBits(),
                &scanLine[left-minX],
                widthInPixels,
                line - top
            );
        }

        // now, clip and render scan line
        clipRegion->OutputSpan(line, minX, maxX);
    }

    clipRegion->EndClipping();

    return Ok;
} // OutputTextOptimized

class DpOutputSolidColorOptimizedSpan : public DpOutputOptimizedSpan<ARGB>
{
    typedef DpOutputOptimizedSpan<ARGB> super;

public:
    DpOutputSolidColorOptimizedSpan(DpScanBuffer * scan, ARGB argb)
        : super(scan), Argb(argb)
    {}

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        INT width = xMax - xMin;
        const ARGB * maskPtr = MaskPtr + xMin - Left;
        ARGB * buf = Scan->NextBuffer(xMin, y, width);
        GpMemcpy(buf, maskPtr, width * sizeof(ARGB));
        return Ok;
    }

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const INT widthInBytes = (widthInPixels + 7) / 8;
        const BYTE * mask = glyphBits + widthInBytes * y;

        for (INT pos = 0; pos < widthInPixels; ++dst, ++pos)
        {
            if (!*dst && (mask[pos>>3] & (0x80 >> (pos & 7))))
                *dst = Argb;
        }
    } // RenderGlyph

protected:
    const ARGB  Argb;
}; // class DpOutputSolidColorOptimizedSpan

static GpStatus
OutputSolidNormalTextOptimized(
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    const GpColor & color,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(surface->Scan, driver, context, surface);

    if (!scan.IsValid())
        return GenericError;

    DpOutputSolidColorOptimizedSpan  outputSolid(&scan, color.GetPremultipliedValue());

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputSolid);
} // OutputSolidNormalTextOptimized

class DpOutputClearTypeOptimizedSpan : public DpOutputOptimizedSpan<BYTE>
{
    typedef DpOutputOptimizedSpan<BYTE> super;

public:
    DpOutputClearTypeOptimizedSpan(DpScanBuffer * scan)
        : super(scan)
    {}

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const BYTE * mask = glyphBits + widthInPixels * y;

        for (INT pos = 0; pos < widthInPixels; ++pos, ++dst)
        {
            const BYTE src = mask[pos];
            ASSERT(0 <= *dst && *dst <= CT_LOOKUP - 1);
            ASSERT(0 <= src && src <= CT_LOOKUP - 1);

            if (*dst == 0)
            {
                *dst = src;
            }
            else if (src != 0)
            {
                // merge ClearType data
                ULONG kR = (ULONG)Globals::gaOutTable[*dst].kR + (ULONG)Globals::gaOutTable[src].kR;
                ULONG kG = (ULONG)Globals::gaOutTable[*dst].kG + (ULONG)Globals::gaOutTable[src].kG;
                ULONG kB = (ULONG)Globals::gaOutTable[*dst].kB + (ULONG)Globals::gaOutTable[src].kB;

                if (kR > CT_SAMPLE_F) {kR = CT_SAMPLE_F;}
                if (kG > CT_SAMPLE_F) {kG = CT_SAMPLE_F;}
                if (kB > CT_SAMPLE_F) {kB = CT_SAMPLE_F;}

                *dst = Globals::FilteredCTLut[kB + 7 * kG + 49 * kR];
            }
        }
    } // RenderGlyph
}; // class DpOutputClearTypeOptimizedSpan

class DpOutputClearTypeSolidOptimizedSpan : public DpOutputClearTypeOptimizedSpan
{
    typedef DpOutputClearTypeOptimizedSpan super;

public:
    DpOutputClearTypeSolidOptimizedSpan(DpScanBuffer * scan)
        : super(scan)
    {}

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        const INT width = xMax - xMin;
        const BYTE * maskPtr = MaskPtr + xMin - Left;
        Scan->NextBuffer(xMin, y, width);
        BYTE * buf = reinterpret_cast<BYTE *>(Scan->GetCurrentCTBuffer());
        for (INT i = 0; i < width; ++i)
        {
            ASSERT(0 <= *maskPtr && *maskPtr <= CT_LOOKUP - 1);
            *buf = *maskPtr;
            ++buf;
            ++maskPtr;
        }
        return Ok;
    }
}; // class DpOutputClearTypeSolidOptimizedSpan

class DpOutputClearTypeBrushOptimizedSpan : public DpOutputClearTypeOptimizedSpan
{
    typedef DpOutputClearTypeOptimizedSpan super;

public:
    DpOutputClearTypeBrushOptimizedSpan(DpScanBuffer * scan, DpOutputSpan * output)
        : super(scan), Output(output)
    {}

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        GpStatus status = Output->OutputSpan(y, xMin, xMax);
        if (status != Ok)
            return status;

        const INT width = xMax - xMin;
        const BYTE * maskPtr = MaskPtr + xMin - Left;
        BYTE * buf = reinterpret_cast<BYTE *>(Scan->GetCurrentCTBuffer());
        for (INT i = 0; i < width; ++i)
        {
            ASSERT(0 <= *maskPtr && *maskPtr <= CT_LOOKUP - 1);
            *buf = *maskPtr;
            ++buf;
            ++maskPtr;
        }
        return Ok;
    }

protected:
    DpOutputSpan *  Output;
}; // class DpOutputClearTypeBrushOptimizedSpan

static GpStatus
OutputBrushClearTypeText(
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    const DpBrush * brush,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE,
        EpScanTypeCT);

    if (!scan.IsValid())
    {
        return GenericError;
    }

    AutoPointer<DpOutputSpan> output(DpOutputSpan::Create(brush, &scan, context));
    if (!output)
        return OutOfMemory;

    DpOutputClearTypeBrushOptimizedSpan  outputCTSpan(&scan, output.Get());

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputCTSpan);
} // OutputBrushClearTypeText

static GpStatus
OutputSolidClearTypeText(
    DpContext* context,
    DpDriver *driver,
    DpBitmap* surface,
    const GpRect* drawBounds,
    GpColor color,
    const GpGlyphPos *glyphPos,
    INT count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE,
        EpScanTypeCTSolidFill,
        PixelFormat32bppPARGB,
        PixelFormat32bppPARGB,
        color.GetValue());

    if (!scan.IsValid())
    {
        return GenericError;
    }

    DpOutputClearTypeSolidOptimizedSpan outputCTSpan(&scan);

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputCTSpan);
} // OutputSolidClearTypeText


class DpOutputAntiAliasSolidColorOptimizedSpan : public DpOutputOptimizedSpan<BYTE>
{
    typedef DpOutputOptimizedSpan<BYTE> super;

public:
    DpOutputAntiAliasSolidColorOptimizedSpan(DpScanBuffer * scan, const GpColor & color, ULONG gammaValue)
        : super(scan)
    {
        TextGammaTable.CreateTextColorGammaTable(&color, gammaValue, GRAYSCALE_LEVEL);
    }

    virtual GpStatus OutputSpan(INT y, INT xMin, INT xMax)
    {
        INT width = xMax - xMin;
        const BYTE * maskPtr = MaskPtr + xMin - Left;
        ARGB * buf = Scan->NextBuffer(xMin, y, width);

        for (ARGB * cur = buf; cur < buf + width; ++cur, ++maskPtr)
        {
            if (*maskPtr)
                *cur = TextGammaTable.argb[*maskPtr];
            else
                *cur = 0;
        }
        return Ok;
    }
protected:
    TextColorGammaTable TextGammaTable;

    BYTE MergeGrayscale(BYTE src, BYTE dst)
    {
        return max(src, dst);

/*      how do we correctly merge overlapping antialiased glyphs?
        we need to know if subpixels come from the same glyph
        UINT res = src + dst;
        if (res >= GsLevel)
            return GsLevel - 1;
        return (BYTE)res;
*/
    } // MergeGrayscale

}; // class DpOutputAntiAliasSolidColorOptimizedSpan

class DpOutputAntiAliasSolid8BPPOptimizedSpan : public DpOutputAntiAliasSolidColorOptimizedSpan
{
    typedef DpOutputAntiAliasSolidColorOptimizedSpan    super;
public:
    DpOutputAntiAliasSolid8BPPOptimizedSpan(DpScanBuffer * scan, const GpColor & color, ULONG gammaValue)
        : super(scan, color, gammaValue)
    {}

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const BYTE * mask = glyphBits + widthInPixels * y;

        for (INT pos = 0; pos < widthInPixels; ++pos, ++dst)
        {
            *dst = MergeGrayscale(*dst, mask[pos]);
        }
    } // RenderGlyph
}; // class DpOutputAntiAliasSolid8BPPOptimizedSpan

class DpOutputAntiAliasSolid4BPPOptimizedSpan : public DpOutputAntiAliasSolidColorOptimizedSpan
{
    typedef DpOutputAntiAliasSolidColorOptimizedSpan    super;
public:
    DpOutputAntiAliasSolid4BPPOptimizedSpan(DpScanBuffer * scan, const GpColor & color, ULONG gammaValue)
        : super(scan, color, gammaValue)
    {}

    void RenderGlyph(const BYTE * glyphBits,
                     SCANMASKTYPE * dst,
                     INT widthInPixels,
                     INT y)
    {
        const INT widthInBytes = (widthInPixels + 1) / 2;
        const BYTE * mask = glyphBits + widthInBytes * y;
        for (INT pos = 0; pos < widthInPixels; ++dst, ++pos)
        {
            BYTE value = mask[pos / 2];
            value >>= 4 * ((pos + 1) & 1);
            value &= 0x0F;
            *dst = MergeGrayscale(*dst, value);
        }
    } // RenderGlyph
}; // class DpOutputAntiAliasSolid4BPPOptimizedSpan

static GpStatus
OutputSolidAntiAliasText8BPPOptimized(
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    DpScanBuffer scan(surface->Scan, driver, context, surface);

    if (!scan.IsValid())
        return GenericError;

    DpOutputAntiAliasSolid8BPPOptimizedSpan outputAASolid(&scan, color, context->TextContrast);

    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputAASolid);
} // OutputSolidAntiAliasText8BPPOptimized

static GpStatus
OutputSolidAntiAliasText4BPPOptimized(
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    DpScanBuffer scan(surface->Scan, driver, context, surface);

    if (!scan.IsValid())
        return GenericError;

    DpOutputAntiAliasSolid4BPPOptimizedSpan outputAASolid(&scan, color, context->TextContrast);
    return OutputTextOptimized(context, drawBounds, glyphPos, count, outputAASolid);
} // OutputSolidAntiAliasText4BPPOptimized

static GpStatus
OutputSolidAntiAliasText8BPP (
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    INT i;

    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE);

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    DpOutputAntiAliasSolidColorSpan  outputAASolid(color, &scan, context->TextContrast, GRAYSCALE_LEVEL);
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y,
        drawBounds->GetRight(), drawBounds->GetBottom()) !=
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(&outputAASolid, drawBounds->Y);
    }

//////////////////////////////////////////////////////////////////////////////

    for (i = 0; i < count; i++)
    {
        INT left = glyphPos[i].GetLeft();
        INT top = glyphPos[i].GetTop();
        INT widthInPixels = glyphPos[i].GetWidth();
        INT right = left + widthInPixels;
        INT height = glyphPos[i].GetHeight();
        INT bottom = top + height;

        if (widthInPixels == 0 || height == 0)
            continue;

        INT widthInBytes = widthInPixels;

        const BYTE* mask = glyphPos[i].GetBits();

        ASSERT(mask != NULL);

        if (clipRegion != NULL)
        {
            //  Clipping
            GpRect clippedRect;
            DpRegion::Visibility visibility =
                clipRegion->GetRectVisibility(
                    left, top, right, bottom, &clippedRect
                );

            if (visibility == DpRegion::Invisible)
                continue;

            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                const BYTE* maskPtr = mask + my * widthInBytes;

                BYTE grayscaleValue = *maskPtr;

                INT runStart = 0;

                for (INT mx = 0; mx <= widthInPixels; mx++)
                {
                    BYTE nextgrayscaleValue;

                    if (mx == widthInPixels)
                    {
                        nextgrayscaleValue = 0;
                    }
                    else
                    {
                        nextgrayscaleValue = *maskPtr;
                        maskPtr++;
                    }

                    if (grayscaleValue != nextgrayscaleValue)
                    {

                        if (grayscaleValue != 0)
                        {

                         //  Draw this run

                            INT runLength = mx - runStart;
                            INT from = left + runStart;

                            if (visibility == DpRegion::TotallyVisible)
                            {

                            //  Draw the entire run
                                FillMemoryInt32( scan.NextBuffer(from, y, runLength), runLength,
                                                    outputAASolid.GetAASolidColor((ULONG) grayscaleValue));
                            }
                            else
                            {

                            //  Clip the run

                                INT to = from + runLength; // reference needed
                                outputAASolid.GetAASolidColor((ULONG) grayscaleValue);

                                clipRegion->OutputSpan(y, from, to);
                            }

                            //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                        else
                        {
                         //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                    }
                }
            }
        }
        else
        {
            ARGB * buf;
            //  No clipping
            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                // Get the first byte in the scan line
                const BYTE* maskPtr = mask + my * widthInBytes;

                buf = scan.NextBuffer(left, y, widthInPixels);

                for (INT mx = 0; mx < widthInPixels; mx++)
                {
                    *buf++ = outputAASolid.GetAASolidColor((ULONG) *maskPtr);
                    maskPtr++;
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    return(Ok);

}

static GpStatus
OutputSolidAntiAliasText4BPP (
    DpContext*  context,
    DpDriver *  driver,
    DpBitmap*   surface,
    const       GpRect* drawBounds,
    GpColor     color,
    const       GpGlyphPos *glyphPos,
    INT         count
    )
{
    INT i;

    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE);

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    DpOutputAntiAliasSolidColorSpan  outputAASolid(color, &scan, context->TextContrast, GRAYSCALE_LEVEL);
    DpClipRegion * clipRegion = NULL;

    if (context->VisibleClip.GetRectVisibility(
        drawBounds->X, drawBounds->Y,
        drawBounds->GetRight(), drawBounds->GetBottom()) !=
        DpRegion::TotallyVisible)
    {
        clipRegion = &(context->VisibleClip);
        clipRegion->InitClipping(&outputAASolid, drawBounds->Y);
    }

//////////////////////////////////////////////////////////////////////////////

    for (i = 0; i < count; i++)
    {
        INT left = glyphPos[i].GetLeft();
        INT top = glyphPos[i].GetTop();
        INT widthInPixels = glyphPos[i].GetWidth();
        INT right = left + widthInPixels;
        INT height = glyphPos[i].GetHeight();
        INT bottom = top + height;

        if (widthInPixels == 0 || height == 0)
            continue;

        INT widthInBytes = ((widthInPixels + 1) / 2);

        const BYTE* mask = glyphPos[i].GetBits();

        ASSERT(mask != NULL);

        if (clipRegion != NULL)
        {
            //  Clipping
            GpRect clippedRect;
            DpRegion::Visibility visibility =
                clipRegion->GetRectVisibility(
                    left, top, right, bottom, &clippedRect
                );

            if (visibility == DpRegion::Invisible)
                continue;

            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                const BYTE* maskPtr = mask + my * widthInBytes;

                BYTE grayscaleValue = *maskPtr >> 4;

                INT runStart = 0;

                for (INT mx = 0; mx <= widthInPixels; mx++)
                {
                    BYTE nextgrayscaleValue;

                    if (mx == widthInPixels)
                    {
                        nextgrayscaleValue = 0;
                    }
                    else
                    {
                       if (mx % 2)
                        {
                            nextgrayscaleValue = *maskPtr & 0x0F;
                            maskPtr++;
                        }
                        else
                        {
                            nextgrayscaleValue = *maskPtr >> 4;
                        }
                    }

                    if (grayscaleValue != nextgrayscaleValue)
                    {

                        if (grayscaleValue != 0)
                        {

                         //  Draw this run

                            INT runLength = mx - runStart;
                            INT from = left + runStart;

                            if (visibility == DpRegion::TotallyVisible)
                            {

                            //  Draw the entire run
                                FillMemoryInt32( scan.NextBuffer(from, y, runLength), runLength,
                                                    outputAASolid.GetAASolidColor((ULONG) grayscaleValue));
                            }
                            else
                            {

                            //  Clip the run

                                INT to = from + runLength; // reference needed
                                outputAASolid.GetAASolidColor((ULONG) grayscaleValue);

                                clipRegion->OutputSpan(y, from, to);
                            }

                            //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                        else
                        {
                         //  Start a new run
                            runStart = mx;
                            grayscaleValue = nextgrayscaleValue;
                        }
                    }
                }
            }
        }
        else
        {
            ARGB * buf;
            //  No clipping
            for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
            {
                // Get the first byte in the scan line
                const BYTE* maskPtr = mask + my * widthInBytes;

                buf = scan.NextBuffer(left, y, widthInPixels);

                for (INT mx = 0; mx < widthInPixels; mx++)
                {
                    if (!(mx % 2))
                        *buf++ = outputAASolid.GetAASolidColor((ULONG) (*maskPtr >> 4));
                    else
                    {
                        *buf++ = outputAASolid.GetAASolidColor((ULONG) (*maskPtr & 0x0F));
                        maskPtr++;
                    }
                }
            }
        }
    }

    if (clipRegion != NULL)
    {
        clipRegion->EndClipping();
    }

    return(Ok);

}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to draw solid text.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*
*   4/4/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus
DpDriver::SolidText(
    DpContext* context,
    DpBitmap* surface,
    const GpRect* drawBounds,
    GpColor   color,
    const GpGlyphPos *glyphPos,
    INT count,
    TextRenderingHint textMode,
    BOOL rightToLeft
    )
{
    ASSERT (textMode != TextRenderingHintSystemDefault);
    switch(textMode)
    {
        case TextRenderingHintSingleBitPerPixelGridFit:
        case TextRenderingHintSingleBitPerPixel:
            if (context->CompositingMode == CompositingModeSourceCopy)
                return OutputSolidNormalText(context, this, surface, drawBounds, color, glyphPos, count);
            // we are allowed to output transparent pixels
            // version with minimized number of scan records
            return OutputSolidNormalTextOptimized(context, this, surface, drawBounds, color, glyphPos, count);

        case TextRenderingHintAntiAlias:
            if (context->CompositingMode == CompositingModeSourceCopy)
                return OutputSolidAntiAliasText8BPP(context, this, surface, drawBounds, color, glyphPos, count);
            return OutputSolidAntiAliasText8BPPOptimized(context, this, surface, drawBounds, color, glyphPos, count);
        case TextRenderingHintAntiAliasGridFit:
            if (context->CompositingMode == CompositingModeSourceCopy)
                return OutputSolidAntiAliasText4BPP(context, this, surface, drawBounds, color, glyphPos, count);

            return OutputSolidAntiAliasText4BPPOptimized(context, this, surface, drawBounds, color, glyphPos, count);

        case TextRenderingHintClearTypeGridFit:
            return OutputSolidClearTypeText(context, this, surface, drawBounds, color, glyphPos, count);
        default:
            break;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to draw text based on a brush.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*   5-1-2000 YungT rewrite it.
*   2/7/2000 YungT modify it.
*   4/14/1999 cameronb
*       Created it.
*
\**************************************************************************/
static GpStatus
OutputBrushNormalText(
    DpContext*        context,
    DpDriver *        driver,
    DpBitmap*         surface,
    const GpRect*     drawBounds,
    const DpBrush*    brush,
    const GpGlyphPos* glyphPos,
    INT               count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE); // (color64.IsOpaque() &&
                // (!context->AntiAliasMode)));
                // !!! If you fix this, you'll get a perf improvement for
                // text that has no transparency.

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    FPUStateSaver fpuState;

    DpOutputSpan* output = DpOutputSpan::Create(brush, &scan, context);

    if (output != NULL)
    {

        INT i;
        INT my;
        GlyphScanBuf glyphScanBuf[256], *pglyphScanBuf;
        DpClipRegion* clipRegion = NULL;

        INT topY = drawBounds->Y;
        INT bottomY = drawBounds->GetBottom();

    // Allocate enough space for glyph scan buffer
        if (count < 256)
        {
            pglyphScanBuf = &glyphScanBuf[0];
        }
        else
        {
            pglyphScanBuf = (GlyphScanBuf *) GpMalloc(count * sizeof(GlyphScanBuf));

            if (!pglyphScanBuf)
                return (OutOfMemory);
        }

        if (context->VisibleClip.GetRectVisibility(drawBounds->X, topY, drawBounds->GetRight(),
                                                    bottomY) != DpRegion::TotallyVisible)
        {
            clipRegion = &(context->VisibleClip);
            clipRegion->InitClipping(output, drawBounds->Y);
        }


        // Scan evrey Glyph and get the Visibility
        // Also we cache some data we will need to for later computation
        for (i = 0; i < count; i++)
        {
            GpRect clippedRect;
            pglyphScanBuf[i].left = glyphPos[i].GetLeft();
            pglyphScanBuf[i].top = glyphPos[i].GetTop();
            pglyphScanBuf[i].widthInBytes = (glyphPos[i].GetWidth() + 7) / 8;
            pglyphScanBuf[i].bottom = pglyphScanBuf[i].top + glyphPos[i].GetHeight();

            // Set the glyph as invisible if it is empty.
            if (glyphPos[i].GetWidth() == 0 || glyphPos[i].GetHeight() == 0)
                pglyphScanBuf[i].visibility = DpRegion::Invisible;
            else if (clipRegion != NULL)
                pglyphScanBuf[i].visibility = clipRegion->GetRectVisibility(pglyphScanBuf[i].left,
                                                                        pglyphScanBuf[i].top,
                                                                        pglyphScanBuf[i].left + glyphPos[i].GetWidth(),
                                                                        pglyphScanBuf[i].bottom, &clippedRect);
            else
                pglyphScanBuf[i].visibility = DpRegion::TotallyVisible;

        }

        // Start to scan from top of bounding box to bottom
        for (int y = topY; y < bottomY; y++)
        {
            for (i = 0; i < count; i++)
            {
                const BYTE* maskPtr;

                INT runLength, runStart;
                INT from, to;

                BYTE thisBit;
                BYTE nextPixel;
                BYTE pixel;

                // Invisible glyph
                if (pglyphScanBuf[i].visibility == DpRegion::Invisible)
                {
                    continue;
                }

                // check the scan line with y.top and y.bottom
                if (y < pglyphScanBuf[i].top || y >= pglyphScanBuf[i].bottom)
                    continue;

                if (pglyphScanBuf[i].visibility != DpRegion::TotallyVisible)
                {
                    // Get the relateive y-scan line for each glyph
                    my = y - pglyphScanBuf[i].top;

                    // Get the address of glyph bits
                    maskPtr = glyphPos[i].GetBits();

                    ASSERT(maskPtr != NULL);

                    maskPtr += my * pglyphScanBuf[i].widthInBytes;

                    thisBit = 0x80;
                    nextPixel = (*(maskPtr) & thisBit) ? 255 : 0;

                    runStart = 0;

                    for (INT mx = 0; mx < glyphPos[i].GetWidth(); mx++)
                    {
                        pixel = nextPixel;
                        thisBit = (thisBit == 0x01) ? 0x80 : thisBit >> 1;
                        nextPixel = (mx == glyphPos[i].GetWidth() - 1) ? 0 : ( (*(maskPtr + (mx + 1) / 8) & thisBit) ? 255 : 0);

                        if (pixel != nextPixel)
                        {
                            if (pixel)
                            {
                                //  Draw this run
                                runLength = mx - runStart + 1;

                                //  Clip the run
                                 from = pglyphScanBuf[i].left + runStart;
                                 to =   from + runLength;

                                 clipRegion->OutputSpan(y, from, to);
                            }

                            if (nextPixel)
                            {
                            //  Start a new run
                                runStart = mx + 1;
                            }
                        }

                    }
                }
                else
                {
                    my = y - pglyphScanBuf[i].top;

                    maskPtr = glyphPos[i].GetBits();

                    ASSERT(maskPtr != NULL);

                    maskPtr += my * pglyphScanBuf[i].widthInBytes;

                    thisBit = 0x80;

                    runLength = 0;

                    for (INT mx = 0; mx < glyphPos[i].GetWidth(); mx++)
                    {
                        BOOL pixelOn = *(maskPtr + mx / 8) & thisBit;

                        if (pixelOn)
                        {
                            if (runLength == 0)
                            {
                            // Start a new run
                                runStart = mx;
                            }

                            runLength++;
                        }

                        if (runLength > 0 && !pixelOn || runLength > 0 && mx == glyphPos[i].GetWidth() - 1)
                        {
                            //  Finish this run and draw it
                            from = pglyphScanBuf[i].left + runStart;
                            to =   from + runLength;
                            output->OutputSpan(y, from, to);
                            runLength = 0;
                        };

                        thisBit = (thisBit == 0x01) ? 0x80 : thisBit >> 1;
                    }
                }
            }

        } // next scan line

        if (clipRegion != NULL)
        {
            clipRegion->EndClipping();
        }

        delete output;

        if (pglyphScanBuf != &glyphScanBuf[0])
            GpFree(pglyphScanBuf);

    }

    return(Ok);
}



/**************************************************************************\
*
* Function Description:
*
*   Antialias version of routine to draw text based on a brush.
*
* Arguments:
*
*   [IN] - same as DDI parameters.
*
* Return Value:
*
*   Ok if successful.
*
* History:
*
*   2/20/00 YungT
*       Created it.
*
\**************************************************************************/

static GpStatus
OutputBrushAntiAliasText8BPP(
    DpContext*          context,
    DpDriver *          driver,
    DpBitmap*           surface,
    const GpRect*       drawBounds,
    const DpBrush*      brush,
    const GpGlyphPos*   glyphPos,
    INT                 count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE); // (color64.IsOpaque() &&
                // (!context->AntiAliasMode)));
                // !!! If you fix this, you'll get a perf improvement for
                // text that has no transparency.

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan* output = DpOutputSpan::Create(brush, &scan, context);

    DpOutputAntiAliasBrushOutputSpan aaBrushSpan;

    if (output != NULL)
    {
        INT i;

        TextColorGammaTable textContrastTable;
        textContrastTable.CreateTextColorGammaTable((GpColor *) NULL, context->TextContrast, GRAYSCALE_LEVEL);

        DpClipRegion* clipRegion = NULL;

        if (context->VisibleClip.GetRectVisibility( drawBounds->X, drawBounds->Y,
                                                    drawBounds->GetRight(), drawBounds->GetBottom()) !=
                                                    DpRegion::TotallyVisible)
        {
            aaBrushSpan.Init(output);

            clipRegion = &(context->VisibleClip);
            clipRegion->InitClipping(&aaBrushSpan, drawBounds->Y);
        }

        for (i = 0; i < count; i++)
        {
            INT left = glyphPos[i].GetLeft();
            INT top = glyphPos[i].GetTop();
            INT widthInPixels = glyphPos[i].GetWidth();
            INT right = left + widthInPixels;
            INT height = glyphPos[i].GetHeight();
            INT bottom = top + height;

            if (widthInPixels == 0 || height == 0)
                continue;

            INT widthInBytes = widthInPixels;

            const BYTE* mask = glyphPos[i].GetBits();

            ASSERT(mask != NULL);

            if (clipRegion != NULL)
            {
                GpRect clippedRect;
                DpRegion::Visibility visibility =
                        clipRegion->GetRectVisibility(left, top, right, bottom, &clippedRect);

                if (visibility == DpRegion::Invisible)
                    continue;

                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                            nextgrayscaleValue = *maskPtr;
                            maskPtr++;
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {

                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;

                                if (visibility == DpRegion::TotallyVisible)
                                {

                                //  Clip the run
                                    INT to = from + runLength; // reference needed
                                    output->OutputSpan(y, from, to);

                                    ARGB *buffer;
                                    buffer = output->GetScanBuffer()->GetCurrentBuffer();

                                    for (INT j = from; j < to; j++)
                                    {
                                        *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                    }

                                }
                                else
                                {

                                //  Clip the run

                                    INT to = from + runLength; // reference needed
                                    aaBrushSpan.SetCoverage(textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));

                                    clipRegion->OutputSpan(y, from, to);
                                }

                                //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
            else
            {


                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                            nextgrayscaleValue = *maskPtr;
                            maskPtr++;
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {
                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;


                            //  Clip the run
                                INT to = from + runLength; // reference needed

                                output->OutputSpan(y, from, to);
                                ARGB *buffer;
                                buffer = output->GetScanBuffer()->GetCurrentBuffer();
                                for (INT j = from; j < to; j++)
                                {
                                    *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                }

                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
        }

        if (clipRegion != NULL)
        {
            clipRegion->EndClipping();
        }

        delete output;
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Antialias version of routine to draw text based on a brush.
*
* Arguments:
*
*   [IN] - same as DDI parameters.
*
* Return Value:
*
*   Ok if successful.
*
* History:
*
*   1/28/00 YungT
*       Created it.
*
\**************************************************************************/

static GpStatus
OutputBrushAntiAliasText4BPP(
    DpContext*          context,
    DpDriver *          driver,
    DpBitmap*           surface,
    const GpRect*       drawBounds,
    const DpBrush*      brush,
    const GpGlyphPos*   glyphPos,
    INT                 count
    )
{
    DpScanBuffer scan(
        surface->Scan,
        driver,
        context,
        surface,
        FALSE); // (color64.IsOpaque() &&
                // (!context->AntiAliasMode)));
                // !!! If you fix this, you'll get a perf improvement for
                // text that has no transparency.

    if (!scan.IsValid())
    {
        return(GenericError);
    }

    DpOutputSpan* output = DpOutputSpan::Create(brush, &scan, context);

    DpOutputAntiAliasBrushOutputSpan aaBrushSpan;

    if (output != NULL)
    {
        INT i;

        TextColorGammaTable textContrastTable;
        textContrastTable.CreateTextColorGammaTable((GpColor *) NULL, context->TextContrast, GRAYSCALE_LEVEL);

        DpClipRegion* clipRegion = NULL;

        if (context->VisibleClip.GetRectVisibility( drawBounds->X, drawBounds->Y,
                                                    drawBounds->GetRight(), drawBounds->GetBottom()) !=
                                                    DpRegion::TotallyVisible)
        {
            aaBrushSpan.Init(output);

            clipRegion = &(context->VisibleClip);
            clipRegion->InitClipping(&aaBrushSpan, drawBounds->Y);
        }

        for (i = 0; i < count; i++)
        {
            INT left = glyphPos[i].GetLeft();
            INT top = glyphPos[i].GetTop();
            INT widthInPixels = glyphPos[i].GetWidth();
            INT right = left + widthInPixels;
            INT height = glyphPos[i].GetHeight();
            INT bottom = top + height;

            if (widthInPixels == 0 || height == 0)
                continue;

            INT widthInBytes = ((widthInPixels + 1) / 2);

            const BYTE* mask = glyphPos[i].GetBits();

            ASSERT(mask != NULL);

            if (clipRegion != NULL)
            {
                GpRect clippedRect;
                DpRegion::Visibility visibility =
                        clipRegion->GetRectVisibility(left, top, right, bottom, &clippedRect);

                if (visibility == DpRegion::Invisible)
                    continue;

                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr >> 4;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                           if (mx % 2)
                            {
                                nextgrayscaleValue = *maskPtr & 0x0F;
                                maskPtr++;
                            }
                            else
                            {
                                nextgrayscaleValue = *maskPtr >> 4;
                            }
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {

                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;

                                if (visibility == DpRegion::TotallyVisible)
                                {

                                //  Clip the run
                                    INT to = from + runLength; // reference needed
                                    output->OutputSpan(y, from, to);

                                    ARGB *buffer;
                                    buffer = output->GetScanBuffer()->GetCurrentBuffer();

                                    for (INT j = from; j < to; j++)
                                    {
                                        *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                    }

                                }
                                else
                                {

                                //  Clip the run

                                    INT to = from + runLength; // reference needed
                                    aaBrushSpan.SetCoverage(textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));

                                    clipRegion->OutputSpan(y, from, to);
                                }

                                //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
            else
            {


                for (INT y = top, my = 0; y < bottom && my < height; y++, my++)
                {
                    const BYTE* maskPtr = mask + my * widthInBytes;

                    BYTE grayscaleValue = *maskPtr >> 4;

                    INT runStart = 0;

                    for (INT mx = 0; mx <= widthInPixels; mx++)
                    {
                        BYTE nextgrayscaleValue;

                        if (mx == widthInPixels)
                        {
                            nextgrayscaleValue = 0;
                        }
                        else
                        {
                            if (mx % 2)
                            {
                                nextgrayscaleValue = *maskPtr & 0x0F;
                                maskPtr++;
                            }
                            else
                            {
                                nextgrayscaleValue = *maskPtr >> 4;
                            }
                        }

                        if (grayscaleValue != nextgrayscaleValue)
                        {

                            if (grayscaleValue != 0)
                            {
                             //  Draw this run

                                INT runLength = mx - runStart;
                                INT from = left + runStart;


                            //  Clip the run
                                INT to = from + runLength; // reference needed

                                output->OutputSpan(y, from, to);
                                ARGB *buffer;
                                buffer = output->GetScanBuffer()->GetCurrentBuffer();
                                for (INT j = from; j < to; j++)
                                {
                                    *buffer++ = GpColor::MultiplyCoverage(*buffer,
                                                           textContrastTable.GetGammaTableIndexValue(grayscaleValue, GRAYSCALE_LEVEL));
                                }

                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                            else
                            {
                             //  Start a new run
                                runStart = mx;
                                grayscaleValue = nextgrayscaleValue;
                            }
                        }
                    }
                }
            }
        }

        if (clipRegion != NULL)
        {
            clipRegion->EndClipping();
        }

        delete output;
    }

    return(Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Engine version of routine to draw solid text.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   TRUE if successful.
*
* History:
*   1/24/2000 YungT modified it
*   4/4/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus
DpDriver::BrushText(
    DpContext* context,
    DpBitmap* surface,
    const GpRect* drawBounds,
    const DpBrush*    brush,
    const GpGlyphPos *glyphPos,
    INT count,
    TextRenderingHint textMode
    )
{
    ASSERT (textMode != TextRenderingHintSystemDefault);
    switch(textMode)
    {
        case TextRenderingHintSingleBitPerPixelGridFit:
        case TextRenderingHintSingleBitPerPixel:
            return OutputBrushNormalText(context, this, surface, drawBounds, brush, glyphPos, count);
        case TextRenderingHintAntiAlias:
            return OutputBrushAntiAliasText8BPP(context, this, surface, drawBounds, brush, glyphPos, count);
        case TextRenderingHintAntiAliasGridFit:
            return OutputBrushAntiAliasText4BPP(context, this, surface, drawBounds, brush, glyphPos, count);
// version 2 :
//        case TextRenderingHintClearType:
        case TextRenderingHintClearTypeGridFit:
            return OutputBrushClearTypeText(context, this, surface, drawBounds, brush, glyphPos, count);
        default:
            break;
    }

    return Ok;

}






/////   GdiText - Draw glyph on downlevel DC
//
//      !!! Optimize to use lpdx
//      NOTE:
//      Here we explicitly call ExtTextOutW because we calling it with
//      ETO_GLYPH_INDEX. It will be fine even if we are running on Windows 9x
//      because internally it calls ExtTextOutA.
//      We didn't use Global::ExtTextOutFunction because we don't want to call
//      ExtTextOutA with ETO_GLYPH_INDEX while recording to a Meta file under
//      Windows 9x. And in that case Windows 9x fails to record it.
//      The code in Windows 9x is recording glyph indexes only if we are spooling
//      only otherwise it will not record.

GpStatus
DpDriver::GdiText(
    HDC             hdc,
    INT             angle,  // Tenths of a degree
    const UINT16   *glyphs,
    const PointF   *glyphOrigins,
    INT             glyphCount,
    BOOL            rightToLeft,
    UINT16          blankGlyph
)
{
    UINT16 lastTwoGlyphs[2];

    if (    glyphCount > 1
        &&  angle == 0)
    {
        // Try to optimise for horizintal text. (We don't try for vertical
        // text since GDI and GDI+ rotation semantics are not compatible)

        INT i=1;
        while (    i < glyphCount
               &&  abs(GpRound(glyphOrigins[i].Y - glyphOrigins[i-1].Y)) == 0)
        {
            i++;
        }

        if (i == glyphCount)
        {
            // All text is at the same dy

            AutoArray<INT> advances(new INT[glyphCount]);

            if (!advances)
            {
                return OutOfMemory;
            }

            if (rightToLeft && !Globals::IsNt && glyphCount>1)
            {
                // Windows 9x doesn't work with the negative advanced widths

                AutoArray<UINT16> bidiGlyphs(new UINT16[glyphCount]);
                if (!bidiGlyphs)
                {
                    return OutOfMemory;
                }

                for (i=0; i<glyphCount-1; i++)
                {
                    bidiGlyphs[i] = glyphs[glyphCount - i - 1];
                    advances[i]   = GpRound(glyphOrigins[glyphCount- i - 2].X - glyphOrigins[glyphCount- i - 1].X);
                }

                bidiGlyphs[glyphCount-1] = glyphs[0];
                advances[glyphCount-1]   = 0;

                if (blankGlyph > 0 && (glyphCount & 1))
                {
                    if (!ExtTextOutW(
                        hdc,
                        GpRound(glyphOrigins[glyphCount - 1].X),
                        GpRound(glyphOrigins[glyphCount - 1].Y),
                        ETO_GLYPH_INDEX,
                        NULL,
                        (PWSTR)bidiGlyphs.Get(),
                        glyphCount-1,
                        advances.Get()
                    )) {
                        return Win32Error;
                    }

                    lastTwoGlyphs[0] = bidiGlyphs[glyphCount-1];
                    lastTwoGlyphs[1] = blankGlyph;
                    
                    if (!ExtTextOutW(
                        hdc,
                        GpRound(glyphOrigins[0].X),
                        GpRound(glyphOrigins[0].Y),
                        ETO_GLYPH_INDEX,
                        NULL,
                        (PWSTR)lastTwoGlyphs,
                        2,
                        NULL
                    )) {
                        return Win32Error;
                    }
                }
                else
                {
                    if (!ExtTextOutW(
                        hdc,
                        GpRound(glyphOrigins[glyphCount - 1].X),
                        GpRound(glyphOrigins[glyphCount - 1].Y),
                        ETO_GLYPH_INDEX,
                        NULL,
                        (PWSTR)bidiGlyphs.Get(),
                        glyphCount,
                        advances.Get()
                    )) {
                        return Win32Error;
                    }
                }
                return Ok;
            }


            INT offset = GpRound(glyphOrigins[0].X);

            for (i=0; i<glyphCount-1; i++)
            {
                advances[i] = GpRound(glyphOrigins[i+1].X) - offset;
                offset += advances[i];
            }
            advances[glyphCount-1] = 0;


            if (blankGlyph > 0 && (glyphCount & 1))
            {
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[0].X),
                    GpRound(glyphOrigins[0].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)glyphs,
                    glyphCount-1,
                    advances.Get()
                )) {
                    return Win32Error;
                }

                lastTwoGlyphs[0] = glyphs[glyphCount-1];
                lastTwoGlyphs[1] = blankGlyph;
                
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[glyphCount-1].X),
                    GpRound(glyphOrigins[glyphCount-1].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)lastTwoGlyphs,
                    2,
                    NULL
                )) {
                    return Win32Error;
                }
            }
            else
            {
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[0].X),
                    GpRound(glyphOrigins[0].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)glyphs,
                    glyphCount,
                    advances.Get()
                )) {
                    return Win32Error;
                }
            }

            
            return Ok;
        }
    }



    if (blankGlyph > 0)
    {
        lastTwoGlyphs[1] = blankGlyph;
        
        for (INT i=0; i<glyphCount; i++)
        {
            if (glyphs[i] != 0xffff)    // 0xffff is never displayed
            {
                lastTwoGlyphs[0] = glyphs[i];
            
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[i].X),
                    GpRound(glyphOrigins[i].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)lastTwoGlyphs,
                    2,
                    NULL
                )) {
                    return Win32Error;
                }
            }
        }
    }
    else
    {
        // Failed to optimise ...
        for (INT i=0; i<glyphCount; i++)
        {
            if (glyphs[i] != 0xffff)    // 0xffff is never displayed
            {
                if (!ExtTextOutW(
                    hdc,
                    GpRound(glyphOrigins[i].X),
                    GpRound(glyphOrigins[i].Y),
                    ETO_GLYPH_INDEX,
                    NULL,
                    (PWSTR)glyphs+i,
                    1,
                    NULL
                )) {
                    return Win32Error;
                }
            }
        }
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\dispnotify.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*  Display/Palette notification routines for GDI+.
*
* Revision History:
*
*   7/19/99 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\render\vgahash.hpp"

#include <winuser.h>

VOID DisplayNotify();
VOID PaletteNotify();
VOID SysColorNotify();

/////////////////////////////// MESSAGE HANDLERS ///////////////////////////////

/**************************************************************************\
*
* Function Description:
*
*   This routine receives a display notification request and appropriately
*   readjusts the size and resolution of DCI screen surface.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID DisplayNotify()
{
    GpDevice *device = Globals::DesktopDevice;

    Devlock devlock(device);

    // Check to see if we have switched to a Terminal Server Session
    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        // it is a remote session
        Globals::IsTerminalServer = TRUE;
    }
    else
    {
        // it isn't a remote session.
        Globals::IsTerminalServer = FALSE;
    }

    
    Globals::DesktopDriver->DesktopChangeNotification();

    DWORD width, height;

    width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    if ((device != NULL) &&
        (device->DeviceHdc != NULL) &&
        (GetDeviceCaps(device->DeviceHdc, BITSPIXEL) <= 8))
    {
        // <SystemPalette>
        
        if (device->Palette == NULL) 
        {
            device->Palette = (ColorPalette*)GpMalloc(sizeof(ColorPalette)
                                                      + sizeof(ARGB) * 256);
            if (device->Palette == NULL)
            {
                return;
            }
        }
       
        INT           numEntries;
        PALETTEENTRY  palentry[256];
        RGBQUAD       rgb[256];
        ColorPalette* palette;

        palette = device->Palette;

        // [agodfrey] On Win9x, GetSystemPaletteEntries(hdc, 0, 256, NULL) 
        //    doesn't do what MSDN says it does. It seems to return the number
        //    of entries in the logical palette of the DC instead. So we have
        //    to make it up ourselves.
        
        numEntries = (1 << (GetDeviceCaps(device->DeviceHdc, BITSPIXEL) *
                            GetDeviceCaps(device->DeviceHdc, PLANES)));

        GetSystemPaletteEntries(device->DeviceHdc, 0, 256, &palentry[0]);

        palette->Count = numEntries;
        
        for (INT i=0; i<numEntries; i++) 
        {
            palette->Entries[i] = GpColor::MakeARGB(0xFF,
                                                    palentry[i].peRed,
                                                    palentry[i].peGreen,
                                                    palentry[i].peBlue);
            rgb[i].rgbRed = palentry[i].peRed;
            rgb[i].rgbGreen = palentry[i].peGreen;
            rgb[i].rgbBlue = palentry[i].peBlue;
            rgb[i].rgbReserved = 0;
        }
    
        if (device->DIBSectionBitmap != NULL) 
        {
            SetDIBColorTable(device->DIBSectionHdc, 0, numEntries, &rgb[0]);
        }

        Globals::PaletteChangeCount++;
    }

    // Set BufferWidth to 0.  This forces ::Start() to recreate the temporary
    // BufferDIB at the correct bit depth next time we process any cached records.

    // This needs to be done especially if the screen mode is not palettized
    // any more since the BufferDIB shouldn't be 8bpp, but reformatted to 32bpp.
    
    device->BufferWidth = 0;

    // Recreate the DCI object.  If the allocation fails, keep the old one
    // so that we don't access violate 'ScanDci' (although we might quite
    // happily draw wrong):

    EpScanGdiDci *scanDci = new EpScanGdiDci(Globals::DesktopDevice, TRUE);
    if (scanDci != NULL)
    {
        delete Globals::DesktopDevice->ScanDci;
        Globals::DesktopDevice->ScanDci = scanDci;
    }
    
    // update width and height on desktop surface
    // this copies the Device ScanDCI to Screen bitmap.

    Globals::DesktopSurface->InitializeForGdiScreen(
        Globals::DesktopDevice,
        width,
        height
    );
    
    // Give the driver an opportunity to adjust the surface.
    
    Globals::DesktopDriver->UpdateSurfacePixelFormat(
        Globals::DesktopSurface
    );
}

/**************************************************************************\
*
* Function Description:
*
*   This routine receives a palette change notification request and appropriately
*   readjusts the system palette matching.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID PaletteNotify()
{
    Devlock devlock(Globals::DesktopDevice);

    // update count to force lazy recomputation of translation vector
    Globals::PaletteChangeCount++;

    // update the system palette 
    Globals::DesktopDriver->PaletteChangeNotification();
}

/**************************************************************************\
*
* Function Description:
*
*   This routine receives a WM_SYSCOLORCHANGE notifications and updates the
*   system magic colors.
*
* History:
*
*   1/10/2K ericvan
*       Created it.
*
\**************************************************************************/

VOID SysColorNotify()
{
    // [ericvan] There is no synchronization here.  If a synchronization 
    // problem should occur, the worst side effect would be a bad
    // color which would go away on a repaint.  I think we can live with it.

    Globals::SystemColors[16] = ::GetSysColor(COLOR_3DSHADOW);
    Globals::SystemColors[17] = ::GetSysColor(COLOR_3DFACE);
    Globals::SystemColors[18] = ::GetSysColor(COLOR_3DHIGHLIGHT);
    Globals::SystemColors[19] = ::GetSysColor(COLOR_DESKTOP);
    
    VGAHashRebuildTable(&Globals::SystemColors[16]);
}

////////////////////////// MESSAGE/WINEVENT CALLBACKS //////////////////////////

/**************************************************************************\
*
* Function Description:
*
*   This routine is the GDI+ hidden window message pump.  If the app doesn't
*   hook us directly, then we add a top-level window to intercept
*   WM_DISPLAYCHANGE and WM_PALETTECHANGED directly.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

LRESULT 
CALLBACK
NotificationWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
   switch (uMsg) 
   {
   case WM_DISPLAYCHANGE:
      DisplayNotify();
      break;

   case WM_PALETTECHANGED:
      PaletteNotify();
      break;

   case WM_SYSCOLORCHANGE:
      SysColorNotify();
      break;

   case WM_WININICHANGE:
      if(lstrcmpiA((LPCSTR)(lParam), "intl") == 0)
      {
          Globals::UserDigitSubstituteInvalid = TRUE;
      } else if ((wParam == SPI_SETFONTSMOOTHING) || (wParam == SPI_SETFONTSMOOTHINGTYPE) ||
          (wParam == SPI_SETFONTSMOOTHINGCONTRAST) || (wParam == SPI_SETFONTSMOOTHINGORIENTATION))
      {
          Globals::CurrentSystemRenderingHintInvalid  = TRUE;
      }
      break;
      
   default:
      if (Globals::g_nAccessibilityMessage == uMsg && uMsg >= WM_USER)
      {
          Globals::g_fAccessibilityPresent = TRUE;
      }
      else
      {
          return DefWindowProcA(hwnd, uMsg, wParam, lParam);
      }
   }

   // return 0 if we processed it.
   return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   This routine is the GDI+ win-event hook.  It watches for full-drag
*   messages, to let the DCI renderer know when full-drag is being done.
*
* History:
*
*   3/21/2000 andrewgo
*       Created it.
*
\**************************************************************************/

VOID
CALLBACK
WinEventProcedure(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
    )
{
    ASSERT((event == EVENT_SYSTEM_MOVESIZESTART) ||
           (event == EVENT_SYSTEM_MOVESIZEEND));

    Globals::IsMoveSizeActive = (event == EVENT_SYSTEM_MOVESIZESTART);
}

/////////////////////// MESSAGE/WINEVENT INITIALIZATION ////////////////////////

VOID InternalNotificationShutdown();

/**************************************************************************\
*
* Function Description:
*
*   Called by NotificationStartup and BackgroundThreadProc.
*   Initializes the hidden window and WinEvent hook.
*
* Preconditions:
*
*   BackgroundThreadCriticalSection must be held.
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

BOOL
InternalNotificationStartup()
{
    // register a window class
    // we force ANSI rep using GDI+ for benefit of Win9x

    WNDCLASSA wndClass =
    {   
        0,
        &NotificationWndProc,
        0,
        0,
        DllInstance,
        NULL,
        NULL,
        NULL,
        "GDI+ Hook Window",
        "GDI+ Hook Window Class",
    };
    
    Globals::WindowClassAtom = RegisterClassA(&wndClass);

    if (!Globals::WindowClassAtom)
    {
        WARNING(("RegisterClass failed"));
        return FALSE;
    }

    // If this fails, we continue.  It just means we won't work properly
    // with accessibility software.

    Globals::g_nAccessibilityMessage =
        RegisterWindowMessageA("GDI+ Accessibility");
    
    Globals::HwndNotify = CreateWindowA((LPCSTR) Globals::WindowClassAtom,
                                        (LPCSTR) "GDI+ Window",
                                        WS_OVERLAPPED | WS_POPUP | WS_MINIMIZE,
                                        0,
                                        0,
                                        1,
                                        1,         // x,y,width,height
                                        NULL,      // hWndParent
                                        NULL,      // hMenu
                                        DllInstance,
                                        NULL);
    
    if (!Globals::HwndNotify) 
    {
        RIP(("CreateWindowA failed, the GDI+ hook window does not exist!"));
        InternalNotificationShutdown();
        return FALSE;
    }

    // [ericvan] This is BS, but must be done.  We only receive palette 
    // messages if we have called SelectPalette at least once on our primary DC.
    
    {
        struct {
            LOGPALETTE logpal;
            PALETTEENTRY palEntry[256];
        } lp;
        
        const ColorPalette* colorPal = GetDefaultColorPalette(PIXFMT_8BPP_INDEXED);
        
        lp.logpal.palVersion = 0x300;
        lp.logpal.palNumEntries = static_cast<WORD>(colorPal->Count);
        
        for (INT i=0; i<lp.logpal.palNumEntries; i++)
        {
            GpColor color(colorPal->Entries[i]);
        
            lp.logpal.palPalEntry[i].peRed = color.GetRed();
            lp.logpal.palPalEntry[i].peGreen = color.GetGreen();
            lp.logpal.palPalEntry[i].peBlue = color.GetBlue();
            lp.logpal.palPalEntry[i].peFlags = 0;
        }
        
        HPALETTE hPal = CreatePalette(&lp.logpal);
        HDC hdc = GetDC(Globals::HwndNotify);
        SelectPalette(hdc, hPal, FALSE);
        ReleaseDC(Globals::HwndNotify, hdc);
        DeleteObject(hPal);
    }
    
    // [andrewgo] On NT, if a DCI lock is held while a window moves, NT is 
    // forced to redraw the whole screen.  If "Show window contents while 
    // dragging" (AKA "Full-drag") is enabled (it's on by default), 
    // then this can result in repeated, excessive repaints 
    // of the whole screen while somone is dragging a window around.
    //
    // We work around this by disabling DCI rendering while we notice
    // that window moves are happening.  
    
    if ((Globals::IsNt) && (Globals::SetWinEventHookFunction))
    {
        Globals::WinEventHandle = 
            (Globals::SetWinEventHookFunction)(EVENT_SYSTEM_MOVESIZESTART,
                                               EVENT_SYSTEM_MOVESIZEEND,
                                               NULL,
                                               WinEventProcedure,
                                               0,
                                               0,
                                               WINEVENT_OUTOFCONTEXT);
    
        ASSERT(Globals::WinEventHandle != NULL);

        if (!Globals::WinEventHandle)
        {
            InternalNotificationShutdown();
            return FALSE;
        }
    }
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Called by NotificationStartup and BackgroundThreadProc.
*   (Also by InternalNotificationStartup, to clean up when there's an 
*   error.)
*
*   Destroys the hidden window and WinEvent hook.
*
*   Keep this synchronized with SimulateInternalNotificationShutdown.
*
* Preconditions:
*
*   BackgroundThreadSection must be held.
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID
InternalNotificationShutdown()
{
    if (Globals::UnhookWinEventFunction && Globals::WinEventHandle)
    {
        (Globals::UnhookWinEventFunction)(Globals::WinEventHandle);
        Globals::WinEventHandle = NULL;
    }
    
    if (Globals::HwndNotify) 
    {
        if (Globals::IsNt && (Globals::OsVer.dwMajorVersion == 4))
        {
            // NT 4.0 has a problem in its DestroyWindow that will
            // leave the application in a zombie state. 
            // Leak the window and rely on process cleanup.
        }
        else
        {
            DestroyWindow(Globals::HwndNotify);
        }
        Globals::HwndNotify = NULL;
    }
    
    if (Globals::WindowClassAtom)
    {
        UnregisterClassA((LPCSTR)Globals::WindowClassAtom, DllInstance);
        Globals::WindowClassAtom = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   If the thread quits without cleaning up, this fixes our state
*   to avoid crashing later.
*
*   "Cleans up" what it can - keeps the state consistent, but may leak.
*
* Preconditions:
*
*   BackgroundThreadCriticalSection must be held.
*
* History:
*
*   9/16/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID
SimulateInternalNotificationShutdown()
{
    // UnhookWinEvent can't be called from a different thread; so if this
    // causes a leak, we can't help it.
    
    Globals::WinEventHandle = NULL;

    // DestroyWindow can't be called from a different thread; so if this
    // causes a leak, we can't help it.    
    
    Globals::HwndNotify = NULL;
    
    // I don't know about UnregisterClass. I'm assuming we can't call it here.
    // Anyway, the window may not have been destroyed, and MSDN says that must
    // happen first. So, if need be, we'll leak this too.
    
    Globals::WindowClassAtom = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Starts our top-level window, and sets up the WndProc and WinEventHook.
*   This must be called from a GUI thread - it's called from either our
*   own background thread, or by the app (via callback pointers returned
*   from GdiplusStartup).
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

GpStatus WINAPI 
NotificationStartup(
    OUT ULONG_PTR *token
    )
{
    GdiplusStartupCriticalSection critsec;

    // Generate the first token, if necessary.
    // Also handles wraparound.
    
    if (Globals::NotificationInitToken == 0)
    {
        Globals::NotificationInitToken = GenerateInitToken();
        
        // Make sure that the token isn't one of the "special" values.
        
        if (Globals::NotificationInitToken <= NotificationModuleTokenMax)
        {
            Globals::NotificationInitToken = NotificationModuleTokenMax + 1;
        }
    }
    
    // If there's no hidden window yet, create one.
    
    if (Globals::HiddenWindowOwnerToken == NotificationModuleTokenNobody)
    {
        // If there's a background thread, then the owner should be set to
        // 'NotificationModuleTokenGdiplus'.
        
        ASSERT (Globals::ThreadNotify == NULL);

        {
            // We take BackgroundThreadCriticalSection because that's a
            // precondition for InternalNotificationStartup(). I know that we
            // don't actually need to (there's no background thread at this
            // point) - but code can change, so this is safer.

            BackgroundThreadCriticalSection critsec;

            if (!InternalNotificationStartup())
            {
                return GenericError;
            }
        }

        // Store the token of this calling module - when it calls
        // NotificationShutdown, we must destroy the hidden window (and
        // start up the background thread, if necessary).

        Globals::HiddenWindowOwnerToken = Globals::NotificationInitToken;
    }
        
    *token = Globals::NotificationInitToken;

    // Increment the token counter for the next module
    
    Globals::NotificationInitToken++;
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Shuts down our top-level window, WndProc and WinEventHook.
*   This must be called from a GUI thread - it's called from either our
*   own background thread, or by the app (via callback pointers returned
*   from GdiplusStartup).
*
* History:
*
*   9/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

VOID WINAPI
NotificationShutdown(
    ULONG_PTR token
    )
{
    GdiplusStartupCriticalSection critsec;
    
    // The token they pass us should be the one we gave them, so it shouldn't
    // be one of the 'special values'.
    
    if (token <= NotificationModuleTokenMax)
    {
        RIP(("Invalid token passed to NotificationShutdown"));
        
        // Ignore the call.
        
        return;
    }
    
    if (token == Globals::HiddenWindowOwnerToken)
    {
        // The module that created the hidden window is shutting down.
        
        // There shouldn't be a background thread.
        ASSERT (Globals::ThreadNotify == NULL);
            
        {
            BackgroundThreadCriticalSection critsec;

            InternalNotificationShutdown();
        }

        Globals::HiddenWindowOwnerToken = NotificationModuleTokenNobody;

        // If this is not the final module to shut down, start up the
        // background thread

        if (Globals::LibraryInitRefCount > 1)
        {
            if (!BackgroundThreadStartup())
            {
                // !!! [johnstep] Ack, what can we do now? Another client may
                //                be happily using GDI+ and now we've lost
                //                our message notifications.

                WARNING(("Could not start background thread"));
            }
        }
    }
}    

////////////////////////////// BACKGROUND THREAD ///////////////////////////////

/**************************************************************************\
*
* Function Description:
*
*   Thread proc for our background GUI thread. Sets up a hidden window,
*   WndProc and WinEventHook, then starts the message loop.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification
*
\**************************************************************************/

DWORD
WINAPI
BackgroundThreadProc(
    VOID*
    )
{
    BOOL error=FALSE;
    HANDLE threadQuitEvent;
    
    {
        BackgroundThreadCriticalSection critsec;

        // Read threadQuitEvent under the critical section - ensures that
        // we don't get the NULL that was there before the main thread
        // initialized it. We can assume, though, that it won't change until
        // this thread ends.
        
        threadQuitEvent = Globals::ThreadQuitEvent;

        if (!InternalNotificationStartup())
        {
            error = TRUE;
        }
    }

    if (error)
    {
        return 0;
    }

    // [agodfrey] We used to have a call to "WaitForInputIdle" here, 
    // which caused problems. It was motivated by Shell and DDE - 
    // since calling GetMessage() signals user that "the app is 
    // ready to receive DDE messages", and we were doing
    // it in PROCESS_ATTACH, long before the app was really ready.
    //
    // Now, we simply disallow initializing GDI+ in PROCESS_ATTACH.
    
    // Process window messages
    // We use MsgWaitForMultipleObjects, so that we can catch both messages
    // and our "quit" event being signalled.
    
    DWORD dwWake;
    
    MSG msg;
    BOOL quit = FALSE;
    
    while (!quit)
    {
        dwWake = MsgWaitForMultipleObjects(
            1,
            &threadQuitEvent,
            FALSE,
            INFINITE,
            QS_ALLINPUT);
            
        if (dwWake == WAIT_OBJECT_0)
        {
            // Our "quit" event was signaled.
            
            quit = TRUE;
            break;
        }
        else if (dwWake == WAIT_OBJECT_0 + 1)
        {
            // We received a message
            while (PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message == WM_QUIT)
                {
                    quit = TRUE;
                    break;
                }
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
        else
        {
            RIP(("Unexpected return value from MsgQaitForMultipleObjects"));
        }
    }

    // Clean up:
    
    {
        BackgroundThreadCriticalSection critsec;
        InternalNotificationShutdown();
    }
    
    return 1;
}

/**************************************************************************\
*
* Function Description:
*
*   Starts up the background thread. If the user doesn't ask us to piggyback
*   our hidden window onto their main GUI thread, we end up here, to create
*   our own.
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification
*
\**************************************************************************/

BOOL
BackgroundThreadStartup()
{
    ASSERT(Globals::HiddenWindowOwnerToken == NotificationModuleTokenNobody);
    
    // [agodfrey] Create an event object. We'll use this to tell the 
    // background thread to quit.

    HANDLE threadQuitEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
    if (threadQuitEvent == NULL)
    {
        WARNING(("CreateEvent failed: %d", GetLastError()));
        BackgroundThreadShutdown();
        return FALSE;
    }
    
    {
        // Store threadQuitEvent while holding the correct critsec.

        BackgroundThreadCriticalSection critsec;
    
        Globals::ThreadQuitEvent = threadQuitEvent;
    }

    // Create the background thread.

    Globals::ThreadNotify = CreateThread(NULL,                        // LPSECURITY_ATTRIBUTES
                                         0,                           // same stack size
                                         &BackgroundThreadProc,
                                         0,                           // parameter to thread
                                         0,                           // creation flags
                                         &Globals::ThreadId);


    if (Globals::ThreadNotify == NULL)
    {
       BackgroundThreadShutdown();
       return FALSE;
    }
    
    // Record the fact that GDI+ has its own hidden window, and so
    // NotificationStartup shouldn't create another one.
    
    Globals::HiddenWindowOwnerToken = NotificationModuleTokenGdiplus;
    
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Shuts down the background thread.
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*   BackgroundThreadCriticalSection must *NOT* be held (we would deadlock).
*
* History:
*
*   7/23/1999 ericvan
*       Created it.
*   9/15/2000 agodfrey
*       #175866: Improved GDI+ startup, shutdown and event notification.
*       Made it more robust by adding an event, and changing the thread's
*       message loop so that it quits when the event is signaled.
*
\**************************************************************************/

VOID
BackgroundThreadShutdown()
{
    // Stop the background thread
    
    if (Globals::ThreadNotify != NULL)
    {
        ASSERT(Globals::HiddenWindowOwnerToken == NotificationModuleTokenGdiplus);
    
        // We want to be careful not to hold BackgroundThreadCriticalSection
        // while we wait for the thread to terminate, since that could
        // cause a deadlock situation (our wait would time out).
        
        HANDLE threadQuitEvent;
        
        {
            BackgroundThreadCriticalSection critsec;
    
            threadQuitEvent = Globals::ThreadQuitEvent;
        }
    
        ASSERT(threadQuitEvent); // If it's NULL, ThreadNotify should be NULL.
        
        SetEvent(threadQuitEvent);

        DWORD ret = WaitForSingleObject(Globals::ThreadNotify, INFINITE);
        ASSERT(ret == WAIT_OBJECT_0);
        
        CloseHandle(Globals::ThreadNotify);
        Globals::ThreadNotify = NULL;
        Globals::ThreadId = 0;
    
        Globals::HiddenWindowOwnerToken = NotificationModuleTokenNobody;
    }

    {
        BackgroundThreadCriticalSection critsec;
            
        // [agodfrey] I discovered that, if InternalGdiplusShutdown is called 
        // from PROCESS_DETACH, the system will have terminated the thread 
        // already; WaitForSingleObject returns immediately because the 
        // thread has already stopped running. 
        //
        // In this case, InternalNotificationShutdown() isn't called, i.e. the
        // globals it cleans up are still non-NULL. I deem this "ok" because,
        // if we're in PROCESS_DETACH, no-one's going to read those variables
        // again.
        //
        // Still, I don't know if there are other legitimate ways for the 
        // thread to end without it cleaning up properly. So we call 
        // SimulateInternalNotificationShutdown() just to be safe - it's not
        // very expensive.
        
        SimulateInternalNotificationShutdown();
        
        // Destroy the "quit" event
        
        if (Globals::ThreadQuitEvent)
        {
            CloseHandle(Globals::ThreadQuitEvent);
            Globals::ThreadQuitEvent = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\facerealization.cpp ===
#include "precomp.hpp"

#define PATH_HEIGHT_THRESHOLD 800

#define PAGE_SIZE (8*1024)
#define ROUND_TO_PAGE(x)  (((x)+PAGE_SIZE-1)&~(PAGE_SIZE-1))

#define CJMININCREMENT     0x2000
#define CJMAX              (16 * 0x2000)

#define FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED (FO_GRAYSCALE | FO_SUBPIXEL_4 | FO_CLEARTYPE_GRID | FO_CLEARTYPE | FO_MONO_UNHINTED | FO_COMPATIBLE_WIDTH)

// we want number divisible by 8 containing about 75 glyphs,
// almost an upper limit on number of glyphs in the metrics cache
// when running winstone memory constrained scenario

#define GD_INC  (76 * sizeof(GpGlyphData) * 2)

// GD_INC amounts to 1520 == 000005f0H, far less than a page.

// according to Kirk's statistics, very few realizations cache more
// than 60 glyphs, so we shall start with a block which contains about
// 60 glyphs

#define C_GLYPHS_IN_BLOCK 64

ULONG ulClearTypeFilter(GLYPHBITS *GlyphBits, ULONG cjBuf, CacheFaceRealization *prface);

BOOL SetFontXform(
    const GpGraphics *pdc,
    const GpFontFace *pfe,
    REAL              height,
    Unit              unit,
    FD_XFORM         *pfdx,
    BOOL              needPaths,
    const GpMatrix   *pmx
)
{
    REAL EmHt, scale;
    REAL DpiX, DpiY;

    if (needPaths && unit != UnitWorld)
        return FALSE;

    EmHt = pfe->GetDesignEmHeight();

    if (!needPaths)
    {
        DpiX = pdc->GetDpiX();
        DpiY = pdc->GetDpiY();

        // UnitDisplay is device dependent and cannot be used as a font unit
        ASSERT(unit != UnitDisplay);

        if (unit != UnitWorld && unit != UnitPixel)
        {
            height *= DpiY;

            switch (unit)
            {
            case UnitPoint:
                height /= 72.0;
                break;
            case UnitDocument:
                height /= 300.0;
                break;
            case UnitMillimeter:
                height *= 10.0;
                height /= 254.0;
                break;
            default:
                return FALSE;
            }
        }
    }

    scale = height / EmHt;

    GpMatrix tempMatrix(scale, 0, 0, scale, 0, 0);
    GpMatrix wtodMatrix;
    REAL m[6];

    if (pmx)
        tempMatrix.Append(*pmx);

    if (!needPaths)
    {
        pdc->GetWorldToDeviceTransform(&wtodMatrix);
        tempMatrix.Append(wtodMatrix);
    }

    tempMatrix.GetMatrix(m);

    pfdx->eXX = m[0];
    pfdx->eXY = m[1];
    pfdx->eYX = m[2];
    pfdx->eYY = m[3];

    // Adjust for the non-square resolution

    if (!needPaths)
    {
        if (DpiY != DpiX)
        {
            DpiX /= DpiY;
            pfdx->eXX *= DpiX;
            pfdx->eYX *= DpiX;
        }
    }

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////////

GpFaceRealization::GpFaceRealization(
    const GpFontFace  *face,
    INT                style,
    const GpMatrix    *matrix,
    const SizeF        dpi,
    TextRenderingHint  textMode,
    BOOL               bPath,
    BOOL               bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
    BOOL               bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                    used to do the italic simulation in the right direction */
) :
    prface        (NULL),
    Style         (style),
    Status        (GenericError),
    LimitSubpixel (FALSE)
{
    if (bInit(face, style, matrix, dpi, textMode, bPath, bCompatibleWidth, bSideways))
    {
        vGetCache();
        Status = Ok;
    }
}

void GpFaceRealization::CloneFaceRealization(
    const GpFaceRealization *  pfaceRealization,
    BOOL                bPath
)
{
    BOOL    bOK = FALSE;
    SizeF   dpi;

// Adjust for the non-square resolution
// Now we will not do it but eventually we will need to do it.

    prface = NULL;

    if (FindRealizedFace(pfaceRealization->pfdx(), pfaceRealization->GetFontFace(),
                            bPath, pfaceRealization->prface->fobj.flFontType))
        bOK = TRUE;

    dpi.Width = (REAL) pfaceRealization->prface->fobj.sizLogResPpi.cx;
    dpi.Height = (REAL) pfaceRealization->prface->fobj.sizLogResPpi.cy;

    if (!bOK && Realize(dpi, pfaceRealization->GetFontFace(), pfaceRealization->GetStyle(),
                    pfaceRealization->pfdx(), pfaceRealization->prface->fobj.flFontType, bPath))
    {
        prface->Face->pff->cRealizedFace +=1;
        bOK = TRUE;
    }

    if (bOK)
    {
        vGetCache();
        Status = Ok;
    }
}

BOOL GpFaceRealization::bInit(
    const GpFontFace *  pface,
    INT                 style,
    const GpMatrix *    matrix,
    SizeF               dpi,
    TextRenderingHint   textMode,
    BOOL                bPath,
    BOOL                bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
    BOOL                bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                      used to do the italic simulation in the right direction */
)
{

// It is a new version of face realization

    REAL        m[6];
    FD_XFORM    fdxTmp;
    BOOL        canSimulate = TRUE;

    ULONG fl = FO_EM_HEIGHT;
    ULONG flSim = 0;

    matrix->GetMatrix(m);

    fdxTmp.eXX = m[0];
    fdxTmp.eXY = m[1];
    fdxTmp.eYX = m[2];
    fdxTmp.eYY = m[3];

// Adjust for the non-square resolution
// Now we will not do it but eventually we will need to do it.

    prface = NULL;

    // TextRenderingHintSystemDefault should already been converted through GetTextRenderingHintInternal
    ASSERT (textMode != TextRenderingHintSystemDefault);

    if (textMode == TextRenderingHintSingleBitPerPixel)
        fl |= FO_MONO_UNHINTED;
    else if (textMode == TextRenderingHintAntiAliasGridFit)
        fl |= FO_GRAYSCALE;
    else if (textMode == TextRenderingHintAntiAlias)
        fl |= FO_GRAYSCALE | FO_SUBPIXEL_4;
    else if (textMode == TextRenderingHintClearTypeGridFit)
    {
        fl |= FO_GRAYSCALE | FO_CLEARTYPE_GRID;
        if (bCompatibleWidth)
            fl |= FO_COMPATIBLE_WIDTH;
    }
// version 2 :
//    else if (textMode == TextRenderingHintClearType)
//        fl |= FO_GRAYSCALE | FO_CLEARTYPE;


    if (    style & FontStyleBold
        &&  !(pface->GetFaceStyle() & FontStyleBold))
    {
        if (pface->SimBold())
        {
            fl |= FO_SIM_BOLD;
        }
        else
        {
            return FALSE;   // Bold required but cannot be simulated
        }
    }


    if (    style & FontStyleItalic
        &&  !(pface->GetFaceStyle() & FontStyleItalic))
    {
        if (pface->SimItalic())
        {
            if (bSideways)
            {
                fl |= FO_SIM_ITALIC_SIDEWAYS;
            }
            else
            {
                fl |= FO_SIM_ITALIC;
            }
        }
        else
        {
            return FALSE;   // Italic required but cannot be simulated
        }
    }


    if (FindRealizedFace(&fdxTmp, pface, bPath, fl))
        return TRUE;

    if (Realize(dpi, pface, style, &fdxTmp, fl, bPath))
    {
        pface->pff->cRealizedFace +=1;
        return TRUE;
    }

    return FALSE;
}




// Destructor -- Unlocks the CacheFaceRealization

GpFaceRealization::~GpFaceRealization ()
{
    if (prface != (CacheFaceRealization *) NULL )
    {
        vReleaseCache();
    }
}


GpFaceRealization::ReuseRealizedFace()
{

    if (prface != (CacheFaceRealization *) NULL )
    {
        // free glyphbit cache

        GlyphBitsBlock *pbblfree, *pbbl = prface->FirstGlyphBitsBlock;
        while(pbbl)
        {
            pbblfree = pbbl;
            pbbl = pbbl->NextGlyphBitsBlock;
            GpFree((PVOID)pbblfree);
        }

        // free glyphdata cache

        GlyphDataBlock *pdblfree, *pdbl = prface->FirstGlyphDataBlock;
        while (pdbl)
        {
            pdblfree = pdbl;
            pdbl = pdbl->NextGlyphDataBlock;
            GpFree((PVOID)pdblfree);
        }

        GpFree(prface->GlyphDataArray);

        vDestroyRealizedFace(); /* release the FontContext Memory */
    }
    return TRUE;

}



GpFaceRealization::DeleteRealizedFace()
{

    if (prface != (CacheFaceRealization *) NULL )
    {
        ReuseRealizedFace();
        GpFree(prface);
    }

    return TRUE;
}

static inline
BOOL SwitchToPath(FLONG flFontType, const FD_DEVICEMETRICS & deviceMetrics)
{
    BOOL fResult = FALSE;
    INT pathThreshold = PATH_HEIGHT_THRESHOLD;

    if (flFontType & FO_CLEARTYPE_GRID)
        pathThreshold /= 8;
    else if (flFontType & FO_GRAYSCALE)
        pathThreshold /= 4;

    // Note: This function need quite a bit of reworking so that it takes
    // the rotation of the font into account when determining the transition
    // point between bitmap/CT and path. Currently the size where we switch
    // rendering modes is based on the maximum dimension of the bounding
    // box of the largest rotated character. Also note that if a single
    // glyph in the font is significantly offset from the rest of the
    // glyphs in the font, the deviceMetrics will indicate a much larger
    // required bitmap than we would normally use. This switch to path really
    // needs to be strictly based on the ascent of the font above the
    // baseline, independent of the rotation or the maximum bounding
    // rectangle for the rendered glyphs.

    if (flFontType & FO_CLEARTYPE_GRID)
    {
        // Cleartype should not take width of the bitmap into account.
        // For rotated text, we will cache larger bitmaps for ClearType
        // than for other rendering modes, but this will allow us to more
        // closely match the behavior of ClearType in notepad.

        fResult =
            (deviceMetrics.yMax - deviceMetrics.yMin) > pathThreshold;
    }
    else
    {
        fResult =
            (deviceMetrics.xMax - deviceMetrics.xMin) > pathThreshold ||
            (deviceMetrics.yMax - deviceMetrics.yMin) > pathThreshold;
    }

    return fResult;
} // SwitchToPath

BOOL GpFaceRealization::FindRealizedFace(
    FD_XFORM            *fdx,
    const GpFontFace    *fontFace,
    BOOL                needPaths,
    FLONG               fl
) const
{

    FLONG fltemp1 = fl & FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED;
    FLONG fltemp2 = fl & (FO_SIM_BOLD | FO_SIM_ITALIC | FO_SIM_ITALIC_SIDEWAYS);

    for (prface = fontFace->pff->prfaceList;
         prface != NULL;
         prface = (prface->NextCacheFaceRealization == fontFace->pff->prfaceList) ? NULL : prface->NextCacheFaceRealization)
    {
        if (prface->Face == fontFace)
        {
            if ((prface->ForcedPath || (needPaths == IsPathFont())) &&
                MatchFDXForm(fdx))
            {
                if (IsPathFont())
                {
                    // if for given text rendering hint we can't switch to path
                    // skip this realization (unless someone really wants path)
                    if (!needPaths && !SwitchToPath(fl, prface->DeviceMetrics))
                        continue;
                }
                else
                {
                    // FO_NOGRAY16 means that for this transform, grayscale was turned off following the "gasp" table
                    // see vSetGrayState__FONTCONTEXT in TrueType driver
                    FLONG fltemp = fltemp1;
                    if (prface->fobj.flFontType & FO_NOGRAY16)
                        fltemp &= ~FO_GRAYSCALE;

                    if (prface->fobj.flFontType & FO_NOCLEARTYPE)
                    {
                        if (fltemp & FO_CLEARTYPE_GRID)
                            fltemp &= ~(FO_CLEARTYPE_GRID | FO_GRAYSCALE | FO_COMPATIBLE_WIDTH);
                    }

                    if ((prface->fobj.flFontType & FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED) != fltemp)
                    {
                        continue;
                    }
                }

                if ((prface->fobj.flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC | FO_SIM_ITALIC_SIDEWAYS)) != fltemp2)
                    continue;

                // We need to update the recently used list here!
                Globals::FontCacheLastRecentlyUsedList->RemoveFace(prface);
                Globals::FontCacheLastRecentlyUsedList->AddMostRecent(prface);

                return TRUE;
            }
        }
    }

    prface = NULL;

    return FALSE;
}




BOOL GpFaceRealization::bGetDEVICEMETRICS()
{

    if (ttfdSemQueryFontData(
        &prface->fobj,
        QFD_MAXEXTENTS,
        HGLYPH_INVALID,
        (GLYPHDATA *) NULL,
        &prface->DeviceMetrics) == FD_ERROR)
    {
    // The QFD_MAXEXTENTS mode is required of all drivers.
    // However must allow for the possibility of this call to fail.
    // This could happen if the
    // font file is on the net and the net connection dies, and the font
    // driver needs the font file to produce device metrics [bodind]

        return FALSE;
    }


    if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
    {
        // need to compute the filtering correction for CLEAR_TYPE:
        // x filtering adds a pixel on each side of the glyph
        prface->MaxGlyphByteCount = CJ_CTGD(
            prface->DeviceMetrics.cxMax + 2,
            prface->DeviceMetrics.cyMax
        );
    }
    else
    {
        prface->MaxGlyphByteCount = prface->DeviceMetrics.cjGlyphMax; // used to get via QFD_MAXGLYPHBITMAP
    }


    // Everythings OK.

    return TRUE;
}




VOID  GpFaceRealization::vDestroyRealizedFace()
{
    ttfdSemDestroyFont(&prface->fobj);
}

BOOL GpFaceRealization::Realize(
    SizeF             dpi,
    const GpFontFace *pfe,
    INT               style,      // style - which may require simulation
    PFD_XFORM         pfdx,       // font xform (Notional to Device)
    FLONG             fl,         // these two really modify the xform
    BOOL              bNeedPaths
)
{
    BOOL result = FALSE;

// prface is a member variable pointing to the embedded CacheFaceRealization

    if (Globals::FontCacheLastRecentlyUsedList->GetCount() >= MAXRECENTLYUSEDCOUNT)
    {
        prface = Globals::FontCacheLastRecentlyUsedList->ReuseLeastRecent();

        ASSERT(prface);
    }
    else
    {
        prface = (CacheFaceRealization *)GpMalloc(sizeof(CacheFaceRealization));
    }

    if (!prface)
        return FALSE;

// Copy the font transform passed in.

    prface->fobj.fdx = *pfdx;

// Initialize the DDI callback EXFORMOBJ.

    GpMatrix tmpMatrix(pfdx->eXX, pfdx->eXY, pfdx->eYX, pfdx->eYY, 0, 0);
    prface->mxForDDI = tmpMatrix;

// Initialize the FONTOBJ inherited by the embedded CacheFaceRealization

// Save identifiers to the source of the font (physical font).

    prface->Face = pfe;

// GetDpiX() and GetDpiY() return REALs

    prface->fobj.sizLogResPpi.cx = GpRound(dpi.Width);
    prface->fobj.sizLogResPpi.cy = GpRound(dpi.Height);

    prface->fobj.ulPointSize = 0;
    prface->fobj.flFontType = fl | FO_TYPE_TRUETYPE;              // fl contains simulation flag(s)
    prface->fobj.pvProducer = (PVOID) NULL;          // the true type driver will init this field
    prface->fobj.iFace = prface->Face->iFont;
    prface->fobj.iFile = prface->Face->pff->hff;


// Get the device metrics info

    if (!bGetDEVICEMETRICS())
    {
        vDestroyRealizedFace(); // kill the driver realization
        GpFree(prface);
        prface = NULL;
        return result;        // return FALSE
    }

    prface->CacheType = bNeedPaths ? CachePath : CacheBits;
    prface->ForcedPath = FALSE;

    if (!bNeedPaths)
    {
        // We force drawing with a path if size is to large
        if (SwitchToPath(prface->fobj.flFontType, prface->DeviceMetrics))
        {
            prface->CacheType = CachePath;
            prface->ForcedPath = TRUE;
        }
    }


// If you force the path mode then turn off antialiasing

    if (IsPathFont())
    {
        prface->fobj.flFontType &= ~FONT_GRAYSCALE_OR_CT_OR_MONOUNHINTED;
        prface->realizationMethod = TextRenderingHintSingleBitPerPixelGridFit;
        prface->QueryFontDataMode = QFD_GLYPHANDOUTLINE;
    }
    else
    {
        if (prface->fobj.flFontType & FO_GRAYSCALE)
        {
// version 2 :
//            if (prface->fobj.flFontType & FO_CLEARTYPE)
//            {
//                prface->realizationMethod = TextRenderingHintClearType;
//                prface->QueryFontDataMode = QFD_CT;
//            }
            if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
            {
                prface->realizationMethod = TextRenderingHintClearTypeGridFit;
                prface->QueryFontDataMode = QFD_CT_GRID;
            }
            else if (prface->fobj.flFontType & FO_SUBPIXEL_4)
            {
                prface->CacheType = CacheAABits;
                prface->realizationMethod = TextRenderingHintAntiAlias;
                prface->QueryFontDataMode = QFD_TT_GRAY4_BITMAP;
            }
            else
            {
                prface->realizationMethod = TextRenderingHintAntiAliasGridFit;
                prface->QueryFontDataMode = QFD_TT_GRAY4_BITMAP;
            }
        }
        else
        {
            if (prface->fobj.flFontType & FO_MONO_UNHINTED)
            {
                prface->realizationMethod  = TextRenderingHintSingleBitPerPixel;
                prface->QueryFontDataMode = QFD_GLYPHANDBITMAP_SUBPIXEL;
            }
            else
            {
                prface->realizationMethod  = TextRenderingHintSingleBitPerPixelGridFit;
                prface->QueryFontDataMode = QFD_GLYPHANDBITMAP;
            }
        }
    }

    if (!bInitCache())
    {
        vDestroyRealizedFace(); // kill the driver realization
        GpFree(prface);
        prface = NULL;
        return result;        // return FALSE
    }

// Made it this far, so everything is OK

    result = TRUE;

    Globals::FontCacheLastRecentlyUsedList->AddMostRecent(prface);

    vInsert(&prface->Face->pff->prfaceList);

    return result;
}




VOID GpFaceRealization::vInsert(CacheFaceRealization **pprfaceHead)
{

    if (*pprfaceHead != NULL)
    {
        prface->NextCacheFaceRealization = *pprfaceHead;

        prface->PreviousCacheFaceRealization = (*pprfaceHead)->PreviousCacheFaceRealization;

        prface->PreviousCacheFaceRealization->NextCacheFaceRealization = prface;

        (*pprfaceHead)->PreviousCacheFaceRealization = prface;
    }
    else
    {
        prface->NextCacheFaceRealization = prface;
        prface->PreviousCacheFaceRealization = prface;
    }

    *pprfaceHead = prface;

}




BOOL GpFaceRealization::bInitCache() const
{
    BOOL result = TRUE;     // unless proven otherwise

    // Set the pointer to null.  vDeleteCache will free memory from
    // any non-null pointers.  This simplifies cleanup, since bRealize
    // ensures that vDeleteCache is called if this routine fails.

    // metrics portion

    prface->FirstGlyphDataBlock = NULL;
    prface->GlyphDataBlockUnderConstruction = NULL;
    prface->NextFreeGlyphDataIndex    = 0;

    // glyphbits portion

    prface->FirstGlyphBitsBlock = NULL;
    prface->GlyphBitsBlockUnderConstruction = NULL;
    prface->SizeGlyphBitsBlockUnderConstruction    = 0;
    prface->UsedBytesGlyphBitsBlockUnderConstruction    = 0;

    // aux mem portion

    prface->LookasideGlyphData = NULL;
    prface->LookasideByteCount = 0;
    prface->GlyphDataArray = NULL; // to be allocated later, big allocation


    prface->NextCacheFaceRealization = NULL;
    prface->PreviousCacheFaceRealization = NULL;

    // First, figure out how big the max glyph will be
    // Default is zero - glyphdata size is not counted!

    ULONG  cjGlyphMaxX2;

    if (IsPathFont())
    {
        cjGlyphMaxX2 = CJMAX;
    }
    else
    {
        cjGlyphMaxX2 = 2 * prface->MaxGlyphByteCount;
    }

    // if we can't even get one glyph in a maximum size cache, don't cache
    // Note that we need room for the default glyph and one other glyph

    prface->NoCache = FALSE;

    if (cjGlyphMaxX2 > CJMAX)
    {

        // Glyph exceeds maximum cache memory size, so we will revert to
        // caching just the metrics.  This will speed up things like
        // GetCharWidths, and stuff that just *has* to have the glyphs
        // will use the lookaside stuff (previously called BigGlyph)

        /* we don't support NoCache and Path */
        ASSERT(!IsPathFont())
        prface->NoCache = TRUE;
    }


    // set up the cache semaphore.
    // InitializeCriticalSection(&prface->FaceRealizationCritSection);

    return result;
}




BOOL GpFaceRealization::AllocateCache() const
{
    BOOL result = TRUE;     // unless proven otherwise

    ULONG cGlyphsTotal = 0;

    cGlyphsTotal = GetGlyphsSupported();

    if (!cGlyphsTotal)
        return FALSE;

    // The distribution of metics per realized font w/ Winstone97 is:
    //
    //      43% <= 0 Metrics
    //      50% <= 6 Metrics
    //      76% <= 32 Metrics
    //      99% <= 216 Metrics
    //      100% <= 249 Metrics
    //


    // allocate memory for the glyphDataArray :

    if ((prface->GlyphDataArray = (GpGlyphData **) GpMalloc(cGlyphsTotal * sizeof(GpGlyphData*))) == NULL)
    {
        return FALSE;
    }

    // init all glyphdata pointers to zero

    memset(prface->GlyphDataArray, 0, sizeof(GpGlyphData*) * cGlyphsTotal);


    // Allocate memory for the first GpGlyphData block

    if ((prface->GlyphDataBlockUnderConstruction = (GlyphDataBlock *)GpMalloc(sizeof(GlyphDataBlock))) == NULL)
    {
        return FALSE;
    }
    prface->FirstGlyphDataBlock = prface->GlyphDataBlockUnderConstruction;
    prface->FirstGlyphDataBlock->NextGlyphDataBlock = NULL;
    prface->NextFreeGlyphDataIndex = 0;

    // we shall re-interpret cjMax to mean the max number of bytes in
    // glyphbits portion of the cache per 1K of glyphs in the font.
    // That is for larger fonts we shall allow more glyphbits
    // memory per realization than for ordinary US fonts. This will be
    // particularly important for FE fonts. This same code will work fine
    // in their case too:

    ULONG cjBytes = 16 * prface->MaxGlyphByteCount;

    ULONG AllocationSize = ROUND_TO_PAGE(cjBytes);

    if (AllocationSize == 0)
        prface->cBlocksMax = 1;
    else
    {
        prface->cBlocksMax =
            (CJMAX * ((cGlyphsTotal + 1024 - 1)/1024)) /
            AllocationSize;

        /* at least one block */
        if (prface->cBlocksMax == 0)
            prface->cBlocksMax = 1;
    }
    prface->cBlocks = 0;

    return result;
}




////  ConvertGLYPHDATAToGpGlyphMetrics
//
//    Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA


VOID GpFaceRealization::ConvertGLYPHDATAToGpGlyphMetrics(
    IN   INT           glyphIndex,
    IN   GLYPHDATA    *pgd,
    OUT  GpGlyphData  *pgpgd
) const
{
    // horizontal metrics:

    pgpgd->GlyphMetrics[0].AdvanceWidth        = pgd->fxD;
    pgpgd->GlyphMetrics[0].LeadingSidebearing  = pgd->fxA;
    pgpgd->GlyphMetrics[0].TrailingSidebearing = pgd->fxD - pgd->fxAB;
    pgpgd->GlyphMetrics[0].Origin              = PointF(0,0);

    // vertical metrics:

    pgpgd->GlyphMetrics[1].AdvanceWidth        = pgd->fxD_Sideways;
    pgpgd->GlyphMetrics[1].LeadingSidebearing  = pgd->fxA_Sideways;
    pgpgd->GlyphMetrics[1].TrailingSidebearing = pgd->fxD_Sideways - pgd->fxAB_Sideways;

    pgpgd->GlyphMetrics[1].Origin.X = pgd->VerticalOrigin_X / 16.0f;
    pgpgd->GlyphMetrics[1].Origin.Y = pgd->VerticalOrigin_Y / 16.0f;

    pgpgd->GlyphBits = NULL;
}




GpStatus GpFaceRealization::IsMetricsCached
(
    UINT16      glyphIndex,
    ULONG       *pcjNeeded
) const
{
    ULONG cjNeeded = 0;

    if (prface->GlyphDataArray == NULL)
        if (!AllocateCache())
            return OutOfMemory;

    if (glyphIndex >= prface->Face->NumGlyphs)
        return InvalidParameter;

    if (!prface->GlyphDataArray[glyphIndex])
    {
        GLYPHDATA   gd;

        // Verify enough room in metrics cache area, grow if needed.
        // Note that failure to fit a glyphdata is a hard error, get out now.

        if (!CheckMetricsCache())
        {
            return GenericError;
        }

        // Call font driver to get the metrics.

        cjNeeded = ttfdSemQueryFontData(
            &prface->fobj,
            prface->QueryFontDataMode,
            (HGLYPH)glyphIndex,
            &gd,
            NULL
        );
        if (cjNeeded == FD_ERROR)
        {
            return GenericError;
        }

        gd.gdf.pgb = NULL;

        if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
        {
            ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
            ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);
            ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
            cjNeeded = CJ_CTGD(cx+2,cy);
        }

        prface->GlyphDataArray[glyphIndex] = &prface->GlyphDataBlockUnderConstruction->GlyphDataArray[prface->NextFreeGlyphDataIndex];

        // Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA

        ConvertGLYPHDATAToGpGlyphMetrics(glyphIndex, &gd, prface->GlyphDataArray[glyphIndex]);

        prface->NextFreeGlyphDataIndex ++;
    }

    if (pcjNeeded)
    {
        *pcjNeeded = cjNeeded;
    }


    ASSERT(prface->GlyphDataArray[glyphIndex])

    return Ok;
}




BOOL GpFaceRealization::InsertGlyphPath(
    UINT16          glyphIndex,
    BOOL            bFlushOk
) const
{

// Call font driver to get the metrics.

    GpGlyphPath  *fontPath;

    GLYPHDATA   gd;
    GpPath      path;

    ASSERT(IsPathFont());
    ASSERT(prface->GlyphDataArray[glyphIndex]);

    if (prface->GlyphDataArray[glyphIndex]->GlyphPath)
        return TRUE;

    ULONG cjNeeded = ttfdSemQueryFontData(
        &prface->fobj,
        prface->QueryFontDataMode,
        (HGLYPH)glyphIndex,
        &gd,
        (PVOID)&path
    );

    if ( cjNeeded == FD_ERROR )
        return FALSE;

    if (!path.IsValid())
        return FALSE;

    cjNeeded = sizeof(GpGlyphPath) +
               path.GetPointCount() * (sizeof(GpPointF) + sizeof(BYTE));
    cjNeeded = ALIGN(void*, cjNeeded);

    /* a GpGlyphPath* need to be aligned to the next valid pointer address */
    ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);

    VOID *GlyphBits;

    while ((GlyphBits = (GLYPHBITS *)pgbCheckGlyphCache(cjNeeded)) == NULL)
    {
        if ( !bFlushOk )
            return FALSE;

        //TRACE_INSERT(("InsertGlyphBits: Flushing the cache\n"));

        FlushCache();
        bFlushOk = FALSE;
    }

    fontPath = (GpGlyphPath*)GlyphBits;

    if (fontPath->CopyPath(&path) != Ok)
        return FALSE;

    prface->GlyphDataArray[glyphIndex]->GlyphPath = fontPath;

    prface->UsedBytesGlyphBitsBlockUnderConstruction += cjNeeded;

    return TRUE;
}




BOOL GpFaceRealization::InsertGlyphBits(
    UINT16      glyphIndex,
    ULONG       cjNeeded,
    BOOL        bFlushOk
) const
{
    if (prface->NoCache)
    {
        return FALSE;
    }

    ASSERT(!IsPathFont());
    ASSERT(prface->GlyphDataArray[glyphIndex]);

    if (prface->GlyphDataArray[glyphIndex]->GlyphBits)
        return TRUE;

    // Look to see if there is room in the glyphbits cache
    // Grow the glyphbits cache if neccessary, but don't flush the cache

    GLYPHDATA gd;

    // If max glyph will fit, assume max glyph
    // otherwise, call up and ask how big

    if ( (prface->MaxGlyphByteCount < (SIZE_T)(prface->SizeGlyphBitsBlockUnderConstruction - prface->UsedBytesGlyphBitsBlockUnderConstruction))  )
    {
        cjNeeded = prface->MaxGlyphByteCount;
    }
    else
    {
        if (!cjNeeded)
        {
            cjNeeded = ttfdSemQueryFontData(
                &prface->fobj,
                prface->QueryFontDataMode,
                glyphIndex,
                &gd,
                NULL
            );

            if ( cjNeeded == FD_ERROR )
                return FALSE;

            if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
            {
                ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
                ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);
                ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
                cjNeeded = CJ_CTGD(cx+2,cy);
            }
        }
    }

    // Now, we try to fit the bits in.  If they fit, fine.
    // If not, and we can flush the cache, we flush it and try again.
    // If we couldn't flush, or we flushed and still fail, just return.

    GLYPHBITS *GlyphBits;

    //TRACE_INSERT(("InsertGlyphBits: attempting to insert bits at: 0x%lx\n", prface->UsedBytesGlyphBitsBlockUnderConstruction));

    while ((GlyphBits = (GLYPHBITS *)pgbCheckGlyphCache(cjNeeded)) == NULL)
    {
        if ( !bFlushOk )
            return FALSE;

        //TRACE_INSERT(("InsertGlyphBits: Flushing the cache\n"));

        FlushCache();
        bFlushOk = FALSE;
    }

    // Call font driver to get glyph bits.

    cjNeeded = ttfdSemQueryFontData(
                         &prface->fobj,
                         prface->QueryFontDataMode,
                         glyphIndex,
                         &gd,
                         (VOID *)GlyphBits
                         );

    if ( cjNeeded == FD_ERROR )
            return FALSE;

    ASSERT(cjNeeded <= prface->MaxGlyphByteCount);
    if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
    {
        ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
        ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);

        ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
        cjNeeded = CJ_CTGD(cx+2,cy);

        ASSERT(cjNeeded <= prface->MaxGlyphByteCount);

        if (GlyphBits)
        {
            cjNeeded = ulClearTypeFilter(GlyphBits, cjNeeded, prface);
        }
    }

    // Only the glyph bits we need.

    prface->GlyphDataArray[glyphIndex]->GlyphBits = GlyphBits;

    // Adjust the cache next pointers as needed.

    prface->UsedBytesGlyphBitsBlockUnderConstruction += cjNeeded;

    return TRUE;
}




////    GetGlyphDataLookaside
//
//      Returns glyph data for a single glyph, using the lookaside buffer
//      instead of the cache.



GpGlyphData *GpFaceRealization::GetGlyphDataLookaside(
    UINT16      glyphIndex
) const
{
    if (!IsPathFont())
    {
        // Make sure the lookaside buffer has enough room for the bitmap

        ULONG cjMaxBitmap = prface->MaxGlyphByteCount + sizeof(GpGlyphData);

        // Allocate the buffer and save its size if existing buffer isn't big enough

        if (prface->LookasideByteCount < cjMaxBitmap)
        {
            if (prface->LookasideGlyphData != NULL)
            {
                GpFree(prface->LookasideGlyphData);
            }

            prface->LookasideGlyphData = (GpGlyphData  *)GpMalloc(cjMaxBitmap);

            if (prface->LookasideGlyphData == NULL)
                return NULL;

            prface->LookasideByteCount = cjMaxBitmap;
        }

        GpGlyphData *pgd       = prface->LookasideGlyphData;
        GLYPHBITS   *glyphBits = (GLYPHBITS *)(pgd + 1);
        GLYPHDATA    gd;

        ULONG cjNeeded = ttfdSemQueryFontData(
            &prface->fobj,
            prface->QueryFontDataMode,
            glyphIndex,
            &gd,
            glyphBits
        );

        if (cjNeeded == FD_ERROR)
            return NULL;

        ASSERT(cjNeeded <= prface->MaxGlyphByteCount);

        if (prface->fobj.flFontType & FO_CLEARTYPE_GRID)
        {
            ULONG cx = (ULONG)(gd.rclInk.right  - gd.rclInk.left);
            ULONG cy = (ULONG)(gd.rclInk.bottom - gd.rclInk.top);

            ASSERT(cjNeeded <= CJ_CTGD(cx+2,cy));
            cjNeeded = CJ_CTGD(cx+2,cy);

            ASSERT(cjNeeded <= prface->MaxGlyphByteCount);

            if (glyphBits)
            {
                cjNeeded = ulClearTypeFilter(glyphBits, cjNeeded, prface);
            }
        }

        // Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA

        ConvertGLYPHDATAToGpGlyphMetrics(glyphIndex, &gd, pgd);

        // Set the returned value

        pgd->GlyphBits = glyphBits;

        return pgd;
    }
    else
    {
        // For glyph path

        // Call font driver to get the metrics.

        GLYPHDATA   gd;
        GpPath      path;

        // Verify enough room in metrics cache area, grow if needed.
        // Note that failure to fit a glyphdata is a hard error, get out now.


        ULONG cjNeeded = ttfdSemQueryFontData(
                               &prface->fobj,
                               prface->QueryFontDataMode,
                               (HGLYPH)glyphIndex,
                               &gd,
                               (PVOID)&path
        );

        if ( cjNeeded == FD_ERROR )
            return NULL;

        if (!path.IsValid())
            return NULL;

        cjNeeded = sizeof(GpGlyphData) + sizeof(GpGlyphPath) + path.GetPointCount() * (sizeof(GpPointF) + sizeof(BYTE));
        cjNeeded = ALIGN(void*, cjNeeded);

        // Make sure the lookaside buffer is allocated

        if ( ( prface->LookasideByteCount < cjNeeded ) &&
             ( prface->LookasideGlyphData != NULL ))
        {
           GpFree((PVOID) prface->LookasideGlyphData);
           prface->LookasideGlyphData = NULL;
           prface->LookasideByteCount = 0;
        }

        if ( prface->LookasideGlyphData == NULL )
        {
            prface->LookasideGlyphData = (GpGlyphData *)GpMalloc(cjNeeded);

            if ( prface->LookasideGlyphData == NULL )
                return NULL;

            prface->LookasideByteCount = cjNeeded;
        }

        GpGlyphData *   pgd = prface->LookasideGlyphData;
        GpGlyphPath *   fontPath = (GpGlyphPath *)(pgd + 1);

        // Populate GpGlyphMetrics field of GpGlyphData from font driver GLYPHDATA
        ConvertGLYPHDATAToGpGlyphMetrics(glyphIndex, &gd, pgd);

        if (fontPath->CopyPath(&path) != Ok)
            return FALSE;

        // Set the returned value

        pgd->GlyphPath = fontPath;

        return pgd;
    }

}




BOOL GpFaceRealization::CheckMetricsCache() const
{

// Verify enough room in metrics cache area, grow if needed.

    if (prface->NextFreeGlyphDataIndex >= GLYPHDATABLOCKCOUNT)
    {
        GlyphDataBlock *NewGlyphDataBlock;

        // allocate a new block of GpGlyphData structs

        if ((NewGlyphDataBlock = (GlyphDataBlock *)GpMalloc(sizeof(GlyphDataBlock))) == NULL)
        {
            return FALSE;
        }
        NewGlyphDataBlock->NextGlyphDataBlock = NULL;

        prface->GlyphDataBlockUnderConstruction->NextGlyphDataBlock = NewGlyphDataBlock;

        prface->GlyphDataBlockUnderConstruction = NewGlyphDataBlock;
        prface->NextFreeGlyphDataIndex = 0;
    }

    return TRUE;
}


PVOID GpFaceRealization::pgbCheckGlyphCache(SIZE_T cjNeeded) const
{
    if ((prface->UsedBytesGlyphBitsBlockUnderConstruction + cjNeeded) > prface->SizeGlyphBitsBlockUnderConstruction)
    {
        ULONG cjBlockSize;


        ASSERT (!(prface->NoCache));

        if (IsPathFont())
        {
            // this seems to work and this is what we did before DavidFie changes
            // for PATHOBJ case

            cjBlockSize = CJMAX;
        }
        else
        {
            ULONG cjBytes = 16 * prface->MaxGlyphByteCount;

            cjBlockSize = ROUND_TO_PAGE(cjBytes);

            if (prface->FirstGlyphBitsBlock == NULL)
            {
                // first block designed to contain 16 glyphs

                cjBlockSize =  cjBytes;
            }
        }

        if (    !(prface->NoCache)
            &&  (prface->cBlocks < prface->cBlocksMax)
            &&  ((offsetof(GlyphBitsBlock,Bits) + cjNeeded) <= cjBlockSize))
        {
            // The only reason we need the last check is the PATHOBJ case
            // where cjNeeded may actually not fit in the block of SizeGlyphBitsBlock bytes.
            // This is because we have no way of knowing how big the paths
            // are going to be (especailly after doing bFlatten) and our
            // prface->MaxGlyphByteCount is just a good guess in this case.

            // We are going to append another block at the end of the list

            GlyphBitsBlock  *newGlyphBitsBlock = (GlyphBitsBlock *) GpMalloc(cjBlockSize);

            if (!newGlyphBitsBlock)
            {
                return NULL;
            }

            //  we have just allocated another block, update cBlocks:

            prface->cBlocks += 1;

            // append this block to the end of the list

            newGlyphBitsBlock->NextGlyphBitsBlock = NULL;

            if (prface->GlyphBitsBlockUnderConstruction != NULL)
                prface->GlyphBitsBlockUnderConstruction->NextGlyphBitsBlock = newGlyphBitsBlock;

            prface->GlyphBitsBlockUnderConstruction = newGlyphBitsBlock;

            if (!prface->FirstGlyphBitsBlock) // first block ever for this rfont
            {
                prface->FirstGlyphBitsBlock  = newGlyphBitsBlock;
            }
            prface->GlyphBitsBlockUnderConstruction->SizeGlyphBitsBlock = cjBlockSize;
            prface->SizeGlyphBitsBlockUnderConstruction = cjBlockSize;
            prface->UsedBytesGlyphBitsBlockUnderConstruction = offsetof(GlyphBitsBlock,Bits);
            ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);


        }
        else
        {
            // tough luck, we are not allowed to add more blocks

            return NULL;
        }
    }

    return (BYTE *)prface->GlyphBitsBlockUnderConstruction + prface->UsedBytesGlyphBitsBlockUnderConstruction;
}


VOID GpFaceRealization::FlushCache() const
{

    // all the pointers to glyphs bits will be invalidated and we will start
    // filling the glyphbits cache all over again. Therefore, we set the current
    // block to be the same as base block and pgbN to the first available field in
    // in the Current block.
    // Note that vFlushCache is allways called after pgbCheckGlyphCache has failed.
    // pgbCheckGlyphCache could fail for one of the two following reasons:
    //
    // a) (pc->cBlocks == pc->cBlocksMax) && (no room in the last block)
    // b) (pc->cBlocks < pc->cBlocksMax) &&
    //    (failed to alloc mem for the new bitblock).
    //
    // In the latter case we do not want to flush glyphbits cache.
    // Instead we shall try to allocate one more time a bit later.


    if (prface->FirstGlyphBitsBlock && (prface->cBlocks == prface->cBlocksMax))
    {
        prface->GlyphBitsBlockUnderConstruction = prface->FirstGlyphBitsBlock;
        prface->UsedBytesGlyphBitsBlockUnderConstruction = offsetof(GlyphBitsBlock,Bits);
        ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);

        // we do not want to use the last 8 bytes in the BITBLOCK. Some drivers
        // read the last dword (or quadword) past the end of the GLYPHBITS.
        // If there is a GLYPHBITS at the very and of the BITBLOCK AND the
        // allocation happens to be at the end of the page the read will AV.

        prface->SizeGlyphBitsBlockUnderConstruction = prface->GlyphBitsBlockUnderConstruction->SizeGlyphBitsBlock;
    }

        // now go and invalidate the glyphbit pointers in the glyphdata cache

    for
    (
        GlyphDataBlock *pdbl = prface->FirstGlyphDataBlock;
        pdbl != (GlyphDataBlock*)NULL;
        pdbl = pdbl->NextGlyphDataBlock
    )
    {
        UINT i;

        for (i = 0; i < GLYPHDATABLOCKCOUNT; i++)
        {
            pdbl->GlyphDataArray[i].GlyphBits = NULL;
        }
    }
}




////    CheckGlyphStringMetricsCached
//
//      Ensures that glyph metric information for all the glyphs in the
//      given glyph string are already cached.


GpStatus GpFaceRealization::CheckGlyphStringMetricsCached(
    const UINT16 *glyphs,
    INT           glyphCount
) const
{
    ASSERT(glyphCount >= 0);

    // Create glyph data array if none yet exists

    if (prface->GlyphDataArray == NULL)
    {
        if (!AllocateCache())
        {
            return OutOfMemory;
        }
    }

    GpGlyphData **glyphData = prface->GlyphDataArray;


    // Check each glyph

    INT glyphIndexLimit = prface->Face->NumGlyphs;

    INT i=0;

    while (i < glyphCount)
    {
        // Loop quickly through glyphs that are already cached

        while (    i < glyphCount
               &&  (    glyphs[i] == EMPTY_GLYPH_FFFF
                    ||  (    glyphs[i] < glyphIndexLimit
                         &&  glyphData[glyphs[i]] != NULL)))
        {
            i++;
        }

        // Use IsMetricsCached for glyphs not already cached

        if (i < glyphCount)
        {
            GpStatus status = IsMetricsCached(glyphs[i], NULL);
            if (status != Ok)
            {
                return status;
            }
        }
    }

    return Ok;
}




////    GetGlyphStringIdealAdvanceVector
//
//      Returns the realized advance vector scaled to ideal units.


GpStatus GpFaceRealization::GetGlyphStringIdealAdvanceVector(
    const UINT16  *glyphs,
    INT            glyphCount,
    REAL           deviceToIdeal,
    BOOL           vertical,
    INT           *idealAdvances
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    vertical = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    // Provide advance width for each glyph

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            idealAdvances[i] = 0;
        }
        else
        {
            idealAdvances[i] = GpRound(
                  prface->GlyphDataArray[glyphs[i]]->GlyphMetrics[vertical].AdvanceWidth
                * deviceToIdeal
                / 16
            );
        }
    }

    return Ok;
}




////    GetGlyphStringDeviceAdvanceVector
//
//      Returns the realized advance vector in device units


GpStatus GpFaceRealization::GetGlyphStringDeviceAdvanceVector(
    const UINT16  *glyphs,
    INT            glyphCount,
    BOOL           vertical,
    REAL          *deviceAdvances
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    vertical = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    // Provide advance width for each glyph

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            deviceAdvances[i] = 0;
        }
        else
        {
            deviceAdvances[i] = TOREAL(prface->GlyphDataArray[glyphs[i]]->GlyphMetrics[vertical].AdvanceWidth) / 16;
        }
    }

    return Ok;
}


// INT 28.4 variant

GpStatus GpFaceRealization::GetGlyphStringDeviceAdvanceVector(
    const UINT16  *glyphs,
    INT            glyphCount,
    BOOL           vertical,
    INT           *deviceAdvances
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    GpGlyphData **glyphDataArray = prface->GlyphDataArray;

    vertical = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    // Provide advance width for each glyph

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            deviceAdvances[i] = 0;
        }
        else
        {
            deviceAdvances[i] = glyphDataArray[glyphs[i]]
                                ->GlyphMetrics[vertical]
                                .AdvanceWidth;
        }
    }

    return Ok;
}





GpStatus GpFaceRealization::GetGlyphStringVerticalOriginOffsets(
    const UINT16  *glyphs,
    INT            glyphCount,
    PointF        *offsets
) const
{

    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);
    IF_NOT_OK_WARN_AND_RETURN(status);

    GpGlyphData **glyphDataArray = prface->GlyphDataArray;

    for (INT i=0; i<glyphCount; i++)
    {
        if (glyphs[i] == EMPTY_GLYPH_FFFF)
        {
            offsets[i] = PointF(0,0);
        }
        else
        {
            offsets[i] = glyphDataArray[glyphs[i]]->GlyphMetrics[1].Origin;
        }
    }

    return Ok;
}




////    GetGlyphStringSidebearings
//
//      Sidebearings - the sidebearings returned are the largest distances
//      over the ends of the string. i.e. if the first glyph has no negative A
//      width, but the second glyph has a negative A width large enough to reach
//      back over the whole of the first glyph, we return that part of the 2nd
//      glyphs A width that overhangs the left end of the line.
//      This situation is common with scripts that make extensive use of
//      combining characters.


GpStatus GpFaceRealization::GetGlyphStringSidebearings(
    const UINT16  *glyphs,
    INT            glyphCount,
    BOOL           vertical,
    BOOL           reverse,     // For example right-to-left
    INT           *leadingSidebearing,  // 28.4
    INT           *trailingSidebearing  // 28.4
) const
{
    GpStatus status = CheckGlyphStringMetricsCached(glyphs, glyphCount);

    IF_NOT_OK_WARN_AND_RETURN(status);

    GpGlyphData **glyphDataArray = prface->GlyphDataArray;

    INT orientation = vertical ? 1 : 0;    // Prepare vertical flag for use as index

    INT maxSupportedSidebearing28p4 = (prface->DeviceMetrics.yMax-prface->DeviceMetrics.yMin) * 2 * 16;

    if (leadingSidebearing)
    {
        // Determine largest overhang to left of string of any glyph
        // in the string.
        //
        // We assume that no overhang exceeds approx 2 ems.
        //
        // NOTE: If you make a change to for leadingsizdebeating, also fix
        // trailingsidebearing below.

        INT offset28p4      = 0;
        INT sidebearing28p4 = maxSupportedSidebearing28p4;

        INT i = 0;

        while (    i < glyphCount
               &&  offset28p4 < maxSupportedSidebearing28p4)
        {
            INT glyphSidebearing28p4;

            if (reverse)
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .TrailingSidebearing;
            }
            else
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .LeadingSidebearing;
            }


            if (glyphSidebearing28p4 + offset28p4 < sidebearing28p4)
            {
                sidebearing28p4 = glyphSidebearing28p4+offset28p4;
            }

            offset28p4 += glyphDataArray[glyphs[i]]
                          ->GlyphMetrics[orientation]
                          .AdvanceWidth;
            i++;
        }

        *leadingSidebearing = sidebearing28p4;
    }


    if (trailingSidebearing)
    {
        INT offset28p4 = 0;
        INT sidebearing28p4 = maxSupportedSidebearing28p4;

        INT i = glyphCount-1;

        while (    i >= 0
               &&  offset28p4 < maxSupportedSidebearing28p4)
        {
            INT glyphSidebearing28p4;

            if (reverse)
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .LeadingSidebearing;
            }
            else
            {
                glyphSidebearing28p4 = glyphDataArray[glyphs[i]]
                                       ->GlyphMetrics[orientation]
                                       .TrailingSidebearing;
            }

            if (glyphSidebearing28p4 + offset28p4 < sidebearing28p4)
            {
                sidebearing28p4 = glyphSidebearing28p4+offset28p4;
            }

            offset28p4 += glyphDataArray[glyphs[i]]
                          ->GlyphMetrics[orientation]
                          .AdvanceWidth;
            i--;
        }

        *trailingSidebearing = sidebearing28p4;
    }

    return Ok;
}




GpStatus
GpFaceRealization::GetGlyphPath(
    const UINT16     glyphIndice,
    GpGlyphPath    **pFontPath,
    PointF          *sidewaysOffset
) const
{
    VOID *glyphBuffer, *glyphBits;
    GpStatus status;

    if ((status = IsMetricsCached(glyphIndice, NULL)) != Ok)
    {
        return status;
    }

    if (!InsertGlyphPath(glyphIndice, TRUE))
        return GenericError;

    *pFontPath = prface->GlyphDataArray[glyphIndice]->GlyphPath;

    if (sidewaysOffset)
    {
        // Return sideways offset as REAL
        *sidewaysOffset = prface->GlyphDataArray[glyphIndice]->GlyphMetrics[1].Origin;
    }

    return Ok;
}




INT GpFaceRealization::GetGlyphPos(
    const INT      cGlyphs,      // How many glyphs Client want to request
    const UINT16  *glyphs,       // An array of glyph index
    GpGlyphPos    *pgpos,        // An array of GLYPHPOS
    const PointF  *glyphOrigins, // X,Y positions for sub-pixel calculation
    INT           *cParsed,      // How many glyphs we parsed
    BOOL           sideways      // e.g. FE characters in vertical text
) const
{
    INT  cgpos    = 0;
    BOOL noCache  = prface->NoCache;
    BOOL pathFont = IsPathFont();

    *cParsed  = 0;

    INT glyphLimit = noCache ? 1 : cGlyphs;

    if (prface->CacheType == CacheAABits)
    {
        /* we could be in noCache mode with a surrogate sequence, doing one glyph at a time
           and with glyphs[0] == EMPTY_GLYPH_FFFF */
        for (INT i=0; (i < cGlyphs) && (cgpos < glyphLimit); i++)
        {
            if (glyphs[i] != EMPTY_GLYPH_FFFF)
            {
                INT x = GpRound(TOREAL(glyphOrigins[i].X * 16.0));
                INT y = GpRound(TOREAL(glyphOrigins[i].Y * 16.0));

                if (!GetAAGlyphDataCached(glyphs[i], pgpos+cgpos, i==0, x, y, sideways))
                {
                    break;
                }
                cgpos++;
            }
            (*cParsed)++;
        }
    }
    else
    {
        ASSERT(prface->realizationMethod != TextRenderingHintAntiAlias);

       /* we could be in noCache mode with a surrogate sequence, doing one glyph at a time
           and with glyphs[0] == EMPTY_GLYPH_FFFF */
        for (INT i=0; (i < cGlyphs) && (cgpos < glyphLimit); i++)
        {
            if (glyphs[i] != EMPTY_GLYPH_FFFF)
            {
                INT x = GpRound(TOREAL(glyphOrigins[i].X * 16.0));
                INT y = GpRound(TOREAL(glyphOrigins[i].Y * 16.0));

                GpGlyphData *pgd = NULL;

                if (noCache)
                {
                    pgd = GetGlyphDataLookaside(glyphs[i]);
                }
                else
                {
                    pgd = GetGlyphDataCached(glyphs[i], i==0);
                }

                if (!pgd || !pgd->GlyphBits)
                {
                    // No more glyph data available. (Cache may be full)
                    break;
                }

                if (pathFont)
                {
                    INT left = (x+8) >> 4;
                    INT top  = (y+8) >> 4;

                    if (sideways)
                    {
                        left -= GpRound(pgd->GlyphMetrics[1].Origin.X);
                        top  -= GpRound(pgd->GlyphMetrics[1].Origin.Y);
                    }

                    pgpos[cgpos].SetLeft  (left);
                    pgpos[cgpos].SetTop   (top);
                    pgpos[cgpos].SetWidth (1);
                    pgpos[cgpos].SetHeight(1);
                    pgpos[cgpos].SetPath(pgd->GlyphPath);
                }
                else
                {
                    if (sideways)
                    {
                        pgpos[cgpos].SetLeft(pgd->GlyphBits->ptlSidewaysOrigin.x + ((x + 8)>>4));
                        pgpos[cgpos].SetTop (pgd->GlyphBits->ptlSidewaysOrigin.y + ((y + 8)>>4));
                    }
                    else
                    {
                        pgpos[cgpos].SetLeft(pgd->GlyphBits->ptlUprightOrigin.x + ((x + 8)>>4));
                        pgpos[cgpos].SetTop (pgd->GlyphBits->ptlUprightOrigin.y + ((y + 8)>>4));
                    }

                    pgpos[cgpos].SetWidth (pgd->GlyphBits->sizlBitmap.cx);
                    pgpos[cgpos].SetHeight(pgd->GlyphBits->sizlBitmap.cy);
                    pgpos[cgpos].SetBits(pgd->GlyphBits->aj);
                }

                cgpos++;
            }

            (*cParsed)++;
        }
    }

    return cgpos;
}


// Serch the glyph data from cache array.

GpGlyphData *
GpFaceRealization::GetGlyphDataCached(
    UINT16  glyphIndex,
    BOOL    allowFlush
) const
{
    VOID *glyphBuffer, *glyphBits;
    ULONG   cjNeeded = 0;

    GpStatus status;

    if ((status = IsMetricsCached(glyphIndex, &cjNeeded)) != Ok)
    {
        return NULL;
    }

    if (IsPathFont())
    {
        if (!InsertGlyphPath(glyphIndex, allowFlush))
            return NULL;
    }
    else
    {
        if (!InsertGlyphBits(glyphIndex, cjNeeded, allowFlush))
            return NULL;
    }

    ASSERT(prface->GlyphDataArray[glyphIndex]);

    if (!prface->GlyphDataArray[glyphIndex])
        return NULL;

    return prface->GlyphDataArray[glyphIndex];
}





BOOL
GpFaceRealization::GetAAGlyphDataCached(
    UINT16  glyphIndex,
    GpGlyphPos * pgpos,
    BOOL    bFlushOk,
    INT     x,
    INT     y,
    BOOL    sideways        // e.g. FE characters in vertical text
) const
{
    const GpFaceRealization * pfaceRealization = this;

    UINT xsubPos = ((UINT) (((x+1) & 0x0000000F) >> 1));
    // we need to be carefull that y axis is downwards
    UINT ysubPos = ((UINT) (7 - (((y+1) & 0x0000000F) >> 1)));

    // limit the subpixel position to 1/4 of a pixel to have only a maximum of 16 different bitmaps to cache
    xsubPos = xsubPos & 0x6;
    ysubPos = ysubPos & 0x6;

    if (LimitSubpixel)
    {
        // Now limit the subpixel position further so that large font sizes do
        // not generate all 16 subpixel glyphs!

        if ((prface->DeviceMetrics.yMax-prface->DeviceMetrics.yMin) > 50)
        {
            // Force to 4 possible values...
            xsubPos &= 0x4;
            ysubPos &= 0x4;

            if ((prface->DeviceMetrics.yMax-prface->DeviceMetrics.yMin) > 100)
            {
                // Force to 1 possible value...
                xsubPos = 0x4;
                ysubPos = 0x4;
            }
        }
    }

    ASSERT(!pfaceRealization->IsPathFont())

    // Look to see if there is room in the glyphbits cache
    // Grow the glyphbits cache if neccessary, but don't flush the cache

    ULONG   subPosX;
    if (xsubPos <= 7)
        subPosX = xsubPos << 13;
    else
        subPosX = 0;

    ULONG   subPosY;
    if (ysubPos)
        subPosY = ysubPos << 13;
    else
        subPosY = 0;

    // If max glyph will fit, assume max glyph
    // otherwise, call up and ask how big

    ASSERT (pfaceRealization->QueryFontDataMode() == QFD_TT_GRAY4_BITMAP ||
            pfaceRealization->QueryFontDataMode() == QFD_GLYPHANDBITMAP_SUBPIXEL);

    if (IsMetricsCached(glyphIndex, 0) != Ok)
        return FALSE;

    GpGlyphData * glyphData = prface->GlyphDataArray[glyphIndex];
    ASSERT(glyphData);

    // check if we already have a bitmap for this subposition
    for (GpGlyphAABits * cur = glyphData->GlyphAABits; cur != 0; cur = cur->Next)
    {
        if (cur->X == subPosX && cur->Y == subPosY)
            break;
    }

    GLYPHBITS * pgb = 0;
    if (cur)
        pgb = reinterpret_cast<GLYPHBITS *>(&cur->Bits);
    else
    {
        ULONG cjNeeded = ttfdSemQueryFontDataSubPos(
                                       &prface->fobj,
                                       prface->QueryFontDataMode,
                                       glyphIndex,
                                       0,
                                       NULL,
                                       subPosX,
                                       subPosY
                                       );
        if (cjNeeded == FD_ERROR)
            return FALSE;

        ASSERT(cjNeeded != 0);

        cjNeeded += offsetof(GpGlyphAABits, Bits);


        if (prface->NoCache)
        {
            if (prface->LookasideByteCount < cjNeeded)
            {
                GpFree(prface->LookasideGlyphData);

                prface->LookasideGlyphData = (GpGlyphData  *)GpMalloc(cjNeeded);

                if (!prface->LookasideGlyphData)
                    return FALSE;

                prface->LookasideByteCount = cjNeeded;
            }

            cur = reinterpret_cast<GpGlyphAABits *>(prface->LookasideGlyphData);
        }
        else
        {
            // Now, we try to fit the bits in.  If they fit, fine.
            // If not, and we can flush the cache, we flush it and try again.
            // If we couldn't flush, or we flushed and still fail, just return.

            cjNeeded = ALIGN(void*, cjNeeded);

            // a GpGlyphAABits * needs to be aligned to the next valid pointer address
            ALIGN(void*, prface->UsedBytesGlyphBitsBlockUnderConstruction);

            while ((cur = (GpGlyphAABits *)pgbCheckGlyphCache(cjNeeded)) == NULL)
            {
                if ( !bFlushOk )
                    return FALSE;

                FlushCache();
                bFlushOk = FALSE;
            }
            prface->UsedBytesGlyphBitsBlockUnderConstruction += cjNeeded;
        }

        pgb = reinterpret_cast<GLYPHBITS *>(&cur->Bits);

        cjNeeded = ttfdSemQueryFontDataSubPos(
                             pfaceRealization->pfo(),
                             pfaceRealization->QueryFontDataMode(),
                             glyphIndex,
                             0,
                             pgb,
                             subPosX,
                             subPosY
                             );
        if (cjNeeded == FD_ERROR)
            return FALSE;

        cur->X = subPosX;
        cur->Y = subPosY;
        if (!prface->NoCache)
            cur->Next = glyphData->GlyphAABits, glyphData->GlyphAABits = cur;
    }

    // the pixel origin is computed by rouding the real origin minus the subpixel position
    // to get to the placement of the origin of the bitmap, we add to that origin
    // we cast (xsubPos << 1) and (ysubPos << 1) to INT to avoid
    // converting possibly negative x and y to UINTs
    if (sideways)
    {
        pgpos->SetLeft  (pgb->ptlSidewaysOrigin.x + ((x - (INT)(xsubPos << 1) + 8 ) >> 4));
        // we need to be careful that the y axis go downwards
        pgpos->SetTop   (pgb->ptlSidewaysOrigin.y + ((y + (INT)(ysubPos << 1) + 8) >> 4));
    }
    else
    {
        pgpos->SetLeft  (pgb->ptlUprightOrigin.x + ((x - (INT)(xsubPos << 1) + 8 ) >> 4));
        // we need to be careful that the y axis go downwards
        pgpos->SetTop   (pgb->ptlUprightOrigin.y + ((y + (INT)(ysubPos << 1) + 8) >> 4));
    }
    pgpos->SetWidth (pgb->sizlBitmap.cx);
    pgpos->SetHeight(pgb->sizlBitmap.cy);
    pgpos->SetBits(pgb->aj);

    return TRUE;

} // GpFaceRealization::GetAAGlyphDataCached




GpCacheFaceRealizationList::~GpCacheFaceRealizationList()
{
    // elements in that list get released when the font table get released
    ASSERT(count == 0);
}




void GpCacheFaceRealizationList::AddMostRecent(CacheFaceRealization *prface)
{
    count ++;

    if (head != NULL)
    {
        prface->NextRecentCacheFaceRealization = head;

        prface->PreviousRecentCacheFaceRealization = head->PreviousRecentCacheFaceRealization;

        prface->PreviousRecentCacheFaceRealization->NextRecentCacheFaceRealization = prface;

        head->PreviousRecentCacheFaceRealization = prface;
    }
    else
    {
        prface->NextRecentCacheFaceRealization = prface;
        prface->PreviousRecentCacheFaceRealization = prface;
    }

    head = prface;
}




void GpCacheFaceRealizationList::RemoveFace(CacheFaceRealization *prface)
{
    if ((prface->PreviousRecentCacheFaceRealization != NULL) && (prface->NextRecentCacheFaceRealization != NULL))
    {
        if (prface->PreviousRecentCacheFaceRealization == prface)
        {
            head = NULL;
        }
        else
        {
            prface->PreviousRecentCacheFaceRealization->NextRecentCacheFaceRealization = prface->NextRecentCacheFaceRealization;
            prface->NextRecentCacheFaceRealization->PreviousRecentCacheFaceRealization = prface->PreviousRecentCacheFaceRealization;
            if (head == prface)
            {
                head = prface->NextRecentCacheFaceRealization;
            }
        }

        prface->PreviousRecentCacheFaceRealization = NULL;
        prface->NextRecentCacheFaceRealization = NULL;
        count --;
        ASSERT(count >= 0);
    }
}


CacheFaceRealization *GpCacheFaceRealizationList::ReuseLeastRecent (void)
{
    CacheFaceRealization *prface = NULL;
    CacheFaceRealization *prfaceList;
    if (head != NULL)
    {
        prface = head->PreviousRecentCacheFaceRealization;
    }

    ASSERT(prface);

    // remove prface from GpCacheFaceRealizationList

    if (head == prface)
    {
        ASSERT(count == 1);
        head = NULL;
    }
    else
    {
        prface->PreviousRecentCacheFaceRealization->NextRecentCacheFaceRealization = head;
        head->PreviousRecentCacheFaceRealization = prface->PreviousRecentCacheFaceRealization;
    }

    count--;

    if (prface != NULL)
    {
        GpFaceRealizationTMP rface(prface);
        rface.ReuseRealizedFace();

        // remove the face from the face list

        prfaceList = prface->Face->pff->prfaceList;
        ASSERT(prfaceList);

        if ((prfaceList == prface) && (prfaceList->NextCacheFaceRealization == prface))
        {
            // there is only oine face in the faceList for that font face
            prface->Face->pff->prfaceList = NULL;

        } else
        {
            if (prfaceList == prface)
            {
                // set the beginning of the list to the next one
                prface->Face->pff->prfaceList = prfaceList->NextCacheFaceRealization;
            }

            // update the pointers in the faceList

            prface->PreviousCacheFaceRealization->NextCacheFaceRealization = prface->NextCacheFaceRealization;
            prface->NextCacheFaceRealization->PreviousCacheFaceRealization = prface->PreviousCacheFaceRealization;
        }

    }

    return prface;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\facerealization.hpp ===
#ifndef _FACEREALIZATION_
#define _FACEREALIZATION_

#define GLYPHDATABLOCKCOUNT 16
#define MAXRECENTLYUSEDCOUNT 32

#define EMPTY_GLYPH_FFFF 0xFFFF   // Display nothing, neither ink nor width.


// Typedefs for cached funtion pointers in GpFaceRealization.
class GpFaceRealization;

/* used in aatext.cxx and facerealization.cpp : */
#define CJ_CTGD(cx,cy) (ALIGN4(offsetof(GLYPHBITS,aj)) + ALIGN4((cx) * (cy)))
#define ALIGN4(X) (((X) + 3) & ~3)
#define ALIGN(object, p) p =    (p + ((UINT)sizeof(object) - 1)) & ~((UINT)sizeof(object) - 1);


inline BOOL IsGridFittedTextRealizationMethod(TextRenderingHint method)
{
    switch (method)
    {
    case TextRenderingHintSingleBitPerPixelGridFit:
    case TextRenderingHintAntiAliasGridFit:
    case TextRenderingHintClearTypeGridFit:
        return TRUE;

    default:
        return FALSE;
    }
}


/////   GpGlyphMetrics
//
//      Metrics for text handling and glyph placement.
//      There are separate records for horizontal and vertical baselines.

struct GpGlyphMetrics {

    // Metrics along baseline in 28.4

    INT     AdvanceWidth;
    INT     LeadingSidebearing;
    INT     TrailingSidebearing;
    PointF  Origin;   // Float
};

struct GpGlyphAABits
{
    GpGlyphAABits * Next;
    ULONG           X, Y;
    BYTE            Bits[1];    // variable size
};

struct GpGlyphData {
    GpGlyphMetrics      GlyphMetrics[2];          // one for horizontal metrics  and one for vertical metrics
    union {
        GLYPHBITS     *GlyphBits;                 // Same as GDI structure at this moment
        GpGlyphPath   *GlyphPath;
        GpGlyphAABits *GlyphAABits;     // null terminated singly-linked list
    };
};

struct GlyphDataBlock
{
    GlyphDataBlock  *NextGlyphDataBlock;
    GpGlyphData      GlyphDataArray[GLYPHDATABLOCKCOUNT];
};

// blocks of memory used to store glyphbits

struct GlyphBitsBlock
{
    GlyphBitsBlock  *NextGlyphBitsBlock;     // next block in the list
    UINT             SizeGlyphBitsBlock;        // Bytes allocated
    BYTE             Bits[1];    // bits
};


////    CacheFaceRealization - cache entries referenced by FaceRealization
//
//



class EXTFONTOBJ
{
public:
    FONTOBJ     fobj;           // pass to DDI, we need to have it to back compatible with GDI
};

enum GpGlyphDataCacheType
{
    CacheBits,
    CachePath,
    CacheAABits
};

class CacheFaceRealization : public EXTFONTOBJ
{
public:

    // New type information

    BOOL                    NoCache;         // Cache type -
    GpGlyphDataCacheType    CacheType;   // bits, path or AA bits
    BOOL                    ForcedPath;   // was this CacheFaceRealization forced to use path because of huge font size

    // claudebe, try to get rid of both, redundant with fontObj flags : should correspond to what is actually realized
    TextRenderingHint   realizationMethod;
    ULONG               QueryFontDataMode;

    // Physical font information (font source).

    const GpFontFace    *Face;           // pointer to physical font entry

    // Font transform information.

    // DDI callback transform object.  A reference to this EXFORMOBJ is passed
    // to the driver so that it can callback XFORMOBJ_ services for the notional
    // to device transform for this font.

    GpMatrix            mxForDDI;       // xoForDDI's matrix

    // cached here upon font realization for fast access

    ULONG               MaxGlyphByteCount; // (MaxGlyphPixelWidth + 7)/8 * MaxGlyphPixelHeight, or at least it should be for 1 bpp
    FD_DEVICEMETRICS    DeviceMetrics;     // Hinted metric indformation

    // Root of per glyph metrics and images

    GpGlyphData         **GlyphDataArray;          // array of pointers to GpGlyphData's

    // CacheFaceRealization linked list for a particular face

    CacheFaceRealization *NextCacheFaceRealization;
    CacheFaceRealization *PreviousCacheFaceRealization;

    // CacheFaceRealization last recently used linked list

    CacheFaceRealization *NextRecentCacheFaceRealization;
    CacheFaceRealization *PreviousRecentCacheFaceRealization;

    // Font cache information.


    GlyphDataBlock  *FirstGlyphDataBlock;      // First block in chain - used for destruction
    GlyphBitsBlock  *FirstGlyphBitsBlock;

    // Info for GlyphDataBlock being constructed

    GlyphDataBlock  *GlyphDataBlockUnderConstruction;
    UINT             NextFreeGlyphDataIndex;     // (All other blocks are already full)

    // Info for GlyphBitBlock under construction

    GlyphBitsBlock  *GlyphBitsBlockUnderConstruction;
    UINT             SizeGlyphBitsBlockUnderConstruction;        // Bytes allocated
    UINT             UsedBytesGlyphBitsBlockUnderConstruction;   // Bytes used

    // Lookaside cache - holds bits or path and metrics for a single glyph, used whern
    // data too big for cache block.

    GpGlyphData     *LookasideGlyphData;                    // Same as GDI structure at this moment

    SIZE_T           LookasideByteCount;      // size of current lookaside buffer


    // claudebe : still need to be updated to use the global cache size limit :

    UINT        cBlocksMax;       // max # of blocks allowed
    UINT        cBlocks;          // # of blocks allocated so far
};






////    FaceRealization
//
//      Represents a font at a given size (?on a given device?)


class GpFaceRealization
{
private:
    mutable CacheFaceRealization  *prface;
    GpStatus                       Status;
    INT                            Style;
    BOOL                           LimitSubpixel;


public:

    // Constructors -- Lock the CacheFaceRealization.

    GpFaceRealization()
    :   prface  (NULL),
        Status  (InvalidParameter)
    {}


    GpFaceRealization(
        const GpFontFace *pface,
        INT               style,
        const GpMatrix   *matrix,
        const SizeF       dpi,
        TextRenderingHint renderMethod,
        BOOL              bPath,
        BOOL              bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
        BOOL              bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                       used to do the italic simulation in the right direction */
    );

// Destructor -- Unlocks the CacheFaceRealization

   ~GpFaceRealization();

// To clone another GpFaceRealiztion from Bits to Path

    void CloneFaceRealization(
        const GpFaceRealization *  pfaceRealizaton,
        BOOL                bPath
    );

// GetStatus - Called following instantiation to check that construction worked.

    GpStatus GetStatus() const {return Status;}

    INT GetStyle() const
    {

#if DBG
        INT style = 0;

        if (    prface->Face->pifi->fsSelection & FM_SEL_BOLD
            ||  prface->fobj.flFontType         & FO_SIM_BOLD)
        {
            style |= FontStyleBold;
        }

        if (    prface->Face->pifi->fsSelection & FM_SEL_ITALIC
            ||  prface->fobj.flFontType         & FO_SIM_ITALIC_SIDEWAYS
            ||  prface->fobj.flFontType         & FO_SIM_ITALIC)
        {
            style |= FontStyleItalic;
        }

        ASSERT(style == (Style & (FontStyleBold | FontStyleItalic)));
#endif

        return Style;
    }


    BOOL bInit(
        const GpFontFace   *pface,
        INT                 style,
        const GpMatrix     *matrix,
        SizeF               dpi,
        TextRenderingHint   textMode,
        BOOL                bPath,
        BOOL                bCompatibleWidth,  /* we want ClearType compatible width when we come from DrawDriverString */
        BOOL                bSideways  /* for far east vertical writing, run of glyph layed out sideways,
                                          used to do the italic simulation in the right direction */
    );


    // bDelete -- Removes an CacheFaceRealization

    BOOL   DeleteRealizedFace();

    // Reuse an CacheFaceRealization

    BOOL   ReuseRealizedFace();

    // bInitCache -- Initialize the cache

    BOOL   bInitCache() const;
    BOOL   AllocateCache() const;

    // vDeleteCache -- Delete the CACHE from existence.

    VOID   vDeleteCache() const;

    BOOL   noCache() const {return prface->NoCache ;}

    // FindRealizedFace -- check to see whether there is existing realization
    //              on the CacheFaceRealization list in the GpFontFile.

    BOOL FindRealizedFace(
            FD_XFORM            *fdx,
            const GpFontFace    *fontFace,
            BOOL                needPaths,
            FLONG               fl
            ) const;

    // RealizeFont -- Initializer; for IFI, calls driver to realize
    //                 font represented by PFE.

    BOOL Realize(
        SizeF              dpi,
        const GpFontFace  *pfe,
        INT                style,      // style - which may require simulation
        PFD_XFORM          pfdx,       // font xform (Notional to Device)
        FLONG              fl,         // these two really modify the xform
        BOOL               bNeedPaths
    );

    // Valid -- Returns TRUE if object was successfully locked

    BOOL IsValid ()
    {
        return(prface != 0);
    }

    ULONG QueryFontDataMode() const
    {
        return prface->QueryFontDataMode;
    }

    BOOL bGetDEVICEMETRICS();

    // return the font face for this RFace
    const GpFontFace * GetFontFace() const {return(prface->Face);}

    //  Is it in private font file table or not

    BOOL IsPrivate() const {return prface->Face->IsPrivate();}

    // pfdx -- Return pointer to the notional to device font transform.

    FD_XFORM *pfdx() const {return (&prface->fobj.fdx);}

    // pfo -- Return pointer to the font object

    FONTOBJ *pfo() const {return(&prface->fobj);}

    // kill driver realization of the font, i.e. "FONT CONTEXT" in the old lingo.
    // Method calling DrvDestroyFont before CacheFaceRealization is killed itself.

    VOID vDestroyRealizedFace();

    // vGetCache -- Claims the cache semaphore

    VOID    vGetCache ()
    {
    //    EnterCriticalSection(&prface->FaceRealizationCritSection);
    }

    // vReleaseCache -- Releases the cache semaphore

    VOID    vReleaseCache ()
    {

    if ( prface->LookasideGlyphData != NULL )
        {
            GpFree((PVOID) prface->LookasideGlyphData);
            prface->LookasideByteCount = 0;
            prface->LookasideGlyphData = NULL;
        }

        //    LeaveCriticalSection(&prface->FaceRealizationCritSection);
    }


    ULONG GetGlyphsSupported() const
    {
        if (prface && prface->Face)
        {
            return (prface->Face->NumGlyphs);
        }
        return 0;
    }

    GpStatus GetGlyphStringDeviceAdvanceVector(
        const UINT16  *glyphs,
        INT            glyphCount,
        BOOL           vertical,
        REAL          *deviceAdvances
    ) const;

    GpStatus GetGlyphStringDeviceAdvanceVector(
        const UINT16  *glyphs,
        INT            glyphCount,
        BOOL           vertical,
        INT           *deviceAdvances   // Returned in 28.4
    ) const;

    GpStatus GetGlyphStringIdealAdvanceVector(
        const UINT16  *glyphs,
        INT            glyphCount,
        REAL           deviceToIdeal,
        BOOL           vertical,
        INT           *idealAdvances
    ) const;

    GpStatus GetGlyphStringSidebearings(
        const UINT16  *glyphs,
        INT            glyphCount,
        BOOL           vertical,
        BOOL           reverse,     // For example right-to-left
        INT           *leadingSidebearing,  // 28.4
        INT           *trailingSidebearing  // 28.4
    ) const;

    GpStatus GetGlyphStringVerticalOriginOffsets(
        IN  const UINT16  *glyphs,
        IN  INT            glyphCount,
        OUT PointF        *offsets
    ) const;



    // GetGlyphPath

    GpStatus
    GetGlyphPath(
        const UINT16     glyphIndice,
        GpGlyphPath    **pGlyphPath,
        PointF          *sidewaysOffset
    ) const;


    // GetGlyphPos

    INT GetGlyphPos(
        const INT      cGlyphs,     // How many glyphs Client want to request
        const UINT16  *glyphIndex,  // An array of glyph index
        GpGlyphPos    *pgpos,       // An array of GLYPHPOS
        const PointF  *glyphOrigin, // X,Y positions for sub-pixel calculation
        INT           *cParsed,     // How many glyphs we parsed
        BOOL          sideways      // e.g. FE characters in vertical text
    ) const;


    // Realization mode
    inline TextRenderingHint RealizationMethod() const {return(prface->realizationMethod);}

    // IisPathFont -- Is this a path font?

    inline BOOL IsPathFont() const {return(prface->CacheType == CachePath);}


    VOID FlushCache() const;

    // Construction hack used by GpFaceRealizationTMP during CacheFaceRealization cleanup

    void Setprface(CacheFaceRealization *rface) {prface = rface;}
    CacheFaceRealization *Getprface() const {return prface;}


    INT  GetXMin()               const {return prface->DeviceMetrics.xMin;};
    INT  GetXMax()               const {return prface->DeviceMetrics.xMax;};
    INT  GetYMin()               const {return prface->DeviceMetrics.yMin;};
    INT  GetYMax()               const {return prface->DeviceMetrics.yMax;};
    BOOL IsHorizontalTransform() const {return prface->DeviceMetrics.HorizontalTransform;};
    BOOL IsVerticalTransform()   const {return prface->DeviceMetrics.VerticalTransform;};
    BOOL IsFixedPitch()          const {return (prface->Face->pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH);};

    BOOL GetLimitSubpixel() { return LimitSubpixel; }
    void SetLimitSubpixel(BOOL limitSubpixel) { LimitSubpixel = limitSubpixel; }

private:

    GpStatus CheckGlyphStringMetricsCached(const UINT16 *glyphs, INT glyphCount) const;



    // vInsert -- Insert this CacheFaceRealization onto the head of an CacheFaceRealization doubly linked list.

    VOID vInsert (CacheFaceRealization **pprfaceHead);

    // vRemove -- Remove this CacheFaceRealization from an CacheFaceRealization doubly linked list.

    VOID vRemove (CacheFaceRealization **pprfaceHead);

    // Access to cached glyph data

    GpGlyphData *GetGlyphDataCached(UINT16 glyphIndex, BOOL   allowFlush) const;

    GpGlyphData *GetGlyphDataLookaside(UINT16 glyphIndex) const;


    BOOL CheckMetricsCache() const;
    VOID *pgbCheckGlyphCache(SIZE_T cjNeeded) const;


    VOID ConvertGLYPHDATAToGpGlyphMetrics(
        IN   INT           glyphIndex,
        IN   GLYPHDATA    *pgd,
        OUT  GpGlyphData  *pgpgd
    ) const;

    GpStatus IsMetricsCached(UINT16 glyph, ULONG * pcjNeeded) const;

    BOOL InsertGlyphBits(UINT16 glyph, ULONG cjNeeded, BOOL  bFlushOk) const;
    BOOL InsertGlyphPath(UINT16 glyph, BOOL allowFlush) const;

    // bMatchFDXForm -- Is pfdx identical to current font xform?

    inline BOOL MatchFDXForm(FD_XFORM *pfdx) const
    {
        return(!memcmp((PBYTE)pfdx, (PBYTE)&prface->fobj.fdx, sizeof(FD_XFORM)));
    }


    // Calculating sub-pixel position
    BOOL GetAAGlyphDataCached(
        UINT16  glyphIndex,
        GpGlyphPos * pgpos,
        BOOL    allowFlush,
        INT     x,
        INT     y,
        BOOL    sideways        // e.g. FE characters in vertical text
    ) const;
};


class GpFaceRealizationTMP : public GpFaceRealization
{
public:
    GpFaceRealizationTMP(CacheFaceRealization *_prface) {Setprface(_prface);}
    ~GpFaceRealizationTMP()             {Setprface(NULL);}
};



class GpCacheFaceRealizationList
{
public:
    GpCacheFaceRealizationList() { head = NULL; count = 0; }
    ~GpCacheFaceRealizationList();

    void AddMostRecent(CacheFaceRealization *prface);

    void RemoveFace(CacheFaceRealization *prface);

    CacheFaceRealization *ReuseLeastRecent (void);

    INT GetCount() {return count; }

private:
    CacheFaceRealization *head;
    INT count;
};


#endif // __FACEREALIZATION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\endcap.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   End Cap Creator.
*
* Abstract:
*
*   This module defines a class called GpEndCapCreator. This class is 
*   responsible for constructing a path containing all the custom endcaps
*   and anchor endcaps for a given path. These are correctly transformed
*   and positioned.
*
*   This class is used to create and position all the endcaps for a
*   given path and pen. This class is also responsible for trimming
*   the original path down so that it fits the end caps properly.
*   This class will handle all types of end caps except the base endcaps
*   (round, flat and triangle) which may be used as dash caps.
*   Caps that are handled are CustomCaps and the 3 Anchor caps (round,
*   diamond and arrow). Note that the round anchor cap is distinct from
*   the round base cap.
*
* Created:
*
*   10/09/2000 asecchia
*      Created it.
*
**************************************************************************/
#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

GpEndCapCreator::GpEndCapCreator(
    GpPath *path, 
    DpPen *pen, 
    const GpMatrix *m,
    REAL dpi_x, 
    REAL dpi_y,
    bool antialias
)
{
    Path = path;
    Pen = pen;
    if(m) {XForm = *m;}
    XForm.Prepend(pen->Xform);
    DpiX = dpi_x;
    DpiY = dpi_y;
    Antialias = antialias;
    
    StartCap = NULL;
    EndCap = NULL;
    
    switch(Pen->StartCap)
    {
        case LineCapCustom:
        StartCap = static_cast<GpCustomLineCap*>(Pen->CustomStartCap);
        break;
        
        case LineCapArrowAnchor:
        StartCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        StartCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        StartCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;
        
        case LineCapSquareAnchor:
        StartCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };
    
    switch(Pen->EndCap)
    {
        case LineCapCustom:
        EndCap = static_cast<GpCustomLineCap*>(Pen->CustomEndCap);
        break;
        
        case LineCapArrowAnchor:
        EndCap = GpEndCapCreator::ReferenceArrowAnchor();
        break;
        
        case LineCapDiamondAnchor:
        EndCap = GpEndCapCreator::ReferenceDiamondAnchor();
        break;
        
        case LineCapRoundAnchor:
        EndCap = GpEndCapCreator::ReferenceRoundAnchor();
        break;

        case LineCapSquareAnchor:
        EndCap = GpEndCapCreator::ReferenceSquareAnchor();
        break;
        
        // The non-anchor caps are handled by the widener.
    };

    // If we're flipped in the X or Y direction (but not both), 
    // reverse the fill and stroke paths so that the winding 
    // mode will be correct.
    if (pen->Xform.GetDeterminant() < 0)
    {
        if (StartCap)
        {
            StartCap->ReverseFillPath();
            StartCap->ReverseStrokePath();
        }
        if (EndCap)
        {
            EndCap->ReverseFillPath();
            EndCap->ReverseStrokePath();
        }
    }

}


/**************************************************************************\
*
* Function Description:
*
*   This function will return true if the GpEndCapCreator is required for
*   the given pen. If the pen only has simple endcaps, then the 
*   GpEndCapCreator can skipped.
*
*   The GpEndCapCreator is used for creating Anchor and/or Custom caps.
*   LineCap- Flat, Round, Square and Triangle are handled directly by the
*   widener.
*
* Revision History:
*
*   11/10/2000 asecchia
*       Created it
*
\**************************************************************************/

bool GpEndCapCreator::PenNeedsEndCapCreator(const DpPen *pen)
{
    return (
        (pen->StartCap == LineCapCustom) ||
        (pen->EndCap == LineCapCustom) ||
        ((pen->StartCap & LineCapAnchorMask) != 0) ||
        ((pen->EndCap & LineCapAnchorMask) != 0)
    );
}


GpEndCapCreator::~GpEndCapCreator()
{
    // If we allocated memory for temporary custom caps, then 
    // throw that memory away.
    
    if(Pen->StartCap != LineCapCustom)
    {
        delete StartCap;
        StartCap = NULL;
    }
    
    if(Pen->EndCap != LineCapCustom)
    {
        delete EndCap;
        EndCap = NULL;
    }
}
    
/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing an ArrowAnchor.
*    This is an equilateral triangle with edge equal to 2. This means
*    that the scaling will create a 2xStrokeWidth cap edge length.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceArrowAnchor()
{
    // the square root of 3
    
    const REAL root3 = 1.732050808f;
    
    // Anti-clockwise definition of an equilateral triangle of side length 2.0f
    // with a vertex on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[3] = {
        GpPointF(0.0f, 0.0f),
        GpPointF(-1.0f, -root3),
        GpPointF(1.0f, -root3)
    };
    
    GpPath arrowAnchor(FillModeWinding);
    arrowAnchor.AddPolygon(points, 3);
    
    // Create the custom line cap. If it fails it will return NULL.
    GpCustomLineCap *cap = new GpCustomLineCap(&arrowAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(1.0f);
    }
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a DiamondAnchor.
*    This is a square centered on the end point of the path with it's 
*    diagonal along the axis of the spine.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceDiamondAnchor()
{
    // Anti-clockwise definition of a square of diagonal size 2.0f
    // with the center on the origin and axis extending along the negative
    // y axis.
     
    const GpPointF points[4] = {
        GpPointF(0.0f, 1.0f),
        GpPointF(-1.0f, 0.0f),
        GpPointF(0.0f, -1.0f),
        GpPointF(1.0f, 0.0f)
    };
    
    GpPath diamondAnchor(FillModeWinding);
    diamondAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&diamondAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(0.0f);
    }
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a SquareAnchor.
*    This is a square that has a 2 unit long diagonal and is centered on 
*    the end point of the path.
*
* Revision History:
*
*   10/17/2000 peterost
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceSquareAnchor()
{    
    const REAL halfRoot2 = 0.7071068f;
    
    const GpPointF points[4] = {
        GpPointF(-halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, -halfRoot2),
        GpPointF(halfRoot2, halfRoot2),
        GpPointF(-halfRoot2, halfRoot2)
    };
    
    GpPath squareAnchor(FillModeWinding);
    squareAnchor.AddPolygon(points, 4);
    
    // Create the custom line cap. If it fails it will return NULL.
    
    GpCustomLineCap *cap = new GpCustomLineCap(&squareAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(0.0f);
    }
    return cap;
}

/**************************************************************************\
*
* Function Description:
*
*    Creates a reference GpCustomLineCap representing a RoundAnchor.
*    This is a circle centered on the end point of the path.
*
* Revision History:
*
*   10/08/2000 asecchia
*       Created it
*
\**************************************************************************/

GpCustomLineCap *GpEndCapCreator::ReferenceRoundAnchor()
{
    // Create the custom line cap. If it fails it will return NULL.
    
    GpPath roundAnchor(FillModeWinding);
    roundAnchor.AddEllipse(-1.0f, -1.0f, 2.0f, 2.0f);
    GpCustomLineCap *cap = new GpCustomLineCap(&roundAnchor, NULL);
    if(cap)
    {
        cap->SetBaseInset(0.0f);
    }
    return cap;
}


/**************************************************************************\
*
* Function Description:
*
*   ComputeCapGradient.
*
*   Compute the correct gradient for a line cap of a given length.
*   Work out the direction of the cap from the list of input 
*   points in the path and the length of the cap.
*   Simply put, the direction is the line segment formed by 
*   the end point of the path and the first intersection along the 
*   path with a circle of length "length" and centered at the 
*   first point of the path.
*
* Arguments:
*
*    GpIterator<GpPointF> &pointIterator,
*    BYTE *types,
*    IN  REAL lengthSquared,            length of the cap squared.
*    IN  baseInset,                     amount to draw into the shape.
*    OUT GpVector2D *grad,              output gradient vector
*
*
* Revision History:
*
*   08/23/00 asecchia
*       Created it
*
\**************************************************************************/

void GpEndCapCreator::ComputeCapGradient(
    GpIterator<GpPointF> &pointIterator, 
    BYTE *types,
    IN  REAL lengthSquared,
    IN  REAL baseInset,
    OUT GpVector2D *grad
)
{
    // Start at the beginning of the iterator (end of the list of
    // points if isStartCap is FALSE)
    
    GpPointF *endPoint = pointIterator.CurrentItem();
    GpPointF *curPoint = endPoint;
    INT index;
    bool intersectionFound = false;
    bool priorDeletion = false;
    
    while(!pointIterator.IsDone())
    {
        curPoint = pointIterator.CurrentItem();
        if(lengthSquared < distance_squared(*curPoint, *endPoint))
        {
            intersectionFound = true;
            break;
        }
        
        // Mark this point for deletion by the trimming algorithm.
        
        index = pointIterator.CurrentIndex();
        
        // Check to see if anyone already deleted this segment.
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        priorDeletion = (types[index] & PathPointTypeInternalUse) ==
            PathPointTypeInternalUse;
        
        types[index] |= PathPointTypeInternalUse;
        
        pointIterator.Next();
    }
    
    // Now we have the segment that intersects the base of the arrow.
    // or the last segment.
    
    pointIterator.Prev();
    
    // if we couldn't get the Prev, then we were at the beginning.
    #if DBG
    if(pointIterator.IsDone())
    {
        ONCE(WARNING(("not enough points in array")));
    }
    #endif
    
    // If the intersection was not found we have marked the entire subpath
    // for deletion.
    
    if(intersectionFound && !priorDeletion)
    {
        // We overagressively marked this point for deletion,
        // instead of deleting this point, we're going to move it.
        // Note: we may have found an intersection point in a segment
        // that has already been marked for deletion. Checking priorDeletion
        // here ensures that we don't incorrectly undelete this point.
        
        index = pointIterator.CurrentIndex();
        
        // PathPointTypeInternalUse is the marked-for-deletion flag.
        
        types[index] &= ~PathPointTypeInternalUse;
    }
    
    GpPointF *prevPoint = pointIterator.CurrentItem();
    GpPointF intersectionPoint;
    
    if(!intersect_circle_line(
        *endPoint,           // center
        lengthSquared,       // radius^2
        *curPoint,           // P0
        *prevPoint,          // P1
        &intersectionPoint
    ))
    {
        // If there is no intersection, then the line segment is likely too 
        // short, so just take the previous point as the intersection.
        // This is our best guess and in this case will give us the slope from
        // the start to end point as the cap direction.
        
        intersectionPoint.X = prevPoint->X;
        intersectionPoint.Y = prevPoint->Y;
    }
    
    // Compute the gradient - and normalize the vector.
    
    *grad = intersectionPoint - *endPoint;
    grad->Normalize();
    
    // Update the point in the path directly.
    GpVector2D v = *endPoint - intersectionPoint;
    
    *prevPoint = intersectionPoint + (v*(1.0f-baseInset));
}

/**************************************************************************\
*
* Function Description:
*
*   This creates a path containing all the custom end caps for all
*   the open subpaths in the input path.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    caps  -- this is where we put the caps we generate
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/
GpStatus
GpEndCapCreator::CreateCapPath(GpPath **caps)
{
    // Validate our input data.
    
    ASSERT(Pen != NULL);
    ASSERT(Path != NULL);
    ASSERT(caps != NULL);
    ASSERT(*caps == NULL);
    
    // Create our cap path.
    
    *caps = new GpPath(FillModeWinding);
    if(*caps==NULL) 
    { 
        return OutOfMemory; 
    }
    
    // Create a path points iterator because our GpPath doesn't know how
    // to iterate over its own data *sigh*
    
    GpPathPointIterator pathIterator(
        const_cast<GpPointF*>(Path->GetPathPoints()),
        const_cast<BYTE*>(Path->GetPathTypes()),
        Path->GetPointCount()
    );
    
    GpSubpathIterator subpathIterator(&pathIterator);
    
    // Loop through all the available subpaths.
    
    while(!subpathIterator.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = subpathIterator.CurrentIndex();
        GpPointF *points = subpathIterator.CurrentItem();
        BYTE *types = subpathIterator.CurrentType();
        subpathIterator.Next();
        INT elementCount = subpathIterator.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pathIterator.Prev();
        
        bool isClosed = 
            ((*(pathIterator.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath);
            
        pathIterator.Next();
        
        // only want to add end caps if this is an open subpath.
        
        if(!isClosed)
        {
            GpPath *startCap = NULL;
            GpPath *endCap = NULL;
        
            // Create the cap using the points and types
            
            GetCapsForSubpath(
                &startCap,
                &endCap,                
                points,
                types,
                elementCount
            );
            
            // Add the cap to our caps path.
            
            (*caps)->AddPath(startCap, FALSE);
            (*caps)->AddPath(endCap, FALSE);
            
            // Clean up the temporary caps for the next iteration.
            
            delete startCap;
            delete endCap;
        }
    }
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*    This takes a pen and sets it up to match the internal Pen, but modified
*    to support stroking the StrokeCap. E.g. the caps are removed to avoid
*    recursive compound capping etc.
*
* Arguments:
*
*   [OUT]    pen       -- this is where we put the pen we generate
*   [IN]     customCap -- input custom cap.
*
* Created:
*
*   10/09/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

VOID GpEndCapCreator::PrepareDpPenForCustomCap(
    DpPen* pen,
    const GpCustomLineCap* customCap
    ) const
{
    ASSERT(pen);

    *pen = *Pen;
    
    pen->StartCap = LineCapFlat;
    pen->EndCap = LineCapFlat;
    pen->Join = LineJoinMiter;
    pen->MiterLimit = 10;
    pen->PenAlignment = PenAlignmentCenter;
    pen->DashStyle = DashStyleSolid;
    pen->DashCap = LineCapFlat;
    pen->DashCount = 0;
    pen->DashOffset = 0;
    pen->DashArray = NULL;
    pen->CompoundCount = 0;
    pen->CompoundArray = NULL;
    pen->CustomEndCap = NULL;
    pen->CustomStartCap = NULL;

    GpLineCap startCap, endCap;
    GpLineJoin lineJoin;

    if(customCap)
    {
        REAL widthScale;

        customCap->GetStrokeCaps(&startCap, &endCap);
        customCap->GetStrokeJoin(&lineJoin);
        customCap->GetWidthScale(&widthScale);

        pen->Width *= widthScale;
        pen->StartCap = startCap;
        pen->EndCap = endCap;
        pen->Join = lineJoin;
    }
}

GpStatus
GpEndCapCreator::SetCustomFillCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;

    startCapPoints->Reset(FALSE);
    startCapTypes->Reset(FALSE);
    endCapPoints->Reset(FALSE);
    endCapTypes->Reset(FALSE);

    INT count;
    GpPointF tangent;
    GpPointF* points;
    BYTE* types;
    REAL width, widthScale;
    
    // Get minimum line width based on the transform currently in effect.
    REAL majorR, minorR, unitScale;
    GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
    unitScale = min(majorR, minorR);

    if(customStartCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customStartCap->GetFillPointCount();
        
        if(count > 0)
        {            
            points = startCapPoints->AddMultiple(count);
            types = startCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                startCapPoints->Reset(FALSE);
                startCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customStartCap->GetWidthScale(&widthScale);
                width = Pen->Width*widthScale;
                
                REAL length = customStartCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customStartCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);

                // Compute the gradient of the cap.
    
                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointIterator,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient           // OUT parameters
                );
                
                tangent.X = -gradient.X;
                tangent.Y = -gradient.Y;

                // Move start point left or right to account for inset
                // pens, if needed.
                GpPointF start;
                start.X = startPoint.X;
                start.Y = startPoint.Y;
                
                customStartCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    start, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }

    if(status == Ok && customEndCap)
    {
        // Get the start cap and inset of the base start cap.

        count = customEndCap->GetFillPointCount();

        if(count > 0)
        {

            points = endCapPoints->AddMultiple(count);
            types = endCapTypes->AddMultiple(count);

            if(!points || !types)
            {
                endCapPoints->Reset(FALSE);
                endCapTypes->Reset(FALSE);
                status = OutOfMemory;
            }

            if(status == Ok)
            {
                customEndCap->GetWidthScale(&widthScale);

                width = Pen->Width*widthScale;
                
                REAL length = customEndCap->GetFillLength();
                
                // Compute the base inset. Divide by the length to get a 
                // number between 0 and 1. 0=no inset, 1=inset to the full
                // length of the cap.
                
                REAL inset;
                customEndCap->GetBaseInset(&inset);
                if(REALABS(length) < REAL_EPSILON)
                { 
                    inset = 0.0f;
                }
                else
                {
                    inset /= length;
                }
                
                length *= max(width, 1.0f/unitScale);
                
                // Compute the gradient of the cap.

                GpArrayIterator<GpPointF> pointIterator(
                    const_cast<GpPointF*>(centerPoints),
                    centerPointCount
                );
                GpReverseIterator<GpPointF> pointReverse(&pointIterator);
                pointReverse.SeekFirst();
    
                GpVector2D gradient;
                
                ComputeCapGradient(
                    pointReverse,
                    const_cast<BYTE*>(centerTypes),
                    length*length, 
                    inset,
                    &gradient            // OUT parameters
                );
                
                tangent.X = - gradient.X;
                tangent.Y = - gradient.Y;
                
                // Move end point left or right to account for inset
                // pens, if needed.
                GpPointF end;
                end.X = endPoint.X;
                end.Y = endPoint.Y;
                customEndCap->GetTransformedFillCap(
                    points, 
                    types, 
                    count,
                    end, 
                    tangent, 
                    width, 
                    2.0f / unitScale
                );
            }
        }
    }
    
    return status;
}

GpStatus
GpEndCapCreator::SetCustomStrokeCaps(
    GpCustomLineCap* customStartCap,
    GpCustomLineCap* customEndCap,
    const GpPointF& startPoint,
    const GpPointF& endPoint,
    const GpPointF *centerPoints,
    const BYTE *centerTypes,
    INT centerPointCount,
    DynPointFArray *startCapPoints,
    DynPointFArray *endCapPoints,
    DynByteArray *startCapTypes,
    DynByteArray *endCapTypes
    )
{
    GpStatus status = Ok;
        
    GpPointF* points = NULL;
    BYTE* types = NULL;

    INT count;
    GpPointF tangent, start, end;

    INT startCount = 0;
    INT endCount = 0;

    if(customStartCap)
    {
        startCount = customStartCap->GetStrokePointCount();
    }

    if(customEndCap)
    {
        endCount = customEndCap->GetStrokePointCount();
    }

    INT maxCount = max(startCount, endCount);

    if(maxCount <= 0)
    {
        return Ok;
    }

    points = (GpPointF*) GpMalloc(maxCount*sizeof(GpPointF));
    types = (BYTE*) GpMalloc(maxCount);

    if(!points || !types)
    {
        GpFree(points);
        GpFree(types);

        return OutOfMemory;
    }

    DpPen pen;
    GpPointF* widenedPts;
    INT widenedCount;
    REAL widthScale, width;

    if(customStartCap && startCount > 0)
    {
        startCapPoints->Reset(FALSE);
        startCapTypes->Reset(FALSE);
        
        customStartCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customStartCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customStartCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointIterator, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameters
        );
        
        tangent.X = -gradient.X;
        tangent.Y = -gradient.Y;

        // Move start point left or right to account for inset
        // pens, if needed.
        GpPointF start;
        start.X = startPoint.X;
        start.Y = startPoint.Y;
                
        customStartCap->GetTransformedStrokeCap(
            maxCount,
            &points, 
            &types, 
            &startCount,
            start, 
            tangent, 
            width, 
            width   
        );

        PrepareDpPenForCustomCap(&pen, customStartCap);
        
        GpPathWidener widener(
            points, 
            types, 
            startCount,
            &pen, 
            &XForm, 
            DpiX,          // widener doesn't use these.
            DpiY, 
            Antialias
        );

        widener.Widen(startCapPoints, startCapTypes);
    }

    if(customEndCap && endCount > 0)
    {
        endCapPoints->Reset(FALSE);
        endCapTypes->Reset(FALSE);
        
        customEndCap->GetWidthScale(&widthScale);

        width = Pen->Width*widthScale;
        
        REAL length = customEndCap->GetStrokeLength();
        
        // Handle the case of a non-closed stroke path
        // in this case the length is typically zero.
        
        if(REALABS(length)<REAL_EPSILON)
        {
            length = 1.0f;
        }
        
        // Compute the base inset. Divide by the length to get a 
        // number between 0 and 1. 0=no inset, 1=inset to the full
        // length of the cap.
        
        REAL inset;
        customEndCap->GetBaseInset(&inset);
        inset /= length;
        
        length *= width;
        
        // Compute the gradient of the cap.

        GpArrayIterator<GpPointF> pointIterator(
            const_cast<GpPointF*>(centerPoints),
            centerPointCount
        );
        GpReverseIterator<GpPointF> pointReverse(&pointIterator);
        pointReverse.SeekFirst();
        
        GpVector2D gradient;
        
        ComputeCapGradient(
            pointReverse, 
            const_cast<BYTE*>(centerTypes),
            length*length, 
            inset,
            &gradient            // OUT parameter
        );
        
        tangent.X = - gradient.X;
        tangent.Y = - gradient.Y;
        
        // Move end point left or right to account for inset
        // pens, if needed.
        GpPointF end;
        end.X = endPoint.X;
        end.Y = endPoint.Y;
                
        customEndCap->GetTransformedStrokeCap(
            maxCount,
            &points, 
            &types, 
            &endCount,
            end, 
            tangent, 
            width, 
            width
        );

        PrepareDpPenForCustomCap(&pen, customEndCap);
        
        GpPathWidener widener(
            points, 
            types, 
            endCount,
            &pen, 
            &XForm, 
            DpiX,    // widener doesn't use these. 
            DpiY, 
            Antialias
        );

        widener.Widen(endCapPoints, endCapTypes);
    }

    GpFree(points);
    GpFree(types);

    return status;
}



/**************************************************************************\
*
* Function Description:
*
*   This creates and returns two GpPaths containing the start and end cap.
*   The two caps are correctly positioned and scaled.
*
* Return
* 
*   Status
*
* Arguments:
*
*   [OUT]    startCapPath, endCapPath
*
* Created:
*
*   10/05/2000 asecchia
*       created it.
*
\**************************************************************************/

GpStatus
GpEndCapCreator::GetCapsForSubpath(
    GpPath **startCapPath,
    GpPath **endCapPath,
    GpPointF *centerPoints,
    BYTE *centerTypes,
    INT centerCount
    )
{
    // Validate our input parameters.
    
    ASSERT(startCapPath != NULL);
    ASSERT(endCapPath != NULL);
    ASSERT(*startCapPath == NULL);
    ASSERT(*endCapPath == NULL);

    DynPointFArray startCapPoints;
    DynPointFArray endCapPoints;
    DynByteArray startCapTypes;
    DynByteArray endCapTypes; 
    
    GpPointF startPoint, endPoint;

    startPoint = *(centerPoints);
    endPoint = *(centerPoints + centerCount - 1);
    
    GpStatus status = Ok;

    if(StartCap || EndCap)
    {
        status = SetCustomFillCaps(
            StartCap, 
            EndCap,
            startPoint, 
            endPoint, 
            centerPoints,
            centerTypes,
            centerCount,
            &startCapPoints,
            &endCapPoints,
            &startCapTypes,
            &endCapTypes
        );

        if(status == Ok)
        {
            status = SetCustomStrokeCaps(
                StartCap, 
                EndCap,
                startPoint, 
                endPoint, 
                centerPoints,
                centerTypes,
                centerCount,
                &startCapPoints,
                &endCapPoints,
                &startCapTypes,
                &endCapTypes
            );
        }
    }

    if(startCapPoints.GetCount() > 0)
    {
        *startCapPath = new GpPath(
            startCapPoints.GetDataBuffer(),
            startCapTypes.GetDataBuffer(),
            startCapPoints.GetCount()
        );
        
        if(*startCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(endCapPoints.GetCount() > 0)
    {
        *endCapPath = new GpPath(
            endCapPoints.GetDataBuffer(),
            endCapTypes.GetDataBuffer(),
            endCapPoints.GetCount()
        );
        
        if(*endCapPath == NULL)
        {
            status = OutOfMemory;
        }
    }
    
    if(status != Ok)
    {
        delete *startCapPath;
        delete *endCapPath;
        *startCapPath = NULL;
        *endCapPath = NULL;
        status = OutOfMemory;
    }
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\endcap.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   End Cap Creator.
*
* Abstract:
*
*   This module defines a class called GpEndCapCreator. This class is 
*   responsible for constructing a path containing all the custom endcaps
*   and anchor endcaps for a given path. These are correctly transformed
*   and positioned.
*
*   This class is used to create and position all the endcaps for a
*   given path and pen. This class is also responsible for trimming
*   the original path down so that it fits the end caps properly.
*   This class will handle all types of end caps except the base endcaps
*   (round, flat and triangle) which may be used as dash caps.
*   Caps that are handled are CustomCaps and the 3 Anchor caps (round,
*   diamond and arrow). Note that the round anchor cap is distinct from
*   the round base cap.
*
* Created:
*
*   10/09/2000 asecchia
*      Created it.
*
**************************************************************************/
#ifndef _ENDCAP_HPP
#define _ENDCAP_HPP
class GpEndCapCreator
{
public:
    
    GpEndCapCreator(
        GpPath *path, 
        DpPen *pen, 
        const GpMatrix *m,
        REAL dpi_x, 
        REAL dpi_y,
        bool antialias
    );
    
    ~GpEndCapCreator();
    
    GpStatus CreateCapPath(GpPath **caps);
    
    static bool PenNeedsEndCapCreator(const DpPen *pen);
    
protected:
    
    GpStatus GetCapsForSubpath(
        GpPath **startCapPath,
        GpPath **endCapPath,
        GpPointF *centerPoints,
        BYTE *centerTypes,
        INT centerCount
    );
    
    GpStatus SetCustomStrokeCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
    );
    
    GpStatus SetCustomFillCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
    );
    
    void ComputeCapGradient(
        GpIterator<GpPointF> &pointIterator, 
        BYTE *types,
        IN  REAL lengthSquared,
        IN  REAL baseInset,
        OUT GpVector2D *grad
    );
    
    VOID PrepareDpPenForCustomCap(
        DpPen* pen,
        const GpCustomLineCap* customCap
    ) const;

    static GpCustomLineCap *ReferenceArrowAnchor();
    static GpCustomLineCap *ReferenceDiamondAnchor();
    static GpCustomLineCap *ReferenceRoundAnchor();
    static GpCustomLineCap *ReferenceSquareAnchor();

    // Data member variables.

    GpPath *Path;
    DpPen *Pen;
    GpMatrix XForm;
    bool Antialias;
    
    GpCustomLineCap *StartCap;
    GpCustomLineCap *EndCap;
    
    // Note that the widener doesn't use these, so we should actually remove
    // this and the parameters to the widener.
    
    REAL DpiX, DpiY;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fasttext.hpp ===
/////   FastTextImager
//
//      Handles common case string measurement and display



const INT FAST_TEXT_PREALLOCATED_CHARACTERS = 64;

typedef AutoBuffer<UINT16, FAST_TEXT_PREALLOCATED_CHARACTERS> Uint16StackBuffer;
typedef AutoBuffer<INT,    FAST_TEXT_PREALLOCATED_CHARACTERS> IntStackBuffer;


class FastTextImager
{
public:
    GpStatus Initialize(
        GpGraphics            *graphics,
        const WCHAR           *string,
        INT                    length,
        const RectF           &layoutRectangle,
        const GpFontFamily    *family,
        INT                    style,
        REAL                   emSize,   // Preconverted to world units
        const GpStringFormat  *format,
        const GpBrush         *brush
    );

    GpStatus MeasureString(
        RectF *boundingBox,
        INT   *codepointsFitted,
        INT   *linesFilled
    );

    GpStatus DrawString();

private:
    GpStatus RemoveHotkeys();

    GpStatus FastLayoutString();

    GpStatus DrawFontStyleLine(
        const PointF    *baselineOrigin,    // base line origin in device unit
        REAL            baselineLength,     // base line length in device unit
        INT             style               // font styles
    );

    void FastAdjustGlyphPositionsProportional(
        IN   const INT       *hintedWidth,            // 28.4  device
        OUT  INT             *x,                      // 28.4  device Initial x
        OUT  IntStackBuffer  &dx,                     // 32.0  device Glyph advances
        OUT  const UINT16   **displayGlyphs,          // First displayable glyph
        OUT  INT             *displayGlyphCount,
        OUT  INT             *leadingBlankCount
    );

    void GetWorldTextRectangleOrigin(
        PointF &origin
    );

    void GetDeviceBaselineOrigin(
        IN   GpFaceRealization  &faceRealization,
        OUT  PointF             &origin
    );

    GpStatus FastDrawGlyphsGridFit(
        GpFaceRealization  &faceRealization
    );

    GpStatus FastDrawGlyphsNominal(
        GpFaceRealization  &faceRealization
    );


    // Initialisation parameters

    GpGraphics            *Graphics;
    const UINT16          *String;
    INT                    Length;  // Measured, if necessary
    RectF                  LayoutRectangle;
    const GpFontFamily    *Family;
    INT                    Style;
    REAL                   EmSize;  // In world units
    const GpStringFormat  *Format;
    const GpBrush         *Brush;


    // Derived. All are set if Initialize succeeds

    INT               FormatFlags;
    StringAlignment   Alignment;
    GpFontFace       *Face;
    GpMatrix          WorldToDevice;
    REAL              LeftMargin;
    REAL              RightMargin;
    INT               OverflowAvailable;   // Available for advance width expansion 32.0
    REAL              LeftOffset;          // Allowance to reduce adjustment
    INT               GlyphCount;
    REAL              TotalWorldAdvance;
    GpMatrix          FontTransform;
    REAL              LineLengthLimit;
    REAL              WorldToDeviceX;
    REAL              WorldToDeviceY;
    UINT16            BlankGlyph;
    UINT16            DesignEmHeight;
    REAL              CellHeight;
    INT               NominalToBaselineScale;   // 16.16
    TextRenderingHint TextRendering;
    INT               HotkeyPosition;


    // Auto buffers common to drawing and measurement

    AutoBuffer<UINT16, FAST_TEXT_PREALLOCATED_CHARACTERS> Glyphs;
    AutoBuffer<UINT16, FAST_TEXT_PREALLOCATED_CHARACTERS> NominalWidths; // 16.0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\family.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*       Implementation of GpFontFamily and GpFontFamilyList
*
* Revision History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/
#include "precomp.hpp"

#if DBG
#include <mmsystem.h>
#endif

#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#define SWAP_LANGID(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )

//
VOID CopyFamilyName(WCHAR * dest, const WCHAR * src, BOOL bCap)
{

    GpMemset(dest, 0, FamilyNameMax * sizeof(WCHAR));

    if (src != NULL)
    {
        for (int c = 0; src[c] && c < FamilyNameMax - 1; c++)
            dest[c] = src[c];
    }

    if (bCap)
        UnicodeStringToUpper(dest, dest);
}

//////////////////////////////////////////////////////////////////////////////

GpFontFamily::GpFontFamily(const WCHAR *name,  GpFontFile * fontfile, INT index, 
                            FAMILYCACHEENTRY * pCacheEntry, GpFontCollection *fontCollection)
{
    SetValid(TRUE); // set initial valid state to TRUE (valid)


//    InitializeCriticalSection(&FontFamilyCritSection);

    cacheEntry = pCacheEntry;
    
    CopyFamilyName(cacheEntry->Name, name, TRUE);

    for (INT ff = 0; ff < NumFontFaces; ff++)
    {
        Face[ff] = NULL;
        FontFile[ff] = NULL;
        cacheEntry->cFilePathName[ff] = 0;
        cacheEntry->LastWriteTime[ff].LowPart = 0;
        cacheEntry->LastWriteTime[ff].HighPart = 0;
    }

    cFontFamilyRef = 0;

    cacheEntry->iFont = index;

// Get font entry for the font file
    GpFontFace * fontface = fontfile->GetFontFace(cacheEntry->iFont);

// Get LandID for Family Name
    cacheEntry->LangID = SWAP_LANGID((LANGID *) &fontface->pifi->familyNameLangID);
    cacheEntry->AliasLnagID = SWAP_LANGID((LANGID *) &fontface->pifi->familyAliasNameLangID);

// Process Alias name
    cacheEntry->bAlias = fontface->IsAliasName();

    if (cacheEntry->bAlias)
    {
        CopyFamilyName(cacheEntry->FamilyAliasName, fontface->GetAliasName(), TRUE);
        CopyFamilyName(cacheEntry->NormalFamilyAliasName, fontface->GetAliasName(), FALSE);
    }

    CopyFamilyName(cacheEntry->NormalName, fontfile->GetFamilyName(cacheEntry->iFont), FALSE);

    //  Determine face type(s) of font
    FontStyle style = FontStyleRegular;
    //  ...

//    SetFont(face, font);

    cacheEntry->lfCharset = DEFAULT_CHARSET;
    if (fontCollection == NULL)
    {
        associatedFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();
    }
    else
    {
        associatedFontCollection = fontCollection;
    }

    FamilyFallbackInitialized = FALSE;

    bLoadFromCache = FALSE;
    bFontFileLoaded = TRUE;

}

GpFontFamily::GpFontFamily(FAMILYCACHEENTRY * pCacheEntry)
{
    SetValid(TRUE); // set initial valid state to TRUE (valid)

//    InitializeCriticalSection(&FontFamilyCritSection);

    cacheEntry = pCacheEntry;
    
    for (INT ff = 0; ff < NumFontFaces; ff++)
    {
        Face[ff] = NULL;
        FontFile[ff] = NULL;
    }

    cFontFamilyRef = 0;

    // It will be from Cache entry.
    bFontFileLoaded = FALSE;

    //  Determine face type(s) of font
    FontStyle style = FontStyleRegular;
    
    associatedFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

    FamilyFallbackInitialized = FALSE;

    bLoadFromCache = TRUE;

}

GpFontFamily::~GpFontFamily()
{
    if (FamilyFallbackInitialized)
    {
        FamilyFallbackInitialized = FALSE;
        fallback.Destroy();
    }

    ReleaseCacheEntry();

//    DeleteCriticalSection(&FontFamilyCritSection);

    SetValid(FALSE);    // so we don't use a deleted object
}


BOOL GpFontFamily::IsPrivate() const
{
    return associatedFontCollection != GpInstalledFontCollection::GetGpInstalledFontCollection();
}


void GpFontFamily::SetFaceAndFile(INT style, GpFontFace *face, GpFontFile * fontfile)
{
//    EnterCriticalSection(&FontFamilyCritSection);
    Face[style & 3] = face;
    FontFile[style & 3] = fontfile;
    cacheEntry->LastWriteTime[style & 3].QuadPart = (fontfile->GetFileView())->LastWriteTime.QuadPart;
    

//    LeaveCriticalSection(&FontFamilyCritSection);
}

GpStatus GpFontFamily::GetFamilyName(WCHAR   name[LF_FACESIZE], LANGID  language) const
{
    ASSERT(FamilyNameMax == LF_FACESIZE);

    if (cacheEntry->bAlias && language == cacheEntry->AliasLnagID)
    {
        CopyFamilyName(name, cacheEntry->NormalFamilyAliasName, FALSE);
    }
    else
    {
        CopyFamilyName(name, cacheEntry->NormalName, FALSE);
    }

    return Ok;
}

BOOL GpFontFamily::IsFileLoaded(BOOL loadFontFile) const
{

    // If file is not loaed yet then load it.
    if (!bFontFileLoaded)
    {
        if (loadFontFile)
        {
            if (bLoadFromCache)
            {
                GpFontTable *fontTable;
                GpFontFile * fontFile;
                WCHAR *      fontfilepath;
            
                fontTable = (GpInstalledFontCollection::GetGpInstalledFontCollection())->GetFontTable();

                fontfilepath = (WCHAR *) ((BYTE *) cacheEntry + QWORD_ALIGN(sizeof(FAMILYCACHEENTRY)));
            
                for (UINT i = 0; i < NumFontFaces; i++)
                {
                    if (cacheEntry->cFilePathName[i])
                    {
                        fontFile = fontTable->AddFontFile(fontfilepath);
    
                        if (!fontFile)
                        {
                            return FALSE;
                        }
                        else
                        {
                            GpFontFace* face = fontFile->GetFontFace(cacheEntry->iFont);
                            FontStyle style  = face->GetFaceStyle();
        
                            Face[style & 3] = face;
                        
                            face->cGpFontFamilyRef = cFontFamilyRef;
                        
                            FontFile[style & 3] = fontFile;
                        
                            cacheEntry->LastWriteTime[style & 3].QuadPart = 
                                            (fontFile->GetFileView())->LastWriteTime.QuadPart;
                        }

                        fontfilepath = (WCHAR *) ((BYTE *) fontfilepath + cacheEntry->cFilePathName[i]);
                    }                    
                }

                bFontFileLoaded = TRUE;
            }
            else
            {
                ASSERT(!bLoadFromCache);
            }
        }
        else
        {
            return FALSE;
        }
    }

    return bFontFileLoaded;
}
    

GpFontFace *GpFontFamily::GetFace(INT style) const
{
    // Return face for the given style - either the direct face
    // or one which can support this style through simulation.

    GpFontFace *fontFace = NULL;
//    EnterCriticalSection(&FontFamilyCritSection);

    if (IsFileLoaded())
    {        
        if (Face[style&3])
        {
            // Distinct font exists
            fontFace = Face[style&3];
        }
        else
        {
            // Will need simulation
            switch (style & 3)
            {
                case FontStyleBold:
                case FontStyleItalic:
                    fontFace = Face[0];
                    break;

                case FontStyleBold|FontStyleItalic:
                    if (Face[FontStyleBold])
                    {
                        fontFace = Face[FontStyleBold];
                    }
                    else if (Face[FontStyleItalic])
                    {
                        fontFace = Face[FontStyleItalic];
                    }
                    else
                    {
                        fontFace = Face[0];
                    }
                    break;

                default:
                case 0:
                    ;
            }
        }
    }
//    LeaveCriticalSection(&FontFamilyCritSection);
    return fontFace;
}

GpFontFace *GpFontFamily::GetFaceAbsolute(INT style) const
{
    // Return face for the given style, where the style is one of
    // the four basic types.  If it does not exist, return NULL.

    GpFontFace *fontFace = NULL;

//    EnterCriticalSection(&FontFamilyCritSection);
    if (IsFileLoaded())
        fontFace = Face[style & 3];

//    LeaveCriticalSection(&FontFamilyCritSection);
    return (fontFace);
}

UINT16 GpFontFamily::GetDesignEmHeight (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignEmHeight() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;

}

UINT16 GpFontFamily::GetDesignCellAscent (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignCellAscent() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignCellDescent (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignCellDescent() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignLineSpacing (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignLineSpacing() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignUnderscoreSize (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignUnderscoreSize() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

INT16 GpFontFamily::GetDesignUnderscorePosition (INT style) const
{
    INT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignUnderscorePosition() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

UINT16 GpFontFamily::GetDesignStrikeoutSize (INT style) const
{
    UINT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignStrikeoutSize() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}

INT16 GpFontFamily::GetDesignStrikeoutPosition (INT style) const
{
    INT16 result;
    GpFontFace *fontface;

//    EnterCriticalSection(&FontFamilyCritSection);
    fontface = GetFace(style);
    result = ((fontface != NULL) ? fontface->GetDesignStrikeoutPosition() : 0);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Determines available (non-NULL) faces for this family
*
* Arguments:
*
*       None
*
* Returns:
*
*       Bitset of available face flags
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

INT GpFontFamily::AvailableFaces(void) const
{
    INT faces = 0;

    if (bFontFileLoaded)
    {
        for (int ff = 0; ff < NumFontFaces; ff++)
        {
            if (Face[ff] != NULL)
            {
                //  Map index to FontFace flag
                faces |= (0x01 << ff);
            }
        }
    }
    else
    {
    // At least one face exists.
    
        faces = 1;
    }
    
    return faces;
}




/**************************************************************************\
*
* Function Description:
*
*   Determines whether the specified face supports a given string
*
* Arguments:
*
*   style:  font face to test for support
*   lang:   language id
*
* Returns:
*
*       Boolean result
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamily::SupportsLanguage(INT style, LANGID lang) const
{
    BOOL result = TRUE;

    //  ...

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Determines whether the specified face supports a given string
*
* Arguments:
*
*   style:  font face to test for support
*       str:    target string
*   len:    string length
*
* Returns:
*
*       Boolean result
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamily::SupportsCharacters(INT style, WCHAR* str, INT len) const
{
    BOOL result = TRUE;

    //  ...

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal, access the tables from the font, return a pointer
*
* Arguments:
*
*   style:  font style
*   tag: 4 bytes tag for the table, a null tag means return the whole file
*
* Returns:
*
*       table size and pointer to the table
*
* History:
*
*   09/10/1999 caudebe
*       Created it.
*
\**************************************************************************/

GpStatus GpFontFamily::GetFontData(FontStyle style, UINT32 tag, INT* tableSize, BYTE** pjTable)
{
    GpFontFace *face;
    GpStatus status;

//    EnterCriticalSection(&FontFamilyCritSection);

    face = GetFace(style);
    if (face == NULL)
    {
        return GenericError;
    }

    status = face->GetFontData (tag, tableSize, pjTable);

//    LeaveCriticalSection(&FontFamilyCritSection);
    return status;
}

void GpFontFamily::ReleaseFontData(FontStyle style)
{
    GpFontFace *face;

//    EnterCriticalSection(&FontFamilyCritSection);

    face = GetFace(style);
    if (face != NULL)
    {
        face->ReleaseFontData();
    }

//    LeaveCriticalSection(&FontFamilyCritSection);
}

/**************************************************************************\
*
* Function Description:
*
*   Determines whether a font family is deletable.  Returns TRUE
*   if its ref count is 0 and all of its Face pointers are NULL.
*
* Arguments:
*   none
*
* Returns:
*
*       Boolean result
*
* History:
*
*   2/21/2000 dchinn
*       Created it.
*
\**************************************************************************/

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE exactly when all faces of the font family have had
*   RemoveFontFile() called on their corresponding font files.
*
* Arguments:
*   none
*
* Returns:
*   boolean
*
* History:
*
*   03/08/2000 dchinn
*       Created it.
*
\**************************************************************************/
BOOL GpFontFamily::AreAllFacesRemoved()
{
    /* no need for critical section, called only internally */

    if (!bFontFileLoaded)
    {
        ASSERT (bLoadFromCache);

        return FALSE;
    }
    else
    {
        for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
        {
            if (Face[iFace] != NULL)
            {
                ASSERT (Face[iFace]->pff);
                if (!Face[iFace]->pff->bRemoved)
                {
                    // if the GpFontFile corresponding to the GpFontFace
                    // has not been removed, then the face is still "active"
                    // and so the font family is still "active".
                    return FALSE;
                }
            }
        }
    }
    
    return TRUE;

}


BOOL GpFontFamily::Deletable()
{
    BOOL bAllFacesNull = TRUE;

    if (cFontFamilyRef != 0)
    {
        return FALSE;
    }

    for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
    {
        if (Face[iFace] != NULL)
        {
            bAllFacesNull= FALSE;
        }
    }
    return bAllFacesNull;
}

/**************************************************************************\
*
* Function Description:
*
*   Increments/decrements the reference count for the fontFamily and each GpFontFace (PFE)
*   pointed to by the Face pointers of the GpFontFamily object.
*
* Arguments:
*   none
*
* Returns:
*   nothing
*
* History:
*
*   2/21/2000 dchinn
*       Created it.
*
\**************************************************************************/
BOOL GpFontFamily::IncFontFamilyRef()
{
//    EnterCriticalSection(&FontFamilyCritSection);
    if (AreAllFacesRemoved())
    {
//        LeaveCriticalSection(&FontFamilyCritSection);
        return FALSE;
    }
    else
    {
        cFontFamilyRef++;
        
        if (bFontFileLoaded)
        {
            for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
            {
                if (Face[iFace])
                {
                    Face[iFace]->IncGpFontFamilyRef();
                }
            }
        }
        
//        LeaveCriticalSection(&FontFamilyCritSection);
        return TRUE;
    }
}

void GpFontFamily::DecFontFamilyRef()
{
//    EnterCriticalSection(&FontFamilyCritSection);
    cFontFamilyRef--;

    if (bFontFileLoaded)
    {
        for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
        {
            if (Face[iFace])
            {
                Face[iFace]->DecGpFontFamilyRef();
            }
        }
    }

//    LeaveCriticalSection(&FontFamilyCritSection);
}


GpStatus GpFontFamily::CreateFontFamilyFromName(
            const WCHAR *name,
            GpFontCollection *fontCollection,
            GpFontFamily **fontFamily)
{
    GpFontTable *fontTable;
    GpFontCollection *gpFontCollection;

    if (!name || !fontFamily)
    {
        return InvalidParameter;
    }
    
    GpStatus status = Ok;

    // ASSERT: if fontCollection is NULL, then the caller wants to
    // act on the GpInstalledFontCollection object.  Otherwise, the
    // caller has passed in a GpPrivateFontCollection.

    if (fontCollection == NULL)
    {
        gpFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();
    }
    else
    {
        gpFontCollection = fontCollection;
    }

    if (gpFontCollection == NULL)
        return WrongState;

    fontTable = gpFontCollection->GetFontTable();

    if (!fontTable->IsValid())
        return OutOfMemory;

    if (!fontTable->IsPrivate() && !fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    *fontFamily = fontTable->GetFontFamily(name);

    if (*fontFamily == NULL)
    {
        GetFamilySubstitution(name, fontFamily);
    }


    if (!*fontFamily)
        status = FontFamilyNotFound;

    // NOTE: We assume here that GdipCreateFontFamilyFromName gets
    // called externally (e.g., the FontFamily constructor).
    if (*fontFamily && (!(*fontFamily)->IncFontFamilyRef()))
    {
        // all the faces of the found fontFamily have been removed.
        // we do not want to return the fontFamily.
        *fontFamily = NULL;
        status = FontFamilyNotFound;
    }

    return status;
}

GpStatus GpFontFamily::GetGenericFontFamilySansSerif(
            GpFontFamily **nativeFamily)
{
    GpStatus status;

    if (!nativeFamily)
    {
        return InvalidParameter;
    }
    // return FontFamily::GetGenericSansSerif(nativeFamily);
    status = CreateFontFamilyFromName(L"Microsoft Sans Serif", NULL, nativeFamily);

    if (status == FontFamilyNotFound)
    {
        // Not found Arial in system so we got to find another font
        
        status = CreateFontFamilyFromName(L"Arial", NULL, nativeFamily);

        if (status == FontFamilyNotFound)
            status = CreateFontFamilyFromName(L"Tahoma", NULL, nativeFamily);

        // We are in the worst case so trying to find any font we can.

        if (status == FontFamilyNotFound)
        {
            GpFontTable *fontTable;
            GpFontCollection *gpFontCollection;

            gpFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

            fontTable = gpFontCollection->GetFontTable();

            if (!fontTable->IsValid())
                return OutOfMemory;

            *nativeFamily = fontTable->GetAnyFamily();

            if (!*nativeFamily)
                status = FontFamilyNotFound;
            else
                status = Ok;
        }
    }
    
    return status;
}

GpStatus GpFontFamily::GetGenericFontFamilySerif(
            GpFontFamily **nativeFamily)
{
    GpStatus status;

    if (!nativeFamily)
    {
        return InvalidParameter;
    }
    
    // return FontFamily::GetGenericSerif(nativeFamily);
    status = CreateFontFamilyFromName(L"Times New Roman", NULL, nativeFamily);

    // Get the font family from SansSerif
    if (status == FontFamilyNotFound)
        status = GetGenericFontFamilySansSerif(nativeFamily);

    return status;
}


GpStatus GpFontFamily::GetGenericFontFamilyMonospace(
            GpFontFamily **nativeFamily)
{
    GpStatus status;

    if (!nativeFamily)
    {
        return InvalidParameter;
    }
    // return FontFamily::GetGenericMonospace(nativeFamily);
    status = CreateFontFamilyFromName(L"Courier New", NULL, nativeFamily);

    if (status == FontFamilyNotFound)
        status = CreateFontFamilyFromName(L"Lucida Console", NULL, nativeFamily);

    // We are in the worst case so trying to find any font we can.
    if (status == FontFamilyNotFound)
        status = GetGenericFontFamilySansSerif(nativeFamily);

    return status;
}


//////////////////////////////////////////////////////////////////////////////
//  GpFontFamilyList

GpFontFamilyList::GpFontFamilyList()
:   Head(NULL), FamilyCacheEntry(NULL)
{}


GpFontFamilyList::~GpFontFamilyList()
{
    DeleteList();
}

void GpFontFamilyList::DeleteList(void)
{
    for (FamilyNode* node = Head; node != NULL; )
    {
        FamilyNode * next = node->Next;
        delete node->Item;
        delete node;
        node = next;
    }

    if (FamilyCacheEntry)
    {
        GpFree(FamilyCacheEntry);
        FamilyCacheEntry = NULL;
    }
    
    Head = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Counts number of enumerable families
*
* Arguments:
*
*   filter:         filter describing the desired font styles
*
* Returns:
*
*       Number of available families
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

INT GpFontFamilyList::Enumerable(GpGraphics* graphics) const
{
    INT result = 0;
    for (FamilyNode* node = Head; node != NULL; node = node->Next)
    {
        if (node->Item == NULL)
        {
            ASSERT(node->Item);
        }
        else if ( node->Item->AvailableFaces() != 0)
        {
            result++;
        }
    }

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Enumerates the available font families.
*
*   If numExpected == 0 then Enumerate() counts the number of available families
*       and returns the result in numExpected.
*
*   If numExpected != 0 then Enumerate() sets pointers to as many available
*       families as possible.
*
*   The total number of emurated families is return in numEnumerated.
*
* Arguments:
*
*   numExpected:    number of families expected and allocated in families array
*   families:       array to hold pointers to enumerated families (preallocated)
*   numEnumerated:  the actual number of fonts enumerated in this pass
*   filter:         filter describing the desired font styles
*
* Returns:
*
*       Status of the operation, which may include:
*       - success
*       - too few available fonts
*       - too many available fonts
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

Status GpFontFamilyList::Enumerate(
    INT                     numSought,
    GpFontFamily*           gpfamilies[],
    INT&                    numFound,
    GpGraphics*             graphics
) const
{
    Status status = Ok;

    numFound = 0;
    for
    (
        FamilyNode* node = Head;
        node != NULL && numFound < numSought;
        node = node->Next
    )
    {
        if (node->Item == NULL)
        {
            ASSERT(node->Item);
        }
        else if ( node->Item->AvailableFaces() != 0)
        {
            gpfamilies[numFound++] = node->Item;
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Finds the any font (except Marlett) in the family list
*
* Arguments:
*
* Returns:
*
*       Pointer to family if found any, else NULL
*
* History:
*
*   07/14/2000 YungT
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontFamilyList::GetAnyFamily() const
{

    for (FamilyNode* node = Head; node != NULL; node = node->Next)
    {
        if (node->Item == NULL)
        {
            //ASSERT
        }
        else
        {
            if (!UnicodeStringCompare(L"MARLETT", node->Item->GetCaptializedName()) == 0)
            {
                return node->Item;
            }
       }
    }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Finds the named font in the family list
*
* Arguments:
*
*       name:   name of the font family to be found
*
* Returns:
*
*       Pointer to family if found, else NULL
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontFamilyList::GetFamily(const WCHAR *familyName) const
{
    WCHAR       nameCap[FamilyNameMax];  // Family name

    GpMemset(nameCap, 0, sizeof(nameCap));

    for (int c = 0; familyName[c] && c < FamilyNameMax - 1; c++)
       nameCap[c] = familyName[c];

    UnicodeStringToUpper(nameCap, nameCap);

    for (FamilyNode* node = Head; node != NULL; node = node->Next)
    {
        if (node->Item == NULL)
        {
            //ASSERT
        }
        else
        {
            if (UnicodeStringCompare(nameCap, node->Item->GetCaptializedName()) == 0)
            {
                return node->Item;
            }

            if (node->Item->IsAliasName())
            {
                if (UnicodeStringCompare(nameCap, node->Item->GetAliasName()) == 0)
                {
                    return node->Item;
                }
            }
        }
    }

    return NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Adds a font family to the enumeration list ordered alphabetically
*       by family name.
*
* Arguments:
*
*       fontFile:   the font to be added.
*
* Returns:
*
*       Boolean indicating success
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::AddFont(GpFontFile* fontFile,
                               GpFontCollection *fontCollection)
{
    BOOL newFamily = FALSE;
    BOOL newNodeInserted = FALSE;

    //  Loop over each entry per font file
    for (ULONG e = 0; e < fontFile->GetNumEntries(); e++)
    {
        VERBOSE(("Adding \"%ws\" to family list...", fontFile->GetFamilyName(e)))

        //  Check if the family already exists, if not create a new entry
        GpFontFamily* family = GetFamily(fontFile->GetFamilyName(e));

        if (family == NULL)
        {
            FAMILYCACHEENTRY *  pCacheEntry;

            UINT cjSize = sizeof(FAMILYCACHEENTRY);
            
            // This family is not in the list, create a new GpFontFamily object
            if (!(pCacheEntry = (FAMILYCACHEENTRY *) GpMalloc(cjSize)))
            {
                return FALSE;
            }

            pCacheEntry->cjThis = cjSize;
            
            family = new GpFontFamily(fontFile->GetFamilyName(e), fontFile, e, pCacheEntry, fontCollection);
            if (family == NULL)
            {
                GpFree(pCacheEntry);
                WARNING(("Error constructing family."))
                return FALSE;
            }

            newFamily = TRUE;
        }

        //  Insert entry into the enumeration list, ordered alphabetically
        GpFontFace* face = fontFile->GetFontFace(e);
        FontStyle style  = face->GetFaceStyle();

        if (InsertOrdered(family, style, fontFile, face, TRUE))
            newNodeInserted = TRUE;

        if (newFamily && !newNodeInserted)
        {
            // New GpFontFamily object not used, delete it
            delete family;
            return FALSE;
        }
    }

    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*   Inserts font family into the enumeration list ordered alphabetically
*       by family name, and links up the face pointer to the font entry.
*
* Arguments:
*
*   family:     the font family
*   face:       the font face
*   entry:      the font entry
*
* Returns:
*
*       Boolean indicating whether family was added (a new node was created)
*
* History:
*
*   29/07/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::InsertOrdered(
    GpFontFamily*   family,
    FontStyle       style,
    GpFontFile *    fontfile,          
    GpFontFace *    face,
    BOOL            bSetFace
)
{
    BOOL result = FALSE;

    if (Head == NULL)
    {
        //  First entry
        FamilyNode *new_node = new FamilyNode(family);
        if (!new_node)
            return FALSE;

        if(bSetFace)
            new_node->Item->SetFaceAndFile(style, face, fontfile);
            
            
        Head = new_node;
        return TRUE;
    }
    else
    {
        //  Search the enumeration list
        for (FamilyNode* node = Head; node != NULL; node = node->Next)
        {
            int comp = UnicodeStringCompare(node->Item->GetCaptializedName(), family->GetCaptializedName());
            if (comp == 0)
            {
                //  FontFamily found in list
                if (bSetFace && node->Item->FaceExist(style & 3))
                {
                    //  This face already exists for this family, do nothing
                    VERBOSE(("Face collision: face %d exists for family \"%ws\".", style, family->GetCaptializedName()))
                }
                else
                {
                    if (bSetFace)
                    {
                        //  Update face pointer
                        node->Item->SetFaceAndFile(style, face, fontfile);
                    }
                }

                return FALSE;
            }
            else if (comp > 0)
            {
                //  Add new family node
                FamilyNode *new_node = new FamilyNode(family);
                if (!new_node)
                    return FALSE;

                if (bSetFace)
                {
                    //  Update face pointer
                    new_node->Item->SetFaceAndFile(style, face, fontfile);
                }

                //  Insert before node
                if (node->Prev == NULL)
                {
                    //  Insert at head
                    new_node->Next = node;
                    node->Prev = new_node;
                    Head = new_node;
                }
                else
                {
                    //  Insert between node and prev
                    new_node->Next = node;
                    new_node->Prev = node->Prev;
                    node->Prev->Next = new_node;
                    node->Prev = new_node;
                }
                return TRUE;
            }
            else if (node->Next == NULL)
            {
                //  Add new family node
                FamilyNode *new_node = new FamilyNode(family);
                if (!new_node)
                    return FALSE;

                if (bSetFace)
                {
                        //  Update face pointer

                    new_node->Item->SetFaceAndFile(style, face, fontfile);
                }
                
                //  Insert at tail
                new_node->Prev = node;
                node->Next = new_node;

                return TRUE;
            }
        }
    }

    return result;
}


/**************************************************************************\
*
* Function Description:
*
*   Given a pointer to a font family, remove that font family from the list,
*   but only if its ref count is 0 and its Face pointers are all NULL.
*   The parameter bDeleted is set to TRUE if a GpFontFamily was deleted from
*   the list.
*
* Arguments:
*
*   fontFamily: the font family to be removed
*
* Returns:
*
*   Boolean indicating success
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::RemoveFontFamily(GpFontFamily* fontFamily)
{
    FamilyNode *node;

    node = Head;

    while(node)
    {
        if (node->Item == fontFamily)
        {
            if (node->Item->Deletable())
            {
                if (node->Prev)
                    node->Prev->Next = node->Next;
                if (node->Next)
                    node->Next->Prev = node->Prev;

                if (node == Head)
                    Head = node->Next;

                delete node->Item;
                delete node;
                node = NULL;
            }
            else
            {
                // We found the font family, but it's not deletable, so
                // we can quit trying to delete the font family from the list.
                break;
            }
        }
        else
        {
            node = node->Next;
        }
    }
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*   Create a cache list from GpFontFamily.cacheEntry
*   We will load it when the Family list is touched
*
* Arguments:
*
*   None
*
* Returns:
*
*   None
*
* History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

VOID GpFontFamilyList::UpdateFamilyListToCache(BOOL bLoadFromRegistry, HKEY hkey, 
                                ULONG registrySize, ULONG numExpected)
{
    FamilyNode *node;

    UINT                cachedSize = 0;    
    UINT                entrySize = 0;
    GpFontFile *        fontfile;
    GpFontFamily *      family;
    FAMILYCACHEENTRY *  pEntry;
    
    node = Head;

    if (bLoadFromRegistry)
        cachedSize = QWORD_ALIGN(registrySize + 8);

    while(node)
    {
        entrySize = 0;

        // Get the current GpFontFamily from family list
        
        family = node->Item;

        pEntry = family->GetCacheEntry();

        // Here we need to calcuatle the size for each cache entry
        // it include FAMILYCACHEENTRY + fontfilepathname1 + fontfilepathname2
        //   A fmaily could have 1 more font file included
        
        entrySize += QWORD_ALIGN(pEntry->cjThis);

        for (UINT i = 0; i < NumFontFaces; i++)
        {
            
            if (fontfile = family->GetFontFile(i))
            {
                pEntry->cFilePathName[i] = QWORD_ALIGN(fontfile->GetPathNameSize() * 2);
                entrySize += pEntry->cFilePathName[i];                
            }
        }

        cachedSize += entrySize;
        
        node = node->Next;
    }

    BYTE * pCacheEntry = (BYTE *)FontFileCacheAlloc(cachedSize);
    
    if (!pCacheEntry)
    {
        FontFileCacheFault();
        return;
    }

    if (bLoadFromRegistry)
    {
        DWORD   allDataSize = 0;
        ULONG   index = 0;
        LONG    error = ERROR_SUCCESS;
        
        PBYTE   pRegistryData;

        *((ULONG *) pCacheEntry) = 0xBFBFBFBF;
        
        *((ULONG *) (pCacheEntry + 4)) = registrySize;

        pRegistryData = pCacheEntry + 8;

        while (index < numExpected && error != ERROR_NO_MORE_ITEMS && allDataSize < registrySize)
        {
            DWORD   regType = 0;
            DWORD   labelSize = MAX_PATH;
            DWORD   dataSize = MAX_PATH;
            CHAR    label[MAX_PATH];
            BYTE    data[MAX_PATH];

            error = RegEnumValueA(hkey, index, label, &labelSize, NULL, &regType, data, &dataSize);

            if (error == ERROR_NO_MORE_ITEMS)
                break;

            memcpy(pRegistryData, data, dataSize);

            pRegistryData += dataSize;

            allDataSize += dataSize;            

            index ++;
        }

        pCacheEntry += QWORD_ALIGN(registrySize + 8);
    }
       

    node = Head;

    while(node)
    {
        entrySize = 0;


        family = node->Item;

        pEntry = family->GetCacheEntry();

        ASSERT(pEntry->cjThis == sizeof(FAMILYCACHEENTRY));
        
        entrySize = QWORD_ALIGN(pEntry->cjThis);
        
        memcpy((VOID *) pCacheEntry, (VOID *) pEntry, pEntry->cjThis);

        for (UINT i = 0; i < NumFontFaces; i++)
        {

            // cache the font file path name
            if (fontfile = family->GetFontFile(i))
            {
                memcpy((VOID *) (pCacheEntry + entrySize), (VOID *) fontfile->GetPathName(), 
                                fontfile->GetPathNameSize() * 2);
                entrySize += pEntry->cFilePathName[i];                
            }
        }

        ((FAMILYCACHEENTRY *)pCacheEntry)->cjThis = entrySize;

        pCacheEntry += entrySize;
        
        node = node->Next;
    }

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Create a family list form the cache file
*   
*   
* Arguments:
*
*   NONE
*
* Returns:
*
*   Boolean indicating the list is created successfully or not
*
* History:
*
*   06/28/20000 YungT [Yung-Jen Tony Tsai]
*       Created it.
*
\**************************************************************************/

BOOL GpFontFamilyList::BuildFamilyListFromCache(BOOL bLoadFromRegistry)
{
    ULONG cachedSize = 0;
    ULONG calcSize = 0;
    FAMILYCACHEENTRY * pCacheEntry;
    
    BYTE * pCached= (BYTE *)FontFileCacheLookUp(&cachedSize);

    // We can not get data from cached file
    if (!cachedSize)
        return FALSE;

    if (bLoadFromRegistry)
    {
        ASSERT(!Globals::IsNt);
        
        ULONG registrySize = 0;

        if (*((ULONG *) pCached) != 0xBFBFBFBF)
            return FALSE;

        registrySize = *((ULONG *) (pCached + 4)) ;

    	cachedSize -= QWORD_ALIGN(registrySize + 8);
    	
        pCached += QWORD_ALIGN(registrySize + 8);
	}
    else
    {
        if (*((ULONG *) pCached) == 0xBFBFBFBF)
            return FALSE;
    }

    
    
    FamilyCacheEntry = (BYTE *) GpMalloc(cachedSize);

    if (!FamilyCacheEntry)
        return FALSE;

    memcpy(FamilyCacheEntry, pCached, cachedSize);
    
    while (calcSize < cachedSize) 
    {
        pCacheEntry = (FAMILYCACHEENTRY *) (FamilyCacheEntry + calcSize);

        GpFontFamily * family = new GpFontFamily(pCacheEntry);

        if (family == NULL)
        {
        // Clean up we have created.
            DeleteList();
            
            WARNING(("Error constructing family from cache."))
            
            return FALSE;
        }

        if (!InsertOrdered(family, FontStyleRegular, (GpFontFile *) NULL, 
                           (GpFontFace *) NULL, FALSE))
        {
            WARNING(("Error constructing family from cache."))

            // New GpFontFamily object not used, delete it
            // Something wrong with this case so we need to delete it.
            delete family;

            DeleteList();
            
            return FALSE;
        }
        
        
        calcSize += QWORD_ALIGN(pCacheEntry->cjThis);
    }

    ASSERT(calcSize == cachedSize);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\family.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Font family
*
* Revision History:
*
*   27/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSFONTFAMILY_H
#define _GDIPLUSFONTFAMILY_H

#define  NumFontFaces  4

#define  PFF_ENUMERABLE     0x1

#include "fontable.hpp"

class GpFontFace;
class FontFamily;

class GpFamilyFallback;

const UINT FamilyNameMax = 32;

typedef struct _FAMILYCACHEENTRY
{
    UINT        cjThis;
// Cache the data from here
    INT         iFont;

// Cache engine supprt
    UINT        cFilePathName[NumFontFaces];

    WCHAR       Name[FamilyNameMax];        // Captialized Family name
    WCHAR       NormalName[FamilyNameMax];  // Family name

//  Alias name
    WCHAR       FamilyAliasName[FamilyNameMax];         // Captialized FamilyAliasName
    WCHAR       NormalFamilyAliasName[FamilyNameMax];   // FamilyAliasName

    BOOL        bAlias;

// Lang ID for Family name and FamilyAliasName

    LANGID      LangID;
    LANGID      AliasLnagID;

    ULARGE_INTEGER  LastWriteTime[NumFontFaces];

// We need to get a charset to let font select into DC
    BYTE        lfCharset;
} FAMILYCACHEENTRY;

struct FallbackFactory
{
    GpStatus            Create(const GpFontFamily *family);
    void                Destroy();
    GpFamilyFallback    *familyfallback;
};


/*********************************Class************************************\
* class GpFontFamily
*
*       Font family consisiting of pointers to the following font styles:
*       (1) regular
*       (2) italic
*       (3) bold
*       (4) bold italic
*
* History:
*
*   27/06/1999 cameronb created it
*
\**************************************************************************/

class GpFontFamily
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagFontFamily : ObjectTagInvalid;
    }

    // This method is here so that we have a virtual function table so
    // that we can add virtual methods in V2 without shifting the position
    // of the Tag value within the data structure.
    virtual VOID DontCallThis()
    {
        DontCallThis();
    }

public:
    GpFontFamily(const WCHAR *name, GpFontFile * fontfile, INT iFont, FAMILYCACHEENTRY * pCacheEntry, GpFontCollection *fontCollection = NULL);

    GpFontFamily(FAMILYCACHEENTRY * pCacheEntry);

    ~GpFontFamily();

    // If the famly came from a different version of GDI+, its tag
    // will not match, and it won't be considered valid.
    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpFontFamily, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagFontFamily) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Font Family");
        }
    #endif

        return (Tag == ObjectTagFontFamily);
    }

// Name has been captialized
    const WCHAR *GetCaptializedName() {return cacheEntry->Name;}

// The original name is not capitalized
    GpStatus GetFamilyName(WCHAR   name[LF_FACESIZE], LANGID  language = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) const;

    void SetFaceAndFile(INT style, GpFontFace *face, GpFontFile * fontfile);

    GpFontFace *GetFace(INT style) const;

    GpFontFace *GetFaceAbsolute(INT style) const;

    BOOL GpFontFamily::IsFileLoaded(BOOL loadFontFile = TRUE) const;

    GpFontFile * GetFontFile(UINT i) { return FontFile[i]; }

    GpFontCollection *GetFontCollection ()
    {
        return associatedFontCollection;
    }

    BOOL FaceExist(INT style) const
    {
        // Return face for the given style - either the direct face
        // or one which can support this style through simulation.

        if (Face[style&3])
        {
            // Distinct font exists
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    GpFamilyFallback *GetFamilyFallback() const
    {
        if (!FamilyFallbackInitialized)
        {
            if (fallback.Create(this) != Ok)
                return NULL;

            FamilyFallbackInitialized = TRUE;
        }

        return  fallback.familyfallback;
    }

    BOOL IsPrivate() const;

    INT     AvailableFaces(void) const;

    BOOL    SupportsLanguage  (INT style, LANGID lang) const;
    BOOL    SupportsCharacters(INT style, WCHAR* str, INT len) const;

    BOOL    IsStyleAvailable             (INT style) const {return GetFace(style) != NULL;}

    UINT16  GetDesignEmHeight            (INT style) const;
    UINT16  GetDesignCellAscent          (INT style) const;
    UINT16  GetDesignCellDescent         (INT style) const;
    UINT16  GetDesignLineSpacing         (INT style) const;
    UINT16  GetDesignUnderscoreSize      (INT style) const;
    INT16   GetDesignUnderscorePosition  (INT style) const;
    UINT16  GetDesignStrikeoutSize       (INT style) const;
    INT16   GetDesignStrikeoutPosition   (INT style) const;


    GpStatus GetFontData(FontStyle style, UINT32 tag, INT* tableSize, BYTE** pjTable);
    void     ReleaseFontData(FontStyle style);

    BOOL    Deletable(); /* the font family can be removed from the font family list */
    BOOL    IncFontFamilyRef(void); /* return false if all the faces are removed */
    void    DecFontFamilyRef(void);

// API support for Family Alias name
    BOOL    IsAliasName() const
    {
        return cacheEntry->bAlias;
    }

    WCHAR * GetAliasName()
    {
        return cacheEntry->bAlias ? cacheEntry->FamilyAliasName : NULL;
    }

    FAMILYCACHEENTRY * GetCacheEntry()
    {
        return cacheEntry;
    }

    VOID ReleaseCacheEntry()
    {

        ASSERT(cacheEntry);

        if (!bLoadFromCache && cacheEntry)
        {
            GpFree(cacheEntry);
            cacheEntry = NULL;
        }
    }

    static GpStatus CreateFontFamilyFromName
                        (const WCHAR *name,
                         GpFontCollection *fontCollection,
                         GpFontFamily **fontFamily);

    static GpStatus GetGenericFontFamilySansSerif
                        (GpFontFamily **nativeFamily);
                         
    static GpStatus GetGenericFontFamilySerif
                        (GpFontFamily **nativeFamily);

    static GpStatus GetGenericFontFamilyMonospace
                        (GpFontFamily **nativeFamily);

// private member function
private:
    BOOL    AreAllFacesRemoved();
    BOOL    WriteToCache();
    BOOL    ReadFromCache();

// private data
private:
    FAMILYCACHEENTRY *  cacheEntry;

// Indicate
    mutable BOOL        bFontFileLoaded;

//  Ref count for FontFamily objects that point to this GpFontFamily
    INT                 cFontFamilyRef;

// GpFontFace
    mutable GpFontFace *Face[NumFontFaces];     // Pointers to instance of each face

// GpFontFile
    mutable GpFontFile *FontFile[NumFontFaces]; // Pointer to font file


    mutable FallbackFactory  fallback;
    mutable BOOL             FamilyFallbackInitialized;
    BOOL                     bLoadFromCache;

    GpFontCollection *  associatedFontCollection; // if NULL, then GpInstalledFontCollection
};


/*********************************Class************************************\
* class GpFontFamilyList
*
*       Handles the enumerated list of font families
*
* History:
*
*   27/06/1999 cameronb created it
*
\**************************************************************************/

class GpFontFamilyList
{
public:

    //  Internal structure for list handling
    struct FamilyNode
    {
        GpFontFamily   *Item;
        FamilyNode     *Prev;
        FamilyNode     *Next;

        FamilyNode(GpFontFamily *family=NULL)
        {
            Item = family;
            Prev = NULL;
            Next = NULL;
        }

    };

public:
    GpFontFamilyList();
    ~GpFontFamilyList();

private:
    void    DeleteList(void);

public:
    INT     Enumerable(GpGraphics* graphics = 0) const;
    Status  Enumerate(INT numSought, GpFontFamily * gpfamilies[], INT& numFound,
                        GpGraphics * graphics = 0) const;

    GpFontFamily* GetFamily(const WCHAR *familyName) const;
    GpFontFamily* GetAnyFamily() const;

    BOOL    AddFont(GpFontFile* fontFile, GpFontCollection *fontCollection);
    BOOL    RemoveFontFamily(GpFontFamily* fontFamily);
    VOID    UpdateFamilyListToCache(BOOL bLoadFromRegistry, HKEY hkey, ULONG registrySize, ULONG numExpected);
    BOOL    BuildFamilyListFromCache(BOOL bLoadFromRegistry);

private:
    BOOL    InsertOrdered(GpFontFamily * family, FontStyle style, GpFontFile * fontfile,
                            GpFontFace * face, BOOL bSetFace);

//      Data members
private:
    FamilyNode*  Head;   //  The enumerated list
    BYTE * FamilyCacheEntry;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\filetime.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   FileTime.hpp
*
* Abstract:
*
*   Declare the CFILETIME class.  This class wraps the FILETIME
*   structure, and gives it operators and conversion functions
*   (type-cast operators) to make it usable in equations.
*   This class adds no state, so a CFILETIME object is bitwise
*   compatible with a FILETIME object.
*
*   This class is completely inline.  There is no implementation
*   file.
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#ifndef _FILETIME_HPP
#define _FILETIME_HPP

#include <tchar.h>  // _tcsftime


class CFILETIME         // cft
{
    //  ------------
    //  Construction
    //  ------------

public:

    CFILETIME()
    {
        SetToUTC();
    }

    CFILETIME( const CFILETIME &cft )
    {
        _ll = cft._ll;
    }

    CFILETIME( const SYSTEMTIME &st )
    {
        SystemTimeToFileTime( &st, &_filetime );
    }

    CFILETIME( const FILETIME &ft )
    {
        _ll = *(LONGLONG*) &ft;
    }

    CFILETIME( const LONGLONG ll )
    {
        _ll = ll;
    }

    CFILETIME( const LARGE_INTEGER &li )
    {
        _li = li;
    }

    CFILETIME( const ULARGE_INTEGER &uli )
    {
        _uli = uli;
    }


    //  --------------------
    //  Conversion Functions
    //  --------------------

public:

    // Convert to a struct _FILETIME
    operator FILETIME () const
    {
        return( _filetime );
    }

    // Convert to a SYSTEMTIME (fails if the current _filetime)
    // is greater than 0x80000000
    operator SYSTEMTIME () const
    {
        SYSTEMTIME st;
        if( !FileTimeToSystemTime( &_filetime, &st ))
        {
            // The current _filetime is negative.
            memset( &st, 0, sizeof(st) );
        }

        return( st );
    }

    operator LARGE_INTEGER () const
    {
        return( _li );
    }

    operator LONGLONG () const
    {
        return( _ll );
    }

    operator ULARGE_INTEGER () const
    {
        return( _uli );
    }

    //  ---------
    //  Operators
    //  ---------

public:

    // Assignment

    CFILETIME &operator= (const CFILETIME &cft)
    {
        _filetime = cft._filetime;
        return (*this);
    }

    // Addition of an offset

    CFILETIME operator+ ( CFILETIME &cft ) const
    {
        return (CFILETIME) ( _ll + cft._ll );
    }
    CFILETIME &operator+= ( CFILETIME &cft )
    {
        _ll += cft._ll;
        return( *this );
    }

    // Subtraction of an offset (note that this can result in a negative
    // number).

    CFILETIME operator- ( CFILETIME &cft ) const
    {
        return (CFILETIME) ( _ll - cft._ll );
    }
    CFILETIME &operator-= ( CFILETIME &cft )
    {
        _ll -= cft._ll;
        return( *this );
    }

    // Comparisson

    BOOL operator== ( const CFILETIME &cft ) const
    {
        return( cft._ll == _ll );
    }

    BOOL operator> ( const CFILETIME &cft ) const
    {
        return( _ll > cft._ll );
    }

    BOOL operator< ( const CFILETIME &cft ) const
    {
        return( _ll < cft._ll );
    }

    BOOL operator>= ( const CFILETIME &cft ) const
    {
        return( *this == cft || *this > cft );
    }

    BOOL operator<= ( const CFILETIME &cft ) const
    {
        return( *this == cft || *this < cft );
    }



    //  -------
    //  Methods
    //  -------

public:

    void IncrementTickCount( DWORD dwTickCount )
    {
        // Add the tick count offset, converted from milliseconds
        // to 100 nanosecond units

        _ll += (LONGLONG) dwTickCount * 10*1000;
    }

    void DecrementTickCount( DWORD dwTickCount )
    {
        _ll -= (LONGLONG) dwTickCount * 10*1000;
    }

    void IncrementSeconds( DWORD dwSeconds )
    {
        _ll += (LONGLONG) dwSeconds * 10*1000*1000;
    }

    void DecrementSeconds( DWORD dwSeconds )
    {
        _ll -= (LONGLONG) dwSeconds * 10*1000*1000;
    }

    void IncrementMilliseconds( DWORD dwMilliseconds )
    {
        _ll += (LONGLONG) dwMilliseconds * 10*1000;
    }

    void DecrementMilliseconds( DWORD dwMilliseconds )
    {
        _ll -= (LONGLONG) dwMilliseconds * 10*1000;
    }

    void SetToUTC()
    {
        SYSTEMTIME st;
        GetSystemTime( &st );
        SystemTimeToFileTime( &st, (FILETIME*) this );
    }

    void SetToLocal()
    {
        SYSTEMTIME st;
        GetLocalTime( &st );
        SystemTimeToFileTime( &st, (FILETIME*) this );
    }

    // Convert from UTC to Local.  A time of zero, though, converts to zero.
    CFILETIME ConvertUtcToLocal() const
    {
        CFILETIME cftLocal(0);

        if( cftLocal == *this
            ||
            !FileTimeToLocalFileTime( &_filetime, reinterpret_cast<FILETIME*>(&cftLocal) ))
        {
            cftLocal = 0;
        }

        return( cftLocal );
    }

    DWORD HighDateTime() const
    {
        return( _filetime.dwHighDateTime );
    }

    DWORD LowDateTime() const
    {
        return( _filetime.dwLowDateTime );
    }

    // Format the time to a string using a strftime format string.
    // The time is not converted to local or wrt daylight savings
    // Cannot handle times before 1/1/1900.
    void Format( ULONG cch, TCHAR *ptszResult, const TCHAR *ptszFormat ) const
    {
        struct tm tm;
        SYSTEMTIME st = static_cast<SYSTEMTIME>(*this);

        memset( &tm, 0, sizeof(tm) );
        tm.tm_sec   = st.wSecond;
        tm.tm_min   = st.wMinute;
        tm.tm_hour  = st.wHour;
        tm.tm_mday  = st.wDay;
        tm.tm_mon   = st.wMonth - 1;        // tm_mon is 0 based
        tm.tm_year  = st.wYear - 1900;      // tm_year is 1900 based
        tm.tm_isdst = 0;                    // This method does no time zone conversion
        tm.tm_wday  = st.wDayOfWeek;

        if( 0 == _tcsftime( ptszResult, cch, ptszFormat, &tm ))
            ptszResult[0] = TEXT('\0');
    }

    // Default string-ization
    void Stringize( ULONG cch, TCHAR *ptsz ) const
    {
        // E.g. "Sunday, 3/22/98, 13:30:22"
        Format( cch, ptsz, TEXT("%a, %m/%d/%y, %H:%M:%S") );
    }


    //  ------------
    //  Data Members
    //  ------------

private:

    union
    {
        FILETIME _filetime;
        LONGLONG _ll;
        LARGE_INTEGER _li;
        ULARGE_INTEGER _uli;
    };

};

#endif // #ifndef _FILETIME_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontable.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Font table and font loading operations
*
* Revision History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

#ifndef GP_FONT_TABLE_DEFINED
#define GP_FONT_TABLE_DEFINED

class GpFontFile;
class GpFontFamily;
class GpFontFamilyList;
class FontFamily;

/*********************************Class************************************\
* class GpFontTable
*
*	Font table for GpFontFile objects
*
* History:
*   11/12/99 YungT modify it.
*   23/06/1999 cameronb created it
*
\**************************************************************************/

class GpFontTable
{
public:
    GpFontTable();
    ~GpFontTable();

    BOOL IsValid()   
    { 
        return (Table && EnumList); 
    }
    
    BOOL UnloadFontFiles(GpFontFile* fontFile);
    
    GpStatus AddFontFile(const WCHAR* fileName, GpFontCollection *fontCollection);
    GpFontFile * AddFontFile(WCHAR* fileName);
                            
    GpStatus AddFontMemImage(const BYTE* fontMemoryImage, INT   fontImageSize,
                              GpFontCollection *fontCollection);
                                    
    GpStatus RemoveFontFile(const WCHAR* filename);

    GpFontFamily* GetFontFamily(const WCHAR* familyName);
    GpFontFamily* GetAnyFamily();

    INT EnumerableFonts(GpGraphics* graphics = 0);
    
    GpStatus EnumerateFonts(INT numSought, GpFontFamily* gpfamilies[],
                               INT& numFound, GpGraphics* graphics = 0);
    
    void LoadAllFonts(const WCHAR *familyName = NULL); 

    GpFontFile* GetFontFile(const WCHAR* fileName) const;

    UINT GetNumFilesLoaded(void) const
    { 
        return NumFilesLoaded; 
    }
    
    BOOL IsPrivate()
    {
        return bPrivate;
    }
    
    void SetPrivate(BOOL bTable) 
    { 
        bPrivate = bTable;
    }

    BOOL IsFontLoaded()
    {
        return bFontFilesLoaded;
    }
    
    void SetFontFileLoaded(BOOL bLoaded) 
    { 
        bFontFilesLoaded = bLoaded;
    }
   
private:    
    UINT        HashIt(const WCHAR* str) const;

    GpFontFile* GetFontFile(const WCHAR* fileName, UINT hash) const;
    void        LoadAllFontsFromRegistry(BOOL bLoadFromRegistry);
    void        LoadAllFontsFromCache(BOOL bLoadFromRegistry);
    void        UpdateCacheFileFromFontTable(void);

public:
    static  ULONG MemImageUnique;

//	Data members
private:
    UINT                NumFilesLoaded;         // Number of files loaded into Table
    UINT                NumHashEntries;         // Number of possible hash entries
    GpFontFile**        Table;                  // The table
    GpFontFamilyList*   EnumList;               // Sorted enumeration list
    BOOL                bPrivate;               // indicate the files in table are private or public
    BOOL                bFontFilesLoaded;       // indicacte the font file loaded    
};


inline ULONG GetNewMemImageUniqueness(ULONG &ulUnique)
{
    InterlockedIncrement((LPLONG)&ulUnique);
    return ulUnique;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontcollection.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   fontcollection.cpp
*
* Revision History:
*
*   03/06/00 DChinn
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


INT
GpFontCollection::GetFamilyCount()
{
    if (!FontTable->IsPrivate() && !FontTable->IsFontLoaded())
        FontTable->LoadAllFonts();

    return FontTable->EnumerableFonts();
}


GpStatus
GpFontCollection::GetFamilies(
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
    )
{
    if (!FontTable->IsPrivate() && !FontTable->IsFontLoaded())
        FontTable->LoadAllFonts();
    return FontTable->EnumerateFonts(numSought, gpfamilies, *numFound);
}

GpInstalledFontCollection::GpInstalledFontCollection()
{
    FontTable = new GpFontTable;

    if (FontTable != NULL)
    {
        /* verify if we were running out of memory during the creation */
        if (!FontTable->IsValid())
        {
            delete FontTable;
            FontTable = NULL;
        }
        else
        {
            FontTable->SetPrivate(FALSE);
        }
    }
}

GpInstalledFontCollection::~GpInstalledFontCollection()
{
    delete FontTable;
    instance = NULL;
}

// definition of static data member of the singleton class GpInstalledFontCollection
GpInstalledFontCollection* GpInstalledFontCollection::instance = NULL;

GpInstalledFontCollection* GpInstalledFontCollection::GetGpInstalledFontCollection()
{
    if (instance == NULL)
    {
        instance = new GpInstalledFontCollection;

        /* verify if there was any memory error during the creation */
        if (instance != NULL) 
        {
            if (instance->FontTable == NULL)
            {
                 delete instance;
                instance = NULL;
            }
        }
    }
    return instance;
}


GpStatus
GpInstalledFontCollection::InstallFontFile(const WCHAR *filename)
{
    return (FontTable->AddFontFile(filename, this));
}

GpStatus
GpInstalledFontCollection::UninstallFontFile(const WCHAR *filename)
{
    return (FontTable->RemoveFontFile(filename));
}


GpPrivateFontCollection::GpPrivateFontCollection()
{
    FontTable = new GpFontTable;
    if (FontTable != NULL)
    {
        /* verify if we were running out of memory during the creation */
        if (!FontTable->IsValid())
        {
            delete FontTable;
            FontTable = NULL;
        }
        else
        {
            FontTable->SetPrivate(TRUE);
            FontTable->SetFontFileLoaded(TRUE);
        }
    }
}

GpPrivateFontCollection::~GpPrivateFontCollection()
{
    delete FontTable;
}

GpStatus
GpPrivateFontCollection::AddFontFile(const WCHAR* filename)
{
    return (FontTable->AddFontFile(filename, this));
}

GpStatus
GpPrivateFontCollection::AddMemoryFont(const VOID *memory, INT length)
{
    return (FontTable->AddFontMemImage(static_cast<const BYTE *>(memory),
                                       length,
                                       this));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\font.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   font.hpp
*
* Abstract:
*
*   Font and text related header file
*
* Revision History:
*
*   05/05/1999 ikkof
*       Added more constructors.
*
*   12/94/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _FONT_HPP
#define _FONT_HPP

//
// Represent a font object
//
// !!!
//  In the current version, we'll continue to use the existing
//  WFC font related classes. In the managed interface layer,
//  we can extract an HFONT out of the WFC Font object. Internally,
//  we'll use GpFont, which is just an HFONT.
//

class GpFont : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagFont : ObjectTagInvalid);
    }

public:

    GpFont() // used by object factory
    {
        SetValid(TRUE);     // default is valid
    }
    GpFont(HDC hdc);
    GpFont(HDC hdc, LOGFONTW *logfont);
    GpFont(HDC hdc, LOGFONTA *logfont);

    GpFont(const GpFont &font)
    {
        Family   = font.Family;
        EmSize   = font.EmSize;
        Style    = font.Style;
        SizeUnit = font.SizeUnit;

        SetValid(TRUE);     // default is valid
    }

    GpFont(
        REAL                 size,
        const GpFontFamily  *family,
        INT                  style  = FontStyleRegular,
        Unit                 unit   = UnitPoint
    ) ;

    ~GpFont()
    {
    }

    GpFont* Clone() const
    {
        return new GpFont(*this);
    }

    GpStatus    GetLogFontA(GpGraphics * g, LOGFONTA * lfA);
    GpStatus    GetLogFontW(GpGraphics * g, LOGFONTW * lfW);

    BOOL IsValid() const
    {
        // If the font came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((Family != NULL) && GpObject::IsValid(ObjectTagFont));
    }

    const GpFontFamily *GetFamily() const {return Family;}

    REAL                GetEmSize()            const {return EmSize;}
    GpStatus            SetEmSize(REAL size)         {EmSize = size;    UpdateUid(); return Ok;}

    INT                 GetStyle()             const {return Style;}
    GpStatus            SetStyle(INT newStyle)       {Style=newStyle;   UpdateUid(); return Ok;}

    Unit                GetUnit()              const {return SizeUnit;}
    GpStatus            SetUnit(Unit newUnit)        {SizeUnit=newUnit; UpdateUid(); return Ok;}

    GpFontFace *GetFace() const
    {
        return Family ? Family->GetFace(Style) : NULL;
    }

    GpStatus GetHeight(REAL dpi, REAL *height) const;
    GpStatus GetHeight(const GpGraphics *graphics, REAL *height) const;
    GpStatus GetHeightAtWorldEmSize(REAL worldEmSize, REAL *height) const;

    UINT16  GetDesignEmHeight()           const {return GetFace()->GetDesignEmHeight();}
    UINT16  GetDesignCellAscent()         const {return GetFace()->GetDesignCellAscent();}
    UINT16  GetDesignCellDescent()        const {return GetFace()->GetDesignCellDescent();}
    UINT16  GetDesignLineSpacing()        const {return GetFace()->GetDesignLineSpacing();}
    UINT16  GetDesignUnderscoreSize()     const {return GetFace()->GetDesignUnderscoreSize();}
    INT16   GetDesignUnderscorePosition() const {return GetFace()->GetDesignUnderscorePosition();}
    UINT16  GetDesignStrikeoutSize()      const {return GetFace()->GetDesignStrikeoutSize();}
    INT16   GetDesignStrikeoutPosition()  const {return GetFace()->GetDesignStrikeoutPosition();}


    virtual ObjectType GetObjectType() const { return ObjectTypeFont; }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

private:

    VOID InitializeFromDc(HDC hdc);

    const GpFontFamily  *Family;
    REAL                 EmSize;
    INT                  Style;
    Unit                 SizeUnit;
};


class GpGlyphPath : public _PATHOBJ
{
public:

    BOOL      hasBezier;
    INT       pointCount;
    GpPointF *points;
    BYTE     *types;

    GpGlyphPath() {};
    ~GpGlyphPath() {};

    BOOL IsValid() const   { return (pointCount ? (points && types) : TRUE); }
    BOOL IsEmpty() const   { return (pointCount ? FALSE : TRUE); }

    GpStatus
    CopyPath(GpPath *path);
};


#endif // !_FONT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\font.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   font.cpp
*
* Revision History:
*
*   Aug/12/1999 Xudong Wu [tessiew]
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

const DOUBLE PI = 3.1415926535897932384626433832795;

#if DBG
#include <mmsystem.h>
#endif

//
//  Masks for supported code pages in the font
//

#define Latine1CodePageMask                     0x0000000000000001
#define Latine2CodePageMask                     0x0000000000000002
#define CyrillicCodePageMask                    0x0000000000000004
#define GreekCodePageMask                       0x0000000000000008
#define TurkishCodePageMask                     0x0000000000000010
#define HebrewCodePageMask                      0x0000000000000020
#define ArabicCodePageMask                      0x0000000000000040
#define BalticCodePageMask                      0x0000000000000080
#define Reserved1CodePageMask                   0x000000000000FF00
#define ThaiCodePageMask                        0x0000000000010000
#define JapanCodePageMask                       0x0000000000020000
#define ChineseCodePageMask                     0x0000000000040000
#define KoreanCodePageMask                      0x0000000000080000
#define TraditionalChineseCodePageMask          0x0000000000100000
#define KoreanJohabCodePageMask                 0x0000000000200000
#define Reserved2CodePageMask                   0x000000001FC00000
#define MacintoshPageMask                       0x0000000020000000
#define OEMCodePageMask                         0x0000000040000000
#define SymbolCodePageMask                      0x0000000080000000
#define Reserved3CodePageMask                   0x0000FFFF00000000
#define IBMGreekCodePageMask                    0x0001000000000000
#define RussianMsDosCodePageMask                0x0002000000000000
#define NordicCodePageMask                      0x0004000000000000
#define ArabicMsDosCodePageMask                 0x0008000000000000
#define CanandianMsDosCodePageMask              0x0010000000000000
#define HebrewMsDosCodePageMask                 0x0020000000000000
#define IcelandicMsDosCodePageMask              0x0040000000000000
#define PortugueseMsDosCodePageMask             0x0080000000000000
#define IBMTurkishCodePageMask                  0x0100000000000000
#define IBMCyrillicCodePageMask                 0x0200000000000000
#define Latin2MsDosCodePageMask                 0x0400000000000000
#define BalticMsDosCodePageMask                 0x0800000000000000
#define Greek437CodePageMask                    0x1000000000000000
#define ArabicAsmoCodePageMask                  0x2000000000000000
#define WeLatinCodePageMask                     0x4000000000000000
#define USCodePageMask                          0x8000000000000000


/////   Create fonts from DC and optional ANSI or Unicode logfont
//
//

GpFont::GpFont(
    REAL                 size,
    const GpFontFamily  *family,
    INT                  style,
    Unit                 unit
) :
        Family   (family),
        EmSize   (size),
        Style    (style),
        SizeUnit (unit)
{
    SetValid(TRUE);     // default is valid

    if (!(Family && Family->IsFileLoaded()))
        Family = NULL;
}

GpFont::GpFont(
    HDC hdc
)
{
    SetValid(TRUE);     // default is valid

    // intialize it as invalid
    Family = NULL;
    InitializeFromDc(hdc);
}



GpFont::GpFont(
    HDC       hdc,
    LOGFONTW *logfont
)
{
    SetValid(TRUE);     // default is valid

    HFONT hOldFont = NULL;
    // intialize it as invalid
    Family = NULL;

    if (!hdc)
        return;

    HFONT hFont = CreateFontIndirectW(logfont);

    if (!hFont) return;

    hOldFont = (HFONT) SelectObject(hdc, hFont);

    InitializeFromDc(hdc);

    if (!hOldFont)
        return;

    DeleteObject(SelectObject(hdc, hOldFont));
}


GpFont::GpFont(
    HDC       hdc,
    LOGFONTA *logfont
)
{
    SetValid(TRUE);     // default is valid

    HFONT hOldFont = NULL;
    // intialize it as invalid
    Family = NULL;

    if (!hdc)
        return;

    HFONT hFont = CreateFontIndirectA(logfont);

    if (!hFont)
        return;

    hOldFont = (HFONT) SelectObject(hdc, hFont);

    InitializeFromDc(hdc);

    if (!hOldFont)
        return;

    DeleteObject(SelectObject(hdc, hOldFont));
}


VOID GpFont::InitializeFromDc(
    HDC hdc
)
{
    WCHAR faceName[LF_FACESIZE];
    GpFontTable *fontTable;

    fontTable = (GpInstalledFontCollection::GetGpInstalledFontCollection())->GetFontTable();

    if (!fontTable->IsValid())
        return;

    if (!fontTable->IsPrivate() && !fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    if (Globals::IsNt) {
        TEXTMETRICW tmw;

        if (!GetTextMetricsW(hdc, &tmw)) {
            return;
        }

        GetTextFaceW(hdc, LF_FACESIZE, faceName);

        EmSize = REAL(tmw.tmHeight-tmw.tmInternalLeading);

        Style = FontStyleRegular;
        if (tmw.tmWeight > 400)  {Style |= FontStyleBold;}
        if (tmw.tmItalic)        {Style |= FontStyleItalic;}
        if (tmw.tmUnderlined)    {Style |= FontStyleUnderline;}
        if (tmw.tmStruckOut)     {Style |= FontStyleStrikeout;}
    }
    else
    {
        TEXTMETRICA tma;

        if (!GetTextMetricsA(hdc, &tma)) {
            return;
        }

        char faceNameA[LF_FACESIZE];
        GetTextFaceA(hdc, LF_FACESIZE, faceNameA);
        AnsiToUnicodeStr(faceNameA, faceName, LF_FACESIZE);

        EmSize = REAL(tma.tmHeight-tma.tmInternalLeading);

        Style = FontStyleRegular;
        if (tma.tmWeight > 400)  {Style |= FontStyleBold;}
        if (tma.tmItalic)        {Style |= FontStyleItalic;}
        if (tma.tmUnderlined)    {Style |= FontStyleUnderline;}
        if (tma.tmStruckOut)     {Style |= FontStyleStrikeout;}
    }

    if (faceName[0] == L'@')
        UnicodeStringCopy(&faceName[0], &faceName[1]);


    Family = fontTable->GetFontFamily(faceName);

    if (Family == NULL)
    {
        GetFamilySubstitution(faceName, (GpFontFamily **) &Family);
    }

    if (!(Family && Family->IsFileLoaded()))
        Family = NULL;

    SizeUnit = UnitWorld;
}



GpStatus GpFont::GetLogFontA(
    GpGraphics * g,
    LOGFONTA * lfa
)
{
    PointF   scale;
    REAL     rotateRadians;
    REAL     shear;
    PointF   translate;
    GpMatrix worldToDevice;

    g->GetWorldToDeviceTransform(&worldToDevice);


    SplitTransform(
        worldToDevice,
        scale,
        rotateRadians,
        shear,
        translate);

    INT rotateDeciDegrees = 3600 - (INT) (rotateRadians * 1800 / PI);

    if (rotateDeciDegrees == 3600)
        rotateDeciDegrees = 0;

    REAL emHeight = EmSize * scale.Y * g->GetScaleForAlternatePageUnit(SizeUnit);

    lfa->lfHeight = -GpRound(emHeight);
    lfa->lfWidth = 0;
    lfa->lfEscapement = rotateDeciDegrees;
    lfa->lfOrientation = rotateDeciDegrees;
    lfa->lfWeight = Style & FontStyleBold   ? 700 : 400;
    lfa->lfItalic = Style & FontStyleItalic ? 1 : 0;
    lfa->lfUnderline = Style & FontStyleUnderline ? 1 : 0;
    lfa->lfStrikeOut = Style & FontStyleStrikeout ? 1 : 0;
    lfa->lfCharSet = (((GpFontFamily *)Family)->GetFace(Style))->GetCharset(g->GetHdc());
    lfa->lfOutPrecision = 0;
    lfa->lfClipPrecision = 0;
    lfa->lfQuality = 0;
    lfa->lfPitchAndFamily = 0;


    UnicodeToAnsiStr((WCHAR*)( (BYTE*)(((GpFontFamily *)Family)->GetFace(Style))->pifi +
                                (((GpFontFamily *)Family)->GetFace(Style))->pifi->dpwszFamilyName),
                               lfa->lfFaceName, LF_FACESIZE);

    // Do we need to have a scale value for width????
    // We still need to think about it.


    return Ok;
}

GpStatus GpFont::GetLogFontW(
    GpGraphics * g,
    LOGFONTW * lfw)
{
    PointF   scale;
    REAL     rotateRadians;
    REAL     shear;
    PointF   translate;
    GpMatrix worldToDevice;

    g->GetWorldToDeviceTransform(&worldToDevice);

    SplitTransform(
        worldToDevice,
        scale,
        rotateRadians,
        shear,
        translate);

    INT rotateDeciDegrees = 3600 - (INT) (rotateRadians * 1800 / PI);

    if (rotateDeciDegrees == 3600)
        rotateDeciDegrees = 0;

    REAL emHeight = EmSize * scale.Y * g->GetScaleForAlternatePageUnit(SizeUnit);

    lfw->lfHeight = -GpRound(emHeight);
    lfw->lfWidth = 0;
    lfw->lfEscapement = rotateDeciDegrees;
    lfw->lfOrientation = rotateDeciDegrees;
    lfw->lfWeight = Style & FontStyleBold   ? 700 : 400;
    lfw->lfItalic = Style & FontStyleItalic ? 1 : 0;
    lfw->lfUnderline = Style & FontStyleUnderline ? 1 : 0;
    lfw->lfStrikeOut = Style & FontStyleStrikeout ? 1 : 0;

    ASSERT(((GpFontFamily *)Family)->GetFace(Style));
    lfw->lfCharSet = (((GpFontFamily *)Family)->GetFace(Style))->GetCharset(g->GetHdc());

    lfw->lfOutPrecision = 0;
    lfw->lfClipPrecision = 0;
    lfw->lfQuality = 0;
    lfw->lfPitchAndFamily = 0;


    memcpy(lfw->lfFaceName, (WCHAR*)( (BYTE*)(((GpFontFamily *)Family)->GetFace(Style))->pifi +
                            (((GpFontFamily *)Family)->GetFace(Style))->pifi->dpwszFamilyName),
           sizeof(lfw->lfFaceName));


    return Ok;
}

/**************************************************************************\
*
*
* Revision History:
*
*   02/11/1999 YungT
*       Created it.
*
\**************************************************************************/

int CALLBACK GpFontFace::EnumFontFamExProcW(
  const ENUMLOGFONTEXW   *lpelfe,    // pointer to logical-font data
  const NEWTEXTMETRICEXW *lpntme,    // pointer to physical-font data
  int                     FontType,  // type of font
  LPARAM                  lParam     // application-defined data
)
{
    if (FontType == TRUETYPE_FONTTYPE)
    {
        (*(BYTE *) lParam) = lpelfe->elfLogFont.lfCharSet;

        return 0;
    }
    else
    {
        return 1;   // Don't stop!
    }
}


/**************************************************************************\
*
*
* Revision History:
*
*   02/11/1999 YungT
*       Created it.
*
\**************************************************************************/

int CALLBACK GpFontFace::EnumFontFamExProcA(
  const ENUMLOGFONTEXA   *lpelfe,    // pointer to logical-font data
  const NEWTEXTMETRICEXA *lpntme,    // pointer to physical-font data
  int                     FontType,  // type of font
  LPARAM                  lParam     // application-defined data
)
{
    if (FontType == TRUETYPE_FONTTYPE)
    {
        (*(BYTE *) lParam) = lpelfe->elfLogFont.lfCharSet;

        return 0;
    }
    else
    {
        return 1;   // Don't stop!
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Get the charset from GDI
*
* Arguments:
*
*   We need it for we need to select a logfont into DC. Or
*   Convert a GpFont to LOGFONT
*
* Returns:
*
*       BYTE value of charset
*
* History:
*
*   02/11/2000 YungT
*       Created it.
*
\**************************************************************************/

BYTE GpFontFace::GetCharset(HDC hDc) const
{
    if (lfCharset == DEFAULT_CHARSET)
    {
        if (Globals::IsNt) {

            LOGFONTW lfw = {
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                DEFAULT_CHARSET,       // charset
                0,
                0,
                0,
                0,
                L""
            };

            memcpy(lfw.lfFaceName, (WCHAR*)( (BYTE*)pifi + pifi->dpwszFamilyName),
                    sizeof(lfw.lfFaceName));

            EnumFontFamiliesExW(hDc, &lfw, (FONTENUMPROCW) EnumFontFamExProcW, (LPARAM) &lfCharset, 0);
        }
        else
        {
            // ANSI version for Win9X

            LOGFONTA lfa = {
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                DEFAULT_CHARSET,       // charset
                0,
                0,
                0,
                0,
                ""
            };

            UnicodeToAnsiStr((WCHAR*)( (BYTE*)pifi + pifi->dpwszFamilyName),
                                        lfa.lfFaceName, LF_FACESIZE);

            EnumFontFamiliesExA(hDc, &lfa, (FONTENUMPROCA) EnumFontFamExProcA, (LPARAM) &lfCharset, 0);
        }
    }

    return lfCharset;
}

/////   InitializeImagerTables
//
//      Load character to glyph map and design advance widths

static inline
UINT16 byteSwapUINT16(UINT16 u)
{
    return    ((u & 0x00FF) << 8)
           |  ((u & 0xFF00) >> 8);
}


#pragma pack(push, 1)

struct HheaTable {

    // NOTE: all fields are stored in Big Endian (Motorola) ordering

    UINT32 version;                 // Table version number 0x00010000 for version 1.0.
    INT16  Ascender;                // Typographic ascent.
    INT16  Descender;               // Typographic descent.
    INT16  LineGap;                 // Typographic line gap. Negative LineGap values are
                                    // treated as zero in Windows 3.1, System 6, and System 7.
    UINT16 advanceWidthMax;         // Maximum advance width value in 'hmtx' table.
    INT16  minLeftSideBearing;      // Minimum left sidebearing value in 'hmtx' table.
    INT16  minRightSideBearing;     // Minimum right sidebearing value; calculated as Min(aw - lsb - (xMax - xMin)).
    INT16  xMaxExtent;              // Max(lsb + (xMax - xMin)).
    INT16  caretSlopeRise;          // Used to calculate the slope of the cursor (rise/run); 1 for vertical.
    INT16  caretSlopeRun;           // 0 for vertical.
    INT16  reserved1;               // set to 0
    INT16  reserved2;               // set to 0
    INT16  reserved3;               // set to 0
    INT16  reserved4;               // set to 0
    INT16  reserved5;               // set to 0
    INT16  metricDataFormat;        // 0 for current format.
    UINT16 numberOfHMetrics;        // Number of hMetric entries in 'hmtx' table; must be equal to the CharStrings INDEX count in the 'CFF ' table.
};

struct VheaTable {

    // NOTE: all fields are stored in Big Endian (Motorola) ordering

    UINT32 version;             // Version number of the vertical header table (0x00010000 for the initial version).
    INT16  ascent;              // Distance in FUnits from the centerline to the previous line's descent.
    INT16  descent;             // Distance in FUnits from the centerline to the next line's ascent.
    INT16  lineGap;             // Reserved; set to 0
    INT16  advanceHeightMax;    // The maximum advance height measurement -in FUnits found in the font.
                                // This value must be consistent with the entries in the vertical metrics table.
    INT16  minTop;              // SideBearing The minimum top sidebearing measurement found in the font, in FUnits.
                                // This value must be consistent with the entries in the vertical metrics table.
    INT16  minBottom;           // SideBearing The minimum bottom sidebearing measurement found in the font, in FUnits.
                                // This value must be consistent with the entries in the vertical metrics table.
    INT16  yMaxExtent;          // Defined as yMaxExtent=minTopSideBearing+(yMax-yMin)
    INT16  caretSlopeRise;      // The value of the caretSlopeRise field divided by the value of the caretSlopeRun Field
                                // determines the slope of the caret. A value of 0 for the rise and a value of 1 for the
                                // run specifies a horizontal caret. A value of 1 for the rise and a value of 0 for the
                                // run specifies a vertical caret. Intermediate values are desirable for fonts whose
                                // glyphs are oblique or italic. For a vertical font, a horizontal caret is best.
    INT16  caretSlopeRun;       // See the caretSlopeRise field. Value=1 for nonslanted vertical fonts.
    INT16  caretOffset;         // The amount by which the highlight on a slanted glyph needs to be shifted away from
                                // the glyph in order to produce the best appearance. Set value equal to 0 for nonslanted fonts.
    INT16  reserved1;           // Set to 0.
    INT16  reserved2;           // Set to 0.
    INT16  reserved3;           // Set to 0.
    INT16  reserved4;           // Set to 0.
    INT16  metricDataFormat;    // Set to 0.
    UINT16 numOfLongVerMetrics; // Number of advance heights in the vertical metrics table; must be equal to the
                                // CharStrings INDEX count field in the 'CFF ' table.
};

#pragma pack(pop)


GpStatus GpFontFace::GetFontData(UINT32 tag, INT* tableSize, BYTE** pjTable) const
{
    GpStatus status = Ok;
    ULONG  cjTable;

    if (ttfdSemGetTrueTypeTable (pff->hff, iFont, tag, pjTable, &cjTable) == FD_ERROR)
    {
        return GenericError;
    }
    *tableSize = cjTable;

    return status;
}


void GpFontFace::ReleaseFontData() const
{
    ttfdSemReleaseTrueTypeTable (pff->hff);
}



/////   GetGlyphDesignAdvances
//
//      Returns advance widths along or perpendicular to baseline in
//      font design units.


void GpFontFace::GetGlyphDesignAdvances(
    const UINT16  *glyphs,     // In
    INT            glyphCount, // In
    INT            style,      // In  - causes adjustment for algorithmic style emulation
    BOOL           vertical,   // In  - Use vmtx, not hmtx
    REAL           tracking,   // In  - expansion factor
    UINT16        *advances    // Out
) const
{
    if (vertical)
    {
        if (DesignVerticalAdvance)
        {
            DesignVerticalAdvance->Lookup(glyphs, glyphCount, advances);
        }
        else
        {
            // There's no vmtx - fallback appropriately

            // Win 9x uses the typographic height (typo ascender - typo descender),
            // but NT uses the cell height (cell ascender + cell descender).

            // Which shall we use? The problem with the cell height is that in a
            // multilingual font it may be much taller than the Far East glyphs,
            // causing the common case (Far East vertical text) to appear too
            // widely spaced. The problem with the typographic height is that it
            // includes little or no extra space for diacritic marks.

            // Choice: use the Typographic height: It is best for FE, and the font
            // can fix non FE diacritic cases if it wishes by providing a vmtx.

            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = pifi->fwdTypoAscender - pifi->fwdTypoDescender;
            }

        }
    }
    else
    {
        DesignAdvance->Lookup(glyphs, glyphCount, advances);

        if (    (style & FontStyleBold)
            &&  !(GetFaceStyle() & FontStyleBold))
        {
            // Algorithmic emboldening increases glyph width

            UINT16 extraAdvance = ((pifi->fwdUnitsPerEm * 2 - 1) / 100);

            for (INT i=0; i<glyphCount; i++)
            {
                if (advances[i] != 0)
                {
                    advances[i] += extraAdvance;
                }
            }
        }

        if (tracking != 1.0)
        {
            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = static_cast<UINT16>(GpRound(advances[i] * tracking));
            }
        }
    }
}



/////   GetGlyphDesignAdvancesIdeal
//
//      Returns advance widths along or perpendicular to baseline scaled to
//      ideal units.


void GpFontFace::GetGlyphDesignAdvancesIdeal(
    const UINT16  *glyphs,        // In
    INT            glyphCount,    // In
    INT            style,         // In  - Causes adjustment for algorithmic style emulation
    BOOL           vertical,      // In  - Use vtmx, not htmx
    REAL           designToIdeal, // In  - Scale factor for each advance width
    REAL           tracking,      // In  - Expansion factor
    INT           *advances       // Out
) const
{
    if (vertical)
    {
        if (DesignVerticalAdvance)
        {
            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = GpRound(TOREAL(DesignVerticalAdvance->Lookup(glyphs[i]) * designToIdeal));
            }
        }
        else
        {
            INT commonVerticalAdvance = GpRound(TOREAL(
                   //(pifi->fwdMacAscender - pifi->fwdMacDescender)
                   pifi->fwdUnitsPerEm
                *  designToIdeal
            ));
            for (INT i=0; i<glyphCount; i++)
            {
                advances[i] = commonVerticalAdvance;
            }
        }
    }
    else
    {
        // Horizontal advance width

        for (INT i=0; i<glyphCount; i++)
        {
            advances[i] = GpRound(TOREAL(DesignAdvance->Lookup(glyphs[i]) * designToIdeal * tracking));
        }

        if (    (style & FontStyleBold)
            &&  !(GetFaceStyle() & FontStyleBold))
        {
            // Algorithmic emboldening increases glyph width

            UINT16 extraAdvance = ((pifi->fwdUnitsPerEm * 2 - 1) / 100);

            for (INT i=0; i<glyphCount; i++)
            {
                if (advances[i] != 0)
                {
                    advances[i] += extraAdvance;
                }
            }
        }
    }
}


BOOL GpFontFace::IsCodePageSupported(UINT codePage)
{
    switch (codePage)
    {
        case 1252:
            return SupportedCodePages & Latine1CodePageMask ? TRUE : FALSE;
            break;

        case 1250:
            return SupportedCodePages & Latine2CodePageMask ? TRUE : FALSE;
            break;

        case 1251:
            return SupportedCodePages & CyrillicCodePageMask ? TRUE : FALSE;
            break;

        case 1253:
            return SupportedCodePages & GreekCodePageMask ? TRUE : FALSE;
            break;

        case 1254:
            return SupportedCodePages & TurkishCodePageMask ? TRUE : FALSE;
            break;

        case 1255:
            return SupportedCodePages & HebrewCodePageMask ? TRUE : FALSE;
            break;

        case 1256:
            return SupportedCodePages & ArabicCodePageMask ? TRUE : FALSE;
            break;

        case 1257:
            return SupportedCodePages & BalticCodePageMask ? TRUE : FALSE;
            break;

        case 874:
            return SupportedCodePages & ThaiCodePageMask ? TRUE : FALSE;
            break;

        case 932:
            return SupportedCodePages & JapanCodePageMask ? TRUE : FALSE;
            break;

        case 936:
            return SupportedCodePages & ChineseCodePageMask ? TRUE : FALSE;
            break;

        case 949:
            return SupportedCodePages & KoreanCodePageMask ? TRUE : FALSE;
            break;

        case 950:
            return SupportedCodePages & TraditionalChineseCodePageMask ? TRUE : FALSE;
            break;

        case 1361:
            return SupportedCodePages & KoreanJohabCodePageMask? TRUE : FALSE;
            break;

        case 869:
            return SupportedCodePages & IBMGreekCodePageMask ? TRUE : FALSE;
            break;

        case 866:
            return SupportedCodePages & RussianMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 865:
            return SupportedCodePages & NordicCodePageMask ? TRUE : FALSE;
            break;

        case 864:
            return SupportedCodePages & ArabicMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 863:
            return SupportedCodePages & CanandianMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 862:
            return SupportedCodePages & HebrewMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 861:
            return SupportedCodePages & IcelandicMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 860:
            return SupportedCodePages & PortugueseMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 857:
            return SupportedCodePages & IBMTurkishCodePageMask ? TRUE : FALSE;
            break;

        case 855:
            return SupportedCodePages & IBMCyrillicCodePageMask ? TRUE : FALSE;
            break;

        case 852:
            return SupportedCodePages & Latin2MsDosCodePageMask  ? TRUE : FALSE;
            break;

        case 775:
            return SupportedCodePages & BalticMsDosCodePageMask ? TRUE : FALSE;
            break;

        case 737:
            return SupportedCodePages & Greek437CodePageMask ? TRUE : FALSE;
            break;

        case 708:
            return SupportedCodePages & ArabicAsmoCodePageMask ? TRUE : FALSE;
            break;

        case 850:
            return SupportedCodePages & WeLatinCodePageMask ? TRUE : FALSE;
            break;

        case 437:
            return SupportedCodePages & USCodePageMask ? TRUE : FALSE;
            break;
    }
    return FALSE;
}



BOOL GpFontFace::InitializeImagerTables()
{
    // MissingGlyph Should be initialized before calling Shaping.Create()
    // because it depends on it.

    MissingGlyph = 0;   // !!! Not true for all FE fonts

    // We goining to initialize it correctly in shaping.cpp
    SupportedCodePages = 0;

    // Initialise tables to default values
    Cmap = 0;
    DesignAdvance = 0;

    DesignVerticalAdvance             = NULL;
    DesignTopSidebearing              = NULL;
    MissingGlyph                      = 0;   // !!! Not true for all FE fonts
    BlankGlyph                        = 0;
    RequiresFullText                  = FALSE;
    Shaping.Cache                     = NULL;
    Gsub                              = NULL;
    Mort                              = NULL;
    Gpos                              = NULL;
    Gdef                              = NULL;
    VerticalSubstitutionCount         = 0;
    VerticalSubstitutionOriginals     = NULL;
    VerticalSubstitutionSubstitutions = NULL;

    BYTE * hheaTable = 0;
    INT    hheaLength = 0;

    if (GetFontData('aehh', &hheaLength, &hheaTable) != Ok)
    {
        return FALSE;
    }

    // from now on we can't return early, because we need to release font data in the end of the function
    GpStatus status = Ok;

    Cmap = new IntMap<UINT16>;
    if (!Cmap)
        status = OutOfMemory;
    else
        status = Cmap->GetStatus();

    if (status == Ok)
    {
        DesignAdvance = new IntMap<UINT16>;
        if (!DesignAdvance)
            status = OutOfMemory;
        else
            status = DesignAdvance->GetStatus();
    }
    /// Load CMAP
    //
    //
    if (status == Ok)
    {
        INT    cmapLength = 0;
        BYTE  *cmapTable = 0;

        if (Cmap &&
            GetFontData('pamc', &cmapLength, &cmapTable) == Ok)
        {
            AutoArray<BYTE> cmapCopy(new BYTE [cmapLength]);       // copy of cmap table

            if (!cmapCopy)
                status = OutOfMemory;
            else
                GpMemcpy (cmapCopy.Get(), cmapTable, cmapLength);

            ReleaseFontData();          // deref cmap

            if (status == Ok)
            {
                bSymbol = FALSE;

                status = ReadCmap(cmapCopy.Get(), cmapLength, Cmap, &bSymbol);

                // !!! Fix up CMAP for special font types here

                // We fallback to Microsoft Sans serif for Arabic scripts which does not have
                // a glyph for Arabic percent sign (before Whistler)
                // We replace its glyph with the Latin precent sign.

                if (status == Ok &&
                    !UnicodeStringCompareCI((PWSTR)((BYTE*)pifi + pifi->dpwszFamilyName),L"Microsoft Sans Serif") &&
                    Cmap->Lookup(0x066A) == 0)
                {
                    status = Cmap->Insert(0x066A, Cmap->Lookup(0x0025));
                }
            }
        }
    }

    /// Load horizontal metrics
    //
    //
    if (status == Ok)
    {
        INT     hmtxLength = 0;
        BYTE    *hmtxTable = 0;

        if (DesignAdvance &&
            GetFontData('xtmh', &hmtxLength, &hmtxTable) == Ok)
        {
            AutoArray<BYTE> hmtxCopy(new BYTE [hmtxLength]);       // copy of hmtx table

            // Copy the hmtx so we can party on it (byte swap for example)

            if (!hmtxCopy)
                status = OutOfMemory;
            else
                GpMemcpy (hmtxCopy.Get(), hmtxTable, hmtxLength);

            ReleaseFontData();          // deref hmtx

            if (status == Ok)
            {
                status = ReadMtx(
                    hmtxCopy.Get(),
                    hmtxLength,
                    NumGlyphs,
                    byteSwapUINT16(((HheaTable *)hheaTable)->numberOfHMetrics),
                    DesignAdvance
                );
            }
        }
    }

    /// Load vertical metrics, if any
    //
    //
    if (status == Ok)
    {
        BYTE   *vheaTable = 0;
        INT     vheaLength = 0;

        if (GetFontData('aehv', &vheaLength, &vheaTable) == Ok)
        {
            INT     vmtxLength = 0;
            BYTE   *vmtxTable = 0;
            if (GetFontData('xtmv', &vmtxLength, &vmtxTable) == Ok)
            {
                AutoArray<BYTE> vmtxCopy(new BYTE [vmtxLength]);       // copy of vmtx table

                if (!vmtxCopy)
                    status = OutOfMemory;
                else
                    GpMemcpy (vmtxCopy.Get(), vmtxTable, vmtxLength);

                ReleaseFontData();  // deref vmtx

                UINT16  numOfLongVerMetrics = byteSwapUINT16(((VheaTable *)vheaTable)->numOfLongVerMetrics);

                if (status == Ok)
                {
                    DesignVerticalAdvance = new IntMap<UINT16>;
                    if (!DesignVerticalAdvance)
                        status = OutOfMemory;
                    else
                    {
                        status = ReadMtx(
                            vmtxCopy.Get(),
                            vmtxLength,
                            NumGlyphs,
                            numOfLongVerMetrics,
                            DesignVerticalAdvance
                        );
                    }

                    if (status == Ok)
                    {
                        DesignTopSidebearing  = new IntMap<UINT16>;
                        if (!DesignTopSidebearing)
                            status = OutOfMemory;
                        else
                        {
                            status = ReadMtxSidebearing(
                                vmtxCopy.Get(),
                                vmtxLength,
                                NumGlyphs,
                                numOfLongVerMetrics,
                                DesignTopSidebearing
                            );
                        }
                    }
                }
            }
            ReleaseFontData();  // deref vhea
        }
    }


    ///  Load OTL tables
    //
    //
    if (status == Ok)
    {
        INT   tableSize = 0;
        BYTE *tableAddress = 0;

        if (GetFontData('BUSG', &tableSize, &tableAddress) == Ok)  // GSUB
        {
            Gsub = new BYTE[tableSize];
            if (!Gsub)
                status = OutOfMemory;
            else
            {
                memcpy(Gsub, tableAddress, tableSize);
                
                // Override the table first fix32 version field to our own use,
                // it now contains the size of each table in byte.
                
                ((UINT32 *)Gsub)[0] = tableSize;            
            }
            ReleaseFontData();
        }
        else
        {
            if (GetFontData('trom', &tableSize, &tableAddress) == Ok)  // mort
            {
                Mort = new BYTE[tableSize];
                if (!Mort)
                    status = OutOfMemory;
                else
                {
                    memcpy(Mort, tableAddress, tableSize);
                
                    // Override the table first fix32 version field to our own use,
                    // it now contains the size of each table in byte.
                
                    ((UINT32 *)Mort)[0] = tableSize;            
                }
                ReleaseFontData();
            }
        }

        if (status == Ok && GetFontData('SOPG', &tableSize, &tableAddress) == Ok)  // GPOS
        {
            Gpos = new BYTE[tableSize];
            if (!Gpos)
                status = OutOfMemory;
            else
            {
                memcpy(Gpos, tableAddress, tableSize);            
                ((UINT32 *)Gpos)[0] = tableSize;            
            }
            ReleaseFontData();
        }

        if (status == Ok && GetFontData('FEDG', &tableSize, &tableAddress) == Ok)  // GDEF
        {
            Gdef = new BYTE[tableSize];
            if (!Gdef)
                status = OutOfMemory;
            else
            {
                memcpy(Gdef, tableAddress, tableSize);
                ((UINT32 *)Gdef)[0] = tableSize;            
            }
            ReleaseFontData();
        }

        if (status == Ok)
        {
            if (Gsub)
            {
                // Get address of vertical substitution info, if any

                LoadVerticalSubstitution(
                    Gsub,
                    &VerticalSubstitutionCount,
                    &VerticalSubstitutionOriginals,
                    &VerticalSubstitutionSubstitutions
                );
            } 
            else if (Mort)
            {
                LoadMortVerticalSubstitution(
                    Mort,
                    &VerticalSubstitutionCount,
                    &VerticalSubstitutionOriginals,
                    &VerticalSubstitutionSubstitutions
                );
            }
        }
    }

    ///  Build shaping cache
    //
    //
    if (status == Ok)
        status = Shaping.Create(this);

    if (status == Ok)
        BlankGlyph = Cmap->Lookup(' ');

    // All done

    ReleaseFontData();             // deref hhea

    if (status != Ok)
    {
        FreeImagerTables();
        return FALSE;
    }
    return TRUE;
}

void GpFontFace::FreeImagerTables()
{
    delete Cmap, Cmap = NULL;
    delete DesignAdvance, DesignAdvance = NULL;

    Shaping.Destroy();

    delete DesignVerticalAdvance, DesignVerticalAdvance = NULL;
    delete DesignTopSidebearing, DesignTopSidebearing = NULL;
    delete [] Gsub, Gsub = NULL;
    delete [] Mort, Mort = NULL;
    delete [] Gpos, Gpos = NULL;
    delete [] Gdef, Gdef = NULL;
} // GpFontFace::FreeImagerTables

GpStatus
GpGlyphPath::CopyPath(GpPath *path)
{
    ASSERT(path->IsValid());

    INT count;

    curveCount = path->GetSubpathCount();
    hasBezier = path->HasCurve();
    pointCount = count = path->GetPointCount();

    if (count)
    {
        points = (GpPointF*) ((BYTE*)this + sizeof(GpGlyphPath));
        types = (BYTE*) ((BYTE*)points + sizeof(GpPointF) * count);

        const GpPointF *pathPoints = path->GetPathPoints();
        const BYTE *pathTypes = path->GetPathTypes();

        GpMemcpy(points, pathPoints, count * sizeof(GpPointF));
        GpMemcpy(types, pathTypes, count * sizeof(BYTE));
    }
    else  // 'blank' glyph
    {
        points = NULL;
        types = NULL;
    }

    return Ok;
}


/////   GetHeight
//
//      Returns height in world units for a given graphics. If graphics passed
//      as NULL works as if passed a graphics derived from GetDC(NULL).

GpStatus
GpFont::GetHeightAtWorldEmSize(REAL worldEmSize, REAL *height) const
{
    const GpFontFace *face = Family->GetFace(Style);

    if (!face)
    {
        return InvalidParameter;
    }

    *height = TOREAL(worldEmSize * face->GetDesignLineSpacing()
                                 / face->GetDesignEmHeight());

    return Ok;
}

GpStatus
GpFont::GetHeight(REAL dpi, REAL *height) const
{
    REAL worldEmSize = EmSize;

    switch (SizeUnit)
    {
    case UnitPoint:       worldEmSize = EmSize * dpi / 72.0f;   break;
    case UnitInch:        worldEmSize = EmSize * dpi;           break;
    case UnitDocument:    worldEmSize = EmSize * dpi / 300.0f;  break;
    case UnitMillimeter:  worldEmSize = EmSize * dpi / 25.4f;   break;
    }

    return GetHeightAtWorldEmSize(worldEmSize, height);
}


GpStatus
GpFont::GetHeight(const GpGraphics *graphics, REAL *height) const
{
    REAL worldEmSize =    EmSize
                       *  graphics->GetScaleForAlternatePageUnit(SizeUnit);

    return GetHeightAtWorldEmSize(worldEmSize, height);
}


class FontRecordData : public ObjectData
{
public:
    REAL EmSize;
    Unit SizeUnit;
    INT Style;
    UINT Flag;
    UINT Length;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the font data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpFont::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    WCHAR *     familyName = const_cast<WCHAR *>((const_cast<GpFontFamily *>(Family))->GetCaptializedName());
    UINT        length     = 0;

    if (familyName)
    {
        length = UnicodeStringLength(familyName);
    }

    FontRecordData  fontData;

    fontData.EmSize   =  EmSize;
    fontData.SizeUnit = SizeUnit;
    fontData.Style    =   Style;

    // !!! For now, we assume the next block of bytes is the
    // family name (flag == 0).  In the future, we need to handle
    // memory images (flag == 1).
    fontData.Flag     = 0;
    fontData.Length   = length;

    stream->Write(&fontData, sizeof(fontData), NULL);
    stream->Write(familyName, length * sizeof(WCHAR), NULL);

    // align
    if ((length & 0x01) != 0)
    {
        length = 0;
        stream->Write(&length, sizeof(WCHAR), NULL);
    }

    return Ok;
}

UINT
GpFont::GetDataSize() const
{
    UINT                dataSize   = sizeof(FontRecordData);
    WCHAR *             familyName = const_cast<WCHAR *>((const_cast<GpFontFamily *>(Family))->GetCaptializedName());

    if (familyName)
    {
        dataSize += (UnicodeStringLength(familyName) * sizeof(WCHAR));
    }

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the font object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpFont::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if ((dataBuffer == NULL) || (size < sizeof(FontRecordData)))
    {
        WARNING(("dataBuffer is NULL or size is too small"));
        return InvalidParameter;
    }

    UINT flag;
    UINT length;
    WCHAR familyName[FamilyNameMax];
    const FontRecordData * fontData = (const FontRecordData *)dataBuffer;

    if (!fontData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    EmSize = fontData->EmSize;
    SizeUnit = fontData->SizeUnit;
    Style = fontData->Style;
    length = fontData->Length;
    dataBuffer += sizeof(FontRecordData);

    if (size < (sizeof(FontRecordData) + (length * sizeof(WCHAR))))
    {
        WARNING(("size is too small"));
        return InvalidParameter;
    }

    // !!! For now, we assume the next block of bytes is the
    // family name (flag == 0).  In the future, we need to handle
    // memory images (flag == 1).

    if (length > FamilyNameMax)
    {
        length = FamilyNameMax;
    }

    // read in the familyName/data
    UnicodeStringCopyCount (familyName,
                            (WCHAR *)dataBuffer,
                            length);

    familyName[length] = 0;

    // !!! For now, we assume that the font family comes from
    // the installed font collection
    //
    // also make sure the font table is loaded the application may play
    // the meta file before loading the font table.

    GpFontTable *fontTable = Globals::FontCollection->GetFontTable();

    if (!fontTable->IsValid())
        return OutOfMemory;

    if (!fontTable->IsPrivate() && !fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    Family = fontTable->GetFontFamily(familyName);

    if (Family == NULL)
    {
        GpStatus status = GpFontFamily::GetGenericFontFamilySansSerif((GpFontFamily **) &Family);
        if (status != Ok)
        {
            Family = NULL;
            return status;
        }
    }

    if (!(Family && Family->IsFileLoaded()))
    {
        Family = NULL;
    }

    if (Family == NULL)
    {
        return GenericError;
    }

    UpdateUid();
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontcollection.hpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   fontcollection.hpp
*
* Abstract:
*
*   Font collection.  These objects implement the internal GdiPlus
*   installable fonts (system fonts) and private fonts (fonts an
*   application can temporarily install).
*
* Revision History:
*
*   03/06/00  DChinn
*       Created it.
*
\**************************************************************************/

#ifndef _FONTCOLLECTION_HPP
#define _FONTCOLLECTION_HPP


class GpFontCollection
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagFontCollection : ObjectTagInvalid;
    }

public:

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpFontCollection, Tag) == 4);
    #endif
    
        ASSERT((Tag == ObjectTagFontCollection) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid FontCollection");
        }
    #endif

        return (Tag == ObjectTagFontCollection);
    }

    GpFontCollection()
    {
        SetValid(TRUE);     // default is valid
    }

    ~GpFontCollection()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    
    INT GetFamilyCount ();                         // number of enumerable families in the collection
    GpStatus GetFamilies (                         // enumerate the fonts in a collection
        INT             numSought,
        GpFontFamily*   gpfamilies[],
        INT*            numFound
        );

    virtual BOOL LoadRegistered()=0;    // is TRUE if we should load all registered
                                        // fonts every time we try to enumerate
                                        // (e.g., if the object is an installed
                                        // font collection)
    GpFontTable *GetFontTable()     { return FontTable; }

protected:
    GpFontTable *FontTable;             // hash table of GpFontFile
};


class GpInstalledFontCollection : public GpFontCollection
{
public:

    ~GpInstalledFontCollection();
    static GpInstalledFontCollection* GetGpInstalledFontCollection();
    GpStatus InstallFontFile (const WCHAR *filename);
    GpStatus UninstallFontFile (const WCHAR *filename);
    virtual BOOL LoadRegistered()       { return TRUE; }

protected:
    GpInstalledFontCollection();

private:
    static GpInstalledFontCollection* instance;
};

class GpPrivateFontCollection : public GpFontCollection
{
public:
    GpPrivateFontCollection();
    ~GpPrivateFontCollection();
    
    GpStatus AddFontFile (const WCHAR *filename);
    GpStatus AddMemoryFont (const void *memory, INT length);
    virtual BOOL LoadRegistered()       { return FALSE; }
};

#endif // FONTCOLLECTION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontable.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Font table operations
*
* Revision History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\

    Windows 9x compatibility:

    const WCHAR* strW;

    if (Globals::IsNT)
    {
        FunctionW(strW);
    }
    else
    {
        AnsiStrFromUnicode strA(strW);
        FunctionA(strA);
    }

\**************************************************************************/


/**************************************************************************\
*
* Function Description:
*
*   Constructs a GpFontTable object
*
* Arguments:
*
*       none
*
* Returns:
*
*       nothing
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontTable::GpFontTable() : NumFilesLoaded(0), NumHashEntries(61), Table(NULL), EnumList(NULL)
{
    Table = new GpFontFile *[NumHashEntries];

    if (Table != NULL)
    {
        GpMemset(Table, 0, sizeof(GpFontFile *) * NumHashEntries);

        EnumList = new GpFontFamilyList();
    }

    bPrivate = FALSE;
    bFontFilesLoaded = FALSE;
}


/**************************************************************************\
*
* Function Description:
*
*   Destroys a GpFontTable object
*
* Arguments:
*
*       none
*
* Returns:
*
*       nothing
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontTable::~GpFontTable()
{
    if (EnumList)
    {
        delete EnumList;
    }

    if (Table)
    {
        for (UINT h = 0; h < NumHashEntries; h++)
        {
            if (Table[h] != NULL)
            {
                UnloadFontFiles(Table[h]);
            }
        }

        delete [] Table;
    }
}

BOOL GpFontTable::UnloadFontFiles(GpFontFile* fontFile)
{
    if (fontFile->GetNext() != NULL)
    {
        UnloadFontFiles(fontFile->GetNext());
    }

    CacheFaceRealization *prface = fontFile->prfaceList;

    while(prface)
    {
        GpFaceRealizationTMP rface(prface);

        // specially for the case of font added and removed from a private font collection, we need to remove it from the
        // last recently used list
        Globals::FontCacheLastRecentlyUsedList->RemoveFace(prface);

        prface = (prface->NextCacheFaceRealization == fontFile->prfaceList) ? NULL : prface->NextCacheFaceRealization;

        rface.DeleteRealizedFace();
    }

    ttfdSemUnloadFontFile(fontFile->hff);

    // Free objects allocated by text support

    for (UINT i=0; i<fontFile->GetNumEntries(); i++)
    {
        fontFile->GetFontFace(i)->FreeImagerTables();
    }

    if (fontFile->pfv != NULL)
    {
        if (fontFile->pfv->pwszPath == NULL)  // memory image
            GpFree(fontFile->pfv->pvView);

        GpFree(fontFile->pfv);
    }

    GpFree(fontFile);

    return TRUE;
}



/**************************************************************************\
*
* Function Description:
*
*   Load all the fonts from cache or the registry to the font table
*
*
* History:
*
*   11/12/1999 yungt created it.
*
\**************************************************************************/

void GpFontTable::LoadAllFonts(const WCHAR *familyName)
{
    InitFontFileCache();
            
    if (GetFontFileCacheState() & FONT_CACHE_LOOKUP_MODE)
    {
    // Do the fast way to load all the fonts, we will be no need to touch any registry
    // and font file.
        LoadAllFontsFromCache(FontFileCacheReadRegistry());
    }
    else
    {
    // We do need to load the fonts from registry also we need to 
        if (GetFontFileCacheState() & FONT_CACHE_CREATE_MODE)
        {
            LoadAllFontsFromRegistry(TRUE);
        }
        else
        {
            LoadAllFontsFromRegistry(FALSE);
        }
    }
    
    vCloseFontFileCache();
}

/**************************************************************************\
*
* Function Description:
*
*   Adds a font from the font table
*
* Arguments:
*
*       str:    name of font to be added
*
* Returns:
*
*       GpFontFile *:   It will not be NULL if succeeded
*
* History:
*
*   28/06/YungT cameronb
*       Created it.
*
\**************************************************************************/

GpFontFile * GpFontTable::AddFontFile(WCHAR* fileName)
{
// This rountine is called from GpFontFamily which we have load the family from cache
// We need to load the font file now if it is being used.

    GpFontFile* fontFile = NULL;
    
    UINT hash = HashIt(fileName);
    {
        fontFile = GetFontFile(fileName, hash);
    
        if (fontFile != NULL)
        {
            // font exists in the table
            fontFile->cLoaded++;
        }
        else
        {
            if ((fontFile = LoadFontFile(fileName)) == NULL)
            {
                return NULL;
            }
    
            
            // Add to the head of the appropriate hash list (hash bucket)
            
            fontFile->SetPrev(NULL);
            fontFile->SetNext(Table[hash]);
            if (Table[hash] != NULL)
                Table[hash]->SetPrev(fontFile);
            Table[hash] = fontFile;
    
            // loop over pfe's, init the data:
            GpFontFace * face = (GpFontFace *)fontFile->aulData;

            for (ULONG iFont = 0; iFont < fontFile->cFonts; iFont++)
            {
                face[iFont].SetPrivate(bPrivate);
            }

            // Add to the emuneration list
    
            NumFilesLoaded++;
        }
    }   
    
    return fontFile;
}



/**************************************************************************\
*
* Function Description:
*
*   Adds a font from the font table
*
* Arguments:
*
*       str:    name of font to be added
*
* Returns:
*
*       BOOL:   indicating success
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus GpFontTable::AddFontFile(const WCHAR* fileName,
                                  GpFontCollection *fontCollection)
{
    WCHAR awcPath[MAX_PATH];
    FLONG flDummy;

    GpStatus status = Ok;
    
    if (!MakePathName(awcPath, const_cast<WCHAR *>(fileName), &flDummy))
        return FileNotFound;

//  Determine whether font is already in the table
    UnicodeStringToUpper (awcPath, awcPath);
    UINT hash = HashIt(awcPath);
    {
        GpFontFile* fontFile = GetFontFile(awcPath, hash);
    
        if (fontFile != NULL)
        {
            // font exists in the table
            fontFile->cLoaded++;
        }
        else
        {
            if ((fontFile = LoadFontFile(awcPath)) == NULL)
            {
                return FileNotFound;
            }
    
            
            // Add to the head of the appropriate hash list (hash bucket)
            
            fontFile->SetPrev(NULL);
            fontFile->SetNext(Table[hash]);
            if (Table[hash] != NULL)
                Table[hash]->SetPrev(fontFile);
            Table[hash] = fontFile;
    
            // loop over pfe's, init the data:
            GpFontFace * face = (GpFontFace *)fontFile->aulData;

            for (ULONG iFont = 0; iFont < fontFile->cFonts; iFont++)
            {
                face[iFont].SetPrivate(bPrivate);
            }

            // Add to the emuneration list
    
            if (!EnumList->AddFont(fontFile, fontCollection))
                return OutOfMemory;
            NumFilesLoaded++;
        }
    }   
    
    return Ok;
}


/************************************************************\
*
* Function Description:
*
*   Adds a font from the memory image
*
*
* History:
*
*   Nov/09/1999 Xudong Wu [tessiew]
*       Created it.
*
\************************************************************/
ULONG GpFontTable::MemImageUnique = 0;

GpStatus GpFontTable::AddFontMemImage(
    const BYTE* fontMemoryImage,
    INT   fontImageSize,
    GpFontCollection *fontCollection
    )
{
    WCHAR awcPath[MAX_PATH];
    UINT  hash;
    GpFontFile *fontFile;

    // generate a "MEMORY xxx" style file name

    wsprintfW(awcPath, L"MEMORY-%u", GetNewMemImageUniqueness(GpFontTable::MemImageUnique));

    UnicodeStringToUpper (awcPath, awcPath);
    hash = HashIt(awcPath);
    
    fontFile = LoadFontMemImage(awcPath, const_cast<BYTE *>(fontMemoryImage), fontImageSize);
    
    if (fontFile == NULL)   // unable to load font
	{
         return FileNotFound;
	}
    
    // Add to the head of the appropriate hash list (hash bucket)
    
    fontFile->SetNext(Table[hash]);
    if (Table[hash] != NULL)
        Table[hash]->SetPrev(fontFile);
    Table[hash] = fontFile;

    // Add to the emuneration list

    if (!EnumList->AddFont(fontFile, fontCollection))
        return OutOfMemory;
    NumFilesLoaded++;
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Searched the font table for the any font
*
* Arguments:
*
*
* Returns:
*
*       GpFontFamily *: pointer to font file if found, else NULL
*
* History:
*
*  7/15/2000 YungT
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontTable::GetAnyFamily()
{
    return EnumList->GetAnyFamily();
}

/**************************************************************************\
*
* Function Description:
*
*   Searched the font table for the specified font
*
* Arguments:
*
*       fileName:       name of font to be removed
*   hash:       its hash value
*
* Returns:
*
*       GpFontFile*: pointer to font file if found, else NULL
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontTable::GetFontFamily(const WCHAR* familyName)
{
    return EnumList->GetFamily(familyName);
}


/**************************************************************************\
*
* Function Description:
*
*   Removes a font from the font table.
*
*   Note: If the ref count of any of the PFEs in the font file is greater
*   than zero, then we do not delete the font file entry in the font table.
*   However, the bRemoved flag is set in this function.  So, in the case when
*   a ref count decrement could cause a font file to be removed, the caller
*   should first test bRemoved before calling this function.
*
* History:
*
*   Nov/28/1999  Xudong Wu [tessiew]
*       Created it.
*
\**************************************************************************/

GpStatus GpFontTable::RemoveFontFile(const WCHAR* fontFileName)
{
    WCHAR awcPath[MAX_PATH];
    GpFontFile *fontFile = NULL;
    FLONG flDummy;

    if (!MakePathName(awcPath, const_cast<WCHAR *>(fontFileName), &flDummy))
        return GenericError;

    UnicodeStringToUpper (awcPath, awcPath);
    UINT hash = HashIt(awcPath);

    GpFontFile *ff = Table[hash];

    while(ff && !fontFile)
    {
        if ( UnicodeStringCompare(awcPath, ff->pwszPathname_) == 0 )
        {
            fontFile = ff;
        }
        ff = ff->GetNext();
    }

    if (fontFile)
    {
        fontFile->bRemoved = TRUE;

        if (fontFile->cLoaded)
        {
            fontFile->cLoaded--;
        }

        // see if any of the PFEs have a ref count on them
        BOOL bFontFamilyRef = TRUE;
        for (UINT iFont = 0; iFont < fontFile->cFonts; iFont++)
        {
            GpFontFace *pfe = &(((GpFontFace *) &(fontFile->aulData))[iFont]);
            if (pfe->cGpFontFamilyRef > 0)
            {
                bFontFamilyRef = FALSE;
            }
        }
        // ASSERT: if there are no references by any FontFamily to
        // any of the PFEs in this object (via GpFontFamily objects),
        // then bFontFamilyRef is TRUE.  bFontFamilyRef is FALSE otherwise.

        if (fontFile->cLoaded == 0 &&
            bFontFamilyRef &&
            fontFile->prfaceList == NULL)
        {
            // set the Face pointers of the corresponding FontFamily objects
            // to NULL and attempt to remove each font family in the file
            for (UINT iFont = 0; iFont < fontFile->cFonts; iFont++)
            {
                GpFontFamily *gpFontFamily = GetFontFamily(fontFile->GetFamilyName(iFont));
                if (gpFontFamily)
                {
                    for (UINT iFace = 0; iFace < NumFontFaces; iFace++)
                    {
                        if (gpFontFamily->GetFaceAbsolute(iFace) ==
                            (&(((GpFontFace *) (&(fontFile->aulData))) [iFont])))
                        {
                            gpFontFamily->SetFaceAndFile(iFace, NULL, NULL);
                        }
                    }
                    EnumList->RemoveFontFamily(gpFontFamily);
                }
            }

            // remove GpFontFile from the FontTable
            NumFilesLoaded--;

            if (fontFile->GetPrev())
                fontFile->GetPrev()->SetNext(fontFile->GetNext());
            if (fontFile->GetNext())
                fontFile->GetNext()->SetPrev(fontFile->GetPrev());
            
            if (fontFile == Table[hash])
                Table[hash] = fontFile->GetNext();
            
            ttfdSemUnloadFontFile(fontFile->hff);

            // Free objects allocated by text support

            for (ULONG i=0; i<fontFile->GetNumEntries(); i++)
            {
                fontFile->GetFontFace(i)->FreeImagerTables();
            }

            if (fontFile->pfv != NULL)
            {
                if (fontFile->pfv->pwszPath == NULL)  // memory image
                GpFree(fontFile->pfv->pvView);

                GpFree(fontFile->pfv);
            }
            GpFree(fontFile);

            return Ok;
        }
    }
    else
    {
        // couldn't find the font file in the hash table
        return GenericError;
    }
    
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Counts the number of enumerable fonts in the table
*
* Arguments:
*
*
*
* Returns:
*
*       Number of enumerable fonts
*
* History:
*
*   12/07/1999 cameronb
*       Created it.
*
\**************************************************************************/

INT GpFontTable::EnumerableFonts(GpGraphics* graphics)
{
    return EnumList->Enumerable(graphics);
}

/**************************************************************************\
*
* Function Description:
*
*   Enumerates fonts.
*
*   First call EnumerableFonts() to determine the number to expect.
*
* Arguments:
*
*
*
* Returns:
*
*       Status of the enumeration operation
*
* History:
*
*   12/07/1999 cameronb
*       Created it.
*
\**************************************************************************/

GpStatus GpFontTable::EnumerateFonts(
    INT                     numSought,
    GpFontFamily*           gpfamilies[],
    INT&                    numFound,
    GpGraphics*               graphics
) 
{
    GpStatus status = EnumList->Enumerate(numSought, gpfamilies, numFound, graphics);

#if FONTTABLE_DBG
    TERSE(("Enumerated font list:"));
    EnumList->Dump();
    TERSE(("Done."));
#endif

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns a pseudorandom hash value for a given string
*
* Arguments:
*
*       str:    string to be hashed
*
* Returns:
*
*       UINT:   hash value for str
*
* Note: All strings must be capitalized!                                   *
*                                                                          *
* History:
*
*   23/06/1999 cameronb
*       Created it.
* History:                                                                 *
*  Wed 07-Sep-1994 08:12:22 by Kirk Olynyk [kirko]                         *
* Since chuck is gone the mice are free to play. So I have replaced        *
* it with my own variety. Tests show that this one is better. Of           *
* course, once I have gone someone will replace mine. By the way,          *
* just adding the letters and adding produces bad distributions.           *
*  Tue 15-Dec-1992 03:13:15 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  It looks crazy, but I claim there's a theory behind it.       *
*
\**************************************************************************/

UINT GpFontTable::HashIt(const WCHAR* str) const
{
    UINT result = 0;

    //ASSERT(NumHashEntries != 0);

    while (*str)
    {
        // use the lower byte since that is where most of the
        // interesting stuff happens
        //result += 256 * result + (UCHAR)towupper(*str++);
        result += 256 * result + (UCHAR)*str++;
    }

    return result % NumHashEntries;
}

GpFontFile* GpFontTable::GetFontFile(const WCHAR* fileName) const
{
    WCHAR fileNameCopy[MAX_PATH];
    UnicodeStringToUpper (fileNameCopy, const_cast<WCHAR *>(fileName));
    UINT hash = HashIt(fileNameCopy);
    return GetFontFile(fileNameCopy, hash);
}

GpFontFile* GpFontTable::GetFontFile(const WCHAR* fileName, UINT hash) const
{
    for (GpFontFile* ff = Table[hash]; ff != NULL; ff = ff->GetNext())
        if (UnicodeStringCompareCI(fileName, ff->GetPathName()) == 0)
        {
            return ff;
        }

    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Adds fonts from the cache file to the font table
*
* Arguments:
*
* Returns:
*
*       nothing
*
* History:
*
*   6/21/2000 YungT
*       Created it.
*
\**************************************************************************/

void GpFontTable::LoadAllFontsFromCache(BOOL bLoadFromRegistry)
{
    if (!EnumList->BuildFamilyListFromCache(bLoadFromRegistry))
    {
        LoadAllFontsFromRegistry(FALSE);
    }
    else
    {
        bFontFilesLoaded = TRUE;
    }

    return ;
}

/**************************************************************************\
*
* Function Description:
*
*   Adds fonts from the registry to the font table
*
* Arguments:
*
*       numExpected:    number of fonts expected in the registry.  This includes
*                   *.FON files which the TT font driver will not load.
*
* Returns:
*
*       nothing
*
* History:
*
*   23/06/1999 cameronb
*       Created it.
*
\**************************************************************************/

void GpFontTable::LoadAllFontsFromRegistry(BOOL bUpdateCache)
{
    ULONG numExpected;
    
    //  Open the key

    HKEY hkey;

    LONG error = (Globals::IsNt) ? RegOpenKeyExW(HKEY_LOCAL_MACHINE, Globals::FontsKeyW, 0, KEY_QUERY_VALUE, &hkey)
                                 : RegOpenKeyExA(HKEY_LOCAL_MACHINE, Globals::FontsKeyA, 0, KEY_QUERY_VALUE, &hkey);

    if (error == ERROR_SUCCESS)
    {
        //  Must read from the registry in Ascii format for some unfathomable reason

        CHAR  label[MAX_PATH];
        BYTE  data[MAX_PATH];
        WCHAR labelW[MAX_PATH];
        WCHAR fileNameW[MAX_PATH];

        //  Loop through fonts in registry

        //  Note:
        //      Don't make (error != ERROR_NO_MORE_ITEMS) the sole
        //      terminating condition for this loop.  The last entry
        //      may produce a different type of error.

        ULONG index = 0;
        ULONG registrySize = 0;

        error = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &numExpected, NULL, NULL, NULL, NULL);

        if (error != ERROR_SUCCESS)
        {
            numExpected = NumHashEntries << 3;
            error = ERROR_SUCCESS;
        }

		/* we need to add the font Marlett separately since it's hidden and not listed in the registry */
        if (AddFontFile(L"Marlett.ttf", NULL) != Ok)
        {
            VERBOSE(("Error loading font Marlett.ttf.\n"))
        }

        while (index < numExpected && error != ERROR_NO_MORE_ITEMS)
        {
            DWORD   regType = 0;
            DWORD   labelSize = MAX_PATH;
            DWORD   dataSize = MAX_PATH;
            DWORD   dataSizeW = MAX_PATH * sizeof(WCHAR);

            if (Globals::IsNt)
                error = RegEnumValueW(hkey, index, labelW, &labelSize, NULL, &regType, (PBYTE) fileNameW, &dataSizeW );
            else
                error = RegEnumValueA(hkey, index, label, &labelSize, NULL, &regType, data, &dataSize);

            if (error == ERROR_NO_MORE_ITEMS)
                break;
            else if (error != ERROR_SUCCESS)
            {
                index ++;
                //ASSERT
                VERBOSE(("Bad RegEnumValueA %d for %s.", error, data))
                continue;
            }

            if (!Globals::IsNt)
            {
                memset(fileNameW, 0, MAX_PATH * sizeof(WCHAR));
                MultiByteToWideChar(CP_ACP, 0, (CHAR*)data, -1, fileNameW, MAX_PATH);

                registrySize += dataSize; 
            }

            if (AddFontFile(fileNameW, NULL) != Ok)
            {
                VERBOSE(("Error loading font %ws.\n", fileNameW))
            }
    
            index ++;
        }

        if (NumFilesLoaded)
        {
            // loaded all the fonts from reg

            if (bUpdateCache)
                EnumList->UpdateFamilyListToCache(FontFileCacheReadRegistry(), hkey, registrySize, numExpected);

            bFontFilesLoaded = TRUE;
        }

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontface.hpp ===
#ifndef _FONTFACE_

#define _FONTFACE_

class GpFontFile;

class ShapingCache;     // implemented in ..\text\uniscribe\shaping

struct ShapingCacheFactory
{
    GpStatus        Create(const GpFontFace *face);
    void            Destroy();
    ShapingCache    *Cache;
};






/////   GpFontFace
//
//


class GpFontFace
{

public:
    FontStyle GetFaceStyle(void) const
    {
        switch (pifi->fsSelection & (FM_SEL_BOLD | FM_SEL_ITALIC))
        {
            case FM_SEL_BOLD:                  return FontStyleBold;
            case FM_SEL_ITALIC:                return FontStyleItalic;
            case FM_SEL_BOLD | FM_SEL_ITALIC:  return FontStyleBoldItalic;
            default:                           return FontStyleRegular;
        }
    }

    BOOL SimBold() const
    {
        BOOL ret = FALSE;

        if (pifi->dpFontSim)
        {
            FONTSIM *pfs = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);

            ret = (pifi->fsSelection & FM_SEL_ITALIC) ?
                    (BOOL) pfs->dpBoldItalic : (BOOL) pfs->dpBold;
        }
        return (ret);
    }

    BOOL SimItalic() const
    {
        BOOL ret = FALSE;

        if (pifi->dpFontSim)
        {
            FONTSIM *pfs = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);

            ret = (pifi->fsSelection & FM_SEL_BOLD) ?
                    (BOOL) pfs->dpBoldItalic : (BOOL) pfs->dpItalic;
        }
        return (ret);
    }

    void IncGpFontFamilyRef(void) { cGpFontFamilyRef++; }
    void DecGpFontFamilyRef(void) { cGpFontFamilyRef--; }


public:

    // The following internal class variables are public because they
    // are initialised and manipulated by classless code ported from GDI.

    // Location of font.

    GpFontFile     *pff;      // pointer to physical font file object
    ULONG           iFont;    // index of the font for IFI or device, 1 based
    FLONG           flPFE;

    // Font data.

    GP_IFIMETRICS  *pifi;     // pointer to ifimetrics
    ULONG           idifi;    // id returned by driver for IFIMETRICS

    // information needed to support ETO_GLYPHINDEX mode of ExtTextOut.

    ULONG           NumGlyphs;

    //  Ref count for GpFontFamily objects that point to this GpFontFace
    ULONG           cGpFontFamilyRef;

    mutable BYTE lfCharset;

    static int CALLBACK EnumFontFamExProcA(
                    const ENUMLOGFONTEXA   *lpelfe,    // logical-font data
                    const NEWTEXTMETRICEXA *lpntme,    // physical-font data
                    int                     FontType,  // type of font
                    LPARAM                  lParam     // application-defined data
                );

    static int CALLBACK EnumFontFamExProcW(
                    const ENUMLOGFONTEXW   *lpelfe,    // logical-font data
                    const NEWTEXTMETRICEXW *lpntme,    // physical-font data
                    int                     FontType,  // type of font
                    LPARAM                  lParam     // application-defined data
                );



    // Text support

    UINT16  GetDesignEmHeight()           const {return pifi->fwdUnitsPerEm;}
    UINT16  GetDesignCellAscent()         const {return pifi->fwdWinAscender;}
    UINT16  GetDesignCellDescent()        const {return pifi->fwdWinDescender;}
    UINT16  GetDesignLineSpacing()        const {return max(pifi->fwdMacAscender-pifi->fwdMacDescender+pifi->fwdMacLineGap, pifi->fwdWinAscender+pifi->fwdWinDescender);}
    UINT16  GetDesignUnderscoreSize()     const {return pifi->fwdUnderscoreSize;}
    INT16   GetDesignUnderscorePosition() const {return pifi->fwdUnderscorePosition;}
    UINT16  GetDesignStrikeoutSize()      const {return pifi->fwdStrikeoutSize;}
    INT16   GetDesignStrikeoutPosition()  const {return pifi->fwdStrikeoutPosition;}


    GpStatus GetFontData(UINT32     tag,
                         INT*       size,
                         BYTE**     pjTable) const;

    void ReleaseFontData() const;

    BYTE GetCharset(HDC hdc) const;

    const IntMap<UINT16> &GetCmap()                               const {return *Cmap;}
    const IntMap<UINT16> &GetDesignAdvance()                      const {return *DesignAdvance;}
    const IntMap<UINT16> *GetDesignVerticalAdvance()              const {return DesignVerticalAdvance;}
    BOOL                  RequiresFullTextImager()                const {return RequiresFullText;}
    UINT16                GetMissingGlyph()                       const {return MissingGlyph;}
    UINT16                GetBlankGlyph()                         const {return BlankGlyph;}
    BYTE                 *GetGSUB()                               const {return Gsub;}
    BYTE                 *GetGPOS()                               const {return Gpos;}
    BYTE                 *GetGDEF()                               const {return Gdef;}
    BYTE                 *GetMort()                               const {return Mort;}
    UINT16                GetVerticalSubstitutionCount()          const {return VerticalSubstitutionCount;}
    const UINT16         *GetVerticalSubstitutionOriginals()      const {return VerticalSubstitutionOriginals;}
    const UINT16         *GetVerticalSubstitutionSubstitutions()  const {return VerticalSubstitutionSubstitutions;}


    void GetGlyphDesignAdvances(
        IN  const UINT16  *glyphs,     //
        IN  INT            glyphCount, //
        IN  INT            style,      // Causes adjustment for algorithmic style emulation
        IN  BOOL           vertical,   // Use vtmx, not htmx
        IN  REAL           tracking,   // Expansion factor
        OUT UINT16        *advances    //
    ) const;

    void GetGlyphDesignAdvancesIdeal(
        IN  const UINT16  *glyphs,        //
        IN  INT            glyphCount,    //
        IN  INT            style,         // Causes adjustment for algorithmic style emulation
        IN  BOOL           vertical,      // Use vtmx, not htmx
        IN  REAL           designToIdeal, // Scale factor for each advance width
        IN  REAL           tracking,      // Expansion factor
        OUT INT           *advances       //
    ) const;

    inline ShapingCache *GetShapingCache() const
    {
        return  Shaping.Cache;
    }

    void FreeImagerTables();

    BOOL IsAliasName()
    {
        BOOL    bOk = FALSE;

        if (pifi->flInfo & FM_INFO_FAMILY_EQUIV)
        {
            bOk = TRUE;
        }

        return bOk;
    }

    WCHAR * GetAliasName()
    {
        size_t length;

        length = UnicodeStringLength((WCHAR *)(((BYTE*) pifi) + pifi->dpwszFamilyName)) + 1;


        if (!(pifi->flInfo & FM_INFO_FAMILY_EQUIV))
        {
           return (WCHAR *) NULL;
        }

        return((WCHAR *)(((BYTE*) pifi) + pifi->dpwszFamilyName) + length);
    }

    BOOL IsPrivate() const { return bPrivateFace;}
    BOOL IsSymbol()  const { return bSymbol;}

    void SetPrivate(BOOL bPrivate) { bPrivateFace = bPrivate;}
    void SetSymbol(BOOL symbol) { bSymbol = symbol;}

    BOOL InitializeImagerTables();

    void SetSupportedCodePages(__int64 codePages)
    {
        SupportedCodePages  =    ((codePages & 0xFF00000000000000) >> 24);
        SupportedCodePages |=    ((codePages & 0x00FF000000000000) >> 8 );
        SupportedCodePages |=    ((codePages & 0x0000FF0000000000) << 8 );
        SupportedCodePages |=    ((codePages & 0x000000FF00000000) << 24);
        SupportedCodePages |=    ((codePages & 0x00000000FF000000) >> 24);
        SupportedCodePages |=    ((codePages & 0x0000000000FF0000) >> 8 );
        SupportedCodePages |=    ((codePages & 0x000000000000FF00) << 8 );
        SupportedCodePages |=    ((codePages & 0x00000000000000FF) << 24);
    }

    BOOL IsCodePageSupported(UINT codePage);

private:
    mutable IntMap<UINT16> *Cmap;
    mutable IntMap<UINT16> *DesignAdvance;
    mutable IntMap<UINT16> *DesignVerticalAdvance;
    mutable IntMap<UINT16> *DesignTopSidebearing;

    mutable ShapingCacheFactory Shaping;

    mutable BOOL RequiresFullText;

    mutable UINT16 MissingGlyph;
    mutable UINT16 BlankGlyph;

    BOOL    bPrivateFace;

    mutable BOOL    bSymbol;
    mutable __int64 SupportedCodePages;

    mutable BYTE         *Gsub;                              // OTL glyph substitution table
    mutable BYTE         *Gpos;                              // OTL glyph positioning table
    mutable BYTE         *Gdef;                              // OTL glyph definition table
    mutable BYTE         *Mort;                              // legacy vertical substitution table
    mutable UINT16        VerticalSubstitutionCount;         // Number of substitutable glyphs
    mutable const UINT16 *VerticalSubstitutionOriginals;     // Pointer into cached GSUB
    mutable const UINT16 *VerticalSubstitutionSubstitutions; // Pointer into cached GSUB

};

#endif // FONTFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontfilecache.hpp ===
/*****************************************************************************
* Module Name: fontfilecache.hpp
*
* Font File Cahce for GDI+.
*
* History:
*
*  11-9-99 Yung-Jen Tony Tsai   Wrote it.
*
* Copyright (c) 1999-2000 Microsoft Corporation
*****************************************************************************/

#ifndef _FONTFILECACHE_
#if DBG
#include <mmsystem.h>
#endif

#define _FONTFILECACHE_

// For system fonts do not include in font reg 

#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#define SZ_FONTCACHE_HEADER() QWORD_ALIGN(sizeof(FONTFILECACHEHEADER))

// 3 modes of font boot cache operation

#define FONT_CACHE_CLOSE_MODE        0x0
#define FONT_CACHE_LOOKUP_MODE       0x1
#define FONT_CACHE_CREATE_MODE       0x2
#define FONT_CACHE_ERROR_MODE        0x3

#define FONT_CACHE_MASK (FONT_CACHE_LOOKUP_MODE | FONT_CACHE_CREATE_MODE)

typedef struct _FONTFILECACHEHEADER 
{
    ULONG           CheckSum;
    ULONG           ulMajorVersionNumber;
    ULONG           ulMinorVersionNumber;
    ULONG           ulLanguageID;     // For NT5 or later version
    ULONG           ulFileSize;     // total size of fntcache.dat
    ULONG           ulDataSize;
    ULARGE_INTEGER  FntRegLWT;
} FONTFILECACHEHEADER;

typedef struct _FONTFILECACHE
{
    FONTFILECACHEHEADER *pFile;
    HANDLE              hFile;                  // Handle of file of font file cache
    HANDLE              hFileMapping;           // Handle of file mapping
    HMODULE             hShFolder; 
    ULONG               cjFileSize;             // size of font file cache
    PBYTE               pCacheBuf;              // read pointers point to the old table
    BOOL                bReadFromRegistry;    
} FONTFILECACHE;

VOID    InitFontFileCache();
FLONG   GetFontFileCacheState();
VOID    vCloseFontFileCache();

VOID  FontFileCacheFault();
PVOID FontFileCacheAlloc(ULONG ulSize);
PVOID FontFileCacheLookUp(ULONG *pcjData);
BOOL  FontFileCacheReadRegistry();

#if DBG
class MyTimer
{
public:
    MyTimer()
    {
    
    // Set the timer resolution to 1ms
        timerOn = TRUE;
        
        if (timeBeginPeriod(1) == TIMERR_NOCANDO)
        {
            WARNING(("The multimedia timer doesn't work"));
            timerOn=FALSE;
        }
        start = timeGetTime();
    }

    ~MyTimer() {}

    DWORD GetElapsedTime(void)
    {
        DWORD elapsed = 0;
        
        if (timerOn)
        {
            end = timeGetTime();
            elapsed = end-start;

            timeEndPeriod(1);
        }

        return elapsed;
    }

    BOOL On(void)
    {
        return (timerOn);
    }
    
    
private:
    BOOL timerOn;
    DWORD start, end;
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontlinking.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Font linking class definition
*
* Revision History:
*
*   3/03/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

#ifndef GP_FONT_LINKING_HPP
#define GP_FONT_LINKING_HPP

struct AssociatedFamilies 
{
    GpFontFamily        *family;
    AssociatedFamilies  *next;
};


struct FontLinkingFamily
{
    GpFontFamily        *family;
    AssociatedFamilies  *associatedFamilies;
    FontLinkingFamily   *next;
};


struct EUDCMAP
{
    GpFontFamily    *inputFamily;
    GpFontFamily    *eudcFamily;
    EUDCMAP         *next;
};

struct EUDC
{
    GpFontFamily    *defaultFamily;
    EUDCMAP         *eudcMapList;
};


struct PrivateLoadedFonts
{
    GpPrivateFontCollection *fontCollection;
    WCHAR                   FileName[MAX_PATH];
    PrivateLoadedFonts      *next;
};


struct FontSubstitutionEntry
{
    WCHAR         familyName[MAX_PATH];
    INT           familyNameLength;
    GpFontFamily *family;
};


//  definition of the Font linking class. it has an global object defined in the Global name space
//  and created in the Font fallback class exist on the \Text\Uniscribe\shaping folder.

class GpFontLink
{
public:
    GpFontLink();
    ~GpFontLink();
    AssociatedFamilies* GetLinkedFonts(const GpFontFamily *family);
    GpFontFamily *GetDefaultEUDCFamily();
    GpFontFamily *GetMappedEUDCFamily(const GpFontFamily *family);
    GpFontFamily *GetFamilySubstitution(const WCHAR* familyName) const;
    const AssociatedFamilies *GetDefaultFamily();
    
private:
    void GetFontLinkingDataFromRegistryW();
    void GetEudcDataFromTheRegistryW();
    void GetEudcDataFromTheRegistryA();
    GpFontFamily* CheckAndLoadTheFile(WCHAR *fileName);
    void CacheFontSubstitutionDataW();
    void CacheFontSubstitutionDataA();

private:
    FontLinkingFamily       *linkedFonts;
    EUDC                    *eudcCache;
    PrivateLoadedFonts      *privateFonts;
    FontSubstitutionEntry   *FontSubstitutionTable;
    INT                      substitutionCount;
    AssociatedFamilies      *DefaultFamily;
    AssociatedFamilies       DefaultFamilyBuffer; // buffer for self-created linking font
};




// wrapper function to get the substitution Family from the FontLinkTable
// but first it make sure that the FontLinkTable is created.


inline void GetFamilySubstitution(const WCHAR* familyName, GpFontFamily **Family)
{
    if (Globals::FontLinkTable == NULL)
    {
        // All APIs are bounded by critical section. we are sure we will not have
        // multithreading problem.
        Globals::FontLinkTable = new GpFontLink;

    }
        
    if (Globals::FontLinkTable != NULL)
    {
        *Family = Globals::FontLinkTable->GetFamilySubstitution(familyName);
    }
    
    return;
}



#endif // GP_FONT_LINKING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontfilecache.cpp ===
#include "precomp.hpp"
#include <shlobj.h>

#define FONTFILECACHEPATH_W TEXT("\\GDIPFONTCACHEV1.DAT")
#define FONTFILECACHEPATH_A "\\GDIPFONTCACHEV1.DAT"
#define FONTFILECACHEREGLOC_W TEXT("Software\\Microsoft\\GDIPlus")
#define FONTFILECACHEREGKEY_W TEXT("FontCachePath")

#define FONTLOADCACHE_NAMEOBJ "GdiplusFontCacheFileV1"

#define FONT_CACHE_EXTRA_SIZE (8 * 1024)

// Just for tempary use
#define FONTFILECACHE_VER   0x185

//--------------------------------------------------------------------------
// Unicode wrappers for win9x - defined in imgutils.hpp (include file conflict)
//--------------------------------------------------------------------------

LONG
_RegCreateKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    );

LONG
_RegSetString(
    HKEY hkey,
    const WCHAR* name,
    const WCHAR* value
    );

LONG
_RegGetString(
    HKEY hkey,
    const WCHAR* name,
    WCHAR* buf,
    DWORD size
    );

// There are 2 levels synchronization mechanism need to take care
// First level: The lock for GDIPFONTCACHEV1.DAT
//    GDIPFONTCACHEV1.DAT is a gloabl file and will be share by different process
// Second level: The lock fof gflFontCacheState and gFontFileCache
//    They should be shared by different thread in the same process.
//    We define a CriticalSec in gFontFileCache.

FLONG           gflFontCacheState;
FONTFILECACHE   gFontFileCache;
HANDLE          ghsemFontFileCache = NULL;

ULONG CalcFontFileCacheCheckSum(PVOID pvFile, ULONG cjFileSize);
VOID vReleaseFontCacheFile(VOID);

typedef HRESULT (* PSHGETFOLDERPATHA) (HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
typedef HRESULT (* PSHGETFOLDERPATHW) (HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);

/*****************************************************************************
 * VOID vReleaseFontCacheFile(VOID)
 *
 * Unmap the view of the file
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID vReleaseFontCacheFile(VOID)
{

    if (gFontFileCache.pFile)
    {
        UnmapViewOfFile(gFontFileCache.pFile);
        gFontFileCache.pFile = NULL;
    }

    if (gFontFileCache.hFileMapping)
    {
        CloseHandle(gFontFileCache.hFileMapping);
        gFontFileCache.hFileMapping = 0;
    }

    if (gFontFileCache.hFile)
    {
        CloseHandle(gFontFileCache.hFile);
        gFontFileCache.hFile = 0;
    }
}

/*****************************************************************************
 * BOOL  bOpenFontFileCache()
 *
 * Initialize font file cache, open the cacheplus.dat file and create hash table
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bOpenFontCacheFile(BOOL bOpenOnly, ULONG cjFileSize, BOOL bReAlloc)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE  pFile = NULL;
    BOOL   bOK = FALSE;
    DWORD  dwCreation = 0;
#if DBG
    DWORD  dwError = 0;
#endif
    WCHAR  wszFilePath[MAX_PATH];
    WCHAR  wszPathOnly[MAX_PATH];
    CHAR   szFilePath[MAX_PATH];
    CHAR   szPathOnly[MAX_PATH];
    BOOL   bRegValid = FALSE;

    // initialize strings...
    wszFilePath[0] = 0;
    wszPathOnly[0] = 0;
    szFilePath[0]  = 0;
    szPathOnly[0]  = 0;

    if (bOpenOnly)
    {
        dwCreation = OPEN_EXISTING;
    }
    else
    {
        dwCreation = CREATE_ALWAYS;
    }

    // First check the registry to see if we can bypass loading SHFolder
    HKEY hkey = (HKEY)NULL;
    const WCHAR wchLocation[] = FONTFILECACHEREGLOC_W;
    const WCHAR wchValue[] = FONTFILECACHEREGKEY_W;
    DWORD valueLength = sizeof(wszFilePath);

    // If this fails, we cannot access the registry key...
    if (_RegCreateKey(HKEY_CURRENT_USER, wchLocation, KEY_ALL_ACCESS, &hkey) != ERROR_SUCCESS)
        hkey = NULL;

    if (hkey && _RegGetString(hkey, wchValue, wszFilePath, valueLength) == ERROR_SUCCESS)
    {
        // The key exists, so we should read the location of the font file
        // from there instead of loading the SHFolder.DLL...

		lstrcpyW(wszPathOnly, wszFilePath);

        // Append the name of cache file
        lstrcatW(wszFilePath, FONTFILECACHEPATH_W);

        if (Globals::IsNt)
        {
            hFile = CreateFileW(
                wszFilePath,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                dwCreation,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
        }
        else
        {
            AnsiStrFromUnicode ansiStr(wszFilePath);

            if (ansiStr.IsValid())
            {
                hFile = CreateFileA(
                    ansiStr,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    dwCreation,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
            }
        }

        if (hFile != INVALID_HANDLE_VALUE)
            bRegValid = TRUE;
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        // Use SHFolder.DLL to find the proper location for the file if the
        // registry key is not present or is incorrect.

        if (Globals::IsNt)
        {
            // Two steps to get the cache file
            // If SHFolder.DLL is existed then we will put the cache file in CSIDL_LOCAL_APPDATA
            // Or put it on %SystemRoot%\system32 for WINNT

            PSHGETFOLDERPATHW pfnSHGetFolderPathW = NULL;

            // Load SHFolder.DLL
            if (!gFontFileCache.hShFolder)
                gFontFileCache.hShFolder = LoadLibraryW(L"ShFolder.DLL");

            // If SHFolder.DLL is existed then we will put the cache file in CSIDL_LOCAL_APPDATA
            if (gFontFileCache.hShFolder)
            {
                // Get the function SHGetFolderPath
                pfnSHGetFolderPathW = (PSHGETFOLDERPATHW) GetProcAddress(gFontFileCache.hShFolder, "SHGetFolderPathW");

                if (pfnSHGetFolderPathW)
                {
                    // On NT and higher we should use the CSIDL_LOCAL_APPDATA so that this data
                    // does not roam...

                    if ((*pfnSHGetFolderPathW) (NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE,
                                            NULL, 0, wszFilePath) == E_INVALIDARG)
                    {
                        // CSIDL_LOCAL_APPDATA not understood, use CSIDL_APPDATA (IE 5.0 not present)
                        (*pfnSHGetFolderPathW) (NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE,
                                            NULL, 0, wszFilePath);
                    }

                    // Keep a copy of the path for registry update...
                    lstrcpyW(wszPathOnly, wszFilePath);

                    // Append the name of cache file
                    lstrcatW(wszFilePath, FONTFILECACHEPATH_W);

                    hFile = CreateFileW(wszFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
                }
            }

            // Try to put it on %SystemRoot%\system32 for WINNT
            if (hFile == INVALID_HANDLE_VALUE)
            {
                // Get path for system Dircectory
                GetSystemDirectoryW(wszFilePath, MAX_PATH);

                // Keep a copy of the path for registry update...
                lstrcpyW(wszPathOnly, wszFilePath);

                // Append the name of the cache file
                lstrcatW(wszFilePath, FONTFILECACHEPATH_W);

                hFile = CreateFileW(wszFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
            }
        }
        else
        {
            // Windows 9x - non-Unicode

            // Two steps to get the cache file
            // If SHFolder.DLL is existed then we will put the cache file in CSIDL_APPDATA
            // Or put it on %SystemRoot%\system for Win9x

            if (!gFontFileCache.hShFolder)
                gFontFileCache.hShFolder = LoadLibraryA("ShFolder.DLL");

            if (gFontFileCache.hShFolder)
            {
                PSHGETFOLDERPATHA pfnSHGetFolderPathA;

                pfnSHGetFolderPathA = (PSHGETFOLDERPATHA) GetProcAddress(gFontFileCache.hShFolder, "SHGetFolderPathA");

                if (pfnSHGetFolderPathA)
                {
                    (*pfnSHGetFolderPathA) (NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE,
                                                NULL, 0, szFilePath);

                    // Keep a copy of the path for registry update...
                    lstrcpyA(szPathOnly, szFilePath);

                    lstrcatA(szFilePath, FONTFILECACHEPATH_A);

                    hFile = CreateFileA(szFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
                }
            }

            if (hFile == INVALID_HANDLE_VALUE)
            {
                GetSystemDirectoryA(szFilePath, MAX_PATH);

                // Keep a copy of the path for registry update...
                lstrcpyA(szPathOnly, szFilePath);

                lstrcatA(szFilePath, FONTFILECACHEPATH_A);

                hFile = CreateFileA(szFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
            }

            if (hFile != INVALID_HANDLE_VALUE)
            {
                // szFilePath contains the ANSI full path, convert to unicode...
                AnsiToUnicodeStr(szPathOnly, wszPathOnly, sizeof(wszPathOnly)/sizeof(wszPathOnly[0]));
            }
        }
    }

    if (hkey)
    {
        if (hFile != INVALID_HANDLE_VALUE && !bRegValid)
        {
            // wszPathOnly contains the full path to the font cache file
            // so write it out to the registry key...

            _RegSetString(hkey, wchValue, wszPathOnly);
        }

        RegCloseKey(hkey);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if ((dwCreation == OPEN_EXISTING) && !bReAlloc)
        {
            cjFileSize = GetFileSize(hFile, NULL);
        }

        if (cjFileSize != 0xffffffff)
        {
            HANDLE hFileMapping;

            if (Globals::IsNt)
            {
                hFileMapping = CreateFileMappingW(hFile, 0, PAGE_READWRITE, 0, cjFileSize, NULL);
            }
            else
            {
                hFileMapping = CreateFileMappingA(hFile, 0, PAGE_READWRITE, 0, cjFileSize, NULL);
            }

            if (hFileMapping)
            {

                pFile = (PBYTE)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, cjFileSize);

                // It should not be NULL if it is then we must know something wrong

                if (pFile)
                {
                    gFontFileCache.cjFileSize = cjFileSize;
                    gFontFileCache.hFile = hFile;
                    gFontFileCache.hFileMapping = hFileMapping;
                    gFontFileCache.pFile = (FONTFILECACHEHEADER *) pFile;
                    bOK = TRUE;
                }
#if DBG
                else
                {
                    dwError = GetLastError();
                    TERSE(("Error to map a view of a file %x", dwError));
                }
#endif
            }
#if DBG
            else
            {
                dwError = GetLastError();
                TERSE(("Error to map a file %x", dwError));
            }
#endif
        }
    }
#if DBG
    else
    {
        if (!bOpenOnly)
        {
            dwError = GetLastError();
            TERSE(("Error to create a file %x", dwError));
        }
    }
#endif

    if (!bOK)
    {
        vReleaseFontCacheFile();
    }

    return bOK;
}


/*****************************************************************************
 * BOOL bReAllocCacheFile(ULONG ulSize)
 *
 * ReAlloc font cache buffer
 *
 * History
 * 11/16/99 YungT create it
 * Wrote it.
 *****************************************************************************/

BOOL bReAllocCacheFile(ULONG ulSize)
{
    BOOL            bOK = FALSE;
    ULONG           ulFileSizeOrg;
    ULONG           ulSizeExtra;
    ULONG           ulFileSize;

    ulFileSizeOrg = gFontFileCache.pFile->ulFileSize;

    ASSERT(ulSize > gFontFileCache.pFile->ulDataSize);

// Calculate the extra cache we need

    ulSizeExtra = QWORD_ALIGN(ulSize - gFontFileCache.pFile->ulDataSize);

    ulFileSize = ulFileSizeOrg + ulSizeExtra;

    if (gFontFileCache.pFile)
    {
       vReleaseFontCacheFile();
    }

    if (bOpenFontCacheFile(TRUE, ulFileSize, TRUE))
    {

        gFontFileCache.pFile->ulFileSize = ulFileSize;
        gFontFileCache.pFile->ulDataSize = ulSize;

        gFontFileCache.pCacheBuf = (PBYTE) gFontFileCache.pFile + SZ_FONTCACHE_HEADER();

        bOK = TRUE;
    }

    return bOK;
}

/*****************************************************************************
 * BOOL FontFileCacheReadRegistry()
 *
 * Decide we need to open registry or not when load from cache
 *
 * History
 *  07-28-2k Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL FontFileCacheReadRegistry()
{
    return gFontFileCache.bReadFromRegistry;
}

/*****************************************************************************
 * VOID    FontFileCacheFault()
 *
 * Fault reprot for Engine font cache.
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    FontFileCacheFault()
{
    gflFontCacheState = FONT_CACHE_ERROR_MODE;
}

/*****************************************************************************
 * PVOID FontFileCacheAlloc(ULONG ulFastCheckSum, ULONG ulSize)
 *
 * Alloc the cached buffer for font driver
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

PVOID FontFileCacheAlloc(ULONG ulSize)
{

    PVOID pvIfi = NULL;

    {
        ASSERT(gflFontCacheState & FONT_CACHE_CREATE_MODE);

        if (ghsemFontFileCache == NULL)
            return pvIfi;

        if (gflFontCacheState & FONT_CACHE_CREATE_MODE)
        {

            if ( (QWORD_ALIGN(ulSize) < gFontFileCache.pFile->ulDataSize)
                || bReAllocCacheFile(ulSize))
            {
                pvIfi = (PVOID) gFontFileCache.pCacheBuf;

            // Gaurantee the cache pointer is at 8 byte boundary
                gFontFileCache.pFile->ulDataSize = ulSize;
            }
            else
            {
                gflFontCacheState = FONT_CACHE_ERROR_MODE;
            }

        }
    }

    return pvIfi;
}

/*****************************************************************************
 * PVOID FontFileCacheLookUp(ULONG FastCheckSum, ULONG *pcjData)
 *
 * Lookup font cache
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

PVOID FontFileCacheLookUp(ULONG *pcjData)
{
    PBYTE       pCache = NULL;

    *pcjData = 0;

    ASSERT(ghsemFontFileCache);

    if (ghsemFontFileCache == NULL)
       return pCache;


    if (gflFontCacheState & FONT_CACHE_LOOKUP_MODE)
    {
            ASSERT(gFontFileCache.pFile);
            ASSERT(gFontFileCache.pCacheBuf == ((PBYTE) gFontFileCache.pFile +
                                                    SZ_FONTCACHE_HEADER()));
            *pcjData = gFontFileCache.pFile->ulDataSize;
            pCache = gFontFileCache.pCacheBuf;

            gFontFileCache.pCacheBuf += QWORD_ALIGN(*pcjData);
    }


    return (PVOID) pCache;
}

/*****************************************************************************
 * VOID  GetFontFileCacheState()
 *
 * Clean font file cache after load or update the cache file.
 *
 * History
 *  11-12-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

FLONG    GetFontFileCacheState()
{
    return gflFontCacheState;
}

/*****************************************************************************
 * VOID  vCloseFontFileCache()
 *
 * Clean font file cache after load or update the cache file.
 *
 * History
 *  11-12-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID  vCloseFontFileCache()
{

// do paranoid check

    if (!ghsemFontFileCache)
        return;


    if (gflFontCacheState & FONT_CACHE_MASK)
    {

        if (gflFontCacheState & FONT_CACHE_CREATE_MODE)
        {
            // Close the file, we are done recreating it

            if (gFontFileCache.pFile)
            {
                gFontFileCache.pFile->CheckSum = CalcFontFileCacheCheckSum((PVOID) ((PBYTE) gFontFileCache.pFile + 4), (gFontFileCache.cjFileSize - 4));
            }
        }
    }

    if (gFontFileCache.hShFolder)
    {
        FreeLibrary(gFontFileCache.hShFolder);
        gFontFileCache.hShFolder = NULL;
    }

    vReleaseFontCacheFile();

    ReleaseSemaphore(ghsemFontFileCache, 1, NULL);

    CloseHandle(ghsemFontFileCache);

    ghsemFontFileCache = NULL;

    gflFontCacheState = 0;
}

/*****************************************************************************
 * ULONG CalcFontFileCacheCheckSum(PVOID pvFile, ULONG cjFileSize)
 *
 * Helper function for query fonts information from font registry
 *
 * History
 *  11-11-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

ULONG CalcFontFileCacheCheckSum(PVOID pvFile, ULONG cjFileSize)
{
    ULONG sum;
    PULONG pulCur,pulEnd;

    pulCur = (PULONG) pvFile;

    __try
    {
        for (sum = 0, pulEnd = pulCur + cjFileSize / sizeof(ULONG); pulCur < pulEnd; pulCur += 1)
        {
            sum += 256 * sum + *pulCur;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        sum = 0; // oh well, not very unique.
    }

    return ( sum < 2 ) ? 2 : sum;  // 0 is reserved for device fonts
                                      // 1 is reserved for TYPE1 fonts
}

/*****************************************************************************
 * ULONG QueryFontReg(ULARGE_INTEGER *pFontRegLastWriteTime, ULONG *pulFonts)
 *
 * Helper function for query fonts information from font registry
 *
 * History
 *  11-15-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL QueryFontReg(ULARGE_INTEGER *pFontRegLastWriteTime)
{
    BOOL bOK = FALSE;
    ULONG ulFonts;

    HKEY hkey;

    LONG error = (Globals::IsNt) ? RegOpenKeyExW(HKEY_LOCAL_MACHINE, Globals::FontsKeyW, 0, KEY_QUERY_VALUE, &hkey)
                                 : RegOpenKeyExA(HKEY_LOCAL_MACHINE, Globals::FontsKeyA, 0, KEY_QUERY_VALUE, &hkey);

    if (error == ERROR_SUCCESS)
    {
    // There is no difference between A or W APIs at this case.

        error = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &ulFonts, NULL, NULL, NULL,
                                        (FILETIME *)pFontRegLastWriteTime);

        if (error == ERROR_SUCCESS)
        {
            bOK = TRUE;
        }

        RegCloseKey(hkey);
    }

    return bOK;
}


/*****************************************************************************
 * BOOL  bCreateFontFileCache()
 *
 * Initialize font file cache, open the cacheplus.dat file and create hash table
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bCreateFontCacheFile(ULARGE_INTEGER FntRegLWT)
{
    ULONG   ulSize;
    BOOL bOk = FALSE;

    ulSize = SZ_FONTCACHE_HEADER() + FONT_CACHE_EXTRA_SIZE;

    if (gFontFileCache.pFile)
    {
       vReleaseFontCacheFile();
    }


    if(bOpenFontCacheFile(FALSE, ulSize, FALSE))
    {
        gFontFileCache.pFile->ulLanguageID = (ULONG) Globals::LanguageID;
        gFontFileCache.pFile->CheckSum = 0;
        gFontFileCache.pFile->ulMajorVersionNumber = FONTFILECACHE_VER;
        gFontFileCache.pFile->FntRegLWT.QuadPart = FntRegLWT.QuadPart;
        gFontFileCache.pFile->ulFileSize = ulSize;
        gFontFileCache.pFile->ulDataSize = FONT_CACHE_EXTRA_SIZE;
        bOk = TRUE;
    }

    return bOk;
}

#if DBG
/*****************************************************************************
 * BOOL bFontFileCacheDisabled()
 *
 * Tempary routine for performance evaluation
 *
 * History
 *  11-29-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bFontFileCacheDisabled()
{
    return FALSE;
}
#endif


BOOL bScanRegistry()
{
    ASSERT(!Globals::IsNt);

    BOOL bOK = TRUE;
    ULONG index = 0;
    ULONG registrySize = 0;
    ULONG numExpected;

    //  Open the key

    HKEY hkey;


    PBYTE pCached = (PBYTE) gFontFileCache.pFile + SZ_FONTCACHE_HEADER();

    if (*((ULONG *) pCached) != 0xBFBFBFBF)
        return FALSE;

    LONG error = RegOpenKeyExA(HKEY_LOCAL_MACHINE, Globals::FontsKeyA, 0, KEY_QUERY_VALUE, &hkey);

    if (error == ERROR_SUCCESS)
    {

        DWORD   allDataSize = 0;
        error = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &numExpected, NULL, NULL, NULL, NULL);

        if (error != ERROR_SUCCESS)
        {
            RegCloseKey(hkey);
            return FALSE;
        }

        PBYTE  pRegistryData;

        registrySize = *((ULONG *) (pCached + 4)) ;

        pRegistryData = pCached + 8;

        while (index < numExpected)
        {
            DWORD   regType = 0;
            DWORD   labelSize = MAX_PATH;
            DWORD   dataSize = MAX_PATH;
            CHAR    label[MAX_PATH];
            BYTE    data[MAX_PATH];

            error = RegEnumValueA(hkey, index, label, &labelSize, NULL, &regType, data, &dataSize);

            if (error == ERROR_NO_MORE_ITEMS)
            {
               bOK = FALSE;
               break;
            }

            if (allDataSize >= registrySize)
            {
               bOK = FALSE;
               break;
            }


            if (memcmp(pRegistryData, data, dataSize))
            {
               bOK = FALSE;
               break;
            }

            pRegistryData += dataSize;

            allDataSize += dataSize;

            index ++;
        }

        RegCloseKey(hkey);

        if (bOK && (allDataSize == registrySize))
            return TRUE;
    }

    return FALSE;

}
/*****************************************************************************
 * VOID  InitFontFileCache()
 *
 * Initialize font file cache, open the cacheplus.dat file and create hash table
 *
 * History
 *  11-09-99 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID InitFontFileCache()
{
    ULARGE_INTEGER          FntRegLWT = { 0, 0};


    if (gflFontCacheState)
    {
        return;
    }

#if DBG
// Only for performance evaluation.
    if (bFontFileCacheDisabled())
    {
        goto CleanUp;
    }
#endif

// If the named semaphore object existed before the function call,
// the function returns a handle to the existing object and
// GetLastError returns ERROR_ALREADY_EXISTS.

    ghsemFontFileCache = CreateSemaphoreA( NULL, 1, 1, FONTLOADCACHE_NAMEOBJ);


// Something wrong, we can not go with font file cache
    if (ghsemFontFileCache == NULL)
    {
        goto CleanUp;
    }
    else
    {
    // Infinite to wait until the semaphore released
        WaitForSingleObject(ghsemFontFileCache, 0xffffffff);
    }

    gFontFileCache.pFile = NULL;

// now open the TT Fonts key :

    if (!QueryFontReg(&FntRegLWT))
    {
        goto CleanUp;
    }

    if (bOpenFontCacheFile(TRUE, 0, FALSE))
    {

     // File did not change from last time boot.

        if (gFontFileCache.pFile->CheckSum && gFontFileCache.cjFileSize == gFontFileCache.pFile->ulFileSize &&
            gFontFileCache.pFile->CheckSum == CalcFontFileCacheCheckSum((PVOID) ((PBYTE) gFontFileCache.pFile + 4), (gFontFileCache.cjFileSize - 4)) &&
            gFontFileCache.pFile->ulMajorVersionNumber == FONTFILECACHE_VER &&
            gFontFileCache.pFile->ulLanguageID == (ULONG) Globals::LanguageID && // If locale changed, we need to re-create the cache
            gFontFileCache.pFile->FntRegLWT.QuadPart == FntRegLWT.QuadPart && // If registry has been updated we need to re-create the cache file
            (FntRegLWT.QuadPart != 0 || bScanRegistry())
        )
        {
            gflFontCacheState = FONT_CACHE_LOOKUP_MODE;
        }
        else
        {
            if(bCreateFontCacheFile(FntRegLWT))
            {
            // If something will not match, then it means we need to create FNTCACHE again

                    gflFontCacheState = FONT_CACHE_CREATE_MODE;
            }
        }
    }
    else
    {

    // If there is no GDIPFONTCACHE.DAT file
    // Then we need to create it.

        if(bCreateFontCacheFile(FntRegLWT))
        {
            gflFontCacheState = FONT_CACHE_CREATE_MODE;

        }
    }

CleanUp:

// Semaphore initialized

    if (gflFontCacheState & FONT_CACHE_MASK)
    {

    // Initialize the start pointer of current Cache table

        gFontFileCache.pCacheBuf = (PBYTE) gFontFileCache.pFile + SZ_FONTCACHE_HEADER();

        if (FntRegLWT.QuadPart == (ULONGLONG) 0)
            gFontFileCache.bReadFromRegistry = TRUE;
        else
            gFontFileCache.bReadFromRegistry = FALSE;
    }
    else
    {
        gflFontCacheState = 0;

    // Clean up the memory

        if (gFontFileCache.pFile)
        {
            vReleaseFontCacheFile();
        }

        if (ghsemFontFileCache)
        {
            ReleaseSemaphore(ghsemFontFileCache, 1, NULL);
            CloseHandle( ghsemFontFileCache);
            ghsemFontFileCache = NULL;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontlinking.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Abstract:
*
*   Font linking handling
*
* Revision History:
*
*   3/03/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

static const WCHAR FontLinkKeyW[] = 
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink";

static const WCHAR FontSubstitutesKeyW[] =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes";
    
static const WCHAR EudcKeyW[]=L"EUDC\\";
static const char  EudcKeyA[]= "EUDC\\";

static const char  WinIniFontSubstitutionSectionName[] = "FontSubstitutes";

/**************************************************************************\
*
* Function Description:
*   Font Linking constructor.
*   caches the font linking and EUDC from the registry.
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontLink::GpFontLink():
    DefaultFamily          (NULL),
    linkedFonts            (NULL),
    eudcCache              (NULL),
    privateFonts           (NULL),
    FontSubstitutionTable  (NULL),
    substitutionCount      (0)
{
    // Before we cache the font linking and substitution data we need to 
    // make sure we loaded the font table data.

    GpFontTable *fontTable = Globals::FontCollection->GetFontTable();

    if (!fontTable->IsValid())
        return;

    if (!fontTable->IsFontLoaded())
        fontTable->LoadAllFonts();

    if (Globals::IsNt)
    {
        GetFontLinkingDataFromRegistryW();
        GetEudcDataFromTheRegistryW();
        CacheFontSubstitutionDataW();
    }
    else
    {
        // There is no font linking in Win9x. and we don't support the font association 
        // because it is for Ansi support and not Unicode.
        // we support the font substitution under win9x.
        GetEudcDataFromTheRegistryA();
        CacheFontSubstitutionDataA();
    }
}



/**************************************************************************\
*
* Function Description:
*
*   If not already cached, create the default family to be used for font
*   that is not linked by default.
*
*   o  Search for the subtitution font of "MS Shell Dlg"
*   o  Use the font the "MS Shell Dlg" substitution is linked to if exist
*   o  If no "MS Shell Dlg" found, use the final font of the first fontlink
*      entry found if fontlinking is supported in the system.
*   o  If not, lookup hardcoded UI font via system default ansi codepage.
*
* History:
*
*   4/19/2001 Worachai Chaoweeraprasit
*       Created it.
*
\**************************************************************************/

const AssociatedFamilies *GpFontLink::GetDefaultFamily()
{
    if (!DefaultFamily)
    {
        AssociatedFamilies *associated = NULL;
        
        GpFontFamily *family = GetFamilySubstitution(L"MS Shell Dlg");

        if (family)
        {
            associated = GetLinkedFonts(family);
        }
        else
        {
            //  "MS Shell Dlg" not found,
            //  try the first linking font found if one existed

            if (linkedFonts)
            {
                family = linkedFonts->family;
                associated = linkedFonts->associatedFamilies;
            }
            else
            {
                //  No fontlinking supported in this machine. This is likely a Win9x system, 
                //  lookup default UI font via ACP.
                
                typedef struct
                {
                    UINT AnsiCodepage;
                    const WCHAR* FamilyName;
                } AssociatedUIFonts;

                static const UINT MaxEastAsianCodepages = 4;
                static const AssociatedUIFonts uiFonts[MaxEastAsianCodepages] =
                {
                    { 932, L"MS UI Gothic" },   // Japanese
                    { 949, L"Gulim" },          // Korean
                    { 950, L"PMingLiu" },       // Traditional Chinese
                    { 936, L"Simsun" }          // Simplified Chinese
                };

                const WCHAR *familyName = NULL;

                for (UINT i = 0; i < MaxEastAsianCodepages; i++)
                {
                    if (uiFonts[i].AnsiCodepage == Globals::ACP)
                    {
                        familyName = uiFonts[i].FamilyName;
                        break;
                    }
                }

                if (familyName)
                {
                    GpFontTable *fontTable = Globals::FontCollection->GetFontTable();
                    if (fontTable)
                    {
                        family = fontTable->GetFontFamily(familyName);
                    }
                }
            }
        }

        if (family)
        {
            DefaultFamily = &DefaultFamilyBuffer;
            DefaultFamily->family = family;
            DefaultFamily->next = associated;
        }
        else
        {
            //  Nothing we could use,
            //  let's make sure we wouldnt try to cache it again.
            
            DefaultFamily = (AssociatedFamilies *)(-1);
        }
    }

    ASSERT(DefaultFamily != NULL);
    
    return (DefaultFamily && DefaultFamily != (AssociatedFamilies *)(-1)) ?
            DefaultFamily : NULL;
}



/**************************************************************************\
*
* Function Description:
*   Font linking destructor. it should be called when free theGDIPLUS library
*   it free all allocated data.
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontLink::~GpFontLink()
{
    FontLinkingFamily   *tempFontLinkingFamily = linkedFonts;
    AssociatedFamilies  *tempAssocFonts;
    PrivateLoadedFonts  *loadedFontsList;

    while (linkedFonts != NULL)
    {
        while (linkedFonts->associatedFamilies != NULL)
        {
            tempAssocFonts = linkedFonts->associatedFamilies->next;
            GpFree(linkedFonts->associatedFamilies);
            linkedFonts->associatedFamilies = tempAssocFonts;
        }
        
        linkedFonts = linkedFonts->next;
        GpFree(tempFontLinkingFamily);
        tempFontLinkingFamily = linkedFonts;
    }

    if (eudcCache != NULL)
    {
        EUDCMAP *tempEUDCMapList;
        
        while (eudcCache->eudcMapList != NULL)
        {
            tempEUDCMapList = eudcCache->eudcMapList->next;
            GpFree(eudcCache->eudcMapList);
            eudcCache->eudcMapList = tempEUDCMapList;
        }
        GpFree(eudcCache);
    }

    while (privateFonts != NULL)
    {
        delete privateFonts->fontCollection;
        loadedFontsList = privateFonts;
        privateFonts = privateFonts->next;
        GpFree(loadedFontsList);
    }

    if (FontSubstitutionTable)
    {
        GpFree(FontSubstitutionTable);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Read the font linking registry data for the NT 
*
* Arguments:
*
* Returns:
*       nothing
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::GetFontLinkingDataFromRegistryW()
{
    //  Open the key

    HKEY hkey;
    ULONG index = 0;

    WCHAR subKey[MAX_PATH];
    DWORD allocatedDataSize= 2 * MAX_PATH;
    unsigned char *allocatedBuffer = NULL;
    DWORD subKeyLength  ;
    DWORD RegDataLength ;

    LONG error = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE, 
            FontLinkKeyW, 
            0, 
            KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
            &hkey);

    if (error == ERROR_SUCCESS)
    {
        allocatedBuffer = (unsigned char *) GpMalloc(allocatedDataSize);
        if (allocatedBuffer == NULL)
        {
            return;
        }    

        while (error != ERROR_NO_MORE_ITEMS)
        {
            subKeyLength  = MAX_PATH;
            RegDataLength = allocatedDataSize;

            error = RegEnumValueW(
                        hkey, 
                        index, 
                        subKey, 
                        &subKeyLength, 
                        NULL, 
                        NULL, 
                        allocatedBuffer, 
                        &RegDataLength);
                        
            if (error == ERROR_MORE_DATA)
            {
                allocatedDataSize  *= 2;
                GpFree(allocatedBuffer);
                allocatedBuffer = (unsigned char *) GpMalloc(allocatedDataSize);
                if (allocatedBuffer == NULL)
                {
                    return;
                }    
                RegDataLength = allocatedDataSize;
                error = RegEnumValueW(
                            hkey, 
                            index, 
                            subKey, 
                            &subKeyLength, 
                            NULL, 
                            NULL, 
                            allocatedBuffer, 
                            &RegDataLength);
            }
            
            if (error != ERROR_SUCCESS)
            {
                break;
            }    
                
            index ++;

            // record current node. 
            FontLinkingFamily *tempLinkedFonts;
            
            tempLinkedFonts = 
                (FontLinkingFamily *) GpMalloc( sizeof (FontLinkingFamily) );
                
            if (tempLinkedFonts)
            {
                AssociatedFamilies * tailAssociatedFamilies = NULL;
                
                tempLinkedFonts->family = 
                    Globals::FontCollection->GetFontTable()->GetFontFamily(subKey);
                if (tempLinkedFonts->family == NULL)
                {
                    GpFree(tempLinkedFonts);
                    continue;
                }
                tempLinkedFonts->associatedFamilies = NULL;
                tempLinkedFonts->next = NULL;

                DWORD i = 0;
                WCHAR nextFontFile[MAX_PATH];
                WCHAR awcPath[MAX_PATH];
                DWORD charIndex = 0;
                FLONG flDummy;
                UINT  hash ;
                GpFontFile* fontFile;
                AssociatedFamilies *tempAssocFamilies;
                GpFontFamily *family;
                
                BOOL hasFontFileName = FALSE;
                
                RegDataLength /= 2;
                while (charIndex < RegDataLength)
                {
                    if (((WCHAR *)allocatedBuffer)[charIndex] == 0x002C)
                    {
                        i = 0;
                        hasFontFileName = TRUE;
                    }
                    else
                    if (((WCHAR *)allocatedBuffer)[charIndex] == 0x0000)
                    {
                        if (i > 0)
                        {
                            nextFontFile[i] = 0x0;
                            i = 0;
                            if (hasFontFileName)
                            {
                                family = Globals::FontCollection->GetFontTable()->GetFontFamily(nextFontFile);
                                hasFontFileName = FALSE;
                            }
                            else
                            {
                                family = NULL;
                                INT j =0;
                                WCHAR charNumber;

                                if (MakePathName(awcPath, nextFontFile, &flDummy))
                                {
                                    UnicodeStringToUpper(awcPath, awcPath);
                                    
                                    fontFile = Globals::FontCollection->GetFontTable()->GetFontFile(awcPath);
                                    if (fontFile != NULL)
                                    {
                                        family = Globals::FontCollection->GetFontTable()->GetFontFamily(fontFile->GetFamilyName(0));
                                    }
                                    else
                                    {
                                        fontFile = Globals::FontCollection->GetFontTable()->AddFontFile(awcPath);
                                        if (fontFile != NULL)
                                        {
                                            family = Globals::FontCollection->GetFontTable()->GetFontFamily(fontFile->GetFamilyName(0));
                                        }
                                    }
                                }
                            }

                            if (family != NULL)
                            {
                                tempAssocFamilies = (AssociatedFamilies *) GpMalloc( sizeof (AssociatedFamilies) );
                                if (tempAssocFamilies != NULL)
                                {
                                    if (!tailAssociatedFamilies)
                                    {
                                        tempAssocFamilies->family = family;
                                        tempAssocFamilies->next   = tempLinkedFonts->associatedFamilies;
                                        tempLinkedFonts->associatedFamilies = tempAssocFamilies;
                                    }
                                    else
                                    {
                                        tempAssocFamilies->family = family;
                                        tempAssocFamilies->next   = NULL;
                                        tailAssociatedFamilies->next = tempAssocFamilies;
                                    }

                                    tailAssociatedFamilies = tempAssocFamilies;
                                }
                            }
                        }
                    }
                    else  // ! 0 
                    {   
                        nextFontFile[i] = ((WCHAR *)allocatedBuffer)[charIndex];
                        i++;
                    }
                    charIndex++;
                }
                
                tempLinkedFonts->next = linkedFonts;
                linkedFonts = tempLinkedFonts;
            }
        }

        if (allocatedBuffer != NULL)
        {
            GpFree(allocatedBuffer);
        }    
            
        RegCloseKey(hkey);
    }
    return;
}


/**************************************************************************\
*
* Function Description:
*   return the linked list of all fonts linked to family
*   
*
* Arguments:
*   family[in]  the original family
*
* Returns:
*   AssociatedFamilies* the linked list of the linked fonts       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

AssociatedFamilies* GpFontLink::GetLinkedFonts(const GpFontFamily *family)
{
    GpFontFamily *linkedFamily;
    if (family->IsPrivate())
    {
        WCHAR   name[LF_FACESIZE];
        if (family->GetFamilyName(name) != Ok)
        {
            return NULL;
        }

        GpInstalledFontCollection *gpFontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

        if (gpFontCollection == NULL)
        {
            return NULL;
        }
        
        GpFontTable *fontTable = gpFontCollection->GetFontTable();

        if (fontTable == NULL)
        {
            return NULL;
        }

        linkedFamily = fontTable->GetFontFamily(name);
        if (linkedFamily == NULL)
        {
            return NULL;
        }
    }
    else
    {
        linkedFamily = (GpFontFamily *) family;
    }

    FontLinkingFamily *currentFontLink = linkedFonts;
    while (currentFontLink != NULL)
    {
        if (currentFontLink->family == linkedFamily)
        {
            return currentFontLink->associatedFamilies;
        }    
        currentFontLink = currentFontLink->next;
    }
    return NULL;
}


/**************************************************************************\
*
* Function Description:
*   caches EUDC data from the registry
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::GetEudcDataFromTheRegistryW()
{
    eudcCache = (EUDC *) GpMalloc(sizeof(EUDC));
    if (eudcCache == NULL)
    {
        return;
    }    

    eudcCache->defaultFamily    = NULL;
    eudcCache->eudcMapList      = NULL;

    WCHAR tempString[MAX_PATH];
    INT i = 0;
    
    while ( EudcKeyW[i] != 0x0000)
    {
        tempString[i] = EudcKeyW[i];
        i++;
    }

    INT j = 0;
    WCHAR acpString[5];
    UINT acp = GetACP();

    while (j < 5 && acp > 0)
    {
        acpString[j] = (acp % 10) + 0x0030;
        acp /= 10;
        j++;
    }

    j--;
    while (j>=0)
    {
        tempString[i] = acpString[j];
        i++;
        j--;
    }

    tempString[i] = 0x0;

    HKEY hkey = NULL;
    ULONG index = 0;
    LONG error = RegOpenKeyExW(
                    HKEY_CURRENT_USER, 
                    tempString, 
                    0, 
                    KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
                    &hkey);

    WCHAR subKey[MAX_PATH];
    DWORD subKeyLength  ;
    DWORD RegDataLength ;
    GpFontFamily *family;
    GpFontFamily *linkedfamily;
    EUDCMAP      *eudcMap;
    BOOL         isDefaultNotCached = TRUE;

    while (error == ERROR_SUCCESS)
    {
        subKeyLength  = MAX_PATH;
        RegDataLength = MAX_PATH;
        
        error = RegEnumValueW(hkey, 
                    index, 
                    subKey, 
                    &subKeyLength, 
                    NULL, 
                    NULL, 
                    (unsigned char *) tempString, 
                    &RegDataLength);

        if (error == ERROR_SUCCESS)
        {
            if (isDefaultNotCached && UnicodeStringCompareCI(subKey, L"SystemDefaultEUDCFont") == 0)
            {
                isDefaultNotCached = FALSE;
                family = CheckAndLoadTheFile(tempString);
                if (family != NULL)
                {
                    eudcCache->defaultFamily = family;
                }
            }
            else
            {
                family = Globals::FontCollection->GetFontTable()->GetFontFamily(subKey);
                if (family != NULL)
                {
                    linkedfamily = CheckAndLoadTheFile(tempString);
                    if (linkedfamily != NULL)
                    {
                        eudcMap = (EUDCMAP *) GpMalloc(sizeof(EUDCMAP));
                        
                        if (eudcMap != NULL)
                        {
                            eudcMap->inputFamily = family;
                            eudcMap->eudcFamily  = linkedfamily;
                            
                            if (eudcCache->eudcMapList == NULL)
                            {
                                eudcCache->eudcMapList = eudcMap;
                                eudcMap->next = NULL;
                            }
                            else
                            {
                                eudcMap->next = eudcCache->eudcMapList;
                                eudcCache->eudcMapList = eudcMap;
                            }
                        }
                    }
                }
            }
        }

        index++;
    }

    if (hkey != NULL)
    {
        RegCloseKey(hkey);
    }

    return;
}

/**************************************************************************\
*
* Function Description:
*   caches EUDC data from the registry
*   
*
* Arguments:
*
* Returns:
*       
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::GetEudcDataFromTheRegistryA()
{
    eudcCache = (EUDC *) GpMalloc(sizeof(EUDC));
    if (eudcCache == NULL)
    {
        return;
    }    

    eudcCache->defaultFamily    = NULL;
    eudcCache->eudcMapList      = NULL;

    char   tempStringA[MAX_PATH];
    WCHAR  tempString[MAX_PATH];
    INT i = 0;
    
    while ( EudcKeyA[i] != 0x00)
    {
        tempStringA[i] = EudcKeyA[i];
        i++;
    }

    INT j = 0;
    char acpString[5];
    UINT acp = GetACP();

    while (j < 5 && acp > 0)
    {
        acpString[j] = (acp % 10) + 0x30;
        acp /= 10;
        j++;
    }

    j--;
    while (j>=0)
    {
        tempStringA[i] = acpString[j];
        i++;
        j--;
    }

    tempStringA[i] = 0x0;

    HKEY hkey = NULL;
    ULONG index = 0;
    LONG error = RegOpenKeyExA(
                    HKEY_CURRENT_USER, 
                    tempStringA, 
                    0, 
                    KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
                    &hkey);

    WCHAR subKey[MAX_PATH];
    char  subKeyA[MAX_PATH];
    DWORD subKeyLength  ;
    DWORD RegDataLength ;
    GpFontFamily *family;
    GpFontFamily *linkedfamily;
    EUDCMAP      *eudcMap;
    BOOL         isDefaultNotCached = TRUE;

    while (error == ERROR_SUCCESS)
    {
        subKeyLength  = MAX_PATH;
        RegDataLength = MAX_PATH;
        
        error = RegEnumValueA(
                    hkey, 
                    index, 
                    subKeyA, 
                    &subKeyLength, 
                    NULL, 
                    NULL, 
                    (unsigned char *) tempStringA, 
                    &RegDataLength);
        

        if (error == ERROR_SUCCESS)
        {
            if (!AnsiToUnicodeStr(
                    subKeyA, 
                    subKey, 
                    MAX_PATH) || 

                !AnsiToUnicodeStr(
                    tempStringA, 
                    tempString, 
                    MAX_PATH))
                    
                continue;
            
            if (isDefaultNotCached && UnicodeStringCompareCI(subKey, L"SystemDefaultEUDCFont") == 0)
            {
                isDefaultNotCached = FALSE;
                family = CheckAndLoadTheFile(tempString);
                if (family != NULL)
                {
                    eudcCache->defaultFamily = family;
                }
            }
            else
            {
                family = Globals::FontCollection->GetFontTable()->GetFontFamily(subKey);
                if (family != NULL)
                {
                    linkedfamily = CheckAndLoadTheFile(tempString);
                    if (linkedfamily != NULL)
                    {
                        eudcMap = (EUDCMAP *) GpMalloc(sizeof(EUDCMAP));
                        
                        if (eudcMap != NULL)
                        {
                            eudcMap->inputFamily = family;
                            eudcMap->eudcFamily  = linkedfamily;
                            
                            if (eudcCache->eudcMapList == NULL)
                            {
                                eudcCache->eudcMapList = eudcMap;
                                eudcMap->next = NULL;
                            }
                            else
                            {
                                eudcMap->next = eudcCache->eudcMapList;
                                eudcCache->eudcMapList = eudcMap;
                            }
                        }
                    }
                }
            }
        }

        index++;
    }
    
    if (hkey != NULL)
    {
        RegCloseKey(hkey);
    }
    return;
}


/**************************************************************************\
*
* Function Description:
*   check if the font file name is loaded, 
*   and load it if it is not loaded before.
*   
*
* Arguments:
*   fileName[In]    font file name
*
* Returns:
*  GpFontFamily*    the family object for that font
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontFamily* GpFontLink::CheckAndLoadTheFile(WCHAR *fileName)
{
    WCHAR           awcPath[MAX_PATH];
    FLONG           flDummy;
    UINT            hash ;
    GpFontFamily    *family = NULL;
    GpFontFile      *fontFile;
    GpFontTable     *fontTable;
    
    if (MakePathName(awcPath, fileName, &flDummy))
    {
        PrivateLoadedFonts *currentCell = privateFonts;
        while (currentCell != NULL)
        {
            if ( UnicodeStringCompareCI(fileName, currentCell->FileName) == 0 )
            {
                fontTable = currentCell->fontCollection->GetFontTable();
                fontFile  = fontTable->GetFontFile(awcPath);
                if (fontFile)
                {
                    family = fontTable->GetFontFamily(fontFile->GetFamilyName(0));
                };
                break;
            }
            else
            {
                currentCell = currentCell->next;
            }
        }
        
        if (family == NULL)
        {
            GpPrivateFontCollection *privateFontCollection = new GpPrivateFontCollection();
            if (privateFontCollection != NULL)
            {
                if (privateFontCollection->AddFontFile(awcPath) == Ok)
                {
                    fontTable = privateFontCollection->GetFontTable();
                    fontFile = fontTable->GetFontFile(awcPath);
                    if (fontFile != NULL)
                    {
                        family = fontTable->GetFontFamily(fontFile->GetFamilyName(0));
                        PrivateLoadedFonts *tempLoadedFonts = (PrivateLoadedFonts *) GpMalloc(sizeof(PrivateLoadedFonts));
                        if (tempLoadedFonts != NULL)
                        {
                            tempLoadedFonts->fontCollection = privateFontCollection;
                            UnicodeStringCopy(tempLoadedFonts->FileName, fileName);
                            tempLoadedFonts->next = privateFonts;
                            privateFonts = tempLoadedFonts;
                        }
                        else 
                        {
                            delete privateFontCollection;
                        }
                    }
                    else
                    {
                        delete privateFontCollection;
                    }
                }
                else
                {
                    delete privateFontCollection;
                }
            }
        }
    }
    return family;
}

/**************************************************************************\
*
* Function Description:
*   return the default family used as fallback for the EUDC
*   
*
* Arguments:
*
* Returns:
*   GpFontFamily* the family of the EUDC font
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/
GpFontFamily *GpFontLink::GetDefaultEUDCFamily()
{

    if (eudcCache != NULL)
    {
        return eudcCache->defaultFamily;
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*   return the family of the EUDC font mapped from the font family
*   
* Arguments:
*   family[In]  original font family
*
* Returns:
*   GpFontFamily* the family of the EUDC font
*
* History:
*
*   3/3/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/
GpFontFamily *GpFontLink::GetMappedEUDCFamily(const GpFontFamily *family)
{
    EUDCMAP *eudcMaping;
    if (eudcCache != NULL)
    {
        eudcMaping = eudcCache->eudcMapList;
        while (eudcMaping != NULL)
        {
            if (eudcMaping->inputFamily == family)
            {
                return eudcMaping->eudcFamily;
            }
            eudcMaping = eudcMaping->next;
        }
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*   Read and cache the font substitution data from the registry under
*   Windows NT
*   
* Arguments:
*
* Returns:
*
* History:
*
*   4/12/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::CacheFontSubstitutionDataW()
{
    HKEY hkey;

    // open this key for query and enumeration.
    LONG error = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE, 
                    FontSubstitutesKeyW, 
                    0, 
                    KEY_ENUMERATE_SUB_KEYS  | KEY_QUERY_VALUE, 
                    &hkey);

    if (error != ERROR_SUCCESS)
    {
        // failed to find these data in the registry.
        return;
    }

    DWORD numberOfValues = 0;
    error = RegQueryInfoKeyW(
                hkey, NULL, NULL, NULL, NULL, NULL, NULL, &numberOfValues, 
                NULL, NULL, NULL, NULL);

    if (error != ERROR_SUCCESS || numberOfValues==0)
    {
        RegCloseKey(hkey);
        return;
    }


    // Now let's allocate for data.
    // we allocate memory enough to hold all font substitution data but might
    // not use all the allocated memory. I did that to just call the GpMalloc
    // one time.

    FontSubstitutionTable = (FontSubstitutionEntry*)
            GpMalloc(numberOfValues*sizeof(FontSubstitutionEntry));

    if (FontSubstitutionTable == NULL)
    {
        // we can't support font substitution while we out of memory.
        RegCloseKey(hkey);
        return;
    }

    // Time to read the data from the registry.
    ULONG index = 0;
    
    WCHAR subKey[MAX_PATH];
    WCHAR subKeyValue[MAX_PATH];
    DWORD subKeyLength  ;
    DWORD regDataLength ;
    
    while (error == ERROR_SUCCESS)
    {
        subKeyLength  = MAX_PATH;
        regDataLength = MAX_PATH;

        error = RegEnumValueW(
                    hkey, index, subKey, &subKeyLength, NULL, NULL, 
                    (unsigned char *) subKeyValue, &regDataLength);
                        
        if (error != ERROR_SUCCESS)
        {
            break;
        }    
                
        index ++;

        // If the font substitution mentioned the charset, then neglect the charset
        // and keep the family name only.

        for (INT i=regDataLength-1; i>=0; i--)
        {
            if (subKeyValue[i] == 0x002C) // ','
            {
                subKeyValue[i] = 0x0000;
                break;
            }
        }
        
        // we found one. then try to get substitution GpFontFamily
        GpFontFamily *family;

        ASSERT(Globals::FontCollection != NULL);
        
        family = Globals::FontCollection->GetFontTable()->GetFontFamily(subKeyValue);
        if (family != NULL)
        {
            FontSubstitutionTable[substitutionCount].family = family;
            DWORD j;
            for (j=0 ; j<subKeyLength; j++)
            {
                if (subKey[j] == 0x002C) // ','
                {
                    break;
                }
                else
                {
                    FontSubstitutionTable[substitutionCount].familyName[j] = subKey[j];
                }
            }
            FontSubstitutionTable[substitutionCount].familyName[j]    = 0x0000;
            FontSubstitutionTable[substitutionCount].familyNameLength = j;
            substitutionCount++;
        }
    }

    RegCloseKey(hkey);
    return;
}

/**************************************************************************\
*
* Function Description:
*   Read and cache the font substitution data from win.ini under Windows 9x
*   
* Arguments:
*
* Returns:
*
* History:
*
*   6/1/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

void GpFontLink::CacheFontSubstitutionDataA()
{
    DWORD   bufferSize      = 2048; // 2K to allocate for data reading
    DWORD   count           = 2048;
    char    *buffer         = (char*) GpMalloc(bufferSize);
    
    if (!buffer)
    {
        // OutOfMemory
        return;
    }

    // This loop insure we did read all the requested data in the win.ini
    while (bufferSize == count)
    {
        count = GetProfileSectionA(
            WinIniFontSubstitutionSectionName,
            buffer,
            bufferSize);
            
        if (count == 0)
        {
            // something wrong
            GpFree(buffer);
            return;
        }

        if (bufferSize-2 <= count)
        {
            // we didn't read all data, make the buffer bigger
            GpFree(buffer);
            bufferSize += 1024;
            
            if (bufferSize > 32*1024)
            {
                // the upper limit for Windows 95 is 32 KB
                return;
            }
            
            count  = bufferSize; // to continue the loop
            buffer = (char *) GpMalloc(bufferSize);
            if (buffer == NULL)
            {
                // Out of memory
                return;
            }
        }
    }

    // Now we have the filled data buffer and the count. start parsing
    // first we need to know how much memory need to allocate for caching
    // then we fill this cache with useful data.

    DWORD i             = 0;
    INT   entriesCount  = 0;
    
    while (i<count)
    {
        while (i<count && buffer[i] != 0)
        {
            i++;
        }
        
        entriesCount++;
        i++;
    }

    // Now allocate for the font substitution cache according to entriesCount
    FontSubstitutionTable = (FontSubstitutionEntry*)
            GpMalloc(entriesCount*sizeof(FontSubstitutionEntry));

    if (FontSubstitutionTable == NULL)
    {
        // we can't support font substitution while we out of memory.
        GpFree(buffer);
        return;
    }

    ASSERT(Globals::FontCollection != NULL);

    char *fontName;
    char *fontSubstitutionName;
    
    WCHAR               familyName[MAX_PATH];
    GpFontFamily        *family;
    substitutionCount   = 0;
    i                   = 0;

    while (i<count)
    {
        fontName = &buffer[i];
        
        while ( i<count && 
                buffer[i] != '=' && 
                buffer[i] != ',')
        {
            i++;
        }

        if (i>=count-1)
        {
            // something wrong in the data.
            break;
        }

        if (buffer[i] == ',')
        {
            buffer[i] = 0x0;
            i++;
            while (i<count && buffer[i] != '=')
            {
                i++;
            }
            if (i>=count-1)
            {
                // something wrong in the data.
                break;        
            }
        }

        buffer[i] = 0x0;
        i++; 

        fontSubstitutionName = &buffer[i];
        
        while ( i<count && 
                buffer[i] != 0x0 &&
                buffer[i] != ',')
        {
            i++;
        }

        if (i>=count)
        {
            i++;
            // last line may not have a null terminator
            // we sure we have a buffer has space more than the count
            buffer[i] = 0x0;
        }
        
        if (buffer[i] == ',')
        {
            buffer[i] = 0x0;
            i++;
            while (i<count && buffer[i] != 0x0)
            {
                i++;
            }
        }

        i++;
            
        if (!AnsiToUnicodeStr(
                    fontSubstitutionName, 
                    familyName, 
                    MAX_PATH))
        {
            continue;
        }

        family = Globals::FontCollection->GetFontTable()->GetFontFamily(familyName);
        if (family != NULL)
        {
            if (!AnsiToUnicodeStr(
                        fontName, 
                        FontSubstitutionTable[substitutionCount].familyName, 
                        MAX_PATH))
            {
                continue;
            }

            FontSubstitutionTable[substitutionCount].family = family;
            
            INT j=0;
            while (FontSubstitutionTable[substitutionCount].familyName[j] != 0x0000)
            {
                j++;
            }
            
            FontSubstitutionTable[substitutionCount].familyNameLength = j;
            substitutionCount++;
        }
    }

    // clean up the allocated buffer
    GpFree(buffer);
    return;
}

/**************************************************************************\
*
* Function Description:
*   Search for matched substitution font family
*   
* Arguments:
*   familyName [in] name of the font to be substituted 
*
* Returns:
*   font family in success, NULL otherwise
*
* History:
*
*   4/12/2000 Tarek Mahmoud Sayed
*       Created it.
*
\**************************************************************************/

GpFontFamily *GpFontLink::GetFamilySubstitution(const WCHAR* familyName) const
{
    INT nameLength = UnicodeStringLength(familyName);

    for (INT i=0 ; i<substitutionCount ; i++)
    {
        // to speed up the search, we use the string length comparison before
        // comparing the string itself.
        if (nameLength == FontSubstitutionTable[i].familyNameLength &&
            UnicodeStringCompareCI(FontSubstitutionTable[i].familyName, 
                                    familyName) == 0)
        {
            ASSERT(FontSubstitutionTable[i].family != NULL);
            return FontSubstitutionTable[i].family;
        }
    }

    // Not found;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\geometry.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Geometry: Some 2D geometry helper routines.
*
* Created:
*
*   08/26/2000 asecchia
*      Created it.
*
**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*  
* Function Description:
*
*   intersect_circle_line
*
*   Intersection of a circle and a line specified by two points.
*
*   This algorithm is adapted from the geometric line-sphere intersection
*   algorithm by Eric Haines in "An Introduction to Ray Tracing" pp39 edited
*   by Andrew S Glassner.
*
*   Note: This routine only returns positive intersections. 
*
* Arguments:
*
*    const GpPointF &C,      // center
*    const REAL radius2,     // radius * radius  (i.e. squared)
*    const GpPointF &P0,     // line first point (origin)
*    const GpPointF &P1,     // line last point (end)
*    GpPointF &intersection  // return intersection point.
*
*
* Return Value:
*   0 - no intersection
*   1 - intersection.
*
*   08/25/2000 [asecchia]
*       Created it
*
\**************************************************************************/

INT intersect_circle_line(
    IN  const GpPointF &C,      // center
    IN  REAL radius2,           // radius * radius  (i.e. squared)
    IN  const GpPointF &P0,     // line first point (origin)
    IN  const GpPointF &P1,     // line last point (end)
    OUT GpPointF *intersection  // return intersection point.
)
{
    GpPointF vI = P1-P0;    // Vector Line equation  P0 + t*vI
    
    // Normalize vI
    double length = sqrt(dot_product(vI, vI));
    
    if(length < REAL_EPSILON)
    {
        return 0;           // no intersection for degenerate points.
    }
    
    double lv = 1.0/length;
    vI.X *= (REAL)lv;
    vI.Y *= (REAL)lv;
    
    GpPointF vOC = C-P0;    // Vector from line origin to circle center
    
    double L2oc = dot_product(vOC, vOC);
    
    // Distance to closest approach to circle center.
    
    double tca = dot_product(vOC, vI);
    
    // Trivial rejection.
    
    if(tca < REAL_EPSILON && 
       L2oc >= radius2) 
    {
        return 0;           // missed.
    }
    
    // Half chord distance squared.
    
    double t2hc = radius2 - L2oc + tca*tca;
    
    // Trivial rejection. 
    
    if(t2hc < REAL_EPSILON) {
        return 0;          // missed.
    }
    
    t2hc = sqrt(t2hc);
    
    double t;
    
    if(L2oc >= radius2)
    {
        t = tca-t2hc;
        if(t > REAL_EPSILON)
        {
            if(t>=0.0)
            {
                // hit the circle.
                
                *intersection = vI;
                intersection->X *= (REAL)t;
                intersection->Y *= (REAL)t;
                *intersection = *intersection+P0;
                
                return 1;
            }
        }
    }
    
    t = tca+t2hc;
    if(t > REAL_EPSILON)
    {
        if(t>=0.0)
        {
            // hit the circle.
            
            *intersection = vI;
            intersection->X *= (REAL)t;
            intersection->Y *= (REAL)t;
            *intersection = *intersection+P0;
            
            return 1;
        }
    }
    
    return 0;              // missed.
}


/**************************************************************************\
*  
* Function Description:
*
*   intersect_line_yaxis
*
*   Return the intersection of a line specified by p0-p1 along the
*   y axis. Returns FALSE if p0-p1 is parallel to the yaxis.
*
*   Intersection is defined as between p0 and p1 (inclusive). Any
*   intersection point along the line outside of p0 and p1 is ignored.
*
* Arguments:
*
*    IN  const GpPointF &p0,    first point.
*    IN  const GpPointF &p1,    second point.
*    OUT REAL *length           Length along the y axis from zero.
*
* Return Value:
*   0 - no intersection
*   1 - intersection.
*
*   08/25/2000 [asecchia]
*       Created it
*
\**************************************************************************/

BOOL intersect_line_yaxis(
    IN  const GpPointF &p0,
    IN  const GpPointF &p1,
    OUT REAL *length
)
{
    // using vector notation: Line == p0+t(p1-p0)
    
    GpPointF V = p1-p0;
    
    // Check if the line is parallel to the y-axis.
    
    if( REALABS(V.X) < REAL_EPSILON )
    {
        return (FALSE);
    }
    
    // y-axis intersection: p0.X + t V.X = 0
    
    REAL t =  -p0.X/V.X;     
    
    // Check to see that t is between 0 and 1
    
    if( (t < -REAL_EPSILON) ||
        (t-1.0f > REAL_EPSILON) )
    {
        return (FALSE);
    }
        

    // Compute the actual length along the y-axis.
    
    *length = p0.Y + V.Y * t;
    return (TRUE);
}


/**************************************************************************\
*  
* Function Description:
*
*   IntersectLines
*
*   Returns the intersection between two lines specified by their end points.
*
*   The intersection point is returned in intersectionPoint and the 
*   parametric distance along each line is also returned.
*
*   line1Length ranges between [0, 1] for the first line
*   if line1Length is outside of [0, 1] it means that the intersection 
*   extended the line.
*   line2Length ranges between [0, 1] for the second line
*   if r is outside of [0, 1] it means that the intersection extended the line.
*
*   Note: 
*
*   Because we use the vector formulation of the line intersection, there
*   is none of that icky mucking about with vertical line infinities, etc.
*   The only special case we need to consider is the (almost) zero length 
*   line - and that's considered to miss everything.
*
*   Derivation:
*   
*   for the derivation below  
*   p1 == line1End
*   p0 == line1Start
*   r1 == line2End
*   r0 == line2Start
*
*   V = p1-p0
*   W = r1-r0
*   
*   The vector formulation of the two line equations 
*   p0 + tV and r0 + rW
*   
*   The intersection point is derived as follows:
*   Set the two line equations equal to each other
* 
*        p0 + tV = r0 + rW
*    
*   Expand by coordinates to reflect the fact that the vector equation is 
*   actually two simultaneous linear equations.
*
*   <=> (1) p0.x + tV.x = r0.x + rW.x
*       (2) p0.y + tV.y = r0.y + rW.y
*    
*   <=>     p0.x-r0.x      V.x
*       (3) ---------  + t --- = r
*              W.x         W.x
*
*           p0.y-r0.y      V.y
*       (4) ---------  + t --- = r
*              W.y         W.y
*   
*   <=> W.y(p0.x-r0.x) - W.x(p0.y-r0.y) = t(W.x V.y - V.x W.y)   [subst 3, 4]
*   
*   Setting N.x = -W.y and N.y = W.x  (N is normal to W)
*   
*   <=> - N.x(p0.x-r0.x) - N.y(p0.y-r0.y) = t(N.y V.y + N.x V.x)
*   <=> - N.(p0-r0) = t(N.V)                             [rewrite as vectors]
*   <=> t = -N.(p0-r0)/(N.V)
*   
*       r0 + rW = I
*   <=> rW = I - r0
*   <=> r = (I.x - r0.x)/W.x or (I.y - r0.y)/W.y
*   
*
* Arguments:
*
*    IN  const GpPointF &p0,    first line origin
*    IN  const GpPointF &p1,    
*    IN  const GpPointF &r0,    second line origin
*    IN  const GpPointF &r1,    
*    OUT REAL *t                Length along the first line.
*    OUT REAL *r                Length along the second line.
*    OUT GpPointF *intersect    intersection point.
*
* Return Value:
*   FALSE - no intersection
*   TRUE - intersection.
*
*   10/15/2000 [asecchia]
*       Created it
*
\**************************************************************************/

BOOL IntersectLines(
    IN const GpPointF &line1Start,
    IN const GpPointF &line1End,
    IN const GpPointF &line2Start,
    IN const GpPointF &line2End,
    OUT REAL *line1Length,
    OUT REAL *line2Length,
    OUT GpPointF *intersectionPoint
)
{
    GpVector2D V = line1End-line1Start;
    GpVector2D W = line2End-line2Start;
    
    // Fail for zero length lines.
    
    if((REALABS(V.X) < REAL_EPSILON) &&
       (REALABS(V.Y) < REAL_EPSILON) )
    {
        return FALSE;
    }
    
    if((REALABS(W.X) < REAL_EPSILON) &&
       (REALABS(W.Y) < REAL_EPSILON) )
    {
        return FALSE;
    }
    
    // Normal to W
    
    GpVector2D N;
    N.X = -W.Y;
    N.Y = W.X;
    
    REAL denom = N*V;
    
    // No intersection or collinear lines.
    
    if(REALABS(denom) < REAL_EPSILON)
    {
        return FALSE;
    }
    
    GpVector2D I = line1Start-line2Start;
    
    *line1Length = -((N*I)/denom);
    *intersectionPoint = line1Start + (V * (*line1Length));
    
    // At this point we already know that W.X and W.Y are not both zero because
    // of the trivial rejection step at the top.
    // Pick the divisor with the largest magnitude to preserve precision. 
    
    if(REALABS(W.X) > REALABS(W.Y))
    {
        *line2Length = (intersectionPoint->X - line2Start.X)/W.X;
    }
    else
    {
        *line2Length = (intersectionPoint->Y - line2Start.Y)/W.Y;
    }
    
    return TRUE;
}


/**************************************************************************\
*  
* Function Description:
*
*   PointInPolygonAlternate 
*
*   This function computes the point in polygon test for an input polygon
*   using the fill mode alternate method (even-odd rule).
*
*   This algorithm was constructed from an Eric Haines discussion in 
*   'An Introduction to Ray Tracing' (Glassner) p.p. 53-59
*
*   This algorithm translates the polygon so that the requested point is 
*   at the origin and then fires a ray along the horizontal positive x axis
*   and counts the number of lines in the polygon that cross the axis (NC)
*
* Return Value:
*   
*   TRUE iff point is inside the polygon.
*  
* Input Parameters:
*
*   point - the test point.
*   count - the number of points in the polygon.
*   poly  - the polygon points.
*
*   10/11/2000 [asecchia]
*       Created it
*
\**************************************************************************/

BOOL PointInPolygonAlternate(
    GpPointF point,
    INT count, 
    GpPointF *poly
)
{
    UINT crossingCount = 0;
    
    // Sign holder: stores +1 if the point is above the x axis, -1 for below.
    // Points on the x axis are considered to be above.
    
    INT signHolder = ((poly[0].Y-point.Y) >=0) ? 1 : -1;
    INT nextSignHolder;
    
    // a and b are the indices for the current point and the next point.
    
    for(INT a = 0; a < count; a++)
    {
        // Get the next vertex with modulo arithmetic.
        
        INT b = a + 1;
        
        if(b >= count)
        {
            b = 0;
        }
        
        // Compute the next sign holder.
        
        ((poly[b].Y - point.Y) >= 0) ? nextSignHolder = 1: nextSignHolder = -1;
        
        // If the sign holder and next sign holder are different, this may 
        // indicate a crossing of the x axis - determine if it's on the 
        // positive side.
        
        if(signHolder != nextSignHolder)
        {
            // Both X coordinates are positive, we have a +xaxis crossing.
            
            if( ((poly[a].X - point.X) >= 0) &&
                ((poly[b].X - point.X) >= 0))
            {
                crossingCount++;
            }
            else
            {
                // if at least one of the points is positive, we could intersect
                
                if( ((poly[a].X - point.X) >= 0) ||
                    ((poly[b].X - point.X) >= 0))
                {
                    // Compute the line intersection with the xaxis.
                    
                    if( (REALABS(poly[b].Y-poly[a].Y) > REAL_EPSILON ) &&
                        ((poly[a].X - point.X) - 
                             (poly[a].Y - point.Y) * 
                             (poly[b].X - poly[a].X) / 
                             (poly[b].Y - poly[a].Y)    
                        ) > 0)
                    {
                        crossingCount++;
                    }
                }
            }
            signHolder = nextSignHolder;
        }
    }
    return (BOOL)!(crossingCount & 0x1);
}

/**************************************************************************\
*
* Function Description:
*
*   GetFastAngle computes a NON-angle. It is simply a number representing
*   a monotonically increasing ordering on angles starting at 0 at 0 radians
*   and ending at 8 for 2PI radians. It has a NON-linear relation to the angle.
*
*   Starting on the x-axis with the number 0, we increase by one for
*   each octant as we traverse around the origin in an anti-clockwise direction.
*   This is a very useful (fast) way of comparing angles without working out
*   tricky square roots or arctangents.
*
*   The 'angle' is based on the gradient of the input vector.
*
*  \  |  /
*   \3|2/
*   4\|/1
*  -------
*   5/|\8
*   /6|7\
*  /  |  \
*
*
* Arguments:
*
*   [OUT]  angle  - the angle substitute.
*   [IN]   vector - the input vector.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus GetFastAngle(REAL* angle, const GpPointF& vector)
{
    // 0, 0 is an invalid angle.
    
    if(vector.X == 0 && vector.Y == 0)
    {
        *angle = 0.0f;
        return InvalidParameter;
    }

    // Perform a binary octant search. 3 comparisons and 1 divide.
    
    // Are we on the right or the left half of the plane.
    
    if(vector.X >= 0)
    {
        // Right hand half plane.
        // Top or bottom half of the right half plane.
        
        if(vector.Y >= 0)
        {
            // Top right quadrant - check if we're the first or second 
            // octant.
            
            if(vector.X >= vector.Y)
            {
                // First octant - our range is from 0 to 1
                
                *angle = vector.Y/vector.X;
            }
            else
            {
                // Second octant - our range is from 1 to 2
                // reverse the direction to keep the angle increasing
                
                *angle = 2 - vector.X/vector.Y;
            }
        }
        else
        {
            // Bottom right quadrant
            
            if(vector.X >= - vector.Y)
            {
                // eighth (last) octant. y is actually negative, so we're 
                // doing an 8- here. Range 7 to 8
                
                *angle = 8 + vector.Y/vector.X;
            }
            else
            {
                // 7th octant. Our range is 6 to 7
                
                *angle = 6 - vector.X/vector.Y;
            }
        }
    }
    else
    {
        // Left halfplane.
        
        if(vector.Y >= 0)
        {
            // Top left
            
            if(-vector.X >= vector.Y)
            {
                // 4th octant - our range is 3 to 4
                
                *angle = 4 + vector.Y/vector.X;
            }
            else
            {
                // 3rd octant - our range is 2 to 3
                
                *angle = 2 - vector.X/vector.Y;
            }
        }
        else
        {
            // Bottom left
            
            if(-vector.X >= - vector.Y)
            {
                // 5th octant - 4 to 5
                
                *angle = 4 + vector.Y/vector.X;
            }
            else
            {
                // 6th octant - 5 to 6
                
                *angle = 6 - vector.X/vector.Y;
            }
        }
    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontfileplus.cpp ===
// formerly pffobj.cxx

#include "precomp.hpp"

#define FONT_RELATIVE_PATH  1
#define FONT_IN_SYSTEM_DIR  2
#define FONT_IN_FONTS_DIR   4


INT APIENTRY EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return MultiByteToWideChar(CodePage, 0,
                               MultiByteString,BytesInMultiByteString,
                               WideCharString, BytesInWideCharString
                               );
}

INT APIENTRY EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return WideCharToMultiByte(
    CodePage, 0,
    WideCharString,  BytesInWideCharString,
    MultiByteString,BytesInMultiByteString,
    NULL, NULL
    );
}

VOID APIENTRY EngGetCurrentCodePage(
    PUSHORT pOemCodePage,
    PUSHORT pAnsiCodePage
    )
{
    *pAnsiCodePage = (USHORT) GetACP();
    *pOemCodePage = (USHORT) GetOEMCP();
}


VOID APIENTRY EngUnmapFontFileFD(
    ULONG_PTR iFile
    )
{
    FONTFILEVIEW *pffv = (FONTFILEVIEW *)iFile;

    pffv->mapCount--;

    if ((pffv->mapCount == 0) && pffv->pvView)
    {
        if (pffv->pwszPath)
        {
            UnmapViewOfFile(pffv->pvView);
            pffv->pvView = NULL;
        }
    }
}


BOOL APIENTRY EngMapFontFileFD(
    ULONG_PTR  iFile,
    PULONG *ppjBuf,
    ULONG  *pcjBuf
    )
{
    FONTFILEVIEW *pffv = (FONTFILEVIEW *)iFile;
    BOOL bRet = FALSE;

    if (pffv->mapCount)
    {
        pffv->mapCount++;
        if (ppjBuf)
        {
            *ppjBuf = (PULONG)pffv->pvView;
        }
        if (pcjBuf)
        {
            *pcjBuf = pffv->cjView;
        }
        return TRUE;
    }

    if (pffv->pwszPath)
    {
        HANDLE hFile;

        if (Globals::IsNt)
        {
            hFile = CreateFileW(pffv->pwszPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        }
        else  // Windows 9x - non-Unicode
        {
            AnsiStrFromUnicode ansiPath(pffv->pwszPath);

            if (ansiPath.IsValid())
            {
                hFile = CreateFileA(ansiPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
            } else {
                hFile = INVALID_HANDLE_VALUE;
            }
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            ULARGE_INTEGER lastWriteTime;
            
            if (GetFileTime(hFile, NULL, NULL, (FILETIME *) &lastWriteTime.QuadPart) &&
                lastWriteTime.QuadPart == pffv->LastWriteTime.QuadPart)
            {

                *pcjBuf = GetFileSize(hFile, NULL);

                if (*pcjBuf != -1)
                {
                    HANDLE hFileMapping = CreateFileMappingA(hFile, 0, PAGE_READONLY, 0, 0, NULL); // "mappingobject");

                    if (hFileMapping)
                    {
                        *ppjBuf = (PULONG)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
    
                        if (*ppjBuf)
                        {
                            bRet = TRUE;
                            pffv->pvView = *ppjBuf;
                            pffv->cjView = *pcjBuf;
                            pffv->mapCount = 1;
                        }
    
                        CloseHandle(hFileMapping);
                    }
                }
            }
            
            CloseHandle(hFile);
        }
    }

    return bRet;
}


GpFontFile *LoadFontMemImage(
    WCHAR* fontImageName,
    BYTE* fontMemoryImage,
    INT fontImageSize
    )
{
    ULONG cwc = UnicodeStringLength(fontImageName) + 1;
    FONTFILEVIEW *pffv;
    
    if ((pffv = (FONTFILEVIEW *)GpMalloc(sizeof(FONTFILEVIEW))) == NULL)
        return NULL;
    else
    {
        PVOID pvImage;
    
        if ((pvImage = (PVOID)GpMalloc(fontImageSize)) == NULL)
        {
            GpFree(pffv);
            return NULL;
        }
    
        GpMemcpy(pvImage, fontMemoryImage, fontImageSize);
    
        pffv->LastWriteTime.QuadPart = 0;
        pffv->pvView = pvImage;
        pffv->cjView = fontImageSize;
        pffv->mapCount = 1;
        pffv->pwszPath = NULL;
    
        return (LoadFontInternal(fontImageName, cwc, pffv, TRUE));
    }
}


GpFontFile *LoadFontFile(WCHAR *awcPath)
{
    // convert font file name to fully qualified path
    
    ULONG cwc = UnicodeStringLength(awcPath) + 1; // for term. zero

    FONTFILEVIEW *pffv;
    HANDLE       hFile;

    if ((pffv = (FONTFILEVIEW *)GpMalloc(sizeof(FONTFILEVIEW))) == NULL)
    {
        return NULL;
    }

    pffv->LastWriteTime.QuadPart = 0;
    pffv->pvView = NULL;
    pffv->cjView = 0;
    pffv->mapCount = 0;
    pffv->pwszPath = awcPath;

    if (Globals::IsNt)
    {
        hFile = CreateFileW(pffv->pwszPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    }
    else  // Windows 9x - non-Unicode
    {
        AnsiStrFromUnicode ansiPath(pffv->pwszPath);

        if (ansiPath.IsValid())
        {
            hFile = CreateFileA(ansiPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        } else {
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (!(pffv->cjView = GetFileSize(hFile, NULL)))
        {
            goto error;
        }

        if (!GetFileTime(hFile, NULL, NULL, (FILETIME *) &pffv->LastWriteTime.QuadPart))
        {
            goto error;
        }

        CloseHandle(hFile);
        
        return (LoadFontInternal(awcPath, cwc, pffv, FALSE));
    }

error:

    GpFree(pffv);
    
    return NULL;
        
}


GpFontFile *LoadFontInternal(
    WCHAR *         awcPath,
    ULONG           cwc,
    FONTFILEVIEW *  pffv,
    BOOL            bMem
)
{
    GpFontFile *pFontFile = NULL;

    
    ULONG_PTR  hffNew = ttfdSemLoadFontFile(// 1, // #OF FILES
                                       (ULONG_PTR *)&pffv,
                                       (ULONG) Globals::LanguageID //   for english US
                                       );

    if (hffNew)
    {
        ULONG cFonts = ttfdQueryFontFile( hffNew, QFF_NUMFACES,0, NULL);

        if (cFonts && cFonts != FD_ERROR)
        {
            ULONG cjFontFile = offsetof(GpFontFile, aulData) +
                               cFonts * sizeof(GpFontFace)   +
                               cFonts * sizeof(ULONG_PTR)    +
                               cwc * sizeof(WCHAR);

            pFontFile = (GpFontFile *)GpMalloc(cjFontFile);
            if (!pFontFile)
            {
                ttfdSemUnloadFontFile(hffNew);
                if (pffv->pwszPath == NULL)
                    GpFree(pffv->pvView);
                GpFree(pffv);
                return NULL;
            }

            pFontFile->SizeOfThis = cjFontFile;

            // Connect GpFontFile's sharing the same hash bucket
            
            pFontFile->SetNext(NULL);
            pFontFile->SetPrev(NULL);       

            // Point family names to appropriate memory
            
            pFontFile->AllocateNameHolders( 
                (WCHAR **)(
                            (BYTE *)pFontFile               + 
                            offsetof(GpFontFile, aulData)   +
                            cFonts * sizeof(GpFontFace)), cFonts);

            // pwszPathname_ points to the Unicode upper case path
            // name of the associated font file which is stored at the
            // end of the data structure.
            pFontFile->pwszPathname_ =  (WCHAR *)((BYTE *)pFontFile   +
                                        offsetof(GpFontFile, aulData) +
                                        cFonts * sizeof(ULONG_PTR)    +
                                        cFonts * sizeof(GpFontFace));

            UnicodeStringCopy(pFontFile->pwszPathname_, awcPath);
            pFontFile->cwc = cwc;            // total for all strings

            // state
            pFontFile->flState  = 0;        // state (ready to die?)
            pFontFile->cLoaded = 1;
            
            pFontFile->cRealizedFace = 0;        // total number of RFONTs
            pFontFile->bRemoved = FALSE;    // number of referring FontFamily objects

            // RFONT list

            pFontFile->prfaceList = NULL;    // pointer to head of doubly linked list

            // driver information

            pFontFile->hff = hffNew;          // font driver handle to font file, RETURNED by DrvLoadGpFontFile

            // identifies the font driver, it could be a printer driver as well

            // ULONG           ulCheckSum;     // checksum info used for UFI's

            // fonts in this file (and filename slimed in)

            pFontFile->cFonts = cFonts;     // number of fonts (same as chpfe)

            pFontFile->pfv = pffv;          // FILEVIEW structure, passed to DrvLoadFontFile
            
            if (pFontFile->pfv->pwszPath)   // not a memory image
            {
                pFontFile->pfv->pwszPath = pFontFile->pwszPathname_;
            }
  
            // loop over pfe's, init the data:
            GpFontFace *pfe = (GpFontFace *)pFontFile->aulData;
            for (ULONG iFont = 0; iFont < cFonts; iFont++)
            {
                pfe[iFont].pff = pFontFile;   // pointer to physical font file object
                pfe[iFont].iFont = iFont + 1;     // index of the font for IFI or device, 1 based

                pfe[iFont].flPFE = 0;         //!!! REVIEW carefully

                if ((pfe[iFont].pifi = ttfdQueryFont(hffNew, (iFont + 1), &pfe[iFont].idifi)) == NULL )
                {
                    VERBOSE(("Error setting pifi for entry %d.", iFont));

                    ttfdSemUnloadFontFile(hffNew);
                    GpFree(pFontFile);
                    if (pffv->pwszPath == NULL)
                        GpFree(pffv->pvView);
                    GpFree(pffv);
                    return NULL;
                }

                pfe[iFont].NumGlyphs = 0;

                pfe[iFont].NumGlyphs = pfe[iFont].pifi->cig;

                pfe[iFont].cGpFontFamilyRef = 0;

                pfe[iFont].lfCharset = DEFAULT_CHARSET;

                pfe[iFont].SetSymbol(FALSE);

                if (pfe[iFont].InitializeImagerTables() == FALSE)
                {
                    VERBOSE(("Error initializing imager tables for entry %d.", iFont));

                    ttfdSemUnloadFontFile(hffNew);
                    GpFree(pFontFile);
                    if (pffv->pwszPath == NULL)
                        GpFree(pffv->pvView);
                    GpFree(pffv);
                    return NULL;
                }

                //  Set the font family name from the first font entry

                pFontFile->SetFamilyName(iFont, ((WCHAR *)(((BYTE*) pfe[iFont].pifi) + pfe[iFont].pifi->dpwszFamilyName)));
            }
        }
    }

    if (pFontFile == NULL)
    {
        if (pffv->pwszPath == NULL)
            GpFree(pffv->pvView);
        GpFree(pffv);
    }

    return pFontFile;
}


VOID UnloadFontFile(GpFontFile *pFontFile)
{
    return;
}


/******************************Public*Routine******************************\
* bMakePathNameW (PWSZ pwszDst, PWSZ pwszSrc, PWSZ *ppwszFilePart)
*
* Converts the filename pszSrc into a fully qualified pathname pszDst.
* The parameter pszDst must point to a WCHAR buffer at least
* MAX_PATH*sizeof(WCHAR) bytes in size.
*
* An attempt is made find the file first in the new win95 directory
* %windows%\fonts (which also is the first directory in secure font path,
* if one is defined) and then we do the old fashioned windows stuff
* where SearchPathW searches directories in usual order
*
* ppwszFilePart is set to point to the last component of the pathname (i.e.,
* the filename part) in pwszDst.  If this is null it is ignored.
*
* Returns:
*   TRUE if sucessful, FALSE if an error occurs.
*
* History:
*  Mon 02-Oct-1995 -by- Bodin Dresevic [BodinD]
* update: added font path stuff
*  30-Sep-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/
extern "C" int __cdecl 
HackStrncmp( 
    const char *str1, 
    const char *str2, 
    size_t count 
    ) ;


BOOL MakePathName(
    WCHAR  *dst, WCHAR  *src, FLONG  *pfl
)
{
    WCHAR*  pwszF;
    ULONG   path_length = 0;    // essential to initialize


    if (pfl)
        *pfl = 0;

    if (OSInfo::IsNT)
    {

    //    ASSERTGDI(Globals::FontsDir, "gpwcFontsDir not initialized\n");

    // if relative path

        if ( (src[0] != L'\\') && !((src[1] == L':') && (src[2] == L'\\')) )
        {
            if (pfl)
            {
                *pfl |= FONT_RELATIVE_PATH;
            }

        // find out if the font file is in %windir%\fonts

            path_length = SearchPathW(
                                Globals::FontsDirW,
                                src,
                                NULL,
                                MAX_PATH,
                                dst,
                                &pwszF);

    #ifdef DEBUG_PATH
            TERSE(("SPW1: pwszSrc = %ws", src));
            if (path_length)
                TERSE(("SPW1: pwszDst = %ws", dst));
    #endif // DEBUG_PATH
        }

    // Search for file using default windows path and return full pathname.
    // We will only do so if we did not already find the font in the
    // %windir%\fonts directory or if pswzSrc points to the full path
    // in which case search path is ignored

        if (path_length == 0)
        {
            if (path_length = SearchPathW (
                                NULL,
                                src,
                                NULL,
                                MAX_PATH,
                                dst,
                                &pwszF))
            {
            // let us figure it out if the font is in the
            // system directory, or somewhere else along the path:

                if (pfl)
                {
                    ULONG system_count = UnicodeStringLength(Globals::SystemDirW);
                    ULONG dst_count = UnicodeStringLength(dst);

                    if (dst_count > (system_count + 1)) // + 1 for L'\\'
                    {
                        if (UnicodeStringCompareCICount(dst, Globals::SystemDirW, system_count) == 0)
                        {
                            WCHAR* tmp = &dst[system_count];
                            if (*tmp == L'\\')
                            {
                                tmp++; // skip it and see if there are any more of these in pszDst
                                for (;(tmp < &dst[dst_count]) && (*tmp != L'\\'); tmp++)
                                    ;
                                if (*tmp != L'\\')
                                    *pfl |= FONT_IN_SYSTEM_DIR;
                            }
                        }
                    }
                }

            }

    #ifdef DEBUG_PATH
            TERSE(("SPW2: pwszSrc = %ws", src));
            if (path_length)
                TERSE(("SPW2: pwszDst = %ws", dst));
    #endif // DEBUG_PATH
        }
        else
        {
            if (pfl)
            {
                *pfl |= FONT_IN_FONTS_DIR;
            }
        }
    } else {
        /* Windows 9x */
        CHAR*  pwszFA;

        CHAR srcA[MAX_PATH];
        CHAR dstA[MAX_PATH];
        CHAR file_partA[MAX_PATH];

        memset(srcA, 0, sizeof(srcA));
        memset(dstA, 0, sizeof(dstA));
        memset(file_partA, 0, sizeof(file_partA));


        WideCharToMultiByte(CP_ACP, 0, src, UnicodeStringLength(src), srcA, MAX_PATH, 0, 0);

    //    ASSERTGDI(Globals::FontsDir, "gpwcFontsDir not initialized\n");

    // if relative path

        if ( (srcA[0] != '\\') && !((srcA[1] == ':') && (srcA[2] == '\\')) )
        {
            if (pfl)
            {
                *pfl |= FONT_RELATIVE_PATH;
            }

        // find out if the font file is in %windir%\fonts

            path_length = SearchPathA(
                                Globals::FontsDirA,
                                srcA,
                                NULL,
                                MAX_PATH,
                                dstA,
                                (char**)&pwszFA);

        }

    // Search for file using default windows path and return full pathname.
    // We will only do so if we did not already find the font in the
    // %windir%\fonts directory or if pswzSrc points to the full path
    // in which case search path is ignored

        if (path_length == 0)
        {
            if (path_length = SearchPathA (
                                NULL,
                                srcA,
                                NULL,
                                MAX_PATH,
                                dstA,
                                &pwszFA))
            {
            // let us figure it out if the font is in the
            // system directory, or somewhere else along the path:

                if (pfl)
                {
                    ULONG system_count = strlen(Globals::SystemDirA);
                    ULONG dst_count = strlen(dstA);

                    if (dst_count > (system_count + 1)) // + 1 for L'\\'
                    {
                        if (HackStrncmp(dstA, Globals::SystemDirA, system_count) == 0)
                        {
                            CHAR* tmp = &dstA[system_count];
                            if (*tmp == '\\')
                            {
                                tmp++; // skip it and see if there are any more of these in pszDst
                                for (;(tmp < &dstA[dst_count]) && (*tmp != '\\'); tmp++)
                                    ;
                                if (*tmp != '\\')
                                    *pfl |= FONT_IN_SYSTEM_DIR;
                            }
                        }
                    }
                }

            }

    #ifdef DEBUG_PATH
            TERSE(("SPW2: pwszSrc = %ws", src));
            if (path_length)
                TERSE(("SPW2: pwszDst = %ws", dst));
    #endif // DEBUG_PATH
        }
        else
        {
            if (pfl)
            {
                *pfl |= FONT_IN_FONTS_DIR;
            }
        }
        MultiByteToWideChar(CP_ACP, 0, dstA, strlen(dstA), dst, MAX_PATH);
        dst[path_length] = 0; /* null termination */

    }


// If search was successful return TRUE:

    return (path_length != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\fontfile.hpp ===
#ifndef FONT_FILE_DEFINED
#define FONT_FILE_DEFINED


class GpFontTable;

class CacheFaceRealization;

class GpFontFile
{

public:
    GpFontFile() : Next(NULL), Prev(NULL), FamilyName(NULL) {}
    ~GpFontFile() {}

public:
    GpFontFile* GetNext(void) const         
    {
        return Next; 
    }
    
    GpFontFile* GetPrev(void) const         
    { 
        return Prev; 
    }

    void SetNext(GpFontFile* ff)     
    { 
        Next = ff; 
    }

    void SetPrev(GpFontFile* ff)     
    { 
        Prev = ff; 
    }
    
	void AllocateNameHolders(WCHAR** hFamilyName, int numFonts) 
	{
		FamilyName = hFamilyName;
        //  Initialize each name to NULL
        for (INT n = 0; n < numFonts; n++)
        {
            FamilyName[n] = NULL;
        }
	}
	
    const WCHAR*    GetFamilyName(int i) const         
    { 
        return FamilyName[i]; 
    } 

    void            SetFamilyName(int i, WCHAR* name)   
    { 
        FamilyName[i] = name; 
    } 

    const WCHAR*    GetPathName(void) const      
    { 
        return pwszPathname_; 
    } 

    const UINT      GetPathNameSize(void) const  
    { 
        return cwc; 
    }
    
    void SetPathName(WCHAR* name)      
    { 
        pwszPathname_ = name; 
    } 

    BOOL operator== (GpFontFile const& ff) const
    {
        if (this == &ff)
            return TRUE;

        return (wcscmp(pwszPathname_, ff.pwszPathname_) == 0);
    }
    
    ULONG       GetNumEntries(void) const       
    { 
        return cFonts; 
    }
    
    GpFontFace* GetFontFace(ULONG iFont)        
    { 
        return( &(((GpFontFace*)(&aulData))[iFont]) ); 
    }

    FONTFILEVIEW * GetFileView() const
    {
        return pfv;
    }
    
//  Data members
public:
    ULONG           SizeOfThis;

private:

    // Connects GpFontFile's sharing the same hash bucket
    
    GpFontFile*     Next;
    GpFontFile*     Prev;

    WCHAR**         FamilyName;     //  Array of family name in this font file

public:

// pwszPathname_ points to the Unicode upper case path
// name of the associated font file which is stored at the
// end of the data structure.

    WCHAR *         pwszPathname_;
    ULONG           cwc;            // total for all strings

// state

    FLONG           flState;        // state (ready to die?)
    ULONG           cLoaded;        // load count
    ULONG           cRealizedFace;         // total number of RealizedFaces
    ULONG           bRemoved;       // TRUE if the font file has been removed
                                    // (RemoveFontFile() )

// CacheFaceRealization list

    CacheFaceRealization    *prfaceList;      // pointer to head of doubly linked list

// driver information

    ULONG_PTR       hff;            // font driver handle to font file, RETURNED by DrvLoadGpFontFile

// fonts in this file (and filename slimed in)

    ULONG           cFonts;         // number of fonts (same as chpfe)

    FONTFILEVIEW    *pfv;           // address of FILEVIEW structure, passed to DrvLoadFontFile

    ULONG_PTR       aulData[1];     // data buffer for HFontEntry and filename
};



GpFontFile *LoadFontInternal(WCHAR *pwszName, ULONG cwc, FONTFILEVIEW *pffv, BOOL bMem);
GpFontFile *LoadFontFile(WCHAR * pwszFontFileName);
GpFontFile *LoadFontMemImage(WCHAR* fontImageName, BYTE* fontMemoryImage, INT fontImageSize);
VOID   UnloadFontFile(GpFontFile *pFontFile);

BOOL   MakePathName(WCHAR  *dst, WCHAR  *src, FLONG  *pfl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\gdipfontstubs.cpp ===
